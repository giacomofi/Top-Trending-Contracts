['/**\n', ' *Submitted for verification at Ether5.net on 2020-09-07\n', '*/\n', '\n', '/**\n', '  *\n', '  * Designed by Team Brave\n', '  * Developed by Advanced Smart Contract Concepts                                                                                                                                                       \n', '  * Tested and verified by Drexyl, X99, and blockgh0st \n', '  * Translated into 10+ languages by Josh Barton\n', '  * \n', '  * A big thank you to the entire development team for making this possible!\n', '  * \n', '  * Divvy Club is a simple and straightforward crowsdharing smart contract designed around:\n', '  * 1. Daily 5% divident payouts to each participant\n', '  * 2. Direct referral comissions for every referral\n', '  * 3. International participation and platform accessibility\n', '  * 4. FUll transparency and zero dev interaction once launched\n', '  *\n', '  *\n', '  * Enjoy!\n', '  *\n', '  * \n', '  * Website: www.ether5.net\n', '*** Official Telegram Channel: https://t.me/Ether5_Daily\n', '*** Made with YC by Team Brave\n', '  *\n', '  */\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n', '     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n', '     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '}\n', '\n', 'library DataStructs {\n', '\n', '        struct DailyRound {\n', '            uint256 startTime;\n', '            uint256 endTime;\n', '            bool ended; //has daily round ended\n', '            uint256 pool; //amount in the pool;\n', '        }\n', '\n', '        struct Player {\n', '            uint256 totalInvestment;\n', '            uint256 totalVolumeEth;\n', '            uint256 eventVariable;\n', '            uint256 directReferralIncome;\n', '            uint256 roiReferralIncome;\n', '            uint256 currentInvestedAmount;\n', '            uint256 dailyIncome;            \n', '            uint256 lastSettledTime;\n', '            uint256 incomeLimitLeft;\n', '            uint256 investorPoolIncome;\n', '            uint256 sponsorPoolIncome;\n', '            uint256 superIncome;\n', '            uint256 referralCount;\n', '            address referrer;\n', '        }\n', '\n', '        struct PlayerDailyRounds {\n', '            uint256 selfInvestment; \n', '            uint256 ethVolume; \n', '        }\n', '}\n', '\n', 'contract Ether5 {\n', '    using SafeMath for *;\n', '\n', '    address public  owner;\n', '    address public  roundStarter;\n', '    uint256 private houseFee = 18;\n', '    uint256 private poolTime = 24 hours;\n', '    uint256 private payoutPeriod = 24 hours;\n', '    uint256 private dailyWinPool = 10;\n', '    uint256 private incomeTimes  = 30;\n', '    uint256 private incomeDivide = 10;\n', '    uint256 public  roundID;\n', '    uint256 public  r1 = 0;\n', '    uint256 public  r2 = 0;\n', '    uint256 public  r3 = 0;\n', '    uint256[3] private awardPercentage;\n', '\n', '    mapping (uint => uint) public CYCLE_PRICE;\n', '    mapping (address => bool) public playerExist;\n', '    mapping (uint256 => DataStructs.DailyRound) public round;\n', '    mapping (address => DataStructs.Player) public player;\n', '    mapping (address => mapping (uint256 => DataStructs.PlayerDailyRounds)) public plyrRnds_; \n', '\n', '    /****************************  EVENTS   *****************************************/\n', '\n', '    event registerUserEvent(address indexed _playerAddress, address indexed _referrer);\n', '    event investmentEvent(address indexed _playerAddress, uint256 indexed _amount);\n', '    event referralCommissionEvent(address indexed _playerAddress, address indexed _referrer, uint256 indexed amount, uint256 timeStamp);\n', '    event dailyPayoutEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\n', '    event withdrawEvent(address indexed _playerAddress, uint256 indexed amount, uint256 indexed timeStamp);\n', '    event ownershipTransferred(address indexed owner, address indexed newOwner);\n', '\n', '    constructor (address _roundStarter) public {\n', '         owner = msg.sender;\n', '         roundStarter = _roundStarter;\n', '         roundID = 1;\n', '         round[1].startTime = now;\n', '         round[1].endTime = now + poolTime;\n', '         awardPercentage[0] = 50;\n', '         awardPercentage[1] = 30;\n', '         awardPercentage[2] = 20;\n', '    }\n', '    \n', '    /****************************  MODIFIERS    *****************************************/\n', '    \n', '    \n', '    /**\n', '     * @dev sets boundaries for incoming tx\n', '     */\n', '    modifier isWithinLimits(uint256 _eth) {\n', '        require(_eth >= 100000000000000000, "Minimum contribution amount is 0.1 ETH");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev sets permissible values for incoming tx\n', '     */\n', '    modifier isallowedValue(uint256 _eth) {\n', '        require(_eth % 100000000000000000 == 0, "Amount should be in multiple of 0.1 ETH please");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev allows only the user to run the function\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "only Owner");\n', '        _;\n', '    }\n', '\n', '\n', '    /****************************  CORE LOGIC    *****************************************/\n', '\n', '\n', '    //if someone accidently sends eth to contract address\n', '    function () external payable {\n', '        playGame(address(0x0));\n', '    }\n', '\n', '\n', '\n', '   \n', '    function playGame(address _referrer) \n', '    public\n', '    isWithinLimits(msg.value)\n', '    isallowedValue(msg.value)\n', '    payable {\n', '\n', '        uint256 amount = msg.value;\n', '        if (playerExist[msg.sender] == false) { \n', '\n', '            player[msg.sender].lastSettledTime = now;\n', '            player[msg.sender].currentInvestedAmount = amount;\n', '            player[msg.sender].incomeLimitLeft = amount.mul(incomeTimes).div(incomeDivide);\n', '            player[msg.sender].totalInvestment = amount;\n', '            player[msg.sender].eventVariable = 100 ether;\n', '            playerExist[msg.sender] = true;\n', '            \n', "            //update player's investment in current round\n", '            plyrRnds_[msg.sender][roundID].selfInvestment = plyrRnds_[msg.sender][roundID].selfInvestment.add(amount);\n', '\n', '            if(\n', '                // is this a referred purchase?\n', '                _referrer != address(0x0) && \n', '                \n', '                //self referrer not allowed\n', '                _referrer != msg.sender &&\n', '                \n', '                //referrer exists?\n', '                playerExist[_referrer] == true\n', '              ) {\n', '                    player[msg.sender].referrer = _referrer;\n', '                    player[_referrer].referralCount = player[_referrer].referralCount.add(1);\n', '                    player[_referrer].totalVolumeEth = player[_referrer].totalVolumeEth.add(amount);\n', '                    plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\n', '                    \n', '                    referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\n', '                }\n', '              else {\n', '                  r1 = r1.add(amount.mul(20).div(100));\n', '                  _referrer = address(0x0);\n', '                }\n', '              emit registerUserEvent(msg.sender, _referrer);\n', '            }\n', '            \n', '            //if the player has already joined earlier\n', '            else {\n', '                \n', '                require(player[msg.sender].incomeLimitLeft == 0, "Oops your limit is still remaining");\n', '                require(amount >= player[msg.sender].currentInvestedAmount, "Cannot invest lesser amount");\n', '                \n', '                    \n', '                player[msg.sender].lastSettledTime = now;\n', '                player[msg.sender].currentInvestedAmount = amount;\n', '                player[msg.sender].incomeLimitLeft = amount.mul(incomeTimes).div(incomeDivide);\n', '                player[msg.sender].totalInvestment = player[msg.sender].totalInvestment.add(amount);\n', '                    \n', "                //update player's investment in current round\n", '                plyrRnds_[msg.sender][roundID].selfInvestment = plyrRnds_[msg.sender][roundID].selfInvestment.add(amount);\n', '\n', '                if(\n', '                    // is this a referred purchase?\n', '                    _referrer != address(0x0) && \n', '                    // self referrer not allowed\n', '                    _referrer != msg.sender &&\n', '                    //does the referrer exist?\n', '                    playerExist[_referrer] == true\n', '                    )\n', '                    {\n', "                        //if the user has already been referred by someone previously, can't be referred by someone else\n", '                        if(player[msg.sender].referrer != address(0x0))\n', '                            _referrer = player[msg.sender].referrer;\n', '                        else {\n', '                            player[msg.sender].referrer = _referrer;\n', '                            player[_referrer].referralCount = player[_referrer].referralCount.add(1);\n', '                       }\n', '                            \n', '                        player[_referrer].totalVolumeEth = player[_referrer].totalVolumeEth.add(amount);\n', '                        plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\n', '\n', '                        //assign the referral commission to all.\n', '                        referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\n', '                    }\n', '                    //might be possible that the referrer is 0x0 but previously someone has referred the user                    \n', '                    else if(\n', '                        //0x0 coming from the UI\n', '                        _referrer == address(0x0) &&\n', '                        //check if the someone has previously referred the user\n', '                        player[msg.sender].referrer != address(0x0)\n', '                        ) {\n', '                            _referrer = player[msg.sender].referrer;                             \n', '                            plyrRnds_[_referrer][roundID].ethVolume = plyrRnds_[_referrer][roundID].ethVolume.add(amount);\n', '                            player[_referrer].totalVolumeEth = player[_referrer].totalVolumeEth.add(amount);\n', '\n', '                            //assign the referral commission to all.\n', '                            referralBonusTransferDirect(msg.sender, amount.mul(20).div(100));\n', '                          }\n', '                    else {\n', '                          //no referrer, neither was previously used, nor has used now.\n', '                          r1 = r1.add(amount.mul(20).div(100));\n', '                        }\n', '            }\n', '            \n', '            round[roundID].pool = round[roundID].pool.add(amount.mul(dailyWinPool).div(100));\n', '            player[owner].dailyIncome = player[owner].dailyIncome.add(amount.mul(houseFee).div(100));\n', '            r3 = r3.add(amount.mul(5).div(100));\n', '            emit investmentEvent (msg.sender, amount);\n', '            \n', '    }\n', '    \n', '    function referralBonusTransferDirect(address _playerAddress, uint256 amount)\n', '    private\n', '    {\n', '        address _nextReferrer = player[_playerAddress].referrer;\n', '        uint256 _amountLeft = amount.mul(60).div(100);\n', '        uint i;\n', '\n', '        for(i=0; i < 10; i++) {\n', '            \n', '            if (_nextReferrer != address(0x0)) {\n', '                //referral commission to level 1\n', '                if(i == 0) {\n', '                    if (player[_nextReferrer].incomeLimitLeft >= amount.div(2)) {\n', '                        player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(2));\n', '                        player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(amount.div(2));\n', '                        //This event will be used to get the total referral commission of a person, no need for extra variable\n', '                        emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(2), now);                        \n', '                    }\n', '                    else if(player[_nextReferrer].incomeLimitLeft !=0) {\n', '                        player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\n', '                        r1 = r1.add(amount.div(2).sub(player[_nextReferrer].incomeLimitLeft));\n', '                        emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\n', '                        player[_nextReferrer].incomeLimitLeft = 0;\n', '                    }\n', '                    else  {\n', '                        r1 = r1.add(amount.div(2)); \n', '                    }\n', '                    _amountLeft = _amountLeft.sub(amount.div(2));\n', '                }\n', '                \n', '                else if(i == 1 ) {\n', '                    if(player[_nextReferrer].referralCount >= 2) {\n', '                        if (player[_nextReferrer].incomeLimitLeft >= amount.div(10)) {\n', '                            player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(10));\n', '                            player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(amount.div(10));\n', '                            \n', '                            emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(10), now);                        \n', '                        }\n', '                        else if(player[_nextReferrer].incomeLimitLeft !=0) {\n', '                            player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\n', '                            r1 = r1.add(amount.div(10).sub(player[_nextReferrer].incomeLimitLeft));\n', '                            emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\n', '                            player[_nextReferrer].incomeLimitLeft = 0;\n', '                        }\n', '                        else  {\n', '                            r1 = r1.add(amount.div(10)); \n', '                        }\n', '                    }\n', '                    else{\n', '                        r1 = r1.add(amount.div(10)); \n', '                    }\n', '                    _amountLeft = _amountLeft.sub(amount.div(10));\n', '                }\n', '                //referral commission from level 3-10\n', '                else {\n', '                    if(player[_nextReferrer].referralCount >= i+1) {\n', '                        if (player[_nextReferrer].incomeLimitLeft >= amount.div(20)) {\n', '                            player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(20));\n', '                            player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(amount.div(20));\n', '                            \n', '                            emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(20), now);\n', '                    \n', '                        }\n', '                        else if(player[_nextReferrer].incomeLimitLeft !=0) {\n', '                            player[_nextReferrer].directReferralIncome = player[_nextReferrer].directReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\n', '                            r1 = r1.add(amount.div(20).sub(player[_nextReferrer].incomeLimitLeft));\n', '                            emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\n', '                            player[_nextReferrer].incomeLimitLeft = 0;                    \n', '                        }\n', '                        else  {\n', '                            r1 = r1.add(amount.div(20)); \n', '                        }\n', '                    }\n', '                    else {\n', '                        r1 = r1.add(amount.div(20)); \n', '                    }\n', '                }\n', '            }\n', '            else {\n', '                r1 = r1.add((uint(10).sub(i)).mul(amount.div(20)).add(_amountLeft)); \n', '                break;\n', '            }\n', '            _nextReferrer = player[_nextReferrer].referrer;\n', '        }\n', '    }\n', '    \n', '\n', '    \n', '    function referralBonusTransferDailyROI(address _playerAddress, uint256 amount)\n', '    private\n', '    {\n', '        address _nextReferrer = player[_playerAddress].referrer;\n', '        uint256 _amountLeft = amount.div(2);\n', '        uint i;\n', '\n', '        for(i=0; i < 20; i++) {\n', '            \n', '            if (_nextReferrer != address(0x0)) {\n', '                if(i == 0) {\n', '                    if (player[_nextReferrer].incomeLimitLeft >= amount.div(2)) {\n', '                        player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(2));\n', '                        player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(amount.div(2));\n', '                        \n', '                        emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(2), now);\n', '                        \n', '                    } else if(player[_nextReferrer].incomeLimitLeft !=0) {\n', '                        player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\n', '                        r2 = r2.add(amount.div(2).sub(player[_nextReferrer].incomeLimitLeft));\n', '                        emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\n', '                        player[_nextReferrer].incomeLimitLeft = 0;\n', '                        \n', '                    }\n', '                    else {\n', '                        r2 = r2.add(amount.div(2)); \n', '                    }\n', '                    _amountLeft = _amountLeft.sub(amount.div(2));                \n', '                }\n', '                else { // for users 2-20\n', '                    if(player[_nextReferrer].referralCount >= i+1) {\n', '                        if (player[_nextReferrer].incomeLimitLeft >= amount.div(20)) {\n', '                            player[_nextReferrer].incomeLimitLeft = player[_nextReferrer].incomeLimitLeft.sub(amount.div(20));\n', '                            player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(amount.div(20));\n', '                            \n', '                            emit referralCommissionEvent(_playerAddress, _nextReferrer, amount.div(20), now);\n', '                        \n', '                        }else if(player[_nextReferrer].incomeLimitLeft !=0) {\n', '                            player[_nextReferrer].roiReferralIncome = player[_nextReferrer].roiReferralIncome.add(player[_nextReferrer].incomeLimitLeft);\n', '                            r2 = r2.add(amount.div(20).sub(player[_nextReferrer].incomeLimitLeft));\n', '                            emit referralCommissionEvent(_playerAddress, _nextReferrer, player[_nextReferrer].incomeLimitLeft, now);\n', '                            player[_nextReferrer].incomeLimitLeft = 0;                        \n', '                        }\n', '                        else {\n', '                            r2 = r2.add(amount.div(20)); \n', '                        }\n', '                    }\n', '                    else {\n', '                         r2 = r2.add(amount.div(20)); //make a note of the missed commission;\n', '                    }\n', '                }\n', '            }   \n', '            else {\n', '                if(i==0){\n', '                    r2 = r2.add(amount.mul(145).div(100));\n', '                    break;\n', '                }\n', '                else {\n', '                    r2 = r2.add((uint(20).sub(i)).mul(amount.div(20)).add(_amountLeft)); \n', '                    break;\n', '                }\n', '                \n', '            }\n', '            _nextReferrer = player[_nextReferrer].referrer;\n', '        }\n', '    }\n', '    \n', '\n', '    //method to settle and withdraw the daily ROI\n', '    function settleIncome(address _playerAddress)\n', '    private {\n', '        \n', '            \n', '        uint256 remainingTimeForPayout;\n', '        uint256 currInvestedAmount;\n', '            \n', '        if(now > player[_playerAddress].lastSettledTime + payoutPeriod) {\n', '            \n', '            //calculate how much time has passed since last settlement\n', '            uint256 extraTime = now.sub(player[_playerAddress].lastSettledTime);\n', '            uint256 _dailyIncome;\n', '            //calculate how many number of days, payout is remaining\n', '            remainingTimeForPayout = (extraTime.sub((extraTime % payoutPeriod))).div(payoutPeriod);\n', '            \n', '            currInvestedAmount = player[_playerAddress].currentInvestedAmount;\n', '            //*YC*calculate 5%=div(20) of his invested amount, 2%=div(50), 10%=div(10)\n', '            _dailyIncome = currInvestedAmount.div(20);\n', '            //check his income limit remaining\n', '            if (player[_playerAddress].incomeLimitLeft >= _dailyIncome.mul(remainingTimeForPayout)) {\n', '                player[_playerAddress].incomeLimitLeft = player[_playerAddress].incomeLimitLeft.sub(_dailyIncome.mul(remainingTimeForPayout));\n', '                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(_dailyIncome.mul(remainingTimeForPayout));\n', '                player[_playerAddress].lastSettledTime = player[_playerAddress].lastSettledTime.add((extraTime.sub((extraTime % payoutPeriod))));\n', '                emit dailyPayoutEvent( _playerAddress, _dailyIncome.mul(remainingTimeForPayout), now);\n', '                referralBonusTransferDailyROI(_playerAddress, _dailyIncome.mul(remainingTimeForPayout));\n', '            }\n', '            //if person income limit lesser than the daily ROI\n', '            else if(player[_playerAddress].incomeLimitLeft !=0) {\n', '                uint256 temp;\n', '                temp = player[_playerAddress].incomeLimitLeft;                 \n', '                player[_playerAddress].incomeLimitLeft = 0;\n', '                player[_playerAddress].dailyIncome = player[_playerAddress].dailyIncome.add(temp);\n', '                player[_playerAddress].lastSettledTime = now;\n', '                emit dailyPayoutEvent( _playerAddress, temp, now);\n', '                referralBonusTransferDailyROI(_playerAddress, temp);\n', '            }         \n', '        }\n', '        \n', '    }\n', '    \n', '\n', '    //function to allow users to withdraw their earnings\n', '    function withdrawIncome() \n', '    public {\n', '        \n', '        address _playerAddress = msg.sender;\n', '        \n', '        //settle the daily dividend\n', '        settleIncome(_playerAddress);\n', '        \n', '        uint256 _earnings =\n', '                    player[_playerAddress].dailyIncome +\n', '                    player[_playerAddress].directReferralIncome +\n', '                    player[_playerAddress].roiReferralIncome;// +\n', '//                  player[_playerAddress].investorPoolIncome +\n', '//                  player[_playerAddress].sponsorPoolIncome +\n', '//                  player[_playerAddress].superIncome;\n', '\n', '        //can only withdraw if they have some earnings.         \n', '        if(_earnings > 0) {\n', '            require(address(this).balance >= _earnings, "Contract doesn\'t have sufficient amount to give you");\n', '\n', '            player[_playerAddress].dailyIncome = 0;\n', '            player[_playerAddress].directReferralIncome = 0;\n', '            player[_playerAddress].roiReferralIncome = 0;\n', '            player[_playerAddress].investorPoolIncome = 0;\n', '            player[_playerAddress].sponsorPoolIncome = 0;\n', '            player[_playerAddress].superIncome = 0;\n', '            \n', '            address(uint160(_playerAddress)).transfer(_earnings);\n', '            emit withdrawEvent(_playerAddress, _earnings, now);\n', '        }\n', '    }\n', '    \n', '    \n', '    //To start the new round for daily pool\n', '    function startNewRound()\n', '    public\n', '     {\n', '        require(msg.sender == roundStarter,"Oops you can\'t start the next round");\n', '    \n', '        uint256 _roundID = roundID;\n', '       \n', '        uint256 _poolAmount = round[roundID].pool;\n', '        if (now > round[_roundID].endTime && round[_roundID].ended == false) {\n', '            \n', '            round[_roundID].ended = true;\n', '            round[_roundID].pool = _poolAmount;\n', '\n', '                _roundID++;\n', '                roundID++;\n', '                round[_roundID].startTime = now;\n', '                round[_roundID].endTime = now.add(poolTime);\n', '        }\n', '    }\n', '\n', '\n', '    //function to fetch the remaining time for the next daily ROI payout\n', '    function getPlayerInfo(address _playerAddress) \n', '    public \n', '    view\n', '    returns(uint256) {\n', '            \n', '            uint256 remainingTimeForPayout;\n', '            if(playerExist[_playerAddress] == true) {\n', '            \n', '                if(player[_playerAddress].lastSettledTime + payoutPeriod >= now) {\n', '                    remainingTimeForPayout = (player[_playerAddress].lastSettledTime + payoutPeriod).sub(now);\n', '                }\n', '                else {\n', '                    uint256 temp = now.sub(player[_playerAddress].lastSettledTime);\n', '                    remainingTimeForPayout = payoutPeriod.sub((temp % payoutPeriod));\n', '                }\n', '                return remainingTimeForPayout;\n', '            }\n', '    }\n', '\n', '\n', '    function withdrawFees(uint256 _amount, address _receiver, uint256 _numberUI) public onlyOwner {\n', '\n', '        if(_numberUI == 1 && r1 >= _amount) {\n', '            if(_amount > 0) {\n', '                if(address(this).balance >= _amount) {\n', '                    r1 = r1.sub(_amount);\n', '                    address(uint160(_receiver)).transfer(_amount);\n', '                }\n', '            }\n', '        }\n', '        else if(_numberUI == 2 && r2 >= _amount) {\n', '            if(_amount > 0) {\n', '                if(address(this).balance >= _amount) {\n', '                    r2 = r2.sub(_amount);\n', '                    address(uint160(_receiver)).transfer(_amount);\n', '                }\n', '            }\n', '        }\n', '        else if(_numberUI == 3) {\n', '            player[_receiver].superIncome = player[_receiver].superIncome.add(_amount);\n', '            r3 = r3.sub(_amount);\n', '//            emit superBonusAwardEvent(_receiver, _amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) external onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '     /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) private {\n', '        require(newOwner != address(0), "New owner cannot be the zero address");\n', '        emit ownershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}']