['// File: contracts/sakeswap/interfaces/ISakeSwapRouter.sol\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', 'pragma solidity >=0.6.2;\n', '\n', 'interface ISakeSwapRouter {\n', '    function factory() external pure returns (address);\n', '\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB\n', '        );\n', '\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH\n', '        );\n', '\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB\n', '        );\n', '\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH\n', '        );\n', '\n', '    function swapExactTokensForTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        bool ifmint\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactTokens(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        bool ifmint\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactETHForTokens(\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        bool ifmint\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactETH(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        bool ifmint\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactTokensForETH(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        bool ifmint\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapETHForExactTokens(\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        bool ifmint\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function quote(\n', '        uint256 amountA,\n', '        uint256 reserveA,\n', '        uint256 reserveB\n', '    ) external pure returns (uint256 amountB);\n', '\n', '    function getAmountOut(\n', '        uint256 amountIn,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountOut);\n', '\n', '    function getAmountIn(\n', '        uint256 amountOut,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountIn);\n', '\n', '    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n', '\n', '    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n', '\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountETH);\n', '\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        bool ifmint\n', '    ) external;\n', '\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        bool ifmint\n', '    ) external payable;\n', '\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        bool ifmint\n', '    ) external;\n', '}\n', '\n', '// File: contracts/sakeswap/interfaces/IERC20.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '    function mint(address to, uint value) external returns (bool);\n', '    function burn(address from, uint value) external returns (bool);\n', '}\n', '\n', '// File: contracts/sakeswap/interfaces/IWETH.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function withdraw(uint) external;\n', '}\n', '\n', '// File: contracts/sakeswap/interfaces/ISakeSwapFactory.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface ISakeSwapFactory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '    function migrator() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '    function setMigrator(address) external;\n', '}\n', '\n', '// File: contracts/sakeswap/interfaces/ISakeSwapPair.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface ISakeSwapPair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function stoken() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '    function dealSlippageWithIn(address[] calldata path, uint amountIn, address to, bool ifmint) external returns (uint amountOut);\n', '    function dealSlippageWithOut(address[] calldata path, uint amountOut, address to, bool ifmint) external returns (uint extra);\n', '    function getAmountOutMarket(address token, uint amountIn) external view returns (uint _out, uint t0Price);\n', '    function getAmountInMarket(address token, uint amountOut) external view returns (uint _in, uint t0Price);\n', '    function getAmountOutFinal(address token, uint256 amountIn) external view returns (uint256 amountOut, uint256 stokenAmount);\n', '    function getAmountInFinal(address token, uint256 amountOut) external view returns (uint256 amountIn, uint256 stokenAmount);\n', '    function getTokenMarketPrice(address token) external view returns (uint price);\n', '}\n', '\n', '// File: contracts/sakeswap/libraries/SafeMath.sol\n', '\n', 'pragma solidity =0.6.12;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '    }\n', '}\n', '\n', '// File: contracts/tools/SakeSwapBatchTrade.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract SakeSwapBatchTrade {\n', '    using SafeMath for uint256;\n', '    ISakeSwapFactory public factory = ISakeSwapFactory(0x75e48C954594d64ef9613AeEF97Ad85370F13807);\n', '    ISakeSwapRouter public router = ISakeSwapRouter(0x9C578b573EdE001b95d51a55A3FAfb45f5608b1f);\n', '    address public weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '\n', '    // constructor(address _router, address _weth, address _factory) public {\n', '    //     router = ISakeSwapRouter(_router);\n', '    //     weth = _weth;\n', '    //     factory = ISakeSwapFactory(_factory);\n', '    // }\n', '\n', '    event MultiSwap(address indexed user, uint256 consume, uint256 stoken, uint256 lptoken);\n', '\n', '    receive() external payable {\n', '        assert(msg.sender == weth); // only accept ETH via fallback from the WETH contract\n', '    }\n', '\n', '    function swapExactETHForTokens(\n', '        address token,\n', '        uint8 swapTimes,\n', '        bool addLiquidity\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 consumeAmount,\n', '            uint256 stokenAmount,\n', '            uint256 lptokenAmount\n', '        )\n', '    {\n', '        require(msg.value > 0 && (swapTimes > 0 || addLiquidity == true), "invalid params");\n', '        consumeAmount = msg.value;\n', '        address pair = factory.getPair(weth, token);\n', '        address stoken = ISakeSwapPair(pair).stoken();\n', '        IWETH(weth).deposit{value: msg.value}();\n', '        IERC20(weth).approve(address(router), uint256(-1));\n', '        IERC20(token).approve(address(router), uint256(-1));\n', '        if (swapTimes > 0) _swapExactTokensForTokens(weth, token, swapTimes);\n', '        uint256 remain = IERC20(weth).balanceOf(address(this));\n', '        if (addLiquidity) {\n', '            lptokenAmount = _addLiquidity(weth, token, remain);\n', '            uint256 wethDust = IERC20(weth).balanceOf(address(this));\n', '            if (wethDust > 0) {\n', '                IWETH(weth).withdraw(wethDust);\n', '                msg.sender.transfer(wethDust);\n', '            }\n', '            IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\n', '            consumeAmount = consumeAmount.sub(wethDust);\n', '        } else {\n', '            IWETH(weth).withdraw(remain);\n', '            msg.sender.transfer(remain);\n', '            consumeAmount = consumeAmount.sub(remain);\n', '        }\n', '        stokenAmount = IERC20(stoken).balanceOf(address(this));\n', '        IERC20(stoken).transfer(msg.sender, stokenAmount);\n', '        emit MultiSwap(msg.sender, consumeAmount, stokenAmount, lptokenAmount);\n', '    }\n', '\n', '    // function swapExactTokensForTokens(\n', '    //     address tokenA,\n', '    //     address tokenB,\n', '    //     uint256 amountIn,\n', '    //     uint8 swapTimes,\n', '    //     bool addLiquidity\n', '    // )\n', '    //     external\n', '    //     returns (\n', '    //         uint256 consumeAmount,\n', '    //         uint256 stokenAmount,\n', '    //         uint256 lptokenAmount\n', '    //     )\n', '    // {\n', '    //     require(amountIn > 0 && (swapTimes > 0 || addLiquidity == true), "invalid params");\n', '    //     IERC20(tokenA).approve(address(router), uint256(-1));\n', '    //     IERC20(tokenB).approve(address(router), uint256(-1));\n', '    //     address pair = factory.getPair(tokenA, tokenB);\n', '    //     address stoken = ISakeSwapPair(pair).stoken();\n', '    //     IERC20(tokenA).transferFrom(msg.sender, address(this), amountIn);\n', '    //     if (swapTimes > 0) _swapExactTokensForTokens(tokenA, tokenB, swapTimes);\n', '    //     if (addLiquidity) lptokenAmount = _addLiquidity(tokenA, tokenB, IERC20(tokenA).balanceOf(address(this)));\n', '    //     consumeAmount = amountIn.sub(IERC20(tokenA).balanceOf(address(this)));\n', '    //     stokenAmount = IERC20(stoken).balanceOf(address(this));\n', '    //     IERC20(tokenA).transfer(msg.sender, IERC20(tokenA).balanceOf(address(this)));\n', '    //     IERC20(tokenB).transfer(msg.sender, IERC20(tokenB).balanceOf(address(this)));\n', '    //     IERC20(stoken).transfer(msg.sender, stokenAmount);\n', '    //     emit MultiSwap(msg.sender, consumeAmount, stokenAmount, lptokenAmount);\n', '    // }\n', '\n', '    function _swapExactTokensForTokens(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint8 swapTimes\n', '    ) internal {\n', '        address[] memory pathForward = new address[](2);\n', '        address[] memory pathBackward = new address[](2);\n', '        pathForward[0] = tokenA;\n', '        pathForward[1] = tokenB;\n', '        pathBackward[0] = tokenB;\n', '        pathBackward[1] = tokenA;\n', '        for (uint8 i = 0; i < swapTimes; i++) {\n', '            uint256 amountA = IERC20(tokenA).balanceOf(address(this));\n', '            router.swapExactTokensForTokens(amountA, 0, pathForward, address(this), now + 60, true);\n', '            uint256 amountB = IERC20(tokenB).balanceOf(address(this));\n', '            router.swapExactTokensForTokens(amountB, 0, pathBackward, address(this), now + 60, true);\n', '        }\n', '    }\n', '\n', '    function _addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amount\n', '    ) internal returns (uint256 liquidity) {\n', '        uint256 half = amount / 2;\n', '        uint256 swapAmount = amount.sub(half);\n', '        address[] memory path = new address[](2);\n', '        path[0] = tokenA;\n', '        path[1] = tokenB;\n', '        router.swapExactTokensForTokens(swapAmount, 0, path, address(this), now + 60, false);\n', '        (, , liquidity) = router.addLiquidity(\n', '            tokenA,\n', '            tokenB,\n', '            half,\n', '            IERC20(tokenB).balanceOf(address(this)),\n', '            0,\n', '            0,\n', '            msg.sender,\n', '            now + 60\n', '        );\n', '    }\n', '}']