['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', 'library BConst {\n', '    uint public constant BONE                     = 10**18;\n', '\n', '    uint public constant MIN_BOUND_TOKENS         = 2;\n', '    uint public constant MAX_BOUND_TOKENS         = 8;\n', '\n', '    uint public constant DEFAULT_FEE              = BONE * 3 / 1000; // 0.3%\n', '    uint public constant MIN_FEE                  = BONE / 10**6;\n', '    uint public constant MAX_FEE                  = BONE / 10;\n', '\n', '    uint public constant DEFAULT_COLLECTED_FEE    = BONE / 2000; // 0.05%\n', '    uint public constant MAX_COLLECTED_FEE        = BONE / 200; // 0.5%\n', '\n', '    uint public constant DEFAULT_EXIT_FEE         = 0;\n', '    uint public constant MAX_EXIT_FEE             = BONE / 1000; // 0.1%\n', '\n', '    uint public constant MIN_WEIGHT               = BONE;\n', '    uint public constant MAX_WEIGHT               = BONE * 50;\n', '    uint public constant MAX_TOTAL_WEIGHT         = BONE * 50;\n', '    uint public constant MIN_BALANCE              = BONE / 10**12;\n', '\n', '    uint public constant DEFAULT_INIT_POOL_SUPPLY = BONE * 100;\n', '    uint public constant MIN_INIT_POOL_SUPPLY     = BONE / 1000;\n', '    uint public constant MAX_INIT_POOL_SUPPLY     = BONE * 10**18;\n', '\n', '    uint public constant MIN_BPOW_BASE            = 1 wei;\n', '    uint public constant MAX_BPOW_BASE            = (2 * BONE) - 1 wei;\n', '    uint public constant BPOW_PRECISION           = BONE / 10**10;\n', '\n', '    uint public constant MAX_IN_RATIO             = BONE / 2;\n', '    uint public constant MAX_OUT_RATIO            = (BONE / 3) + 1 wei;\n', '}\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', 'contract BNum {\n', '\n', '    function btoi(uint a)\n', '        internal pure \n', '        returns (uint)\n', '    {\n', '        return a / BConst.BONE;\n', '    }\n', '\n', '    function bfloor(uint a)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        return btoi(a) * BConst.BONE;\n', '    }\n', '\n', '    function badd(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint c = a + b;\n', '        require(c >= a, "add overflow");\n', '        return c;\n', '    }\n', '\n', '    function bsub(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        (uint c, bool flag) = bsubSign(a, b);\n', '        require(!flag, "sub underflow");\n', '        return c;\n', '    }\n', '\n', '    function bsubSign(uint a, uint b)\n', '        internal pure\n', '        returns (uint, bool)\n', '    {\n', '        if (a >= b) {\n', '            return (a - b, false);\n', '        } else {\n', '            return (b - a, true);\n', '        }\n', '    }\n', '\n', '    function bmul(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint c0 = a * b;\n', '        require(a == 0 || c0 / a == b, "mul overflow");\n', '        uint c1 = c0 + (BConst.BONE / 2);\n', '        require(c1 >= c0, "mul overflow");\n', '        uint c2 = c1 / BConst.BONE;\n', '        return c2;\n', '    }\n', '\n', '    function bdiv(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        require(b != 0, "div by 0");\n', '        uint c0 = a * BConst.BONE;\n', '        require(a == 0 || c0 / a == BConst.BONE, "div internal"); // bmul overflow\n', '        uint c1 = c0 + (b / 2);\n', '        require(c1 >= c0, "div internal"); //  badd require\n', '        uint c2 = c1 / b;\n', '        return c2;\n', '    }\n', '\n', '    // DSMath.wpow\n', '    function bpowi(uint a, uint n)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint z = n % 2 != 0 ? a : BConst.BONE;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            a = bmul(a, a);\n', '\n', '            if (n % 2 != 0) {\n', '                z = bmul(z, a);\n', '            }\n', '        }\n', '        return z;\n', '    }\n', '\n', '    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n', '    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n', '    // of approximation of b^0.w\n', '    function bpow(uint base, uint exp)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        require(base >= BConst.MIN_BPOW_BASE, "base too low");\n', '        require(base <= BConst.MAX_BPOW_BASE, "base too high");\n', '\n', '        uint whole  = bfloor(exp);   \n', '        uint remain = bsub(exp, whole);\n', '\n', '        uint wholePow = bpowi(base, btoi(whole));\n', '\n', '        if (remain == 0) {\n', '            return wholePow;\n', '        }\n', '\n', '        uint partialResult = bpowApprox(base, remain, BConst.BPOW_PRECISION);\n', '        return bmul(wholePow, partialResult);\n', '    }\n', '\n', '    function bpowApprox(uint base, uint exp, uint precision)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        // term 0:\n', '        uint a     = exp;\n', '        (uint x, bool xneg)  = bsubSign(base, BConst.BONE);\n', '        uint term = BConst.BONE;\n', '        uint sum   = term;\n', '        bool negative = false;\n', '\n', '\n', '        // term(k) = numer / denom \n', '        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n', '        // each iteration, multiply previous term by (a-(k-1)) * x / k\n', '        // continue until term is less than precision\n', '        for (uint i = 1; term >= precision; i++) {\n', '            uint bigK = i * BConst.BONE;\n', '            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BConst.BONE));\n', '            term = bmul(term, bmul(c, x));\n', '            term = bdiv(term, bigK);\n', '            if (term == 0) break;\n', '\n', '            if (xneg) negative = !negative;\n', '            if (cneg) negative = !negative;\n', '            if (negative) {\n', '                sum = bsub(sum, term);\n', '            } else {\n', '                sum = badd(sum, term);\n', '            }\n', '        }\n', '\n', '        return sum;\n', '    }\n', '\n', '}\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '// Highly opinionated token implementation\n', 'interface IERC20 {\n', '    event Approval(address indexed src, address indexed dst, uint amt);\n', '    event Transfer(address indexed src, address indexed dst, uint amt);\n', '\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address whom) external view returns (uint);\n', '    function allowance(address src, address dst) external view returns (uint);\n', '\n', '    function approve(address dst, uint amt) external returns (bool);\n', '    function transfer(address dst, uint amt) external returns (bool);\n', '    function transferFrom(\n', '        address src, address dst, uint amt\n', '    ) external returns (bool);\n', '}\n', '\n', 'contract BTokenBase is BNum {\n', '\n', '    mapping(address => uint)                   internal _balance;\n', '    mapping(address => mapping(address=>uint)) internal _allowance;\n', '    uint internal _totalSupply;\n', '\n', '    event Approval(address indexed src, address indexed dst, uint amt);\n', '    event Transfer(address indexed src, address indexed dst, uint amt);\n', '\n', '    function _mint(uint amt) internal {\n', '        _balance[address(this)] = badd(_balance[address(this)], amt);\n', '        _totalSupply = badd(_totalSupply, amt);\n', '        emit Transfer(address(0), address(this), amt);\n', '    }\n', '\n', '    function _burn(uint amt) internal {\n', '        require(_balance[address(this)] >= amt, "!bal");\n', '        _balance[address(this)] = bsub(_balance[address(this)], amt);\n', '        _totalSupply = bsub(_totalSupply, amt);\n', '        emit Transfer(address(this), address(0), amt);\n', '    }\n', '\n', '    function _move(address src, address dst, uint amt) internal {\n', '        require(_balance[src] >= amt, "!bal");\n', '        _balance[src] = bsub(_balance[src], amt);\n', '        _balance[dst] = badd(_balance[dst], amt);\n', '        emit Transfer(src, dst, amt);\n', '    }\n', '\n', '    function _push(address to, uint amt) internal {\n', '        _move(address(this), to, amt);\n', '    }\n', '\n', '    function _pull(address from, uint amt) internal {\n', '        _move(from, address(this), amt);\n', '    }\n', '}\n', '\n', 'contract BToken is BTokenBase, IERC20 {\n', '    string  private _name     = "Value Liquidity Provider";\n', '    string  private _symbol   = "VLP";\n', '    uint8   private _decimals = 18;\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view returns(uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function allowance(address src, address dst) external override view returns (uint) {\n', '        return _allowance[src][dst];\n', '    }\n', '\n', '    function balanceOf(address whom) public override view returns (uint) {\n', '        return _balance[whom];\n', '    }\n', '\n', '    function totalSupply() public override view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function approve(address dst, uint amt) external override returns (bool) {\n', '        _allowance[msg.sender][dst] = amt;\n', '        emit Approval(msg.sender, dst, amt);\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval(address dst, uint amt) external returns (bool) {\n', '        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\n', '        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address dst, uint amt) external returns (bool) {\n', '        uint oldValue = _allowance[msg.sender][dst];\n', '        if (amt > oldValue) {\n', '            _allowance[msg.sender][dst] = 0;\n', '        } else {\n', '            _allowance[msg.sender][dst] = bsub(oldValue, amt);\n', '        }\n', '        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint amt) external override returns (bool) {\n', '        _move(msg.sender, dst, amt);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\n', '        require(msg.sender == src || amt <= _allowance[src][msg.sender], "!spender");\n', '        _move(src, dst, amt);\n', '        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n', '            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\n', '            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n', '        }\n', '        return true;\n', '    }\n', '}\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', 'contract BMathLite is BNum {\n', '    /**********************************************************************************************\n', '    // calcSpotPrice                                                                             //\n', '    // sP = spotPrice                                                                            //\n', '    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n', '    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n', '    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n', '    // wO = tokenWeightOut                                                                       //\n', '    // sF = swapFee (+ collectedFee)                                                             //\n', '    **********************************************************************************************/\n', '    function calcSpotPrice(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint swapFee\n', '    )\n', '        public pure\n', '        returns (uint spotPrice)\n', '    {\n', '        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\n', '        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\n', '        uint ratio = bdiv(numer, denom);\n', '        uint scale = bdiv(BConst.BONE, bsub(BConst.BONE, swapFee));\n', '        return  (spotPrice = bmul(ratio, scale));\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcOutGivenIn                                                                            //\n', '    // aO = tokenAmountOut                                                                       //\n', '    // bO = tokenBalanceOut                                                                      //\n', '    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n', '    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n', '    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n', '    // wO = tokenWeightOut                                                                       //\n', '    // sF = swapFee (+ collectedFee)                                                             //\n', '    **********************************************************************************************/\n', '    function calcOutGivenIn(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint tokenAmountIn,\n', '        uint swapFee\n', '    )\n', '        public pure\n', '        returns (uint tokenAmountOut)\n', '    {\n', '        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n', '        uint adjustedIn = bsub(BConst.BONE, swapFee);\n', '        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n', '        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n', '        uint foo = bpow(y, weightRatio);\n', '        uint bar = bsub(BConst.BONE, foo);\n', '        tokenAmountOut = bmul(tokenBalanceOut, bar);\n', '        return tokenAmountOut;\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcInGivenOut                                                                            //\n', '    // aI = tokenAmountIn                                                                        //\n', '    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n', '    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n', '    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n', '    // wI = tokenWeightIn           --------------------------------------------                 //\n', '    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n', '    // sF = swapFee (+ collectedFee)                                                             //\n', '    **********************************************************************************************/\n', '    function calcInGivenOut(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint tokenAmountOut,\n', '        uint swapFee\n', '    )\n', '        public pure\n', '        returns (uint tokenAmountIn)\n', '    {\n', '        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n', '        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\n', '        uint y = bdiv(tokenBalanceOut, diff);\n', '        uint foo = bpow(y, weightRatio);\n', '        foo = bsub(foo, BConst.BONE);\n', '        tokenAmountIn = bsub(BConst.BONE, swapFee);\n', '        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n', '        return tokenAmountIn;\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcPoolOutGivenSingleIn                                                                  //\n', '    // pAo = poolAmountOut         /                                              \\              //\n', '    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\n', '    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n', '    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n', '    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n', '    // pS = poolSupply            \\\\                    tBi               /        /             //\n', '    // sF = swapFee (+ collectedFee)\\                                              /              //\n', '    **********************************************************************************************/\n', '    function calcPoolOutGivenSingleIn(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint tokenAmountIn,\n', '        uint swapFee\n', '    )\n', '        public pure\n', '        returns (uint poolAmountOut)\n', '    {\n', '        // @dev Charge the trading fee for the proportion of tokenAi\n', '        // which is implicitly traded to the other pool tokens.\n', '        // That proportion is (1- weightTokenIn)\n', '        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n', '        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n', '        uint zaz = bmul(bsub(BConst.BONE, normalizedWeight), swapFee);\n', '        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BConst.BONE, zaz));\n', '\n', '        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n', '        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n', '\n', '        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n', '        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\n', '        uint newPoolSupply = bmul(poolRatio, poolSupply);\n', '        poolAmountOut = bsub(newPoolSupply, poolSupply);\n', '        return poolAmountOut;\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcSingleOutGivenPoolIn                                                                  //\n', '    // tAo = tokenAmountOut            /      /                                             \\\\   //\n', '    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\n', '    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n', '    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n', '    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n', '    // tW = totalWeight                    /     /      wO \\       \\                             //\n', '    // sF = swapFee (+ collectedFee)   *  | 1 - |  1 - ---- | * sF  |                            //\n', '    // eF = exitFee                        \\     \\      tW /       /                             //\n', '    **********************************************************************************************/\n', '    function calcSingleOutGivenPoolIn(\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint poolAmountIn,\n', '        uint swapFee,\n', '        uint exitFee\n', '    )\n', '        public pure\n', '        returns (uint tokenAmountOut)\n', '    {\n', '        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n', '        // charge exit fee on the pool token side\n', '        // pAiAfterExitFee = pAi*(1-exitFee)\n', '        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BConst.BONE, exitFee));\n', '        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n', '        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n', '     \n', '        // newBalTo = poolRatio^(1/weightTo) * balTo;\n', '        uint tokenOutRatio = bpow(poolRatio, bdiv(BConst.BONE, normalizedWeight));\n', '        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n', '\n', '        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n', '\n', '        // charge swap fee on the output token side \n', '        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n', '        uint zaz = bmul(bsub(BConst.BONE, normalizedWeight), swapFee);\n', '        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BConst.BONE, zaz));\n', '        return tokenAmountOut;\n', '    }\n', '\n', '\n', '}\n', '\n', 'interface IBFactory {\n', '    function collectedToken() external view returns (address);\n', '}\n', '\n', 'contract BPoolLite is BToken, BMathLite {\n', '    struct Record {\n', '        bool bound;   // is token bound to pool\n', '        uint index;   // private\n', '        uint denorm;  // denormalized weight\n', '        uint balance;\n', '    }\n', '\n', '    event LOG_SWAP(\n', '        address indexed caller,\n', '        address indexed tokenIn,\n', '        address indexed tokenOut,\n', '        uint256 tokenAmountIn,\n', '        uint256 tokenAmountOut\n', '    );\n', '\n', '    event LOG_JOIN(\n', '        address indexed caller,\n', '        address indexed tokenIn,\n', '        uint256 tokenAmountIn\n', '    );\n', '\n', '    event LOG_EXIT(\n', '        address indexed caller,\n', '        address indexed tokenOut,\n', '        uint256 tokenAmountOut\n', '    );\n', '\n', '    event LOG_COLLECTED_FUND(\n', '        address indexed collectedToken,\n', '        uint256 collectedAmount\n', '    );\n', '\n', '    event LOG_FINALIZE(\n', '        uint swapFee,\n', '        uint initPoolSupply,\n', '        uint version,\n', '        address[] bindTokens,\n', '        uint[] bindDenorms,\n', '        uint[] balances\n', '    );\n', '\n', '    modifier _lock_() {\n', '        require(!_mutex, "reentry");\n', '        _mutex = true;\n', '        _;\n', '        _mutex = false;\n', '    }\n', '\n', '    modifier _viewlock_() {\n', '        require(!_mutex, "reentry");\n', '        _;\n', '    }\n', '\n', '    bool private _mutex;\n', '\n', '    uint public version = 2001;\n', '    address public factory;    // BFactory address to push token exitFee to\n', '    address public controller; // has CONTROL role\n', '\n', '    // `setSwapFee` and `finalize` require CONTROL\n', '    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\n', '    uint public swapFee;\n', '    uint public collectedFee; // 0.05% | https://yfv.finance/vip-vote/vip_5\n', '    uint public exitFee;\n', '    bool public finalized;\n', '\n', '    address[] internal _tokens;\n', '    mapping(address => Record) internal _records;\n', '    uint private _totalWeight;\n', '\n', '    constructor(address _factory) public {\n', '        controller = _factory;\n', '        factory = _factory;\n', '        swapFee = BConst.DEFAULT_FEE;\n', '        collectedFee = BConst.DEFAULT_COLLECTED_FEE;\n', '        exitFee = BConst.DEFAULT_EXIT_FEE;\n', '        finalized = false;\n', '    }\n', '\n', '    function setCollectedFee(uint _collectedFee) public {\n', '        require(msg.sender == factory, "!fctr");\n', '        require(_collectedFee <= BConst.MAX_COLLECTED_FEE, ">maxCoFee");\n', '        require(bmul(_collectedFee, 2) <= swapFee, ">sFee/2");\n', '        collectedFee = _collectedFee;\n', '    }\n', '\n', '    function setExitFee(uint _exitFee) public {\n', '        require(!finalized, "fnl");\n', '        require(msg.sender == factory, "!fctr");\n', '        require(_exitFee <= BConst.MAX_EXIT_FEE, ">maxExitFee");\n', '        exitFee = _exitFee;\n', '    }\n', '\n', '    function isBound(address t)\n', '    external view\n', '    returns (bool)\n', '    {\n', '        return _records[t].bound;\n', '    }\n', '\n', '    function getNumTokens()\n', '    external view\n', '    returns (uint)\n', '    {\n', '        return _tokens.length;\n', '    }\n', '\n', '    function getCurrentTokens()\n', '    external view _viewlock_\n', '    returns (address[] memory tokens)\n', '    {\n', '        return _tokens;\n', '    }\n', '\n', '    function getFinalTokens()\n', '    external view\n', '    _viewlock_\n', '    returns (address[] memory tokens)\n', '    {\n', '        require(finalized, "!fnl");\n', '        return _tokens;\n', '    }\n', '\n', '    function getDenormalizedWeight(address token)\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '\n', '        require(_records[token].bound, "!bound");\n', '        return _records[token].denorm;\n', '    }\n', '\n', '    function getTotalDenormalizedWeight()\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '        return _totalWeight;\n', '    }\n', '\n', '    function getNormalizedWeight(address token)\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '\n', '        require(_records[token].bound, "!bound");\n', '        uint denorm = _records[token].denorm;\n', '        return bdiv(denorm, _totalWeight);\n', '    }\n', '\n', '    function getBalance(address token)\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '\n', '        require(_records[token].bound, "!bound");\n', '        return _records[token].balance;\n', '    }\n', '\n', '    function setController(address _controller)\n', '    external\n', '    _lock_\n', '    {\n', '        require(msg.sender == controller, "!cntler");\n', '        controller = _controller;\n', '    }\n', '\n', '    function finalize(\n', '        uint _swapFee,\n', '        uint _initPoolSupply,\n', '        address[] calldata _bindTokens,\n', '        uint[] calldata _bindDenorms\n', '    ) external _lock_ {\n', '        require(msg.sender == controller, "!cntler");\n', '        require(!finalized, "fnl");\n', '\n', '        require(_swapFee >= BConst.MIN_FEE, "<minFee");\n', '        require(_swapFee <= BConst.MAX_FEE, ">maxFee");\n', '        require(bmul(collectedFee, 2) <= _swapFee, "<Fee*2");\n', '        swapFee = _swapFee;\n', '\n', '        require(_initPoolSupply >= BConst.MIN_INIT_POOL_SUPPLY, "<minInitPSup");\n', '        require(_initPoolSupply <= BConst.MAX_INIT_POOL_SUPPLY, ">maxInitPSup");\n', '\n', '        require(_bindTokens.length >= BConst.MIN_BOUND_TOKENS, "<minTokens");\n', '        require(_bindTokens.length < BConst.MAX_BOUND_TOKENS, ">maxTokens");\n', '        require(_bindTokens.length == _bindDenorms.length, "erLengMism");\n', '\n', '        uint totalWeight = 0;\n', '        uint256[] memory balances = new uint[](_bindTokens.length);\n', '        for (uint i = 0; i < _bindTokens.length; i++) {\n', '            address token = _bindTokens[i];\n', '            uint denorm = _bindDenorms[i];\n', '            uint balance = BToken(token).balanceOf(address(this));\n', '            balances[i] = balance;\n', '            require(!_records[token].bound, "bound");\n', '            require(denorm >= BConst.MIN_WEIGHT, "<minWeight");\n', '            require(denorm <= BConst.MAX_WEIGHT, ">maxWeight");\n', '            require(balance >= BConst.MIN_BALANCE, "<minBal");\n', '            _records[token] = Record({\n', '                bound : true,\n', '                index : i,\n', '                denorm : denorm,\n', '                balance : balance\n', '                });\n', '            totalWeight = badd(totalWeight, denorm);\n', '        }\n', '        require(totalWeight <= BConst.MAX_TOTAL_WEIGHT, ">maxTWeight");\n', '        _totalWeight = totalWeight;\n', '        _tokens = _bindTokens;\n', '        finalized = true;\n', '        _mintPoolShare(_initPoolSupply);\n', '        _pushPoolShare(msg.sender, _initPoolSupply);\n', '        emit LOG_FINALIZE(swapFee, _initPoolSupply, version, _bindTokens, _bindDenorms, balances);\n', '    }\n', '\n', '    // Absorb any tokens that have been sent to this contract into the pool\n', '    function gulp(address token)\n', '    external\n', '    _lock_\n', '    {\n', '        require(_records[token].bound, "!bound");\n', '        _records[token].balance = IERC20(token).balanceOf(address(this));\n', '    }\n', '\n', '    function getSpotPrice(address tokenIn, address tokenOut)\n', '    external view\n', '    _viewlock_\n', '    returns (uint spotPrice)\n', '    {\n', '        require(_records[tokenIn].bound, "!bound");\n', '        require(_records[tokenOut].bound, "!bound");\n', '        Record storage inRecord = _records[tokenIn];\n', '        Record storage outRecord = _records[tokenOut];\n', '        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, swapFee);\n', '    }\n', '\n', '    function getSpotPriceSansFee(address tokenIn, address tokenOut)\n', '    external view\n', '    _viewlock_\n', '    returns (uint spotPrice)\n', '    {\n', '        require(_records[tokenIn].bound, "!bound");\n', '        require(_records[tokenOut].bound, "!bound");\n', '        Record storage inRecord = _records[tokenIn];\n', '        Record storage outRecord = _records[tokenOut];\n', '        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\n', '    }\n', '\n', '    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\n', '    external virtual\n', '    _lock_\n', '    {\n', '        require(finalized, "!fnl");\n', '\n', '        uint poolTotal = totalSupply();\n', '        uint ratio = bdiv(poolAmountOut, poolTotal);\n', '        require(ratio != 0, "erMApr");\n', '\n', '        for (uint i = 0; i < _tokens.length; i++) {\n', '            address t = _tokens[i];\n', '            uint bal = _records[t].balance;\n', '            uint tokenAmountIn = bmul(ratio, bal);\n', '            require(tokenAmountIn != 0, "erMApr");\n', '            require(tokenAmountIn <= maxAmountsIn[i], "<limIn");\n', '            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\n', '            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n', '            _pullUnderlying(t, msg.sender, tokenAmountIn);\n', '        }\n', '        _mintPoolShare(poolAmountOut);\n', '        _pushPoolShare(msg.sender, poolAmountOut);\n', '    }\n', '\n', '    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\n', '    external virtual\n', '    _lock_\n', '    {\n', '        require(finalized, "!fnl");\n', '\n', '        uint poolTotal = totalSupply();\n', '        uint _exitFee = bmul(poolAmountIn, exitFee);\n', '        uint pAiAfterExitFee = bsub(poolAmountIn, _exitFee);\n', '        uint ratio = bdiv(pAiAfterExitFee, poolTotal);\n', '        require(ratio != 0, "erMApr");\n', '\n', '        _pullPoolShare(msg.sender, poolAmountIn);\n', '        if (_exitFee > 0) {\n', '            _pushPoolShare(factory, _exitFee);\n', '        }\n', '        _burnPoolShare(pAiAfterExitFee);\n', '\n', '        for (uint i = 0; i < _tokens.length; i++) {\n', '            address t = _tokens[i];\n', '            uint bal = _records[t].balance;\n', '            uint tokenAmountOut = bmul(ratio, bal);\n', '            require(tokenAmountOut != 0, "erMApr");\n', '            require(tokenAmountOut >= minAmountsOut[i], "<limO");\n', '            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\n', '            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n', '            _pushUnderlying(t, msg.sender, tokenAmountOut);\n', '        }\n', '    }\n', '\n', '    function swapExactAmountIn(\n', '        address tokenIn,\n', '        uint tokenAmountIn,\n', '        address tokenOut,\n', '        uint minAmountOut,\n', '        uint maxPrice\n', '    )\n', '    external\n', '    _lock_\n', '    returns (uint tokenAmountOut, uint spotPriceAfter)\n', '    {\n', '\n', '        require(_records[tokenIn].bound, "!bound");\n', '        require(_records[tokenOut].bound, "!bound");\n', '\n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '\n', '        require(tokenAmountIn <= bmul(inRecord.balance, BConst.MAX_IN_RATIO), ">maxIRat");\n', '\n', '        uint spotPriceBefore = calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            swapFee\n', '        );\n', '        require(spotPriceBefore <= maxPrice, "badLimPrice");\n', '\n', '        tokenAmountOut = calcOutGivenIn(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            tokenAmountIn,\n', '            swapFee\n', '        );\n', '        require(tokenAmountOut >= minAmountOut, "<limO");\n', '\n', '        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n', '        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n', '\n', '        spotPriceAfter = calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            swapFee\n', '        );\n', '        require(spotPriceAfter >= spotPriceBefore, "erMApr");\n', '        require(spotPriceAfter <= maxPrice, ">limPrice");\n', '        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), "erMApr");\n', '\n', '        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n', '\n', '        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n', '        uint _subTokenAmountIn;\n', '        (_subTokenAmountIn, tokenAmountOut) = _pushCollectedFundGivenOut(tokenIn, tokenAmountIn, tokenOut, tokenAmountOut);\n', '        if (_subTokenAmountIn > 0) inRecord.balance = bsub(inRecord.balance, _subTokenAmountIn);\n', '        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n', '\n', '        return (tokenAmountOut, spotPriceAfter);\n', '    }\n', '\n', '    function swapExactAmountOut(\n', '        address tokenIn,\n', '        uint maxAmountIn,\n', '        address tokenOut,\n', '        uint tokenAmountOut,\n', '        uint maxPrice\n', '    )\n', '    external\n', '    _lock_\n', '    returns (uint tokenAmountIn, uint spotPriceAfter)\n', '    {\n', '        require(_records[tokenIn].bound, "!bound");\n', '        require(_records[tokenOut].bound, "!bound");\n', '\n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '\n', '        require(tokenAmountOut <= bmul(outRecord.balance, BConst.MAX_OUT_RATIO), ">maxORat");\n', '\n', '        uint spotPriceBefore = calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            swapFee\n', '        );\n', '        require(spotPriceBefore <= maxPrice, "badLimPrice");\n', '\n', '        tokenAmountIn = calcInGivenOut(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            tokenAmountOut,\n', '            swapFee\n', '        );\n', '        require(tokenAmountIn <= maxAmountIn, "<limIn");\n', '\n', '        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n', '        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n', '\n', '        spotPriceAfter = calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            swapFee\n', '        );\n', '        require(spotPriceAfter >= spotPriceBefore, "erMApr");\n', '        require(spotPriceAfter <= maxPrice, ">limPrice");\n', '        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), "erMApr");\n', '\n', '        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n', '\n', '        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n', '        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n', '        uint _collectedFeeAmount = _pushCollectedFundGivenIn(tokenIn, tokenAmountIn);\n', '        if (_collectedFeeAmount > 0) inRecord.balance = bsub(inRecord.balance, _collectedFeeAmount);\n', '\n', '        return (tokenAmountIn, spotPriceAfter);\n', '    }\n', '\n', '    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\n', '    external\n', '    _lock_\n', '    returns (uint poolAmountOut)\n', '\n', '    {\n', '        require(finalized, "!fnl");\n', '        require(_records[tokenIn].bound, "!bound");\n', '        require(tokenAmountIn <= bmul(_records[tokenIn].balance, BConst.MAX_IN_RATIO), ">maxIRat");\n', '\n', '        Record storage inRecord = _records[tokenIn];\n', '\n', '        poolAmountOut = calcPoolOutGivenSingleIn(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            _totalSupply,\n', '            _totalWeight,\n', '            tokenAmountIn,\n', '            swapFee\n', '        );\n', '\n', '        require(poolAmountOut >= minPoolAmountOut, "<limO");\n', '\n', '        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n', '\n', '        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n', '\n', '        _mintPoolShare(poolAmountOut);\n', '        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n', '        uint _subTokenAmountIn;\n', '        (_subTokenAmountIn, poolAmountOut) = _pushCollectedFundGivenOut(tokenIn, tokenAmountIn, address(this), poolAmountOut);\n', '        if (_subTokenAmountIn > 0) inRecord.balance = bsub(inRecord.balance, _subTokenAmountIn);\n', '        _pushPoolShare(msg.sender, poolAmountOut);\n', '\n', '        return poolAmountOut;\n', '    }\n', '\n', '    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\n', '    external\n', '    _lock_\n', '    returns (uint tokenAmountOut)\n', '    {\n', '        require(finalized, "!fnl");\n', '        require(_records[tokenOut].bound, "!bound");\n', '\n', '        Record storage outRecord = _records[tokenOut];\n', '\n', '        tokenAmountOut = calcSingleOutGivenPoolIn(\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            _totalSupply,\n', '            _totalWeight,\n', '            poolAmountIn,\n', '            swapFee,\n', '            exitFee\n', '        );\n', '\n', '        require(tokenAmountOut >= minAmountOut, "<limO");\n', '\n', '        require(tokenAmountOut <= bmul(_records[tokenOut].balance, BConst.MAX_OUT_RATIO), ">maxORat");\n', '\n', '        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n', '\n', '        uint _exitFee = bmul(poolAmountIn, exitFee);\n', '\n', '        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n', '\n', '        _pullPoolShare(msg.sender, poolAmountIn);\n', '        _burnPoolShare(bsub(poolAmountIn, _exitFee));\n', '        if (_exitFee > 0) {\n', '            _pushPoolShare(factory, _exitFee);\n', '        }\n', '        (, tokenAmountOut) = _pushCollectedFundGivenOut(address(this), poolAmountIn, tokenOut, tokenAmountOut);\n', '        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n', '\n', '        return tokenAmountOut;\n', '    }\n', '\n', '    // ==\n', "    // 'Underlying' token-manipulation functions make external calls but are NOT locked\n", '    // You must `_lock_` or otherwise ensure reentry-safety\n', '    //\n', '    // Fixed ERC-20 transfer revert for some special token such as USDT\n', '    function _pullUnderlying(address erc20, address from, uint amount) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = erc20.call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), '!_pullU');\n", '    }\n', '\n', '    function _pushUnderlying(address erc20, address to, uint amount) internal\n', '    {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = erc20.call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), '!_pushU');\n", '    }\n', '\n', '    function _pullPoolShare(address from, uint amount)\n', '    internal\n', '    {\n', '        _pull(from, amount);\n', '    }\n', '\n', '    function _pushPoolShare(address to, uint amount)\n', '    internal\n', '    {\n', '        _push(to, amount);\n', '    }\n', '\n', '    function _mintPoolShare(uint amount)\n', '    internal\n', '    {\n', '        _mint(amount);\n', '    }\n', '\n', '    function _burnPoolShare(uint amount)\n', '    internal\n', '    {\n', '        _burn(amount);\n', '    }\n', '\n', '    function _pushCollectedFundGivenOut(address _tokenIn, uint _tokenAmountIn, address _tokenOut, uint _tokenAmountOut) internal returns (uint subTokenAmountIn, uint tokenAmountOut) {\n', '        subTokenAmountIn = 0;\n', '        tokenAmountOut = _tokenAmountOut;\n', '        if (collectedFee > 0) {\n', '            address _collectedToken = IBFactory(factory).collectedToken();\n', '            if (_collectedToken == _tokenIn) {\n', '                subTokenAmountIn = bdiv(bmul(_tokenAmountIn, collectedFee), BConst.BONE);\n', '                _pushUnderlying(_tokenIn, factory, subTokenAmountIn);\n', '                emit LOG_COLLECTED_FUND(_tokenIn, subTokenAmountIn);\n', '            } else {\n', '                uint _collectedFeeAmount = bdiv(bmul(_tokenAmountOut, collectedFee), BConst.BONE);\n', '                _pushUnderlying(_tokenOut, factory, _collectedFeeAmount);\n', '                tokenAmountOut = bsub(_tokenAmountOut, _collectedFeeAmount);\n', '                emit LOG_COLLECTED_FUND(_tokenOut, _collectedFeeAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    // always push out _tokenIn (already have)\n', '    function _pushCollectedFundGivenIn(address _tokenIn, uint _tokenAmountIn) internal returns (uint collectedFeeAmount) {\n', '        collectedFeeAmount = 0;\n', '        if (collectedFee > 0) {\n', '            address _collectedToken = IBFactory(factory).collectedToken();\n', '            if (_collectedToken != address(0)) {\n', '                collectedFeeAmount = bdiv(bmul(_tokenAmountIn, collectedFee), BConst.BONE);\n', '                _pushUnderlying(_tokenIn, factory, collectedFeeAmount);\n', '                emit LOG_COLLECTED_FUND(_tokenIn, collectedFeeAmount);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'interface IFaaSPool {\n', '    function stake(uint) external;\n', '    function withdraw(uint) external;\n', '    function getReward(uint8 _pid, address _account) external;\n', '    function getAllRewards(address _account) external;\n', '    function pendingReward(uint8 _pid, address _account) external view returns (uint);\n', '    function emergencyWithdraw() external;\n', '}\n', '\n', 'interface IFaaSRewardFund {\n', '    function balance(IERC20 _token) external view returns (uint);\n', '    function safeTransfer(IERC20 _token, address _to, uint _value) external;\n', '}\n', '\n', '// This implements BPool contract, and allows for generalized staking, yield farming, and token distribution.\n', 'contract FaaSPoolLite is BPoolLite, IFaaSPool {\n', '    using SafeMath for uint;\n', '\n', '    // Info of each user.\n', '    struct UserInfo {\n', '        uint amount;\n', '        mapping(uint8 => uint) rewardDebt;\n', '        mapping(uint8 => uint) accumulatedEarned; // will accumulate every time user harvest\n', '        mapping(uint8 => uint) lockReward;\n', '        mapping(uint8 => uint) lockRewardReleased;\n', '        uint lastStakeTime;\n', '    }\n', '\n', '    // Info of each rewardPool funding.\n', '    struct RewardPoolInfo {\n', '        IERC20 rewardToken;     // Address of rewardPool token contract.\n', '        uint lastRewardBlock;   // Last block number that rewardPool distribution occurs.\n', '        uint endRewardBlock;    // Block number which rewardPool distribution ends.\n', '        uint rewardPerBlock;    // Reward token amount to distribute per block.\n', '        uint accRewardPerShare; // Accumulated rewardPool per share, times 1e18.\n', '\n', '        uint lockRewardPercent; // Lock reward percent - 0 to disable lock & vesting\n', '        uint startVestingBlock; // Block number which vesting starts.\n', '        uint endVestingBlock;   // Block number which vesting ends.\n', '        uint numOfVestingBlocks;\n', '\n', '        uint totalPaidRewards;\n', '    }\n', '\n', '    mapping(address => UserInfo) private userInfo;\n', '    RewardPoolInfo[] public rewardPoolInfo;\n', '\n', '    IFaaSRewardFund public rewardFund;\n', '    address public exchangeProxy;\n', '    uint public unstakingFrozenTime = 3 days;\n', '\n', '    event Deposit(address indexed account, uint256 amount);\n', '    event Withdraw(address indexed account, uint256 amount);\n', '    event RewardPaid(uint8 pid, address indexed account, uint256 amount);\n', '\n', '    constructor(address _factory) public BPoolLite(_factory) {\n', '    }\n', '\n', '    modifier onlyController() {\n', '        require(msg.sender == controller, "!cntler");\n', '        _;\n', '    }\n', '\n', '    function setRewardFund(IFaaSRewardFund _rewardFund) public onlyController {\n', '        rewardFund = _rewardFund;\n', '    }\n', '\n', '    function setExchangeProxy(address _exchangeProxy) public onlyController {\n', '        exchangeProxy = _exchangeProxy;\n', '    }\n', '\n', '    function setUnstakingFrozenTime(uint _unstakingFrozenTime) public onlyController {\n', '        assert(unstakingFrozenTime <= 30 days); // do not lock fund for too long, please!\n', '        unstakingFrozenTime = _unstakingFrozenTime;\n', '    }\n', '\n', '    function addRewardPool(IERC20 _rewardToken, uint256 _startBlock, uint256 _endRewardBlock, uint256 _rewardPerBlock,\n', '        uint256 _lockRewardPercent, uint256 _startVestingBlock, uint256 _endVestingBlock) public onlyController {\n', '        require(rewardPoolInfo.length < 8, "exceed rwdPoolLim");\n', '        require(_startVestingBlock <= _endVestingBlock, "sVB>eVB");\n', '        _startBlock = (block.number > _startBlock) ? block.number : _startBlock;\n', '        require(_startBlock < _endRewardBlock, "sB>=eB");\n', '        updateReward();\n', '        rewardPoolInfo.push(RewardPoolInfo({\n', '            rewardToken : _rewardToken,\n', '            lastRewardBlock : _startBlock,\n', '            endRewardBlock : _endRewardBlock,\n', '            rewardPerBlock : _rewardPerBlock,\n', '            accRewardPerShare : 0,\n', '            lockRewardPercent : _lockRewardPercent,\n', '            startVestingBlock : _startVestingBlock,\n', '            endVestingBlock : _endVestingBlock,\n', '            numOfVestingBlocks: _endVestingBlock - _startVestingBlock,\n', '            totalPaidRewards: 0\n', '            }));\n', '    }\n', '\n', '    function updateRewardPool(uint8 _pid, uint256 _endRewardBlock, uint256 _rewardPerBlock) public onlyController {\n', '        updateReward(_pid);\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n', '        require(block.number <= rewardPool.endRewardBlock, "late");\n', '        rewardPool.endRewardBlock = _endRewardBlock;\n', '        rewardPool.rewardPerBlock = _rewardPerBlock;\n', '    }\n', '\n', '    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external override {\n', '        joinPoolFor(msg.sender, poolAmountOut, maxAmountsIn);\n', '    }\n', '\n', '    function joinPoolFor(address account, uint poolAmountOut, uint[] calldata maxAmountsIn) public _lock_ {\n', '        require(msg.sender == account || msg.sender == exchangeProxy, "!(prx||own)");\n', '        _joinPool(account, poolAmountOut, maxAmountsIn);\n', '        _stakePoolShare(account, poolAmountOut);\n', '    }\n', '\n', '    function joinPoolNotStake(uint poolAmountOut, uint[] calldata maxAmountsIn) external _lock_ {\n', '        _joinPool(msg.sender, poolAmountOut, maxAmountsIn);\n', '        _pushPoolShare(msg.sender, poolAmountOut);\n', '    }\n', '\n', '    function _joinPool(address account, uint poolAmountOut, uint[] calldata maxAmountsIn) internal {\n', '        require(finalized, "!fnl");\n', '\n', '        uint rewardTotal = totalSupply();\n', '        uint ratio = bdiv(poolAmountOut, rewardTotal);\n', '        require(ratio != 0, "erMApr");\n', '\n', '        for (uint i = 0; i < _tokens.length; i++) {\n', '            address t = _tokens[i];\n', '            uint bal = _records[t].balance;\n', '            uint tokenAmountIn = bmul(ratio, bal);\n', '            require(tokenAmountIn != 0 && tokenAmountIn <= maxAmountsIn[i], "erMApr||<limIn");\n', '            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\n', '            emit LOG_JOIN(account, t, tokenAmountIn);\n', '            _pullUnderlying(t, msg.sender, tokenAmountIn);\n', '        }\n', '        _mintPoolShare(poolAmountOut);\n', '    }\n', '\n', '    function stake(uint _shares) external override {\n', '        uint _before = balanceOf(address(this));\n', '        _pullPoolShare(msg.sender, _shares);\n', '        uint _after = balanceOf(address(this));\n', '        _shares = bsub(_after, _before); // Additional check for deflationary tokens\n', '        _stakePoolShare(msg.sender, _shares);\n', '    }\n', '\n', '    function _stakePoolShare(address _account, uint _shares) internal {\n', '        UserInfo storage user = userInfo[_account];\n', '        getAllRewards(_account);\n', '        user.amount = user.amount.add(_shares);\n', '        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n', '        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n', '            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n', '        }\n', '        user.lastStakeTime = block.timestamp;\n', '        emit Deposit(_account, _shares);\n', '    }\n', '\n', '    function unfrozenStakeTime(address _account) public view returns (uint) {\n', '        return userInfo[_account].lastStakeTime + unstakingFrozenTime;\n', '    }\n', '\n', '    function withdraw(uint _amount) public override {\n', '        UserInfo storage user = userInfo[msg.sender];\n', '        require(user.amount >= _amount, "am>us.am");\n', '        require(block.timestamp >= user.lastStakeTime.add(unstakingFrozenTime), "frozen");\n', '        getAllRewards(msg.sender);\n', '        user.amount = bsub(user.amount, _amount);\n', '        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n', '        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n', '            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n', '        }\n', '        _pushPoolShare(msg.sender, _amount);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    // using PUSH pattern for using by Proxy if needed\n', '    function getAllRewards(address _account) public override {\n', '        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n', '        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n', '            getReward(_pid, _account);\n', '        }\n', '    }\n', '\n', '    function getReward(uint8 _pid, address _account) public override {\n', '        updateReward(_pid);\n', '        UserInfo storage user = userInfo[_account];\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n', '        uint _pendingReward = user.amount.mul(rewardPool.accRewardPerShare).div(1e18).sub(user.rewardDebt[_pid]);\n', '        uint _lockRewardPercent = rewardPool.lockRewardPercent;\n', '        if (_lockRewardPercent > 0) {\n', '            if (block.number > rewardPool.endVestingBlock) {\n', '                uint _unlockReward = user.lockReward[_pid].sub(user.lockRewardReleased[_pid]);\n', '                if (_unlockReward > 0) {\n', '                    _pendingReward = _pendingReward.add(_unlockReward);\n', '                    user.lockRewardReleased[_pid] = user.lockRewardReleased[_pid].add(_unlockReward);\n', '                }\n', '            } else {\n', '                if (_pendingReward > 0) {\n', '                    uint _toLocked = _pendingReward.mul(_lockRewardPercent).div(100);\n', '                    _pendingReward = _pendingReward.sub(_toLocked);\n', '                    user.lockReward[_pid] = user.lockReward[_pid].add(_toLocked);\n', '                }\n', '                if (block.number > rewardPool.startVestingBlock) {\n', '                    uint _toReleased = user.lockReward[_pid].mul(block.number.sub(rewardPool.startVestingBlock)).div(rewardPool.numOfVestingBlocks);\n', '                    uint _lockRewardReleased = user.lockRewardReleased[_pid];\n', '                    if (_toReleased > _lockRewardReleased) {\n', '                        uint _unlockReward = _toReleased.sub(_lockRewardReleased);\n', '                        user.lockRewardReleased[_pid] = _lockRewardReleased.add(_unlockReward);\n', '                        _pendingReward = _pendingReward.add(_unlockReward);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        if (_pendingReward > 0) {\n', '            user.accumulatedEarned[_pid] = user.accumulatedEarned[_pid].add(_pendingReward);\n', '            rewardPool.totalPaidRewards = rewardPool.totalPaidRewards.add(_pendingReward);\n', '            rewardFund.safeTransfer(rewardPool.rewardToken, _account, _pendingReward);\n', '            emit RewardPaid(_pid, _account, _pendingReward);\n', '            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n', '        }\n', '    }\n', '\n', '    function pendingReward(uint8 _pid, address _account) public override view returns (uint _pending) {\n', '        UserInfo storage user = userInfo[_account];\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n', '        uint _accRewardPerShare = rewardPool.accRewardPerShare;\n', '        uint lpSupply = balanceOf(address(this));\n', '        uint _endRewardBlockApplicable = block.number > rewardPool.endRewardBlock ? rewardPool.endRewardBlock : block.number;\n', '        if (_endRewardBlockApplicable > rewardPool.lastRewardBlock && lpSupply != 0) {\n', '            uint _numBlocks = _endRewardBlockApplicable.sub(rewardPool.lastRewardBlock);\n', '            uint _incRewardPerShare = _numBlocks.mul(rewardPool.rewardPerBlock).mul(1e18).div(lpSupply);\n', '            _accRewardPerShare = _accRewardPerShare.add(_incRewardPerShare);\n', '        }\n', '        _pending = user.amount.mul(_accRewardPerShare).div(1e18).sub(user.rewardDebt[_pid]);\n', '    }\n', '\n', '    // Withdraw without caring about rewards. EMERGENCY ONLY.\n', '    function emergencyWithdraw() external override {\n', '        UserInfo storage user = userInfo[msg.sender];\n', '        uint _amount = user.amount;\n', '        _pushPoolShare(msg.sender, _amount);\n', '        user.amount = 0;\n', '        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n', '        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n', '            user.rewardDebt[_pid] = 0;\n', '        }\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    function getUserInfo(uint8 _pid, address _account) public view returns (uint amount, uint rewardDebt, uint accumulatedEarned, uint lockReward, uint lockRewardReleased) {\n', '        UserInfo storage user = userInfo[_account];\n', '        amount = user.amount;\n', '        rewardDebt = user.rewardDebt[_pid];\n', '        accumulatedEarned = user.accumulatedEarned[_pid];\n', '        lockReward = user.lockReward[_pid];\n', '        lockRewardReleased = user.lockRewardReleased[_pid];\n', '    }\n', '\n', '    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external override _lock_ {\n', '        require(finalized, "!fnl");\n', '\n', '        uint rewardTotal = totalSupply();\n', '        uint _exitFee = bmul(poolAmountIn, exitFee);\n', '        uint pAiAfterExitFee = bsub(poolAmountIn, _exitFee);\n', '        uint ratio = bdiv(pAiAfterExitFee, rewardTotal);\n', '        require(ratio != 0, "erMApr");\n', '\n', '        uint _externalShares = balanceOf(msg.sender);\n', '        if (_externalShares < poolAmountIn) {\n', '            uint _withdrawShares = bsub(poolAmountIn, _externalShares);\n', '            uint _stakedShares = userInfo[msg.sender].amount;\n', '            require(_stakedShares >= _withdrawShares, "stk<wdr");\n', '            withdraw(_withdrawShares);\n', '        }\n', '\n', '        _pullPoolShare(msg.sender, poolAmountIn);\n', '        if (_exitFee > 0) {\n', '            _pushPoolShare(factory, _exitFee);\n', '        }\n', '        _burnPoolShare(pAiAfterExitFee);\n', '\n', '        for (uint i = 0; i < _tokens.length; i++) {\n', '            address t = _tokens[i];\n', '            uint bal = _records[t].balance;\n', '            uint tokenAmountOut = bmul(ratio, bal);\n', '            require(tokenAmountOut != 0, "erMApr");\n', '            require(tokenAmountOut >= minAmountsOut[i], "<limO");\n', '            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\n', '            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n', '            _pushUnderlying(t, msg.sender, tokenAmountOut);\n', '        }\n', '    }\n', '\n', '    function updateReward() public {\n', '        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n', '        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n', '            updateReward(_pid);\n', '        }\n', '    }\n', '\n', '    function updateReward(uint8 _pid) public {\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n', '        uint _endRewardBlockApplicable = block.number > rewardPool.endRewardBlock ? rewardPool.endRewardBlock : block.number;\n', '        if (_endRewardBlockApplicable > rewardPool.lastRewardBlock) {\n', '            uint lpSupply = balanceOf(address(this));\n', '            if (lpSupply > 0) {\n', '                uint _numBlocks = _endRewardBlockApplicable.sub(rewardPool.lastRewardBlock);\n', '                uint _incRewardPerShare = _numBlocks.mul(rewardPool.rewardPerBlock).mul(1e18).div(lpSupply);\n', '                rewardPool.accRewardPerShare = rewardPool.accRewardPerShare.add(_incRewardPerShare);\n', '            }\n', '            rewardPool.lastRewardBlock = _endRewardBlockApplicable;\n', '        }\n', '    }\n', '}\n', '\n', 'contract FaaSPoolCreatorLite {\n', '    function newBPool() external returns (BPoolLite) {\n', '        return new FaaSPoolLite(msg.sender);\n', '    }\n', '}']