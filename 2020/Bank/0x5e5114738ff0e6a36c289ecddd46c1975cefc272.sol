['// File: contracts\\modules\\Ownable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\interfaces\\IVolatility.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'interface IVolatility {\n', '    function calculateIv(uint32 underlying,uint8 optType,uint256 expiration,uint256 currentPrice,uint256 strikePrice)external view returns (uint256);\n', '}\n', 'contract ImportVolatility is Ownable{\n', '    IVolatility internal _volatility;\n', '    function getVolatilityAddress() public view returns(address){\n', '        return address(_volatility);\n', '    }\n', '    function setVolatilityAddress(address volatility)public onlyOwner{\n', '        _volatility = IVolatility(volatility);\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\SmallNumbers.sol\n', '\n', 'pragma solidity =0.5.16;\n', '    /**\n', '     * @dev Implementation of a Fraction number operation library.\n', '     */\n', 'library SmallNumbers {\n', '//    using Fraction for fractionNumber;\n', '    int256 constant private sqrtNum = 1<<120;\n', '    int256 constant private shl = 80;\n', '    uint8 constant private PRECISION   = 32;  // fractional bits\n', '    uint256 constant public FIXED_ONE = uint256(1) << PRECISION; // 0x100000000\n', '    int256 constant public FIXED_64 = 1 << 64; // 0x100000000\n', '    uint256 constant private FIXED_TWO = uint256(2) << PRECISION; // 0x200000000\n', '    int256 constant private FIXED_SIX = int256(6) << PRECISION; // 0x200000000\n', '    uint256 constant private MAX_VAL   = uint256(1) << (256 - PRECISION); // 0x0000000100000000000000000000000000000000000000000000000000000000\n', '\n', '    /**\n', '     * @dev Standard normal cumulative distribution function\n', '     */\n', '    function normsDist(int256 xNum) internal pure returns (int256) {\n', '        bool _isNeg = xNum<0;\n', '        if (_isNeg) {\n', '            xNum = -xNum;\n', '        }\n', '        if (xNum > FIXED_SIX){\n', '            return _isNeg ? 0 : int256(FIXED_ONE);\n', '        } \n', '        // constant int256 b1 = 1371733226;\n', '        // constant int256 b2 = -1531429783;\n', '        // constant int256 b3 = 7651389478;\n', '        // constant int256 b4 = -7822234863;\n', '        // constant int256 b5 = 5713485167;\n', '        //t = 1.0/(1.0 + p*x);\n', '        int256 p = 994894385;\n', '        int256 t = FIXED_64/(((p*xNum)>>PRECISION)+int256(FIXED_ONE));\n', '        //double val = 1 - (1/(Math.sqrt(2*Math.PI))  * Math.exp(-1*Math.pow(a, 2)/2)) * (b1*t + b2 * Math.pow(t,2) + b3*Math.pow(t,3) + b4 * Math.pow(t,4) + b5 * Math.pow(t,5) );\n', '        //1.0 - (-x * x / 2.0).exp()/ (2.0*pi()).sqrt() * t * (a1 + t * (-0.356563782 + t * (1.781477937 + t * (-1.821255978 + t * 1.330274429)))) ;\n', '        xNum=xNum*xNum/int256(FIXED_TWO);\n', '        xNum = int256(7359186145390886912/fixedExp(uint256(xNum)));\n', '        int256 tt = t;\n', '        int256 All = 1371733226*tt;\n', '        tt = (tt*t)>>PRECISION;\n', '        All += -1531429783*tt;\n', '        tt = (tt*t)>>PRECISION;\n', '        All += 7651389478*tt;\n', '        tt = (tt*t)>>PRECISION;\n', '        All += -7822234863*tt;\n', '        tt = (tt*t)>>PRECISION;\n', '        All += 5713485167*tt;\n', '        xNum = (xNum*All)>>64;\n', '        if (!_isNeg) {\n', '            xNum = uint64(FIXED_ONE) - xNum;\n', '        }\n', '        return xNum;\n', '    }\n', '    function pow(uint256 _x,uint256 _y) internal pure returns (uint256){\n', '        _x = (ln(_x)*_y)>>PRECISION;\n', '        return fixedExp(_x);\n', '    }\n', '\n', '    //This is where all your gas goes, sorry\n', '    //Not sorry, you probably only paid 1 gwei\n', '    function sqrt(uint x) internal pure returns (uint y) {\n', '        x = x << PRECISION;\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '    function ln(uint256 _x)  internal pure returns (uint256) {\n', '        return fixedLoge(_x);\n', '    }\n', '        /**\n', '        input range: \n', '            [0x100000000,uint256_max]\n', '        output range:\n', '            [0, 0x9b43d4f8d6]\n', '\n', '        This method asserts outside of bounds\n', '\n', '    */\n', '    function fixedLoge(uint256 _x) internal pure returns (uint256 logE) {\n', '        /*\n', '        Since `fixedLog2_min` output range is max `0xdfffffffff` \n', '        (40 bits, or 5 bytes), we can use a very large approximation\n', '        for `ln(2)`. This one is used since it’s the max accuracy \n', '        of Python `ln(2)`\n', '\n', '        0xb17217f7d1cf78 = ln(2) * (1 << 56)\n', '        \n', '        */\n', '        //Cannot represent negative numbers (below 1)\n', '        require(_x >= FIXED_ONE,"loge function input is too small");\n', '\n', '        uint256 _log2 = fixedLog2(_x);\n', '        logE = (_log2 * 0xb17217f7d1cf78) >> 56;\n', '    }\n', '\n', '    /**\n', '        Returns log2(x >> 32) << 32 [1]\n', '        So x is assumed to be already upshifted 32 bits, and \n', '        the result is also upshifted 32 bits. \n', '        \n', '        [1] The function returns a number which is lower than the \n', '        actual value\n', '\n', '        input-range : \n', '            [0x100000000,uint256_max]\n', '        output-range: \n', '            [0,0xdfffffffff]\n', '\n', '        This method asserts outside of bounds\n', '\n', '    */\n', '    function fixedLog2(uint256 _x) internal pure returns (uint256) {\n', '        // Numbers below 1 are negative. \n', '        require( _x >= FIXED_ONE,"Log2 input is too small");\n', '\n', '        uint256 hi = 0;\n', '        while (_x >= FIXED_TWO) {\n', '            _x >>= 1;\n', '            hi += FIXED_ONE;\n', '        }\n', '\n', '        for (uint8 i = 0; i < PRECISION; ++i) {\n', '            _x = (_x * _x) / FIXED_ONE;\n', '            if (_x >= FIXED_TWO) {\n', '                _x >>= 1;\n', '                hi += uint256(1) << (PRECISION - 1 - i);\n', '            }\n', '        }\n', '\n', '        return hi;\n', '    }\n', '    function exp(int256 _x)internal pure returns (uint256){\n', '        bool _isNeg = _x<0;\n', '        if (_isNeg) {\n', '            _x = -_x;\n', '        }\n', '        uint256 value = fixedExp(uint256(_x));\n', '        if (_isNeg){\n', '            return uint256(FIXED_64) / value;\n', '        }\n', '        return value;\n', '    }\n', '    /**\n', '        fixedExp is a ‘protected’ version of `fixedExpUnsafe`, which \n', '        asserts instead of overflows\n', '    */\n', '    function fixedExp(uint256 _x) internal pure returns (uint256) {\n', '        require(_x <= 0x386bfdba29,"exp function input is overflow");\n', '        return fixedExpUnsafe(_x);\n', '    }\n', '       /**\n', '        fixedExp \n', '        Calculates e^x according to maclauren summation:\n', '\n', '        e^x = 1+x+x^2/2!...+x^n/n!\n', '\n', '        and returns e^(x>>32) << 32, that is, upshifted for accuracy\n', '\n', '        Input range:\n', '            - Function ok at    <= 242329958953 \n', '            - Function fails at >= 242329958954\n', '\n', '        This method is is visible for testcases, but not meant for direct use. \n', ' \n', '        The values in this method been generated via the following python snippet: \n', '\n', '        def calculateFactorials():\n', '            “”"Method to print out the factorials for fixedExp”“”\n', '\n', '            ni = []\n', '            ni.append( 295232799039604140847618609643520000000) # 34!\n', '            ITERATIONS = 34\n', '            for n in range( 1,  ITERATIONS,1 ) :\n', '                ni.append(math.floor(ni[n - 1] / n))\n', '            print( “\\n        “.join([“xi = (xi * _x) >> PRECISION;\\n        res += xi * %s;” % hex(int(x)) for x in ni]))\n', '\n', '    */\n', '    function fixedExpUnsafe(uint256 _x) internal pure returns (uint256) {\n', '    \n', '        uint256 xi = FIXED_ONE;\n', '        uint256 res = 0xde1bc4d19efcac82445da75b00000000 * xi;\n', '\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xde1bc4d19efcb0000000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x6f0de268cf7e58000000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x2504a0cd9a7f72000000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x9412833669fdc800000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x1d9d4d714865f500000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x4ef8ce836bba8c0000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xb481d807d1aa68000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x16903b00fa354d000000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x281cdaac677b3400000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x402e2aad725eb80000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x5d5a6c9f31fe24000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x7c7890d442a83000000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x9931ed540345280000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xaf147cf24ce150000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xbac08546b867d000000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xbac08546b867d00000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xafc441338061b8000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x9c3cabbc0056e000000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x839168328705c80000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x694120286c04a0000;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x50319e98b3d2c400;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x3a52a1e36b82020;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x289286e0fce002;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x1b0c59eb53400;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x114f95b55400;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0xaa7210d200;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x650139600;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x39b78e80;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x1fd8080;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x10fbc0;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x8c40;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x462;\n', '        xi = (xi * _x) >> PRECISION;\n', '        res += xi * 0x22;\n', '\n', '        return res / 0xde1bc4d19efcac82445da75b00000000;\n', '    }  \n', '}\n', '\n', '// File: contracts\\optionsPrice.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '/**\n', ' * @title Options price calculation contract.\n', " * @dev calculate options' price, using B-S formulas.\n", ' *\n', ' */\n', 'contract OptionsPrice is ImportVolatility{\n', '    // one year seconds\n', '    uint256 constant internal Year = 365 days;\n', '    int256 constant public FIXED_ONE = 1 << 32; // 0x100000000\n', '    uint256 internal ratioR2 = 4<<32;\n', '    \n', '    /**\n', '     * @dev constructor function , setting contract address.\n', '     */  \n', '    constructor (address ivContract) public{\n', '        setVolatilityAddress(ivContract);\n', '    }\n', '\n', '    /**\n', "     * @dev calculate option's price using B_S formulas\n", '     * @param currentPrice current underlying price.\n', "     * @param strikePrice option's strike price.\n", "     * @param expiration option's expiration left time. Equal option's expiration timestamp - now.\n", "     * @param underlying option's underlying id, 1 for BTC, 2 for ETH.\n", "     * @param optType option's type, 0 for CALL, 2 for PUT.\n", '     */\n', '    function getOptionsPrice(uint256 currentPrice, uint256 strikePrice, uint256 expiration,uint32 underlying,uint8 optType)public view returns (uint256){\n', '         uint256 _iv = _volatility.calculateIv(underlying,optType,expiration,currentPrice,strikePrice);\n', '        if (optType == 0) {\n', '            return callOptionsPrice(currentPrice,strikePrice,expiration,_iv);\n', '        }else if (optType == 1){\n', '            return putOptionsPrice(currentPrice,strikePrice,expiration,_iv);\n', '        }else{\n', '            require(optType<2," Must input 0 for call option or 1 for put option");\n', '        }\n', '    }\n', '    /**\n', "     * @dev calculate option's price using B_S formulas with user input iv.\n", '     * @param currentPrice current underlying price.\n', "     * @param strikePrice option's strike price.\n", "     * @param expiration option's expiration left time. Equal option's expiration timestamp - now.\n", '     * @param _iv user input iv numerator.\n', "     * @param optType option's type, 0 for CALL, 2 for PUT.\n", '     */\n', '    function getOptionsPrice_iv(uint256 currentPrice, uint256 strikePrice, uint256 expiration,\n', '            uint256 _iv,uint8 optType)public view returns (uint256){\n', '        if (optType == 0) {\n', '            return callOptionsPrice(currentPrice,strikePrice,expiration,_iv);\n', '        }else if (optType == 1){\n', '            return putOptionsPrice(currentPrice,strikePrice,expiration,_iv);\n', '        }else{\n', '            require(optType<2," Must input 0 for call option or 1 for put option");\n', '        }\n', '    }\n', '    /**\n', '     * @dev An auxiliary function, calculate parameter d1 and d2 in B_S formulas.\n', '     * @param currentPrice current underlying price.\n', "     * @param strikePrice option's strike price.\n", "     * @param expiration option's expiration left time. Equal option's expiration timestamp - now.\n", '     * @param derta implied volatility value in B-S formulas.\n', '     */\n', '    function calculateD1D2(uint256 currentPrice, uint256 strikePrice, uint256 expiration, uint256 derta) \n', '            internal pure returns (int256,int256) {\n', '        int256 d1 = 0;\n', '        if (currentPrice > strikePrice){\n', '            d1 = int256(SmallNumbers.fixedLoge((currentPrice<<32)/strikePrice));\n', '        }else if (currentPrice<strikePrice){\n', '            d1 = -int256(SmallNumbers.fixedLoge((strikePrice<<32)/currentPrice));\n', '        }\n', '        uint256 derta2 = (derta*derta)>>33;//0.5*derta^2\n', '        derta2 = derta2*expiration/Year;\n', '        d1 = d1+int256(derta2);\n', '        derta2 = SmallNumbers.sqrt(derta2*2);\n', '        d1 = (d1<<32)/int256(derta2);\n', '        return (d1, d1 - int256(derta2));\n', '    }\n', '    /**\n', '     * @dev An auxiliary function, calculate put option price using B_S formulas.\n', '     * @param currentPrice current underlying price.\n', "     * @param strikePrice option's strike price.\n", "     * @param expiration option's expiration left time. Equal option's expiration timestamp - now.\n", '     * @param derta implied volatility value in B-S formulas.\n', '     */\n', '    //L*pow(e,-rT)*(1-N(d2)) - S*(1-N(d1))\n', '    function putOptionsPrice(uint256 currentPrice, uint256 strikePrice, uint256 expiration, uint256 derta) \n', '                internal pure returns (uint256) {\n', '       (int256 d1, int256 d2) = calculateD1D2(currentPrice, strikePrice, expiration, derta);\n', '        d1 = SmallNumbers.normsDist(d1);\n', '        d2 = SmallNumbers.normsDist(d2);\n', '        d1 = (FIXED_ONE - d1)*int256(currentPrice);\n', '        d2 = (FIXED_ONE - d2)*int256(strikePrice);\n', '        d1 = d2 - d1;\n', '        int256 minPrice = int256(currentPrice)*12884902;\n', '        return (d1>minPrice) ? uint256(d1>>32) : currentPrice*3/1000;\n', '    }\n', '    /**\n', '     * @dev An auxiliary function, calculate call option price using B_S formulas.\n', '     * @param currentPrice current underlying price.\n', "     * @param strikePrice option's strike price.\n", "     * @param expiration option's expiration left time. Equal option's expiration timestamp - now.\n", '     * @param derta implied volatility value in B-S formulas.\n', '     */\n', '    //S*N(d1)-L*pow(e,-rT)*N(d2)\n', '    function callOptionsPrice(uint256 currentPrice, uint256 strikePrice, uint256 expiration, uint256 derta) \n', '                internal pure returns (uint256) {\n', '       (int256 d1, int256 d2) = calculateD1D2(currentPrice, strikePrice, expiration, derta);\n', '        d1 = SmallNumbers.normsDist(d1);\n', '        d2 = SmallNumbers.normsDist(d2);\n', '        d1 = d1*int256(currentPrice)-d2*int256(strikePrice);\n', '        int256 minPrice = int256(currentPrice)*12884902;\n', '        return (d1>minPrice) ? uint256(d1>>32) : currentPrice*3/1000;\n', '    }\n', '    function calOptionsPriceRatio(uint256 selfOccupied,uint256 totalOccupied,uint256 totalCollateral) public pure returns (uint256){\n', '        //r1 + 0.5\n', '        if (selfOccupied*2<=totalOccupied){\n', '            return 4294967296;\n', '        }\n', '        uint256 r1 = (selfOccupied<<32)/totalOccupied-2147483648;\n', '        uint256 r2 = (totalOccupied<<32)/totalCollateral*2;\n', '        //r1*r2*1.5\n', '        r1 = (r1*r2)>>32;\n', '        return ((r1*r1*r1)>>64)*3+4294967296;\n', '//        return SmallNumbers.pow(r1,r2);\n', '    }\n', '}']