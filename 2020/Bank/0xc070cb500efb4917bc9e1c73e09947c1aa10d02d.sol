['pragma solidity ^0.5.0;\n', '\n', 'contract Context {\n', '    constructor () internal {}\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () internal {\n', '        _owner = _msgSender();\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'contract Governor is Context {\n', '    address private _guardian;\n', '\n', '    event GovernorTransferred(address indexed previousGuardian, address indexed newGuardian);\n', '\n', '    constructor () internal {\n', '        _guardian = _msgSender();\n', '        emit GovernorTransferred(address(0), _guardian);\n', '    }\n', '\n', '    function governor() public view returns (address) {\n', '        return _guardian;\n', '    }\n', '\n', '    modifier onlyGovernor() {\n', '        require(isGovernor(), "Caller is not the governor!");\n', '        _;\n', '    }\n', '\n', '    function isGovernor() public view returns (bool) {\n', '        return _msgSender() == _guardian;\n', '    }\n', '\n', '    function transferGovernor(address newGovernor) public onlyGovernor {\n', '        _transferGovernor(newGovernor);\n', '    }\n', '\n', '    function _transferGovernor(address newGovernor) internal {\n', '        require(newGovernor != address(0), "New governor is the zero address!");\n', '        emit GovernorTransferred(_guardian, newGovernor);\n', '        _guardian = newGovernor;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function mint(address account, uint256 amount) external;\n', '\n', '    function burn(uint256 amount) external;\n', '}\n', '\n', 'pragma solidity ^0.5.5;\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        assembly {codehash := extcodehash(account)}\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '        (bool success,) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) {// Return data is optional\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', 'interface IUniswapV2Router02 {\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '}\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', 'contract FairStockEquity is Ownable, Governor {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    struct businessModule {\n', '        address moduleAddress;\n', '        uint256 running;\n', '        uint256 mintRatio;\n', '    }\n', '\n', '    mapping(address => businessModule) public modulePool;\n', '\n', '    IERC20[3] public tokens;\n', '\n', '    uint256 public startTime;\n', '    uint256 constant public stockIssueLimit = 10000 * (10 ** 18);\n', '    uint256 public stockIssueRemain = stockIssueLimit;\n', '    uint256 constant public tokenLockRatio = 5000;\n', '    uint256 constant public tokenMainRatio = 10;\n', '    mapping(address => uint256) public stockShares;\n', '    uint256 public balanceMainSH = 0;\n', '    uint256 public balanceLockSH = 0;\n', '\n', '    mapping(address => bool) public depositTokens;\n', '    mapping(address => mapping(address => uint256)) public depositPool;\n', '\n', '    uint256 public profitPercentMT;\n', '    uint256 public balanceMainMT = 0;\n', '    uint256 public mintDegree;\n', '\n', '    uint256 public profitPercentPJ;\n', '    uint256 public balanceMainPJ = 0;\n', '\n', '    IUniswapV2Router02 public uniswapV2Router02;\n', '    address public dataSource;\n', '    uint256 public gasFeeForCallback;\n', '\n', '    event eSetToken(address tokenAddress, bool running);\n', '    event eSetUniswapV2Router02(address previousUniswapV2Router02, address newUniswapV2Router02);\n', '    event eSetDataSource(address previousDataSource, address newDataSource);\n', '    event eSetProfitPercentMT(uint256 previousProfitPercentMT, uint256 newProfitPercentMT);\n', '    event eSetProfitPercentPJ(uint256 previousProfitPercentTeam, uint256 newProfitPercentTeam);\n', '    event eSetMintDegree(uint256 previousMintDegree, uint256 newMintDegree);\n', '    event eSetModule(address previousModuleAddress, address newModuleAddress,\n', '        uint256 previousModuleRunning, uint256 newModuleRunning,\n', '        uint256 previousMintRatio, uint256 newMintRatio);\n', '\n', '    event eInvest(address indexed user, uint256 stockAmount, uint256 timestamp);\n', '    event eReduce(address indexed user, uint256 stockAmount, uint256 timestamp);\n', '    event eBusiness(address indexed module, address indexed user,\n', '        uint256 payAmount, uint256 bonusAmount, uint256 mintShare, uint256 profitMT, uint256 timestamp);\n', '    event eDepositLPT(address indexed user, address token, uint256 lptAmount, uint256 timestamp);\n', '    event eWithdrawLPT(address indexed user, address token, uint256 lptAmount, uint256 timestamp);\n', '    event eWithdrawMT(address indexed user, uint256 gasForCallback, uint256 timestamp);\n', '    event eWithdrawCallback(address indexed user, uint256 indexed tx, uint256 amount, uint256 timestamp);\n', '    event eSwap(uint256 amountIn, uint256 timestamp);\n', '\n', '    constructor (address _mainToken, address _lockToken, address _stockToken,\n', '        address _uniswapV2Router02, address _dataSource, uint256 _startTime) public {\n', '\n', '        tokens = [IERC20(_mainToken),\n', '        IERC20(_lockToken),\n', '        IERC20(_stockToken)];\n', '\n', '        setUniswapV2Router02(_uniswapV2Router02);\n', '        setDataSource(_dataSource);\n', '\n', '        setGasFeeForCallback(10 ** 16);\n', '        setMintDegree(10000);\n', '        setProfitPercentMT(5000);\n', '        setProfitPercentPJ(500);\n', '        startTime = _startTime;\n', '    }\n', '\n', '    function() external payable {\n', '    }\n', '\n', '    modifier onlyDataSource() {\n', '        require(_msgSender() == dataSource, "NOT DataSource!");\n', '        _;\n', '    }\n', '\n', '    modifier checkStart(){\n', '        require(block.timestamp > startTime, "not start");\n', '        _;\n', '    }\n', '\n', '    function setStartTime(uint256 _startTime)\n', '    public onlyOwner {\n', '        require(_startTime > startTime, "wrong time!");\n', '        startTime = _startTime;\n', '    }\n', '\n', '    function setLPT(address _tokenAddress, bool _running)\n', '    public onlyOwner {\n', '        depositTokens[_tokenAddress] = _running;\n', '        emit eSetToken(_tokenAddress, _running);\n', '    }\n', '\n', '    function setGasFeeForCallback(uint256 _gasFeeForCallback)\n', '    public onlyOwner {\n', '        gasFeeForCallback = _gasFeeForCallback;\n', '    }\n', '\n', '    function setUniswapV2Router02(address _newUniswapV2Router02)\n', '    public onlyOwner {\n', '        emit eSetUniswapV2Router02(address(uniswapV2Router02), _newUniswapV2Router02);\n', '        uniswapV2Router02 = IUniswapV2Router02(_newUniswapV2Router02);\n', '    }\n', '\n', '    function setDataSource(address _newDataSource)\n', '    public onlyOwner {\n', '        emit eSetDataSource(dataSource, _newDataSource);\n', '        dataSource = _newDataSource;\n', '    }\n', '\n', '    function setModule(address moduleAddress, uint256 moduleRunning, uint256 mintRatio)\n', '    public onlyOwner {\n', '        emit eSetModule(modulePool[moduleAddress].moduleAddress, moduleAddress,\n', '            modulePool[moduleAddress].running, moduleRunning,\n', '            modulePool[moduleAddress].mintRatio, mintRatio);\n', '        modulePool[moduleAddress] = businessModule(moduleAddress, moduleRunning, mintRatio);\n', '    }\n', '\n', '    function setMintDegree(uint256 _mintDegree)\n', '    public onlyOwner {\n', '        emit eSetMintDegree(mintDegree, _mintDegree);\n', '        mintDegree = _mintDegree;\n', '    }\n', '\n', '    function setProfitPercentMT(uint256 _profitPercent)\n', '    public onlyGovernor {\n', '        emit eSetProfitPercentMT(profitPercentMT, _profitPercent);\n', '        profitPercentMT = _profitPercent;\n', '    }\n', '\n', '    function setProfitPercentPJ(uint256 _profitPercent)\n', '    public onlyGovernor {\n', '        emit eSetProfitPercentPJ(profitPercentPJ, _profitPercent);\n', '        profitPercentPJ = _profitPercent;\n', '    }\n', '\n', '    function getCostAmount(uint256 stockAmount)\n', '    public view\n', '    returns (uint256 _mainTokenAmount, uint256 _lockTokenAmount, uint256 _stockTokenAmount){\n', '        uint256 stockTotalSupply = stockIssueLimit.sub(stockIssueRemain);\n', '        if (stockTotalSupply > 0) {\n', '            return (\n', '            stockAmount.mul(balanceMainSH).div(stockTotalSupply),\n', '            _getLockAmount(stockAmount),\n', '            stockAmount.mul(tokens[2].balanceOf(address(this))).div(stockTotalSupply));\n', '        }\n', '        return (\n', '        stockAmount.mul(tokenMainRatio),\n', '        _getLockAmount(stockAmount),\n', '        0);\n', '    }\n', '\n', '    function _getLockAmount(uint256 stockAmount)\n', '    internal pure\n', '    returns (uint256 _lockTokenAmount){\n', '        return stockAmount.mul(tokenLockRatio);\n', '    }\n', '\n', '    function _getMintShareAmount(uint256 _availableAmount, uint256 _mintRatio)\n', '    internal view returns (uint256 _mintShare){\n', '        return _availableAmount.mul(_mintRatio).mul(mintDegree).div(1000000);\n', '    }\n', '\n', '    function invest(uint256 stockAmount)\n', '    public checkStart {\n', '        require(stockAmount > 0, "Cannot invest 0");\n', '        require(stockIssueRemain >= stockAmount, "Have no enough stock!");\n', '        (uint256 _mainTokenAmount,uint256 _lockTokenAmount,uint256 _stockTokenAmount) = getCostAmount(stockAmount);\n', '\n', '        stockIssueRemain = stockIssueRemain.sub(stockAmount);\n', '\n', '        balanceMainSH = balanceMainSH.add(_mainTokenAmount);\n', '        balanceLockSH = balanceLockSH.add(_lockTokenAmount);\n', '\n', '        tokens[0].safeTransferFrom(_msgSender(), address(this), _mainTokenAmount);\n', '        tokens[1].safeTransferFrom(_msgSender(), address(this), _lockTokenAmount);\n', '        if (_stockTokenAmount > 0) {\n', '            tokens[2].safeTransferFrom(_msgSender(), address(this), _stockTokenAmount);\n', '        }\n', '\n', '        stockShares[_msgSender()] = stockShares[_msgSender()].add(stockAmount);\n', '\n', '        emit eInvest(_msgSender(), stockAmount, block.timestamp);\n', '    }\n', '\n', '    function reduceShare(uint256 stockAmount)\n', '    public checkStart {\n', '        require(stockAmount > 0, "Cannot reduce 0");\n', '        require(stockShares[_msgSender()] >= stockAmount, "You have no enough stock!");\n', '\n', '        (uint256 mainTokeAmount, uint256 lockTokenAmount,uint256 stockTokenAmount) = getCostAmount(stockAmount);\n', '\n', '        stockShares[_msgSender()] = stockShares[_msgSender()].sub(stockAmount);\n', '        stockIssueRemain = stockIssueRemain.add(stockAmount);\n', '        balanceMainSH = balanceMainSH.sub(mainTokeAmount);\n', '        balanceLockSH = balanceLockSH.sub(lockTokenAmount);\n', '\n', '        tokens[0].safeTransfer(_msgSender(), mainTokeAmount);\n', '        tokens[1].safeTransfer(_msgSender(), lockTokenAmount);\n', '        if (stockTokenAmount > 0) {\n', '            tokens[2].safeTransfer(_msgSender(), stockTokenAmount);\n', '        }\n', '\n', '        emit eReduce(_msgSender(), stockAmount, block.timestamp);\n', '    }\n', '\n', '    function business(address user, uint256 payAmount, uint256 availableAmount, uint256 bonusAmount)\n', '    public checkStart {\n', '        require(payAmount > 0, "Illegal payAmount!");\n', '        businessModule memory module = modulePool[_msgSender()];\n', '        require(module.moduleAddress != address(0), "Illegal module!");\n', '        require(module.running == 1, "Module is not running!");\n', '\n', '        tokens[0].safeTransferFrom(_msgSender(), address(this), payAmount);\n', '\n', '        uint256 profitSum = payAmount.mul(module.mintRatio).div(100);\n', '        uint256 profitMT = 0;\n', '        uint256 profitPJ = 0;\n', '        profitMT = profitSum.mul(profitPercentMT).div(10000);\n', '        profitPJ = profitSum.mul(profitPercentPJ).div(10000);\n', '\n', '        require(balanceMainSH.add(payAmount) >= profitMT.add(profitPJ).add(bonusAmount), "Insufficient Balance!");\n', '\n', '        balanceMainMT = balanceMainMT.add(profitMT);\n', '        balanceMainPJ = balanceMainPJ.add(profitPJ);\n', '        balanceMainSH = balanceMainSH.add(payAmount).sub(profitMT).sub(profitPJ).sub(bonusAmount);\n', '\n', '        uint256 mintShareAmount = _getMintShareAmount(availableAmount, module.mintRatio);\n', '\n', '        if (bonusAmount > 0) {\n', '            tokens[0].safeTransfer(user, bonusAmount);\n', '        }\n', '        if (mintShareAmount > 0) {\n', '            tokens[2].mint(user, mintShareAmount);\n', '        }\n', '        emit eBusiness(_msgSender(), user, payAmount, bonusAmount, mintShareAmount, profitMT, block.timestamp);\n', '    }\n', '\n', '    function depositLPT(address _token, uint256 _lptAmount)\n', '    public checkStart {\n', '        require(depositTokens[_token], "illegal token");\n', '        require(_lptAmount > 0, "Cannot deposit 0");\n', '        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _lptAmount);\n', '        depositPool[_msgSender()][_token] = depositPool[_msgSender()][_token].add(_lptAmount);\n', '        emit eDepositLPT(_msgSender(), _token, _lptAmount, block.timestamp);\n', '    }\n', '\n', '    function withdrawLPT(address _token, uint256 _lptAmount)\n', '    public checkStart {\n', '        require(_lptAmount > 0, "Cannot withdraw 0");\n', '        require(depositPool[_msgSender()][_token] >= _lptAmount, "Insufficient Balance!");\n', '        depositPool[_msgSender()][_token] = depositPool[_msgSender()][_token].sub(_lptAmount);\n', '        IERC20(_token).safeTransfer(_msgSender(), _lptAmount);\n', '        emit eWithdrawLPT(_msgSender(), _token, _lptAmount, block.timestamp);\n', '    }\n', '\n', '    function withdrawMT()\n', '    public payable checkStart {\n', '        require(msg.value >= gasFeeForCallback, "Insufficient gas fee!");\n', '        Address.toPayable(dataSource).transfer(msg.value);\n', '        emit eWithdrawMT(_msgSender(), msg.value, block.timestamp);\n', '    }\n', '\n', '    function withdrawPJ()\n', '    public onlyOwner checkStart {\n', '        require(balanceMainPJ > 0, "Insufficient Balance!");\n', '        uint256 amount = balanceMainPJ;\n', '        balanceMainPJ = 0;\n', '        tokens[0].safeTransfer(_msgSender(), amount);\n', '    }\n', '\n', '    function withdrawCallback(address _user, uint256 _tx, uint256 _amount)\n', '    public onlyDataSource checkStart {\n', '        require(_amount > 0, "Cannot withdraw 0");\n', '        require(balanceMainMT >= _amount, "Insufficient Balance!");\n', '        balanceMainMT = balanceMainMT.sub(_amount);\n', '        tokens[0].safeTransfer(_user, _amount);\n', '        emit eWithdrawCallback(_user, _tx, _amount, block.timestamp);\n', '    }\n', '\n', '    function swapMainToStock(\n', '        uint256 amountIn,\n', '        uint256 amountOutReduce,\n', '        uint256 deadline)\n', '    public onlyDataSource checkStart {\n', '        require(balanceMainSH > stockIssueLimit &&\n', '            amountIn <= balanceMainSH.sub(stockIssueLimit),\n', '            "Insufficient Balance!");\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(tokens[0]);\n', '        path[1] = address(tokens[2]);\n', '\n', '        uint[] memory amounts = uniswapV2Router02.getAmountsOut(amountIn, path);\n', '        tokens[0].approve(address(uniswapV2Router02), amountIn);\n', '        balanceMainSH = balanceMainSH.sub(amountIn);\n', '\n', '        uniswapV2Router02.swapExactTokensForTokens(\n', '            amountIn, amounts[1].mul(amountOutReduce).div(100),\n', '            path, address(this), deadline);\n', '        emit eSwap(amountIn, block.timestamp);\n', '    }\n', '}']