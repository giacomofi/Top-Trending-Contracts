['pragma solidity 0.7.1;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'abstract contract IERC20 {\n', '    function balanceOf(address who) public virtual view returns (uint);\n', '    function transferFrom(address sender, address recipient, uint amount) external virtual;\n', '    function transfer(address recipient, uint amount) public virtual;\n', '}\n', '\n', 'contract PFIContract{\n', '    using SafeMath for uint256;\n', '    \n', '    modifier onlyOwner{\n', '        require(msg.sender == _owner,"Forbidden");\n', '        _;\n', '    }\n', '    \n', '    address internal _owner;\n', '    \n', '    uint256 internal _ethToPfiPrice = 5000000;              //1ETH = 5 PFI\n', '    uint256 internal _ethToPfiPriceDivided = 1000000;       //ETH to PFI = _ethToPfiPrice / _ethToPfiPriceDivided\n', '    \n', '    address private _pfiTokenContractAddress = 0x6096Ef5A1321e405EdC63D40e9a4C190a7ef1B98;      //PFI Contract\n', '    \n', '    uint256 internal _purchaseEndTime = 1612137600; //2021-02-01 00:00:00\n', '    \n', '    constructor () payable{\n', '        _owner = _msgSender();\n', '    }\n', '    \n', '    function updatePrice(uint256 price) external onlyOwner{\n', '         _ethToPfiPrice = price;\n', '        emit UpdatePfiPrice(price);\n', '    }\n', '    \n', '    function getPrice() external view returns(uint256){\n', '        return _ethToPfiPrice.div(_ethToPfiPriceDivided);\n', '    }\n', '    \n', '    function updatePurchaseEndTime(uint256 endTime) external onlyOwner{\n', '        _purchaseEndTime = endTime;\n', '    }\n', '    \n', '    function getPurchaseEndTime() external view returns(uint256){\n', '        return _purchaseEndTime;\n', '    }\n', '    \n', '    receive () external payable{\n', '         processPurchase();\n', '    }\n', '    \n', '    function processPurchase() internal{\n', '        require(_getNow() < _purchaseEndTime, "Purchase token time is end");\n', '        address sender = _msgSender();\n', '        \n', '        uint256 ethAmount = msg.value;\n', '        \n', '        //Process to pay token for sender\n', '        //Calculate ETH to token price\n', '        uint256 tokenAmount = ethAmount.mul(_ethToPfiPrice).div(_ethToPfiPriceDivided);\n', '        \n', '        IERC20 token = IERC20(_pfiTokenContractAddress);\n', '        require(token.balanceOf(address(this)) >= tokenAmount,"System balance is not enough");\n', '         \n', '        token.transfer(sender, tokenAmount);\n', '        emit Purchase(sender, tokenAmount);\n', '    }\n', '    \n', '    function withdrawEth() external onlyOwner{\n', '        uint256 ethBalance = address(this).balance; \n', "        require(ethBalance > 0,'Balance is zero');\n", '        msg.sender.transfer(ethBalance);\n', '        \n', '        emit WithdrawEth(ethBalance);\n', '    }\n', '    \n', '    function withdrawToken(uint256 amount) external onlyOwner{\n', '        require(amount > 0, "Withdraw amount should be greater than 0");\n', '        \n', '        IERC20 token = IERC20(_pfiTokenContractAddress);\n', '        uint256 tokenBalance = token.balanceOf(address(this));\n', '        require(tokenBalance >= amount, "Balance is not enough");\n', '        \n', '        token.transfer(_msgSender(),amount);\n', '        emit WithdrawToken(amount);\n', '    }\n', '    \n', '    function _getNow() private view returns(uint256){\n', '        return block.timestamp;\n', '    }\n', '    \n', '    function _msgSender() internal view returns(address){\n', '        return msg.sender;\n', '    }\n', '    \n', '    event UpdatePfiPrice(uint256 price);\n', '    event Purchase(address sender, uint256 purchasedAmount);\n', '    event WithdrawEth(uint256 eth);\n', '    event WithdrawToken(uint256 amount);\n', '}\n', '\n', '//SPDX-License-Identifier: MIT']