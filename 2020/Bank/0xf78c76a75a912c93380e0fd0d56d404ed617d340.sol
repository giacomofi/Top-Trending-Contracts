['pragma solidity 0.6.4;\n', '\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    \n', '    function supplyeffect(uint _amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', ' \n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface POWER {\n', '    \n', '   function scaledPower(uint amount) external returns(bool);\n', '   function totalPopping() external view returns (uint256);\n', ' }\n', '\n', 'interface FIRE {\n', '\n', '    function balanceOf(address _user) external view returns (uint256); \n', ' }\n', ' \n', ' \n', 'contract POWERGENERTORS{\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    //======================================EVENTS=========================================//\n', '    event POPCORNEvent(address indexed executioner, address indexed pool, uint amount);\n', '    event DITCHEvent(address indexed executioner, address indexed pool, uint amount);\n', '    event PooppingRewardEvent(address indexed executioner, address indexed pool, uint amount);\n', '\n', '   \n', '     //======================================INTERRACTING MACHINE SECTIONS=========================================//\n', '    address public popcornToken;\n', '    address public fireball;\n', '    address public operator;\n', '    address public powerToken;\n', '    \n', '    bool public _machineReady;\n', '    \n', '    uint256 constant private FLOAT_SCALAR = 2**64;\n', '    uint256 public MINIMUM_POP = 10000000000000000000;\n', '\tuint256 private MIN_POP_DUR = 10 days;\n', '\tuint256 public MIN_FIRE_TO_POP = 1000000000000000000;\n', '\t\n', '\tuint public infocheck;\n', '\t\n', '\tuint actualValue;\n', '    \n', '    struct User {\n', '        \n', '\t\tuint256 popslot;\n', '\t\tint256 scaledPayout;  \n', '\t\tuint256 poptime;\n', '\t}\n', '\n', '\tstruct Info {\n', '\t    \n', '\t\tuint256 totalPopping;\n', '\t\tmapping(address => User) users;\n', '\t\tuint256 scaledPayoutPerToken; //pool balance \n', '\t\taddress admin;\n', '\t}\n', '\t\n', '\tInfo private info;\n', '\t//mapping(address => bool) whitelisted;\n', '\t\n', '\tconstructor() public {\n', '       \n', '\t    info.admin = msg.sender;\n', '\t\t_machineReady = true;\n', '\t\t\n', '\t}\n', '\t\n', '//======================================ADMINSTRATION=========================================//\n', '\n', '\tmodifier onlyCreator() {\n', '        require(msg.sender == info.admin, "Ownable: caller is not the administrator");\n', '        _;\n', '    }\n', '    \n', '    modifier onlypopcornTokenoroperators() {\n', '        require(msg.sender == popcornToken || msg.sender == operator, "Authorization: only authorized contract can call");\n', '        _;\n', '    }\n', '    \n', '    \n', ' \n', '    \n', '\t function machinery(address _popcornToken, address _powertoken, address _fire, address _operator) public onlyCreator returns (bool success) {\n', '\t    \n', '\t    popcornToken = _popcornToken;\n', '        powerToken = _powertoken; //liquidity token\n', '        fireball = _fire;\n', '        operator = _operator;\n', '        \n', '        return true;\n', '    }\n', '    \n', '\n', '\t\n', '\tfunction _minPopAmount(uint256 _number) onlyCreator public {\n', '\t\t\n', '\t\tMINIMUM_POP = _number*1000000000000000000;\n', '\t\t\n', '\t}\n', '\t\n', '\tfunction _minFIRE_TO_POP(uint256 _number) onlyCreator public {\n', '\t\t\n', '\t\tMIN_FIRE_TO_POP = _number*1000000000000000000;\n', '\t\t\n', '\t}\n', '    \n', '    function machineReady(bool _status) public onlyCreator {\n', '\t_machineReady = _status;\n', '    }\n', '    \n', '  \n', '\n', '\tfunction popCorns(uint256 _tokens) external {\n', '\t\t_popcorns(_tokens);\n', '\t}\n', '    \n', '    function DitchCorns(uint256 _tokens) external {\n', '\t\t_ditchcorns(_tokens);\n', '\t}\n', '\t\n', '\n', '\n', '\tfunction totalPopping() public view returns (uint256) {\n', '\t\treturn info.totalPopping;\n', '\t}\n', '\t\n', '    function popslotOf(address _user) public view returns (uint256) {\n', '\t\treturn info.users[_user].popslot;\n', '\t}\n', '\n', '\tfunction cornsOf(address _user) public view returns (uint256) {\n', '\t    \n', '\t   return uint256(int256(info.scaledPayoutPerToken * info.users[_user].popslot) - info.users[_user].scaledPayout) / FLOAT_SCALAR;   \n', '\t    \n', '\t}\n', '\t\n', '\n', '\tfunction userData(address _user) public view \n', '\treturns (uint256 totalCornsPopping, uint256 userpopslot, \n', '\tuint256 usercorns, uint256 userpoptime, int256 scaledPayout) {\n', '\t    \n', '\t\treturn (totalPopping(), popslotOf(_user), cornsOf(_user), info.users[_user].poptime, info.users[_user].scaledPayout);\n', '\t\n', '\t    \n', '\t}\n', '\t\n', '\n', '//======================================ACTION CALLS=========================================//\t\n', '\t\n', '\tfunction _popcorns(uint256 _amount) internal {\n', '\t    \n', '\t    require(_machineReady, "Staking not yet initialized");\n', '\t    require(FIRE(fireball).balanceOf(msg.sender) > MIN_FIRE_TO_POP, "You do not have sufficient fire to pop this corn");\n', '\t    \n', '\t\trequire(IERC20(powerToken).balanceOf(msg.sender) >= _amount, "Insufficient power token balance");\n', '\t\trequire(popslotOf(msg.sender) + _amount >= MINIMUM_POP, "Your amount is lower than the minimum amount allowed to pop");\n', '\t\trequire(IERC20(powerToken).allowance(msg.sender, address(this)) >= _amount, "Not enough allowance given to contract yet to spend by user");\n', '\t\t\n', '\t\tinfo.users[msg.sender].poptime = now;\n', '\t\tinfo.totalPopping += _amount;\n', '\t\tinfo.users[msg.sender].popslot += _amount;\n', '\t\t\n', '\t\tinfo.users[msg.sender].scaledPayout += int256(_amount * info.scaledPayoutPerToken); \n', '\t\tIERC20(powerToken).transferFrom(msg.sender, address(this), _amount);      // Transfer liquidity tokens from the sender to this contract\n', '\t\t\n', '        emit POPCORNEvent(msg.sender, address(this), _amount);\n', '\t}\n', '\t\n', '\t    \n', '\t\n', '\tfunction _ditchcorns(uint256 _amount) internal {\n', '\t    \n', '\t\trequire(popslotOf(msg.sender) >= _amount, "You currently do not have up to that amount popping");\n', '\t\t\n', '\t\tinfo.totalPopping -= _amount;\n', '\t\tinfo.users[msg.sender].popslot -= _amount;\n', '\t\tinfo.users[msg.sender].scaledPayout -= int256(_amount * info.scaledPayoutPerToken);\n', '\t\t\n', '\t\trequire(IERC20(powerToken).transfer(msg.sender, _amount), "Transaction failed");\n', '        emit DITCHEvent(address(this), msg.sender, _amount);\n', '\t\t\n', '\t}\n', '\t\t\n', '\t\t\n', '\tfunction Takecorns() external returns (uint256) {\n', '\t\t    \n', '\t\tuint256 _dividends = cornsOf(msg.sender);\n', '\t\trequire(_dividends >= 0, "you do not have any corn yet");\n', '\t\tinfo.users[msg.sender].scaledPayout += int256(_dividends * FLOAT_SCALAR);\n', '\t\t\n', '\t\trequire(IERC20(popcornToken).transfer(msg.sender, _dividends), "Transaction Failed");    // Transfer dividends to msg.sender\n', '\t\temit PooppingRewardEvent(msg.sender, address(this), _dividends);\n', '\t\t\n', '\t\treturn _dividends;\n', '\t    \n', '\t\t    \n', '\t}\n', '\t\t\n', '\t\t\n', ' \n', '    function scaledPower(uint _amount) external onlypopcornTokenoroperators returns(bool){\n', '            \n', '    \t\tinfo.scaledPayoutPerToken += _amount * FLOAT_SCALAR / info.totalPopping;\n', '    \t\tinfocheck = info.scaledPayoutPerToken;\n', '    \t\treturn true;\n', '            \n', '    }\n', '    \n', '   \n', '        \n', '    function mulDiv (uint x, uint y, uint z) public pure returns (uint) {\n', '              (uint l, uint h) = fullMul (x, y);\n', '              assert (h < z);\n', '              uint mm = mulmod (x, y, z);\n', '              if (mm > l) h -= 1;\n', '              l -= mm;\n', '              uint pow2 = z & -z;\n', '              z /= pow2;\n', '              l /= pow2;\n', '              l += h * ((-pow2) / pow2 + 1);\n', '              uint r = 1;\n', '              r *= 2 - z * r;\n', '              r *= 2 - z * r;\n', '              r *= 2 - z * r;\n', '              r *= 2 - z * r;\n', '              r *= 2 - z * r;\n', '              r *= 2 - z * r;\n', '              r *= 2 - z * r;\n', '              r *= 2 - z * r;\n', '              return l * r;\n', '    }\n', '        \n', '    function fullMul (uint x, uint y) private pure returns (uint l, uint h) {\n', '              uint mm = mulmod (x, y, uint (-1));\n', '              l = x * y;\n', '              h = mm - l;\n', '              if (mm < l) h -= 1;\n', '    }\n', ' \n', '    \n', '}']