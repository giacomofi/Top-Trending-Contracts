['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library ECDSA {\n', '    /**\n', '     * @dev Recover signer address from a message by using their signature\n', '     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '     * @param signature bytes signature, the signature is generated using web3.eth.sign()\n', '     */\n', '    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // Check the signature length\n', '        if (signature.length != 65) {\n', '            return (address(0));\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '\n', '        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        // If the version is correct return the signer address\n', '        if (v != 27 && v != 28) {\n', '            return (address(0));\n', '        } else {\n', '            // solium-disable-next-line arg-overflow\n', '            return ecrecover(hash, v, r, s);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * toEthSignedMessageHash\n', '     * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '     * and hash the result\n', '     */\n', '    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n', '        // 32 is the length in bytes of hash,\n', '        // enforced by the type signature above\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '}\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' * This module is used through inheritance. It will make available the\n', ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n', ' * the functions of your contract. Note that they will not be pausable by\n', ' * simply including this module, only once the modifiers are put in place.\n', ' */\n', 'contract Pausable is Context {\n', '    /**\n', '     * @dev Emitted when the pause is triggered by `account`.\n', '     */\n', '    event Paused(address account);\n', '\n', '    /**\n', '     * @dev Emitted when the pause is lifted by `account`.\n', '     */\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    /**\n', '     * @dev Initializes the contract in unpaused state.\n', '     */\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the contract is paused, and false otherwise.\n', '     */\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused, "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused, "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Triggers stopped state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    function _pause() internal virtual whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(_msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Returns to normal state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    function _unpause() internal virtual whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(_msgSender());\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Configurations is Ownable {\n', '    using SafeMath for uint256;\n', '    uint256 public minFee;\n', '    uint256 public maxFee;\n', '    uint256 public minAmount;\n', '    uint256 public maxAmount;\n', '    uint256 public percentageFee;\n', '    uint256 public collectedFee;\n', '\n', '    address public pauser;\n', '    address public feeAccount;\n', '    address public middleware;\n', '\n', '    string[] public pairs;\n', '    uint256[] public minRate;\n', '    uint256[] public maxRate;\n', '\n', '    uint256 public rateDecimals = 18;\n', '    string public baseCurrency = "GSU";\n', '\n', '    mapping(string => uint8) public pairIndex;\n', '\n', '    event PauserChanged(address pauser);\n', '    event MiddlewareChanged(address middleware);\n', '    event FeeAccountUpdated(address feeAccount);\n', '    event RateUpdated(uint8 pair, uint256 minRate, uint256 maxRate);\n', '    event AmountUpdated(uint256 minAmount, uint256 maxAmount);\n', '    event FeeUpdated(uint256 minFee, uint256 maxFee, uint256 percentageFee);\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the pauser.\n', '     */\n', '    modifier onlyPauser() {\n', '        require(pauser == _msgSender(), "Dex: caller is not the pauser");\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        uint256 _minFee,\n', '        uint256 _maxFee,\n', '        uint256 _percentageFee,\n', '        uint256 _minAmount,\n', '        uint256 _maxAmount,\n', '        uint256[] memory _minRate,\n', '        uint256[] memory _maxRate,\n', '        address _feeAccount,\n', '        address _middleware\n', '    ) public {\n', '        require(_feeAccount != address(0x0));\n', '        collectedFee = 0;\n', '        minFee = _minFee;\n', '        maxFee = _maxFee;\n', '        minRate = _minRate;\n', '        maxRate = _maxRate;\n', '        minAmount = _minAmount;\n', '        maxAmount = _maxAmount;\n', '        percentageFee = _percentageFee;\n', '        setfeeAccount(_feeAccount);\n', '        setMiddleware(_middleware);\n', '        setPauser(_msgSender());\n', '        pairs.push("GSU/ETH");\n', '        pairs.push("ETH/GSU");\n', '        pairs.push("GSU/USDT");\n', '        pairs.push("USDT/GSU");\n', '        pairIndex["GSU/ETH"] = 0;\n', '        pairIndex["ETH/GSU"] = 1;\n', '        pairIndex["GSU/USDT"] = 2;\n', '        pairIndex["USDT/GSU"] = 3;\n', '    }\n', '\n', '    function setMinFee(uint256 _minFee) external onlyOwner returns (bool) {\n', '        require(_minFee <= maxFee);\n', '        minFee = _minFee;\n', '        emit FeeUpdated(minFee, maxFee, percentageFee);\n', '        return true;\n', '    }\n', '\n', '    function setMaxFee(uint256 _maxFee) external onlyOwner returns (bool) {\n', '        require(_maxFee >= minFee);\n', '        maxFee = _maxFee;\n', '        emit FeeUpdated(minFee, maxFee, percentageFee);\n', '        return true;\n', '    }\n', '\n', '    function setPercentageFee(uint256 _percentageFee)\n', '        external\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        percentageFee = _percentageFee;\n', '        emit FeeUpdated(minFee, maxFee, percentageFee);\n', '        return true;\n', '    }\n', '\n', '    function setfeeAccount(address _feeAccount)\n', '        public\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        require(_feeAccount != address(0x0));\n', '\n', '        feeAccount = _feeAccount;\n', '        emit FeeAccountUpdated(feeAccount);\n', '        return true;\n', '    }\n', '\n', '    function setMiddleware(address _middleware)\n', '        public\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        require(\n', '            _middleware != address(0x0),\n', '            "[Dex] middleware is ZERO Address"\n', '        );\n', '        middleware = _middleware;\n', '        emit MiddlewareChanged(middleware);\n', '        return true;\n', '    }\n', '\n', '    function setPauser(address _pauser) public onlyOwner returns (bool) {\n', '        require(_pauser != address(0x0), "[Dex] pauser is ZERO Address");\n', '        pauser = _pauser;\n', '        emit PauserChanged(pauser);\n', '        return true;\n', '    }\n', '\n', '    function collectFee(uint256 _fee) internal returns (bool) {\n', '        collectedFee = collectedFee.add(_fee);\n', '        return true;\n', '    }\n', '\n', '    function claimFee(uint256 _fee) internal returns (bool) {\n', '        collectedFee = collectedFee.sub(_fee);\n', '        return true;\n', '    }\n', '\n', '    function setMinRate(uint8 pair, uint256 rate)\n', '        public\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        require(rate != 0);\n', '        minRate[pair] = rate;\n', '        emit RateUpdated(pair, minRate[pair], maxRate[pair]);\n', '        return true;\n', '    }\n', '\n', '    function setMaxRate(uint8 pair, uint256 rate)\n', '        public\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        require(rate >= minRate[pair]);\n', '        maxRate[pair] = rate;\n', '        emit RateUpdated(pair, minRate[pair], maxRate[pair]);\n', '        return true;\n', '    }\n', '\n', '    function setMinAmount(uint256 amount) public onlyOwner returns (bool) {\n', '        require(amount != 0);\n', '        minAmount = amount;\n', '        emit AmountUpdated(minAmount, maxAmount);\n', '        return true;\n', '    }\n', '\n', '    function setMaxAmount(uint256 amount) public onlyOwner returns (bool) {\n', '        require(amount >= minAmount);\n', '        maxAmount = amount;\n', '        emit AmountUpdated(minAmount, maxAmount);\n', '        return true;\n', '    }\n', '}\n', '\n', 'interface ILIQUIDITY {\n', '    function balanceOf(string calldata symbol) external view returns (uint256);\n', '\n', '    function contractAddress(string calldata symbol)\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    function transfer(\n', '        string calldata symbol,\n', '        address payable recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '}\n', '\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '}\n', '\n', 'contract Dex is Ownable, Pausable, Configurations {\n', '    using SafeMath for uint256;\n', '    using ECDSA for bytes32;\n', '\n', '    ILIQUIDITY public liquidityContract;\n', '\n', '    event FeeWithdrawn(address to, uint256 amount);\n', '    event LiquidityContractUpdated(ILIQUIDITY liquidityContract);\n', '    event Swap(\n', '        address indexed sender,\n', '        string buy,\n', '        string sell,\n', '        uint256 buyAmount,\n', '        uint256 sellAmount,\n', '        uint256 rate,\n', '        uint256 fee\n', '    );\n', '\n', '    constructor(\n', '        uint256 _minFee,\n', '        uint256 _maxFee,\n', '        uint256 _percentageFee,\n', '        uint256 _minAmount,\n', '        uint256 _maxAmount,\n', '        uint256[] memory _minRate,\n', '        uint256[] memory _maxRate,\n', '        address _feeAccount,\n', '        address _middleware,\n', '        ILIQUIDITY _liquidity\n', '    )\n', '        public\n', '        Configurations(\n', '            _minFee,\n', '            _maxFee,\n', '            _percentageFee,\n', '            _minAmount,\n', '            _maxAmount,\n', '            _minRate,\n', '            _maxRate,\n', '            _feeAccount,\n', '            _middleware\n', '        )\n', '    {\n', '        setLiquidity(_liquidity);\n', '    }\n', '\n', '    // Reject incoming ethers\n', '    receive() external payable {\n', '        revert();\n', '    }\n', '\n', '    // swap currencies\n', '    function swap(\n', '        string calldata buy,\n', '        string calldata sell,\n', '        uint256 amount,\n', '        uint256 rate,\n', '        uint32 expireTime,\n', '        bytes calldata signature\n', '    ) external payable whenNotPaused returns (bool) {\n', '        if (\n', '            keccak256(bytes(buy)) == keccak256(bytes(baseCurrency)) &&\n', '            keccak256(bytes(sell)) == keccak256(bytes("ETH"))\n', '        ) {\n', '            require(\n', '                _beforeSwap(buy, sell, msg.value, rate, expireTime, signature)\n', '            );\n', '            return swapETHForGSU(rate);\n', '        }\n', '\n', '        require(msg.value == 0, "[Dex] ethers are not accepted");\n', '        require(_beforeSwap(buy, sell, amount, rate, expireTime, signature));\n', '\n', '        if (\n', '            keccak256(bytes(buy)) == keccak256(bytes("ETH")) &&\n', '            keccak256(bytes(sell)) == keccak256(bytes(baseCurrency))\n', '        ) {\n', '            return swapGSUForETH(amount, rate);\n', '        } else {\n', '            return swapTokens(buy, sell, amount, rate);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Pauses swap.\n', '     *\n', '     * See {Pausable-_pause}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the `PAUSER_ROLE`.\n', '     */\n', '    function pause() external onlyPauser {\n', '        _pause();\n', '    }\n', '\n', '    /**\n', '     * @dev Unpauses swap.\n', '     *\n', '     * See {Pausable-_unpause}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the `PAUSER_ROLE`.\n', '     */\n', '    function unpause() external onlyPauser {\n', '        _unpause();\n', '    }\n', '\n', '    function withdrawFee(uint256 _fee) external onlyOwner returns (bool) {\n', '        require(_fee <= collectedFee);\n', '\n', '        require(\n', '            liquidityContract.transfer(baseCurrency, payable(feeAccount), _fee)\n', '        );\n', '\n', '        require(claimFee(_fee), "[Dex] unable to update collected fee");\n', '\n', '        emit FeeWithdrawn(feeAccount, _fee);\n', '\n', '        return true;\n', '    }\n', '\n', '    function setLiquidity(ILIQUIDITY _liquidity)\n', '        public\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        require(\n', '            _liquidity != ILIQUIDITY(address(0x0)),\n', '            "[Dex] liquidityContract is ZERO Address"\n', '        );\n', '        liquidityContract = _liquidity;\n', '        emit LiquidityContractUpdated(liquidityContract);\n', '        return true;\n', '    }\n', '\n', '    function _beforeSwap(\n', '        string memory buy,\n', '        string memory sell,\n', '        uint256 amount,\n', '        uint256 rate,\n', '        uint32 expireTime,\n', '        bytes memory signature\n', '    ) private view returns (bool) {\n', '        require(verifySigner(buy, sell, amount, rate, expireTime, signature));\n', '        require(verifySwap(buy, sell, amount, rate, expireTime));\n', '        return true;\n', '    }\n', '\n', '    function swapETHForGSU(uint256 rate) private returns (bool) {\n', '        uint256 amountBase = (swapAmount("GSU", "ETH", msg.value, rate));\n', '\n', '        (uint256 fee, uint256 netAmount) = chargeFee(amountBase);\n', '\n', '        payable(address(liquidityContract)).transfer(msg.value);\n', '        liquidityContract.transfer("GSU", _msgSender(), netAmount);\n', '        emit Swap(_msgSender(), "GSU", "ETH", netAmount, msg.value, rate, fee);\n', '        return true;\n', '    }\n', '\n', '    function swapGSUForETH(uint256 amount, uint256 rate)\n', '        private\n', '        returns (bool)\n', '    {\n', '        require(_moveTokensToLiquidity("GSU", amount));\n', '\n', '        (uint256 fee, uint256 netAmount) = chargeFee(amount);\n', '\n', '        uint256 amountWei = (swapAmount("ETH", "GSU", netAmount, rate));\n', '\n', '        require(\n', '            liquidityContract.transfer("ETH", _msgSender(), amountWei),\n', '            "[Dex] error in token tranfer"\n', '        );\n', '\n', '        emit Swap(_msgSender(), "ETH", "GSU", amountWei, amount, rate, fee);\n', '        return true;\n', '    }\n', '\n', '    function swapTokens(\n', '        string memory buy,\n', '        string memory sell,\n', '        uint256 amount,\n', '        uint256 rate\n', '    ) private returns (bool) {\n', '        uint256 fee;\n', '        uint256 buyAmount;\n', '\n', '        require(_moveTokensToLiquidity(sell, amount));\n', '\n', '        //if baseCurrency is received deduct fee directly from amount\n', '        if (keccak256(bytes(sell)) == keccak256(bytes(baseCurrency))) {\n', '            (uint256 _fee, uint256 netAmount) = chargeFee(amount);\n', '            buyAmount = (swapAmount(buy, sell, netAmount, rate));\n', '            fee = _fee;\n', '        } else {\n', '            //else convert amount to baseCurrency then deduct fee\n', '            (fee, buyAmount) = chargeFee((swapAmount(buy, sell, amount, rate)));\n', '        }\n', '\n', '        // tranfer buyAmount to sender.\n', '        require(\n', '            liquidityContract.transfer(buy, _msgSender(), buyAmount),\n', '            "[Dex] error in token tranfer"\n', '        );\n', '\n', '        emit Swap(_msgSender(), buy, sell, buyAmount, amount, rate, fee);\n', '\n', '        return true;\n', '    }\n', '\n', '    function _moveTokensToLiquidity(string memory currency, uint256 amount)\n', '        private\n', '        returns (bool)\n', '    {\n', '        address _contractAddress = contractAddress(currency);\n', '        require(\n', '            IERC20(_contractAddress).transferFrom(\n', '                _msgSender(),\n', '                address(liquidityContract),\n', '                amount\n', '            ),\n', '            "[Dex] error in tranferFrom"\n', '        );\n', '        return true;\n', '    }\n', '\n', '    function chargeFee(uint256 amount)\n', '        internal\n', '        returns (uint256 fee, uint256 netAmount)\n', '    {\n', '        uint256 _fee = calculateFee(amount);\n', '        uint256 _amount = amount.sub(_fee);\n', '        collectFee(_fee);\n', '        return (_fee, _amount);\n', '    }\n', '\n', '    function verifySwap(\n', '        string memory buy,\n', '        string memory sell,\n', '        uint256 amount,\n', '        uint256 rate,\n', '        uint32 expireTime\n', '    ) public view whenNotPaused returns (bool) {\n', '        require(expireTime > block.timestamp, "[Dex] rate is expired");\n', '        require(\n', '            rate >= minRate[pairId(buy, sell)],\n', '            "[Dex] rate is less than minRate"\n', '        );\n', '        require(\n', '            rate <= maxRate[pairId(buy, sell)],\n', '            "[Dex] rate is greater than maxRate"\n', '        );\n', '\n', '        uint256 _amount = toBaseCurrency(sell, amount, rate);\n', '        require(_amount >= minAmount, "[Dex] amount is less than minAmount");\n', '        require(_amount <= maxAmount, "[Dex] amount is greater than maxAmount");\n', '        require(liquidity(buy) >= _amount, "[Dex] Not enough liquidity");\n', '\n', '        return true;\n', '    }\n', '\n', '    function pairId(string memory buy, string memory sell)\n', '        private\n', '        view\n', '        returns (uint8)\n', '    {\n', '        string memory _pair = string(abi.encodePacked(buy, "/", sell));\n', '        return pairIndex[_pair];\n', '    }\n', '\n', '    function toBaseCurrency(\n', '        string memory from,\n', '        uint256 amount,\n', '        uint256 rate\n', '    ) private view returns (uint256) {\n', '        if (keccak256(bytes(from)) == keccak256(bytes(baseCurrency))) {\n', '            return amount;\n', '        } else {\n', '            return swapAmount("GSU", from, amount, rate);\n', '        }\n', '    }\n', '\n', '    function swapAmount(\n', '        string memory buy,\n', '        string memory sell,\n', '        uint256 amount,\n', '        uint256 rate\n', '    ) private view returns (uint256) {\n', '        uint256 exponent = (rateDecimals.add(decimals(buy))).sub(\n', '            decimals(sell)\n', '        );\n', '        return (amount.mul(10**exponent)).div(rate);\n', '    }\n', '\n', '    function verifySigner(\n', '        string memory buy,\n', '        string memory sell,\n', '        uint256 amount,\n', '        uint256 rate,\n', '        uint32 expireTime,\n', '        bytes memory signature\n', '    ) public view returns (bool) {\n', '        address signer = keccak256(\n', '            abi.encodePacked(buy, sell, amount, rate, expireTime)\n', '        )\n', '            .recover(signature);\n', '\n', '        require(middleware == signer, "[Dex] signer is not middleware");\n', '\n', '        return true;\n', '    }\n', '\n', '    function decimals(string memory symbol) public view returns (uint256) {\n', '        if (keccak256(bytes(symbol)) == keccak256(bytes("ETH"))) return 18;\n', '        else {\n', '            address contractAddress = liquidityContract.contractAddress(symbol);\n', '            return IERC20(contractAddress).decimals();\n', '        }\n', '    }\n', '\n', '    function contractAddress(string memory symbol)\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return liquidityContract.contractAddress(symbol);\n', '    }\n', '\n', '    function liquidity(string memory symbol) public view returns (uint256) {\n', '        return liquidityContract.balanceOf(symbol);\n', '    }\n', '\n', '    function calculateFee(uint256 baseAmount) public view returns (uint256) {\n', '        uint256 divisor = uint256(100).mul((10**decimals(baseCurrency)));\n', '        uint256 _fee = (baseAmount.mul(percentageFee)).div(divisor);\n', '\n', '        if (_fee < minFee) {\n', '            _fee = minFee;\n', '        } else if (_fee > maxFee) {\n', '            _fee = maxFee;\n', '        }\n', '        return _fee;\n', '    }\n', '\n', '    function destroy() external onlyOwner {\n', '        selfdestruct(payable(owner()));\n', '    }\n', '}']