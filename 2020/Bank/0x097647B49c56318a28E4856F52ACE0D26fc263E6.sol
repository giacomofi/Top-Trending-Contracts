['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-15\n', '*/\n', '\n', 'pragma solidity 0.5.12;\n', '\n', 'interface IHandler {\n', '    function deposit(address _token, uint256 _amount)\n', '        external\n', '        returns (uint256);\n', '\n', '    function withdraw(address _token, uint256 _amount)\n', '        external\n', '        returns (uint256);\n', '\n', '    function getRealBalance(address _token) external returns (uint256);\n', '\n', '    function getRealLiquidity(address _token) external returns (uint256);\n', '\n', '    function getBalance(address _token) external view returns (uint256);\n', '\n', '    function getLiquidity(address _token) external view returns (uint256);\n', '\n', '    function paused() external view returns (bool);\n', '\n', '    function tokenIsEnabled(address _underlyingToken)\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', 'contract DSAuthority {\n', '    function canCall(\n', '        address src,\n', '        address dst,\n', '        bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority(address indexed authority);\n', '    event LogSetOwner(address indexed owner);\n', '    event OwnerUpdate(address indexed owner, address indexed newOwner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority public authority;\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    // Warning: you should absolutely sure you want to give up authority!!!\n', '    function disableOwnership() public onlyOwner {\n', '        owner = address(0);\n', '        emit OwnerUpdate(msg.sender, owner);\n', '    }\n', '\n', '    function transferOwnership(address newOwner_) public onlyOwner {\n', '        require(newOwner_ != owner, "TransferOwnership: the same owner.");\n', '        newOwner = newOwner_;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(\n', '            msg.sender == newOwner,\n', '            "AcceptOwnership: only new owner do this."\n', '        );\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0x0);\n', '    }\n', '\n', '    ///[snow] guard is Authority who inherit DSAuth.\n', '    function setAuthority(DSAuthority authority_) public onlyOwner {\n', '        authority = authority_;\n', '        emit LogSetAuthority(address(authority));\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(isOwner(msg.sender), "ds-auth-non-owner");\n', '        _;\n', '    }\n', '\n', '    function isOwner(address src) internal view returns (bool) {\n', '        return bool(src == owner);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig), "ds-auth-unauthorized");\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, address(this), sig);\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y > 0, "ds-math-div-overflow");\n', '        z = x / y;\n', '    }\n', '}\n', '\n', 'contract Dispatcher is DSAuth {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * @dev List all handler contract address.\n', '     */\n', '    address[] public handlers;\n', '\n', '    address public defaultHandler;\n', '\n', '    /**\n', '     * @dev Deposit ratio of each handler contract.\n', '     *      Notice: the sum of all deposit ratio should be 1000000.\n', '     */\n', '    mapping(address => uint256) public proportions;\n', '\n', '    uint256 public constant totalProportion = 1000000;\n', '\n', '    /**\n', '     * @dev map: handlerAddress -> true/false,\n', '     *      Whether the handler has been added or not.\n', '     */\n', '    mapping(address => bool) public isHandlerActive;\n', '\n', '    /**\n', '     * @dev Set original handler contract and its depoist ratio.\n', '     *      Notice: the sum of all deposit ratio should be 1000000.\n', '     * @param _handlers The original support handler contract.\n', '     * @param _proportions The original depoist ratio of support handler.\n', '     */\n', '    constructor(address[] memory _handlers, uint256[] memory _proportions)\n', '        public\n', '    {\n', '        setHandlers(_handlers, _proportions);\n', '    }\n', '\n', '    /**\n', '     * @dev Sort handlers in descending order of the liquidity in each market.\n', '     * @param _data The data to sort, which are the handlers here.\n', '     * @param _left The index of data to start sorting.\n', '     * @param _right The index of data to end sorting.\n', '     * @param _token Asset address.\n', '     */\n', '    function sortByLiquidity(\n', '        address[] memory _data,\n', '        int256 _left,\n', '        int256 _right,\n', '        address _token\n', '    ) internal {\n', '        int256 i = _left;\n', '        int256 j = _right;\n', '        if (i == j) return;\n', '\n', '        uint256 _pivot = IHandler(_data[uint256(_left + (_right - _left) / 2)])\n', '            .getRealLiquidity(_token);\n', '        while (i <= j) {\n', '            while (\n', '                IHandler(_data[uint256(i)]).getRealLiquidity(_token) > _pivot\n', '            ) i++;\n', '            while (\n', '                _pivot > IHandler(_data[uint256(j)]).getRealLiquidity(_token)\n', '            ) j--;\n', '            if (i <= j) {\n', '                (_data[uint256(i)], _data[uint256(j)]) = (\n', '                    _data[uint256(j)],\n', '                    _data[uint256(i)]\n', '                );\n', '                i++;\n', '                j--;\n', '            }\n', '        }\n', '        if (_left < j) sortByLiquidity(_data, _left, j, _token);\n', '        if (i < _right) sortByLiquidity(_data, i, _right, _token);\n', '    }\n', '\n', '    /************************/\n', '    /*** Admin Operations ***/\n', '    /************************/\n', '\n', '    /**\n', '     * @dev Replace current handlers with _handlers and corresponding _proportions,\n', '     * @param _handlers The list of new handlers, the 1st one will act as default hanlder.\n', '     * @param _proportions The list of corresponding proportions.\n', '     */\n', '    function setHandlers(\n', '        address[] memory _handlers,\n', '        uint256[] memory _proportions\n', '    ) private {\n', '        require(\n', '            _handlers.length == _proportions.length && _handlers.length > 0,\n', '            "setHandlers: handlers & proportions should not have 0 or different lengths"\n', '        );\n', '\n', '        // The 1st will act as the default handler.\n', '        defaultHandler = _handlers[0];\n', '\n', '        uint256 _sum = 0;\n', '        for (uint256 i = 0; i < _handlers.length; i++) {\n', '            require(\n', '                _handlers[i] != address(0),\n', '                "setHandlers: handler address invalid"\n', '            );\n', '\n', '            // Do not allow to set the same handler twice\n', '            require(\n', '                !isHandlerActive[_handlers[i]],\n', '                "setHandlers: handler address already exists"\n', '            );\n', '\n', '            _sum = _sum.add(_proportions[i]);\n', '\n', '            handlers.push(_handlers[i]);\n', '            proportions[_handlers[i]] = _proportions[i];\n', '            isHandlerActive[_handlers[i]] = true;\n', '        }\n', '\n', '        // The sum of proportions should be 1000000.\n', '        require(\n', '            _sum == totalProportion,\n', '            "the sum of proportions must be 1000000"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Update proportions of the handlers.\n', '     * @param _handlers List of the handlers to update.\n', '     * @param _proportions List of the corresponding proportions to update.\n', '     */\n', '    function updateProportions(\n', '        address[] memory _handlers,\n', '        uint256[] memory _proportions\n', '    ) public auth {\n', '        require(\n', '            _handlers.length == _proportions.length &&\n', '                handlers.length == _proportions.length,\n', '            "updateProportions: handlers & proportions must match the current length"\n', '        );\n', '\n', '        uint256 _sum = 0;\n', '        for (uint256 i = 0; i < _proportions.length; i++) {\n', '            for (uint256 j = 0; j < i; j++) {\n', '                require(\n', '                    _handlers[i] != _handlers[j],\n', '                    "updateProportions: input handler contract address is duplicate"\n', '                );\n', '            }\n', '            require(\n', '                isHandlerActive[_handlers[i]],\n', '                "updateProportions: the handler contract address does not exist"\n', '            );\n', '            _sum = _sum.add(_proportions[i]);\n', '\n', '            proportions[_handlers[i]] = _proportions[i];\n', '        }\n', '\n', '        // The sum of `proportions` should be 1000000.\n', '        require(\n', '            _sum == totalProportion,\n', '            "the sum of proportions must be 1000000"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Add new handler.\n', '     *      Notice: the corresponding proportion of the new handler is 0.\n', '     * @param _handlers List of the new handlers to add.\n', '     */\n', '    function addHandlers(address[] memory _handlers) public auth {\n', '        for (uint256 i = 0; i < _handlers.length; i++) {\n', '            require(\n', '                !isHandlerActive[_handlers[i]],\n', '                "addHandlers: handler address already exists"\n', '            );\n', '            require(\n', '                _handlers[i] != address(0),\n', '                "addHandlers: handler address invalid"\n', '            );\n', '\n', '            handlers.push(_handlers[i]);\n', '            proportions[_handlers[i]] = 0;\n', '            isHandlerActive[_handlers[i]] = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Reset handlers and corresponding proportions, will delete the old ones.\n', '     * @param _handlers The list of new handlers.\n', '     * @param _proportions the list of corresponding proportions.\n', '     */\n', '    function resetHandlers(\n', '        address[] calldata _handlers,\n', '        uint256[] calldata _proportions\n', '    ) external auth {\n', '        address[] memory _oldHandlers = handlers;\n', '        for (uint256 i = 0; i < _oldHandlers.length; i++) {\n', '            delete proportions[_oldHandlers[i]];\n', '            delete isHandlerActive[_oldHandlers[i]];\n', '        }\n', '        defaultHandler = address(0);\n', '        delete handlers;\n', '\n', '        setHandlers(_handlers, _proportions);\n', '    }\n', '\n', '    /**\n', '     * @dev Update the default handler.\n', '     * @param _defaultHandler The default handler to update.\n', '     */\n', '    function updateDefaultHandler(address _defaultHandler) public auth {\n', '        require(\n', '            _defaultHandler != address(0),\n', '            "updateDefaultHandler: New defaultHandler should not be zero address"\n', '        );\n', '\n', '        address _oldDefaultHandler = defaultHandler;\n', '        require(\n', '            _defaultHandler != _oldDefaultHandler,\n', '            "updateDefaultHandler: Old and new address cannot be the same."\n', '        );\n', '\n', '        handlers[0] = _defaultHandler;\n', '        proportions[_defaultHandler] = proportions[_oldDefaultHandler];\n', '        isHandlerActive[_defaultHandler] = true;\n', '\n', '        delete proportions[_oldDefaultHandler];\n', '        delete isHandlerActive[_oldDefaultHandler];\n', '\n', '        defaultHandler = _defaultHandler;\n', '    }\n', '\n', '    /***********************/\n', '    /*** User Operations ***/\n', '    /***********************/\n', '\n', '    /**\n', '     * @dev Query the current handlers and the corresponding proportions.\n', '     * @return Return two arrays, the current handlers,\n', '     *         and the corresponding proportions.\n', '     */\n', '    function getHandlers()\n', '        external\n', '        view\n', '        returns (address[] memory, uint256[] memory)\n', '    {\n', '        address[] memory _handlers = handlers;\n', '        uint256[] memory _proportions = new uint256[](_handlers.length);\n', '        for (uint256 i = 0; i < _proportions.length; i++)\n', '            _proportions[i] = proportions[_handlers[i]];\n', '\n', '        return (_handlers, _proportions);\n', '    }\n', '\n', '    /**\n', '     * @dev According to the proportion, calculate deposit amount for each handler.\n', '     * @param _amount The amount to deposit.\n', '     * @return Return two arrays, the current handlers,\n', '     *         and the corresponding deposit amounts.\n', '     */\n', '    function getDepositStrategy(uint256 _amount)\n', '        external\n', '        view\n', '        returns (address[] memory, uint256[] memory)\n', '    {\n', '        address[] memory _handlers = handlers;\n', '\n', '        uint256[] memory _amounts = new uint256[](_handlers.length);\n', '\n', '        uint256 _sum = 0;\n', '        uint256 _res = _amount;\n', '        uint256 _lastIndex = _amounts.length.sub(1);\n', '        for (uint256 i = 0; ; i++) {\n', '            // Return empty strategy if any handler is paused for abnormal case,\n', '            // resulting further failure with mint and burn\n', '            if (IHandler(_handlers[i]).paused()) {\n', '                delete _handlers;\n', '                delete _amounts;\n', '                break;\n', '            }\n', '\n', '            // The last handler gets the remaining amount without check proportion.\n', '            if (i == _lastIndex) {\n', '                _amounts[i] = _res.sub(_sum);\n', '                break;\n', '            }\n', '\n', '            // Calculate deposit amount according to the proportion,\n', '            _amounts[i] = _res.mul(proportions[_handlers[i]]) / totalProportion;\n', '\n', '            _sum = _sum.add(_amounts[i]);\n', '        }\n', '\n', '        return (_handlers, _amounts);\n', '    }\n', '\n', '    /**\n', '     * @dev Provide a strategy to withdraw, now sort handlers in descending order of the liquidity.\n', '     * @param _token The token to withdraw.\n', '     * @param _amount The amount to withdraw, including exchange fees between tokens.\n', '     * @return Return two arrays, the handlers,\n', '     *         and the corresponding withdraw amount.\n', '     */\n', '    function getWithdrawStrategy(address _token, uint256 _amount)\n', '        external\n', '        returns (address[] memory, uint256[] memory)\n', '    {\n', '        address[] memory _handlers = handlers;\n', '        // Sort handlers in descending order of the liquidity.\n', '        if (_handlers.length > 2)\n', '            sortByLiquidity(\n', '                _handlers,\n', '                int256(1),\n', '                int256(_handlers.length - 1),\n', '                _token\n', '            );\n', '\n', '        uint256[] memory _amounts = new uint256[](_handlers.length);\n', '        uint256 _balance;\n', '        uint256 _res = _amount;\n', '        uint256 _lastIndex = _amounts.length.sub(1);\n', '        for (uint256 i = 0; i < _handlers.length; i++) {\n', '            // Return empty strategy if any handler is paused for abnormal case,\n', '            // resulting further failure with mint and burn\n', '            if (IHandler(_handlers[i]).paused()) {\n', '                delete _handlers;\n', '                delete _amounts;\n', '                break;\n', '            }\n', '\n', '            // Continue to check whether all handlers are unpaused\n', '            if (_res == 0) continue;\n', '\n', '            if (i == _lastIndex) {\n', '                _amounts[i] = _res;\n', '                break;\n', '            }\n', '\n', '            // The maximum amount can be withdrown from market.\n', '            _balance = IHandler(_handlers[i]).getRealLiquidity(_token);\n', '            _amounts[i] = _balance > _res ? _res : _balance;\n', '            _res = _res.sub(_amounts[i]);\n', '        }\n', '\n', '        return (_handlers, _amounts);\n', '    }\n', '}']