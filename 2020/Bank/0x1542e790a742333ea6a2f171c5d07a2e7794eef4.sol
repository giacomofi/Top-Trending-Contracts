['/**\n', ' *Submitted for verification at Etherscan.io on 2020-08-11\n', '*/\n', '\n', 'pragma solidity 0.6.0;\n', '\n', '/**\n', ' * @title Offering contract\n', ' * @dev Offering logic and mining logic\n', ' */\n', 'contract Nest_NToken_OfferMain {\n', '    \n', '    using SafeMath for uint256;\n', '    using address_make_payable for address;\n', '    using SafeERC20 for ERC20;\n', '    \n', '    // Offering data structure\n', '    struct Nest_NToken_OfferPriceData {\n', '        // The unique identifier is determined by the position of the offer in the array, and is converted to each other through a fixed algorithm (toindex(), toaddress())\n', '        address owner;                                  //  Offering owner\n', '        bool deviate;                                   //  Whether it deviates \n', '        address tokenAddress;                           //  The erc20 contract address of the target offer token\n', '        \n', '        uint256 ethAmount;                              //  The ETH amount in the offer list\n', '        uint256 tokenAmount;                            //  The token amount in the offer list\n', '        \n', '        uint256 dealEthAmount;                          //  The remaining number of tradable ETH\n', '        uint256 dealTokenAmount;                        //  The remaining number of tradable tokens\n', '        \n', '        uint256 blockNum;                               //  The block number where the offer is located\n', '        uint256 serviceCharge;                          //  The fee for mining\n', '        // Determine whether the asset has been collected by judging that ethamount, tokenamount, and servicecharge are all 0\n', '    }\n', '    \n', '    Nest_NToken_OfferPriceData [] _prices;                              //  Array used to save offers\n', '    Nest_3_VoteFactory _voteFactory;                                    //  Voting contract\n', '    Nest_3_OfferPrice _offerPrice;                                      //  Price contract\n', '    Nest_NToken_TokenMapping _tokenMapping;                             //  NToken mapping contract\n', '    ERC20 _nestToken;                                                   //  nestToken\n', '    Nest_3_Abonus _abonus;                                              //  Bonus pool\n', '    uint256 _miningETH = 10;                                            //  Offering mining fee ratio\n', '    uint256 _tranEth = 1;                                               //  Taker fee ratio\n', '    uint256 _tranAddition = 2;                                          //  Additional transaction multiple\n', '    uint256 _leastEth = 10 ether;                                       //  Minimum offer of ETH\n', '    uint256 _offerSpan = 10 ether;                                      //  ETH Offering span\n', '    uint256 _deviate = 10;                                              //  Price deviation - 10%\n', '    uint256 _deviationFromScale = 10;                                   //  Deviation from asset scale\n', '    uint256 _ownerMining = 5;                                           //  Creator ratio\n', '    uint256 _afterMiningAmount = 0.4 ether;                             //  Stable period mining amount\n', '    uint32 _blockLimit = 25;                                            //  Block interval upper limit\n', '    \n', '    uint256 _blockAttenuation = 2400000;                                //  Block decay interval\n', '    mapping(uint256 => mapping(address => uint256)) _blockOfferAmount;  //  Block offer times - block number=>token address=>offer fee\n', '    mapping(uint256 => mapping(address => uint256)) _blockMining;       //  Offering block mining amount - block number=>token address=>mining amount\n', '    uint256[10] _attenuationAmount;                                     //  Mining decay list\n', '    \n', '    //  Log token contract address\n', '    event OfferTokenContractAddress(address contractAddress);           \n', '    //  Log offering contract, token address, amount of ETH, amount of ERC20, delayed block, mining fee\n', '    event OfferContractAddress(address contractAddress, address tokenAddress, uint256 ethAmount, uint256 erc20Amount, uint256 continued,uint256 mining);         \n', '    //  Log transaction sender, transaction token, transaction amount, purchase token address, purchase token amount, transaction offering contract address, transaction user address\n', '    event OfferTran(address tranSender, address tranToken, uint256 tranAmount,address otherToken, uint256 otherAmount, address tradedContract, address tradedOwner);        \n', '    //  Log current block, current block mined amount, token address\n', '    event OreDrawingLog(uint256 nowBlock, uint256 blockAmount, address tokenAddress);\n', '    //  Log offering block, token address, token offered times\n', '    event MiningLog(uint256 blockNum, address tokenAddress, uint256 offerTimes);\n', '    \n', '    /**\n', '     * Initialization method\n', '     * @param voteFactory Voting contract address\n', '     **/\n', '    constructor (address voteFactory) public {\n', '        Nest_3_VoteFactory voteFactoryMap = Nest_3_VoteFactory(address(voteFactory));\n', '        _voteFactory = voteFactoryMap;                                                                 \n', '        _offerPrice = Nest_3_OfferPrice(address(voteFactoryMap.checkAddress("nest.v3.offerPrice")));            \n', '        _nestToken = ERC20(voteFactoryMap.checkAddress("nest"));                                                          \n', '        _abonus = Nest_3_Abonus(voteFactoryMap.checkAddress("nest.v3.abonus"));\n', '        _tokenMapping = Nest_NToken_TokenMapping(address(voteFactoryMap.checkAddress("nest.nToken.tokenMapping")));\n', '        \n', '        uint256 blockAmount = 4 ether;\n', '        for (uint256 i = 0; i < 10; i ++) {\n', '            _attenuationAmount[i] = blockAmount;\n', '            blockAmount = blockAmount.mul(8).div(10);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Reset voting contract method\n', '     * @param voteFactory Voting contract address\n', '     **/\n', '    function changeMapping(address voteFactory) public onlyOwner {\n', '        Nest_3_VoteFactory voteFactoryMap = Nest_3_VoteFactory(address(voteFactory));\n', '        _voteFactory = voteFactoryMap;                                                          \n', '        _offerPrice = Nest_3_OfferPrice(address(voteFactoryMap.checkAddress("nest.v3.offerPrice")));      \n', '        _nestToken = ERC20(voteFactoryMap.checkAddress("nest"));                                                   \n', '        _abonus = Nest_3_Abonus(voteFactoryMap.checkAddress("nest.v3.abonus"));\n', '        _tokenMapping = Nest_NToken_TokenMapping(address(voteFactoryMap.checkAddress("nest.nToken.tokenMapping")));\n', '    }\n', '    \n', '    /**\n', '     * Offering method\n', '     * @param ethAmount ETH amount\n', '     * @param erc20Amount Erc20 token amount\n', '     * @param erc20Address Erc20 token address\n', '     **/\n', '    function offer(uint256 ethAmount, uint256 erc20Amount, address erc20Address) public payable {\n', '        require(address(msg.sender) == address(tx.origin), "It can\'t be a contract");\n', '        address nTokenAddress = _tokenMapping.checkTokenMapping(erc20Address);\n', '        require(nTokenAddress != address(0x0));\n', '        //  Judge whether the price deviates\n', '        uint256 ethMining;\n', '        bool isDeviate = comparativePrice(ethAmount,erc20Amount,erc20Address);\n', '        if (isDeviate) {\n', '            require(ethAmount >= _leastEth.mul(_deviationFromScale), "EthAmount needs to be no less than 10 times of the minimum scale");\n', '            ethMining = _leastEth.mul(_miningETH).div(1000);\n', '        } else {\n', '            ethMining = ethAmount.mul(_miningETH).div(1000);\n', '        }\n', '        require(msg.value >= ethAmount.add(ethMining), "msg.value needs to be equal to the quoted eth quantity plus Mining handling fee");\n', '        uint256 subValue = msg.value.sub(ethAmount.add(ethMining));\n', '        if (subValue > 0) {\n', '            repayEth(address(msg.sender), subValue);\n', '        }\n', '        //  Create an offer\n', '        createOffer(ethAmount, erc20Amount, erc20Address,isDeviate, ethMining);\n', '        //  Transfer in offer asset - erc20 to this contract\n', '        ERC20(erc20Address).safeTransferFrom(address(msg.sender), address(this), erc20Amount);\n', '        _abonus.switchToEthForNTokenOffer.value(ethMining)(nTokenAddress);\n', '        //  Mining\n', '        if (_blockOfferAmount[block.number][erc20Address] == 0) {\n', '            uint256 miningAmount = oreDrawing(nTokenAddress);\n', '            Nest_NToken nToken = Nest_NToken(nTokenAddress);\n', '            nToken.transfer(nToken.checkBidder(), miningAmount.mul(_ownerMining).div(100));\n', '            _blockMining[block.number][erc20Address] = miningAmount.sub(miningAmount.mul(_ownerMining).div(100));\n', '        }\n', '        _blockOfferAmount[block.number][erc20Address] = _blockOfferAmount[block.number][erc20Address].add(ethMining);\n', '    }\n', '    \n', '    /**\n', '     * @dev Create offer\n', '     * @param ethAmount Offering ETH amount\n', '     * @param erc20Amount Offering erc20 amount\n', '     * @param erc20Address Offering erc20 address\n', '     **/\n', '    function createOffer(uint256 ethAmount, uint256 erc20Amount, address erc20Address, bool isDeviate, uint256 mining) private {\n', '        // Check offer conditions\n', '        require(ethAmount >= _leastEth, "Eth scale is smaller than the minimum scale");                                                 \n', '        require(ethAmount % _offerSpan == 0, "Non compliant asset span");\n', '        require(erc20Amount % (ethAmount.div(_offerSpan)) == 0, "Asset quantity is not divided");\n', '        require(erc20Amount > 0);\n', '        // Create offering contract\n', '        emit OfferContractAddress(toAddress(_prices.length), address(erc20Address), ethAmount, erc20Amount,_blockLimit,mining);\n', '        _prices.push(Nest_NToken_OfferPriceData(\n', '            msg.sender,\n', '            isDeviate,\n', '            erc20Address,\n', '            \n', '            ethAmount,\n', '            erc20Amount,\n', '            \n', '            ethAmount, \n', '            erc20Amount, \n', '            \n', '            block.number,\n', '            mining\n', '        ));\n', '        // Record price\n', '        _offerPrice.addPrice(ethAmount, erc20Amount, block.number.add(_blockLimit), erc20Address, address(msg.sender));\n', '    }\n', '    \n', '    // Convert offer address into index in offer array\n', '    function toIndex(address contractAddress) public pure returns(uint256) {\n', '        return uint256(contractAddress);\n', '    }\n', '    \n', '    // Convert index in offer array into offer address \n', '    function toAddress(uint256 index) public pure returns(address) {\n', '        return address(index);\n', '    }\n', '    \n', '    /**\n', '     * Withdraw offer assets\n', '     * @param contractAddress Offer address\n', '     **/\n', '    function turnOut(address contractAddress) public {\n', '        require(address(msg.sender) == address(tx.origin), "It can\'t be a contract");\n', '        uint256 index = toIndex(contractAddress);\n', '        Nest_NToken_OfferPriceData storage offerPriceData = _prices[index];\n', '        require(checkContractState(offerPriceData.blockNum) == 1, "Offer status error");\n', '        // Withdraw ETH\n', '        if (offerPriceData.ethAmount > 0) {\n', '            uint256 payEth = offerPriceData.ethAmount;\n', '            offerPriceData.ethAmount = 0;\n', '            repayEth(offerPriceData.owner, payEth);\n', '        }\n', '        // Withdraw erc20\n', '        if (offerPriceData.tokenAmount > 0) {\n', '            uint256 payErc = offerPriceData.tokenAmount;\n', '            offerPriceData.tokenAmount = 0;\n', '            ERC20(address(offerPriceData.tokenAddress)).safeTransfer(address(offerPriceData.owner), payErc);\n', '            \n', '        }\n', '        // Mining settlement\n', '        if (offerPriceData.serviceCharge > 0) {\n', '            mining(offerPriceData.blockNum, offerPriceData.tokenAddress, offerPriceData.serviceCharge, offerPriceData.owner);\n', '            offerPriceData.serviceCharge = 0;\n', '        }\n', '    }\n', '    \n', '    /**\n', '    * @dev Taker order - pay ETH and buy erc20\n', '    * @param ethAmount The amount of ETH of this offer\n', '    * @param tokenAmount The amount of erc20 of this offer\n', '    * @param contractAddress The target offer address\n', '    * @param tranEthAmount The amount of ETH of taker order\n', '    * @param tranTokenAmount The amount of erc20 of taker order\n', '    * @param tranTokenAddress The erc20 address of taker order\n', '    */\n', '    function sendEthBuyErc(uint256 ethAmount, uint256 tokenAmount, address contractAddress, uint256 tranEthAmount, uint256 tranTokenAmount, address tranTokenAddress) public payable {\n', '        require(address(msg.sender) == address(tx.origin), "It can\'t be a contract");\n', '        uint256 serviceCharge = tranEthAmount.mul(_tranEth).div(1000);\n', '        require(msg.value == ethAmount.add(tranEthAmount).add(serviceCharge), "msg.value needs to be equal to the quotation eth quantity plus transaction eth plus");\n', '        require(tranEthAmount % _offerSpan == 0, "Transaction size does not meet asset span");\n', '        \n', '        //  Get the offer data structure\n', '        uint256 index = toIndex(contractAddress);\n', '        Nest_NToken_OfferPriceData memory offerPriceData = _prices[index]; \n', '        //  Check the price, compare the current offer to the last effective price\n', '        bool thisDeviate = comparativePrice(ethAmount,tokenAmount,tranTokenAddress);\n', '        bool isDeviate;\n', '        if (offerPriceData.deviate == true) {\n', '            isDeviate = true;\n', '        } else {\n', '            isDeviate = thisDeviate;\n', '        }\n', '        //  Limit the taker order only be twice the amount of the offer to prevent large-amount attacks\n', '        if (offerPriceData.deviate) {\n', '            //  The taker order deviates  x2\n', '            require(ethAmount >= tranEthAmount.mul(_tranAddition), "EthAmount needs to be no less than 2 times of transaction scale");\n', '        } else {\n', '            if (isDeviate) {\n', '                //  If the taken offer is normal and the taker order deviates x10\n', '                require(ethAmount >= tranEthAmount.mul(_deviationFromScale), "EthAmount needs to be no less than 10 times of transaction scale");\n', '            } else {\n', '                //  If the taken offer is normal and the taker order is normal x2\n', '                require(ethAmount >= tranEthAmount.mul(_tranAddition), "EthAmount needs to be no less than 2 times of transaction scale");\n', '            }\n', '        }\n', '        \n', '        // Check whether the conditions for taker order are satisfied\n', '        require(checkContractState(offerPriceData.blockNum) == 0, "Offer status error");\n', '        require(offerPriceData.dealEthAmount >= tranEthAmount, "Insufficient trading eth");\n', '        require(offerPriceData.dealTokenAmount >= tranTokenAmount, "Insufficient trading token");\n', '        require(offerPriceData.tokenAddress == tranTokenAddress, "Wrong token address");\n', '        require(tranTokenAmount == offerPriceData.dealTokenAmount * tranEthAmount / offerPriceData.dealEthAmount, "Wrong token amount");\n', '        \n', '        // Update the offer information\n', '        offerPriceData.ethAmount = offerPriceData.ethAmount.add(tranEthAmount);\n', '        offerPriceData.tokenAmount = offerPriceData.tokenAmount.sub(tranTokenAmount);\n', '        offerPriceData.dealEthAmount = offerPriceData.dealEthAmount.sub(tranEthAmount);\n', '        offerPriceData.dealTokenAmount = offerPriceData.dealTokenAmount.sub(tranTokenAmount);\n', '        _prices[index] = offerPriceData;\n', '        // Create a new offer\n', '        createOffer(ethAmount, tokenAmount, tranTokenAddress, isDeviate, 0);\n', '        // Transfer in erc20 + offer asset to this contract\n', '        if (tokenAmount > tranTokenAmount) {\n', '            ERC20(tranTokenAddress).safeTransferFrom(address(msg.sender), address(this), tokenAmount.sub(tranTokenAmount));\n', '        } else {\n', '            ERC20(tranTokenAddress).safeTransfer(address(msg.sender), tranTokenAmount.sub(tokenAmount));\n', '        }\n', '\n', '        // Modify price\n', '        _offerPrice.changePrice(tranEthAmount, tranTokenAmount, tranTokenAddress, offerPriceData.blockNum.add(_blockLimit));\n', '        emit OfferTran(address(msg.sender), address(0x0), tranEthAmount, address(tranTokenAddress), tranTokenAmount, contractAddress, offerPriceData.owner);\n', '        \n', '        // Transfer fee\n', '        if (serviceCharge > 0) {\n', '            address nTokenAddress = _tokenMapping.checkTokenMapping(tranTokenAddress);\n', '            _abonus.switchToEth.value(serviceCharge)(nTokenAddress);\n', '        }\n', '    }\n', '    \n', '    /**\n', '    * @dev Taker order - pay erc20 and buy ETH\n', '    * @param ethAmount The amount of ETH of this offer\n', '    * @param tokenAmount The amount of erc20 of this offer\n', '    * @param contractAddress The target offer address\n', '    * @param tranEthAmount The amount of ETH of taker order\n', '    * @param tranTokenAmount The amount of erc20 of taker order\n', '    * @param tranTokenAddress The erc20 address of taker order\n', '    */\n', '    function sendErcBuyEth(uint256 ethAmount, uint256 tokenAmount, address contractAddress, uint256 tranEthAmount, uint256 tranTokenAmount, address tranTokenAddress) public payable {\n', '        require(address(msg.sender) == address(tx.origin), "It can\'t be a contract");\n', '        uint256 serviceCharge = tranEthAmount.mul(_tranEth).div(1000);\n', '        require(msg.value == ethAmount.sub(tranEthAmount).add(serviceCharge), "msg.value needs to be equal to the quoted eth quantity plus transaction handling fee");\n', '        require(tranEthAmount % _offerSpan == 0, "Transaction size does not meet asset span");\n', '        //  Get the offer data structure\n', '        uint256 index = toIndex(contractAddress);\n', '        Nest_NToken_OfferPriceData memory offerPriceData = _prices[index]; \n', '        //  Check the price, compare the current offer to the last effective price\n', '        bool thisDeviate = comparativePrice(ethAmount,tokenAmount,tranTokenAddress);\n', '        bool isDeviate;\n', '        if (offerPriceData.deviate == true) {\n', '            isDeviate = true;\n', '        } else {\n', '            isDeviate = thisDeviate;\n', '        }\n', '        //  Limit the taker order only be twice the amount of the offer to prevent large-amount attacks\n', '        if (offerPriceData.deviate) {\n', '            //  The taker order deviates  x2\n', '            require(ethAmount >= tranEthAmount.mul(_tranAddition), "EthAmount needs to be no less than 2 times of transaction scale");\n', '        } else {\n', '            if (isDeviate) {\n', '                //  If the taken offer is normal and the taker order deviates x10\n', '                require(ethAmount >= tranEthAmount.mul(_deviationFromScale), "EthAmount needs to be no less than 10 times of transaction scale");\n', '            } else {\n', '                //  If the taken offer is normal and the taker order is normal x2\n', '                require(ethAmount >= tranEthAmount.mul(_tranAddition), "EthAmount needs to be no less than 2 times of transaction scale");\n', '            }\n', '        }\n', '        // Check whether the conditions for taker order are satisfied\n', '        require(checkContractState(offerPriceData.blockNum) == 0, "Offer status error");\n', '        require(offerPriceData.dealEthAmount >= tranEthAmount, "Insufficient trading eth");\n', '        require(offerPriceData.dealTokenAmount >= tranTokenAmount, "Insufficient trading token");\n', '        require(offerPriceData.tokenAddress == tranTokenAddress, "Wrong token address");\n', '        require(tranTokenAmount == offerPriceData.dealTokenAmount * tranEthAmount / offerPriceData.dealEthAmount, "Wrong token amount");\n', '        // Update the offer information\n', '        offerPriceData.ethAmount = offerPriceData.ethAmount.sub(tranEthAmount);\n', '        offerPriceData.tokenAmount = offerPriceData.tokenAmount.add(tranTokenAmount);\n', '        offerPriceData.dealEthAmount = offerPriceData.dealEthAmount.sub(tranEthAmount);\n', '        offerPriceData.dealTokenAmount = offerPriceData.dealTokenAmount.sub(tranTokenAmount);\n', '        _prices[index] = offerPriceData;\n', '        // Create a new offer\n', '        createOffer(ethAmount, tokenAmount, tranTokenAddress, isDeviate, 0);\n', '        // Transfer in erc20 + offer asset to this contract\n', '        ERC20(tranTokenAddress).safeTransferFrom(address(msg.sender), address(this), tranTokenAmount.add(tokenAmount));\n', '        // Modify price\n', '        _offerPrice.changePrice(tranEthAmount, tranTokenAmount, tranTokenAddress, offerPriceData.blockNum.add(_blockLimit));\n', '        emit OfferTran(address(msg.sender), address(tranTokenAddress), tranTokenAmount, address(0x0), tranEthAmount, contractAddress, offerPriceData.owner);\n', '        // Transfer fee\n', '        if (serviceCharge > 0) {\n', '            address nTokenAddress = _tokenMapping.checkTokenMapping(tranTokenAddress);\n', '            _abonus.switchToEth.value(serviceCharge)(nTokenAddress);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Offering mining\n', '     * @param ntoken NToken address\n', '     **/\n', '    function oreDrawing(address ntoken) private returns(uint256) {\n', '        Nest_NToken miningToken = Nest_NToken(ntoken);\n', '        (uint256 createBlock, uint256 recentlyUsedBlock) = miningToken.checkBlockInfo();\n', '        uint256 attenuationPointNow = block.number.sub(createBlock).div(_blockAttenuation);\n', '        uint256 miningAmount = 0;\n', '        uint256 attenuation;\n', '        if (attenuationPointNow > 9) {\n', '            attenuation = _afterMiningAmount;\n', '        } else {\n', '            attenuation = _attenuationAmount[attenuationPointNow];\n', '        }\n', '        miningAmount = attenuation.mul(block.number.sub(recentlyUsedBlock));\n', '        miningToken.increaseTotal(miningAmount);\n', '        emit OreDrawingLog(block.number, miningAmount, ntoken);\n', '        return miningAmount;\n', '    }\n', '    \n', '    /**\n', '     * Retrieve mining\n', '     * @param token Token address\n', '     **/\n', '    function mining(uint256 blockNum, address token, uint256 serviceCharge, address owner) private returns(uint256) {\n', '        //  Block mining amount*offer fee/block offer fee\n', '        uint256 miningAmount = _blockMining[blockNum][token].mul(serviceCharge).div(_blockOfferAmount[blockNum][token]);        \n', '        //  Transfer NToken \n', '        Nest_NToken nToken = Nest_NToken(address(_tokenMapping.checkTokenMapping(token)));\n', '        require(nToken.transfer(address(owner), miningAmount), "Transfer failure");\n', '        \n', '        emit MiningLog(blockNum, token,_blockOfferAmount[blockNum][token]);\n', '        return miningAmount;\n', '    }\n', '    \n', '    // Compare order prices\n', '    function comparativePrice(uint256 myEthValue, uint256 myTokenValue, address token) private view returns(bool) {\n', '        (uint256 frontEthValue, uint256 frontTokenValue) = _offerPrice.updateAndCheckPricePrivate(token);\n', '        if (frontEthValue == 0 || frontTokenValue == 0) {\n', '            return false;\n', '        }\n', '        uint256 maxTokenAmount = myEthValue.mul(frontTokenValue).mul(uint256(100).add(_deviate)).div(frontEthValue.mul(100));\n', '        if (myTokenValue <= maxTokenAmount) {\n', '            uint256 minTokenAmount = myEthValue.mul(frontTokenValue).mul(uint256(100).sub(_deviate)).div(frontEthValue.mul(100));\n', '            if (myTokenValue >= minTokenAmount) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    // Check contract status\n', '    function checkContractState(uint256 createBlock) public view returns (uint256) {\n', '        if (block.number.sub(createBlock) > _blockLimit) {\n', '            return 1;\n', '        }\n', '        return 0;\n', '    }\n', '    \n', '    // Transfer ETH\n', '    function repayEth(address accountAddress, uint256 asset) private {\n', '        address payable addr = accountAddress.make_payable();\n', '        addr.transfer(asset);\n', '    }\n', '    \n', '    // View the upper limit of the block interval\n', '    function checkBlockLimit() public view returns(uint256) {\n', '        return _blockLimit;\n', '    }\n', '    \n', '    // View taker fee ratio\n', '    function checkTranEth() public view returns (uint256) {\n', '        return _tranEth;\n', '    }\n', '    \n', '    // View additional transaction multiple\n', '    function checkTranAddition() public view returns(uint256) {\n', '        return _tranAddition;\n', '    }\n', '    \n', '    // View minimum offering ETH\n', '    function checkleastEth() public view returns(uint256) {\n', '        return _leastEth;\n', '    }\n', '    \n', '    // View offering ETH span\n', '    function checkOfferSpan() public view returns(uint256) {\n', '        return _offerSpan;\n', '    }\n', '\n', '    // View block offering amount\n', '    function checkBlockOfferAmount(uint256 blockNum, address token) public view returns (uint256) {\n', '        return _blockOfferAmount[blockNum][token];\n', '    }\n', '    \n', '    // View offering block mining amount\n', '    function checkBlockMining(uint256 blockNum, address token) public view returns (uint256) {\n', '        return _blockMining[blockNum][token];\n', '    }\n', '    \n', '    // View offering mining amount\n', '    function checkOfferMining(uint256 blockNum, address token, uint256 serviceCharge) public view returns (uint256) {\n', '        if (serviceCharge == 0) {\n', '            return 0;\n', '        } else {\n', '            return _blockMining[blockNum][token].mul(serviceCharge).div(_blockOfferAmount[blockNum][token]);\n', '        }\n', '    }\n', '    \n', '    //  View the owner allocation ratio\n', '    function checkOwnerMining() public view returns(uint256) {\n', '        return _ownerMining;\n', '    }\n', '    \n', '    // View the mining decay\n', '    function checkAttenuationAmount(uint256 num) public view returns(uint256) {\n', '        return _attenuationAmount[num];\n', '    }\n', '    \n', '    // Modify taker order fee ratio\n', '    function changeTranEth(uint256 num) public onlyOwner {\n', '        _tranEth = num;\n', '    }\n', '    \n', '    // Modify block interval upper limit\n', '    function changeBlockLimit(uint32 num) public onlyOwner {\n', '        _blockLimit = num;\n', '    }\n', '    \n', '    // Modify additional transaction multiple\n', '    function changeTranAddition(uint256 num) public onlyOwner {\n', '        require(num > 0, "Parameter needs to be greater than 0");\n', '        _tranAddition = num;\n', '    }\n', '    \n', '    // Modify minimum offering ETH\n', '    function changeLeastEth(uint256 num) public onlyOwner {\n', '        require(num > 0, "Parameter needs to be greater than 0");\n', '        _leastEth = num;\n', '    }\n', '    \n', '    // Modify offering ETH span\n', '    function changeOfferSpan(uint256 num) public onlyOwner {\n', '        require(num > 0, "Parameter needs to be greater than 0");\n', '        _offerSpan = num;\n', '    }\n', '    \n', '    // Modify price deviation\n', '    function changekDeviate(uint256 num) public onlyOwner {\n', '        _deviate = num;\n', '    }\n', '    \n', '    // Modify the deviation from scale \n', '    function changeDeviationFromScale(uint256 num) public onlyOwner {\n', '        _deviationFromScale = num;\n', '    }\n', '    \n', '    // Modify the owner allocation ratio\n', '    function changeOwnerMining(uint256 num) public onlyOwner {\n', '        _ownerMining = num;\n', '    }\n', '    \n', '    // Modify the mining decay\n', '    function changeAttenuationAmount(uint256 firstAmount, uint256 top, uint256 bottom) public onlyOwner {\n', '        uint256 blockAmount = firstAmount;\n', '        for (uint256 i = 0; i < 10; i ++) {\n', '            _attenuationAmount[i] = blockAmount;\n', '            blockAmount = blockAmount.mul(top).div(bottom);\n', '        }\n', '    }\n', '    \n', '    // Vote administrators only\n', '    modifier onlyOwner(){\n', '        require(_voteFactory.checkOwners(msg.sender), "No authority");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * Get the number of offers stored in the offer array\n', '     * @return The number of offers stored in the offer array\n', '     **/\n', '    function getPriceCount() view public returns (uint256) {\n', '        return _prices.length;\n', '    }\n', '    \n', '    /**\n', '     * Get offer information according to the index\n', '     * @param priceIndex Offer index\n', '     * @return Offer information\n', '     **/\n', '    function getPrice(uint256 priceIndex) view public returns (string memory) {\n', '        //  The buffer array used to generate the result string\n', '        bytes memory buf = new bytes(500000);\n', '        uint256 index = 0;\n', '        index = writeOfferPriceData(priceIndex, _prices[priceIndex], buf, index);\n', '        // Generate the result string and return\n', '        bytes memory str = new bytes(index);\n', '        while(index-- > 0) {\n', '            str[index] = buf[index];\n', '        }\n', '        return string(str);\n', '    }\n', '    \n', '    /**\n', '     * Search the contract address list of the target account (reverse order)\n', '     * @param start Search forward from the index corresponding to the given contract address (not including the record corresponding to start address)\n', '     * @param count Maximum number of records to return\n', '     * @param maxFindCount The max index to search\n', '     * @param owner Target account address\n', '     * @return Separate the offer records with symbols. use , to divide fields:  \n', '     * uuid,owner,tokenAddress,ethAmount,tokenAmount,dealEthAmount,dealTokenAmount,blockNum,serviceCharge\n', '     **/\n', '    function find(address start, uint256 count, uint256 maxFindCount, address owner) view public returns (string memory) {\n', '        // Buffer array used to generate result string\n', '        bytes memory buf = new bytes(500000);\n', '        uint256 index = 0;\n', '        // Calculate search interval i and end\n', '        uint256 i = _prices.length;\n', '        uint256 end = 0;\n', '        if (start != address(0)) {\n', '            i = toIndex(start);\n', '        }\n', '        if (i > maxFindCount) {\n', '            end = i - maxFindCount;\n', '        }\n', '        // Loop search, write qualified records into buffer\n', '        while (count > 0 && i-- > end) {\n', '            Nest_NToken_OfferPriceData memory price = _prices[i];\n', '            if (price.owner == owner) {\n', '                --count;\n', '                index = writeOfferPriceData(i, price, buf, index);\n', '            }\n', '        }\n', '        // Generate result string and return\n', '        bytes memory str = new bytes(index);\n', '        while(index-- > 0) {\n', '            str[index] = buf[index];\n', '        }\n', '        return string(str);\n', '    }\n', '    \n', '    /**\n', '     * Get the list of offers by page\n', '     * @param offset Skip the first offset records\n', '     * @param count Maximum number of records to return\n', '     * @param order Sort rules. 0 means reverse order, non-zero means positive order\n', '     * @return Separate the offer records with symbols. use , to divide fields: \n', '     * uuid,owner,tokenAddress,ethAmount,tokenAmount,dealEthAmount,dealTokenAmount,blockNum,serviceCharge\n', '     **/\n', '    function list(uint256 offset, uint256 count, uint256 order) view public returns (string memory) {\n', '        \n', '        // Buffer array used to generate result string \n', '        bytes memory buf = new bytes(500000);\n', '        uint256 index = 0;\n', '        \n', '        // Find search interval i and end\n', '        uint256 i = 0;\n', '        uint256 end = 0;\n', '        \n', '        if (order == 0) {\n', '            // Reverse order, in default \n', '            // Calculate search interval i and end\n', '            if (offset < _prices.length) {\n', '                i = _prices.length - offset;\n', '            } \n', '            if (count < i) {\n', '                end = i - count;\n', '            }\n', '            \n', '            // Write records in the target interval into the buffer\n', '            while (i-- > end) {\n', '                index = writeOfferPriceData(i, _prices[i], buf, index);\n', '            }\n', '        } else {\n', '            // Ascending order\n', '            // Calculate the search interval i and end\n', '            if (offset < _prices.length) {\n', '                i = offset;\n', '            } else {\n', '                i = _prices.length;\n', '            }\n', '            end = i + count;\n', '            if(end > _prices.length) {\n', '                end = _prices.length;\n', '            }\n', '            \n', '            // Write the records in the target interval into the buffer\n', '            while (i < end) {\n', '                index = writeOfferPriceData(i, _prices[i], buf, index);\n', '                ++i;\n', '            }\n', '        }\n', '        \n', '        // Generate the result string and return\n', '        bytes memory str = new bytes(index);\n', '        while(index-- > 0) {\n', '            str[index] = buf[index];\n', '        }\n', '        return string(str);\n', '    }   \n', '     \n', '    // Write the offer data into the buffer and return the buffer index\n', '    function writeOfferPriceData(uint256 priceIndex, Nest_NToken_OfferPriceData memory price, bytes memory buf, uint256 index) pure private returns (uint256) {\n', '        \n', '        index = writeAddress(toAddress(priceIndex), buf, index);\n', '        buf[index++] = byte(uint8(44));\n', '        \n', '        index = writeAddress(price.owner, buf, index);\n', '        buf[index++] = byte(uint8(44));\n', '        \n', '        index = writeAddress(price.tokenAddress, buf, index);\n', '        buf[index++] = byte(uint8(44));\n', '        \n', '        index = writeUInt(price.ethAmount, buf, index);\n', '        buf[index++] = byte(uint8(44));\n', '        \n', '        index = writeUInt(price.tokenAmount, buf, index);\n', '        buf[index++] = byte(uint8(44));\n', '       \n', '        index = writeUInt(price.dealEthAmount, buf, index);\n', '        buf[index++] = byte(uint8(44));\n', '        \n', '        index = writeUInt(price.dealTokenAmount, buf, index);\n', '        buf[index++] = byte(uint8(44));\n', '        \n', '        index = writeUInt(price.blockNum, buf, index);\n', '        buf[index++] = byte(uint8(44));\n', '        \n', '        index = writeUInt(price.serviceCharge, buf, index);\n', '        buf[index++] = byte(uint8(44));\n', '        \n', '        return index;\n', '    }\n', '     \n', '    // Convert integer to string in decimal form, write the string into the buffer, and return the buffer index\n', '    function writeUInt(uint256 iv, bytes memory buf, uint256 index) pure public returns (uint256) {\n', '        uint256 i = index;\n', '        do {\n', '            buf[index++] = byte(uint8(iv % 10 +48));\n', '            iv /= 10;\n', '        } while (iv > 0);\n', '        \n', '        for (uint256 j = index; j > i; ++i) {\n', '            byte t = buf[i];\n', '            buf[i] = buf[--j];\n', '            buf[j] = t;\n', '        }\n', '        \n', '        return index;\n', '    }\n', '\n', '    // Convert the address to a hexadecimal string and write it into the buffer, and return the buffer index\n', '    function writeAddress(address addr, bytes memory buf, uint256 index) pure private returns (uint256) {\n', '        \n', '        uint256 iv = uint256(addr);\n', '        uint256 i = index + 40;\n', '        do {\n', '            uint256 w = iv % 16;\n', '            if(w < 10) {\n', '                buf[index++] = byte(uint8(w +48));\n', '            } else {\n', '                buf[index++] = byte(uint8(w +87));\n', '            }\n', '            \n', '            iv /= 16;\n', '        } while (index < i);\n', '        \n', '        i -= 40;\n', '        for (uint256 j = index; j > i; ++i) {\n', '            byte t = buf[i];\n', '            buf[i] = buf[--j];\n', '            buf[j] = t;\n', '        }\n', '        \n', '        return index;\n', '    }\n', '}\n', '\n', '// Price contract\n', 'interface Nest_3_OfferPrice {\n', '    // Add price data\n', '    function addPrice(uint256 ethAmount, uint256 tokenAmount, uint256 endBlock, address tokenAddress, address offerOwner) external;\n', '    // Modify price\n', '    function changePrice(uint256 ethAmount, uint256 tokenAmount, address tokenAddress, uint256 endBlock) external;\n', '    function updateAndCheckPricePrivate(address tokenAddress) external view returns(uint256 ethAmount, uint256 erc20Amount);\n', '}\n', '\n', '// Voting contract\n', 'interface Nest_3_VoteFactory {\n', '    //  Check address\n', '\tfunction checkAddress(string calldata name) external view returns (address contractAddress);\n', '\t// Check whether an administrator\n', '\tfunction checkOwners(address man) external view returns (bool);\n', '}\n', '\n', '// NToken contract\n', 'interface Nest_NToken {\n', '    // Additional issuance\n', '    function increaseTotal(uint256 value) external;\n', '    // Check mining information\n', '    function checkBlockInfo() external view returns(uint256 createBlock, uint256 recentlyUsedBlock);\n', '    // Check creator\n', '    function checkBidder() external view returns(address);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// NToken mapping contract\n', 'interface Nest_NToken_TokenMapping {\n', '    // Check token mapping\n', '    function checkTokenMapping(address token) external view returns (address);\n', '}\n', '\n', '// Bonus pool contract\n', 'interface Nest_3_Abonus {\n', '    function switchToEth(address token) external payable;\n', '    function switchToEthForNTokenOffer(address token) external payable;\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library address_make_payable {\n', '   function make_payable(address x) internal pure returns (address payable) {\n', '      return address(uint160(x));\n', '   }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '    function callOptionalReturn(ERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) {\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}']