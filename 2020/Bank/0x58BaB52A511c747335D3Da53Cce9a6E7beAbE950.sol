['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', 'library BConst {\n', '    uint public constant BONE                     = 10**18;\n', '\n', '    uint public constant MIN_BOUND_TOKENS         = 2;\n', '    uint public constant MAX_BOUND_TOKENS         = 8;\n', '\n', '    uint public constant DEFAULT_FEE              = BONE * 3 / 1000; // 0.3%\n', '    uint public constant MIN_FEE                  = BONE / 10**6;\n', '    uint public constant MAX_FEE                  = BONE / 10;\n', '\n', '    uint public constant DEFAULT_COLLECTED_FEE    = BONE / 2000; // 0.05%\n', '    uint public constant MAX_COLLECTED_FEE        = BONE / 200; // 0.5%\n', '\n', '    uint public constant DEFAULT_EXIT_FEE         = 0;\n', '    uint public constant MAX_EXIT_FEE             = BONE / 1000; // 0.1%\n', '\n', '    uint public constant MIN_WEIGHT               = BONE;\n', '    uint public constant MAX_WEIGHT               = BONE * 50;\n', '    uint public constant MAX_TOTAL_WEIGHT         = BONE * 50;\n', '    uint public constant MIN_BALANCE              = BONE / 10**12;\n', '\n', '    uint public constant DEFAULT_INIT_POOL_SUPPLY = BONE * 100;\n', '    uint public constant MIN_INIT_POOL_SUPPLY     = BONE / 1000;\n', '    uint public constant MAX_INIT_POOL_SUPPLY     = BONE * 10**18;\n', '\n', '    uint public constant MIN_BPOW_BASE            = 1 wei;\n', '    uint public constant MAX_BPOW_BASE            = (2 * BONE) - 1 wei;\n', '    uint public constant BPOW_PRECISION           = BONE / 10**10;\n', '\n', '    uint public constant MAX_IN_RATIO             = BONE / 2;\n', '    uint public constant MAX_OUT_RATIO            = (BONE / 3) + 1 wei;\n', '}\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', 'contract BNum {\n', '\n', '    function btoi(uint a)\n', '    internal pure\n', '    returns (uint)\n', '    {\n', '        return a / BConst.BONE;\n', '    }\n', '\n', '    function bfloor(uint a)\n', '    internal pure\n', '    returns (uint)\n', '    {\n', '        return btoi(a) * BConst.BONE;\n', '    }\n', '\n', '    function badd(uint a, uint b)\n', '    internal pure\n', '    returns (uint)\n', '    {\n', '        uint c = a + b;\n', '        require(c >= a, "add overflow");\n', '        return c;\n', '    }\n', '\n', '    function bsub(uint a, uint b)\n', '    internal pure\n', '    returns (uint)\n', '    {\n', '        (uint c, bool flag) = bsubSign(a, b);\n', '        require(!flag, "sub underflow");\n', '        return c;\n', '    }\n', '\n', '    function bsubSign(uint a, uint b)\n', '    internal pure\n', '    returns (uint, bool)\n', '    {\n', '        if (a >= b) {\n', '            return (a - b, false);\n', '        } else {\n', '            return (b - a, true);\n', '        }\n', '    }\n', '\n', '    function bmul(uint a, uint b)\n', '    internal pure\n', '    returns (uint)\n', '    {\n', '        uint c0 = a * b;\n', '        require(a == 0 || c0 / a == b, "mul overflow");\n', '        uint c1 = c0 + (BConst.BONE / 2);\n', '        require(c1 >= c0, "mul overflow");\n', '        uint c2 = c1 / BConst.BONE;\n', '        return c2;\n', '    }\n', '\n', '    function bdiv(uint a, uint b)\n', '    internal pure\n', '    returns (uint)\n', '    {\n', '        require(b != 0, "div by 0");\n', '        uint c0 = a * BConst.BONE;\n', '        require(a == 0 || c0 / a == BConst.BONE, "div internal"); // bmul overflow\n', '        uint c1 = c0 + (b / 2);\n', '        require(c1 >= c0, "div internal"); //  badd require\n', '        uint c2 = c1 / b;\n', '        return c2;\n', '    }\n', '\n', '    // DSMath.wpow\n', '    function bpowi(uint a, uint n)\n', '    internal pure\n', '    returns (uint)\n', '    {\n', '        uint z = n % 2 != 0 ? a : BConst.BONE;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            a = bmul(a, a);\n', '\n', '            if (n % 2 != 0) {\n', '                z = bmul(z, a);\n', '            }\n', '        }\n', '        return z;\n', '    }\n', '\n', '    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n', '    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n', '    // of approximation of b^0.w\n', '    function bpow(uint base, uint exp)\n', '    internal pure\n', '    returns (uint)\n', '    {\n', '        require(base >= BConst.MIN_BPOW_BASE, "base too low");\n', '        require(base <= BConst.MAX_BPOW_BASE, "base too high");\n', '\n', '        uint whole  = bfloor(exp);\n', '        uint remain = bsub(exp, whole);\n', '\n', '        uint wholePow = bpowi(base, btoi(whole));\n', '\n', '        if (remain == 0) {\n', '            return wholePow;\n', '        }\n', '\n', '        uint partialResult = bpowApprox(base, remain, BConst.BPOW_PRECISION);\n', '        return bmul(wholePow, partialResult);\n', '    }\n', '\n', '    function bpowApprox(uint base, uint exp, uint precision)\n', '    internal pure\n', '    returns (uint)\n', '    {\n', '        // term 0:\n', '        uint a     = exp;\n', '        (uint x, bool xneg)  = bsubSign(base, BConst.BONE);\n', '        uint term = BConst.BONE;\n', '        uint sum   = term;\n', '        bool negative = false;\n', '\n', '\n', '        // term(k) = numer / denom \n', '        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n', '        // each iteration, multiply previous term by (a-(k-1)) * x / k\n', '        // continue until term is less than precision\n', '        for (uint i = 1; term >= precision; i++) {\n', '            uint bigK = i * BConst.BONE;\n', '            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BConst.BONE));\n', '            term = bmul(term, bmul(c, x));\n', '            term = bdiv(term, bigK);\n', '            if (term == 0) break;\n', '\n', '            if (xneg) negative = !negative;\n', '            if (cneg) negative = !negative;\n', '            if (negative) {\n', '                sum = bsub(sum, term);\n', '            } else {\n', '                sum = badd(sum, term);\n', '            }\n', '        }\n', '\n', '        return sum;\n', '    }\n', '\n', '}\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '// Highly opinionated token implementation\n', 'interface IERC20 {\n', '    event Approval(address indexed src, address indexed dst, uint amt);\n', '    event Transfer(address indexed src, address indexed dst, uint amt);\n', '\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address whom) external view returns (uint);\n', '    function allowance(address src, address dst) external view returns (uint);\n', '\n', '    function approve(address dst, uint amt) external returns (bool);\n', '    function transfer(address dst, uint amt) external returns (bool);\n', '    function transferFrom(\n', '        address src, address dst, uint amt\n', '    ) external returns (bool);\n', '}\n', '\n', 'contract BTokenBase is BNum {\n', '\n', '    mapping(address => uint)                   internal _balance;\n', '    mapping(address => mapping(address=>uint)) internal _allowance;\n', '    uint internal _totalSupply;\n', '\n', '    event Approval(address indexed src, address indexed dst, uint amt);\n', '    event Transfer(address indexed src, address indexed dst, uint amt);\n', '\n', '    function _mint(uint amt) internal {\n', '        _balance[address(this)] = badd(_balance[address(this)], amt);\n', '        _totalSupply = badd(_totalSupply, amt);\n', '        emit Transfer(address(0), address(this), amt);\n', '    }\n', '\n', '    function _burn(uint amt) internal {\n', '        require(_balance[address(this)] >= amt, "!bal");\n', '        _balance[address(this)] = bsub(_balance[address(this)], amt);\n', '        _totalSupply = bsub(_totalSupply, amt);\n', '        emit Transfer(address(this), address(0), amt);\n', '    }\n', '\n', '    function _move(address src, address dst, uint amt) internal {\n', '        require(_balance[src] >= amt, "!bal");\n', '        _balance[src] = bsub(_balance[src], amt);\n', '        _balance[dst] = badd(_balance[dst], amt);\n', '        emit Transfer(src, dst, amt);\n', '    }\n', '\n', '    function _push(address to, uint amt) internal {\n', '        _move(address(this), to, amt);\n', '    }\n', '\n', '    function _pull(address from, uint amt) internal {\n', '        _move(from, address(this), amt);\n', '    }\n', '}\n', '\n', 'contract BToken is BTokenBase, IERC20 {\n', '    string  private _name     = "Value Liquidity Provider";\n', '    string  private _symbol   = "VLP";\n', '    uint8   private _decimals = 18;\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view returns(uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function allowance(address src, address dst) external override view returns (uint) {\n', '        return _allowance[src][dst];\n', '    }\n', '\n', '    function balanceOf(address whom) external override view returns (uint) {\n', '        return _balance[whom];\n', '    }\n', '\n', '    function totalSupply() public override view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function approve(address dst, uint amt) external override returns (bool) {\n', '        _allowance[msg.sender][dst] = amt;\n', '        emit Approval(msg.sender, dst, amt);\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval(address dst, uint amt) external returns (bool) {\n', '        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\n', '        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address dst, uint amt) external returns (bool) {\n', '        uint oldValue = _allowance[msg.sender][dst];\n', '        if (amt > oldValue) {\n', '            _allowance[msg.sender][dst] = 0;\n', '        } else {\n', '            _allowance[msg.sender][dst] = bsub(oldValue, amt);\n', '        }\n', '        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint amt) external override returns (bool) {\n', '        _move(msg.sender, dst, amt);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\n', '        require(msg.sender == src || amt <= _allowance[src][msg.sender], "!spender");\n', '        _move(src, dst, amt);\n', '        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n', '            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\n', '            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n', '        }\n', '        return true;\n', '    }\n', '}\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', 'contract BMath is BNum {\n', '    /**********************************************************************************************\n', '    // calcSpotPrice                                                                             //\n', '    // sP = spotPrice                                                                            //\n', '    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n', '    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n', '    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n', '    // wO = tokenWeightOut                                                                       //\n', '    // sF = swapFee (+ collectedFee)                                                             //\n', '    **********************************************************************************************/\n', '    function calcSpotPrice(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint swapFee\n', '    )\n', '    public pure\n', '    returns (uint spotPrice)\n', '    {\n', '        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\n', '        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\n', '        uint ratio = bdiv(numer, denom);\n', '        uint scale = bdiv(BConst.BONE, bsub(BConst.BONE, swapFee));\n', '        return  (spotPrice = bmul(ratio, scale));\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcOutGivenIn                                                                            //\n', '    // aO = tokenAmountOut                                                                       //\n', '    // bO = tokenBalanceOut                                                                      //\n', '    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n', '    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n', '    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n', '    // wO = tokenWeightOut                                                                       //\n', '    // sF = swapFee (+ collectedFee)                                                             //\n', '    **********************************************************************************************/\n', '    function calcOutGivenIn(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint tokenAmountIn,\n', '        uint swapFee\n', '    )\n', '    public pure\n', '    returns (uint tokenAmountOut)\n', '    {\n', '        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n', '        uint adjustedIn = bsub(BConst.BONE, swapFee);\n', '        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n', '        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n', '        uint foo = bpow(y, weightRatio);\n', '        uint bar = bsub(BConst.BONE, foo);\n', '        tokenAmountOut = bmul(tokenBalanceOut, bar);\n', '        return tokenAmountOut;\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcInGivenOut                                                                            //\n', '    // aI = tokenAmountIn                                                                        //\n', '    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n', '    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n', '    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n', '    // wI = tokenWeightIn           --------------------------------------------                 //\n', '    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n', '    // sF = swapFee (+ collectedFee)                                                             //\n', '    **********************************************************************************************/\n', '    function calcInGivenOut(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint tokenAmountOut,\n', '        uint swapFee\n', '    )\n', '    public pure\n', '    returns (uint tokenAmountIn)\n', '    {\n', '        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n', '        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\n', '        uint y = bdiv(tokenBalanceOut, diff);\n', '        uint foo = bpow(y, weightRatio);\n', '        foo = bsub(foo, BConst.BONE);\n', '        tokenAmountIn = bsub(BConst.BONE, swapFee);\n', '        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n', '        return tokenAmountIn;\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcPoolOutGivenSingleIn                                                                  //\n', '    // pAo = poolAmountOut         /                                              \\              //\n', '    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\n', '    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n', '    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n', '    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n', '    // pS = poolSupply            \\\\                    tBi               /        /             //\n', '    // sF = swapFee (+ collectedFee)\\                                              /              //\n', '    **********************************************************************************************/\n', '    function calcPoolOutGivenSingleIn(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint tokenAmountIn,\n', '        uint swapFee\n', '    )\n', '    public pure\n', '    returns (uint poolAmountOut)\n', '    {\n', '        // @dev Charge the trading fee for the proportion of tokenAi\n', '        // which is implicitly traded to the other pool tokens.\n', '        // That proportion is (1- weightTokenIn)\n', '        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n', '        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n', '        uint zaz = bmul(bsub(BConst.BONE, normalizedWeight), swapFee);\n', '        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BConst.BONE, zaz));\n', '\n', '        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n', '        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n', '\n', '        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n', '        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\n', '        uint newPoolSupply = bmul(poolRatio, poolSupply);\n', '        poolAmountOut = bsub(newPoolSupply, poolSupply);\n', '        return poolAmountOut;\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcSingleInGivenPoolOut                                                                  //\n', '    // tAi = tokenAmountIn              //(pS + pAo)\\     /    1    \\\\                           //\n', '    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\n', '    // pAo = poolAmountOut              \\\\    pS    /     \\(wI / tW)//                           //\n', '    // bI = balanceIn          tAi =  --------------------------------------------               //\n', '    // wI = weightIn                              /      wI  \\                                   //\n', '    // tW = totalWeight                          |  1 - ----  |  * sF                            //\n', '    // sF = swapFee (+ collectedFee)              \\      tW  /                                   //\n', '    **********************************************************************************************/\n', '    function calcSingleInGivenPoolOut(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint poolAmountOut,\n', '        uint swapFee\n', '    )\n', '    public pure\n', '    returns (uint tokenAmountIn)\n', '    {\n', '        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n', '        uint newPoolSupply = badd(poolSupply, poolAmountOut);\n', '        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n', '\n', '        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\n', '        uint boo = bdiv(BConst.BONE, normalizedWeight);\n', '        uint tokenInRatio = bpow(poolRatio, boo);\n', '        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\n', '        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\n', '        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way \n', '        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\n', '        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\n', '        uint zar = bmul(bsub(BConst.BONE, normalizedWeight), swapFee);\n', '        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BConst.BONE, zar));\n', '        return tokenAmountIn;\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcSingleOutGivenPoolIn                                                                  //\n', '    // tAo = tokenAmountOut            /      /                                             \\\\   //\n', '    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\n', '    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n', '    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n', '    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n', '    // tW = totalWeight                    /     /      wO \\       \\                             //\n', '    // sF = swapFee (+ collectedFee)   *  | 1 - |  1 - ---- | * sF  |                            //\n', '    // eF = exitFee                        \\     \\      tW /       /                             //\n', '    **********************************************************************************************/\n', '    function calcSingleOutGivenPoolIn(\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint poolAmountIn,\n', '        uint swapFee,\n', '        uint exitFee\n', '    )\n', '    public pure\n', '    returns (uint tokenAmountOut)\n', '    {\n', '        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n', '        // charge exit fee on the pool token side\n', '        // pAiAfterExitFee = pAi*(1-exitFee)\n', '        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BConst.BONE, exitFee));\n', '        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n', '        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n', '\n', '        // newBalTo = poolRatio^(1/weightTo) * balTo;\n', '        uint tokenOutRatio = bpow(poolRatio, bdiv(BConst.BONE, normalizedWeight));\n', '        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n', '\n', '        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n', '\n', '        // charge swap fee on the output token side \n', '        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n', '        uint zaz = bmul(bsub(BConst.BONE, normalizedWeight), swapFee);\n', '        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BConst.BONE, zaz));\n', '        return tokenAmountOut;\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcPoolInGivenSingleOut                                                                  //\n', '    // pAi = poolAmountIn               // /               tAo             \\\\     / wO \\     \\   //\n', '    // bO = tokenBalanceOut            // | bO - -------------------------- |\\   | ---- |     \\  //\n', '    // tAo = tokenAmountOut      pS - ||   \\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\ tW /  * pS | //\n', '    // ps = poolSupply                 \\\\ -----------------------------------/                /  //\n', '    // wO = tokenWeightOut  pAi =       \\\\               bO                 /                /   //\n', '    // tW = totalWeight           -------------------------------------------------------------  //\n', '    // sF = swapFee (+ collectedFee)                       ( 1 - eF )                            //\n', '    // eF = exitFee                                                                              //\n', '    **********************************************************************************************/\n', '    function calcPoolInGivenSingleOut(\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint tokenAmountOut,\n', '        uint swapFee,\n', '        uint exitFee\n', '    )\n', '    public pure\n', '    returns (uint poolAmountIn)\n', '    {\n', '\n', '        // charge swap fee on the output token side \n', '        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n', '        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\n', '        uint zoo = bsub(BConst.BONE, normalizedWeight);\n', '        uint zar = bmul(zoo, swapFee);\n', '        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BConst.BONE, zar));\n', '\n', '        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n', '        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n', '\n', '        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\n', '        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\n', '        uint newPoolSupply = bmul(poolRatio, poolSupply);\n', '        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\n', '\n', '        // charge exit fee on the pool token side\n', '        // pAi = pAiAfterExitFee/(1-exitFee)\n', '        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BConst.BONE, exitFee));\n', '        return poolAmountIn;\n', '    }\n', '\n', '\n', '}\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', 'interface IBFactory {\n', '    function collectedToken() external view returns(address);\n', '}\n', '\n', 'contract BPool is BToken, BMath {\n', '    struct Record {\n', '        bool bound;   // is token bound to pool\n', '        uint index;   // private\n', '        uint denorm;  // denormalized weight\n', '        uint balance;\n', '    }\n', '\n', '    event LOG_SWAP(\n', '        address indexed caller,\n', '        address indexed tokenIn,\n', '        address indexed tokenOut,\n', '        uint256         tokenAmountIn,\n', '        uint256         tokenAmountOut\n', '    );\n', '\n', '    event LOG_JOIN(\n', '        address indexed caller,\n', '        address indexed tokenIn,\n', '        uint256         tokenAmountIn\n', '    );\n', '\n', '    event LOG_EXIT(\n', '        address indexed caller,\n', '        address indexed tokenOut,\n', '        uint256         tokenAmountOut\n', '    );\n', '    event LOG_CALL(\n', '        bytes4  indexed sig,\n', '        address indexed caller,\n', '        bytes           data\n', '    ) anonymous;\n', '\n', '    modifier _logs_() {\n', '        emit LOG_CALL(msg.sig, msg.sender, msg.data);\n', '        _;\n', '    }\n', '    event LOG_COLLECTED_FUND(\n', '        address indexed collectedToken,\n', '        uint256         collectedAmount\n', '    );\n', '\n', '    modifier _lock_() {\n', '        require(!_mutex, "reentry");\n', '        _mutex = true;\n', '        _;\n', '        _mutex = false;\n', '    }\n', '\n', '    modifier _viewlock_() {\n', '        require(!_mutex, "reentry");\n', '        _;\n', '    }\n', '\n', '    bool private _mutex;\n', '\n', '    uint public version = 1001;\n', '    address public factory;    // BFactory address to push token exitFee to\n', '    address public controller; // has CONTROL role\n', '    bool public publicSwap;\n', '\n', '    // `setSwapFee` and `finalize` require CONTROL\n', '    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\n', '    uint public initPoolSupply;\n', '    uint public swapFee;\n', '    uint public collectedFee; // 0.05% | https://yfv.finance/vip-vote/vip_5\n', '    uint public exitFee;\n', '    bool public finalized;\n', '\n', '    address[] private _tokens;\n', '    mapping(address => Record) private _records;\n', '    uint private _totalWeight;\n', '\n', '    constructor(address _factory) public {\n', '        controller = _factory;\n', '        factory = _factory;\n', '        initPoolSupply = BConst.DEFAULT_INIT_POOL_SUPPLY;\n', '        swapFee = BConst.DEFAULT_FEE;\n', '        collectedFee = BConst.DEFAULT_COLLECTED_FEE;\n', '        exitFee = BConst.DEFAULT_EXIT_FEE;\n', '        publicSwap = false;\n', '        finalized = false;\n', '    }\n', '\n', '    function setInitPoolSupply(uint _initPoolSupply) public _logs_ {\n', '        require(!finalized, "finalized");\n', '        require(msg.sender == controller, "!controller");\n', '        require(_initPoolSupply >= BConst.MIN_INIT_POOL_SUPPLY, "<minInitPoolSup");\n', '        require(_initPoolSupply <= BConst.MAX_INIT_POOL_SUPPLY, ">maxInitPoolSup");\n', '        initPoolSupply = _initPoolSupply;\n', '    }\n', '\n', '    function setCollectedFee(uint _collectedFee) public _logs_ {\n', '        require(msg.sender == factory, "!factory");\n', '        require(_collectedFee <= BConst.MAX_COLLECTED_FEE, ">maxCoFee");\n', '        require(bmul(_collectedFee, 2) <= swapFee, ">swapFee/2");\n', '        collectedFee = _collectedFee;\n', '    }\n', '\n', '    function setExitFee(uint _exitFee) public _logs_ {\n', '        require(!finalized, "finalized");\n', '        require(msg.sender == factory, "!factory");\n', '        require(_exitFee <= BConst.MAX_EXIT_FEE, ">maxExitFee");\n', '        exitFee = _exitFee;\n', '    }\n', '\n', '    function isBound(address t)\n', '    external view\n', '    returns (bool)\n', '    {\n', '        return _records[t].bound;\n', '    }\n', '\n', '    function getNumTokens()\n', '    external view\n', '    returns (uint)\n', '    {\n', '        return _tokens.length;\n', '    }\n', '\n', '    function getCurrentTokens()\n', '    external view _viewlock_\n', '    returns (address[] memory tokens)\n', '    {\n', '        return _tokens;\n', '    }\n', '\n', '    function getFinalTokens()\n', '    external view\n', '    _viewlock_\n', '    returns (address[] memory tokens)\n', '    {\n', '        require(finalized, "!finalized");\n', '        return _tokens;\n', '    }\n', '\n', '    function getDenormalizedWeight(address token)\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '\n', '        require(_records[token].bound, "!bound");\n', '        return _records[token].denorm;\n', '    }\n', '\n', '    function getTotalDenormalizedWeight()\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '        return _totalWeight;\n', '    }\n', '\n', '    function getNormalizedWeight(address token)\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '\n', '        require(_records[token].bound, "!bound");\n', '        uint denorm = _records[token].denorm;\n', '        return bdiv(denorm, _totalWeight);\n', '    }\n', '\n', '    function getBalance(address token)\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '\n', '        require(_records[token].bound, "!bound");\n', '        return _records[token].balance;\n', '    }\n', '\n', '    function setSwapFee(uint _swapFee)\n', '    external\n', '    _lock_\n', '    _logs_\n', '    {\n', '        require(!finalized, "finalized");\n', '        require(msg.sender == controller, "!controller");\n', '        require(_swapFee >= BConst.MIN_FEE, "<minFee");\n', '        require(_swapFee <= BConst.MAX_FEE, ">maxFee");\n', '        require(bmul(collectedFee, 2) <= _swapFee, "<collectedFee*2");\n', '        swapFee = _swapFee;\n', '    }\n', '\n', '    function setController(address _controller)\n', '    external\n', '    _lock_\n', '    _logs_\n', '    {\n', '        require(msg.sender == controller, "!controller");\n', '        controller = _controller;\n', '    }\n', '\n', '    function setPublicSwap(bool _publicSwap)\n', '    external\n', '    _lock_\n', '    _logs_\n', '    {\n', '        require(!finalized, "finalized");\n', '        require(msg.sender == controller, "!controller");\n', '        publicSwap = _publicSwap;\n', '    }\n', '\n', '    function finalize()\n', '    external\n', '    _lock_\n', '    _logs_\n', '    {\n', '        require(msg.sender == controller, "!controller");\n', '        require(!finalized, "finalized");\n', '        require(_tokens.length >= BConst.MIN_BOUND_TOKENS, "<minTokens");\n', '\n', '        finalized = true;\n', '        publicSwap = true;\n', '\n', '        _mintPoolShare(initPoolSupply);\n', '        _pushPoolShare(msg.sender, initPoolSupply);\n', '    }\n', '\n', '\n', '    function bind(address token, uint balance, uint denorm)\n', '    external\n', '    _logs_\n', '        // _lock_  Bind does not lock because it jumps to `rebind`, which does\n', '    {\n', '        require(msg.sender == controller, "!controller");\n', '        require(!_records[token].bound, "bound");\n', '        require(!finalized, "finalized");\n', '\n', '        require(_tokens.length < BConst.MAX_BOUND_TOKENS, ">maxTokens");\n', '\n', '        _records[token] = Record({\n', '            bound: true,\n', '            index: _tokens.length,\n', '            denorm: 0,    // balance and denorm will be validated\n', '            balance: 0   // and set by `rebind`\n', '            });\n', '        _tokens.push(token);\n', '        rebind(token, balance, denorm);\n', '    }\n', '\n', '    function rebind(address token, uint balance, uint denorm)\n', '    public\n', '    _lock_\n', '    _logs_\n', '    {\n', '\n', '        require(msg.sender == controller, "!controller");\n', '        require(_records[token].bound, "!bound");\n', '        require(!finalized, "finalized");\n', '\n', '        require(denorm >= BConst.MIN_WEIGHT, "<minWeight");\n', '        require(denorm <= BConst.MAX_WEIGHT, ">maxWeight");\n', '        require(balance >= BConst.MIN_BALANCE, "<minBal");\n', '\n', '        // Adjust the denorm and totalWeight\n', '        uint oldWeight = _records[token].denorm;\n', '        if (denorm > oldWeight) {\n', '            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\n', '            require(_totalWeight <= BConst.MAX_TOTAL_WEIGHT, ">maxTWeight");\n', '        } else if (denorm < oldWeight) {\n', '            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\n', '        }\n', '        _records[token].denorm = denorm;\n', '\n', '        // Adjust the balance record and actual token balance\n', '        uint oldBalance = _records[token].balance;\n', '        _records[token].balance = balance;\n', '        if (balance > oldBalance) {\n', '            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\n', '        } else if (balance < oldBalance) {\n', '            // In this case liquidity is being withdrawn, so charge EXIT_FEE\n', '            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\n', '            uint tokenExitFee = bmul(tokenBalanceWithdrawn, exitFee);\n', '            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\n', '            _pushUnderlying(token, factory, tokenExitFee);\n', '        }\n', '    }\n', '\n', '    function unbind(address token)\n', '    external\n', '    _lock_\n', '    _logs_\n', '    {\n', '\n', '        require(msg.sender == controller, "!controller");\n', '        require(_records[token].bound, "!bound");\n', '        require(!finalized, "finalized");\n', '\n', '        uint tokenBalance = _records[token].balance;\n', '        uint tokenExitFee = bmul(tokenBalance, exitFee);\n', '\n', '        _totalWeight = bsub(_totalWeight, _records[token].denorm);\n', '\n', '        // Swap the token-to-unbind with the last token,\n', '        // then delete the last token\n', '        uint index = _records[token].index;\n', '        uint last = _tokens.length - 1;\n', '        _tokens[index] = _tokens[last];\n', '        _records[_tokens[index]].index = index;\n', '        _tokens.pop();\n', '        _records[token] = Record({\n', '            bound: false,\n', '            index: 0,\n', '            denorm: 0,\n', '            balance: 0\n', '            });\n', '\n', '        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\n', '        _pushUnderlying(token, factory, tokenExitFee);\n', '    }\n', '\n', '    // Absorb any tokens that have been sent to this contract into the pool\n', '    function gulp(address token)\n', '    external\n', '    _logs_\n', '    _lock_\n', '    {\n', '        require(_records[token].bound, "!bound");\n', '        _records[token].balance = IERC20(token).balanceOf(address(this));\n', '    }\n', '\n', '    function getSpotPrice(address tokenIn, address tokenOut)\n', '    external view\n', '    _viewlock_\n', '    returns (uint spotPrice)\n', '    {\n', '        require(_records[tokenIn].bound, "!bound");\n', '        require(_records[tokenOut].bound, "!bound");\n', '        Record storage inRecord = _records[tokenIn];\n', '        Record storage outRecord = _records[tokenOut];\n', '        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, swapFee);\n', '    }\n', '\n', '    function getSpotPriceSansFee(address tokenIn, address tokenOut)\n', '    external view\n', '    _viewlock_\n', '    returns (uint spotPrice)\n', '    {\n', '        require(_records[tokenIn].bound, "!bound");\n', '        require(_records[tokenOut].bound, "!bound");\n', '        Record storage inRecord = _records[tokenIn];\n', '        Record storage outRecord = _records[tokenOut];\n', '        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\n', '    }\n', '\n', '    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\n', '    external\n', '    _lock_\n', '    _logs_\n', '    {\n', '        require(finalized, "!finalized");\n', '\n', '        uint poolTotal = totalSupply();\n', '        uint ratio = bdiv(poolAmountOut, poolTotal);\n', '        require(ratio != 0, "errMathAprox");\n', '\n', '        for (uint i = 0; i < _tokens.length; i++) {\n', '            address t = _tokens[i];\n', '            uint bal = _records[t].balance;\n', '            uint tokenAmountIn = bmul(ratio, bal);\n', '            require(tokenAmountIn != 0, "errMathAprox");\n', '            require(tokenAmountIn <= maxAmountsIn[i], "<limIn");\n', '            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\n', '            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n', '            _pullUnderlying(t, msg.sender, tokenAmountIn);\n', '        }\n', '        _mintPoolShare(poolAmountOut);\n', '        _pushPoolShare(msg.sender, poolAmountOut);\n', '    }\n', '\n', '    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\n', '    external\n', '    _lock_\n', '    _logs_\n', '    {\n', '        require(finalized, "!finalized");\n', '\n', '        uint poolTotal = totalSupply();\n', '        uint _exitFee = bmul(poolAmountIn, exitFee);\n', '        uint pAiAfterExitFee = bsub(poolAmountIn, _exitFee);\n', '        uint ratio = bdiv(pAiAfterExitFee, poolTotal);\n', '        require(ratio != 0, "errMathAprox");\n', '\n', '        _pullPoolShare(msg.sender, poolAmountIn);\n', '        _pushPoolShare(factory, _exitFee);\n', '        _burnPoolShare(pAiAfterExitFee);\n', '\n', '        for (uint i = 0; i < _tokens.length; i++) {\n', '            address t = _tokens[i];\n', '            uint bal = _records[t].balance;\n', '            uint tokenAmountOut = bmul(ratio, bal);\n', '            require(tokenAmountOut != 0, "errMathAprox");\n', '            require(tokenAmountOut >= minAmountsOut[i], "<limO");\n', '            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\n', '            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n', '            _pushUnderlying(t, msg.sender, tokenAmountOut);\n', '        }\n', '    }\n', '\n', '\n', '    function swapExactAmountIn(\n', '        address tokenIn,\n', '        uint tokenAmountIn,\n', '        address tokenOut,\n', '        uint minAmountOut,\n', '        uint maxPrice\n', '    )\n', '    external\n', '    _lock_\n', '    _logs_\n', '    returns (uint tokenAmountOut, uint spotPriceAfter)\n', '    {\n', '\n', '        require(_records[tokenIn].bound, "!bound");\n', '        require(_records[tokenOut].bound, "!bound");\n', '        require(publicSwap, "!publicSwap");\n', '\n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '\n', '        require(tokenAmountIn <= bmul(inRecord.balance, BConst.MAX_IN_RATIO), ">maxIRat");\n', '\n', '        uint spotPriceBefore = calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            swapFee\n', '        );\n', '        require(spotPriceBefore <= maxPrice, "badLimPrice");\n', '\n', '        tokenAmountOut = calcOutGivenIn(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            tokenAmountIn,\n', '            swapFee\n', '        );\n', '        require(tokenAmountOut >= minAmountOut, "<limO");\n', '\n', '        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n', '        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n', '\n', '        spotPriceAfter = calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            swapFee\n', '        );\n', '        require(spotPriceAfter >= spotPriceBefore, "errMathAprox");\n', '        require(spotPriceAfter <= maxPrice, ">limPrice");\n', '        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), "errMathAprox");\n', '\n', '        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n', '\n', '        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n', '        uint _subTokenAmountIn;\n', '        (_subTokenAmountIn, tokenAmountOut) = _pushCollectedFundGivenOut(tokenIn, tokenAmountIn, tokenOut, tokenAmountOut);\n', '        if (_subTokenAmountIn > 0) inRecord.balance = bsub(inRecord.balance, _subTokenAmountIn);\n', '        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n', '\n', '        return (tokenAmountOut, spotPriceAfter);\n', '    }\n', '\n', '    function swapExactAmountOut(\n', '        address tokenIn,\n', '        uint maxAmountIn,\n', '        address tokenOut,\n', '        uint tokenAmountOut,\n', '        uint maxPrice\n', '    )\n', '    external\n', '    _lock_\n', '    _logs_\n', '    returns (uint tokenAmountIn, uint spotPriceAfter)\n', '    {\n', '        require(_records[tokenIn].bound, "!bound");\n', '        require(_records[tokenOut].bound, "!bound");\n', '        require(publicSwap, "!publicSwap");\n', '\n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '\n', '        require(tokenAmountOut <= bmul(outRecord.balance, BConst.MAX_OUT_RATIO), ">maxORat");\n', '\n', '        uint spotPriceBefore = calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            swapFee\n', '        );\n', '        require(spotPriceBefore <= maxPrice, "badLimPrice");\n', '\n', '        tokenAmountIn = calcInGivenOut(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            tokenAmountOut,\n', '            swapFee\n', '        );\n', '        require(tokenAmountIn <= maxAmountIn, "<limIn");\n', '\n', '        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n', '        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n', '\n', '        spotPriceAfter = calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            swapFee\n', '        );\n', '        require(spotPriceAfter >= spotPriceBefore, "errMathAprox");\n', '        require(spotPriceAfter <= maxPrice, ">limPrice");\n', '        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), "errMathAprox");\n', '\n', '        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n', '\n', '        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n', '        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n', '        uint _collectedFeeAmount = _pushCollectedFundGivenIn(tokenIn, tokenAmountIn);\n', '        if (_collectedFeeAmount > 0) inRecord.balance = bsub(inRecord.balance, _collectedFeeAmount);\n', '\n', '        return (tokenAmountIn, spotPriceAfter);\n', '    }\n', '\n', '\n', '    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\n', '    external\n', '    _lock_\n', '    _logs_\n', '    returns (uint poolAmountOut)\n', '\n', '    {\n', '        require(finalized, "!finalized");\n', '        require(_records[tokenIn].bound, "!bound");\n', '        require(tokenAmountIn <= bmul(_records[tokenIn].balance, BConst.MAX_IN_RATIO), ">maxIRat");\n', '\n', '        Record storage inRecord = _records[tokenIn];\n', '\n', '        poolAmountOut = calcPoolOutGivenSingleIn(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            _totalSupply,\n', '            _totalWeight,\n', '            tokenAmountIn,\n', '            swapFee\n', '        );\n', '\n', '        require(poolAmountOut >= minPoolAmountOut, "<limO");\n', '\n', '        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n', '\n', '        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n', '\n', '        _mintPoolShare(poolAmountOut);\n', '        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n', '        uint _subTokenAmountIn;\n', '        (_subTokenAmountIn, poolAmountOut) = _pushCollectedFundGivenOut(tokenIn, tokenAmountIn, address(this), poolAmountOut);\n', '        if (_subTokenAmountIn > 0) inRecord.balance = bsub(inRecord.balance, _subTokenAmountIn);\n', '        _pushPoolShare(msg.sender, poolAmountOut);\n', '\n', '        return poolAmountOut;\n', '    }\n', '\n', '    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)\n', '    external\n', '    _lock_\n', '    _logs_\n', '    returns (uint tokenAmountIn)\n', '    {\n', '        require(finalized, "!finalized");\n', '        require(_records[tokenIn].bound, "!bound");\n', '\n', '        Record storage inRecord = _records[tokenIn];\n', '\n', '        tokenAmountIn = calcSingleInGivenPoolOut(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            _totalSupply,\n', '            _totalWeight,\n', '            poolAmountOut,\n', '            swapFee\n', '        );\n', '\n', '        require(tokenAmountIn != 0, "errMathAprox");\n', '        require(tokenAmountIn <= maxAmountIn, "<limIn");\n', '\n', '        require(tokenAmountIn <= bmul(_records[tokenIn].balance, BConst.MAX_IN_RATIO), ">maxIRat");\n', '\n', '        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\n', '\n', '        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n', '\n', '        _mintPoolShare(poolAmountOut);\n', '        _pushPoolShare(msg.sender, poolAmountOut);\n', '        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n', '        uint _collectedFeeAmount = _pushCollectedFundGivenIn(tokenIn, tokenAmountIn);\n', '        if (_collectedFeeAmount > 0) inRecord.balance = bsub(inRecord.balance, _collectedFeeAmount);\n', '\n', '        return tokenAmountIn;\n', '    }\n', '\n', '    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\n', '    external\n', '    _lock_\n', '    _logs_\n', '    returns (uint tokenAmountOut)\n', '    {\n', '        require(finalized, "!finalized");\n', '        require(_records[tokenOut].bound, "!bound");\n', '\n', '        Record storage outRecord = _records[tokenOut];\n', '\n', '        tokenAmountOut = calcSingleOutGivenPoolIn(\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            _totalSupply,\n', '            _totalWeight,\n', '            poolAmountIn,\n', '            swapFee,\n', '            exitFee\n', '        );\n', '\n', '        require(tokenAmountOut >= minAmountOut, "<limO");\n', '\n', '        require(tokenAmountOut <= bmul(_records[tokenOut].balance, BConst.MAX_OUT_RATIO), ">maxORat");\n', '\n', '        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n', '\n', '        uint _exitFee = bmul(poolAmountIn, exitFee);\n', '\n', '        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n', '\n', '        _pullPoolShare(msg.sender, poolAmountIn);\n', '        _burnPoolShare(bsub(poolAmountIn, _exitFee));\n', '        _pushPoolShare(factory, _exitFee);\n', '        (, tokenAmountOut) = _pushCollectedFundGivenOut(address(this), poolAmountIn, tokenOut, tokenAmountOut);\n', '        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n', '\n', '        return tokenAmountOut;\n', '    }\n', '\n', '    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)\n', '    external\n', '    _lock_\n', '    _logs_\n', '    returns (uint poolAmountIn)\n', '    {\n', '        require(finalized, "!finalized");\n', '        require(_records[tokenOut].bound, "!bound");\n', '        require(tokenAmountOut <= bmul(_records[tokenOut].balance, BConst.MAX_OUT_RATIO), ">maxORat");\n', '\n', '        Record storage outRecord = _records[tokenOut];\n', '\n', '        poolAmountIn = calcPoolInGivenSingleOut(\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            _totalSupply,\n', '            _totalWeight,\n', '            tokenAmountOut,\n', '            swapFee,\n', '            exitFee\n', '        );\n', '\n', '        require(poolAmountIn != 0, "errMathAprox");\n', '        require(poolAmountIn <= maxPoolAmountIn, "<limIn");\n', '\n', '        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n', '\n', '        uint _exitFee = bmul(poolAmountIn, exitFee);\n', '\n', '        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n', '\n', '        _pullPoolShare(msg.sender, poolAmountIn);\n', '        uint _collectedFeeAmount = _pushCollectedFundGivenIn(address(this), poolAmountIn);\n', '        _burnPoolShare(bsub(bsub(poolAmountIn, _exitFee), _collectedFeeAmount));\n', '        _pushPoolShare(factory, _exitFee);\n', '        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n', '\n', '        return poolAmountIn;\n', '    }\n', '\n', '\n', '    // ==\n', "    // 'Underlying' token-manipulation functions make external calls but are NOT locked\n", '    // You must `_lock_` or otherwise ensure reentry-safety\n', '\n', '    function _pullUnderlying(address erc20, address from, uint amount)\n', '    internal\n', '    {\n', '        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\n', '        require(xfer, "errErc20");\n', '    }\n', '\n', '    function _pushUnderlying(address erc20, address to, uint amount)\n', '    internal\n', '    {\n', '        bool xfer = IERC20(erc20).transfer(to, amount);\n', '        require(xfer, "errErc20");\n', '    }\n', '\n', '    function _pullPoolShare(address from, uint amount)\n', '    internal\n', '    {\n', '        _pull(from, amount);\n', '    }\n', '\n', '    function _pushPoolShare(address to, uint amount)\n', '    internal\n', '    {\n', '        _push(to, amount);\n', '    }\n', '\n', '    function _mintPoolShare(uint amount)\n', '    internal\n', '    {\n', '        _mint(amount);\n', '    }\n', '\n', '    function _burnPoolShare(uint amount)\n', '    internal\n', '    {\n', '        _burn(amount);\n', '    }\n', '\n', '    function _pushCollectedFundGivenOut(address _tokenIn, uint _tokenAmountIn, address _tokenOut, uint _tokenAmountOut) internal returns (uint subTokenAmountIn, uint tokenAmountOut) {\n', '        subTokenAmountIn = 0;\n', '        tokenAmountOut = _tokenAmountOut;\n', '        if (collectedFee > 0) {\n', '            address _collectedToken = IBFactory(factory).collectedToken();\n', '            if (_collectedToken == _tokenIn) {\n', '                subTokenAmountIn = bdiv(bmul(_tokenAmountIn, collectedFee), BConst.BONE);\n', '                _pushUnderlying(_tokenIn, factory, subTokenAmountIn);\n', '                emit LOG_COLLECTED_FUND(_tokenIn, subTokenAmountIn);\n', '            } else {\n', '                uint _collectedFeeAmount = bdiv(bmul(_tokenAmountOut, collectedFee), BConst.BONE);\n', '                _pushUnderlying(_tokenOut, factory, _collectedFeeAmount);\n', '                tokenAmountOut = bsub(_tokenAmountOut, _collectedFeeAmount);\n', '                emit LOG_COLLECTED_FUND(_tokenOut, _collectedFeeAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    // always push out _tokenIn (already have)\n', '    function _pushCollectedFundGivenIn(address _tokenIn, uint _tokenAmountIn) internal returns (uint collectedFeeAmount) {\n', '        collectedFeeAmount = 0;\n', '        if (collectedFee > 0) {\n', '            address _collectedToken = IBFactory(factory).collectedToken();\n', '            if (_collectedToken != address(0)) {\n', '                collectedFeeAmount = bdiv(bmul(_tokenAmountIn, collectedFee), BConst.BONE);\n', '                _pushUnderlying(_tokenIn, factory, collectedFeeAmount);\n', '                emit LOG_COLLECTED_FUND(_tokenIn, collectedFeeAmount);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '// This program is disstributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '// Builds new BPools, logging their addresses and providing `isBPool(address) -> (bool)`\n', 'contract BPoolCreator {\n', '    function newBPool() external returns (BPool) {\n', '        return new BPool(msg.sender);\n', '    }\n', '}']