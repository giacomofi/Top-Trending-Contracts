['// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '}\n', '\n', '// File: contracts/interfaces/IHiposwapV2Pair.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IHiposwapV2Pair {\n', '    \n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint reserve0, uint reserve1);\n', '    event _Maker(address indexed sender, address token, uint amount, uint time);\n', '\n', '    \n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function currentPoolId0() external view returns (uint);\n', '    function currentPoolId1() external view returns (uint);\n', '    function getMakerPool0(uint poolId) external view returns (uint _balance, uint _swapOut, uint _swapIn);\n', '    function getMakerPool1(uint poolId) external view returns (uint _balance, uint _swapOut, uint _swapIn);\n', '    function getReserves() external view returns (uint reserve0, uint reserve1);\n', '    function getBalance() external view returns (uint _balance0, uint _balance1);\n', '    function getMaker(address mkAddress) external view returns (uint,address,uint,uint);\n', '    function getFees() external view returns (uint _fee0, uint _fee1);\n', '    function getFeeAdmins() external view returns (uint _feeAdmin0, uint _feeAdmin1);\n', '    function getAvgTimes() external view returns (uint _avgTime0, uint _avgTime1);\n', '    function transferFeeAdmin(address to) external;\n', '    function getFeePercents() external view returns (uint _feeAdminPercent, uint _feePercent, uint _totalPercent);\n', '    function setFeePercents(uint _feeAdminPercent, uint _feePercent, uint _totalPercent) external;\n', '    function getRemainPercent() external view returns (uint);\n', '    function getTotalPercent() external view returns (uint);\n', '    \n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function order(address to) external returns (address token, uint amount);\n', '    function retrieve(uint amount0, uint amount1, address sender, address to) external returns (uint, uint);\n', '    function getAmountA(address to, uint amountB) external view returns(uint amountA, uint _amountB, uint rewardsB, uint remainA);\n', '    function getAmountB(address to, uint amountA) external view returns(uint _amountA, uint amountB, uint rewardsB, uint remainA);\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// File: contracts/interfaces/IHiposwapV2Factory.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.6;\n', '\n', 'abstract contract IHiposwapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view virtual returns (address);\n', '    function uniswapFactory() external view virtual returns (address);\n', '    function WETH() external pure virtual returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view virtual returns (address pair);\n', '    function allPairs(uint) external view virtual returns (address pair);\n', '    function allPairsLength() external view virtual returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external virtual returns (address pair);\n', '\n', '    function setFeeTo(address) external virtual;\n', '    function setUniswapFactory(address _factory) external virtual;\n', '    \n', '    function getContribution(address tokenA, address tokenB, address tokenMain, address mkAddress) external view virtual returns (address pairAddress, uint contribution);\n', '    \n', '    function getMaxMakerAmount(address tokenA, address tokenB) external view virtual returns (uint amountA, uint amountB);\n', '    function getMaxMakerAmountETH(address token) external view virtual returns (uint amount, uint amountETH);\n', '    function addMaker(address tokenA, address tokenB, uint amountA, uint amountB, address to, uint deadline) external virtual returns (address token, uint amount);\n', '    function addMakerETH(address token, uint amountToken, address to, uint deadline) external payable virtual returns (address _token, uint amount);\n', '    function removeMaker(address tokenA, address tokenB, uint amountA, uint amountB, address to, uint deadline) external virtual returns (uint amount0, uint amount1);\n', '    function removeMakerETH(address token, uint amountToken, uint amountETH, address to, uint deadline) external virtual returns (uint _amountToken, uint _amountETH);\n', '    function removeMakerETHSupportingFeeOnTransferTokens(address token, uint amountToken, uint amountETH, address to, uint deadline) external virtual returns (uint _amountETH);\n', '    \n', '    function collectFees(address tokenA, address tokenB) external virtual;\n', '    function collectFees(address pair) external virtual;\n', '    function setFeePercents(address tokenA, address tokenB, uint _feeAdminPercent, uint _feePercent, uint _totalPercent) external virtual;\n', '    function setFeePercents(address pair, uint _feeAdminPercent, uint _feePercent, uint _totalPercent) external virtual;\n', '}\n', '\n', '// File: contracts/libraries/SafeMath.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.6;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '    }\n', '}\n', '\n', '// File: contracts/libraries/HiposwapV2Library.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'library HiposwapV2Library {\n', '    using SafeMath for uint;\n', '    \n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'HiposwapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'HiposwapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\n', '        pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair\n', '    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '        \n', '        address pair = pairFor(factory, tokenA, tokenB);\n', '        if (pair == address(0)) {\n', '            return (0, 0);\n', '        }\n', '        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pair).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '    \n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function makerPairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        pair = address(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'2603bd3b15dbef4d28f9036d8301021d5edc3ae2f073f054721f61b9bf1fa5f3' // init code hash\n", '            ))));\n', '    }\n', '    \n', '    function getMakerReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '        (uint reserve0, uint reserve1) = IHiposwapV2Pair(makerPairFor(factory, tokenA, tokenB)).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n', '    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n', "        require(amountA > 0, 'HiposwapV2Library: INSUFFICIENT_AMOUNT');\n", "        require(reserveA > 0 && reserveB > 0, 'HiposwapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountB = amountA.mul(reserveB) / reserveA;\n', '    }\n', '    \n', '    function getMakerAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint makerReserve, uint remainPercent, uint totalPercent) internal pure returns (uint amountOut) {\n', "        require(amountIn >= 10, 'HiposwapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'HiposwapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountOut = getAmountOut(amountIn / 10, reserveIn, reserveOut, remainPercent, totalPercent).mul(10);\n', "        require(amountOut <= makerReserve, 'HiposwapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n", '    }\n', '    \n', '    // function getMakerAmountsOut(address hipoFactory, address uniFactory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n', "    //     require(path.length >= 2, 'HiposwapV2Library: INVALID_PATH');\n", '    //     amounts = new uint[](path.length);\n', '    //     amounts[0] = amountIn;\n', '    //     for (uint i; i < path.length - 1; i++) {\n', '    //         (uint reserveIn, uint reserveOut) = getReserves(uniFactory, path[i], path[i + 1]);\n', '    //         (, uint makerReserveOut) = getMakerReserves(hipoFactory, path[i], path[i + 1]);\n', '    //         amounts[i + 1] = getMakerAmountOut(amounts[i], reserveIn, reserveOut, makerReserveOut);\n', '    //     }\n', '    // }\n', '    \n', '    function getMakerAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint makerReserve, uint remainPercent, uint totalPercent) internal pure returns (uint amountIn) {\n', "        require(amountOut >= 10 && amountOut <= makerReserve, 'HiposwapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'HiposwapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountIn = getAmountIn(amountOut / 10, reserveIn, reserveOut, remainPercent, totalPercent).sub(1).mul(10).add(1);\n', '    }\n', '    \n', '    // function getMakerAmountsIn(address hipoFactory, address uniFactory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n', "    //     require(path.length >= 2, 'HiposwapV2Library: INVALID_PATH');\n", '    //     amounts = new uint[](path.length);\n', '    //     amounts[amounts.length - 1] = amountOut;\n', '    //     for (uint i = path.length - 1; i > 0; i--) {\n', '    //         (uint reserveIn, uint reserveOut) = getReserves(uniFactory, path[i - 1], path[i]);\n', '    //         (, uint makerReserveOut) = getMakerReserves(hipoFactory, path[i - 1], path[i]);\n', '    //         amounts[i - 1] = getMakerAmountIn(amounts[i], reserveIn, reserveOut, makerReserveOut);\n', '    //     }\n', '    // }\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint remainPercent, uint totalPercent) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'HiposwapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'HiposwapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = amountIn.mul(remainPercent);\n', '        uint numerator = amountInWithFee.mul(reserveOut);\n', '        uint denominator = reserveIn.mul(totalPercent).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint remainPercent, uint totalPercent) internal pure returns (uint amountIn) {\n', "        require(amountOut > 0, 'HiposwapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'HiposwapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint numerator = reserveIn.mul(amountOut).mul(totalPercent);\n', '        uint denominator = reserveOut.sub(amountOut).mul(remainPercent);\n', '        amountIn = (numerator / denominator).add(1);\n', '    }\n', '\n', '    // performs chained getAmountOut calculations on any number of pairs\n', '    // function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n', "    //     require(path.length >= 2, 'HiposwapV2Library: INVALID_PATH');\n", '    //     amounts = new uint[](path.length);\n', '    //     amounts[0] = amountIn;\n', '    //     for (uint i; i < path.length - 1; i++) {\n', '    //         (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n', '    //         amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n', '    //     }\n', '    // }\n', '\n', '    // performs chained getAmountIn calculations on any number of pairs\n', '    // function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n', "    //     require(path.length >= 2, 'HiposwapV2Library: INVALID_PATH');\n", '    //     amounts = new uint[](path.length);\n', '    //     amounts[amounts.length - 1] = amountOut;\n', '    //     for (uint i = path.length - 1; i > 0; i--) {\n', '    //         (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n', '    //         amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n', '    //     }\n', '    // }\n', '}\n', '\n', '// File: contracts/libraries/TransferHelper.sol\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', 'pragma solidity >=0.6.0;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', '// File: contracts/interfaces/IHiposwapV2Router.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.6;\n', '\n', 'interface IHiposwapV2Router {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    //function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    //function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    //function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    //function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    //function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    \n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getMakerAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint makerReserve, uint remainPercent, uint totalPercent) external pure returns (uint amountOut);\n', '    function getMakerAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint makerReserve, uint remainPercent, uint totalPercent) external pure returns (uint amountIn);\n', '    function getHipoReserves(address tokenA, address tokenB) external view returns (uint r0, uint r1);\n', '    function getMakerAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getMakerAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '    \n', '}\n', '\n', '// File: contracts/interfaces/IWETH.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function withdraw(uint) external;\n', '}\n', '\n', '// File: contracts/interfaces/IERC20.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', '// File: contracts/HiposwapV2Router.sol\n', '\n', 'pragma solidity =0.6.6;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract HiposwapV2Router is IHiposwapV2Router{\n', '    using SafeMath for uint;\n', '    address public immutable override factory;\n', '    address public immutable override WETH;\n', '    \n', '    uint public constant MIN_RESERVE_UPDATE_TIME = 10 minutes;\n', '    \n', '    struct Reserve {\n', '        uint reserve0;\n', '        uint reserve1;\n', '        uint time;\n', '    }\n', '    mapping(address => Reserve) public rs;\n', '    \n', '    constructor(address _factory) public {\n', '        factory = _factory;\n', '        WETH = IHiposwapV2Factory(_factory).WETH();\n', '    }\n', '    \n', '    modifier ensure(uint deadline) {\n', "        require(deadline >= block.timestamp, 'HiposwapV2Router: EXPIRED');\n", '        _;\n', '    }\n', '    \n', '    receive() external payable {\n', '        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n', '    }\n', '    \n', '    // **** SWAP ****\n', '    // requires the initial amount to have already been sent to the first pair\n', '    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (address input, address output) = (path[i], path[i + 1]);\n', '            (address token0,) = HiposwapV2Library.sortTokens(input, output);\n', '            uint amountOut = amounts[i + 1];\n', '            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n', '            address to = i < path.length - 2 ? HiposwapV2Library.makerPairFor(factory, output, path[i + 2]) : _to;\n', '            IHiposwapV2Pair(HiposwapV2Library.makerPairFor(factory, input, output)).swap(\n', '                amount0Out, amount1Out, to, new bytes(0)\n', '            );\n', '        }\n', '    }\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n', '        amounts = getMakerAmountsOutUpdateReserve(amountIn, path);\n', "        require(amounts[amounts.length - 1] >= amountOutMin, 'HiposwapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n", '        TransferHelper.safeTransferFrom(\n', '            path[0], msg.sender, HiposwapV2Library.makerPairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        _swap(amounts, path, to);\n', '    }\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n', '        amounts = getMakerAmountsInUpdateReserve(amountOut, path);\n', "        require(amounts[0] <= amountInMax, 'HiposwapV2Router: EXCESSIVE_INPUT_AMOUNT');\n", '        TransferHelper.safeTransferFrom(\n', '            path[0], msg.sender, HiposwapV2Library.makerPairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        _swap(amounts, path, to);\n', '    }\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        virtual\n', '        override\n', '        payable\n', '        ensure(deadline)\n', '        returns (uint[] memory amounts)\n', '    {\n', "        require(path[0] == WETH, 'HiposwapV2Router: INVALID_PATH');\n", '        amounts = getMakerAmountsOutUpdateReserve(msg.value, path);\n', "        require(amounts[amounts.length - 1] >= amountOutMin, 'HiposwapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n", '        IWETH(WETH).deposit{value: amounts[0]}();\n', '        assert(IWETH(WETH).transfer(HiposwapV2Library.makerPairFor(factory, path[0], path[1]), amounts[0]));\n', '        _swap(amounts, path, to);\n', '    }\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        virtual\n', '        override\n', '        ensure(deadline)\n', '        returns (uint[] memory amounts)\n', '    {\n', "        require(path[path.length - 1] == WETH, 'HiposwapV2Router: INVALID_PATH');\n", '        amounts = getMakerAmountsInUpdateReserve(amountOut, path);\n', "        require(amounts[0] <= amountInMax, 'HiposwapV2Router: EXCESSIVE_INPUT_AMOUNT');\n", '        TransferHelper.safeTransferFrom(\n', '            path[0], msg.sender, HiposwapV2Library.makerPairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        _swap(amounts, path, address(this));\n', '        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n', '        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n', '    }\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        virtual\n', '        override\n', '        ensure(deadline)\n', '        returns (uint[] memory amounts)\n', '    {\n', "        require(path[path.length - 1] == WETH, 'HiposwapV2Router: INVALID_PATH');\n", '        amounts = getMakerAmountsOutUpdateReserve(amountIn, path);\n', "        require(amounts[amounts.length - 1] >= amountOutMin, 'HiposwapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n", '        TransferHelper.safeTransferFrom(\n', '            path[0], msg.sender, HiposwapV2Library.makerPairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        _swap(amounts, path, address(this));\n', '        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n', '        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n', '    }\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        virtual\n', '        override\n', '        payable\n', '        ensure(deadline)\n', '        returns (uint[] memory amounts)\n', '    {\n', "        require(path[0] == WETH, 'HiposwapV2Router: INVALID_PATH');\n", '        amounts = getMakerAmountsInUpdateReserve(amountOut, path);\n', "        require(amounts[0] <= msg.value, 'HiposwapV2Router: EXCESSIVE_INPUT_AMOUNT');\n", '        IWETH(WETH).deposit{value: amounts[0]}();\n', '        assert(IWETH(WETH).transfer(HiposwapV2Library.makerPairFor(factory, path[0], path[1]), amounts[0]));\n', '        _swap(amounts, path, to);\n', '        // refund dust eth, if any\n', '        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n', '    }\n', '\n', '    // **** SWAP (supporting fee-on-transfer tokens) ****\n', '    // requires the initial amount to have already been sent to the first pair\n', '    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (address input, address output) = (path[i], path[i + 1]);\n', '            (address token0, address token1) = HiposwapV2Library.sortTokens(input, output);\n', '            IHiposwapV2Pair pair = IHiposwapV2Pair(HiposwapV2Library.makerPairFor(factory, input, output));\n', '            uint amountInput;\n', '            uint amountOutput;\n', '            { // scope to avoid stack too deep errors\n', '            Reserve storage r = rs[address(pair)];\n', '            if (now > r.time.add(10)) {\n', '                (r.reserve0, r.reserve1) = HiposwapV2Library.getReserves(IHiposwapV2Factory(factory).uniswapFactory(), token0, token1);\n', '                r.time = now;\n', '            }\n', '            (uint reserveInput, uint reserveOutput) = input == token0 ? (r.reserve0, r.reserve1) : (r.reserve1, r.reserve0);\n', '            (uint makerReserveInput, uint makerReserveOut) = HiposwapV2Library.getMakerReserves(factory, input, output);\n', '            amountInput = IERC20(input).balanceOf(address(pair)).sub(makerReserveInput);\n', '            amountOutput = HiposwapV2Library.getAmountOut(amountInput / 10, reserveInput, reserveOutput, pair.getRemainPercent(), pair.getTotalPercent()).mul(10);\n', '            require(amountOutput <= makerReserveOut, "HiposwapV2Pair: INSUFFICIENT_OUTPUT_AMOUNT");\n', '            if (input == token0) {\n', '                r.reserve0 = r.reserve0.add(amountInput / 10);\n', '                r.reserve1 = r.reserve1.sub(amountOutput / 10);\n', '            } else {\n', '                r.reserve1 = r.reserve1.add(amountInput / 10);\n', '                r.reserve0 = r.reserve0.sub(amountOutput / 10);\n', '            }\n', '            }\n', '            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n', '            address to = i < path.length - 2 ? HiposwapV2Library.makerPairFor(factory, output, path[i + 2]) : _to;\n', '            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n', '        }\n', '    }\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external virtual override ensure(deadline) {\n', '        TransferHelper.safeTransferFrom(\n', '            path[0], msg.sender, HiposwapV2Library.makerPairFor(factory, path[0], path[1]), amountIn\n', '        );\n', '        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n', '        _swapSupportingFeeOnTransferTokens(path, to);\n', '        require(\n', '            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n', "            'HiposwapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n", '        );\n', '    }\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    )\n', '        external\n', '        virtual\n', '        override\n', '        payable\n', '        ensure(deadline)\n', '    {\n', "        require(path[0] == WETH, 'HiposwapV2Router: INVALID_PATH');\n", '        uint amountIn = msg.value;\n', '        IWETH(WETH).deposit{value: amountIn}();\n', '        assert(IWETH(WETH).transfer(HiposwapV2Library.makerPairFor(factory, path[0], path[1]), amountIn));\n', '        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n', '        _swapSupportingFeeOnTransferTokens(path, to);\n', '        require(\n', '            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n', "            'HiposwapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n", '        );\n', '    }\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    )\n', '        external\n', '        virtual\n', '        override\n', '        ensure(deadline)\n', '    {\n', "        require(path[path.length - 1] == WETH, 'HiposwapV2Router: INVALID_PATH');\n", '        TransferHelper.safeTransferFrom(\n', '            path[0], msg.sender, HiposwapV2Library.makerPairFor(factory, path[0], path[1]), amountIn\n', '        );\n', '        _swapSupportingFeeOnTransferTokens(path, address(this));\n', '        uint amountOut = IERC20(WETH).balanceOf(address(this));\n', "        require(amountOut >= amountOutMin, 'HiposwapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n", '        IWETH(WETH).withdraw(amountOut);\n', '        TransferHelper.safeTransferETH(to, amountOut);\n', '    }\n', '    \n', '\n', '    \n', '    // **** LIBRARY FUNCTIONS ****\n', '    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\n', '        return HiposwapV2Library.quote(amountA, reserveA, reserveB);\n', '    }\n', '\n', '    function getMakerAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint makerReserve, uint remainPercent, uint totalPercent) external pure virtual override\n', '        returns (uint amountOut) {\n', '        return HiposwapV2Library.getMakerAmountOut(amountIn, reserveIn, reserveOut, makerReserve, remainPercent, totalPercent);\n', '    }\n', '\n', '    function getMakerAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint makerReserve, uint remainPercent, uint totalPercent) external pure virtual override\n', '        returns (uint amountIn) {\n', '        return HiposwapV2Library.getMakerAmountIn(amountOut, reserveIn, reserveOut, makerReserve, remainPercent, totalPercent);\n', '    }\n', '\n', '    // function getMakerAmountsOut(uint amountIn, address[] calldata path) external view virtual override\n', '    //     returns (uint[] memory amounts) {\n', '    //     return HiposwapV2Library.getMakerAmountsOut(factory, IHiposwapV2Factory(factory).uniswapFactory(), amountIn, path);\n', '    // }\n', '\n', '    // function getMakerAmountsIn(uint amountOut, address[] calldata path) external view virtual override\n', '    //     returns (uint[] memory amounts) {\n', '    //     return HiposwapV2Library.getMakerAmountsIn(factory, IHiposwapV2Factory(factory).uniswapFactory(), amountOut, path);\n', '    // }\n', '    \n', '    function getHipoReserves(address tokenA, address tokenB) external view virtual override returns (uint r0, uint r1){\n', '        Reserve memory r = rs[HiposwapV2Library.makerPairFor(factory, tokenA, tokenB)];\n', '        (r0, r1) = (r.reserve0, r.reserve1);\n', '    }\n', '    \n', '    function getMakerAmountsOut(uint amountIn, address[] calldata path) external view virtual override returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'HiposwapV2Router: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint i; i < path.length - 1; i++) {\n', '            IHiposwapV2Pair pair = IHiposwapV2Pair(HiposwapV2Library.makerPairFor(factory, path[i], path[i + 1]));\n', '            Reserve memory r = rs[address(pair)];\n', '            uint r0 = r.reserve0;\n', '            uint r1 = r.reserve1;\n', '            if (now > r.time.add(MIN_RESERVE_UPDATE_TIME)) {\n', '                (address token0, address token1) = HiposwapV2Library.sortTokens(path[i], path[i + 1]);\n', '                (r0, r1) = HiposwapV2Library.getReserves(IHiposwapV2Factory(factory).uniswapFactory(), token0, token1);\n', '            }\n', '            (uint reserveIn, uint reserveOut) = path[i] < path[i + 1] ? (r0, r1) : (r1, r0);\n', '            (, uint makerReserveOut) = HiposwapV2Library.getMakerReserves(factory, path[i], path[i + 1]);\n', '            amounts[i + 1] = HiposwapV2Library.getMakerAmountOut(amounts[i], reserveIn, reserveOut, makerReserveOut, pair.getRemainPercent(), pair.getTotalPercent());\n', '        }\n', '    }\n', '    \n', '    function getMakerAmountsIn(uint amountOut, address[] calldata path) external view virtual override returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'HiposwapV2Router: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[amounts.length - 1] = amountOut;\n', '        for (uint i = path.length - 1; i > 0; i--) {\n', '            IHiposwapV2Pair pair = IHiposwapV2Pair(HiposwapV2Library.makerPairFor(factory, path[i - 1], path[i]));\n', '            Reserve memory r = rs[address(pair)];\n', '            uint r0 = r.reserve0;\n', '            uint r1 = r.reserve1;\n', '            if (now > r.time.add(MIN_RESERVE_UPDATE_TIME)) {\n', '                (address token0, address token1) = HiposwapV2Library.sortTokens(path[i - 1], path[i]);\n', '                (r0, r1) = HiposwapV2Library.getReserves(IHiposwapV2Factory(factory).uniswapFactory(), token0, token1);\n', '            }\n', '            (uint reserveIn, uint reserveOut) = path[i - 1] < path[i] ? (r0, r1) : (r1, r0);\n', '            (, uint makerReserveOut) = HiposwapV2Library.getMakerReserves(factory, path[i - 1], path[i]);\n', '            amounts[i - 1] = HiposwapV2Library.getMakerAmountIn(amounts[i], reserveIn, reserveOut, makerReserveOut, pair.getRemainPercent(), pair.getTotalPercent());\n', '        }\n', '    }\n', '    \n', '    function getMakerAmountsOutUpdateReserve(uint amountIn, address[] memory path) internal returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'HiposwapV2Router: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint i; i < path.length - 1; i++) {\n', '            IHiposwapV2Pair pair = IHiposwapV2Pair(HiposwapV2Library.makerPairFor(factory, path[i], path[i + 1]));\n', '            Reserve storage r = rs[address(pair)];\n', '            if (now > r.time.add(MIN_RESERVE_UPDATE_TIME)) {\n', '                (address token0, address token1) = HiposwapV2Library.sortTokens(path[i], path[i + 1]);\n', '                (r.reserve0, r.reserve1) = HiposwapV2Library.getReserves(IHiposwapV2Factory(factory).uniswapFactory(), token0, token1);\n', '                r.time = now;\n', '            }\n', '            (uint reserveIn, uint reserveOut) = path[i] < path[i + 1] ? (r.reserve0, r.reserve1) : (r.reserve1, r.reserve0);\n', '            (, uint makerReserveOut) = HiposwapV2Library.getMakerReserves(factory, path[i], path[i + 1]);\n', '            amounts[i + 1] = HiposwapV2Library.getMakerAmountOut(amounts[i], reserveIn, reserveOut, makerReserveOut, pair.getRemainPercent(), pair.getTotalPercent());\n', '            if (path[i] < path[i + 1]) {\n', '                r.reserve0 = r.reserve0.add(amounts[i] / 10);\n', '                r.reserve1 = r.reserve1.sub(amounts[i + 1] / 10);\n', '            } else {\n', '                r.reserve1 = r.reserve1.add(amounts[i] / 10);\n', '                r.reserve0 = r.reserve0.sub(amounts[i + 1] / 10);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getMakerAmountsInUpdateReserve(uint amountOut, address[] memory path) internal returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'HiposwapV2Router: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[amounts.length - 1] = amountOut;\n', '        for (uint i = path.length - 1; i > 0; i--) {\n', '            IHiposwapV2Pair pair = IHiposwapV2Pair(HiposwapV2Library.makerPairFor(factory, path[i - 1], path[i]));\n', '            Reserve storage r = rs[address(pair)];\n', '            if (now > r.time.add(MIN_RESERVE_UPDATE_TIME)) {\n', '                (address token0, address token1) = HiposwapV2Library.sortTokens(path[i - 1], path[i]);\n', '                (r.reserve0, r.reserve1) = HiposwapV2Library.getReserves(IHiposwapV2Factory(factory).uniswapFactory(), token0, token1);\n', '                r.time = now;\n', '            }\n', '            (uint reserveIn, uint reserveOut) = path[i - 1] < path[i] ? (r.reserve0, r.reserve1) : (r.reserve1, r.reserve0);\n', '            (, uint makerReserveOut) = HiposwapV2Library.getMakerReserves(factory, path[i - 1], path[i]);\n', '            amounts[i - 1] = HiposwapV2Library.getMakerAmountIn(amounts[i], reserveIn, reserveOut, makerReserveOut, pair.getRemainPercent(), pair.getTotalPercent());\n', '            \n', '            if (path[i - 1] < path[i]) {\n', '                r.reserve0 = r.reserve0.add(amounts[i - 1] / 10);\n', '                r.reserve1 = r.reserve1.sub(amounts[i] / 10);\n', '            } else {\n', '                r.reserve1 = r.reserve1.add(amounts[i - 1] / 10);\n', '                r.reserve0 = r.reserve0.sub(amounts[i] / 10);\n', '            }\n', '        }\n', '    }\n', '    \n', '}']