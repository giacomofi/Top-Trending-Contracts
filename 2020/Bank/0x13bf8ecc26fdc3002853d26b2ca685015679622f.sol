['pragma solidity ^0.6.0;\n', '\n', 'interface ERC20Interface {\n', '    \n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address who) external view returns (uint256);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '  function approve(address spender, uint256 value) external returns (bool);\n', '  function approveAndCall(address spender, uint tokens, bytes calldata data) external returns (bool success);\n', '  function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract AxiaVault {\n', '    \n', '    address public AXIA;\n', '    address public SwapLiquidity;\n', '    address public OracleLiquidty;\n', '    address public DefiLiquidity;\n', '    \n', '    address owner = msg.sender;\n', '    uint256 public lastTradingFeeDistributionAxia;\n', '    uint256 public lastTradingFeeDistributionSwap;\n', '    uint256 public lastTradingFeeDistributionOracle;\n', '    uint256 public lastTradingFeeDistributionDefi;\n', '    \n', '    uint256 public migrationLock;\n', '    address public migrationRecipient;\n', '    \n', '    \n', '// Has a hardcap of 1% per trading fees distribution in one week.\n', '\n', '    function distributeAXIA(address recipient, uint256 amount) external {\n', '        uint256 TokenBalance = ERC20Interface(AXIA).balanceOf(address(this));\n', '        require(amount <= (TokenBalance / 10), "Amount is higher than 1% of AXIA vault balance"); // Max 1%\n', '        require(lastTradingFeeDistributionAxia + 168 hours < now, "Time is less than assigned time for distribution of Axia"); // Max once a week \n', '        require(msg.sender == owner, "No Authorization");\n', '               ERC20Interface(AXIA).transfer(recipient, amount);\n', '        lastTradingFeeDistributionAxia = now;\n', '    } \n', '    \n', '    function distributeSWAP(address recipient, uint256 amount) external {\n', '        uint256 TokenBalance = ERC20Interface(SwapLiquidity).balanceOf(address(this));\n', '        require(amount <= (TokenBalance / 10), "Amount is higher than 10% of SwapLiquidity vault balance"); // Max 10%\n', '        require(lastTradingFeeDistributionSwap + 1 weeks < now, "Time is less than assigned time for distribution of SwapLiquidity"); // Max once a week \n', '        require(msg.sender == owner, "No Authorization");\n', '               ERC20Interface(SwapLiquidity).transfer(recipient, amount);\n', '        lastTradingFeeDistributionSwap = now;\n', '    } \n', '    \n', '    function distributeORACLE(address recipient, uint256 amount) external {\n', '        uint256 TokenBalance = ERC20Interface(OracleLiquidty).balanceOf(address(this));\n', '        require(amount <= (TokenBalance / 10), "Amount is higher than 10% of OracleLiquidty vault balance"); // Max 10%\n', '        require(lastTradingFeeDistributionOracle + 1 weeks < now, "Time is less than assigned time for distribution of OracleLiquidty"); // Max once a week \n', '        require(msg.sender == owner, "No Authorization");\n', '               ERC20Interface(OracleLiquidty).transfer(recipient, amount);\n', '        lastTradingFeeDistributionOracle = now;\n', '    } \n', '    \n', '    function distributeDEFI(address recipient, uint256 amount) external {\n', '        uint256 TokenBalance = ERC20Interface(DefiLiquidity).balanceOf(address(this));\n', '        require(amount <= (TokenBalance / 10), "Amount is higher than 10% of DefiLiquidity vault balance"); // Max 10%\n', '        require(lastTradingFeeDistributionDefi + 1 weeks < now, "Time is less than assigned time for distribution of DefiLiquidity"); // Max once a week \n', '        require(msg.sender == owner, "No Authorization");\n', '               ERC20Interface(DefiLiquidity).transfer(recipient, amount);\n', '        lastTradingFeeDistributionDefi = now;\n', '    } \n', '    \n', '\n', '// Function allows liquidity to be migrated, after 10 weeks lockup - preventing abuse.\n', '\n', '\n', '    function startLiquidityMigration(address recipient) external {\n', '        require(msg.sender == owner, "No Authorization");\n', '        migrationLock = now + 10 weeks;\n', '        migrationRecipient = recipient;\n', '    }\n', '    \n', '    \n', '// Migrates liquidity to new location, assuming the 3 months lockup has passed -preventing abuse.\n', '\n', '    function processMigration() external {\n', '        \n', '        require(msg.sender == owner, "No Authorization");\n', '        require(migrationRecipient != address(0));\n', '        require(now > migrationLock);\n', '        \n', '        uint256 TokenBalance = ERC20Interface(AXIA).balanceOf(address(this));\n', '        uint256 TokenBalanceSwap = ERC20Interface(SwapLiquidity).balanceOf(address(this));\n', '        uint256 TokenBalanceOracle = ERC20Interface(OracleLiquidty).balanceOf(address(this));\n', '        uint256 TokenBalanceDefi = ERC20Interface(DefiLiquidity).balanceOf(address(this));\n', '        \n', '        ERC20Interface(AXIA).transfer(migrationRecipient, TokenBalance);\n', '        ERC20Interface(SwapLiquidity).transfer(migrationRecipient, TokenBalanceSwap);\n', '        ERC20Interface(OracleLiquidty).transfer(migrationRecipient, TokenBalanceOracle);\n', '        ERC20Interface(DefiLiquidity).transfer(migrationRecipient, TokenBalanceDefi);\n', '        \n', '    }  \n', '    \n', '    \n', '    // Setting the interracting tokens\n', '    \n', '    function startToken(address _AXIAaddress, address _SwapLiquidity, address _OracleLiquidity, address _DefiLiquidity) external {\n', '        require(msg.sender == owner);\n', '        AXIA = _AXIAaddress;\n', '        SwapLiquidity = _SwapLiquidity;\n', '        OracleLiquidty = _OracleLiquidity;\n', '        DefiLiquidity = _DefiLiquidity;\n', '    }\n', '    \n', '    \n', '}']