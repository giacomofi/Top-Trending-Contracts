['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\t\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '    address public admin;\n', '    address public dev;\n', '    \n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    function setAdmin(address _admin) public onlyOwner {\n', '        admin = _admin;\n', '    }\n', '\n', '    function setDev(address _dev) public onlyOwner {\n', '        dev = _dev;\n', '    }\n', '    \n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin || msg.sender == _owner);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyDev {\n', '        require(msg.sender == dev || msg.sender == admin || msg.sender == _owner);\n', '        _;\n', '    }    \n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '   function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'abstract contract ContractConn{\n', '\n', '    function transfer(address _to, uint256 _value) virtual public;\n', '    function balanceOf(address who) virtual public view returns (uint256);\n', '}\n', '\n', 'contract Minter is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '    uint256 public userMinted = 0;   \n', '    uint256 public minHandlingFee = 5;\n', '    uint256 public minHandlingFeeNew;\n', '    uint256 public handlingFeeRate = 4;\n', '    uint256 public handlingFeeRateNew;\n', '    uint256 public changeFeeWaitTime = 12000;\n', '    uint256 public changeFeeTime;\n', '\tbool    public needChangeFee = false;\n', '    uint256 public handlingFeeCollect;\n', '    uint256 public minedAmount;\n', '    address public collector = address(0);\n', '    \n', '    ContractConn public zild;    \n', '\n', '    mapping(address => uint256) public user_minter_amount;\n', '    mapping(address => uint256) public user_minter_netincome;\n', '    mapping(address => uint256) public user_minter_fee;\n', '    \n', '    event MinterRevenue(uint256 total,address indexed who,uint256 amount, uint256 handlingfee,uint256 netincome,uint256 userTotal);\n', '    event SetCollector(address indexed collector,uint256 time);\n', '    event CollectHandlingFee(uint256 amount,uint256 handlingFeeCollect,uint256 now);\n', '    event SetHandlingFee(uint256 fee,uint256 rate,address indexed who,uint256 time);\n', '    event EffectHandlingFee(uint256 fee,uint256 rate,address indexed who,uint256 time);\n', '    \n', '    constructor(address _token) public {\n', '        zild = ContractConn(_token);\n', '    }\n', '\n', '    function generate(uint256 amount) public onlyOwner returns(bool){\n', '        require(amount > 0, "minter：generate amount error");\n', '        require(amount <= zild.balanceOf(address(this)), "minter：insufficient balance generates more mines");\n', '        minedAmount = minedAmount.add(amount);\n', '        return true;\n', '    } \n', '    \n', '    function minter(address _to, uint256 amount) public onlyDev returns(bool){\n', '        require(amount > minHandlingFee.mul(10 ** 18).div(100), "minter：withdrawal amount must be greater than the minimum handling fee");\n', '        require(amount <= minedAmount,"minter：Not so many mined token");\n', '        uint256 handlingfee = amount.mul(handlingFeeRate).div(1000);\n', '        if (handlingfee < minHandlingFee.mul(10 ** 18).div(100)) handlingfee = minHandlingFee.mul(10 ** 18).div(100);\n', '        zild.transfer(_to,amount.sub(handlingfee));\n', '        minedAmount = minedAmount.sub(amount);\n', '        userMinted = userMinted.add(amount);\n', '        user_minter_amount[_to] = user_minter_amount[_to].add(amount);\n', '        user_minter_netincome[_to] = user_minter_netincome[_to].add(amount.sub(handlingfee));\n', '        user_minter_fee[_to] = user_minter_fee[_to].add(handlingfee);\n', '        handlingFeeCollect = handlingFeeCollect.add(handlingfee);\n', '        emit MinterRevenue(userMinted,_to,amount,handlingfee,amount.sub(handlingfee),user_minter_amount[_to]);\n', '        return true;\n', '    } \n', '\n', '    function setCollector(address _collector) public onlyAdmin {\n', '        require(_collector != address(0), "Minter: collector is the zero address");\n', '        collector = _collector;\n', '        emit SetCollector(_collector,now);\n', '    }\n', '    \n', '    function collectHandlingFee(uint256 amount) public onlyAdmin returns(bool){\n', '        require(amount > 0, "minter：collect amount error");\n', '        require(amount <= handlingFeeCollect, "minter：withdrawal amount exceeds collector balance");\n', '        zild.transfer(collector,amount);\n', '        handlingFeeCollect = handlingFeeCollect.sub(amount);\n', '        emit CollectHandlingFee(amount,handlingFeeCollect,now);\n', '        return true;\n', '    }     \n', '\n', '    function setHandlingFee(uint256 _fee,uint256 _rate) public onlyAdmin {\n', '        require(_fee > 0 || _rate > 0,"Minter: New handling fee rate must be greater than 0"); \n', '\t\tminHandlingFeeNew = _fee;\n', '        handlingFeeRateNew = _rate;\n', '        changeFeeTime = block.number;\n', '        needChangeFee = true;\n', '        emit SetHandlingFee(_fee,_rate,msg.sender,now);\n', '    }\n', '    \n', '    function effectblockchange() public onlyAdmin {\n', '        require(needChangeFee,"Minter: No new handling fee rate are set");\n', '        uint256 currentTime = block.number;\n', '        uint256 effectTime = changeFeeTime.add(changeFeeWaitTime);\n', '        if (currentTime < effectTime) return;\n', '        minHandlingFee = minHandlingFeeNew;\n', '        handlingFeeRate = handlingFeeRateNew;\n', '        needChangeFee = false;\n', '        emit EffectHandlingFee(minHandlingFee,handlingFeeRate,msg.sender,now);\n', '    } \n', '}']