['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) { return 0; }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint256 value) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint256 value) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint256 value) internal {\n', '        (bool success, ) = to.call{value: value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this;\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract UniLayerLimitOrder is Ownable {\n', '    using SafeMath for uint256;\n', '    \n', '    IUniswapV2Router02 public immutable uniswapV2Router;\n', '    IUniswapV2Factory public immutable uniswapV2Factory;\n', '    \n', '    enum OrderState {Created, Cancelled, Finished}\n', '    enum OrderType {EthForTokens, TokensForEth, TokensForTokens}\n', '    \n', '    struct Order {\n', '        OrderState orderState;\n', '        OrderType orderType;\n', '        address payable traderAddress;\n', '        address assetIn;\n', '        address assetOut;\n', '        uint assetInOffered;\n', '        uint assetOutExpected;\n', '        uint executorFee;\n', '        uint stake;\n', '        uint id;\n', '        uint ordersI;\n', '    }\n', '    \n', '    uint public STAKE_FEE = 2;\n', '    uint public STAKE_PERCENTAGE = 92;\n', '    uint public EXECUTOR_FEE = 500000000000000;\n', '    uint[] public orders;\n', '    uint public ordersNum = 0;\n', '    address public stakeAddress = address(0xC9f9de264cd16FD0e5b3FB4C1b276549f70814c7);\n', '    address public owAddress = address(0xc56dE69EC711D6E4A48283c346b1441f449eCA5A);\n', '    \n', '    event logOrderCreated(\n', '        uint id,\n', '        OrderState orderState, \n', '        OrderType orderType, \n', '        address payable traderAddress, \n', '        address assetIn, \n', '        address assetOut,\n', '        uint assetInOffered, \n', '        uint assetOutExpected, \n', '        uint executorFee\n', '    );\n', '    event logOrderCancelled(uint id, address payable traderAddress, address assetIn, address assetOut, uint refundETH, uint refundToken);\n', '    event logOrderExecuted(uint id, address executor, uint[] amounts);\n', '    \n', '    mapping(uint => Order) public orderBook;\n', '    mapping(address => uint[]) private ordersForAddress;\n', '    \n', '    constructor(IUniswapV2Router02 _uniswapV2Router) {\n', '        uniswapV2Router = _uniswapV2Router;\n', '        uniswapV2Factory = IUniswapV2Factory(_uniswapV2Router.factory());\n', '    }\n', '    \n', '    function setNewStakeFee(uint256 _STAKE_FEE) external onlyOwner {\n', '        STAKE_FEE = _STAKE_FEE;\n', '    }\n', '    \n', '    function setNewStakePercentage(uint256 _STAKE_PERCENTAGE) external onlyOwner {\n', "        require(_STAKE_PERCENTAGE >= 0 && _STAKE_PERCENTAGE <= 100,'STAKE_PERCENTAGE must be between 0 and 100');\n", '        STAKE_PERCENTAGE = _STAKE_PERCENTAGE;\n', '    }\n', '    \n', '    function setNewExecutorFee(uint256 _EXECUTOR_FEE) external onlyOwner {\n', '        EXECUTOR_FEE = _EXECUTOR_FEE;\n', '    }\n', '    \n', '    function setNewStakeAddress(address _stakeAddress) external onlyOwner {\n', "        require(_stakeAddress != address(0), 'Do not use 0 address');\n", '        stakeAddress = _stakeAddress;\n', '    }\n', '    \n', '    function setNewOwAddress(address _owAddress) external onlyOwner {\n', "        require(_owAddress != address(0), 'Do not use 0 address');\n", '        owAddress = _owAddress;\n', '    }\n', '    \n', '    function getPair(address tokenA, address tokenB) internal view returns (address) {\n', '        address _tokenPair = uniswapV2Factory.getPair(tokenA, tokenB);\n', '        require(_tokenPair != address(0), "Unavailable token pair");\n', '        return _tokenPair;\n', '    }\n', '    \n', '    function updateOrder(Order memory order, OrderState newState) internal {\n', '        if(orders.length > 1) {\n', '            uint openId = order.ordersI;\n', '            uint lastId = orders[orders.length-1];\n', '            Order memory lastOrder = orderBook[lastId];\n', '            lastOrder.ordersI = openId;\n', '            orderBook[lastId] = lastOrder;\n', '            orders[openId] = lastId;\n', '        }\n', '        orders.pop();\n', '        order.orderState = newState;\n', '        orderBook[order.id] = order;        \n', '    }\n', '    \n', '    function createOrder(OrderType orderType, address assetIn, address assetOut, uint assetInOffered, uint assetOutExpected, uint executorFee) external payable {\n', '        \n', '        uint payment = msg.value;\n', '        uint stakeValue = 0;\n', '        \n', '        require(assetInOffered > 0, "Asset in amount must be greater than 0");\n', '        require(assetOutExpected > 0, "Asset out amount must be greater than 0");\n', '        require(executorFee >= EXECUTOR_FEE, "Invalid fee");\n', '        \n', '        if(orderType == OrderType.EthForTokens) {\n', '            require(assetIn == uniswapV2Router.WETH(), "Use WETH as the assetIn");\n', '            stakeValue = assetInOffered.mul(STAKE_FEE).div(1000);\n', '            require(payment == assetInOffered.add(executorFee).add(stakeValue), "Payment = assetInOffered + executorFee + stakeValue");\n', '            TransferHelper.safeTransferETH(stakeAddress, stakeValue);\n', '        }\n', '        else {\n', '            require(payment == executorFee, "Transaction value must match executorFee");\n', '            if (orderType == OrderType.TokensForEth) { require(assetOut == uniswapV2Router.WETH(), "Use WETH as the assetOut"); }\n', '            TransferHelper.safeTransferFrom(assetIn, msg.sender, address(this), assetInOffered);\n', '        }\n', '        \n', '        \n', '        uint orderId = ordersNum;\n', '        ordersNum++;\n', '        \n', '        orderBook[orderId] = Order(OrderState.Created, orderType, msg.sender, assetIn, assetOut, assetInOffered, \n', '        assetOutExpected, executorFee, stakeValue, orderId, orders.length);\n', '        \n', '        ordersForAddress[msg.sender].push(orderId);\n', '        orders.push(orderId);\n', '        \n', '        emit logOrderCreated(\n', '            orderId, \n', '            OrderState.Created, \n', '            orderType, \n', '            msg.sender, \n', '            assetIn, \n', '            assetOut,\n', '            assetInOffered, \n', '            assetOutExpected, \n', '            executorFee\n', '        );\n', '    }\n', '    \n', '    function executeOrder(uint orderId) external returns (uint[] memory) {\n', '        Order memory order = orderBook[orderId];  \n', '        require(order.traderAddress != address(0), "Invalid order");\n', "        require(order.orderState == OrderState.Created, 'Invalid order state');\n", '        \n', '        updateOrder(order, OrderState.Finished);\n', '    \n', '        address[] memory pair = new address[](2);\n', '        pair[0] = order.assetIn;\n', '        pair[1] = order.assetOut;\n', '\n', '        uint[] memory swapResult;\n', '        \n', '        if (order.orderType == OrderType.EthForTokens) {\n', '            swapResult = uniswapV2Router.swapExactETHForTokens{value:order.assetInOffered}(order.assetOutExpected, pair, order.traderAddress, block.timestamp);\n', '            TransferHelper.safeTransferETH(stakeAddress, order.stake.mul(STAKE_PERCENTAGE).div(100));\n', '            TransferHelper.safeTransferETH(owAddress, order.stake.mul(100-STAKE_PERCENTAGE).div(100));\n', '        } \n', '        else if (order.orderType == OrderType.TokensForEth) {\n', '            TransferHelper.safeApprove(order.assetIn, address(uniswapV2Router), order.assetInOffered);\n', '            swapResult = uniswapV2Router.swapExactTokensForETH(order.assetInOffered, order.assetOutExpected, pair, order.traderAddress, block.timestamp);\n', '        }\n', '        else if (order.orderType == OrderType.TokensForTokens) {\n', '            TransferHelper.safeApprove(order.assetIn, address(uniswapV2Router), order.assetInOffered);\n', '            swapResult = uniswapV2Router.swapExactTokensForTokens(order.assetInOffered, order.assetOutExpected, pair, order.traderAddress, block.timestamp);\n', '        }\n', '        \n', '        TransferHelper.safeTransferETH(msg.sender, order.executorFee);\n', '        emit logOrderExecuted(order.id, msg.sender, swapResult);\n', '        \n', '        return swapResult;\n', '    }\n', '    \n', '    function cancelOrder(uint orderId) external {\n', '        Order memory order = orderBook[orderId];  \n', '        require(order.traderAddress != address(0), "Invalid order");\n', "        require(msg.sender == order.traderAddress, 'This order is not yours');\n", "        require(order.orderState == OrderState.Created, 'Invalid order state');\n", '        \n', '        updateOrder(order, OrderState.Cancelled);\n', '        \n', '        uint refundETH = 0;\n', '        uint refundToken = 0;\n', '        \n', '        if (order.orderType != OrderType.EthForTokens) {\n', '            refundETH = order.executorFee;\n', '            refundToken = order.assetInOffered;\n', '            TransferHelper.safeTransferETH(order.traderAddress, refundETH);\n', '            TransferHelper.safeTransfer(order.assetIn, order.traderAddress, refundToken);\n', '        }\n', '        else {\n', '            refundETH = order.assetInOffered.add(order.executorFee).add(order.stake);\n', '            TransferHelper.safeTransferETH(order.traderAddress, refundETH);  \n', '        }\n', '        \n', '        emit logOrderCancelled(order.id, order.traderAddress, order.assetIn, order.assetOut, refundETH, refundToken);        \n', '    }\n', '    \n', '    function calculatePaymentETH(uint ethValue) external view returns (uint valueEth, uint stake, uint executorFee, uint total) {\n', '        uint pay = ethValue;\n', '        uint stakep = pay.mul(STAKE_FEE).div(1000);\n', '        uint totalp = (pay.add(stakep).add(EXECUTOR_FEE));\n', '        return (pay, stakep, EXECUTOR_FEE, totalp);\n', '    }\n', '    \n', '    function getOrdersLength() external view returns (uint) {\n', '        return orders.length;\n', '    }\n', '    \n', '    function getOrdersForAddressLength(address _address) external view returns (uint)\n', '    {\n', '        return ordersForAddress[_address].length;\n', '    }\n', '\n', '    function getOrderIdForAddress(address _address, uint index) external view returns (uint)\n', '    {\n', '        return ordersForAddress[_address][index];\n', '    }    \n', '    \n', '    receive() external payable {}\n', '    \n', '}']