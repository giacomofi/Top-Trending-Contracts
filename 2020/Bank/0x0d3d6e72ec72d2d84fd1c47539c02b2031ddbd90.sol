['pragma solidity ^0.5.16;\n', '\n', '/**\n', '  * @title Artem Token Pool\n', "  * @notice Derived from Compound's Reservoir\n", '  *         https://github.com/compound-finance/compound-protocol/tree/master/contracts\n', '  */\n', '/**\n', ' * @title ERC 20 Token Standard Interface\n', ' *  https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface EIP20Interface {\n', '    \n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '\n', '    /**\n', '      * @notice Get the total number of tokens in circulation\n', '      * @return The supply of tokens\n', '      */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @notice Gets the balance of the specified address\n', '     * @param owner The address from which the balance will be retrieved\n', '     * @return The balance\n', '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n', '      * @param dst The address of the destination account\n', '      * @param amount The number of tokens to transfer\n', '      * @return Whether or not the transfer succeeded\n', '      */\n', '    function transfer(address dst, uint256 amount) external returns (bool success);\n', '\n', '    /**\n', '      * @notice Transfer `amount` tokens from `src` to `dst`\n', '      * @param src The address of the source account\n', '      * @param dst The address of the destination account\n', '      * @param amount The number of tokens to transfer\n', '      * @return Whether or not the transfer succeeded\n', '      */\n', '    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\n', '\n', '    /**\n', '      * @notice Approve `spender` to transfer up to `amount` from `src`\n', '      * @dev This will overwrite the approval amount for `spender`\n', '      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n', '      * @param spender The address of the account which may transfer tokens\n', '      * @param amount The number of tokens that are approved (-1 means infinite)\n', '      * @return Whether or not the approval succeeded\n', '      */\n', '    function approve(address spender, uint256 amount) external returns (bool success);\n', '\n', '    /**\n', '      * @notice Get the current allowance from `owner` for `spender`\n', '      * @param owner The address of the account which owns the tokens to be spent\n', '      * @param spender The address of the account which may transfer tokens\n', '      * @return The number of tokens allowed to be spent (-1 means infinite)\n', '      */\n', '    function allowance(address owner, address spender) external view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 amount);\n', '    event Approval(address indexed owner, address indexed spender, uint256 amount);\n', '}\n', '\n', '\n', 'contract ArtemPool {\n', '\n', '  /// @notice The block number when the Reservoir started (immutable)\n', '  uint public dripStart;\n', '\n', '  /// @notice Tokens per block that to drip to target (immutable)\n', '  uint public dripRate;\n', '\n', '  /// @notice Reference to token to drip (immutable)\n', '  EIP20Interface public token;\n', '\n', '  /// @notice Target to receive dripped tokens (immutable)\n', '  address public target;\n', '\n', '  /// @notice Amount that has already been dripped\n', '  uint public dripped;\n', '\n', '  constructor(uint dripRate_, EIP20Interface token_, address target_) public {\n', '    dripStart = block.number;\n', '    dripRate = dripRate_;\n', '    token = token_;\n', '    target = target_;\n', '    dripped = 0;\n', '  }\n', '\n', '\n', '  function drip() public returns (uint) {\n', '\n', '    EIP20Interface token_ = token;\n', '    uint reservoirBalance_ = token_.balanceOf(address(this)); \n', '    uint dripRate_ = dripRate;\n', '    uint dripStart_ = dripStart;\n', '    uint dripped_ = dripped;\n', '    address target_ = target;\n', '    uint blockNumber_ = block.number;\n', '\n', '    // Calculate intermediate values\n', '    uint dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, "dripTotal overflow");\n', '    uint deltaDrip_ = sub(dripTotal_, dripped_, "deltaDrip underflow");\n', '    uint toDrip_ = min(reservoirBalance_, deltaDrip_);\n', '    uint drippedNext_ = add(dripped_, toDrip_, "tautological");\n', '\n', '    dripped = drippedNext_;\n', '    token_.transfer(target_, toDrip_);\n', '\n', '    return toDrip_;\n', '  }\n', '\n', '  // SafeMath\n', '\n', '  function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    require(c >= a, errorMessage);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '    require(b <= a, errorMessage);\n', '    uint c = a - b;\n', '    return c;\n', '  }\n', '\n', '  function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint c = a * b;\n', '    require(c / a == b, errorMessage);\n', '    return c;\n', '  }\n', '\n', '  function min(uint a, uint b) internal pure returns (uint) {\n', '    if (a <= b) {\n', '      return a;\n', '    } else {\n', '      return b;\n', '    }\n', '  }\n', '}']