['pragma solidity^0.6.0;\n', '/*\n', '* Team Equitable Builds Inc presents..\n', '* ====================================*\n', '*        _____ ___ _______ ______     *\n', '*       |  _  |  ||  |  __|   __|     *\n', '*       |     |  |  |  __|   |__      *\n', '*       |__|__|_____|____|_____|      *\n', '*                                     *\n', '* ====================================*\n', '*/\n', 'contract AVEC{\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '    //verify caller address members_ = true\n', '    modifier onlyMembers(address _customerAddress) {\n', '        require(\n', '                // is the customer in the member whitelist?\n', '                members_[_customerAddress] == true\n', '            );\n', '            // execute\n', '        _;\n', '    }\n', '    //verify caller address founderdevelopers_ = true\n', '    modifier onlyFounderDevelopers(address _customerAddress) {\n', '        require(\n', '                // is the customer in the Founder Developer whitelist?\n', '                founderdevelopers_[_customerAddress] == true\n', '            );\n', '            // execute\n', '        _;\n', '    }\n', '    //verify caller address ceva_ = true\n', '    modifier onlyCEVA(address _customerAddress) {\n', '        require(\n', '                // is the customer in the ceva whitelist?\n', '                ceva_[_customerAddress] == true\n', '            );\n', '            // execute\n', '        _;\n', '    }\n', '    modifier onlyAdministrator(address _customerAddress){\n', '        require(\n', '            administrators[_customerAddress] == true\n', '            );\n', '        _;\n', '    }\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 tokensWithdrawn\n', '    );\n', '    // ERC20\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '    event Burn(\n', '        address indexed from,\n', '        uint256 tokens,\n', '        uint256 propertyValue\n', '    );\n', '    // ERC20\n', '    event Approval(\n', '        address indexed _owner, \n', '        address indexed _spender, \n', '        uint256 _value\n', '    );\n', '    event PropertyValuation(\n', '        address indexed from,\n', '        bytes32 _propertyUniqueID,\n', '        uint256 propertyValue\n', '    );\n', '    event PropertyWhitelisted(\n', '        address indexed from,\n', '        bytes32 _propertyUniqueID,\n', '        bool _trueFalse\n', '    );\n', '    event MemberWhitelisted(\n', '        address indexed from,\n', '        address indexed to,\n', '        bool _trueFalse\n', '    );\n', '    event FounderDeveloperWhitelisted(\n', '        address indexed from,\n', '        address indexed to,\n', '        bool _trueFalse\n', '    );\n', '    event CEVAWhitelisted(\n', '        address indexed from,\n', '        address indexed to,\n', '        bool _trueFalse\n', '    );\n', '    event AdminWhitelisted(\n', '        address indexed from,\n', '        address indexed to,\n', '        bool _trueFalse\n', '    );\n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '    string private name = "AlternateVirtualEquityCredits";\n', '    string private symbol = "AVEC";\n', '    uint8 private decimals = 18;\n', '    address internal whoaaddress_ = 0x314d0ED76d866826C809fb6a51d63642b2E9eC3e;\n', '    address internal whoamaintenanceaddress_ = 0x2722B426B11978c29660e8395a423Ccb93AE0403;\n', '    address internal whoarewardsaddress_ = 0xA9d241b568DF9E8A7Ec9e44737f29a8Ee00bfF53;\n', '    address internal cevaaddress_ = 0xdE281c22976dE2E9b3f4F87bEB60aE9E67DFf5C4;\n', '    address internal credibleyouaddress_ = 0xc9c1Ffd6B4014232Ef474Daa4CA1506A6E39Be89;\n', '    address internal techaddress_ = 0xB6148C62e6A6d48f41241D01e3C4841139144ABa;\n', '    address internal existholdingsaddress_ = 0xac1B6580a175C1f2a4e3220A24e6f65fF3AB8A03;\n', '    address internal existcryptoaddress_ = 0xb8C098eE976f1162aD277936a5D1BCA7a8Fe61f5;\n', '    // founder developer address whitelist archive\n', '    mapping(address => bool) internal members_;\n', '    // members whitelist address archive\n', '    mapping(address => bool) internal founderdevelopers_;\n', '    // ceva whitelist address archive\n', '    mapping(address => bool) internal ceva_;\n', '    // administrator list (see above on what they can do)\n', '    mapping(address => bool) internal administrators;\n', '    // setting for allowance function determines amount of tokens address can spend from mapped address\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '    mapping (address => mapping(bytes32 => bool)) internal mintrequestwhitelist_;\n', '    mapping (address => mapping(bytes32 => bool)) internal burnrequestwhitelist_;\n', '    mapping (address => mapping(bytes32 => bool)) internal propertywhitelist_;\n', '    mapping (address => mapping(bytes32 => uint256)) internal propertyvalue_;\n', '    mapping(address => bytes32) workingPropertyid_;\n', '    mapping(address => bytes32) workingMintRequestid_;\n', '    mapping(address => bytes32) workingBurnRequestid_;\n', '   /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    // amount of shares for each address (scaled number)\n', '    mapping(address => uint256) internal tokenBalanceLedger_ ;\n', '    mapping(address => uint256) internal mintingDepositsOf_;\n', '    mapping(address => uint256) internal AmountCirculated_;\n', '    mapping(address => uint256) internal taxesFeeTotalWithdrawn_;\n', '    mapping(address => uint256) internal taxesPreviousWithdrawn_;\n', '    mapping(address => uint256) internal taxesFeeSharehold_;\n', '    mapping(address => uint256) internal insuranceFeeTotalWithdrawn_;\n', '    mapping(address => uint256) internal insurancePreviousWithdrawn_;\n', '    mapping(address => uint256) internal insuranceFeeSharehold_;\n', '    mapping(address => uint256) internal maintenanceFeeTotalWithdrawn_;\n', '    mapping(address => uint256) internal maintenancePreviousWithdrawn_;\n', '    mapping(address => uint256) internal maintenanceFeeSharehold_;\n', '    mapping(address => uint256) internal waECOFeeTotalWithdrawn_;\n', '    mapping(address => uint256) internal waECOPreviousWithdrawn_;\n', '    mapping(address => uint256) internal waECOFeeSharehold_;\n', '    mapping(address => uint256) internal holdoneTotalWithdrawn_;\n', '    mapping(address => uint256) internal holdonePreviousWithdrawn_;\n', '    mapping(address => uint256) internal holdoneSharehold_;\n', '    mapping(address => uint256) internal holdtwoTotalWithdrawn_;\n', '    mapping(address => uint256) internal holdtwoPreviousWithdrawn_;\n', '    mapping(address => uint256) internal holdtwoSharehold_;\n', '    mapping(address => uint256) internal holdthreeTotalWithdrawn_;\n', '    mapping(address => uint256) internal holdthreePreviousWithdrawn_;\n', '    mapping(address => uint256) internal holdthreeSharehold_;\n', '    mapping(address => uint256) internal rewardsTotalWithdrawn_;\n', '    mapping(address => uint256) internal rewardsPreviousWithdrawn_;\n', '    mapping(address => uint256) internal rewardsSharehold_;\n', '    mapping(address => uint256) internal techTotalWithdrawn_;\n', '    mapping(address => uint256) internal techPreviousWithdrawn_;\n', '    mapping(address => uint256) internal techSharehold_;\n', '    mapping(address => uint256) internal existholdingsTotalWithdrawn_;\n', '    mapping(address => uint256) internal existholdingsPreviousWithdrawn_;\n', '    mapping(address => uint256) internal existholdingsSharehold_;\n', '    mapping(address => uint256) internal existcryptoTotalWithdrawn_;\n', '    mapping(address => uint256) internal existcryptoPreviousWithdrawn_;\n', '    mapping(address => uint256) internal existcryptoSharehold_;\n', '    mapping(address => uint256) internal whoaTotalWithdrawn_;\n', '    mapping(address => uint256) internal whoaPreviousWithdrawn_;\n', '    mapping(address => uint256) internal whoaSharehold_;\n', '    mapping(address => uint256) internal credibleyouTotalWithdrawn_;\n', '    mapping(address => uint256) internal credibleyouPreviousWithdrawn_;\n', '    mapping(address => uint256) internal credibleyouSharehold_;\n', '    mapping(address => uint256) internal numberofmintingrequestswhitelisted_;\n', '    mapping(address => uint256) internal numberofpropertieswhitelisted_;\n', '    mapping(address => uint256) internal numberofburnrequestswhitelisted_;\n', '    mapping(address => uint256) internal transferingFromWallet_;\n', '    uint256 public tokenSupply_ = 0;\n', '    uint256 public feeTotalHolds_ = 0;\n', '    uint256 internal cevaBurnerStockpile_ = 0;\n', '    uint256 internal cevaBurnerStockpileWithdrawn_ = 0;\n', '    uint256 internal taxesfeeTotalHolds_ = 0;\n', '    uint256 internal taxesfeeBalanceLedger_ = 0;\n', '    uint256 internal insurancefeeTotalHolds_ = 0;\n', '    uint256 internal insurancefeeBalanceLedger_ = 0;\n', '    uint256 internal maintencancefeeTotalHolds_ = 0;\n', '    uint256 internal maintenancefeeBalanceLedger_ = 0;\n', '    uint256 internal waECOfeeTotalHolds_ = 0;\n', '    uint256 internal waECOfeeBalanceLedger_ = 0;\n', '    uint256 internal holdonefeeTotalHolds_ = 0;\n', '    uint256 internal holdonefeeBalanceLedger_ = 0;\n', '    uint256 internal holdtwofeeTotalHolds_ = 0;\n', '    uint256 internal holdtwofeeBalanceLedger_ = 0;\n', '    uint256 internal holdthreefeeTotalHolds_ = 0;\n', '    uint256 internal holdthreefeeBalanceLedger_ = 0;\n', '    uint256 internal RewardsfeeTotalHolds_ = 0;\n', '    uint256 internal RewardsfeeBalanceLedger_ = 0;\n', '    uint256 internal techfeeTotalHolds_ = 0;\n', '    uint256 internal techfeeBalanceLedger_ = 0;\n', '    uint256 internal existholdingsfeeTotalHolds_ = 0;\n', '    uint256 internal existholdingsfeeBalanceLedger_ = 0;\n', '    uint256 internal existcryptofeeTotalHolds_ = 0;\n', '    uint256 internal existcryptofeeBalanceLedger_ = 0;\n', '    uint256 internal whoafeeTotalHolds_ = 0;\n', '    uint256 internal whoafeeBalanceLedger_ = 0;\n', '    uint256 internal credibleyoufeeTotalHolds_ = 0;\n', '    uint256 internal credibleyoufeeBalanceLedger_ = 0;\n', '    /*=======================================\n', '    =            MEMBER FUNCTIONS            =\n', '    =======================================*/\n', '    /*\n', '    * -- APPLICATION ENTRY POINTS -- \n', '    */\n', '    constructor()\n', '        public\n', '    {\n', '    }\n', '    /*\n', '    * -- APPLICATION ENTRY POINTS -- \n', '    */\n', '    function InitialSet()\n', '        public\n', '    {\n', '        // add the first users\n', '        //James Admin\n', '        administrators[0x27851761A8fBC03f57965b42528B39af07cdC42b] = true;\n', '        //Brenden Admin\n', '        administrators[0xA9873d93db3BCA9F68aDfEAb226Fa9189641069A] = true;\n', '        members_[0x314d0ED76d866826C809fb6a51d63642b2E9eC3e] = true;\n', '        members_[0x2722B426B11978c29660e8395a423Ccb93AE0403] = true;\n', '        members_[0xdE281c22976dE2E9b3f4F87bEB60aE9E67DFf5C4] = true;\n', '        members_[0xc9c1Ffd6B4014232Ef474Daa4CA1506A6E39Be89] = true;\n', '        members_[0xac1B6580a175C1f2a4e3220A24e6f65fF3AB8A03] = true;\n', '        members_[0xb8C098eE976f1162aD277936a5D1BCA7a8Fe61f5] = true;\n', '        members_[0xB6148C62e6A6d48f41241D01e3C4841139144ABa] = true;\n', '        members_[0xA9d241b568DF9E8A7Ec9e44737f29a8Ee00bfF53] = true;\n', '        members_[0x314d0ED76d866826C809fb6a51d63642b2E9eC3e] = true;\n', '        members_[0x314d0ED76d866826C809fb6a51d63642b2E9eC3e] = true;\n', '        \n', '    }\n', '    /*\n', '    * -- APPLICATION ENTRY POINTS -- \n', '    */\n', '    function genesis(address _existcryptoaddress, address _existhooldingsaddress, address _techaddress, \n', '        address _credibleyouaddress, address _cevaaddress, address _whoaddress, address _whoarewardsaddress, address _whoamaintenanceaddress)\n', '        public\n', '        onlyAdministrator(msg.sender)\n', '    {\n', '        require(administrators[msg.sender]);\n', '        // adds the first founder developer here.\n', '        founderdevelopers_[msg.sender] = true;\n', '        // adds the _whoaddress input as the current whoa address\n', '        whoaaddress_ = _whoaddress;\n', '        // adds the _whoamaintenanceaddress input as the current whoa maintenence address\n', '        whoamaintenanceaddress_ = _whoamaintenanceaddress;\n', '        // adds the _whoarewardsaddress input as the current whoa rewards address\n', '        whoarewardsaddress_ = _whoarewardsaddress;\n', '        // adds the )cevaaddress_ input as the current ceva address\n', '        cevaaddress_ = _cevaaddress;\n', '        // adds the _credibleyouaddress input as the current credible you address\n', '        credibleyouaddress_ = _credibleyouaddress;\n', '        // adds the _techaddress input as the current tech address\n', '        techaddress_ = _techaddress;\n', '        // adds the __existhooldingsaddress input as the current exist holdings address\n', '        existholdingsaddress_ = _existhooldingsaddress;\n', '        // adds the _existcryptoaddress input as the current exist crypto address\n', '        existcryptoaddress_ = _existcryptoaddress;\n', '        // adds the first ceva qualified founder developers here.\n', '        ceva_[msg.sender] = true;\n', '        numberofburnrequestswhitelisted_[msg.sender] = 0;\n', '        numberofpropertieswhitelisted_[msg.sender] = 0;\n', '        numberofmintingrequestswhitelisted_[msg.sender] = 0;\n', '        // adds the first member here.\n', '        members_[msg.sender] = true;\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function buyFounderDeveloperLicense(address _FounderDeveloperOne, address _FounderDeveloperTwo, address _CEVA)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool _success)\n', '    {\n', '        require(founderdevelopers_[_FounderDeveloperOne] == true && ceva_[_CEVA] == true && founderdevelopers_[_FounderDeveloperTwo] == true);\n', '        // setup data\n', '            address _customerAddress = msg.sender;\n', '            uint256 _licenseprice = (1000 * 1e18);\n', '            if(tokenBalanceLedger_[_customerAddress] > _licenseprice){\n', '                tokenBalanceLedger_[_CEVA] = (_licenseprice / 5) + tokenBalanceLedger_[_CEVA];\n', '                tokenBalanceLedger_[_FounderDeveloperOne] =  (_licenseprice / 5) + tokenBalanceLedger_[_FounderDeveloperOne];\n', '                tokenBalanceLedger_[_FounderDeveloperTwo] =  (_licenseprice / 10) + tokenBalanceLedger_[_FounderDeveloperTwo];\n', '                tokenBalanceLedger_[_customerAddress] =  tokenBalanceLedger_[_customerAddress] - _licenseprice;\n', '                founderdevelopers_[_customerAddress] = true;\n', '                return true;\n', '            } else {\n', '                return false;\n', '        }\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawTaxesdividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = EtaxesdividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        taxesFeeTotalWithdrawn_[_customerAddress] +=  _dividends;\n', '        tokenBalanceLedger_[_customerAddress] +=  _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawInsurancedividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = EinsurancedividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        insuranceFeeTotalWithdrawn_[_customerAddress] += _dividends;\n', '        tokenBalanceLedger_[_customerAddress] += _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawMaintenancedividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = EmaintenancedividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        maintenanceFeeTotalWithdrawn_[_customerAddress] += _dividends;\n', '        tokenBalanceLedger_[_customerAddress] += _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawwaECOdividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = EwaECOdividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        maintenanceFeeTotalWithdrawn_[_customerAddress] +=  _dividends;\n', '        waECOFeeTotalWithdrawn_[_customerAddress] +=  _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawHoldOnedividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = EholdonedividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        holdoneTotalWithdrawn_[_customerAddress] +=  _dividends;\n', '        tokenBalanceLedger_[_customerAddress] +=  _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawHoldTwodividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = EholdtwodividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        holdtwoTotalWithdrawn_[_customerAddress] +=  _dividends;\n', '        tokenBalanceLedger_[_customerAddress] +=  _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawHoldThreeedividends()\n', '        onlyMembers(msg.sender)\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = EholdthreedividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        holdthreeTotalWithdrawn_[_customerAddress] +=  _dividends;\n', '        tokenBalanceLedger_[_customerAddress] +=  _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawRewardsdividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = ErewardsdividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        rewardsTotalWithdrawn_[_customerAddress] +=  _dividends;\n', '        tokenBalanceLedger_[_customerAddress] +=  _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawTechdividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = EtechdividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        techTotalWithdrawn_[_customerAddress] +=  _dividends;\n', '        tokenBalanceLedger_[_customerAddress] +=  _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawExistHoldingsdividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = existholdingsdividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        existholdingsTotalWithdrawn_[_customerAddress] +=  _dividends;\n', '        tokenBalanceLedger_[_customerAddress] +=  _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawExistCryptodividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = existcryptodividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        existcryptoTotalWithdrawn_[_customerAddress] +=  _dividends;\n', '        tokenBalanceLedger_[_customerAddress] +=  _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawWHOAdividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = EwhoadividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        whoaTotalWithdrawn_[_customerAddress] +=  _dividends;\n', '        tokenBalanceLedger_[_customerAddress] +=  _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Withdraws all of the callers taxes earnings.\n', '     */\n', '    function withdrawCrediblelYoudividends()\n', '        public\n', '    {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = EcredibleyoudividendsOf(msg.sender);\n', '        // update dividend tracker\n', '        credibleyouTotalWithdrawn_[_customerAddress] +=  _dividends;\n', '        tokenBalanceLedger_[_customerAddress] +=  _dividends;\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '    /**\n', '     * Transfer tokens from the caller to a new holder.\n', "     * Remember, there's a 2% fee here as well. members only\n", '     */\n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amountOfTokens > 0){\n', '        // make sure we have the requested tokens\n', '            require(_amountOfTokens + (_amountOfTokens / 50) <= tokenBalanceLedger_[msg.sender] && \n', '            _amountOfTokens >= 0 && _toAddress != msg.sender && members_[_toAddress] == true);\n', '        //Exchange tokens\n', '            tokenBalanceLedger_[_toAddress] = tokenBalanceLedger_[_toAddress] + _amountOfTokens;\n', '            tokenBalanceLedger_[msg.sender] -= _amountOfTokens + (_amountOfTokens / 50);\n', '        //Update Equity Rents\n', '            updateEquityRents(_amountOfTokens);\n', '            AmountCirculated_[msg.sender] += _amountOfTokens;\n', '            emit Transfer(msg.sender, _toAddress, (_amountOfTokens + (_amountOfTokens / 50)));\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer tokens from the caller to a new holder.\n', "     * Remember, there's a 2% fee here as well. members only\n", '     */\n', '    function transferFrom(address from, address to, uint256 tokens)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(tokens >= 0){\n', '            require(members_[to] == true);\n', '            // setup\n', '            address _customerAddress = msg.sender;\n', '            // make sure we have the requested tokens\n', '            require(tokens + (tokens / 50) <= tokenBalanceLedger_[from] && tokens >= 0 && to != _customerAddress && from != to && \n', '            tokens + (tokens / 50) <= _allowed[from][msg.sender] && msg.sender != from && transferingFromWallet_[msg.sender] == 0);\n', '            transferingFromWallet_[msg.sender] = 1;\n', '            //Exchange tokens\n', '            tokenBalanceLedger_[to] = tokenBalanceLedger_[to] + tokens;\n', '            tokenBalanceLedger_[msg.sender] -= tokens + (tokens / 50);\n', '            //Reduce Approval Amount\n', '            _allowed[from][msg.sender] -= tokens + (tokens / 50);\n', '            emit Transfer(_customerAddress, to, (tokens + (tokens / 50)));\n', '            transferingFromWallet_[msg.sender] = 0;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', "    // transferred to the spender's account\n", '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return _allowed[tokenOwner][spender];\n', '    }\n', '     /**\n', '     * Transfer tokens from the caller to a new holder.\n', "     * Remember, there's a 2% fee here as well. members only\n", '     */\n', '    function clearTitle(uint256 _propertyValue, uint256 _amountOfTokens, address _clearFrom)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if((_amountOfTokens / 1e18) * 100 <= _propertyValue){\n', '            require(burnrequestwhitelist_[_clearFrom][workingBurnRequestid_[msg.sender]] == true && propertywhitelist_[_clearFrom][workingPropertyid_[msg.sender]] == true && \n', '            _amountOfTokens <= tokenBalanceLedger_[_clearFrom] && _amountOfTokens >= 0);\n', '            //Burn Tokens\n', '            burnA(_propertyValue);\n', '            tokenSupply_ -= _amountOfTokens;\n', '            taxesfeeTotalHolds_ -= _propertyValue / 100;\n', '            insurancefeeTotalHolds_ -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            maintencancefeeTotalHolds_ -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            waECOfeeTotalHolds_ -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            holdonefeeTotalHolds_ -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            holdtwofeeTotalHolds_ -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            holdthreefeeTotalHolds_ -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100); \n', '            // take tokens out of stockpile\n', '            //Exchange tokens\n', '            cevaBurnerStockpile_ -= ((propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100) * 1e18) - _amountOfTokens;\n', '            tokenBalanceLedger_[msg.sender] -= _amountOfTokens;\n', '            //  burn fee shareholds\n', '            taxesFeeSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            insuranceFeeSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            maintenanceFeeSharehold_[whoamaintenanceaddress_] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            waECOFeeSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            holdoneSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            holdtwoSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            holdthreeSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            rewardsSharehold_[msg.sender] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            techSharehold_[techaddress_] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            existholdingsSharehold_[existholdingsaddress_] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            existcryptoSharehold_[existcryptoaddress_] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            whoaSharehold_[whoaaddress_] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            credibleyouSharehold_[credibleyouaddress_] -= (propertyvalue_[_clearFrom][workingPropertyid_[msg.sender]] / 100);\n', '            // returns bool true\n', '            emit Burn(msg.sender, _amountOfTokens, _propertyValue);\n', '            \n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellTaxesFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            require(members_[_toAddress] == true);\n', '        // setup\n', '            address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= taxesFeeSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                taxesPreviousWithdrawn_[_toAddress] += (taxesFeeTotalWithdrawn_[_customerAddress] / taxesFeeSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                taxesFeeSharehold_[_toAddress] += _amount;\n', '                taxesFeeSharehold_[_customerAddress] -= _amount;\n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellInsuranceFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            require(members_[_toAddress] == true);\n', '        // setup\n', '            address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= insuranceFeeSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                insurancePreviousWithdrawn_[_toAddress] += (insuranceFeeTotalWithdrawn_[_customerAddress] / insuranceFeeSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                insuranceFeeSharehold_[_toAddress] += _amount;\n', '                insuranceFeeSharehold_[_customerAddress] -= _amount;\n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellMaintenanceFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            require(members_[_toAddress] == true);\n', '        // setup\n', '            address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= maintenanceFeeSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                maintenancePreviousWithdrawn_[_toAddress] += (maintenanceFeeTotalWithdrawn_[_customerAddress] / maintenanceFeeSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                maintenanceFeeSharehold_[_toAddress] += _amount;\n', '                maintenanceFeeSharehold_[_customerAddress] -= _amount;\n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellwaECOFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            require(members_[_toAddress] == true);\n', '        // setup\n', '            address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= waECOFeeSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                waECOPreviousWithdrawn_[_toAddress] += (waECOFeeTotalWithdrawn_[_customerAddress] / waECOFeeSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                waECOFeeSharehold_[_toAddress] += _amount;\n', '                waECOFeeSharehold_[_customerAddress] -= _amount;\n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellHoldOneFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            require(members_[_toAddress] == true);\n', '        // setup\n', '            address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= holdoneSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                holdonePreviousWithdrawn_[_toAddress] += (holdoneTotalWithdrawn_[_customerAddress] / holdoneSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                holdoneSharehold_[_toAddress] += _amount;\n', '                holdoneSharehold_[_customerAddress] -= _amount;\n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellHoldTwoFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            require(members_[_toAddress] == true);\n', '        // setup\n', '            address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= holdtwoSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                holdtwoPreviousWithdrawn_[_toAddress] += (holdtwoTotalWithdrawn_[_customerAddress] / holdtwoSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                holdtwoSharehold_[_toAddress] += _amount;\n', '                holdtwoSharehold_[_customerAddress] -= _amount;\n', '            \n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellHoldThreeFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            require(members_[_toAddress] == true);\n', '        // setup\n', '            address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= holdthreeSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                holdthreePreviousWithdrawn_[_toAddress] += (holdthreeTotalWithdrawn_[_customerAddress] / holdthreeSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                holdthreeSharehold_[_toAddress] += _amount;\n', '                holdthreeSharehold_[_customerAddress] -= _amount;\n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellRewardsFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            require(members_[_toAddress] == true);\n', '        // setup\n', '            address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= rewardsSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                rewardsPreviousWithdrawn_[_toAddress] += (rewardsTotalWithdrawn_[_customerAddress] / rewardsSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                rewardsSharehold_[_toAddress] += _amount;\n', '                rewardsSharehold_[_customerAddress] -= _amount;\n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellTechFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            require(members_[_toAddress] == true);\n', '        // setup\n', '            address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= techSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                techPreviousWithdrawn_[_toAddress] += (techTotalWithdrawn_[_customerAddress] / techSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                techSharehold_[_toAddress] += _amount;\n', '                techSharehold_[_customerAddress] -= _amount;\n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellExistHoldingsFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        onlyMembers(_toAddress)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            //require(members_[_toAddress] == true);\n', '        // setup\n', '            address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= existholdingsSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                existholdingsPreviousWithdrawn_[_toAddress] += (existholdingsTotalWithdrawn_[_customerAddress] / existholdingsSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                existholdingsSharehold_[_toAddress] += _amount;\n', '                existholdingsSharehold_[_customerAddress] -= _amount;\n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellExistCryptoFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            require(members_[_toAddress] == true);\n', '        // setup\n', '            address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= existcryptoSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                existcryptoPreviousWithdrawn_[_toAddress] += (existcryptoTotalWithdrawn_[_customerAddress] / existcryptoSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                existcryptoSharehold_[_toAddress] += _amount;\n', '                existcryptoSharehold_[_customerAddress] -= _amount;\n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellWHOAFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            require(members_[_toAddress] == true);\n', '        // setup\n', '         address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= whoaSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                whoaPreviousWithdrawn_[_toAddress] += (whoaTotalWithdrawn_[_customerAddress] / whoaSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                whoaSharehold_[_toAddress] += _amount;\n', '                whoaSharehold_[_customerAddress] -= _amount;\n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Transfer fee sharehold from the caller to a new holder.\n', '     */\n', '    function sellCredibleYouFeeSharehold(address _toAddress, uint256 _amount)\n', '        onlyMembers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_amount > 0){\n', '            require(members_[_toAddress] == true);\n', '        // setup\n', '            address _customerAddress = msg.sender;\n', '        // make sure we have the requested sharehold\n', '            require(_amount <= credibleyouSharehold_[_customerAddress] && _amount >= 0 && _toAddress != _customerAddress);\n', '        //Update fee sharehold previous withdrawals    \n', '                credibleyouPreviousWithdrawn_[_toAddress] += (credibleyouTotalWithdrawn_[_customerAddress] / credibleyouSharehold_[_customerAddress]) * _amount;\n', '        //Exchange sharehold\n', '                credibleyouSharehold_[_toAddress] += _amount;\n', '                credibleyouSharehold_[_customerAddress] -= _amount;\n', '                return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Check and address to see if it has CEVA privileges or not\n', '     */\n', '    function checkCEVA(address _identifier)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        if(ceva_[_identifier] == true){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Check and address to see if it has member privileges\n', '     */\n', '    function checkMember(address _identifier)\n', '        public\n', '        view\n', '        returns(bool) \n', '    {\n', '        if(members_[_identifier] == true){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Check and address to see is its got founder developer privileges\n', '     */\n', '    function checkFounderDeveloper(address _identifier)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        if(founderdevelopers_[_identifier] == true){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Check and address to see if it has admin privileges\n', '     */\n', '    function checkAdmin(address _identifier)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        if(administrators[_identifier] == true){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    /**\n', '     * whitelist Admins admin only\n', '     */\n', '    function AwhitelistAdministrator(address _identifier, bool _status)\n', '        onlyAdministrator(msg.sender)\n', '        public\n', '    {\n', '        require(msg.sender != _identifier);\n', '            administrators[_identifier] = _status;\n', '            emit AdminWhitelisted(msg.sender, _identifier, _status);\n', '    }\n', '    /**\n', '     * Automation entrypoint to whitelist ceva_ admin only\n', '     */\n', '    function AwhitelistCEVA(address _identifier, bool _status)\n', '        onlyAdministrator(msg.sender)\n', '        public\n', '    {\n', '        require(msg.sender != _identifier);\n', '            ceva_[_identifier] = _status;\n', '            numberofburnrequestswhitelisted_[msg.sender] = 0;\n', '            numberofpropertieswhitelisted_[msg.sender] = 0;\n', '            numberofmintingrequestswhitelisted_[msg.sender] = 0;\n', '            emit CEVAWhitelisted(msg.sender, _identifier, _status);\n', '    }\n', '    function withdrawCEVABurnerStockpiledividends(uint256 _amountOfTokens)\n', '        onlyCEVA(msg.sender)\n', '        public\n', '    {\n', '        // setup data\n', '        require(_amountOfTokens <= cevaBurnerStockpile_);\n', '            // update dividend tracker\n', '            cevaBurnerStockpile_ -= _amountOfTokens;\n', '            cevaBurnerStockpileWithdrawn_ += _amountOfTokens;\n', '            tokenBalanceLedger_[cevaaddress_] += _amountOfTokens;\n', '            emit Transfer(msg.sender, msg.sender, _amountOfTokens);\n', '    }\n', '    /**\n', '     * Whitelist a Property that has been confirmed on the site.. ceva only\n', '     */\n', '    function AwhitelistMintRequest(address _OwnerAddress, bool _trueFalse, bytes32 _mintingRequestUniqueid)\n', '        onlyCEVA(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_mintingRequestUniqueid == workingMintRequestid_[msg.sender]){\n', '            require(msg.sender != _OwnerAddress);\n', '            mintrequestwhitelist_[_OwnerAddress][_mintingRequestUniqueid] = _trueFalse;\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Whitelist a Property that has been confirmed on the site.. ceva only\n', '     */\n', '    function AwhitelistBurnRequest(address _OwnerAddress, bool _trueFalse, bytes32 _burnrequestUniqueID)\n', '        onlyCEVA(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_burnrequestUniqueID == workingBurnRequestid_[msg.sender]){\n', '            require(msg.sender != _OwnerAddress);\n', '            burnrequestwhitelist_[_OwnerAddress][_burnrequestUniqueID] = _trueFalse;\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Whitelist a Minting Request that has been confirmed on the site.. ceva only\n', '     */\n', '    function AwhitelistProperty(address _OwnerAddress, bool _trueFalse, bytes32 _propertyUniqueID)\n', '        onlyCEVA(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        if(_trueFalse = true){\n', '            require(workingPropertyid_[msg.sender] == _propertyUniqueID);\n', '            propertywhitelist_[_OwnerAddress][_propertyUniqueID] = _trueFalse;\n', '            emit PropertyWhitelisted(msg.sender, _propertyUniqueID, _trueFalse);\n', '            return true;\n', '        } else { \n', '            return false;\n', '        }\n', '    }\n', '    /**\n', '     * Whitelist a Minting Request that has been confirmed on the site.. ceva only\n', '     */\n', '    function AsetWhitelistedPropertyValue(address _OwnerAddress, bytes32 _propertyUniqueID, uint256 _propertyValue)\n', '        onlyCEVA(msg.sender)\n', '        public\n', '        returns(uint256)\n', '    {\n', '        require(propertywhitelist_[_OwnerAddress][_propertyUniqueID] = true && _propertyValue >= 0);\n', '            if(_OwnerAddress != msg.sender){\n', '                address _customerAddress = msg.sender;\n', '                numberofmintingrequestswhitelisted_[msg.sender] += 1;\n', '                emit PropertyValuation(_customerAddress, _propertyUniqueID, _propertyValue);\n', '                return _propertyValue;\n', '            } else { \n', '                numberofmintingrequestswhitelisted_[msg.sender] -= 1;\n', '                _propertyValue = 0;\n', '                return _propertyValue;\n', '            }\n', '    }\n', '    /**\n', '     * Whitelist a Minting Request that has been confirmed on the site.. ceva only\n', '     */\n', '    function AsetworkingPropertyid(address _OwnerAddress, bytes32 _propertyUniqueID)\n', '        onlyFounderDevelopers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        require(propertywhitelist_[_OwnerAddress][_propertyUniqueID] = true);\n', '            if(_OwnerAddress != msg.sender){\n', '                workingPropertyid_[_OwnerAddress] = _propertyUniqueID;\n', '                return true;\n', '            } else { \n', '                return false;\n', '            }\n', '    }\n', '    /**\n', '     * Whitelist a Minting Request that has been confirmed on the site.. ceva only\n', '     */\n', '    function AsetworkingMintingRequest(address _OwnerAddress, bytes32 _mintingRequestUniqueid)\n', '        onlyFounderDevelopers(msg.sender)\n', '        public\n', '        returns(bool)\n', '    {\n', '        require(mintrequestwhitelist_[_OwnerAddress][_mintingRequestUniqueid] = true);\n', '            if(_OwnerAddress != msg.sender){\n', '                workingMintRequestid_[_OwnerAddress] = _mintingRequestUniqueid;\n', '                return true;\n', '            } else { \n', '                return false;\n', '            }\n', '    }\n', '    /**\n', '     * Whitelist a Minting Request that has been confirmed on the site.. ceva only\n', '     */\n', '    function Asetworkingburnrequestid(address _OwnerAddress, bytes32 _propertyUniqueID, uint256 _propertyValue)\n', '        onlyFounderDevelopers(msg.sender)\n', '        public\n', '        returns(bytes32)\n', '    {\n', '        require(burnrequestwhitelist_[_OwnerAddress][_propertyUniqueID] = true);\n', '            if(_OwnerAddress != msg.sender){\n', '                workingPropertyid_[_OwnerAddress] = _propertyUniqueID;\n', '                numberofmintingrequestswhitelisted_[msg.sender] += 1;\n', '                emit PropertyValuation(msg.sender, _propertyUniqueID, _propertyValue);\n', '                return _propertyUniqueID;\n', '            } else { \n', '                numberofmintingrequestswhitelisted_[msg.sender] -= 1;\n', '                _propertyValue = 0;\n', '                return _propertyUniqueID;\n', '            }\n', '    }\n', '    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n', '        uint8 i = 0;\n', '        while(i < 32 && _bytes32[i] != 0) {\n', '            i++;\n', '        }\n', '        bytes memory bytesArray = new bytes(i);\n', '        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n', '            bytesArray[i] = _bytes32[i];\n', '        }\n', '        return string(bytesArray);\n', '    }\n', '    function bStringToBytes32(string memory source) \n', '    public pure returns (bytes32 result) {\n', '    bytes memory tempEmptyStringTest = bytes(source);\n', '    if (tempEmptyStringTest.length == 0) {\n', '        return 0x0;\n', '    }\n', '\n', '    assembly {\n', '        result := mload(add(source, 32))\n', '    }\n', '}\n', '    /**\n', '     * Whitelist a Founder Developer ceva only\n', '     */\n', '    function AWhitelistFounderDeveloper(address _identifier, bool _status)\n', '        onlyCEVA(msg.sender)\n', '        public\n', '    {\n', '            founderdevelopers_[_identifier] = _status;\n', '            numberofburnrequestswhitelisted_[msg.sender] = 0;\n', '            numberofpropertieswhitelisted_[msg.sender] = 0;\n', '            numberofmintingrequestswhitelisted_[msg.sender] = 0;\n', '            emit FounderDeveloperWhitelisted(msg.sender, _identifier, _status);\n', '    }\n', '    /*----------  FOUNDER DEVELOPER ONLY FUNCTIONS  ----------*/\n', '    // Mint an amount of tokens to an address \n', '    // using a whitelisted minting request unique ID founder developer only\n', '    function _mint(uint256 _FounderDeveloperFee, address _toAddress, address _holdOne, address _holdTwo, address _holdThree, \n', '        uint256 _propertyValue, bytes32 _propertyUniqueID, bytes32 _mintingRequestUniqueid)\n', '        onlyFounderDevelopers(msg.sender)\n', '        public\n', '    {\n', '        if(_propertyValue >= 100){\n', '        // data setup\n', '            uint256 _amountOfTokens = (_propertyValue * 1e18) / 100;\n', '            require(members_[_toAddress] == true && _FounderDeveloperFee >= 20001 && _FounderDeveloperFee <= 100000 && \n', '            (_amountOfTokens + tokenSupply_) > tokenSupply_ && msg.sender != _toAddress && _propertyUniqueID == workingPropertyid_[msg.sender]\n', '            && _mintingRequestUniqueid == workingMintRequestid_[msg.sender] && _propertyValue == propertyvalue_[_toAddress][_propertyUniqueID]);\n', '            // add tokens to the pool\n', '            tokenSupply_ = tokenSupply_ + _amountOfTokens;\n', '            updateHoldsandSupply(_amountOfTokens);\n', '            // add to burner stockpile\n', '            cevaBurnerStockpile_ += (_amountOfTokens / 16667) * 100;\n', '            // whoa fee\n', '            whoafeeBalanceLedger_ = whoafeeBalanceLedger_ + _amountOfTokens;\n', '            // credit founder developer fee\n', '            tokenBalanceLedger_[msg.sender] += (_amountOfTokens / _FounderDeveloperFee) * 1000;\n', '            //credit Envelope Fee Shareholds\n', '            creditFeeSharehold(_amountOfTokens, _toAddress, _holdOne, _holdTwo, _holdThree);\n', '            // credit tech feeSharehold_    ;\n', '            uint256 _TechFee = (_amountOfTokens / 25000) * 100;\n', '            techfeeBalanceLedger_ = techfeeBalanceLedger_ + _TechFee;\n', '            // fire event\n', '            // add tokens to the _toAddress \n', '            uint256 _cevabTransferfees = (_amountOfTokens / 333334) * 10000;\n', '            uint256 _Fee = (_amountOfTokens / _FounderDeveloperFee) * 1000;\n', '            tokenBalanceLedger_[_toAddress] = tokenBalanceLedger_[_toAddress] + (_amountOfTokens - _cevabTransferfees);\n', '            tokenBalanceLedger_[_toAddress] -= _Fee;\n', '            tokenBalanceLedger_[_toAddress] -= _TechFee;\n', '            emit Transfer(msg.sender, _toAddress, _amountOfTokens);\n', '            mintingDepositsOf_[_toAddress] += _amountOfTokens;\n', '        } else {\n', '            return;\n', '        }\n', '    }\n', '    function AworkingPropertyIDOf(address _user)\n', '        onlyFounderDevelopers(msg.sender)\n', '        public\n', '        view\n', '        returns(bytes32)\n', '    {\n', '        return workingPropertyid_[_user];\n', '    }\n', '    function AworkingBurnRequestIDOf(address _user)\n', '        onlyFounderDevelopers(msg.sender)\n', '        public\n', '        view\n', '        returns(bytes32)\n', '    {\n', '        return workingBurnRequestid_[_user];\n', '    }\n', '    function AworkingMintIDOf(address _user)\n', '        onlyFounderDevelopers(msg.sender)\n', '        public\n', '        view\n', '        returns(bytes32)\n', '    {\n', '        return workingMintRequestid_[_user];\n', '    }\n', '    /**\n', '     * whitelist a member founder developer only\n', '     */\n', '    function AWhitelistMember(address _identifier, bool _status)\n', '        onlyFounderDevelopers(msg.sender)\n', '        public\n', '    {\n', '        require(msg.sender != _identifier);\n', '            members_[_identifier] = _status;\n', '            emit MemberWhitelisted(msg.sender, _identifier, _status);\n', '    } \n', '    /*----------  HELPERS AND CALCULATORS  ----------*/\n', '    /**\n', '     * Retrieve the tokens owned by the caller.\n', '     */\n', '    function TokensNoDecimals()\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        uint256 _tokens =  (balanceOf(_customerAddress) / 1e18);\n', '        if(_tokens >= 1){\n', '            return _tokens;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '    function balanceOf(address _owner)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        return tokenBalanceLedger_[_owner];\n', '    }\n', '    function EtaxesdividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(taxesFeeSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (taxesfeeBalanceLedger_ / taxesfeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * taxesFeeSharehold_[_customerAddress]) - \n', '            (taxesFeeTotalWithdrawn_[_customerAddress] + taxesPreviousWithdrawn_[_customerAddress])) / \n', '            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  taxes dividend balance of any single address.\n', '     */\n', '    function EtaxesShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        \n', '        if(taxesFeeSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return taxesFeeSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  insurance dividend balance of any single address.\n', '     */\n', '    function EinsurancedividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(insuranceFeeSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (insurancefeeBalanceLedger_ / insurancefeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * insuranceFeeSharehold_[_customerAddress]) - \n', '            (insuranceFeeTotalWithdrawn_[_customerAddress] + insurancePreviousWithdrawn_[_customerAddress])) / \n', '            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  taxes dividend balance of any single address.\n', '     */\n', '    function EinsuranceShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        \n', '        if(insuranceFeeSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return insuranceFeeSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  maintenance dividend balance of any single address.\n', '     */\n', '    function EmaintenancedividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(maintenanceFeeSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (maintenancefeeBalanceLedger_ / maintencancefeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * maintenanceFeeSharehold_[_customerAddress]) - \n', '            (maintenanceFeeTotalWithdrawn_[_customerAddress] + maintenancePreviousWithdrawn_[_customerAddress])) / \n', '            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  taxes dividend balance of any single address.\n', '     */\n', '    function EmaintenanceShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        if(maintenanceFeeSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return maintenanceFeeSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  Wealth Architect ECO Register 1.2 dividend balance of any single address.\n', '     */\n', '    function EwaECOdividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(waECOFeeSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (waECOfeeBalanceLedger_ / waECOfeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * waECOFeeSharehold_[_customerAddress]) - \n', '            (waECOFeeTotalWithdrawn_[_customerAddress] + waECOPreviousWithdrawn_[_customerAddress])) / \n', '            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '        }\n', '    /**\n', '     * Retrieve the  taxes dividend balance of any single address.\n', '     */\n', '    function EwaECOShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        if(waECOFeeSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return waECOFeeSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the hold one dividend balance of any single address.\n', '     */\n', '    function EholdonedividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(holdoneSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (holdonefeeBalanceLedger_ / holdonefeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * holdoneSharehold_[_customerAddress]) - \n', '            (holdoneTotalWithdrawn_[_customerAddress] + holdonePreviousWithdrawn_[_customerAddress])) / \n', '            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the  taxes dividend balance of any single address.\n', '     */\n', '    function EholdoneShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        if(holdoneSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return holdoneSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the hold two dividend balance of any single address.\n', '     */\n', '    function EholdtwodividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(holdtwoSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (holdtwofeeBalanceLedger_ / holdtwofeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * holdtwoSharehold_[_customerAddress]) -\n', '            (holdtwoTotalWithdrawn_[_customerAddress] + holdtwoPreviousWithdrawn_[_customerAddress])) / \n', '            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  taxes dividend balance of any single address.\n', '     */\n', '    function EholdtwoShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        if(holdtwoSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return holdtwoSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the hold three dividend balance of any single address.\n', '     */\n', '    function EholdthreedividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(holdthreeSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (holdthreefeeBalanceLedger_ / holdthreefeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * holdthreeSharehold_[_customerAddress]) -\n', '            (holdthreeTotalWithdrawn_[_customerAddress] + holdthreePreviousWithdrawn_[_customerAddress])) / \n', '            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  taxes dividend balance of any single address.\n', '     */\n', '    function EholdthreeShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        if(holdthreeSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return holdthreeSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the rewards dividend balance of any single address.\n', '     */\n', '    function ErewardsdividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(rewardsSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (RewardsfeeBalanceLedger_ / RewardsfeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * rewardsSharehold_[_customerAddress]) -\n', '            (rewardsTotalWithdrawn_[_customerAddress] + rewardsPreviousWithdrawn_[_customerAddress])) / \n', '            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  taxes dividend balance of any single address.\n', '     */\n', '    function ErewardsShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        if(rewardsSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return rewardsSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the tech dividend balance of any single address.\n', '     */\n', '    function EtechdividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(techfeeTotalHolds_ == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (techfeeBalanceLedger_ / techfeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * techSharehold_[_customerAddress]) -\n', '            (techTotalWithdrawn_[_customerAddress] + techPreviousWithdrawn_[_customerAddress])) /\n', '            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  taxes dividend balance of any single address.\n', '     */\n', '    function EtechShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        if(techSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return techSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the exist holdings dividend balance of any single address.\n', '     */\n', '    function existholdingsdividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(existholdingsfeeTotalHolds_ == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (existholdingsfeeBalanceLedger_ / existholdingsfeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * existholdingsSharehold_[_customerAddress]) -\n', '            (existholdingsTotalWithdrawn_[_customerAddress] + existholdingsPreviousWithdrawn_[_customerAddress])) / \n', '            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  taxes dividend balance of any single address.\n', '     */\n', '    function existholdingsShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        \n', '        if(existholdingsSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return existholdingsSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the exist crypto dividend balance of any single address.\n', '     */\n', '    function existcryptodividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(existcryptofeeTotalHolds_ == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (existcryptofeeBalanceLedger_ / existcryptofeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * existcryptoSharehold_[_customerAddress]) -\n', '            (existcryptoTotalWithdrawn_[_customerAddress] + existcryptoPreviousWithdrawn_[_customerAddress])) / \n', '            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  taxes dividend balance of any single address.\n', '     */\n', '    function existcryptoShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        if(existcryptoSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return existcryptoSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the Worldwide Home Owners Association dividend balance of any single address.\n', '     */\n', '    function EwhoadividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(whoafeeTotalHolds_ == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (whoafeeBalanceLedger_ / whoafeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * whoaSharehold_[_customerAddress]) -\n', '            (whoaTotalWithdrawn_[_customerAddress] + whoaPreviousWithdrawn_[_customerAddress])) /\n', '            calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the WHOA dividend balance of any single address.\n', '     */\n', '    function EwhoaShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        if(whoaSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return whoaSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the Credible You dividend balance of any single address.\n', '     */\n', '    function EcredibleyoudividendsOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        if(credibleyoufeeTotalHolds_ == 0){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = (credibleyoufeeBalanceLedger_ / credibleyoufeeTotalHolds_);\n', '            return (uint256) ((_dividendPershare * credibleyouSharehold_[_customerAddress]) -\n', '            (credibleyouTotalWithdrawn_[_customerAddress] + credibleyouPreviousWithdrawn_[_customerAddress]))\n', '            / calulateAmountQualified(mintingDepositsOf_[_customerAddress], AmountCirculated_[_customerAddress]);\n', '            \n', '        }\n', '    }\n', '    /**\n', '     * Retrieve the  taxes dividend balance of any single address.\n', '     */\n', '    function EcredibleyouShareholdOf(address _customerAddress)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        if(credibleyouSharehold_[_customerAddress] == 0){\n', '            return 0;\n', '        } else {\n', '            return credibleyouSharehold_[_customerAddress];\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * Retrieve the CEVA Burner Stockpile dividend balance using a CEVA whitelisted address.\n', '     */\n', '    function EcevaBurnerStockpileDividends()\n', '        onlyCEVA(msg.sender)\n', '        view\n', '        public\n', '        returns(uint256)\n', '    {\n', '        uint256 _dividendPershare;\n', '        address _customerAddress = msg.sender;\n', '        if(ceva_[_customerAddress] != true){\n', '            return 0;\n', '        } else {\n', '            _dividendPershare = cevaBurnerStockpile_;\n', '            return _dividendPershare;\n', '        }\n', '    }\n', '    \n', '    function totalSupply() \n', '        public \n', '        view\n', '        returns(uint256)\n', '    {\n', '            if(tokenSupply_ == 0){\n', '                return 0;\n', '            } else {\n', '            return tokenSupply_;}\n', '    }\n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '    /**\n', '     * Update token balance ledger of an address tokens from the caller to a new holder.\n', '     */\n', '    function updateHoldsandSupply(uint256 _amountOfTokens)\n', '        internal\n', '        returns(bool)\n', '    {\n', '        tokenSupply_ = tokenSupply_ + _amountOfTokens;\n', '        taxesfeeTotalHolds_ = (_amountOfTokens / 1e18) + taxesfeeTotalHolds_;\n', '        insurancefeeTotalHolds_ = (_amountOfTokens / 1e18) + insurancefeeTotalHolds_;\n', '        maintencancefeeTotalHolds_ = (_amountOfTokens / 1e18) + maintencancefeeTotalHolds_;\n', '        waECOfeeTotalHolds_ = (_amountOfTokens / 1e18) + waECOfeeTotalHolds_;\n', '        holdonefeeTotalHolds_ = (_amountOfTokens / 1e18) + holdonefeeTotalHolds_;\n', '        holdtwofeeTotalHolds_ = (_amountOfTokens / 1e18) + holdtwofeeTotalHolds_;\n', '        holdthreefeeTotalHolds_ = (_amountOfTokens / 1e18) + holdthreefeeTotalHolds_;\n', '        RewardsfeeTotalHolds_ = (_amountOfTokens / 1e18) + RewardsfeeTotalHolds_;\n', '        techfeeTotalHolds_ = (_amountOfTokens / 1e18) + techfeeTotalHolds_;\n', '        existholdingsfeeTotalHolds_ = (_amountOfTokens / 1e18) + existholdingsfeeTotalHolds_;\n', '        existcryptofeeTotalHolds_ = (_amountOfTokens / 1e18) + existcryptofeeTotalHolds_;\n', '        whoafeeTotalHolds_ = (_amountOfTokens / 1e18) + whoafeeTotalHolds_;\n', '        credibleyoufeeTotalHolds_= (_amountOfTokens / 1e18) + credibleyoufeeTotalHolds_;\n', '        feeTotalHolds_ = ((_amountOfTokens / 1e18)* 13) + feeTotalHolds_;\n', '        return true;\n', '    }\n', '    /**\n', '     * Update token balance ledger of an address tokens from the caller to a new holder.\n', "     * Remember, there's a fee here as well.\n", '     */\n', '    function burnA(uint256 _amount)\n', '        internal\n', '        returns(bool)\n', '    {\n', '        uint256 _pValue = _amount / 100;\n', '        if(_amount > 0){\n', '            RewardsfeeTotalHolds_ -= _pValue;\n', '            techfeeTotalHolds_ -= _pValue;\n', '            existholdingsfeeTotalHolds_ -= _pValue;\n', '            existcryptofeeTotalHolds_ -= _pValue;\n', '            whoafeeTotalHolds_-= _pValue;\n', '            credibleyoufeeTotalHolds_ -= _pValue;\n', '            feeTotalHolds_ -= _pValue;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        } \n', '    }\n', '    /**\n', '     * calculate 2% total transfer fee based on _amountOfTokens\n', '     */\n', '    function calulateAmountQualified(uint256 _TokenMintingDepositsOf, uint256 _AmountCirculated)\n', '        internal\n', '        pure\n', '        returns(uint256 _AmountQualified)\n', '    {\n', '        _AmountQualified = _TokenMintingDepositsOf / _AmountCirculated;\n', '        if(_AmountQualified <= 1){\n', '            _AmountQualified = 1;\n', '            return _AmountQualified;\n', '        } else {\n', '            return _AmountQualified;\n', '        }\n', '    }\n', '    function updateEquityRents(uint256 _amountOfTokens)\n', '        internal\n', '        returns(bool)\n', '    {\n', '        if(_amountOfTokens < 0){\n', '            _amountOfTokens = 0;\n', '            return false;\n', '        } else {\n', '            taxesfeeBalanceLedger_ = taxesfeeBalanceLedger_ + (_amountOfTokens / 800);\n', '            insurancefeeBalanceLedger_ = insurancefeeBalanceLedger_ + (_amountOfTokens / 800);\n', '            maintenancefeeBalanceLedger_ = maintenancefeeBalanceLedger_ + (_amountOfTokens / 800);\n', '            waECOfeeBalanceLedger_ = waECOfeeBalanceLedger_ + (_amountOfTokens / 800);\n', '            holdonefeeBalanceLedger_ = holdonefeeBalanceLedger_ + (_amountOfTokens / 800);\n', '            holdtwofeeBalanceLedger_ = holdtwofeeBalanceLedger_ + (_amountOfTokens / 800);\n', '            holdthreefeeBalanceLedger_ = holdthreefeeBalanceLedger_ + (_amountOfTokens / 800);\n', '            RewardsfeeBalanceLedger_ = RewardsfeeBalanceLedger_ + (_amountOfTokens / 800);\n', '            techfeeBalanceLedger_ = techfeeBalanceLedger_ + ((_amountOfTokens / 25000) * 100);\n', '            existholdingsfeeBalanceLedger_ = existholdingsfeeBalanceLedger_ + (_amountOfTokens / 445);\n', '            existcryptofeeBalanceLedger_ = existcryptofeeBalanceLedger_ + (_amountOfTokens / 800);\n', '            whoafeeBalanceLedger_ = whoafeeBalanceLedger_ + (_amountOfTokens / 800);\n', '            credibleyoufeeBalanceLedger_ = credibleyoufeeBalanceLedger_ + (_amountOfTokens / 800);\n', '            return true;\n', '        } \n', '    }\n', '    /**\n', '     * Update taxes fee sharehold of an address..\n', '     */\n', '    function creditTaxesFeeSharehold(uint256 _amountOfTokens,  address _toAddress)\n', '        internal\n', '    {\n', '        taxesFeeSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update insurance fee sharehold of an address..\n', '     */\n', '    function creditInsuranceFeeSharehold(uint256 _amountOfTokens, address _toAddress)\n', '        internal\n', '    {\n', '        insuranceFeeSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update maintenance fee sharehold of an address..\n', '     */\n', '    function creditMaintenanceFeeSharehold(uint256 _amountOfTokens, address _toAddress)\n', '        internal\n', '    {\n', '        maintenanceFeeSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update Wealth Architect fee sharehold of an address..\n', '     */\n', '    function creditwaECOFeeSharehold(uint256 _amountOfTokens, address _toAddress)\n', '        internal\n', '    {\n', '        waECOFeeSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update hold one fee sharehold of an address..\n', '     */\n', '    function creditHoldOneFeeSharehold(uint256 _amountOfTokens, address _toAddress)\n', '        internal\n', '    {\n', '        holdoneSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update hold two fee sharehold of an address..\n', '     */\n', '    function creditHoldTwoFeeSharehold(uint256 _amountOfTokens, address _toAddress)\n', '        internal\n', '    {\n', '        holdtwoSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update hold three fee sharehold of an address..\n', '     */\n', '    function creditHoldThreeFeeSharehold(uint256 _amountOfTokens, address _toAddress)\n', '        internal\n', '    {\n', '        holdthreeSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update Rewards fee sharehold of an address..\n', '     */\n', '    function creditRewardsFeeSharehold(uint256 _amountOfTokens, address _toAddress)\n', '        internal\n', '    {\n', '        rewardsSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update Tech fee sharehold of an address..\n', '     */\n', '    function creditTechFeeSharehold(uint256 _amountOfTokens, address _toAddress)\n', '        internal\n', '    {\n', '        techSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update Exist Holdings fee sharehold of an address..\n', '     */\n', '    function creditExistHoldingsFeeSharehold(uint256 _amountOfTokens, address _toAddress)\n', '        internal\n', '    {\n', '        existholdingsSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update Exist Crypto fee sharehold of an address..\n', '     */\n', '    function creditExistCryptoFeeSharehold(uint256 _amountOfTokens, address _toAddress)\n', '        internal\n', '    {\n', '        existcryptoSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update WHOA fee sharehold of an address..\n', '     */\n', '    function creditWHOAFeeSharehold(uint256 _amountOfTokens, address _toAddress)\n', '        internal\n', '    {\n', '        whoaSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update Credible You fee sharehold of an address..\n', '     */\n', '    function creditCredibleYouFeeSharehold(uint256 _amountOfTokens, address _toAddress)\n', '        internal\n', '    {\n', '        credibleyouSharehold_[_toAddress] += _amountOfTokens;\n', '    }\n', '    /**\n', '     * Update Exist Holdings fee sharehold of an address..\n', '     */\n', '    function creditFeeSharehold(uint256 _amountOfTokens, address _owner, address _toAddress, address _toAddresstwo, address _toAddressthree)\n', '        internal\n', '        returns(bool)\n', '    {\n', '        creditTaxesFeeSharehold((_amountOfTokens / 1e18), _owner);\n', '        creditInsuranceFeeSharehold((_amountOfTokens / 1e18), _owner);\n', '        creditMaintenanceFeeSharehold((_amountOfTokens / 1e18), whoamaintenanceaddress_);\n', '        creditwaECOFeeSharehold((_amountOfTokens / 1e18), _owner);\n', '        creditHoldOneFeeSharehold((_amountOfTokens / 1e18), _toAddress);\n', '        creditHoldTwoFeeSharehold((_amountOfTokens / 1e18), _toAddresstwo);\n', '        creditHoldThreeFeeSharehold((_amountOfTokens / 1e18), _toAddressthree);\n', '        creditRewardsFeeSharehold((_amountOfTokens / 1e18), whoarewardsaddress_);\n', '        creditTechFeeSharehold((_amountOfTokens / 1e18), techaddress_);\n', '        creditExistHoldingsFeeSharehold((_amountOfTokens / 1e18), existholdingsaddress_);\n', '        creditExistCryptoFeeSharehold((_amountOfTokens / 1e18), existcryptoaddress_);\n', '        creditWHOAFeeSharehold((_amountOfTokens / 1e18), whoaaddress_);\n', '        creditCredibleYouFeeSharehold((_amountOfTokens / 1e18), credibleyouaddress_);\n', '        return true;\n', '    }\n', '    //This is where all your gas goes, sorry\n', '    //Not sorry, you probably only paid 1 gwei\n', '    function sqrt(uint x) internal pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}']