['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-24\n', '*/\n', '\n', 'pragma solidity ^0.5.12;\n', '\n', 'contract ReserveLike {\n', '}\n', '\n', 'contract ProxyLike {\n', '    function withdrawODai(address, uint) public;\n', '    function withdrawEDai(address, uint) public;\n', '}\n', '\n', 'contract WrappedDai {\n', '    string public constant version = "0511";\n', '\n', '    // --- Owner ---\n', '    address public owner;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    event SetOwner(address owner);\n', '\n', '    function setOwner(address _owner) public onlyOwner {\n', '        owner = _owner;\n', '        emit SetOwner(_owner);\n', '    }\n', '\n', '    // --- Math ---\n', '    function add(uint a, uint b) private pure returns (uint) {\n', '        require(a <= uint(-1) - b);\n', '        return a + b;\n', '    }\n', '\n', '    function sub(uint a, uint b) private pure returns (uint) {\n', '        require(a >= b);\n', '        return a - b;\n', '    }\n', '\n', '    // --- Proxy ---\n', '    ProxyLike public Proxy;\n', '\n', '    event SetProxy(address proxy);\n', '\n', '    modifier onlyProxy {\n', '        require(msg.sender == address(Proxy));\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrProxy {\n', '        require(msg.sender == owner || msg.sender == address(Proxy));\n', '        _;\n', '    }\n', '\n', '    // 최초 발행 시에는 Owner, 그 뒤에는 Proxy가 호출\n', '    function setProxy(address proxy) public onlyOwnerOrProxy {\n', '        Proxy = ProxyLike(proxy);\n', '        emit SetProxy(proxy);\n', '    }\n', '\n', '    // --- Contracts & Constructor ---\n', '    ReserveLike public Reserve;\n', '    uint public reserveLimit;\n', '\n', '    event SetReserve(address reserve);\n', '    event SetReserveLimit(uint limit);\n', '\n', '    function setReserve(address reserve) public onlyProxy {\n', '        Reserve = ReserveLike(reserve);\n', '        emit SetReserve(reserve);\n', '    }\n', '\n', '    function setReserveLimit(uint limit) public onlyOwner {\n', '        reserveLimit = limit;\n', '        emit SetReserveLimit(limit);\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // --- ERC20 ---\n', '    uint8 public constant decimals = 18;\n', '    uint public totalSupply;\n', '\n', '    mapping(address => uint) public balanceOf;\n', '    mapping(address => mapping(address => uint)) public allowance;  // (holder, spender)\n', '\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '    event Approval(address indexed holder, address indexed spender, uint amount);\n', '\n', '    function transferFrom(address from, address to, uint amount) public returns (bool) {\n', '        if (from != msg.sender && allowance[from][msg.sender] != uint(-1)) {\n', '            allowance[from][msg.sender] = sub(allowance[from][msg.sender], amount);\n', '        }\n', '\n', '        balanceOf[from] = sub(balanceOf[from], amount);\n', '        balanceOf[to] = add(balanceOf[to], amount);\n', '\n', '        emit Transfer(from, to, amount);\n', '\n', '        if (to == address(Reserve)) {\n', '            require(balanceOf[to] <= reserveLimit);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint amount) public returns (bool) {\n', '        allowance[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval(address spender, uint amount) public returns (bool) {\n', '        amount = add(allowance[msg.sender][spender], amount);\n', '\n', '        allowance[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address spender, uint amount) public returns (bool) {\n', '        if (amount > allowance[msg.sender][spender]) {\n', '            amount = 0;\n', '        }\n', '        else {\n', '            amount = allowance[msg.sender][spender] - amount;\n', '        }\n', '\n', '        allowance[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function mint(address user, uint amount) public onlyProxy {\n', '        balanceOf[user] = add(balanceOf[user], amount);\n', '        totalSupply = add(totalSupply, amount);\n', '\n', '        emit Transfer(address(0), user, amount);\n', '    }\n', '\n', '    function burn(address user, uint amount) public onlyProxy {\n', '        balanceOf[user] = sub(balanceOf[user], amount);\n', '        totalSupply = sub(totalSupply, amount);\n', '\n', '        emit Transfer(user, address(0), amount);\n', '    }\n', '}\n', '\n', 'contract EtherDai is WrappedDai {\n', '    // --- ERC20 ---\n', '    string public constant name = "Ether Dai";\n', '    string public constant symbol = "EDAI";\n', '\n', '    function transfer(address to, uint amount) public returns (bool) {\n', '        if (msg.sender == address(Reserve)) {\n', '            Proxy.withdrawEDai(to, amount);\n', '            return true;\n', '        }\n', '\n', '        return transferFrom(msg.sender, to, amount);\n', '    }\n', '}']