['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.7.0;\n', '\n', '\n', '/**\n', '* @title interface of ERC 20 token\n', '* \n', '*/\n', 'interface IERC20 {\n', '    \n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title IERC1404 - Simple Restricted Token Standard \n', ' * @dev https://github.com/ethereum/eips/issues/1404\n', ' */\n', 'interface IERC1404 {\n', '    \n', '     // Implementation of all the restriction of transfer and returns error code\n', '     function detectTransferRestriction (address from, address to, uint256 value) external view returns (uint8);\n', '\n', '    // Returns error message off error code\n', '    function messageForTransferRestriction (uint8 restrictionCode) external view returns (string memory);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Implementation of the {IERC20} interface.\n', ' *\n', ' */\n', 'contract ERC20 is IERC20 {\n', '\n', '    using SafeMath for uint256; \n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public immutable decimals;\n', '    uint256 public override totalSupply;\n', '    \n', '\n', '    constructor(string memory _name, string  memory _symbol, uint8 _decimals, uint256 _totalSupply){\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        _mint(msg.sender, _totalSupply);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '    \n', '        \n', '     /**\n', '     * @dev Burns a specific amount of tokens.\n', '     * @param value The amount of token to be burned.\n', '     */\n', '    function burn(uint256 value) public {\n', '        _burn(msg.sender, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Burns a specific amount of tokens from the target address and decrements allowance\n', '     * @param from address The account whose tokens will be burned.\n', '     * @param value uint256 The amount of token to be burned.\n', '     */\n', '    function burnFrom(address from, uint256 value) public {\n', '        _burnFrom(from, value);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '        totalSupply = totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        totalSupply = totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '    \n', '    /**\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burnFrom(address account, uint256 value) internal {\n', '        _burn(account, value);\n', '        _approve(account, msg.sender, _allowances[account][msg.sender].sub(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '     *\n', '     * This internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '    \n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    \n', '    address public owner;\n', '    address private _newOwner;\n', '    \n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    \n', '    constructor () {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), owner);\n', '    }\n', '\n', '    // Throws if called by any account other than the owner\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    // True if `msg.sender` is the owner of the contract.\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == owner;\n', '    }\n', '\n', '    // Allows the current owner to relinquish control of the contract.\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '    }\n', '\n', '    // Propose the new Owner of the smart contract \n', '    function proposeOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        _newOwner = newOwner;\n', '    }\n', '    \n', '    // Accept the ownership of the smart contract as a new Owner\n', '    function acceptOwnership() public {\n', '        require(msg.sender == _newOwner, "Ownable: caller is not the new owner");\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title TimelockerRole\n', ' * @dev TimelockerRole can lock any users wallet for some time.\n', ' */\n', 'contract TimelockerRole is Ownable {\n', '\n', '    using Roles for Roles.Role;\n', '  \n', '    event TimelockerAdded(address indexed addedTimelocker, address indexed addedBy);\n', '    event TimelockerRemoved(address indexed removedTimelocker, address indexed removedBy);\n', '\n', '    Roles.Role private _timelockers;\n', '\n', '    modifier onlyTimelocker() {\n', '        require(isTimelocker(msg.sender), "TimelockerRole: caller does not have the Timelocker role");\n', '        _;\n', '    }\n', '\n', '    function isTimelocker(address account) public view returns (bool) {\n', '        return _timelockers.has(account);\n', '    }\n', '\n', '    function addTimelocker(address account) public onlyOwner {\n', '        _addTimelocker(account);\n', '    }\n', '\n', '    function removeTimelocker(address account) public onlyOwner {\n', '        _removeTimelocker(account);\n', '    }\n', '\n', '    function _addTimelocker(address account) internal {\n', '        _timelockers.add(account);\n', '        emit TimelockerAdded(account, msg.sender);\n', '    }\n', '\n', '    function _removeTimelocker(address account) internal {\n', '        _timelockers.remove(account);\n', '        emit TimelockerRemoved(account, msg.sender);\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title WhitelisterRole\n', ' * @dev WhitelisterRole can whitelist any users wallet.\n', ' */\n', 'contract WhitelisterRole is Ownable {\n', '\n', '    using Roles for Roles.Role;\n', '  \n', '    event WhitelisterAdded(address indexed addedWhitelister, address indexed addedBy);\n', '    event WhitelisterRemoved(address indexed removedWhitelister, address indexed removedBy);\n', '\n', '    Roles.Role private _whitelisters;\n', '\n', '    modifier onlyWhitelister() {\n', '        require(isWhitelister(msg.sender), "WhitelisterRole: caller does not have the Whitelister role");\n', '        _;\n', '    }\n', '\n', '    function isWhitelister(address account) public view returns (bool) {\n', '        return _whitelisters.has(account);\n', '    }\n', '\n', '    function addWhitelister(address account) public onlyOwner {\n', '        _addWhitelister(account);\n', '    }\n', '\n', '    function removeWhitelister(address account) public onlyOwner {\n', '        _removeWhitelister(account);\n', '    }\n', '\n', '    function _addWhitelister(address account) internal {\n', '        _whitelisters.add(account);\n', '        emit WhitelisterAdded(account, msg.sender);\n', '    }\n', '\n', '    function _removeWhitelister(address account) internal {\n', '        _whitelisters.remove(account);\n', '        emit WhitelisterRemoved(account, msg.sender);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' */\n', 'contract Pausable is Ownable {\n', '    /**\n', '     * @dev Emitted when the pause is triggered by `account`.\n', '     */\n', '    event Paused(address account);\n', '\n', '    /**\n', '     * @dev Emitted when the pause is lifted by `account`.\n', '     */\n', '    event Unpaused(address account);\n', '    \n', '    /**\n', '     * @dev By Default it is false \n', '     */\n', '    bool private _paused;\n', '\n', '    /**\n', '     * @dev Returns true if the contract is paused, and false otherwise.\n', '     */\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused, "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused, "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Triggers stopped state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    function _pause() internal virtual whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns to normal state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    function _unpause() internal virtual whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(msg.sender);\n', '    }\n', '\n', '     /**\n', '     * @dev To pause the all transfer of the token\n', '     */\n', '    function pause() public onlyOwner {\n', '        _pause();\n', '    }\n', '\n', '    /**\n', '     * @dev To unpause the all trasfer of the token\n', '     */\n', '    function unpause() public onlyOwner {\n', '        _unpause();\n', '    }  \n', '\n', '}\n', '\n', '/**\n', ' * @title Timelockable\n', ' * @dev TimelockerRole can lock any users all fund in wallet address upto some releaseTime\n', ' */ \n', '\n', 'contract Timelockable is TimelockerRole{\n', '\n', '    mapping (address => uint256) private timeLockups;\n', '\n', '    event AccountLock(address indexed _address, uint256 _releaseTime);\n', '\n', '    /**\n', '    * @dev Lock the amount of this address till releaseTime\n', '    */\n', '    function lock( address _address, uint256 _releaseTime) public onlyTimelocker returns (bool) {\n', '        require(_releaseTime > block.timestamp, "Timelockable: Release time should be greater than release time");\n', '        require(_address != address(0), "Timelockable: Address should not be Zero address");\n', '        timeLockups[_address] = _releaseTime;\n', '        emit AccountLock(_address, _releaseTime);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Get the timestamp when timelock is released\n', '     */\n', '    function checkLockup(address _address) public view returns(uint256) {\n', '         return timeLockups[_address];\n', '    }\n', '\n', '    /**\n', '    * @dev Check if wallet is locked or not\n', '    */\n', '    function isLocked(address _address) public view returns(bool) {\n', '         return timeLockups[_address] > block.timestamp;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Whitelistable\n', ' * @dev The Whitelistable contract has an can whitelist any address to transfer the security token\n', ' */\n', 'contract Whitelistable is  WhitelisterRole{\n', '    \n', '    event SetWhitelist(address _address, bool status);\n', '\n', '    // White list status\n', '    mapping (address => bool) private whitelist;\n', '    \n', '    // Whitelist owner\n', '    constructor(){\n', '        whitelist[msg.sender] = true;\n', '        emit SetWhitelist(msg.sender, true);\n', '    }\n', '    \n', '    /**\n', '    * @dev Set a white list address\n', '    */\n', '    function setWhitelist(address to, bool status)  public onlyWhitelister returns(bool){\n', '        whitelist[to] = status;\n', '        emit SetWhitelist(to, status);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Get the status of the whitelist\n', '    */\n', '    function isWhitelisted(address _address) public view returns(bool){\n', '        return whitelist[_address];\n', '    }\n', '\n', '    /**\n', '    * @dev Determine if sender and receiver are whitelisted, return true if both accounts are whitelisted\n', '    */\n', '    function checkWhitelists(address from, address to) external view returns (bool) {\n', '        return whitelist[from] && whitelist[to];\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title RVW \n', ' * @dev RVW is ERC20 standard with  Ownable, Pausable, Whitelistable, Timelockable and IERC1404\n', ' */ \n', 'contract RVW is ERC20, Ownable, Pausable, Whitelistable, Timelockable, IERC1404{\n', '\n', ' \n', '    uint8 public constant SUCCESS = 0;\n', '    \n', '    /**\n', '     *   @dev external smart contract for transfer restriction\n', '     */\n', '    IERC1404 public restrictedTransfer;\n', '\n', '    event UpdatedRestrictedTransfer(address indexed _restrictedTransfer);\n', '    event Issue(address indexed to, uint256 value);\n', '    \n', '    /**\n', '     * @dev Initializes the details of the token with all the above details\n', '     * Also put the ERC1404 smart contract\n', '     */\n', "    constructor(IERC1404 _restrictedTransfer)  ERC20('RVW Movie Token', 'RVW', 18, 5000000 * (10 ** 18)) {\n", '        restrictedTransfer = _restrictedTransfer;\n', '    }\n', '    \n', '    \n', '    /**\n', '     * @dev modifier to check the transfer restriction\n', '     */\n', '    modifier notRestricted (address _from, address _to, uint256 _value) {\n', '        uint8 code = restrictedTransfer.detectTransferRestriction(_from, _to, _value);\n', '        require(code == SUCCESS, restrictedTransfer.messageForTransferRestriction(code));\n', '        _;\n', '    }\n', '    \n', '   /**\n', '     * @dev Update ERC1404 smart contract\n', '     */\n', '    function updateRestrictedTransfer(address _restrictedTransfer) public onlyOwner{\n', '        restrictedTransfer = IERC1404(_restrictedTransfer);\n', '        emit UpdatedRestrictedTransfer(_restrictedTransfer);\n', '    }\n', '    \n', '    /**\n', '     * @dev Get the code of the transfer restriction\n', '     */\n', '    function detectTransferRestriction (address _from, address _to, uint256 _amount) public override view  returns (uint8) {\n', "        require(restrictedTransfer != IERC1404(0), 'RestrictedTransfer: Contract is not set');\n", '        return restrictedTransfer.detectTransferRestriction(_from, _to, _amount);\n', '    }\n', '        \n', '     /**\n', '     * @dev Get the message of the code form the trasnfer restriction contract\n', '     */\n', '    function messageForTransferRestriction (uint8 code) external override view  returns (string memory) {\n', '        return restrictedTransfer.messageForTransferRestriction(code);\n', '    }\n', '\n', '    /**\n', '     * @dev Standard trasnfer function is override here with restriction\n', '     */\n', '    function transfer (address to, uint256 value) public override notRestricted(msg.sender, to, value) returns (bool success) {\n', '        success = super.transfer(to, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Standard trasnferFrom function is override here with restriction\n', '     */\n', '    function transferFrom (address from, address to, uint256 value) public override notRestricted(from, to, value) returns (bool success) {\n', '        success = super.transferFrom(from, to, value);\n', '    }\n', '    \n', '    \n', '    /**\n', '     *  @dev Taking out mistaken sent token to this Smart contract to owner \n', '     */\n', '    function transferSCFunds(address token) public onlyOwner{\n', "         require(token != address(0), 'Token: Contract Address should not be ZERO value');\n", '         uint256 balance = IERC20(token).balanceOf(address(this));\n', "         require( balance > 0, 'Token: Contract does not have token');\n", '         IERC20(token).transfer(owner, balance);\n', '    }\n', '    \n', '    \n', '    /**\n', '     *  @dev Whitelist, Issue and lock the RVW token to the address to from address from\n', '     */\n', '    function _issueIssueWhitelistAndTimelock(address from, address to, uint256 value, uint256 releaseTime) internal returns(bool){\n', '        if(from == address(0) || to == address(0)) return false;\n', '        if(releaseTime > block.timestamp){\n', '            lock(to, releaseTime);\n', '        }\n', '        if(!isWhitelisted(to)){\n', '           setWhitelist(to, true);\n', '        }\n', '        uint8 code = restrictedTransfer.detectTransferRestriction(from, to, value);\n', '        if(code != SUCCESS) return false;\n', '        transferFrom(from, to, value);\n', '        emit Issue(to, value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     *  @dev Bulk Whitelist and Issue tokens to address to from address from\n', '     *  @param from, Wallet where tokens are present\n', '     *  @param to, contains all the address of users wallet\n', '     *  @param value, amount to token to be issued\n', '     *  @param releaseTime, if greater than block.timestamp then lock it otherwise do not lock it\n', '     */\n', '    function bulkIssueWhitelistAndTimelock(address from, address[] calldata to, uint256[] calldata value, uint256[] calldata releaseTime) public onlyWhitelister onlyTimelocker returns (bool) {\n', "        require(releaseTime.length == to.length, 'Bulk issue: Release Time and To Length is not same');\n", "        require(to.length == value.length, 'Bulk issue: To and Value Length is not same');\n", '        uint256 len = to.length;\n', '        for(uint256 i=0; i< len;i++){\n', '            _issueIssueWhitelistAndTimelock(from, to[i], value[i], releaseTime[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '\n', '    struct Role {\n', '        mapping (address => bool) manager;\n', '    }\n', '\n', '    /**\n', '     * @dev Add the role to the account\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(!has(role, account), "Roles: account already has role");\n', '        role.manager[account] = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Remove the role of the account\n', '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(has(role, account), "Roles: account does not have role");\n', '        role.manager[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if an account has this role.\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0), "Roles: account is the zero address");\n', '        return role.manager[account];\n', '    }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        \n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}']