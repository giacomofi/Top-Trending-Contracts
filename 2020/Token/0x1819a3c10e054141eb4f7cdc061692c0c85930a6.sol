['/**\n', ' RealTripChain \n', '*/\n', '\n', 'pragma solidity 0.4.11;\n', '\n', 'contract SafeMath {\n', '\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  // mitigate short address attack\n', '  // thanks to https://github.com/numerai/contract/blob/c182465f82e50ced8dacb3977ec374a892f5fa8c/contracts/Safe.sol#L30-L34.\n', '  // TODO: doublecheck implication of >= compared to ==\n', '  modifier onlyPayloadSize(uint numWords) {\n', '     assert(msg.data.length >= numWords * 32 + 4);\n', '     _;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Token { // ERC20 standard\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', '\n', 'contract StandardToken is Token, SafeMath {\n', '\n', '    uint256 public totalSupply;\n', '\n', '    // TODO: update tests to expect throw\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2) returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[msg.sender] >= _value && _value > 0);\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    // TODO: update tests to expect throw\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) returns (bool success) {\n', '        require(_to != address(0));\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', "    // To change the approve amount you first have to reduce the addresses'\n", "    //  allowance to zero by calling 'approve(_spender, 0)' if it is not\n", '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    function approve(address _spender, uint256 _value) onlyPayloadSize(2) returns (bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) onlyPayloadSize(3) returns (bool success) {\n', '        require(allowed[msg.sender][_spender] == _oldValue);\n', '        allowed[msg.sender][_spender] = _newValue;\n', '        Approval(msg.sender, _spender, _newValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '}\n', '\n', '\n', '/*------------------------------------\n', 'RealTripChain \n', ' SYMBOL : RTC\n', ' decimal : 8 \n', ' issue amount :  1,000,000,000\n', '--------------------------------------*/\n', '\n', 'contract RTC  is StandardToken { \n', '\n', '    /* Public variables of the token */\n', '\n', '    /*\n', '    NOTE:\n', '    The following variables are choice vanities. One does not have to include them.\n', '    They allow one to customise the token contract & in no way influences the core functionality.\n', '    Some wallets/interfaces might not even bother to look at this information.\n', '    */\n', '    string public name;                   // Token Name  token issued \n', '    uint8 public decimals;                // How many decimals to show. To be standard complicant keep it 18\n', '    string public symbol;                 // An identifier: eg SBX, XPR etc..\n', "    string public version = 'C1.0'; \n", '    uint256 public unitsOneEthCanBuy;     // How many units of your coin can be bought by 1 ETH?\n', "    uint256 public totalEthInWei;         // WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We'll store the total ETH raised via our ICO here.  \n", '    address public fundsWallet;           // Where should the raised ETH go?\n', '\n', '    // This is a constructor function \n', '    // which means the following function name has to match the contract name declared above\n', '\n', '    function RTC() {                        //** funtion name **/\n', '        balances[msg.sender] = 100000000000000000;          //** Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (coinchel )\n', '        totalSupply = 100000000000000000;               //** Update total supply (1000 for example) \n', '        name = "RealTripChain";                       //** Set the name for display purposes \n', '        decimals = 8 ;                                  // Amount of decimals for display purposes\n', '        symbol = "RTC";                                // Set the symbol for display purposes \n', '        unitsOneEthCanBuy = 10;                         // Set the price of your token for the ICO \n', '        fundsWallet = msg.sender;                       // The owner of the contract gets ETH\n', '    }\n', '\n', '\n', '    function() payable{\n', '        totalEthInWei = totalEthInWei + msg.value;\n', '        uint256 amount = msg.value * unitsOneEthCanBuy;\n', '        require(balances[fundsWallet] >= amount);\n', '\n', '        balances[fundsWallet] = balances[fundsWallet] - amount;\n', '        balances[msg.sender] = balances[msg.sender] + amount;\n', '\n', '        Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain\n', '\n', '        //Transfer ether to fundsWallet\n', '        fundsWallet.transfer(msg.value);                               \n', '    }\n', '\n', '    /* Approves and then calls the receiving contract */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '\n', "        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n", '        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n', '        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n', '        if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) { throw; }\n', '        return true;\n', '    }\n', '}']