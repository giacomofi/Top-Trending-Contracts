['pragma solidity 0.4.24;\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (_a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = _a * _b;\n', '    assert(c / _a == _b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = _a / _b;\n', "    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '    return _a / _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '    assert(_b <= _a);\n', '    return _a - _b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n', '    c = _a + _b;\n', '    assert(c >= _a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract VestingVault12 {\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint16;\n', '    \n', '    modifier onlyV12MultiSig {\n', '        require(msg.sender == v12MultiSig, "not owner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyValidAddress(address _recipient) {\n', '        require(_recipient != address(0) && _recipient != address(this) && _recipient != address(token), "not valid _recipient");\n', '        _;\n', '    }\n', '\n', '    uint256 constant internal SECONDS_PER_DAY = 86400;\n', '\n', '    struct Grant {\n', '        uint256 startTime;\n', '        uint256 amount;\n', '        uint16 vestingDuration;\n', '        uint16 vestingCliff;\n', '        uint16 daysClaimed;\n', '        uint256 totalClaimed;\n', '        address recipient;\n', '    }\n', '\n', '    event GrantAdded(address indexed recipient, uint256 vestingId);\n', '    event GrantTokensClaimed(address indexed recipient, uint256 amountClaimed);\n', '    event GrantRemoved(address recipient, uint256 amountVested, uint256 amountNotVested);\n', '    event ChangedMultisig(address multisig);\n', '\n', '    ERC20 public token;\n', '    \n', '    mapping (uint256 => Grant) public tokenGrants;\n', '    mapping (address => uint[]) private activeGrants;\n', '    address public v12MultiSig;\n', '    uint256 public totalVestingCount;\n', '\n', '    constructor(ERC20 _token) public {\n', '        require(address(_token) != address(0));\n', '        v12MultiSig = msg.sender;\n', '        token = _token;\n', '    }\n', '    \n', '    function addTokenGrant(\n', '        address _recipient,\n', '        uint256 _startTime,\n', '        uint256 _amount,\n', '        uint16 _vestingDurationInDays,\n', '        uint16 _vestingCliffInDays    \n', '    ) \n', '        external\n', '        onlyV12MultiSig\n', '    {\n', '        require(_vestingCliffInDays <= 10*365, "more than 10 years");\n', '        require(_vestingDurationInDays <= 25*365, "more than 25 years");\n', '        require(_vestingDurationInDays >= _vestingCliffInDays, "Duration < Cliff");\n', '        \n', '        uint256 amountVestedPerDay = _amount.div(_vestingDurationInDays);\n', '        require(amountVestedPerDay > 0, "amountVestedPerDay > 0");\n', '\n', '        // Transfer the grant tokens under the control of the vesting contract\n', '        require(token.transferFrom(v12MultiSig, address(this), _amount), "transfer failed");\n', '\n', '        Grant memory grant = Grant({\n', '            startTime: _startTime == 0 ? currentTime() : _startTime,\n', '            amount: _amount,\n', '            vestingDuration: _vestingDurationInDays,\n', '            vestingCliff: _vestingCliffInDays,\n', '            daysClaimed: 0,\n', '            totalClaimed: 0,\n', '            recipient: _recipient\n', '        });\n', '        tokenGrants[totalVestingCount] = grant;\n', '        activeGrants[_recipient].push(totalVestingCount);\n', '        emit GrantAdded(_recipient, totalVestingCount);\n', '        totalVestingCount++;\n', '    }\n', '\n', '    function getActiveGrants(address _recipient) public view returns(uint256[]){\n', '        return activeGrants[_recipient];\n', '    }\n', '\n', '    /// @notice Calculate the vested and unclaimed months and tokens available for `_grantId` to claim\n', '    /// Due to rounding errors once grant duration is reached, returns the entire left grant amount\n', '    /// Returns (0, 0) if cliff has not been reached\n', '    function calculateGrantClaim(uint256 _grantId) public view returns (uint16, uint256) {\n', '        Grant storage tokenGrant = tokenGrants[_grantId];\n', '\n', "        // For grants created with a future start date, that hasn't been reached, return 0, 0\n", '        if (currentTime() < tokenGrant.startTime) {\n', '            return (0, 0);\n', '        }\n', '\n', '        // Check cliff was reached\n', '        uint elapsedTime = currentTime().sub(tokenGrant.startTime);\n', '        uint elapsedDays = elapsedTime.div(SECONDS_PER_DAY);\n', '        \n', '        if (elapsedDays < tokenGrant.vestingCliff) {\n', '            return (uint16(elapsedDays), 0);\n', '        }\n', '\n', '        // If over vesting duration, all tokens vested\n', '        if (elapsedDays >= tokenGrant.vestingDuration) {\n', '            uint256 remainingGrant = tokenGrant.amount.sub(tokenGrant.totalClaimed);\n', '            return (tokenGrant.vestingDuration, remainingGrant);\n', '        } else {\n', '            uint16 daysVested = uint16(elapsedDays.sub(tokenGrant.daysClaimed));\n', '            uint256 amountVestedPerDay = tokenGrant.amount.div(uint256(tokenGrant.vestingDuration));\n', '            uint256 amountVested = uint256(daysVested.mul(amountVestedPerDay));\n', '            return (daysVested, amountVested);\n', '        }\n', '    }\n', '\n', '    /// @notice Allows a grant recipient to claim their vested tokens. Errors if no tokens have vested\n', '    /// It is advised recipients check they are entitled to claim via `calculateGrantClaim` before calling this\n', '    function claimVestedTokens(uint256 _grantId) external {\n', '        uint16 daysVested;\n', '        uint256 amountVested;\n', '        (daysVested, amountVested) = calculateGrantClaim(_grantId);\n', '        require(amountVested > 0, "amountVested is 0");\n', '\n', '        Grant storage tokenGrant = tokenGrants[_grantId];\n', '        tokenGrant.daysClaimed = uint16(tokenGrant.daysClaimed.add(daysVested));\n', '        tokenGrant.totalClaimed = uint256(tokenGrant.totalClaimed.add(amountVested));\n', '        \n', '        require(token.transfer(tokenGrant.recipient, amountVested), "no tokens");\n', '        emit GrantTokensClaimed(tokenGrant.recipient, amountVested);\n', '    }\n', '\n', '    /// @notice Terminate token grant transferring all vested tokens to the `_grantId`\n', '    /// and returning all non-vested tokens to the V12 MultiSig\n', '    /// Secured to the V12 MultiSig only\n', '    /// @param _grantId grantId of the token grant recipient\n', '    function removeTokenGrant(uint256 _grantId) \n', '        external \n', '        onlyV12MultiSig\n', '    {\n', '        Grant storage tokenGrant = tokenGrants[_grantId];\n', '        address recipient = tokenGrant.recipient;\n', '        uint16 daysVested;\n', '        uint256 amountVested;\n', '        (daysVested, amountVested) = calculateGrantClaim(_grantId);\n', '\n', '        uint256 amountNotVested = (tokenGrant.amount.sub(tokenGrant.totalClaimed)).sub(amountVested);\n', '\n', '        require(token.transfer(recipient, amountVested));\n', '        require(token.transfer(v12MultiSig, amountNotVested));\n', '\n', '        tokenGrant.startTime = 0;\n', '        tokenGrant.amount = 0;\n', '        tokenGrant.vestingDuration = 0;\n', '        tokenGrant.vestingCliff = 0;\n', '        tokenGrant.daysClaimed = 0;\n', '        tokenGrant.totalClaimed = 0;\n', '        tokenGrant.recipient = address(0);\n', '\n', '        emit GrantRemoved(recipient, amountVested, amountNotVested);\n', '    }\n', '\n', '    function currentTime() private view returns(uint256) {\n', '        return block.timestamp;\n', '    }\n', '\n', '    function tokensVestedPerDay(uint256 _grantId) public view returns(uint256) {\n', '        Grant storage tokenGrant = tokenGrants[_grantId];\n', '        return tokenGrant.amount.div(uint256(tokenGrant.vestingDuration));\n', '    }\n', '\n', '    function changeMultiSig(address _newMultisig) \n', '        external \n', '        onlyV12MultiSig\n', '        onlyValidAddress(_newMultisig)\n', '    {\n', '        v12MultiSig = _newMultisig;\n', '        emit ChangedMultisig(_newMultisig);\n', '    }\n', '\n', '}']