['pragma solidity ^0.5.16;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n', '// Subject to the MIT license.\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, errorMessage);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot underflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction underflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot underflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, errorMessage);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers.\n', '     * Reverts on division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers.\n', '     * Reverts with custom message on division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract QuickToken {\n', '    /// @notice EIP-20 token name for this token\n', '    string public constant name = "Quickswap";\n', '\n', '    /// @notice EIP-20 token symbol for this token\n', '    string public constant symbol = "QUICK";\n', '\n', '    /// @notice EIP-20 token decimals for this token\n', '    uint8 public constant decimals = 18;\n', '\n', '    /// @notice Total number of tokens in circulation\n', '    uint public totalSupply = 10000000000000000000000000; // 1 million QUICK\n', '\n', '    /// @notice Address which may mint new tokens\n', '    address public minter;\n', '\n', '    /// @notice The timestamp after which minting may occur\n', '    uint public mintingAllowedAfter;\n', '\n', '    /// @notice Minimum time between mints\n', '    uint32 public constant minimumTimeBetweenMints = 1 days * 365;\n', '\n', '    /// @notice Cap on the percentage of totalSupply that can be minted at each mint\n', '    uint8 public constant mintCap = 2;\n', '\n', '    /// @notice Allowance amounts on behalf of others\n', '    mapping (address => mapping (address => uint96)) internal allowances;\n', '\n', '    /// @notice Official record of token balances for each account\n', '    mapping (address => uint96) internal balances;\n', '\n', '\n', '    /// @notice An event thats emitted when the minter address is changed\n', '    event MinterChanged(address minter, address newMinter);\n', '\n', '    /// @notice The standard EIP-20 transfer event\n', '    event Transfer(address indexed from, address indexed to, uint256 amount);\n', '\n', '    /// @notice The standard EIP-20 approval event\n', '    event Approval(address indexed owner, address indexed spender, uint256 amount);\n', '\n', '    /**\n', '     * @notice Construct a new Quick token\n', '     * @param account The initial account to grant all the tokens\n', '     * @param minter_ The account with minting ability\n', '     * @param mintingAllowedAfter_ The timestamp after which minting may occur\n', '     */\n', '    constructor(address account, address minter_, uint mintingAllowedAfter_) public {\n', '        require(mintingAllowedAfter_ >= block.timestamp, "Quick::constructor: minting can only begin after deployment");\n', '\n', '        balances[account] = uint96(totalSupply);\n', '        emit Transfer(address(0), account, totalSupply);\n', '        minter = minter_;\n', '        emit MinterChanged(address(0), minter);\n', '        mintingAllowedAfter = mintingAllowedAfter_;\n', '    }\n', '\n', '    /**\n', '     * @notice Change the minter address\n', '     * @param minter_ The address of the new minter\n', '     */\n', '    function setMinter(address minter_) external {\n', '        require(msg.sender == minter, "Quick::setMinter: only the minter can change the minter address");\n', '        emit MinterChanged(minter, minter_);\n', '        minter = minter_;\n', '    }\n', '\n', '    /**\n', '     * @notice Mint new tokens\n', '     * @param dst The address of the destination account\n', '     * @param rawAmount The number of tokens to be minted\n', '     */\n', '    function mint(address dst, uint rawAmount) external {\n', '        require(msg.sender == minter, "Quick::mint: only the minter can mint");\n', '        require(block.timestamp >= mintingAllowedAfter, "Quick::mint: minting not allowed yet");\n', '        require(dst != address(0), "Quick::mint: cannot transfer to the zero address");\n', '\n', '        // record the mint\n', '        mintingAllowedAfter = SafeMath.add(block.timestamp, minimumTimeBetweenMints);\n', '\n', '        // mint the amount\n', '        uint96 amount = safe96(rawAmount, "Quick::mint: amount exceeds 96 bits");\n', '        require(amount <= SafeMath.div(SafeMath.mul(totalSupply, mintCap), 100), "Quick::mint: exceeded mint cap");\n', '        totalSupply = safe96(SafeMath.add(totalSupply, amount), "Quick::mint: totalSupply exceeds 96 bits");\n', '\n', '        // transfer the amount to the recipient\n', '        balances[dst] = add96(balances[dst], amount, "Quick::mint: transfer amount overflows");\n', '        emit Transfer(address(0), dst, amount);\n', '\n', '    }\n', '\n', '    /**\n', '     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n', '     * @param account The address of the account holding the funds\n', '     * @param spender The address of the account spending the funds\n', '     * @return The number of tokens approved\n', '     */\n', '    function allowance(address account, address spender) external view returns (uint) {\n', '        return allowances[account][spender];\n', '    }\n', '\n', '    /**\n', '     * @notice Approve `spender` to transfer up to `amount` from `src`\n', '     * @dev This will overwrite the approval amount for `spender`\n', '     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n', '     * @param spender The address of the account which may transfer tokens\n', '     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n', '     * @return Whether or not the approval succeeded\n', '     */\n', '    function approve(address spender, uint rawAmount) external returns (bool) {\n', '        uint96 amount;\n', '        if (rawAmount == uint(-1)) {\n', '            amount = uint96(-1);\n', '        } else {\n', '            amount = safe96(rawAmount, "Quick::approve: amount exceeds 96 bits");\n', '        }\n', '\n', '        allowances[msg.sender][spender] = amount;\n', '\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the number of tokens held by the `account`\n', '     * @param account The address of the account to get the balance of\n', '     * @return The number of tokens held\n', '     */\n', '    function balanceOf(address account) external view returns (uint) {\n', '        return balances[account];\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n', '     * @param dst The address of the destination account\n', '     * @param rawAmount The number of tokens to transfer\n', '     * @return Whether or not the transfer succeeded\n', '     */\n', '    function transfer(address dst, uint rawAmount) external returns (bool) {\n', '        uint96 amount = safe96(rawAmount, "Quick::transfer: amount exceeds 96 bits");\n', '        _transferTokens(msg.sender, dst, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer `amount` tokens from `src` to `dst`\n', '     * @param src The address of the source account\n', '     * @param dst The address of the destination account\n', '     * @param rawAmount The number of tokens to transfer\n', '     * @return Whether or not the transfer succeeded\n', '     */\n', '    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\n', '        address spender = msg.sender;\n', '        uint96 spenderAllowance = allowances[src][spender];\n', '        uint96 amount = safe96(rawAmount, "Quick::approve: amount exceeds 96 bits");\n', '\n', '        if (spender != src && spenderAllowance != uint96(-1)) {\n', '            uint96 newAllowance = sub96(spenderAllowance, amount, "Quick::transferFrom: transfer amount exceeds spender allowance");\n', '            allowances[src][spender] = newAllowance;\n', '\n', '            emit Approval(src, spender, newAllowance);\n', '        }\n', '\n', '        _transferTokens(src, dst, amount);\n', '        return true;\n', '    }\n', '\n', '    function _transferTokens(address src, address dst, uint96 amount) internal {\n', '        require(src != address(0), "Quick::_transferTokens: cannot transfer from the zero address");\n', '        require(dst != address(0), "Quick::_transferTokens: cannot transfer to the zero address");\n', '\n', '        balances[src] = sub96(balances[src], amount, "Quick::_transferTokens: transfer amount exceeds balance");\n', '        balances[dst] = add96(balances[dst], amount, "Quick::_transferTokens: transfer amount overflows");\n', '        emit Transfer(src, dst, amount);\n', '\n', '    }\n', '\n', '    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n', '        require(n < 2**32, errorMessage);\n', '        return uint32(n);\n', '    }\n', '\n', '    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\n', '        require(n < 2**96, errorMessage);\n', '        return uint96(n);\n', '    }\n', '\n', '    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n', '        uint96 c = a + b;\n', '        require(c >= a, errorMessage);\n', '        return c;\n', '    }\n', '\n', '    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '}']