['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract TwoWeeksNotice {\n', '    \n', '    struct StakeState {\n', '        uint64 balance;\n', '        uint64 unlockPeriod; // time it takes from requesting withdraw to being able to withdraw\n', '        uint64 lockedUntil; // 0 if withdraw is not requested\n', '        uint64 since;\n', '        uint128 accumulated; // token-days staked\n', '        uint128 accumulatedStrict; // token-days staked sans withdraw periods\n', '    }\n', '    \n', '    event StakeUpdate(address indexed from, uint64 balance);\n', '    event WithdrawRequest(address indexed from, uint64 until);\n', '    \n', '    mapping(address => StakeState) private _states;\n', '    \n', '    IERC20 private token;\n', '    \n', '    constructor (IERC20 _token) public {\n', '        token = _token;\n', '    }\n', '\n', '    function getStakeState(address account) external view returns (uint64, uint64, uint64, uint64) {\n', '        StakeState storage ss = _states[account];\n', '        return (ss.balance, ss.unlockPeriod, ss.lockedUntil, ss.since);\n', '    }\n', '    \n', '    function getAccumulated(address account) external view returns (uint128, uint128) {\n', '        StakeState storage ss = _states[account];\n', '        return (ss.accumulated, ss.accumulatedStrict);\n', '    }\n', '\n', '    function estimateAccumulated(address account) external view returns (uint128, uint128) {\n', '        StakeState storage ss = _states[account];\n', '        uint128 sum = ss.accumulated;\n', '        uint128 sumStrict = ss.accumulatedStrict;\n', '        if (ss.balance > 0) {\n', '            uint256 until = block.timestamp;\n', '            if (ss.lockedUntil > 0 && ss.lockedUntil < block.timestamp) {\n', '                until = ss.lockedUntil;\n', '            }\n', '            if (until > ss.since) {\n', '                uint128 delta = uint128( (uint256(ss.balance) * (until - ss.since))/86400 );\n', '                sum += delta;\n', '                if (ss.lockedUntil == 0) {\n', '                    sumStrict += delta;\n', '                }\n', '            }\n', '        }\n', '        return (sum, sumStrict);\n', '    }\n', '    \n', '    \n', '    function updateAccumulated(StakeState storage ss) private {\n', '        if (ss.balance > 0) {\n', '            uint256 until = block.timestamp;\n', '            if (ss.lockedUntil > 0 && ss.lockedUntil < block.timestamp) {\n', '                until = ss.lockedUntil;\n', '            }\n', '            if (until > ss.since) {\n', '                uint128 delta = uint128( (uint256(ss.balance) * (until - ss.since))/86400 );\n', '                ss.accumulated += delta;\n', '                if (ss.lockedUntil == 0) {\n', '                    ss.accumulatedStrict += delta;\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function stake(uint64 amount, uint64 unlockPeriod) external {\n', '        StakeState storage ss = _states[msg.sender];\n', '        require(amount > 0, "amount must be positive");\n', '        require(ss.balance <= amount, "cannot decrease balance");\n', '        require(unlockPeriod <= 1000 days, "unlockPeriod cannot be higher than 1000 days");\n', '        require(ss.unlockPeriod <= unlockPeriod, "cannot decrease unlock period");\n', '        require(unlockPeriod >= 2 weeks, "unlock period can\'t be less than 2 weeks");\n', '        \n', '        updateAccumulated(ss);\n', '        \n', '        uint128 delta = amount - ss.balance;\n', '        if (delta > 0) {\n', '            require(token.transferFrom(msg.sender, address(this), delta), "transfer unsuccessful");\n', '        }\n', '\n', '        ss.balance = amount;\n', '        ss.unlockPeriod = unlockPeriod;\n', '        ss.lockedUntil = 0;\n', '        ss.since = uint64(block.timestamp);\n', '        emit StakeUpdate(msg.sender, amount);\n', '    }\n', '    \n', '    function requestWithdraw() external {\n', '         StakeState storage ss = _states[msg.sender];\n', '         require(ss.balance > 0);\n', '         updateAccumulated(ss);\n', '         ss.since = uint64(block.timestamp);\n', '         ss.lockedUntil = uint64(block.timestamp + ss.unlockPeriod);\n', '    }\n', '\n', '    function withdraw(address to) external {\n', '        StakeState storage ss = _states[msg.sender];\n', '        require(ss.balance > 0, "must have tokens to withdraw");\n', '        require(ss.lockedUntil != 0, "unlock not requested");\n', '        require(ss.lockedUntil < block.timestamp, "still locked");\n', '        updateAccumulated(ss);\n', '        uint128 balance = ss.balance;\n', '        ss.balance = 0;\n', '        ss.unlockPeriod = 0;\n', '        ss.lockedUntil = 0;\n', '        ss.since = 0;\n', '        require(token.transfer(to, balance), "transfer unsuccessful");\n', '        emit StakeUpdate(msg.sender, 0);\n', '    }\n', '}']