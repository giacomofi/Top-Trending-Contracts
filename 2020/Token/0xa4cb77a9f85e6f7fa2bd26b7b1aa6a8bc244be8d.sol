['# @version 0.2.7\n', '"""\n', '@title "Zap" Depositer for Curve pool\n', '@author Curve.Fi\n', '@license Copyright (c) Curve.Fi, 2020 - all rights reserved\n', '"""\n', '\n', 'from vyper.interfaces import ERC20\n', '\n', '\n', 'interface CurveMeta:\n', '    def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256) -> uint256: nonpayable\n', '    def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]) -> uint256[N_COINS]: nonpayable\n', '    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256) -> uint256: nonpayable\n', '    def remove_liquidity_imbalance(amounts: uint256[N_COINS], max_burn_amount: uint256) -> uint256: nonpayable\n', '    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\n', '    def calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256: view\n', '    def base_pool() -> address: view\n', '    def coins(i: uint256) -> address: view\n', '\n', 'interface CurveBase:\n', '    def add_liquidity(amounts: uint256[BASE_N_COINS], min_mint_amount: uint256): nonpayable\n', '    def remove_liquidity(_amount: uint256, min_amounts: uint256[BASE_N_COINS]): nonpayable\n', '    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256): nonpayable\n', '    def remove_liquidity_imbalance(amounts: uint256[BASE_N_COINS], max_burn_amount: uint256): nonpayable\n', '    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\n', '    def calc_token_amount(amounts: uint256[BASE_N_COINS], deposit: bool) -> uint256: view\n', '    def coins(i: uint256) -> address: view\n', '    def fee() -> uint256: view\n', '\n', '\n', 'N_COINS: constant(int128) = 2\n', 'MAX_COIN: constant(int128) = N_COINS-1\n', 'BASE_N_COINS: constant(int128) = 5\n', 'N_ALL_COINS: constant(int128) = N_COINS + BASE_N_COINS - 1\n', '\n', '# An asset which may have a transfer fee (USDT)\n', 'FEE_ASSET: constant(address) = 0xdAC17F958D2ee523a2206206994597C13D831ec7\n', '\n', 'FEE_DENOMINATOR: constant(uint256) = 10 ** 10\n', 'FEE_IMPRECISION: constant(uint256) = 100 * 10 ** 8  # % of the fee\n', '\n', '\n', 'pool: public(address)\n', 'token: public(address)\n', 'base_pool: public(address)\n', '\n', 'coins: public(address[N_COINS])\n', 'base_coins: public(address[BASE_N_COINS])\n', '\n', '\n', '@external\n', 'def __init__(_pool: address, _token: address):\n', '    """\n', '    @notice Contract constructor\n', '    @param _pool Metapool address\n', '    @param _token Pool LP token address\n', '    """\n', '    self.pool = _pool\n', '    self.token = _token\n', '    _base_pool: address = CurveMeta(_pool).base_pool()\n', '    self.base_pool = _base_pool\n', '\n', '    for i in range(N_COINS):\n', '        coin: address = CurveMeta(_pool).coins(convert(i, uint256))\n', '        self.coins[i] = coin\n', '        # approve coins for infinite transfers\n', '        _response: Bytes[32] = raw_call(\n', '            coin,\n', '            concat(\n', '                method_id("approve(address,uint256)"),\n', '                convert(_pool, bytes32),\n', '                convert(MAX_UINT256, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(_response) > 0:\n', '            assert convert(_response, bool)\n', '\n', '    for i in range(BASE_N_COINS):\n', '        coin: address = CurveBase(_base_pool).coins(convert(i, uint256))\n', '        self.base_coins[i] = coin\n', '        # approve underlying coins for infinite transfers\n', '        _response: Bytes[32] = raw_call(\n', '            coin,\n', '            concat(\n', '                method_id("approve(address,uint256)"),\n', '                convert(_base_pool, bytes32),\n', '                convert(MAX_UINT256, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(_response) > 0:\n', '            assert convert(_response, bool)\n', '\n', '\n', '@external\n', 'def add_liquidity(amounts: uint256[N_ALL_COINS], min_mint_amount: uint256) -> uint256:\n', '    """\n', '    @notice Wrap underlying coins and deposit them in the pool\n', '    @param amounts List of amounts of underlying coins to deposit\n', '    @param min_mint_amount Minimum amount of LP tokens to mint from the deposit\n', '    @return Amount of LP tokens received by depositing\n', '    """\n', '    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\n', '    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\n', '    deposit_base: bool = False\n', '\n', '    # Transfer all coins in\n', '    for i in range(N_ALL_COINS):\n', '        amount: uint256 = amounts[i]\n', '        if amount == 0:\n', '            continue\n', '        coin: address = ZERO_ADDRESS\n', '        if i < MAX_COIN:\n', '            coin = self.coins[i]\n', '            meta_amounts[i] = amount\n', '        else:\n', '            x: int128 = i - MAX_COIN\n', '            coin = self.base_coins[x]\n', '            base_amounts[x] = amount\n', '            deposit_base = True\n', '        # "safeTransferFrom" which works for ERC20s which return bool or not\n', '        _response: Bytes[32] = raw_call(\n', '            coin,\n', '            concat(\n', '                method_id("transferFrom(address,address,uint256)"),\n', '                convert(msg.sender, bytes32),\n', '                convert(self, bytes32),\n', '                convert(amount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )  # dev: failed transfer\n', '        if len(_response) > 0:\n', '            assert convert(_response, bool)  # dev: failed transfer\n', '        # end "safeTransferFrom"\n', '        # Handle potential Tether fees\n', '        if coin == FEE_ASSET:\n', '            amount = ERC20(FEE_ASSET).balanceOf(self)\n', '            if i < MAX_COIN:\n', '                meta_amounts[i] = amount\n', '            else:\n', '                base_amounts[i - MAX_COIN] = amount\n', '\n', '    # Deposit to the base pool\n', '    if deposit_base:\n', '        CurveBase(self.base_pool).add_liquidity(base_amounts, 0)\n', '        meta_amounts[MAX_COIN] = ERC20(self.coins[MAX_COIN]).balanceOf(self)\n', '\n', '    # Deposit to the meta pool\n', '    CurveMeta(self.pool).add_liquidity(meta_amounts, min_mint_amount)\n', '\n', '    # Transfer meta token back\n', '    _lp_token: address = self.token\n', '    _lp_amount: uint256 = ERC20(_lp_token).balanceOf(self)\n', '    assert ERC20(_lp_token).transfer(msg.sender, _lp_amount)\n', '\n', '    return _lp_amount\n', '\n', '\n', '@external\n', 'def remove_liquidity(_amount: uint256, min_amounts: uint256[N_ALL_COINS]) -> uint256[N_ALL_COINS]:\n', '    """\n', '    @notice Withdraw and unwrap coins from the pool\n', '    @dev Withdrawal amounts are based on current deposit ratios\n', '    @param _amount Quantity of LP tokens to burn in the withdrawal\n', '    @param min_amounts Minimum amounts of underlying coins to receive\n', '    @return List of amounts of underlying coins that were withdrawn\n', '    """\n', '    _token: address = self.token\n', '    assert ERC20(_token).transferFrom(msg.sender, self, _amount)\n', '\n', '    min_amounts_meta: uint256[N_COINS] = empty(uint256[N_COINS])\n', '    min_amounts_base: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\n', '    amounts: uint256[N_ALL_COINS] = empty(uint256[N_ALL_COINS])\n', '\n', '    # Withdraw from meta\n', '    for i in range(MAX_COIN):\n', '        min_amounts_meta[i] = min_amounts[i]\n', '    CurveMeta(self.pool).remove_liquidity(_amount, min_amounts_meta)\n', '\n', '    # Withdraw from base\n', '    _base_amount: uint256 = ERC20(self.coins[MAX_COIN]).balanceOf(self)\n', '    for i in range(BASE_N_COINS):\n', '        min_amounts_base[i] = min_amounts[MAX_COIN+i]\n', '    CurveBase(self.base_pool).remove_liquidity(_base_amount, min_amounts_base)\n', '\n', '    # Transfer all coins out\n', '    for i in range(N_ALL_COINS):\n', '        coin: address = ZERO_ADDRESS\n', '        if i < MAX_COIN:\n', '            coin = self.coins[i]\n', '        else:\n', '            coin = self.base_coins[i - MAX_COIN]\n', '        amounts[i] = ERC20(coin).balanceOf(self)\n', '        # "safeTransfer" which works for ERC20s which return bool or not\n', '        _response: Bytes[32] = raw_call(\n', '            coin,\n', '            concat(\n', '                method_id("transfer(address,uint256)"),\n', '                convert(msg.sender, bytes32),\n', '                convert(amounts[i], bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )  # dev: failed transfer\n', '        if len(_response) > 0:\n', '            assert convert(_response, bool)  # dev: failed transfer\n', '        # end "safeTransfer"\n', '\n', '    return amounts\n', '\n', '\n', '@external\n', 'def remove_liquidity_one_coin(_token_amount: uint256, i: int128, _min_amount: uint256) -> uint256:\n', '    """\n', '    @notice Withdraw and unwrap a single coin from the pool\n', '    @param _token_amount Amount of LP tokens to burn in the withdrawal\n', '    @param i Index value of the coin to withdraw\n', '    @param _min_amount Minimum amount of underlying coin to receive\n', '    @return Amount of underlying coin received\n', '    """\n', '    assert ERC20(self.token).transferFrom(msg.sender, self, _token_amount)\n', '\n', '    coin: address = ZERO_ADDRESS\n', '    if i < MAX_COIN:\n', '        coin = self.coins[i]\n', '        # Withdraw a metapool coin\n', '        CurveMeta(self.pool).remove_liquidity_one_coin(_token_amount, i, _min_amount)\n', '    else:\n', '        coin = self.base_coins[i - MAX_COIN]\n', '        # Withdraw a base pool coin\n', '        CurveMeta(self.pool).remove_liquidity_one_coin(_token_amount, MAX_COIN, 0)\n', '        CurveBase(self.base_pool).remove_liquidity_one_coin(\n', '            ERC20(self.coins[MAX_COIN]).balanceOf(self), i-MAX_COIN, _min_amount\n', '        )\n', '\n', '    # Tranfer the coin out\n', '    coin_amount: uint256 = ERC20(coin).balanceOf(self)\n', '    # "safeTransfer" which works for ERC20s which return bool or not\n', '    _response: Bytes[32] = raw_call(\n', '        coin,\n', '        concat(\n', '            method_id("transfer(address,uint256)"),\n', '            convert(msg.sender, bytes32),\n', '            convert(coin_amount, bytes32),\n', '        ),\n', '        max_outsize=32,\n', '    )  # dev: failed transfer\n', '    if len(_response) > 0:\n', '        assert convert(_response, bool)  # dev: failed transfer\n', '    # end "safeTransfer"\n', '\n', '    return coin_amount\n', '\n', '\n', '@external\n', 'def remove_liquidity_imbalance(amounts: uint256[N_ALL_COINS], max_burn_amount: uint256) -> uint256:\n', '    """\n', '    @notice Withdraw coins from the pool in an imbalanced amount\n', '    @param amounts List of amounts of underlying coins to withdraw\n', '    @param max_burn_amount Maximum amount of LP token to burn in the withdrawal.\n', "                           This value cannot exceed the caller's LP token balance.\n", '    @return Actual amount of the LP token burned in the withdrawal\n', '    """\n', '    _base_pool: address = self.base_pool\n', '    _meta_pool: address = self.pool\n', '    _base_coins: address[BASE_N_COINS] = self.base_coins\n', '    _meta_coins: address[N_COINS] = self.coins\n', '    _lp_token: address = self.token\n', '\n', '    fee: uint256 = CurveBase(_base_pool).fee() * BASE_N_COINS / (4 * (BASE_N_COINS - 1))\n', '    fee += fee * FEE_IMPRECISION / FEE_DENOMINATOR  # Overcharge to account for imprecision\n', '\n', '    # Transfer the LP token in\n', '    assert ERC20(_lp_token).transferFrom(msg.sender, self, max_burn_amount)\n', '\n', '    withdraw_base: bool = False\n', '    amounts_base: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\n', '    amounts_meta: uint256[N_COINS] = empty(uint256[N_COINS])\n', '    leftover_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\n', '\n', '    # Prepare quantities\n', '    for i in range(MAX_COIN):\n', '        amounts_meta[i] = amounts[i]\n', '\n', '    for i in range(BASE_N_COINS):\n', '        amount: uint256 = amounts[MAX_COIN + i]\n', '        if amount != 0:\n', '            amounts_base[i] = amount\n', '            withdraw_base = True\n', '\n', '    if withdraw_base:\n', '        amounts_meta[MAX_COIN] = CurveBase(self.base_pool).calc_token_amount(amounts_base, False)\n', '        amounts_meta[MAX_COIN] += amounts_meta[MAX_COIN] * fee / FEE_DENOMINATOR + 1\n', '\n', '    # Remove liquidity and deposit leftovers back\n', '    CurveMeta(_meta_pool).remove_liquidity_imbalance(amounts_meta, max_burn_amount)\n', '    if withdraw_base:\n', '        CurveBase(_base_pool).remove_liquidity_imbalance(amounts_base, amounts_meta[MAX_COIN])\n', '        leftover_amounts[MAX_COIN] = ERC20(_meta_coins[MAX_COIN]).balanceOf(self)\n', '        if leftover_amounts[MAX_COIN] > 0:\n', '            CurveMeta(_meta_pool).add_liquidity(leftover_amounts, 0)\n', '\n', '    # Transfer all coins out\n', '    for i in range(N_ALL_COINS):\n', '        coin: address = ZERO_ADDRESS\n', '        amount: uint256 = 0\n', '        if i < MAX_COIN:\n', '            coin = _meta_coins[i]\n', '            amount = amounts_meta[i]\n', '        else:\n', '            coin = _base_coins[i - MAX_COIN]\n', '            amount = amounts_base[i - MAX_COIN]\n', '        # "safeTransfer" which works for ERC20s which return bool or not\n', '        if amount > 0:\n', '            _response: Bytes[32] = raw_call(\n', '                coin,\n', '                concat(\n', '                    method_id("transfer(address,uint256)"),\n', '                    convert(msg.sender, bytes32),\n', '                    convert(amount, bytes32),\n', '                ),\n', '                max_outsize=32,\n', '            )  # dev: failed transfer\n', '            if len(_response) > 0:\n', '                assert convert(_response, bool)  # dev: failed transfer\n', '            # end "safeTransfer"\n', '\n', '    # Transfer the leftover LP token out\n', '    leftover: uint256 = ERC20(_lp_token).balanceOf(self)\n', '    if leftover > 0:\n', '        assert ERC20(_lp_token).transfer(msg.sender, leftover)\n', '\n', '    return max_burn_amount - leftover\n', '\n', '\n', '@view\n', '@external\n', 'def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256:\n', '    """\n', '    @notice Calculate the amount received when withdrawing and unwrapping a single coin\n', '    @param _token_amount Amount of LP tokens to burn in the withdrawal\n', '    @param i Index value of the underlying coin to withdraw\n', '    @return Amount of coin received\n', '    """\n', '    if i < MAX_COIN:\n', '        return CurveMeta(self.pool).calc_withdraw_one_coin(_token_amount, i)\n', '    else:\n', '        _base_tokens: uint256 = CurveMeta(self.pool).calc_withdraw_one_coin(_token_amount, MAX_COIN)\n', '        return CurveBase(self.base_pool).calc_withdraw_one_coin(_base_tokens, i-MAX_COIN)\n', '\n', '\n', '@view\n', '@external\n', 'def calc_token_amount(amounts: uint256[N_ALL_COINS], is_deposit: bool) -> uint256:\n', '    """\n', '    @notice Calculate addition or reduction in token supply from a deposit or withdrawal\n', '    @dev This calculation accounts for slippage, but not fees.\n', '         Needed to prevent front-running, not for precise calculations!\n', '    @param amounts Amount of each underlying coin being deposited\n', '    @param is_deposit set True for deposits, False for withdrawals\n', '    @return Expected amount of LP tokens received\n', '    """\n', '    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\n', '    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\n', '\n', '    for i in range(MAX_COIN):\n', '        meta_amounts[i] = amounts[i]\n', '\n', '    for i in range(BASE_N_COINS):\n', '        base_amounts[i] = amounts[i + MAX_COIN]\n', '\n', '    _base_tokens: uint256 = CurveBase(self.base_pool).calc_token_amount(base_amounts, is_deposit)\n', '    meta_amounts[MAX_COIN] = _base_tokens\n', '\n', '    return CurveMeta(self.pool).calc_token_amount(meta_amounts, is_deposit)']