['pragma solidity ^0.4.24;\n', '\n', 'contract Rootex {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  string public author;\n', '  uint public offerRef;\n', '  uint256 internal PPT;\n', '\n', '  bytes32 internal SYMBOL;\n', '  mapping (bytes32 => uint256) public limits;\n', '  mapping (bytes32 => uint256) public supplies;\n', '  mapping (bytes32 => mapping (address => uint256)) public balances;\n', '\n', '  mapping (uint => Market) public markets;\n', '  struct Market {\n', '    bytes32 askCoin;\n', '    bytes32 ownCoin;\n', '    uint256 ask2own;\n', '    uint256 value;\n', '    uint256 taken;\n', '    address maker;\n', '    uint time; }\n', '\n', '  event Transfer (address indexed from, address indexed to, uint256 value);\n', '  event Move (bytes32 indexed coin, address indexed from, address indexed to, uint256 value);\n', '  event Sell (uint refno, bytes32 indexed askCoin, bytes32 indexed ownCoin, uint256 ask2own, address indexed maker);\n', '  event Buy (uint indexed refno, address indexed taker, uint256 paidValue);\n', '\n', '  constructor () public {\n', '    PPT = 10**18;\n', '    decimals = 18;\n', '  }\n', '\n', '  function tocoin (string memory coinSymbol)\n', '  internal pure returns (bytes32) {\n', '    return (keccak256(abi.encodePacked(coinSymbol)));\n', '  }\n', '\n', '  function move (bytes32 coin, address from, address to, uint256 value)\n', '  internal {\n', '    require (value<=balances[coin][from]);\n', '    require (balances[coin][to]+value>balances[coin][to]);\n', '    uint256 sum = balances[coin][from]+balances[coin][to];\n', '    balances[coin][from] -= value;\n', '    balances[coin][to] += value;\n', '    assert (balances[coin][from]+balances[coin][to]==sum);\n', '  }\n', '\n', '  function mint (bytes32 coin, address to, uint256 value)\n', '  internal {\n', '    require (limits[coin]==0||limits[coin]>=supplies[coin]+value);\n', '    require (balances[coin][to]+value>balances[coin][to]);\n', '    uint256 dif = supplies[coin]-balances[coin][to];\n', '    supplies[coin] += value;\n', '    balances[coin][to] += value;\n', '    assert (supplies[coin]-balances[coin][to]==dif);\n', '  }\n', '\n', '  function burn (bytes32 coin, address from, uint256 value)\n', '  internal {\n', '    require (value<=balances[coin][from]);\n', '    uint256 dif = supplies[coin]-balances[coin][from];\n', '    supplies[coin] -= value;\n', '    balances[coin][from] -= value;\n', '    assert (supplies[coin]-balances[coin][from]==dif);\n', '  }\n', '\n', '  function swap (bytes32 coin1, uint256 value1, bytes32 coin2, uint256 value2)\n', '  internal {\n', '    burn (coin1, msg.sender, value1);\n', '    mint (coin2, msg.sender, value2);\n', '  }\n', '\n', '  function deduct (Market storage mi, uint256 value)\n', '  internal {\n', '    uint256 sum = mi.value+mi.taken;\n', '    mi.value -= value;\n', '    mi.taken += value;\n', '    assert (mi.value+mi.taken==sum);\n', '  }\n', '\n', '  function take (uint refno, address taker, uint256 fitValue)\n', '  internal returns (uint256) {\n', '    Market storage mi = markets[refno];\n', '    require (mi.value>0&&mi.ask2own>0, "#data");\n', '    require (mi.time==0||mi.time>=now, "#time");\n', '    uint256 askValue = PPT*mi.value/mi.ask2own;\n', '    uint256 ownValue = fitValue*mi.ask2own/PPT;\n', '    if (askValue>fitValue) askValue = fitValue;\n', '    if (ownValue>mi.value) ownValue = mi.value;\n', '    move (mi.askCoin, taker, mi.maker, askValue);\n', '    move (mi.ownCoin, address(this), taker, ownValue);\n', '    deduct (mi, ownValue);\n', '    return askValue;\n', '  }\n', '\n', '  // PUBLIC METHODS\n', '\n', '  function post (bytes32 askCoin, bytes32 ownCoin, uint256 ask2own, uint256 value, uint time) public returns (bool success) {\n', '    require (time==0||time>now, "#time");\n', '    require (value>0&&ask2own>0, "#values");\n', '    move (ownCoin, msg.sender, address(this), value);\n', '    Market memory mi;\n', '    mi.askCoin = askCoin;\n', '    mi.ownCoin = ownCoin;\n', '    mi.ask2own = ask2own;\n', '    mi.maker = msg.sender;\n', '    mi.value = value;\n', '    mi.time = time;\n', '    markets[++offerRef] = mi;\n', '    emit Sell (offerRef, mi.askCoin, mi.ownCoin, mi.ask2own, mi.maker);\n', '    return true;\n', '  }\n', '\n', '  function unpost (uint refno) public returns (bool success) {\n', '    Market storage mi = markets[refno];\n', '    require (mi.value>0, "#data");\n', '    require (mi.maker==msg.sender, "#user");\n', '    require (mi.time==0||mi.time<now, "#time");\n', '    move (mi.ownCoin, address(this), mi.maker, mi.value);\n', '    mi.value = 0;\n', '    return true;\n', '  }\n', '\n', '  function acquire (uint refno, uint256 fitValue) public returns (bool success) {\n', '    fitValue = take (refno, msg.sender, fitValue);\n', '    emit Buy (refno, msg.sender, fitValue);\n', '    return true;\n', '  }\n', '\n', '  function who (uint surf, bytes32 askCoin, bytes32 ownCoin, uint256 ask2own, uint256 value) public view returns (uint found) {\n', '    uint pos = offerRef<surf?1:offerRef-surf+1;\n', '    for (uint i=pos; i<=offerRef; i++) {\n', '      Market memory mi = markets[i];\n', '      if (mi.askCoin==askCoin&&mi.ownCoin==ownCoin&&mi.value>value&&mi.ask2own>=ask2own&&(mi.time==0||mi.time>=now)) return(i);\n', '    }\n', '  }\n', '\n', '  // ERC20 METHODS\n', '\n', '  function balanceOf (address wallet) public view returns (uint256) {\n', '    return balances[SYMBOL][wallet];\n', '  }\n', '\n', '  function totalSupply () public view returns (uint256) {\n', '    return supplies[SYMBOL];\n', '  }\n', '\n', '  function transfer (address to, uint256 value) public returns (bool success) {\n', '    move (SYMBOL, msg.sender, to, value);\n', '    emit Transfer (msg.sender, to, value);\n', '    return true;\n', '  }\n', '\n', '  function transfer (bytes32 coin, address to, uint256 value) public returns (bool success) {\n', '    move (coin, msg.sender, to, value);\n', '    emit Move (coin, msg.sender, to, value);\n', '    return true;\n', '  }\n', '}']
['pragma solidity ^0.4.24;\n', '\n', 'import "./Rootex.sol";\n', '\n', 'contract Exet is Rootex {\n', '  address public owner;\n', '\n', '  address[] public adminsList;\n', '  mapping (address => bool) public listedAdmins;\n', '  mapping (address => bool) public activeAdmins;\n', '\n', '  string[] public symbolsList;\n', '  mapping (bytes32 => bool) public listedCoins;\n', '  mapping (bytes32 => bool) public lockedCoins;\n', '  mapping (bytes32 => uint256) public coinPrices;\n', '\n', '  string constant ETH = "ETH";\n', '  bytes32 constant ETHEREUM = 0xaaaebeba3810b1e6b70781f14b2d72c1cb89c0b2b320c43bb67ff79f562f5ff4;\n', '  address constant PROJECT = 0x537ca62B4c232af1ef82294BE771B824cCc078Ff;\n', '\n', '  event Admin (address user, bool active);\n', '  event Coin (string indexed coinSymbol, string coinName, address maker, uint256 rate);\n', '  event Deposit (string indexed coinSymbol, address indexed maker, uint256 value);\n', '  event Withdraw (string indexed coinSymbol, address indexed maker, uint256 value);\n', '\n', '  constructor (uint sysCost, uint ethCost) public {\n', '    author = "ASINERUM INTERNATIONAL";\n', '    name = "ETHEREUM CRYPTO EXCHANGE TOKEN";\n', '    symbol = "EXET";\n', '    owner = msg.sender;\n', '    newadmin (owner, true);\n', '    SYMBOL = tocoin(symbol);\n', '    newcoin (symbol, name, sysCost*PPT);\n', '    newcoin (ETH, "ETHEREUM", ethCost*PPT);\n', '  }\n', '\n', '  function newadmin (address user, bool active)\n', '  internal {\n', '    if (!listedAdmins[user]) {\n', '      listedAdmins[user] = true;\n', '      adminsList.push (user);\n', '    }\n', '    activeAdmins[user] = active;\n', '    emit Admin (user, active);\n', '  }\n', '\n', '  function newcoin (string memory coinSymbol, string memory coinName, uint256 rate)\n', '  internal {\n', '    bytes32 coin = tocoin (coinSymbol);\n', '    if (!listedCoins[coin]) {\n', '      listedCoins[coin] = true;\n', '      symbolsList.push (coinSymbol);\n', '    }\n', '    coinPrices[coin] = rate;\n', '    emit Coin (coinSymbol, coinName, msg.sender, rate);\n', '  }\n', '\n', '  // GOVERNANCE FUNCTIONS\n', '\n', '  function adminer (address user, bool active) public {\n', '    require (msg.sender==owner, "#owner");\n', '    newadmin (user, active);\n', '  }\n', '\n', '  function coiner (string memory coinSymbol, string memory coinName, uint256 rate) public {\n', '    require (activeAdmins[msg.sender], "#admin");\n', '    newcoin (coinSymbol, coinName, rate);\n', '  }\n', '\n', '  function lock (bytes32 coin) public {\n', '    require (msg.sender==owner, "#owner");\n', '    require (!lockedCoins[coin], "#coin");\n', '    lockedCoins[coin] = true;\n', '  }\n', '\n', '  function lim (bytes32 coin, uint256 value) public {\n', '    require (activeAdmins[msg.sender], "#admin");\n', '    require (limits[coin]==0, "#coin");\n', '    limits[coin] = value;\n', '  }\n', '\n', '  // PUBLIC METHODS\n', '\n', '  function () public payable {\n', '    deposit (ETH);\n', '  }\n', '\n', '  function deposit () public payable returns (bool success) {\n', '    return deposit (symbol);\n', '  }\n', '\n', '  function deposit (string memory coinSymbol) public payable returns (bool success) {\n', '    return deposit (coinSymbol, msg.sender);\n', '  }\n', '\n', '  function deposit (string memory coinSymbol, address to) public payable returns (bool success) {\n', '    bytes32 coin = tocoin (coinSymbol);\n', '    uint256 crate = coinPrices[coin];\n', '    uint256 erate = coinPrices[ETHEREUM];\n', '    require (!lockedCoins[coin], "#coin");\n', '    require (crate>0, "#token");\n', '    require (erate>0, "#ether");\n', '    require (msg.value>0, "#value");\n', '    uint256 value = msg.value*erate/crate;\n', '    mint (coin, to, value);\n', '    mint (SYMBOL, PROJECT, value);\n', '    emit Deposit (coinSymbol, to, value);\n', '    return true;\n', '  }\n', '\n', '  function withdraw (string memory coinSymbol, uint256 value) public returns (bool success) {\n', '    bytes32 coin = tocoin (coinSymbol);\n', '    uint256 crate = coinPrices[coin];\n', '    uint256 erate = coinPrices[ETHEREUM];\n', '    require (crate>0, "#token");\n', '    require (erate>0, "#ether");\n', '    require (value>0, "#value");\n', '    burn (coin, msg.sender, value);\n', '    mint (SYMBOL, PROJECT, value);\n', '    msg.sender.transfer (value*crate/erate);\n', '    emit Withdraw (coinSymbol, msg.sender, value);\n', '    return true;\n', '  }\n', '\n', '  function swap (bytes32 coin1, uint256 value1, bytes32 coin2) public returns (bool success) {\n', '    require (!lockedCoins[coin2], "#target");\n', '    uint256 price1 = coinPrices[coin1];\n', '    uint256 price2 = coinPrices[coin2];\n', '    require (price1>0, "#coin1");\n', '    require (price2>0, "#coin2");\n', '    require (value1>0, "#input");\n', '    uint256 value2 = value1*price1/price2;\n', '    swap (coin1, value1, coin2, value2);\n', '    mint (SYMBOL, PROJECT, value2);\n', '    return true;\n', '  }\n', '\n', '  function lens () public view returns (uint admins, uint symbols) {\n', '    admins = adminsList.length;\n', '    symbols = symbolsList.length;\n', '  }\n', '}']
