['// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity ^0.6.12;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        require(b > 0);\n', '        uint c = a / b;\n', '        require(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint a, uint b) internal pure returns (uint) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint a, uint b) internal pure returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '\n', 'interface ISupplyController {\n', '\tfunction mint(address token, address owner, uint amount) external;\n', '}\n', '\n', 'interface IADXToken {\n', '\tfunction transfer(address to, uint256 amount) external returns (bool);\n', '\tfunction transferFrom(address from, address to, uint256 amount) external returns (bool);\n', '\tfunction approve(address spender, uint256 amount) external returns (bool);\n', '\tfunction balanceOf(address spender) external view returns (uint);\n', '\tfunction allowance(address owner, address spender) external view returns (uint);\n', '\tfunction supplyController() external view returns (ISupplyController);\n', '}\n', '\n', 'contract ADXLoyaltyPoolToken {\n', '\tusing SafeMath for uint;\n', '\n', '\t// ERC20 stuff\n', '\t// Constants\n', '\tstring public constant name = "AdEx Loyalty";\n', '\tuint8 public constant decimals = 18;\n', '\tstring public symbol = "ADX-LOYALTY";\n', '\n', '\t// Mutable variables\n', '\tuint public totalSupply;\n', '\tmapping(address => uint) balances;\n', '\tmapping(address => mapping(address => uint)) allowed;\n', '\n', '\t// EIP 2612\n', '\tbytes32 public DOMAIN_SEPARATOR;\n', '\t// keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '\tmapping(address => uint) public nonces;\n', '\n', '\t// ERC20 events\n', '\tevent Approval(address indexed owner, address indexed spender, uint amount);\n', '\tevent Transfer(address indexed from, address indexed to, uint amount);\n', '\n', '\tfunction balanceOf(address owner) external view returns (uint balance) {\n', '\t\treturn balances[owner];\n', '\t}\n', '\n', '\tfunction transfer(address to, uint amount) external returns (bool success) {\n', "\t\trequire(to != address(this), 'BAD_ADDRESS');\n", '\t\tbalances[msg.sender] = balances[msg.sender].sub(amount);\n', '\t\tbalances[to] = balances[to].add(amount);\n', '\t\temit Transfer(msg.sender, to, amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction transferFrom(address from, address to, uint amount) external returns (bool success) {\n', '\t\tbalances[from] = balances[from].sub(amount);\n', '\t\tallowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n', '\t\tbalances[to] = balances[to].add(amount);\n', '\t\temit Transfer(from, to, amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction approve(address spender, uint amount) external returns (bool success) {\n', '\t\tallowed[msg.sender][spender] = amount;\n', '\t\temit Approval(msg.sender, spender, amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction allowance(address owner, address spender) external view returns (uint remaining) {\n', '\t\treturn allowed[owner][spender];\n', '\t}\n', '\n', '\t// EIP 2612\n', '\tfunction permit(address owner, address spender, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n', "\t\trequire(deadline >= block.timestamp, 'DEADLINE_EXPIRED');\n", '\t\tbytes32 digest = keccak256(abi.encodePacked(\n', "\t\t\t'\\x19\\x01',\n", '\t\t\tDOMAIN_SEPARATOR,\n', '\t\t\tkeccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline))\n', '\t\t));\n', '\t\taddress recoveredAddress = ecrecover(digest, v, r, s);\n', "\t\trequire(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\n", '\t\tallowed[owner][spender] = amount;\n', '\t\temit Approval(owner, spender, amount);\n', '\t}\n', '\n', '\t// Inner\n', '\tfunction innerMint(address owner, uint amount) internal {\n', '\t\ttotalSupply = totalSupply.add(amount);\n', '\t\tbalances[owner] = balances[owner].add(amount);\n', '\t\t// Because of https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer-1\n', '\t\temit Transfer(address(0), owner, amount);\n', '\t}\n', '\tfunction innerBurn(address owner, uint amount) internal {\n', '\t\ttotalSupply = totalSupply.sub(amount);\n', '\t\tbalances[owner] = balances[owner].sub(amount);\n', '\t\temit Transfer(owner, address(0), amount);\n', '\t}\n', '\n', '\n', '\t// Pool functionality\n', '\tevent LogSetGovernance(address indexed addr, bool hasGovt, uint time);\n', '\tevent LogSetIncentive(uint incentive, uint time);\n', '\n', '\tIADXToken public ADXToken;\n', '\tuint public incentivePerTokenPerAnnum;\n', '\tuint public lastMintTime;\n', '\tuint public maxTotalADX;\n', '\tmapping (address => bool) public governance;\n', '\tconstructor(IADXToken token, uint incentive, uint cap) public {\n', '\t\tADXToken = token;\n', '\t\tincentivePerTokenPerAnnum = incentive;\n', '\t\tmaxTotalADX = cap;\n', '\t\tgovernance[msg.sender] = true;\n', '\t\tlastMintTime = block.timestamp;\n', '\t\t// EIP 2612\n', '\t\tuint chainId;\n', '\t\tassembly {\n', '\t\t\tchainId := chainid()\n', '\t\t}\n', '\t\tDOMAIN_SEPARATOR = keccak256(\n', '\t\t\tabi.encode(\n', "\t\t\t\tkeccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n", '\t\t\t\tkeccak256(bytes(name)),\n', "\t\t\t\tkeccak256(bytes('1')),\n", '\t\t\t\tchainId,\n', '\t\t\t\taddress(this)\n', '\t\t\t)\n', '\t\t);\n', '\n', '\t\temit LogSetGovernance(msg.sender, true, block.timestamp);\n', '\t\temit LogSetIncentive(incentive, block.timestamp);\n', '\t}\n', '\n', '\t// Governance functions\n', '\tfunction setGovernance(address addr, bool hasGovt) external {\n', "\t\trequire(governance[msg.sender], 'NOT_GOVERNANCE');\n", '\t\tgovernance[addr] = hasGovt;\n', '\t\temit LogSetGovernance(addr, hasGovt, block.timestamp);\n', '\t}\n', "\t// This doesn't trigger a mint because otherwise we risk of being unable to setIncentive to 0\n", '\t// if minting is impossible\n', "\t// It's the better tradeoff to make - and the issue of front-running mintIncnetive with setIncentive(0) can\n", '\t// be solved by timelocking the governance\n', '\tfunction setIncentive(uint newIncentive) external {\n', "\t\trequire(governance[msg.sender], 'NOT_GOVERNANCE');\n", '\t\tincentivePerTokenPerAnnum = newIncentive;\n', '\t\tlastMintTime = block.timestamp;\n', '\t\temit LogSetIncentive(newIncentive, block.timestamp);\n', '\t}\n', '\tfunction setSymbol(string calldata newSymbol) external {\n', "\t\trequire(governance[msg.sender], 'NOT_GOVERNANCE');\n", '\t\tsymbol = newSymbol;\n', '\t}\n', '\tfunction setMaxTotalADX(uint newMaxTotalADX) external {\n', "\t\trequire(governance[msg.sender], 'NOT_GOVERNANCE');\n", '\t\tmaxTotalADX = newMaxTotalADX;\n', '\t}\n', '\n', '\n', '\t// Pool stuff\n', '\t// There are a few notable items in how minting works\n', '\t// 1) if ADX is sent to the LoyaltyPool in-between mints, it will calculate the incentive as if this amount\n', '\t// has been there the whole time since the last mint\n', '\t// 2) Compounding is happening when mint is called, so essentially when entities enter/leave/trigger it manually\n', '\tfunction toMint() external view returns (uint) {\n', '\t\tif (block.timestamp <= lastMintTime) return 0;\n', '\t\tuint totalADX = ADXToken.balanceOf(address(this));\n', '\t\treturn (block.timestamp - lastMintTime)\n', '\t\t\t.mul(totalADX)\n', '\t\t\t.mul(incentivePerTokenPerAnnum)\n', '\t\t\t.div(365 days * 10e17);\n', '\t}\n', '\n', '\tfunction shareValue() external view returns (uint) {\n', '\t\tif (totalSupply == 0) return 0;\n', '\t\treturn ADXToken.balanceOf(address(this))\n', '\t\t\t.add(this.toMint())\n', '\t\t\t.mul(10e17)\n', '\t\t\t.div(totalSupply);\n', '\t}\n', '\n', '\tfunction mintIncentive() public {\n', '\t\tif (incentivePerTokenPerAnnum == 0) return;\n', '\t\tuint amountToMint = this.toMint();\n', '\t\tif (amountToMint == 0) return;\n', '\t\tlastMintTime = block.timestamp;\n', '\t\tADXToken.supplyController().mint(address(ADXToken), address(this), amountToMint);\n', '\t}\n', '\n', '\tfunction enter(uint256 amount) external {\n', '\t\t// Please note that minting has to be in the beginning so that we take it into account\n', '\t\t// when using ADXToken.balanceOf()\n', "\t\t// Minting makes an external call but it's to a trusted contract (ADXToken)\n", '\t\tmintIncentive();\n', '\n', '\t\tuint totalADX = ADXToken.balanceOf(address(this));\n', "\t\trequire(totalADX.add(amount) <= maxTotalADX, 'REACHED_MAX_TOTAL_ADX');\n", '\n', '\t\t// The totalADX == 0 check here should be redudnant; the only way to get totalSupply to a nonzero val is by adding ADX\n', '\t\tif (totalSupply == 0 || totalADX == 0) {\n', '\t\t\tinnerMint(msg.sender, amount);\n', '\t\t} else {\n', '\t\t\tuint256 newShares = amount.mul(totalSupply).div(totalADX);\n', '\t\t\tinnerMint(msg.sender, newShares);\n', '\t\t}\n', '\t\trequire(ADXToken.transferFrom(msg.sender, address(this), amount));\n', '\t}\n', '\n', '\tfunction leaveInner(uint256 shares) internal {\n', '\t\tuint256 totalADX = ADXToken.balanceOf(address(this));\n', '\t\tuint256 adxAmount = shares.mul(totalADX).div(totalSupply);\n', '\t\tinnerBurn(msg.sender, shares);\n', '\t\trequire(ADXToken.transfer(msg.sender, adxAmount));\n', '\t}\n', '\n', '\tfunction leave(uint256 shares) external {\n', '\t\tmintIncentive();\n', '\t\tleaveInner(shares);\n', '\t}\n', '\n', '\t// Guarantees ADX can be taken out even if minting is failing\n', '\tfunction emergencyLeave(uint256 shares) external {\n', '\t\tleaveInner(shares);\n', '\t}\n', '}']