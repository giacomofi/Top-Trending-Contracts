['/*\n', '*******\n', '*******\n', '\n', '\n', '██████╗ ██╗  ██╗ ██████╗ ███████╗███╗   ██╗██╗██╗  ██╗████████╗██╗ ██████╗ ███████╗██████╗ \n', '██╔══██╗██║  ██║██╔═══██╗██╔════╝████╗  ██║██║╚██╗██╔╝╚══██╔══╝██║██╔════╝ ██╔════╝██╔══██╗\n', '██████╔╝███████║██║   ██║█████╗  ██╔██╗ ██║██║ ╚███╔╝    ██║   ██║██║  ███╗█████╗  ██████╔╝\n', '██╔═══╝ ██╔══██║██║   ██║██╔══╝  ██║╚██╗██║██║ ██╔██╗    ██║   ██║██║   ██║██╔══╝  ██╔══██╗\n', '██║     ██║  ██║╚██████╔╝███████╗██║ ╚████║██║██╔╝ ██╗   ██║   ██║╚██████╔╝███████╗██║  ██║\n', '╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═╝  ╚═══╝╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝\n', '                                                                                           \n', 'copyright@2020 PHOENIXTIGER.IO\n', '\n', '-Developed by Kryptual Team\n', '\n', '****                                                          \n', '*/\n', '\n', 'pragma solidity >=0.4.23 <0.6.0;\n', '\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    /**\n', '      * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '      * account.\n', '      */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '      * @dev Throws if called by any account other than the owner.\n', '      */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic {\n', '    uint public _totalSupply;\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address who) public constant returns (uint);\n', '    function transfer(address to, uint value) public;\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public constant returns (uint);\n', '    function transferFrom(address from, address to, uint value) public;\n', '    function approve(address spender, uint value) public;\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is Ownable, ERC20Basic {\n', '    using SafeMath for uint;\n', '\n', '    mapping(address => uint) public balances;\n', '\n', '    // additional variables for use if transaction fees ever became necessary\n', '    uint public basisPointsRate = 0;\n', '    uint public maximumFee = 0;\n', '\n', '    /**\n', '    * @dev Fix for the ERC20 short address attack.\n', '    */\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(!(msg.data.length < size + 4));\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev transfer token for a specified address\n', '    * @param _to The address to transfer to.\n', '    * @param _value The amount to be transferred.\n', '    */\n', '    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n', '        uint fee = (_value.mul(basisPointsRate)).div(10000);\n', '        if (fee > maximumFee) {\n', '            fee = maximumFee;\n', '        }\n', '        uint sendAmount = _value.sub(fee);\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(sendAmount);\n', '        if (fee > 0) {\n', '            balances[owner] = balances[owner].add(fee);\n', '            Transfer(msg.sender, owner, fee);\n', '        }\n', '        Transfer(msg.sender, _to, sendAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param _owner The address to query the the balance of.\n', '    * @return An uint representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address _owner) public constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based oncode by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\n', '    mapping (address => mapping (address => uint)) public allowed;\n', '\n', '    uint public constant MAX_UINT = 2**256 - 1;\n', '\n', '    /**\n', '    * @dev Transfer tokens from one address to another\n', '    * @param _from address The address which you want to send tokens from\n', '    * @param _to address The address which you want to transfer to\n', '    * @param _value uint the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {\n', '        var _allowance = allowed[_from][msg.sender];\n', '\n', '        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '        // if (_value > _allowance) throw;\n', '\n', '        uint fee = (_value.mul(basisPointsRate)).div(10000);\n', '        if (fee > maximumFee) {\n', '            fee = maximumFee;\n', '        }\n', '        if (_allowance < MAX_UINT) {\n', '            allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        }\n', '        uint sendAmount = _value.sub(fee);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(sendAmount);\n', '        if (fee > 0) {\n', '            balances[owner] = balances[owner].add(fee);\n', '            Transfer(_from, owner, fee);\n', '        }\n', '        Transfer(_from, _to, sendAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    /**\n', '    * @dev Function to check the amount of tokens than an owner allowed to a spender.\n', '    * @param _owner address The address which owns the funds.\n', '    * @param _spender address The address which will spend the funds.\n', '    * @return A uint specifying the amount of tokens still available for the spender.\n', '    */\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', 'contract BlackList is Ownable, BasicToken {\n', '\n', '    /////// Getters to allow the same blacklist to be used also by other contracts (including upgraded Tether) ///////\n', '    function getBlackListStatus(address _maker) external constant returns (bool) {\n', '        return isBlackListed[_maker];\n', '    }\n', '\n', '    function getOwner() external constant returns (address) {\n', '        return owner;\n', '    }\n', '\n', '    mapping (address => bool) public isBlackListed;\n', '\n', '    function addBlackList (address _evilUser) public onlyOwner {\n', '        isBlackListed[_evilUser] = true;\n', '        AddedBlackList(_evilUser);\n', '    }\n', '\n', '    function removeBlackList (address _clearedUser) public onlyOwner {\n', '        isBlackListed[_clearedUser] = false;\n', '        RemovedBlackList(_clearedUser);\n', '    }\n', '\n', '    function destroyBlackFunds (address _blackListedUser) public onlyOwner {\n', '        require(isBlackListed[_blackListedUser]);\n', '        uint dirtyFunds = balanceOf(_blackListedUser);\n', '        balances[_blackListedUser] = 0;\n', '        _totalSupply -= dirtyFunds;\n', '        DestroyedBlackFunds(_blackListedUser, dirtyFunds);\n', '    }\n', '\n', '    event DestroyedBlackFunds(address _blackListedUser, uint _balance);\n', '\n', '    event AddedBlackList(address _user);\n', '\n', '    event RemovedBlackList(address _user);\n', '\n', '}\n', '\n', 'contract UpgradedStandardToken is StandardToken{\n', '    // those methods are called by the legacy contract\n', '    // and they must ensure msg.sender to be the contract address\n', '    function transferByLegacy(address from, address to, uint value) public;\n', '    function transferFromByLegacy(address sender, address from, address spender, uint value) public;\n', '    function approveByLegacy(address from, address spender, uint value) public;\n', '}\n', '\n', 'contract TetherToken is Pausable, StandardToken, BlackList {\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint public decimals;\n', '    address public upgradedAddress;\n', '    bool public deprecated;\n', '\n', '    //  The contract can be initialized with a number of tokens\n', '    //  All the tokens are deposited to the owner address\n', '    //\n', '    // @param _balance Initial supply of the contract\n', '    // @param _name Token Name\n', '    // @param _symbol Token symbol\n', '    // @param _decimals Token decimals\n', '    function TetherToken(uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n', '        _totalSupply = _initialSupply;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        balances[owner] = _initialSupply;\n', '        deprecated = false;\n', '    }\n', '\n', '    // Forward ERC20 methods to upgraded contract if this one is deprecated\n', '    function transfer(address _to, uint _value) public whenNotPaused {\n', '        require(!isBlackListed[msg.sender]);\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);\n', '        } else {\n', '            return super.transfer(_to, _value);\n', '        }\n', '    }\n', '\n', '    // Forward ERC20 methods to upgraded contract if this one is deprecated\n', '    function transferFrom(address _from, address _to, uint _value) public whenNotPaused {\n', '        require(!isBlackListed[_from]);\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);\n', '        } else {\n', '            return super.transferFrom(_from, _to, _value);\n', '        }\n', '    }\n', '\n', '    // Forward ERC20 methods to upgraded contract if this one is deprecated\n', '    function balanceOf(address who) public constant returns (uint) {\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).balanceOf(who);\n', '        } else {\n', '            return super.balanceOf(who);\n', '        }\n', '    }\n', '\n', '    // Forward ERC20 methods to upgraded contract if this one is deprecated\n', '    function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _value);\n', '        } else {\n', '            return super.approve(_spender, _value);\n', '        }\n', '    }\n', '\n', '    // Forward ERC20 methods to upgraded contract if this one is deprecated\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '        if (deprecated) {\n', '            return StandardToken(upgradedAddress).allowance(_owner, _spender);\n', '        } else {\n', '            return super.allowance(_owner, _spender);\n', '        }\n', '    }\n', '\n', '    // deprecate current contract in favour of a new one\n', '    function deprecate(address _upgradedAddress) public onlyOwner {\n', '        deprecated = true;\n', '        upgradedAddress = _upgradedAddress;\n', '        Deprecate(_upgradedAddress);\n', '    }\n', '\n', '    // deprecate current contract if favour of a new one\n', '    function totalSupply() public constant returns (uint) {\n', '        if (deprecated) {\n', '            return StandardToken(upgradedAddress).totalSupply();\n', '        } else {\n', '            return _totalSupply;\n', '        }\n', '    }\n', '\n', '    // Issue a new amount of tokens\n', '    // these tokens are deposited into the owner address\n', '    //\n', '    // @param _amount Number of tokens to be issued\n', '    function issue(uint amount) public onlyOwner {\n', '        require(_totalSupply + amount > _totalSupply);\n', '        require(balances[owner] + amount > balances[owner]);\n', '\n', '        balances[owner] += amount;\n', '        _totalSupply += amount;\n', '        Issue(amount);\n', '    }\n', '\n', '    // Redeem tokens.\n', '    // These tokens are withdrawn from the owner address\n', '    // if the balance must be enough to cover the redeem\n', '    // or the call will fail.\n', '    // @param _amount Number of tokens to be issued\n', '    function redeem(uint amount) public onlyOwner {\n', '        require(_totalSupply >= amount);\n', '        require(balances[owner] >= amount);\n', '\n', '        _totalSupply -= amount;\n', '        balances[owner] -= amount;\n', '        Redeem(amount);\n', '    }\n', '\n', '    function setParams(uint newBasisPoints, uint newMaxFee) public onlyOwner {\n', '        // Ensure transparency by hardcoding limit beyond which fees can never be added\n', '        require(newBasisPoints < 20);\n', '        require(newMaxFee < 50);\n', '\n', '        basisPointsRate = newBasisPoints;\n', '        maximumFee = newMaxFee.mul(10**decimals);\n', '\n', '        Params(basisPointsRate, maximumFee);\n', '    }\n', '\n', '    // Called when new token are issued\n', '    event Issue(uint amount);\n', '\n', '    // Called when tokens are redeemed\n', '    event Redeem(uint amount);\n', '\n', '    // Called when contract is deprecated\n', '    event Deprecate(address newAddress);\n', '\n', '    // Called if contract ever adds fees\n', '    event Params(uint feeBasisPoints, uint maxFee);\n', '}\n', '\n', '\n', '\n', 'contract PhoenixTiger {\n', '    TetherToken tether;\n', '    \n', '    /*-----------Public Variables---------------\n', '    -----------------------------------*/\n', '    address public owner;\n', '    uint public totalGpv;\n', '    uint[6] private poolEli = [uint(100000000000), 1000000000000, 250000000000, 100000000000, 100000000000, 1000000000000];\n', '    //poolEli[6] : 0 - orgEli; 1 - millEli; 2- gloEli; 3- countEli; 4 - orgDownEli; 5 - millDownEli \n', '    \n', '    /*-----------Private Varibales---------------\n', '    -----------------------------------*/\n', '    uint private total_packs = 11;\n', '    uint private totalcountry = 200;\n', '    uint private countrycommissionprice = 2;\n', '    uint private gloComPrice = 1;\n', '    uint private milComPrice = 1;\n', '    uint private orgComPrice = 1;\n', '    address private expenseAddress;\n', '    address[] private orgPool;\n', '    address[] private milPool;\n', '    address[] private gloPool; \n', '    /*-----------Mapping---------------\n', '    -----------------------------------*/\n', '    mapping(address => bool) public nonEcoUser;\n', '    mapping(address => User) public users;\n', '    mapping(address => bool) public userExist;\n', '    mapping(uint => uint) public totalCountryGpv;\n', '    mapping(address => uint[]) private userPackages;\n', '    mapping(uint=>address[]) private countrypool;\n', '    mapping(uint=>address[]) private countEliPool;\n', '    mapping(address => bool) public orgpool;\n', '    mapping(address=> bool) public millpool;\n', '    mapping(address => bool) public globalpool;\n', '    mapping(address=>address[]) public userDownlink;\n', '    mapping(address => bool) public isRegistrar;\n', '    mapping(address=> uint) public userLockTime;\n', '    mapping(address =>bool) public isCountryEli;    \n', '    \n', '    /*-----------Arrays--------------\n', '    -----------------------------------0x0000000000000000000000000000000000000000*/\n', '    \n', '    uint[12] public Packs;\n', '    \n', '    \n', '    /*-----------enums---------------\n', '    -----------------------------------*/\n', '    enum Status {CREATED, ACTIVE}\n', '\n', '    /*----------Modifier-------------\n', '    -----------------------------------*/\n', '    modifier onlyOwner(){\n', '      require(msg.sender == owner,"only owner");\n', '      _;\n', '    }\n', '\n', '    /*-----------Structures---------------\n', '    -----------------------------------*/\n', '    struct User {\n', '        uint countrycode;\n', '        uint pbalance;\n', '        uint rbalance;\n', '        uint rank;\n', '        uint gHeight;\n', '        uint gpv;\n', '        uint[2] lastBuy;   //0- time ; 1- pack;\n', '        uint[7] earnings;  // 0 - team earnings; 1 - family earnings; 2 - match earnings; 3 - country earnings, 4- organisation, 5 - global, 6 - millionaire\n', '        bool isbonus;\n', '        bool isKyc;\n', '        address teamaddress;\n', '        address familyaddress;\n', '        Status status;\n', '        uint traininglevel;\n', '        mapping(uint=>TrainingLevel) trainingpackage;\n', '    }\n', '    \n', '    struct TrainingLevel {\n', '        uint package;\n', '        bool purchased;\n', '\n', '    }\n', '    /*-----------EVENTS---------------\n', '    -----------------------------------*/\n', '    event Registration(\n', '                \n', '                address useraddress,\n', '                uint countrycode,\n', '                uint gHeight,\n', '                address teamaddress,\n', '                address familyaddress\n', '    );\n', '\n', '    event newPackage (\n', '                address useraddress,\n', '                uint pack\n', '            );\n', '\n', '    event RaiseTrainingLevel(\n', '            \n', '                address useraddress,\n', '                uint tlevel,\n', '                uint rank\n', '            );\n', '\n', '    event RedeemEarning(\n', '            \n', '                address useraddress,\n', '                uint pbalance,\n', '                uint rbalance\n', '            );\n', '            \n', '    event LockTimeUpdate(\n', '                address useraddress,\n', '                uint locktime\n', '            );\n', ' \n', '    event KycDone(\n', '                address useraddress\n', '            );\n', '            \n', '    /*-----------Constructor---------------\n', '    -----------------------------------*/\n', '\n', '    constructor(address ownerAddress,address _expenseAddress) public {\n', '\n', '        tether = TetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n', '        Packs = [0,500, 1000, 2000, 5000, 10000, 20000,50000,100000,250000, 500000, 1000000];\n', '\n', '        owner = ownerAddress;\n', '        expenseAddress = _expenseAddress;\n', '        isRegistrar[owner] = true;\n', '  \n', '        address master = 0x3417F6448eeDbf8737af2cef9Ca2d2dd2Ee3d543;\n', '        \n', '        userExist[master] = true;\n', '        User memory user;\n', '        user= User({\n', '            \n', '            teamaddress : address(0),\n', '            countrycode: 192,\n', '            isbonus : false,\n', '            familyaddress : address(0),\n', '            pbalance: 0,\n', '            rbalance : 0,\n', '            rank : 0,\n', '            gHeight: 1,\n', '            status : Status.ACTIVE,\n', '            traininglevel : 0,\n', '            gpv : 0,\n', '            isKyc:false,\n', '            lastBuy:[uint(0),0],\n', '            earnings:[uint(0),0,0,0,0,0,0]\n', '        });\n', '        nonEcoUser[master] = true;\n', '        users[master] = user; //Master\n', '\n', '\n', '    }\n', '\n', '    /*-----------Main functions---------------\n', '    -------------------------------------------*/\n', '    \n', '    function superRegister(address useraddress,address referrerAddress,uint usercountry,uint pack, uint rbal, uint gbv, uint[7] userEarnings, uint[2] lastBuy) public onlyOwner {\n', '        require(!isUserExists(useraddress) && isUserExists(referrerAddress), "user exists");\n', '        require(checkCountry(usercountry), "country must be from 0 to 200");\n', '        require(isAddress(useraddress), "cannot be a contract");\n', '        totalCountryGpv[usercountry] += Packs[pack]*1000000;\n', '        totalGpv += Packs[pack]*1000000;\n', '       \n', '        userExist[useraddress] = true;\n', '        nonEcoUser[useraddress] = true;\n', '        User memory user = User({\n', '            teamaddress : referrerAddress,\n', '            countrycode: usercountry,\n', '            isbonus : true,\n', '            familyaddress : getFamilyFromReferral(referrerAddress),\n', '            pbalance: 0,\n', '            rbalance : rbal,\n', '            rank : pack,\n', '            gHeight: users[referrerAddress].gHeight+1,\n', '            status : Status.ACTIVE,\n', '            gpv : gbv,\n', '            isKyc : false,\n', '            lastBuy:[uint(lastBuy[0]),lastBuy[1]],\n', '            traininglevel :0,\n', '            earnings: [uint(userEarnings[0]),userEarnings[1],userEarnings[2],userEarnings[3],userEarnings[4],userEarnings[5],userEarnings[6]]\n', '        });\n', '        \n', '        if(lastBuy[1]==0){\n', '            users[useraddress].status = Status.CREATED;\n', '            users[useraddress].isbonus = false;\n', '        }\n', '        \n', '        isCountryEli[useraddress] = false;\n', '        globalpool[useraddress] = false;\n', '        millpool[useraddress] = false;\n', '        orgpool[useraddress] = false;\n', '        \n', '        users[useraddress].trainingpackage[pack].package=pack;\n', '        users[useraddress].traininglevel=0;\n', '        users[useraddress].trainingpackage[pack].purchased=true;     \n', '      \n', '        userLockTime[useraddress] = 0;\n', '        userPackages[useraddress].push(pack);\n', '        countrypool[usercountry].push(useraddress);\n', '        users[useraddress] = user;\n', '        userDownlink[referrerAddress].push(useraddress);\n', '        \n', '        /*-------------------Emitter--------------*/\n', '        emit Registration(\n', '            useraddress,\n', '            users[useraddress].gHeight,\n', '            users[useraddress].countrycode,\n', '            users[useraddress].teamaddress,\n', '            users[useraddress].familyaddress\n', '        );        \n', '    }\n', '    \n', '    function registration(address useraddress, address referrerAddress, uint usercountry,uint locktime) external {\n', '        require(!isUserExists(useraddress) && isUserExists(referrerAddress), "user exists");\n', '        require(msg.sender == useraddress);\n', '        require(referrerAddress != address(0),"referrerAddress cannot be zero address");\n', '        require(checkCountry(usercountry), "country must be from 0 to 200");\n', '        require(isAddress(useraddress) && isAddress(referrerAddress), "cannot be a contract");\n', '        \n', '        address teamaddress = referrerAddress;\n', '    \n', '        userExist[useraddress] = true;\n', '        User memory user = User({\n', '            \n', '            teamaddress : teamaddress,\n', '            // packlevel : 0,\n', '            countrycode: usercountry,\n', '            isbonus : false,\n', '            familyaddress : getFamilyFromReferral(teamaddress),\n', '            pbalance: 0,\n', '            rbalance : 0,\n', '            rank : 0,\n', '            gHeight: getHeight(teamaddress),\n', '            status : Status.CREATED,\n', '            gpv :0,\n', '            isKyc : false,\n', '            lastBuy:[uint(0),0],\n', '            traininglevel :0,\n', '            earnings:[uint(0),0,0,0,0,0,0]\n', '        });\n', '        \n', '        userLockTime[useraddress] = locktime;\n', '        \n', '        countrypool[usercountry].push(useraddress);\n', '\n', '        userDownlink[teamaddress].push(useraddress);\n', '        users[useraddress] = user;\n', '\n', '        /*-------------------Emitter--------------*/\n', '        emit Registration(\n', '            useraddress,\n', '            users[useraddress].gHeight,\n', '            users[useraddress].countrycode,\n', '            users[useraddress].teamaddress,\n', '            users[useraddress].familyaddress\n', '        );\n', '\n', '    }\n', '\n', '    function buypackage( uint pack ,uint amount) external {\n', '        \n', '        uint _amount = amount/1000000;\n', '        require(isUserExists(msg.sender), "user not exists");\n', '        require(pack > users[msg.sender].lastBuy[1] && pack < total_packs && pack>0, "check pack purchase");\n', '        require(Packs[pack]<= _amount, "invalid amount of wholesale package purchase");\n', '        require(tether.allowance(msg.sender,address(this)) >= amount,"set allowance");\n', '        \n', '        if(discountValid(msg.sender,pack)){\n', '            uint newAmount = (Packs[pack] - Packs[users[msg.sender].lastBuy[1]])*1000000;\n', '            tether.transferFrom(msg.sender,address(this),newAmount); \n', '            disburse(msg.sender, newAmount, pack);            \n', '        }else{\n', '            tether.transferFrom(msg.sender,address(this),amount); \n', '            disburse(msg.sender, amount, pack);\n', '        }\n', '        \n', '        userPackages[msg.sender].push(pack);\n', '        users[msg.sender].lastBuy = [now,pack];\n', '    }\n', '    \n', '    function raiseTrainingLevel(address [] useraddress, uint[] pack) external  payable {\n', '        require(isRegistrar[msg.sender],"Not a registrar");\n', '        require(useraddress.length == pack.length,"useraddress length not equal to packs length");\n', '       for(uint i=0;i<useraddress.length;i++){\n', '        require(isUserExists(useraddress[i]), "user not exists");\n', '        require(total_packs >= pack[i], "invalid pack");\n', '\n', '        require(users[useraddress[i]].trainingpackage[pack[i]].purchased, "Pack is not purchased.");\n', '        users[useraddress[i]].isbonus = true;\n', '        users[useraddress[i]].traininglevel= ++users[useraddress[i]].traininglevel;\n', '\n', '        emit RaiseTrainingLevel(\n', '            \n', '            useraddress[i],\n', '            users[useraddress[i]].traininglevel,\n', '            users[useraddress[i]].rank\n', '        );   \n', '       }\n', '    }\n', '\n', '    function redeemEarning(address useraddress) public{\n', '        require(isUserExists(useraddress), "user not exists");\n', '        require(users[msg.sender].pbalance>0, "insufficient balance");\n', '        users[useraddress].pbalance = 0;\n', '        tether.transfer(useraddress,users[useraddress].pbalance);\n', '        users[useraddress].rbalance = users[useraddress].rbalance + users[useraddress].pbalance;\n', '\n', '        emit RedeemEarning(\n', '            useraddress,\n', '            users[useraddress].pbalance,\n', '            users[useraddress].rbalance\n', '        );\n', '    }\n', '\n', '    /*-----------non-payable functions---------------\n', '    -----------------------------------*/\n', '\n', '    function addRegistrar(address registrar) public onlyOwner{\n', '        isRegistrar[registrar] = true;\n', '    }\n', '    \n', '    function removeRegistrar(address registrar) public onlyOwner{\n', '        isRegistrar[registrar] = false;\n', '    } \n', '    \n', '    function updateLockTime(address useraddress ,uint locktime ) public{\n', '        require(useraddress==msg.sender);\n', '        require(locktime> 6,"must be greater than 6 months");\n', '        require(isUserExists(useraddress),"user not exist");\n', '        userLockTime[useraddress] = locktime;\n', '        \n', '        emit LockTimeUpdate(\n', '            useraddress, \n', '            locktime\n', '        );\n', '    }\n', '    \n', '    function discountValid(address useraddress,uint pack) public view returns(bool _bool){\n', '       uint  _lastPack =  users[useraddress].lastBuy[1] ;\n', '       uint  _lastTime =  users[useraddress].lastBuy[0];\n', '       \n', '       if(_lastPack==0 || pack<= _lastPack || now - _lastTime >= 30 days){\n', '           return false;\n', '       }else{\n', '           return true;\n', '       }\n', '    }\n', '    \n', '    function getEarnings(address useraddress) public view returns(uint[7] memory _earnings){\n', '        return users[useraddress].earnings;\n', '    }\n', '    \n', '    function getLastBuyPack(address useraddress) public view returns(uint[2] memory _lastpack){\n', '        return users[useraddress].lastBuy;\n', '    }\n', '    \n', '    function getCountryUsersCount(uint country) public view returns (uint count){\n', '        return countrypool[country].length;\n', '    }\n', '\n', '    function getTrainingLevel(address useraddress, uint pack) public view returns (uint tlevel, uint upack) {\n', '        return (users[useraddress].traininglevel, pack);\n', '\n', '    }\n', '\n', '    function getUserDownLink(address useraddress) public view  returns (address[] memory addr) {\n', '        if(userDownlink[useraddress].length != 0){\n', '            return userDownlink[useraddress];\n', '        }\n', '        else{\n', '            address[] memory pack;\n', '            return pack ;\n', '        }\n', '    }\n', '\n', '    /*-----------Helper functions---------------\n', '    -----------------------------------*/\n', '    \n', '    function getAllPacksofUsers(address useraddress) public view returns(uint[] memory pck) {\n', '        return userPackages[useraddress];\n', '    }\n', '\n', '    function getAllLevelsofUsers(address useraddress,uint pack) public view returns(uint lvl) {\n', '        \n', '        if(users[useraddress].trainingpackage[pack].purchased){\n', '            return users[useraddress].traininglevel;\n', '        }\n', '        \n', '        return 0;\n', '    }\n', '\n', '    function isAddress(address _address) private view returns (bool value){\n', '        uint32 size;\n', '        assembly {\n', '                size := extcodesize(_address)\n', '        }\n', '        return(size==0);\n', '    }\n', '\n', '    function isUserExists(address user) public view returns (bool) {\n', '        return userExist[user];\n', '    }\n', '\n', '    function checkCountry(uint country) private pure returns (bool) {\n', '        return (country <= 200);\n', '    }\n', '\n', '    function getFamilyFromReferral(address referrerAddres) private view returns (address addr) {\n', '        if (users[referrerAddres].teamaddress != address(0)){\n', '            return users[referrerAddres].teamaddress;\n', '        }\n', '        else {\n', '            return address(0);\n', '        }\n', '    }\n', '\n', '    function getFamilyFromUser(address useraddress) private view returns (address addr) {\n', '        if (users[users[useraddress].teamaddress].teamaddress != address(0)){\n', '            return users[users[useraddress].teamaddress].teamaddress;\n', '        }\n', '        else {\n', '            return address(0);\n', '        }\n', '    }\n', '\n', '    function getTeam(address useraddress) private view returns (address addr) {\n', '        return users[useraddress].teamaddress;\n', '    }\n', '\n', '    function getGminus2(address useraddress) private view returns (address gaddr) {\n', '\n', '        if(users[useraddress].teamaddress == address(0)){\n', '            return address(0);\n', '        }\n', '        else{\n', '            return users[users[useraddress].teamaddress].familyaddress;\n', '        }\n', '    }\n', '    \n', '    function getHeight(address referrerAddres) private view returns (uint ghgt) {\n', '        return users[referrerAddres].gHeight +1;\n', '    }\n', '\n', '    function disburse(address useraddress, uint amount, uint pack) private {\n', '\n', '      uint leftamount;\n', '      uint disbursedamount;\n', '\n', '      //disburse 10% to the team\n', '      disbursedamount = disburseTeam(useraddress, amount);\n', '      leftamount = amount - disbursedamount;\n', '\n', '      //disburse 3% to family\n', '      disbursedamount = disburseFamily(useraddress,  amount);\n', '      leftamount = leftamount - disbursedamount;\n', '\n', '\n', '      //disbruse 4% to match and +1% +2% +3% to higher rank users\n', '      disbursedamount = disburseMatch(useraddress,amount);\n', '      leftamount = leftamount - disbursedamount;\n', '\n', '      //disburse 2% to country\n', '      disbursedamount = disburseCountryPool(useraddress, amount);\n', '      leftamount = leftamount - disbursedamount;\n', '\n', '      //disburse 1% to Global\n', '      disbursedamount = disburseOMGPool(useraddress, amount);\n', '      leftamount = leftamount - disbursedamount;\n', '      \n', '      payoutGpv(useraddress,amount);\n', '      tether.transfer(expenseAddress,leftamount);\n', '      /* address(uint160(owner)).transfer(leftamount); */\n', '    \n', '      users[useraddress].status = Status.ACTIVE;\n', '      // users[msg.sender].packlevel = pack;\n', '      users[useraddress].rank = pack;\n', '      //users[msg.sender].trainingpackage[0].traininglevel[pack]=0;\n', '\n', '      users[useraddress].trainingpackage[pack].package=pack;\n', '      users[useraddress].traininglevel=0;\n', '      users[useraddress].trainingpackage[pack].purchased=true;     \n', '      emit newPackage (\n', '          msg.sender,\n', '          pack\n', '      );\n', '    }\n', '\n', '    function disburseTeam(address useraddress, uint amount) private  returns (uint amnt) {\n', '        address teamaddress = getTeam(useraddress);\n', '        if(teamaddress == address(0)){\n', '            return 0;\n', '        }\n', '        else if(users[teamaddress].status == Status.CREATED) {\n', '            return amount;\n', '        }\n', '        else{\n', '            users[teamaddress].pbalance = users[teamaddress].pbalance+ (amount * 10)/100;\n', '            users[teamaddress].earnings[0] += (amount * 10)/100;\n', '            // gpvUpdater(useraddress,teamaddress);\n', '            return (amount * 10)/100;\n', '        }\n', '    }\n', '\n', '    function disburseFamily(address useraddress, uint amount) private  returns (uint amnt) {\n', '        address familyaddress = getFamilyFromUser(useraddress);\n', '        if(familyaddress != address(0)){\n', '            if(users[familyaddress].status == Status.CREATED){\n', '                return 0;\n', '            }\n', '            else{\n', '                users[familyaddress].pbalance = users[familyaddress].pbalance+ (amount * 30)/1000;\n', '                users[familyaddress].earnings[1] += (amount * 30)/1000;\n', '                \n', '                return (amount * 30)/1000;\n', '            }\n', '        }\n', '        else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function disburseMatch(address useraddress, uint amount) private  returns (uint amnt) {\n', '        \n', '        address familyaddress = getFamilyFromUser(useraddress);\n', '        if(familyaddress != address(0)){\n', '            users[familyaddress].earnings[2] += (amount * 4)/1000;\n', '        }else{\n', '            return 0;\n', '        }\n', '\n', '        address teamaddress = getTeam(familyaddress);\n', '        if(teamaddress != address(0)){\n', '            users[teamaddress].earnings[2] += (amount * 136)/100000;\n', '            amount = (amount * 136)/100000;\n', '        }else{\n', '            return 0;\n', '        }\n', '\n', '        address matchaddress = getGminus2(useraddress);\n', '        \n', '        uint commissionamount;\n', '        uint disbursed ;\n', '        \n', '        uint gold_due;\n', '        uint diamond_due;\n', '        uint plat_due;\n', '        \n', '        if(matchaddress==address(0)){\n', '            return 0;\n', '        }\n', '        else{\n', '            while(matchaddress != address(0)){\n', '\n', '                if(users[matchaddress].status == Status.CREATED){\n', '                    matchaddress = users[matchaddress].teamaddress;\n', '                    return disbursed;\n', '                }\n', '                else{\n', '                    \n', '                    commissionamount = (amount *4 )/100; //comission = 4%\n', '                    \n', '                    gold_due = gold_due +commissionamount;\n', '                    diamond_due = diamond_due + commissionamount;\n', '                    plat_due = plat_due + commissionamount;\n', '                    \n', '                    if( users[useraddress].trainingpackage[11].purchased){//PlatinumFounder\n', '                        commissionamount += (plat_due*3)/100;\n', '                        \n', '                        plat_due = 0;\n', '                       \n', '                    }\n', '                    else if( users[useraddress].trainingpackage[10].purchased){//DiamondFounder\n', '                        commissionamount += (diamond_due*2)/100;\n', '                        \n', '                        diamond_due = 0;\n', '                      \n', '                    }\n', '                    else if( users[useraddress].trainingpackage[9].purchased ){  // Gold-founder\n', '                        commissionamount += (gold_due)/100;\n', '                        \n', '                        gold_due = 0;\n', '                        \n', '                    }\n', '                 \n', '                    users[matchaddress].pbalance = users[matchaddress].pbalance+ commissionamount;\n', '                    users[matchaddress].earnings[2] += commissionamount;\n', '                    matchaddress = users[matchaddress].teamaddress;\n', '                    amount = commissionamount;\n', '                    disbursed = disbursed + amount;\n', '                }\n', '            }\n', '            return disbursed;\n', '        }\n', '    }\n', '\n', '    function disburseCountryPool(address useraddress, uint amount) private  returns (uint amnt) {\n', '        uint country = users[useraddress].countrycode;\n', '        uint disbursed;\n', '\n', '        for(uint i=0; i < countEliPool[country].length && disbursed <= ((amount*2)/100); i++){\n', '                uint gpv = users[countEliPool[country][i]].gpv;\n', '\t\t\t\tuint countDisbursed = (amount * countrycommissionprice*gpv)/(100*totalCountryGpv[users[useraddress].countrycode]);\n', '                users[countEliPool[country][i]].pbalance = users[countEliPool[country][i]].pbalance + countDisbursed;\n', '                users[countEliPool[country][i]].earnings[3] += countDisbursed;\n', '                disbursed = disbursed + countDisbursed;\n', '            }\n', '        \n', '        return disbursed;\n', '    }\n', '\n', '    function disburseOMGPool(address useraddress, uint amount) private  returns (uint amnt) {\n', '        uint disbursed;\n', '\n', '    \tfor(uint i=orgPool.length ; i > 0 ; i--) {\n', '    \t    uint gpvOrg = users[orgPool[i]].gpv;\n', '    \t    users[orgPool[i]].earnings[4] += (amount * orgComPrice *gpvOrg)/(100*totalGpv);\n', '    \t    users[orgPool[i]].pbalance += (amount * orgComPrice *gpvOrg)/(100*totalGpv);\n', '            disbursed += (amount * orgComPrice *gpvOrg)/(100*totalGpv);\n', '    \t}\n', '    \n', '    \tfor( i=milPool.length ; i > 0 ; i--) {\n', '    \t    uint gpvMill = users[milPool[i]].gpv;\n', '    \t    users[milPool[i]].earnings[4] += (amount * milComPrice *gpvMill)/(100*totalGpv);\n', '    \t    users[milPool[i]].pbalance = (amount * milComPrice *gpvMill)/(100*totalGpv);\n', '            disbursed += (amount * milComPrice *gpvMill)/(100*totalGpv);\n', '    \t}\n', '    \n', '    \tfor(i=gloPool.length ; i > 0 ; i--) {\n', '    \t    uint gpvGlo = users[gloPool[i]].gpv;\n', '    \t    users[gloPool[i]].earnings[4] += (amount * gloComPrice *gpvGlo)/(100*totalGpv);\n', '    \t    users[gloPool[i]].pbalance = (amount * gloComPrice *gpvGlo)/(100*totalGpv);\n', '            disbursed += (amount * gloComPrice *gpvGlo)/(100*totalGpv);\n', '    \t}\n', '\n', '\t    return disbursed;\n', '    }\n', '\n', '    function checkPackPurchased(address useraddress, uint pack) public view returns (uint userpack, uint usertraininglevel, bool packpurchased){\n', '        if(users[useraddress].trainingpackage[pack].purchased){\n', '            return (pack, users[useraddress].traininglevel, users[useraddress].trainingpackage[pack].purchased);\n', '        }\n', '    }\n', '\n', '    function payoutGpv(address useraddress,uint amount) private{\n', '\n', '        totalGpv = totalGpv + (amount*(users[useraddress].gHeight-1));  \n', '        totalCountryGpv[users[useraddress].countrycode] = totalCountryGpv[users[useraddress].countrycode] + (amount*users[useraddress].gHeight-1);\n', '        address _Address = users[useraddress].teamaddress;\n', '        for(uint i = users[useraddress].gHeight-1 ; i>0 ;i--){\n', '            users[_Address].gpv += amount;\n', '            _Address = users[_Address].teamaddress;\n', '            \n', '            if(users[_Address].gpv > poolEli[0]  && !orgpool[_Address] && checkEligible(_Address,poolEli[4])){\n', '                orgpool[_Address] = true;\n', '\t\t        orgPool.push(_Address);\n', '            }\n', '            if(users[_Address].gpv > poolEli[1] && !millpool[_Address] && checkEligible(_Address,poolEli[5])){\n', '                millpool[_Address] = true;\n', '\t\t        milPool.push(_Address);\n', '            }\n', '            if(users[_Address].gpv > poolEli[2] && !globalpool[_Address]){\n', '                globalpool[_Address] = true;\n', '\t\t        milPool.push(_Address);\n', '            }\n', '            if(users[_Address].gpv > poolEli[3] && !isCountryEli[_Address] && users[_Address].isKyc == true){\n', '                isCountryEli[_Address] =true;\n', '\t\t        countEliPool[users[useraddress].countrycode].push(_Address);\n', '\n', '            }\n', '         }\n', '    }\n', '    \n', '    function checkEligible(address useraddress,uint amount) private view returns(bool){\n', '        uint a = 0 ;\n', '        address [] memory _addresses = getUserDownLink(useraddress);\n', '        if(_addresses.length < 5){\n', '                return false;\n', '        }\n', '        for(uint i =0;i< _addresses.length;i++){\n', '            if(users[_addresses[i]].gpv > amount){\n', '                a += 1;\n', '             }\n', '            if(a>=5){\n', '              return true;\n', '            }\n', '        }\n', '        return false;\n', '        \n', '    }\n', '    \n', '    function setKyc(address useraddress) public onlyOwner{\n', '        users[useraddress].isKyc = true;\n', '        \n', '        emit KycDone(\n', '            useraddress\n', '            );\n', '    } \n', '    \n', '    function updateEligibilty(uint _orgEli,uint _millEli,uint _gloEli,uint _countEli,uint _orgDownEli,uint _millDownEli ) public onlyOwner{\n', '        uint i;\n', '        uint j;\n', '        poolEli[5] = _millDownEli;\n', '        poolEli[4] = _orgDownEli;\n', '        gloPool.length = 0;\n', '        milPool.length = 0;\n', '        orgPool.length = 0; \n', '        if(poolEli[0] != _orgEli){\n', '           poolEli[0] = _orgEli;\n', '           for(  i= 0; i<totalcountry;i++){\n', '               for( j=0; j<countrypool[i].length; j++){\n', '                   orgpool[countrypool[i][j]] = false;\n', '                   if(checkEligible(countrypool[i][j],poolEli[0])){\n', '                       orgpool[countrypool[i][j]] = true;\n', '                       orgPool.push(countrypool[i][j]);\n', '                    } \n', '                }\n', '            }\n', '        }\n', '        if(poolEli[1] != _millEli){\n', '            poolEli[1] = _millEli;\n', '            for(  i= 0; i<totalcountry;i++){\n', '                for( j=0; j<countrypool[i].length; j++){\n', '                    millpool[countrypool[i][j]] = false;\n', '                    if(checkEligible(countrypool[i][j],poolEli[0])){\n', '                        millpool[countrypool[i][j]] = true;\n', '                        milPool.push(countrypool[i][j]);\n', '                    } \n', '                }\n', '            }\n', '        }     \n', '        if(poolEli[2] != _gloEli){\n', '            poolEli[2] = _gloEli;\n', '            for(  i= 0; i<totalcountry;i++){\n', '                for( j=0; j<countrypool[i].length; j++){\n', '                    globalpool[countrypool[i][j]] = false;\n', '                    if(users[countrypool[i][j]].gpv > poolEli[2]){\n', '                       globalpool[countrypool[i][j]] = true;\n', '                       gloPool.push(countrypool[i][j]);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        if(poolEli[3] != _countEli){\n', '            poolEli[3] = _countEli;\n', '            for(  i= 0; i<totalcountry;i++){\n', '                countEliPool[i].length = 0;\n', '                for( j=0; j<countrypool[i].length; j++){\n', '                    isCountryEli[countrypool[i][j]] = false;\n', '                    if(users[countrypool[i][j]].gpv > poolEli[3] && users[countrypool[i][j]].isKyc == true){\n', '                        isCountryEli[countrypool[i][j]] =true;\n', '                        countEliPool[users[countrypool[i][j]].countrycode].push(countrypool[i][j]);\n', '                    }               \n', '                }\n', '            }\n', '        }\n', '    }\n', '}']