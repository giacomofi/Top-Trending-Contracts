['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-01\n', '*/\n', '\n', '// File: contracts\\modules\\SafeMath.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'SafeMath: addition overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'SafeMath: substraction underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'SafeMath: multiplication overflow');\n", '    }\n', '}\n', '\n', '// File: contracts\\modules\\Ownable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Managerable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'contract Managerable is Ownable {\n', '\n', '    address private _managerAddress;\n', '    /**\n', '     * @dev modifier, Only manager can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyManager() {\n', '        require(_managerAddress == msg.sender,"Managerable: caller is not the Manager");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev set manager by owner. \n', '     *\n', '     */\n', '    function setManager(address managerAddress)\n', '    public\n', '    onlyOwner\n', '    {\n', '        _managerAddress = managerAddress;\n', '    }\n', '    /**\n', '     * @dev get manager address. \n', '     *\n', '     */\n', '    function getManager()public view returns (address) {\n', '        return _managerAddress;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Halt.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', 'contract Halt is Ownable {\n', '    \n', '    bool private halted = false; \n', '    \n', '    modifier notHalted() {\n', '        require(!halted,"This contract is halted");\n', '        _;\n', '    }\n', '\n', '    modifier isHalted() {\n', '        require(halted,"This contract is not halted");\n', '        _;\n', '    }\n', '    \n', '    /// @notice function Emergency situation that requires \n', '    /// @notice contribution period to stop or not.\n', '    function setHalt(bool halt) \n', '        public \n', '        onlyOwner\n', '    {\n', '        halted = halt;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\whiteList.sol\n', '\n', 'pragma solidity =0.5.16;\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible uint32.\n', '     */\n', 'library whiteListUint32 {\n', '    /**\n', '     * @dev add uint32 into white list.\n', '     * @param whiteList the storage whiteList.\n', '     * @param temp input value\n', '     */\n', '\n', '    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\n', '        if (!isEligibleUint32(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    /**\n', '     * @dev remove uint32 from whitelist.\n', '     */\n', '    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible uint256.\n', '     */\n', 'library whiteListUint256 {\n', '    // add whiteList\n', '    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\n', '        if (!isEligibleUint256(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible address.\n', '     */\n', 'library whiteListAddress {\n', '    // add whiteList\n', '    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\n', '        if (!isEligibleAddress(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\AddressWhiteList.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '    /**\n', '     * @dev Implementation of a whitelist filters a eligible address.\n', '     */\n', 'contract AddressWhiteList is Halt {\n', '\n', '    using whiteListAddress for address[];\n', '    uint256 constant internal allPermission = 0xffffffff;\n', '    uint256 constant internal allowBuyOptions = 1;\n', '    uint256 constant internal allowSellOptions = 1<<1;\n', '    uint256 constant internal allowExerciseOptions = 1<<2;\n', '    uint256 constant internal allowAddCollateral = 1<<3;\n', '    uint256 constant internal allowRedeemCollateral = 1<<4;\n', '    // The eligible adress list\n', '    address[] internal whiteList;\n', '    mapping(address => uint256) internal addressPermission;\n', '    /**\n', '     * @dev Implementation of add an eligible address into the whitelist.\n', '     * @param addAddress new eligible address.\n', '     */\n', '    function addWhiteList(address addAddress)public onlyOwner{\n', '        whiteList.addWhiteListAddress(addAddress);\n', '        addressPermission[addAddress] = allPermission;\n', '    }\n', '    function modifyPermission(address addAddress,uint256 permission)public onlyOwner{\n', '        addressPermission[addAddress] = permission;\n', '    }\n', '    /**\n', '     * @dev Implementation of revoke an invalid address from the whitelist.\n', '     * @param removeAddress revoked address.\n', '     */\n', '    function removeWhiteList(address removeAddress)public onlyOwner returns (bool){\n', '        addressPermission[removeAddress] = 0;\n', '        return whiteList.removeWhiteListAddress(removeAddress);\n', '    }\n', '    /**\n', '     * @dev Implementation of getting the eligible whitelist.\n', '     */\n', '    function getWhiteList()public view returns (address[] memory){\n', '        return whiteList;\n', '    }\n', '    /**\n', '     * @dev Implementation of testing whether the input address is eligible.\n', '     * @param tmpAddress input address for testing.\n', '     */    \n', '    function isEligibleAddress(address tmpAddress) public view returns (bool){\n', '        return whiteList.isEligibleAddress(tmpAddress);\n', '    }\n', '    function checkAddressPermission(address tmpAddress,uint256 state) public view returns (bool){\n', '        return  (addressPermission[tmpAddress]&state) == state;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\ReentrancyGuard.sol\n', '\n', 'pragma solidity =0.5.16;\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancyLock = false;\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancyLock);\n', '    reentrancyLock = true;\n', '    _;\n', '    reentrancyLock = false;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts\\FNXMinePool\\MinePoolData.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '/**\n', ' * @title FPTCoin mine pool, which manager contract is FPTCoin.\n', ' * @dev A smart-contract which distribute some mine coins by FPTCoin balance.\n', ' *\n', ' */\n', 'contract MinePoolData is Managerable,AddressWhiteList,ReentrancyGuard {\n', '    //Special decimals for calculation\n', '    uint256 constant calDecimals = 1e18;\n', "    // miner's balance\n", '    // map mineCoin => user => balance\n', '    mapping(address=>mapping(address=>uint256)) internal minerBalances;\n', "    // miner's origins, specially used for mine distribution\n", '    // map mineCoin => user => balance\n', '    mapping(address=>mapping(address=>uint256)) internal minerOrigins;\n', '    \n', '    // mine coins total worth, specially used for mine distribution\n', '    mapping(address=>uint256) internal totalMinedWorth;\n', '    // total distributed mine coin amount\n', '    mapping(address=>uint256) internal totalMinedCoin;\n', '    // latest time to settlement\n', '    mapping(address=>uint256) internal latestSettleTime;\n', '    //distributed mine amount\n', '    mapping(address=>uint256) internal mineAmount;\n', '    //distributed time interval\n', '    mapping(address=>uint256) internal mineInterval;\n', '    //distributed mine coin amount for buy options user.\n', '    mapping(address=>uint256) internal buyingMineMap;\n', "    // user's Opterator indicator \n", '    uint256 constant internal opBurnCoin = 1;\n', '    uint256 constant internal opMintCoin = 2;\n', '    uint256 constant internal opTransferCoin = 3;\n', '    /**\n', '     * @dev Emitted when `account` mint `amount` miner shares.\n', '     */\n', '    event MintMiner(address indexed account,uint256 amount);\n', '    /**\n', '     * @dev Emitted when `account` burn `amount` miner shares.\n', '     */\n', '    event BurnMiner(address indexed account,uint256 amount);\n', '    /**\n', '     * @dev Emitted when `from` redeem `value` mineCoins.\n', '     */\n', '    event RedeemMineCoin(address indexed from, address indexed mineCoin, uint256 value);\n', '    /**\n', '     * @dev Emitted when `from` transfer to `to` `amount` mineCoins.\n', '     */\n', '    event TranserMiner(address indexed from, address indexed to, uint256 amount);\n', '    /**\n', '     * @dev Emitted when `account` buying options get `amount` mineCoins.\n', '     */\n', '    event BuyingMiner(address indexed account,address indexed mineCoin,uint256 amount);\n', '}\n', '\n', '// File: contracts\\ERC20\\IERC20.sol\n', '\n', 'pragma solidity =0.5.16;\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts\\FNXMinePool\\FNXMinePool.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '/**\n', ' * @title FPTCoin mine pool, which manager contract is FPTCoin.\n', ' * @dev A smart-contract which distribute some mine coins by FPTCoin balance.\n', ' *\n', ' */\n', 'contract FNXMinePool is MinePoolData {\n', '    using SafeMath for uint256;\n', '    constructor () public{\n', '        initialize();\n', '    }\n', '    function initialize() onlyOwner public{\n', '    }\n', '    function update() onlyOwner public{\n', '    }\n', '    /**\n', '     * @dev default function for foundation input miner coins.\n', '     */\n', '    function()external payable{\n', '\n', '    }\n', '    /**\n', '     * @dev foundation redeem out mine coins.\n', '     * @param mineCoin mineCoin address\n', '     * @param amount redeem amount.\n', '     */\n', '    function redeemOut(address mineCoin,uint256 amount)public onlyOwner{\n', '        if (mineCoin == address(0)){\n', '            msg.sender.transfer(amount);\n', '        }else{\n', '            IERC20 token = IERC20(mineCoin);\n', '            uint256 preBalance = token.balanceOf(address(this));\n', '            token.transfer(msg.sender,amount);\n', '            uint256 afterBalance = token.balanceOf(address(this));\n', '            require(preBalance - afterBalance == amount,"settlement token transfer error!");\n', '        }\n', '    }\n', '    /**\n', '     * @dev retrieve total distributed mine coins.\n', '     * @param mineCoin mineCoin address\n', '     */\n', '    function getTotalMined(address mineCoin)public view returns(uint256){\n', '        uint256 _totalSupply = totalSupply();\n', '        uint256 _mineInterval = mineInterval[mineCoin];\n', '        if (_totalSupply > 0 && _mineInterval>0){\n', '            uint256 _mineAmount = mineAmount[mineCoin];\n', '            uint256 latestMined = _mineAmount.mul(now-latestSettleTime[mineCoin])/_mineInterval;\n', '            return totalMinedCoin[mineCoin].add(latestMined);\n', '        }\n', '        return totalMinedCoin[mineCoin];\n', '    }\n', '    /**\n', '     * @dev retrieve minecoin distributed informations.\n', '     * @param mineCoin mineCoin address\n', '     * @return distributed amount and distributed time interval.\n', '     */\n', '    function getMineInfo(address mineCoin)public view returns(uint256,uint256){\n', '        return (mineAmount[mineCoin],mineInterval[mineCoin]);\n', '    }\n', '    /**\n', "     * @dev retrieve user's mine balance.\n", "     * @param account user's account\n", '     * @param mineCoin mineCoin address\n', '     */\n', '    function getMinerBalance(address account,address mineCoin)public view returns(uint256){\n', '        uint256 totalBalance = minerBalances[mineCoin][account];\n', '        uint256 _totalSupply = totalSupply();\n', '        uint256 balance = balanceOf(account);\n', '        if (_totalSupply > 0 && balance>0){\n', '            uint256 tokenNetWorth = _getCurrentTokenNetWorth(mineCoin);\n', '            totalBalance= totalBalance.add(_settlement(mineCoin,account,balance,tokenNetWorth));\n', '        }\n', '        return totalBalance;\n', '    }\n', '    /**\n', '     * @dev Set mineCoin mine info, only foundation owner can invoked.\n', '     * @param mineCoin mineCoin address\n', '     * @param _mineAmount mineCoin distributed amount\n', '     * @param _mineInterval mineCoin distributied time interval\n', '     */\n', '    function setMineCoinInfo(address mineCoin,uint256 _mineAmount,uint256 _mineInterval)public onlyOwner {\n', '        require(_mineAmount<1e30,"input mine amount is too large");\n', '        require(_mineInterval>0,"input mine Interval must larger than zero");\n', '        _mineSettlement(mineCoin);\n', '        mineAmount[mineCoin] = _mineAmount;\n', '        mineInterval[mineCoin] = _mineInterval;\n', '        addWhiteList(mineCoin);\n', '    }\n', '    /**\n', '     * @dev Set the reward for buying options.\n', '     * @param mineCoin mineCoin address\n', '     * @param _mineAmount mineCoin reward amount\n', '     */\n', '    function setBuyingMineInfo(address mineCoin,uint256 _mineAmount)public onlyOwner {\n', '//        require(_mineAmount<1e30,"input mine amount is too large");\n', '        buyingMineMap[mineCoin] = _mineAmount;\n', '        addWhiteList(mineCoin);\n', '    }\n', '    /**\n', '     * @dev Get the reward for buying options.\n', '     * @param mineCoin mineCoin address\n', '     */\n', '    function getBuyingMineInfo(address mineCoin)public view returns(uint256){\n', '        return buyingMineMap[mineCoin];\n', '    }\n', '    /**\n', '     * @dev Get the all rewards for buying options.\n', '     */\n', '    function getBuyingMineInfoAll()public view returns(address[] memory,uint256[] memory){\n', '        uint256 len = whiteList.length;\n', '        address[] memory mineCoins = new address[](len);\n', '        uint256[] memory mineNums = new uint256[](len);\n', '        for (uint256 i=0;i<len;i++){\n', '            mineCoins[i] = whiteList[i];\n', '            mineNums[i] = buyingMineMap[mineCoins[i]];\n', '        }\n', '        return (mineCoins,mineNums);\n', '    }\n', '    /**\n', '     * @dev transfer mineCoin to recieptor when account transfer amount FPTCoin to recieptor, only manager contract can modify database.\n', '     * @param account the account transfer from\n', '     * @param recieptor the account transfer to\n', '     * @param amount the mine shared amount\n', '     */\n', '    function transferMinerCoin(address account,address recieptor,uint256 amount) public onlyManager {\n', '        _mineSettlementAll();\n', '        _transferMinerCoin(account,recieptor,amount);\n', '    }\n', '    /**\n', '     * @dev mint mineCoin to account when account add collateral to collateral pool, only manager contract can modify database.\n', "     * @param account user's account\n", '     * @param amount the mine shared amount\n', '     */\n', '    function mintMinerCoin(address account,uint256 amount) public onlyManager {\n', '        _mineSettlementAll();\n', '        _mintMinerCoin(account,amount);\n', '        emit MintMiner(account,amount);\n', '    }\n', '    /**\n', '     * @dev Burn mineCoin to account when account redeem collateral to collateral pool, only manager contract can modify database.\n', "     * @param account user's account\n", '     * @param amount the mine shared amount\n', '     */\n', '    function burnMinerCoin(address account,uint256 amount) public onlyManager {\n', '        _mineSettlementAll();\n', '        _burnMinerCoin(account,amount);\n', '        emit BurnMiner(account,amount);\n', '    }\n', '    /**\n', '     * @dev give amount buying reward to account, only manager contract can modify database.\n', "     * @param account user's account\n", '     * @param amount the buying shared amount\n', '     */\n', '    function addMinerBalance(address account,uint256 amount) public onlyManager {\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            address addr = whiteList[i];\n', '            uint256 mineNum = buyingMineMap[addr];\n', '            if (mineNum > 0){\n', '                uint128 mineRate = uint128(mineNum);\n', '                uint128 mineAdd = uint128(mineNum>>128);\n', '                uint256 _mineAmount = mineRate*amount/calDecimals + mineAdd;\n', '                minerBalances[addr][account] = minerBalances[addr][account].add(_mineAmount);\n', '                //totalMinedCoin[addr] = totalMinedCoin[addr].add(_mineAmount);\n', '                emit BuyingMiner(account,addr,_mineAmount);\n', '            }\n', '        }\n', '    }\n', '    /**\n', '     * @dev changer mine coin distributed amount , only foundation owner can modify database.\n', '     * @param mineCoin mine coin address\n', '     * @param _mineAmount the distributed amount.\n', '     */\n', '    function setMineAmount(address mineCoin,uint256 _mineAmount)public onlyOwner {\n', '        require(_mineAmount<1e30,"input mine amount is too large");\n', '        _mineSettlement(mineCoin);\n', '        mineAmount[mineCoin] = _mineAmount;\n', '    }\n', '    /**\n', '     * @dev changer mine coin distributed time interval , only foundation owner can modify database.\n', '     * @param mineCoin mine coin address\n', '     * @param _mineInterval the distributed time interval.\n', '     */\n', '    function setMineInterval(address mineCoin,uint256 _mineInterval)public onlyOwner {\n', '        require(_mineInterval>0,"input mine Interval must larger than zero");\n', '        _mineSettlement(mineCoin);\n', '        mineInterval[mineCoin] = _mineInterval;\n', '    }\n', '    /**\n', '     * @dev user redeem mine rewards.\n', '     * @param mineCoin mine coin address\n', '     * @param amount redeem amount.\n', '     */\n', '    function redeemMinerCoin(address mineCoin,uint256 amount)public nonReentrant notHalted {\n', '        _mineSettlement(mineCoin);\n', '        _settlementAllCoin(mineCoin,msg.sender);\n', '        uint256 minerAmount = minerBalances[mineCoin][msg.sender];\n', '        require(minerAmount>=amount,"miner balance is insufficient");\n', '\n', '        minerBalances[mineCoin][msg.sender] = minerAmount-amount;\n', '        _redeemMineCoin(mineCoin,msg.sender,amount);\n', '    }\n', '    /**\n', '     * @dev subfunction for user redeem mine rewards.\n', '     * @param mineCoin mine coin address\n', "     * @param recieptor recieptor's account\n", '     * @param amount redeem amount.\n', '     */\n', '    function _redeemMineCoin(address mineCoin,address payable recieptor,uint256 amount)internal {\n', '        if (amount == 0){\n', '            return;\n', '        }\n', '        if (mineCoin == address(0)){\n', '            recieptor.transfer(amount);\n', '        }else{\n', '            IERC20 minerToken = IERC20(mineCoin);\n', '            uint256 preBalance = minerToken.balanceOf(address(this));\n', '            minerToken.transfer(recieptor,amount);\n', '            uint256 afterBalance = minerToken.balanceOf(address(this));\n', '            require(preBalance - afterBalance == amount,"settlement token transfer error!");\n', '        }\n', '        emit RedeemMineCoin(recieptor,mineCoin,amount);\n', '    }\n', '    /**\n', '     * @dev settle all mine coin.\n', '     */    \n', '    function _mineSettlementAll()internal{\n', '        uint256 addrLen = whiteList.length;\n', '        for(uint256 i=0;i<addrLen;i++){\n', '            _mineSettlement(whiteList[i]);\n', '        }\n', '    }\n', '    /**\n', '     * @dev the auxiliary function for _mineSettlementAll.\n', '     */    \n', '    function _mineSettlement(address mineCoin)internal{\n', '        uint256 latestMined = _getLatestMined(mineCoin);\n', '        uint256 _mineInterval = mineInterval[mineCoin];\n', '        if (latestMined>0){\n', '            totalMinedWorth[mineCoin] = totalMinedWorth[mineCoin].add(latestMined.mul(calDecimals));\n', '            totalMinedCoin[mineCoin] = totalMinedCoin[mineCoin]+latestMined;\n', '        }\n', '        if (_mineInterval>0){\n', '            latestSettleTime[mineCoin] = now/_mineInterval*_mineInterval;\n', '        }else{\n', '            latestSettleTime[mineCoin] = now;\n', '        }\n', '    }\n', '    /**\n', '     * @dev the auxiliary function for _mineSettlementAll. Calculate latest time phase distributied mine amount.\n', '     */ \n', '    function _getLatestMined(address mineCoin)internal view returns(uint256){\n', '        uint256 _mineInterval = mineInterval[mineCoin];\n', '        uint256 _totalSupply = totalSupply();\n', '        if (_totalSupply > 0 && _mineInterval>0){\n', '            uint256 _mineAmount = mineAmount[mineCoin];\n', '            uint256 mintTime = (now-latestSettleTime[mineCoin])/_mineInterval;\n', '            uint256 latestMined = _mineAmount*mintTime;\n', '            return latestMined;\n', '        }\n', '        return 0;\n', '    }\n', '    /**\n', '     * @dev subfunction, transfer mineCoin to recieptor when account transfer amount FPTCoin to recieptor\n', '     * @param account the account transfer from\n', '     * @param recipient the account transfer to\n', '     * @param amount the mine shared amount\n', '     */\n', '    function _transferMinerCoin(address account,address recipient,uint256 amount)internal{\n', '        uint256 addrLen = whiteList.length;\n', '        for(uint256 i=0;i<addrLen;i++){\n', '            settleMinerBalance(whiteList[i],account,recipient,amount,opTransferCoin);\n', '        }\n', '        emit TranserMiner(account,recipient,amount);\n', '    }\n', '    /**\n', '     * @dev subfunction, mint mineCoin to account when account add collateral to collateral pool\n', "     * @param account user's account\n", '     * @param amount the mine shared amount\n', '     */\n', '    function _mintMinerCoin(address account,uint256 amount)internal{\n', '        uint256 addrLen = whiteList.length;\n', '        for(uint256 i=0;i<addrLen;i++){\n', '            settleMinerBalance(whiteList[i],account,address(0),amount,opMintCoin);\n', '        }\n', '    }\n', '    /**\n', "     * @dev subfunction, settle user's mint balance when user want to modify mine database.\n", '     * @param mineCoin the mine coin address\n', "     * @param account user's account\n", '     */\n', '    function _settlementAllCoin(address mineCoin,address account)internal{\n', '        settleMinerBalance(mineCoin,account,address(0),0,0);\n', '    }\n', '    /**\n', '     * @dev subfunction, Burn mineCoin to account when account redeem collateral to collateral pool\n', "     * @param account user's account\n", '     * @param amount the mine shared amount\n', '     */\n', '    function _burnMinerCoin(address account,uint256 amount)internal{\n', '        uint256 addrLen = whiteList.length;\n', '        for(uint256 i=0;i<addrLen;i++){\n', '            settleMinerBalance(whiteList[i],account,address(0),amount,opBurnCoin);\n', '        }\n', '    }\n', '    /**\n', "     * @dev settle user's mint balance when user want to modify mine database.\n", '     * @param mineCoin the mine coin address\n', "     * @param account user's account\n", "     * @param recipient the recipient's address if operator is transfer\n", '     * @param amount the input amount for operator\n', '     * @param operators User operator to modify mine database.\n', '     */\n', '    function settleMinerBalance(address mineCoin,address account,address recipient,uint256 amount,uint256 operators)internal{\n', '        uint256 _totalSupply = totalSupply();\n', '        uint256 tokenNetWorth = _getTokenNetWorth(mineCoin);\n', '        if (_totalSupply > 0){\n', '            minerBalances[mineCoin][account] = minerBalances[mineCoin][account].add(\n', '                    _settlement(mineCoin,account,balanceOf(account),tokenNetWorth));\n', '            if (operators == opBurnCoin){\n', '                totalMinedWorth[mineCoin] = totalMinedWorth[mineCoin].sub(tokenNetWorth.mul(amount));\n', '            }else if (operators==opMintCoin){\n', '                totalMinedWorth[mineCoin] = totalMinedWorth[mineCoin].add(tokenNetWorth.mul(amount));\n', '            }else if (operators==opTransferCoin){\n', '                minerBalances[mineCoin][recipient] = minerBalances[mineCoin][recipient].add(\n', '                    _settlement(mineCoin,recipient,balanceOf(recipient),tokenNetWorth));\n', '                minerOrigins[mineCoin][recipient] = tokenNetWorth;\n', '            }\n', '        }\n', '        minerOrigins[mineCoin][account] = tokenNetWorth;\n', '    }\n', '    /**\n', "     * @dev subfunction, settle user's latest mine amount.\n", '     * @param mineCoin the mine coin address\n', "     * @param account user's account\n", '     * @param amount the input amount for operator\n', '     * @param tokenNetWorth the latest token net worth\n', '     */\n', '    function _settlement(address mineCoin,address account,uint256 amount,uint256 tokenNetWorth)internal view returns (uint256) {\n', '        uint256 origin = minerOrigins[mineCoin][account];\n', '        require(tokenNetWorth>=origin,"error: tokenNetWorth logic error!");\n', '        return amount.mul(tokenNetWorth-origin)/calDecimals;\n', '    }\n', '    /**\n', '     * @dev subfunction, calculate current token net worth.\n', '     * @param mineCoin the mine coin address\n', '     */\n', '    function _getCurrentTokenNetWorth(address mineCoin)internal view returns (uint256) {\n', '        uint256 latestMined = _getLatestMined(mineCoin);\n', '        uint256 _totalSupply = totalSupply();\n', '        if (_totalSupply > 0){\n', '            return (totalMinedWorth[mineCoin].add(latestMined*calDecimals))/_totalSupply;\n', '        }\n', '        return 0;\n', '    }\n', '    /**\n', '     * @dev subfunction, calculate token net worth when settlement is completed.\n', '     * @param mineCoin the mine coin address\n', '     */\n', '    function _getTokenNetWorth(address mineCoin)internal view returns (uint256) {\n', '        uint256 _totalSupply = totalSupply();\n', '        if (_totalSupply > 0){\n', '            return totalMinedWorth[mineCoin]/_totalSupply;\n', '        }\n', '        return 0;\n', '    }\n', '    /**\n', "     * @dev get FPTCoin's total supply.\n", '     */\n', '    function totalSupply()internal view returns(uint256){\n', '        IERC20 _FPTCoin = IERC20(getManager());\n', '        return _FPTCoin.totalSupply();\n', '    }\n', '    /**\n', "     * @dev get FPTCoin's user balance.\n", '     */\n', '    function balanceOf(address account)internal view returns(uint256){\n', '        IERC20 _FPTCoin = IERC20(getManager());\n', '        return _FPTCoin.balanceOf(account);\n', '    }\n', '}']