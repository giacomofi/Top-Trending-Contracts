['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.3;\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', 'interface ItokenRecipient { \n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external returns (bool); \n', '}\n', '\n', 'interface IstakeContract { \n', '    function createStake(address _wallet, uint8 _timeFrame, uint256 _value) external returns (bool); \n', '}\n', '\n', 'interface IERC20Token {\n', '    function totalSupply() external view returns (uint256 supply);\n', '    function transfer(address _to, uint256 _value) external  returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n', '}\n', '\n', 'contract Ownable {\n', '\n', '    address private owner;\n', '    \n', '    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Caller is not owner");\n', '        _;\n', '    }\n', '\n', '    constructor() {\n', "        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n", '        emit OwnerSet(address(0), owner);\n', '    }\n', '\n', '\n', '    function changeOwner(address newOwner) public onlyOwner {\n', '        emit OwnerSet(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function getOwner() external view returns (address) {\n', '        return owner;\n', '    }\n', '}\n', '\n', 'contract StandardToken is IERC20Token {\n', '    \n', '    using SafeMath for uint256;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public _totalSupply;\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    \n', '    function totalSupply() override public view returns (uint256 supply) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) override virtual public returns (bool success) {\n', '        require(_to != address(0x0), "Use burn function instead");                               // Prevent transfer to 0x0 address. Use burn() instead\n', '\t\trequire(_value >= 0, "Invalid amount"); \n', '\t\trequire(balances[msg.sender] >= _value, "Not enough balance");\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\temit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) override virtual public returns (bool success) {\n', '        require(_to != address(0x0), "Use burn function instead");                               // Prevent transfer to 0x0 address. Use burn() instead\n', '\t\trequire(_value >= 0, "Invalid amount"); \n', '\t\trequire(balances[_from] >= _value, "Not enough balance");\n', '\t\trequire(allowed[_from][msg.sender] >= _value, "You need to increase allowance");\n', '\t\tbalances[_from] = balances[_from].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\temit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) override public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) override public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) override public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '}\n', '\n', 'contract YUIToken is Ownable, StandardToken {\n', '\n', '    using SafeMath for uint256;\n', '    string public name;\n', '    uint8 public decimals;\n', '    string public symbol;\n', '    address public stakeContract;\n', '    address public crowdSaleContract;\n', '    uint256 public soldTokensUnlockTime;\n', '    mapping (address => uint256) frozenBalances;\n', '    mapping (address => uint256) timelock;\n', '    \n', '    event Burn(address indexed from, uint256 value);\n', '    event StakeContractSet(address indexed contractAddress);\n', '\n', '    \n', '    constructor() {\n', '        name = "YUI Token";\n', '        decimals = 18;\n', '        symbol = "YUI";\n', '        stakeContract = address(0x0);\n', '        crowdSaleContract = 0x5530AF4758A33bE9Fd62165ef543b5E2e6742953;                 // contract for ICO tokens\n', '        address teamWallet =  0x07B8DcbDF4d52B9C1f4251373A289D803Cc670f8;               // wallet for team tokens\n', '        address privateSaleWallet = 0xC5f1f4fdbFAb7F73CfC814d72408B648059514A0;         // wallet for private sale tokens\n', '        address marketingWallet = 0x5e0e67AA4f29aD2920Fa8BFe3ae38B52D4f2ceb1;           // wallet for marketing\n', '        address exchangesLiquidity = 0x7e47b3C642A72520fF7DbFDc052535A0c804fC3C;        // add liquidity to exchanges\n', '        address stakeWallet = 0x16B92c0473C0491D1509c447285B7c925355e3D3;               // tokens for the stake contract\n', '        uint256 teamReleaseTime = 1620324000;                                           // lock team tokens for 6 months\n', '        uint256 marketingReleaseTime = 1612548000;                                      // lock marketing tokens - 1k tokens for 3 months\n', '        uint256 stakesReleaseTime = 1606586400;                                         // lock stakeContract tokens - 7.5k tokens for 3 weeks\n', '\n', '        balances[teamWallet] = 3000 ether;\n', '        emit Transfer(address(0x0), teamWallet, (3000 ether));\n', '        frozenBalances[teamWallet] = 3000 ether;\n', '        timelock[teamWallet] = teamReleaseTime;\n', '        \n', '        balances[stakeWallet] = 7500 ether;\n', '        emit Transfer(address(0x0), address(stakeWallet), (7500 ether));\n', '        frozenBalances[stakeWallet] = 7500 ether;\n', '        timelock[stakeWallet] = stakesReleaseTime;\n', '        \n', '        balances[marketingWallet] = 2000 ether;\n', '        emit Transfer(address(0x0), address(marketingWallet), (2000 ether));\n', '        frozenBalances[marketingWallet] = 1000 ether;\n', '        timelock[marketingWallet] = marketingReleaseTime;\n', '        \n', '        balances[privateSaleWallet] = 1500 ether;\n', '        emit Transfer(address(0x0), address(privateSaleWallet), (1500 ether));\n', '        \n', '        balances[crowdSaleContract] = 5000 ether;\n', '        emit Transfer(address(0x0), address(crowdSaleContract), (5000 ether));\n', '\n', '        balances[exchangesLiquidity] = 9000 ether;\n', '        emit Transfer(address(0x0), address(exchangesLiquidity), (9000 ether));\n', '\n', '        _totalSupply = 28000 ether;\n', '        \n', '        soldTokensUnlockTime = 1605636300;\n', '\n', '    }\n', '    \n', '    function frozenBalanceOf(address _owner) public view returns (uint256 balance) {\n', '        return frozenBalances[_owner];\n', '    }\n', '    \n', '    function unlockTimeOf(address _owner) public view returns (uint256 time) {\n', '        return timelock[_owner];\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) override public  returns (bool success) {\n', '        require(txAllowed(msg.sender, _value), "Crowdsale tokens are still frozen");\n', '        return super.transfer(_to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) {\n', '        require(txAllowed(msg.sender, _value), "Crowdsale tokens are still frozen");\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '    \n', '    function setStakeContract(address _contractAddress) onlyOwner public {\n', '        stakeContract = _contractAddress;\n', '        emit StakeContractSet(_contractAddress);\n', '    }\n', '    \n', '    function setCrowdSaleContract(address _contractAddress) onlyOwner public {\n', '        crowdSaleContract = _contractAddress;\n', '    }\n', '    \n', '        // Tokens sold by crowdsale contract will be frozen ultil crowdsale ends\n', '    function txAllowed(address sender, uint256 amount) private returns (bool isAllowed) {\n', '        if (timelock[sender] > block.timestamp) {\n', '            return isBalanceFree(sender, amount);\n', '        } else {\n', '            if (frozenBalances[sender] > 0) frozenBalances[sender] = 0;\n', '            return true;\n', '        }\n', '        \n', '    }\n', '    \n', '    function isBalanceFree(address sender, uint256 amount) private view returns (bool isfree) {\n', '        if (amount <= (balances[sender] - frozenBalances[sender])) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balances[msg.sender] >= _value, "Not enough balance");\n', '\t\trequire(_value >= 0, "Invalid amount"); \n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        _totalSupply = _totalSupply.sub(_value);\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function approveStake(uint8 _timeFrame, uint256 _value) public returns (bool success) {\n', '        require(stakeContract != address(0x0));\n', '        allowed[msg.sender][stakeContract] = _value;\n', '        emit Approval(msg.sender, stakeContract, _value);\n', '        IstakeContract recipient = IstakeContract(stakeContract);\n', '        require(recipient.createStake(msg.sender, _timeFrame, _value));\n', '        return true;\n', '    }\n', '    \n', '    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        ItokenRecipient recipient = ItokenRecipient(_spender);\n', '        require(recipient.receiveApproval(msg.sender, _value, address(this), _extraData));\n', '        return true;\n', '    }\n', '    \n', '    function tokensSold(address buyer, uint256 amount) public returns (bool success) {\n', '        require(msg.sender == crowdSaleContract);\n', '        frozenBalances[buyer] += amount;\n', '        if (timelock[buyer] == 0 ) timelock[buyer] = soldTokensUnlockTime;\n', '        return super.transfer(buyer, amount);\n', '    }\n', '    \n', '\n', '}']