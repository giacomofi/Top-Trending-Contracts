['/**\n', ' *Submitted for verification at Etherscan.io on 2020-09-23\n', ' * Initial Seed fund contract \n', ' * Fractionalization of "22hrs" convenience store chain and tokenizing it\n', ' * https://22hrs.com, An initiative to bring the real-world assets into blockchain\n', '*/\n', 'pragma solidity ^0.5.7;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', ' \n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract HRSToken{\n', '    \n', '    string internal _name;\n', '    string internal _symbol;\n', '    uint8 internal _decimals;\n', '    uint256 internal _totalSupply;\n', '    uint256 internal _totalburnt;\n', '    uint256 mintLimit;\n', '    uint256 burnLimit;\n', '    address public owner;\n', '    address public newOwner;\n', '    address central_account;\n', '    mapping (address => uint256) internal balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    mapping (address=>uint256) internal blocklist;\n', '    bool stopped=false;\n', '    \n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '    \n', '    \n', '    \n', '    constructor () public {\n', "        _name = '22hrs';\n", "        _symbol = '22hrs';\n", '        _decimals = 18;\n', '        _totalSupply = 0;\n', '        _totalburnt = 0;\n', '        mintLimit = 1000000;\n', '        burnLimit = 1000000;\n', '        \n', '        owner = msg.sender;\n', '  }\n', '  \n', '  \n', '   modifier onlyOwner() {\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '    modifier onlycentralAccount {\n', '        require(msg.sender == central_account);\n', '        _;\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '   function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    return balances[_owner];\n', '   }\n', '   \n', '   function isBlockList(address _ads) public view returns (bool){\n', '       if(blocklist[_ads]>0)\n', '        return true;\n', '       else\n', '        return false;\n', '   }\n', '   \n', '   function mintStatus()public view returns (bool status){\n', '       return !stopped;\n', '   }\n', '   \n', '   function set_centralAccount(address central_Acccount) external onlyOwner\n', '    {\n', '        require(blocklist[central_Acccount]==0);\n', '        central_account = central_Acccount;\n', '    }\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '     // If this function is called again it overwrites the current allowance with _value.\n', '     \n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '     require(blocklist[_spender]==0 && blocklist[msg.sender]==0);\n', '     require( _spender != address(0));\n', '     \n', '     allowed[msg.sender][_spender] = _value;\n', '     emit Approval(msg.sender, _spender, _value);\n', '     return true;\n', '   }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '      require( _owner != address(0) && _spender !=address(0));\n', '     return allowed[_owner][_spender];\n', '   }\n', '\n', '   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '     require(blocklist[_spender]==0 && blocklist[msg.sender]==0);\n', '     allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue);\n', '     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '     return true;\n', '   }\n', '\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '     require(blocklist[_spender]==0 && blocklist[msg.sender]==0);\n', '     uint oldValue = allowed[msg.sender][_spender];\n', '     if (_subtractedValue > oldValue) {\n', '       allowed[msg.sender][_spender] = 0;\n', '     } else {\n', '       allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);\n', '    }\n', '     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '     return true;\n', '   }\n', '   \n', "   // Transfer the balance from the owner's account to another account\n", '   \n', '    function transfer(address _to, uint256 _value) public returns(bool){\n', '        \n', '        require( balances[msg.sender]>= _value && _value > 0 );\n', '        require(blocklist[_to]==0 && blocklist[msg.sender]==0);\n', '\n', '        balances[msg.sender] = SafeMath.sub(balances[msg.sender] , _value);\n', '        balances[_to] = SafeMath.add(balances[_to] , _value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /** Send _value amount of tokens from address _from to address _to\n', '      * \n', '      * The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '      * \n', '      * tokens on your behalf, for example, to "deposit" to a contract address and/or to charge\n', '      * \n', '      * fees in sub-currencies; the command should fail unless the _from account has\n', '      * \n', '      * deliberately authorized the sender of the message via some mechanism; we propose\n', '      * \n', '      * these standardized APIs for approval:\n', '      */\n', '     \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(blocklist[_to]==0 && blocklist[msg.sender]==0);\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '        require(_value > 0 );\n', '\n', '        balances[_from] = SafeMath.sub(balances[_from], _value);\n', '        balances[_to] = SafeMath.add(balances[_to], _value);\n', '        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '   }\n', '   \n', '   function transferby(address _from,address _to,uint256 _amount) external onlycentralAccount returns(bool success) {\n', '        require( _to != address(0)); \n', '        require(blocklist[_from]==0 && blocklist[_to]==0);\n', '        require (balances[_from] >= _amount && _amount > 0);\n', '        \n', '        balances[_from] = SafeMath.sub( balances[_from] , _amount);\n', '        balances[_to] = SafeMath.add(balances[_to] , _amount);\n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '    /** @notice  Mint the specified value from the given address.\n', '      *\n', '      * @dev  ads balance is added by the value they mentioned.\n', '      *\n', '      * @param  value  The amount to mint.\n', '      *\n', '      * @param  ads     address of the user\n', '      * \n', '      * @return  success true if the mint succeeded.\n', '      */\n', '   \n', '   function mint(uint value , address ads) external onlycentralAccount returns (bool){\n', '       \n', '       require(!stopped);\n', '       require(ads!=address(0) && value > 0 && value <= mintLimit);\n', '       require(blocklist[ads]==0);\n', '       \n', '       _totalSupply = SafeMath.add(_totalSupply, value);\n', '      balances[ads] = SafeMath.add(balances[ads], value);\n', '      emit Transfer(address(0), ads, value);\n', '      return true;\n', '       \n', '   }\n', '   \n', '   \n', '   \n', '    function batchMint(address[] calldata _tos, uint256[] calldata  _values) external onlycentralAccount returns (bool success) {\n', '        require(_tos.length == _values.length);\n', '        require(!stopped);\n', '\n', '        uint256 totalTransfers = _tos.length;\n', '\n', '        for (uint256 i = 0; i < totalTransfers; i++) {\n', '           address to = _tos[i];\n', '           uint256 value = _values[i];\n', '           require(to!=address(0) && value > 0 && value <= mintLimit);\n', '           require(blocklist[to]==0);\n', '\n', '           _totalSupply = SafeMath.add(_totalSupply, value);\n', '           balances[to] = SafeMath.add(balances[to], value);\n', '           emit Transfer(address(0), to, value);\n', '        }\n', '\n', '\n', '        return true;\n', '    }\n', '   \n', '   /** @notice  Burns the specified value from the given address.\n', '      *\n', '      * @dev  ads balance is subtracted by the value they mentioned.\n', '      *\n', '      * @param  value  The amount to burn.\n', '      *\n', '      * @param  ads     address of the user\n', '      * \n', '      * @return  success true if the burn succeeded.\n', '      */\n', '   \n', '   function burn(uint value ,  address ads) external onlycentralAccount returns (bool){\n', '        \n', '        require(ads!=address(0) && value > 0 && !stopped);\n', '        require(blocklist[ads]==0);\n', '        require(balances[ads]>=value && value <= burnLimit);\n', '        \n', '        balances[ads] = SafeMath.sub(balances[ads], value);\n', '        _totalSupply = SafeMath.sub(_totalSupply, value);\n', '        _totalburnt = SafeMath.add(_totalburnt,value);\n', '        emit Transfer(ads, address(0), value);\n', '        return true;\n', '   }\n', '   \n', '    function increaseSupply(uint value, address to) external onlyOwner returns (bool) {\n', '      \n', '      require(to!= address(0) && value > 0);\n', '      _totalSupply = SafeMath.add(_totalSupply, value);\n', '      balances[to] = SafeMath.add(balances[to], value);\n', '      emit Transfer(address(0), to, value);\n', '      return true;\n', '}\n', '\n', '\n', '\n', '    function decreaseSupply(uint value, address from) external onlyOwner returns (bool) {\n', '        \n', '        require(from!=address(0) && value > 0);\n', '        require(balances[from]>=value);\n', '        balances[from] = SafeMath.sub(balances[from], value);\n', '        _totalSupply = SafeMath.sub(_totalSupply, value);  \n', '        _totalburnt = SafeMath.add(_totalburnt,value);\n', '        emit Transfer(from, address(0), value);\n', '        return true;\n', '}\n', '\n', '     // called by the owner, pause Mint & Burn\n', '    function PauseMint() external onlyOwner{\n', '        stopped = true;\n', '       }\n', '    \n', '    // called by the owner, resume Mint & Burn\n', '    function ResumeMint() external onlyOwner{\n', '        stopped = false;\n', '      }\n', '    \n', '    // called by the owner, set Mint Limit for the Central Account\n', '    function SetMintLimit(uint256 _limit) external onlyOwner{\n', '        mintLimit = _limit;\n', '    }\n', '    \n', '    function getMintLimit() public view returns(uint256){\n', '        return mintLimit;\n', '    }\n', '    \n', '    // called by the owner, set Burn Limit for the Central Account\n', '    function SetBurnLimit(uint256 _limit) external onlyOwner{\n', '        burnLimit = _limit;\n', '    }\n', '    \n', '    function getBurnLimit()public view returns(uint256){\n', '        return burnLimit;\n', '    }\n', '      \n', '     \n', '    // called by the owner, to add particular address to the blocklist\n', '    function addBlockLIst(address ads) external onlyOwner{\n', '         require(ads != owner);\n', '         blocklist[ads] = 1;\n', '     }\n', '     \n', '    // called by the owner, to remove particular address from the blocklist\n', '    function removeBlockList(address ads) external onlyOwner{\n', '         blocklist[ads] = 0;\n', '     }\n', '     \n', '     \n', '      /** @notice This function transfers the balances of all the given addresses \n', '       \n', '      * to the given destination.\n', '      *\n', '      * @dev The central account is the only authorized caller of\n', '      * this function. This function accepts an array of addresses to have their\n', '      * balances transferred for gas efficiency purposes.\n', '      * NOTE: transfers to the zero address are disallowed.\n', '      *\n', '      * @param  _froms  The addresses to have their balances swept.\n', '      * @param  _to  The destination address of all these transfers.\n', '      */\n', '     \n', '      function sweep(address[] calldata _froms, address _to) external  onlycentralAccount returns(bool) {\n', '        require(_to != address(0));\n', '        uint256 lenFroms = _froms.length;\n', '        uint256 sweptBalance = 0;\n', '\n', '        for (uint256 i=0; i<lenFroms; ++i) {\n', '            address from = _froms[i];\n', '\n', '                uint256 fromBalance = balances[from];\n', '\n', '                if (fromBalance > 0) {\n', '                    sweptBalance += fromBalance;\n', '\n', '                    balances[from] = 0;\n', '\n', '                     emit Transfer(from, _to, fromBalance);\n', '                }\n', '        }\n', '\n', '        if (sweptBalance > 0) {\n', '            balances[_to] = SafeMath.add(balances[_to],sweptBalance);\n', '            return true;\n', '        }\n', '    }\n', '      \n', '      \n', '       /** @notice  A function for a sender to issue multiple transfers to multiple\n', '      * different addresses at once. This function is implemented for gas\n', '      * considerations when someone wishes to transfer, as one transaction is\n', '      * cheaper than issuing several distinct individual `transfer` transactions.\n', '      *\n', '      * @dev  By specifying a set of destination addresses and values, the\n', '      * sender can issue one transaction to transfer multiple amounts to\n', '      * distinct addresses, rather than issuing each as a separate\n', '      * transaction. The `_tos` and `_values` arrays must be equal length, and\n', '      * an index in one array corresponds to the same index in the other array\n', '      * (e.g. `_tos[0]` will receive `_values[0]`, `_tos[1]` will receive\n', '      * `_values[1]`, and so on.)\n', '      * NOTE: transfers to the zero address are disallowed.\n', '      *\n', '      * @param  _tos  The destination addresses to receive the transfers.\n', '      * @param  _values  The values for each destination address.\n', '      * @return  success  If transfers succeeded.\n', '      */\n', '      \n', '     function batchTransfer(address[] memory _tos, uint256[] memory  _values) public returns (bool success) {\n', '        require(_tos.length == _values.length);\n', '\n', '        uint256 totalTransfers = _tos.length;\n', '        uint256 senderBalance = balances[msg.sender];\n', '\n', '        for (uint256 i = 0; i < totalTransfers; i++) {\n', '          address to = _tos[i];\n', '          require(to != address(0));\n', '          uint256 amount = _values[i];\n', '          require(senderBalance >= amount);\n', '\n', '          if (msg.sender != to) {\n', '            senderBalance -= amount;\n', '            SafeMath.add(balances[to], amount);\n', '          }\n', '          emit Transfer(msg.sender, to, amount);\n', '        }\n', '\n', '        balances[msg.sender] = senderBalance;\n', '\n', '        return true;\n', '    }\n', '\n', '    \n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(blocklist[_newOwner]==0);\n', '        newOwner = _newOwner;\n', '    }\n', '    \n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner && blocklist[msg.sender]==0);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '    \n', '   function () external payable {\n', '        revert();\n', '    } \n', '}']