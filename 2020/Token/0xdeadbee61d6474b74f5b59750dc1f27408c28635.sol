['// SPDX-License-Identifier: MIT\n', '\n', '// Author: Grzegorz Kucmierz <gkucmierz@gmail.com>\n', '// Source: https://github.com/gkucmierz/wisdom-contract\n', '\n', 'pragma solidity ^0.7.2;\n', '\n', 'contract ERC20 {\n', '\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '  uint256 public totalSupply;\n', '\n', '  mapping (address => uint256) public balanceOf;\n', '  mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '  function _transfer(address sender, address recipient, uint256 amount) internal virtual returns (bool) {\n', '    require(balanceOf[sender] >= amount);\n', '    balanceOf[sender] -= amount;\n', '    balanceOf[recipient] += amount;\n', '    emit Transfer(sender, recipient, amount);\n', '    return true;\n', '  }\n', '\n', '  function transfer(address recipient, uint256 amount) public returns (bool) {\n', '    return _transfer(msg.sender, recipient, amount);\n', '  }\n', '\n', '  function allowance(address holder, address spender) public view returns (uint256) {\n', '    return allowed[holder][spender];\n', '  }\n', '\n', '  function approve(address spender, uint256 amount) public returns (bool) {\n', '    require(balanceOf[msg.sender] >= amount);\n', '    allowed[msg.sender][spender] = amount;\n', '    emit Approval(msg.sender, spender, amount);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '    require(allowed[sender][msg.sender] >= amount);\n', '    _transfer(sender, recipient, amount);\n', '    allowed[sender][msg.sender] -= amount;\n', '    return true;\n', '  }\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed holder, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface IERC677Receiver {\n', '  function onTokenTransfer(address from, uint256 amount, bytes calldata data) external;\n', '}\n', '\n', 'contract ERC667 is ERC20 {\n', '  function transferAndCall(address recipient, uint amount, bytes calldata data) public returns (bool) {\n', '    bool success = _transfer(msg.sender, recipient, amount);\n', '    if (success){\n', '      IERC677Receiver(recipient).onTokenTransfer(msg.sender, amount, data);\n', '    }\n', '    return success;\n', '  }\n', '}\n', '\n', 'contract ERCTransferFrom is ERC667 {\n', '  mapping (address => mapping (address => uint256)) public nonceOf;\n', '\n', '  function _transfer(address from, address recipient, uint256 amount, uint256 nonce) private returns (bool) {\n', '    uint256 nextNonce = nonceOf[from][recipient] + 1;\n', '    require(nonce == nextNonce);\n', '    bool success = _transfer(from, recipient, amount);\n', '    if (success) nonceOf[from][recipient] = nextNonce;\n', '    return success;\n', '  }\n', '\n', '  function transferFrom(address recipient, uint256 amount, uint256 nonce, uint8 _v, bytes32 _r, bytes32 _s) public returns (bool) {\n', "    bytes32 hash = keccak256(abi.encodePacked('transferFrom', recipient, amount, nonce));\n", '    address from = ecrecover(hash, _v, _r, _s);\n', '    return _transfer(from, recipient, amount, nonce);\n', '  }\n', '\n', '  function transferFromUntil(address recipient, uint256 amount, uint256 untilBlock, uint256 nonce, uint8 _v, bytes32 _r, bytes32 _s) public returns (bool) {\n', '    require(untilBlock <= block.number);\n', "    bytes32 hash = keccak256(abi.encodePacked('transferFromUntil', recipient, amount, nonce, untilBlock));\n", '    address from = ecrecover(hash, _v, _r, _s);\n', '    return _transfer(from, recipient, amount, nonce);\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address owner;\n', '\n', '  constructor() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0x0));\n', '    owner = newOwner;\n', '    emit TransferOwnership(newOwner);\n', '  }\n', '\n', '  event TransferOwnership(address newOwner);\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '  bool public paused = true;\n', '\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '\n', '  event Pause();\n', '  event Unpause();\n', '}\n', '\n', 'contract Issuable is ERC20, Ownable {\n', '  bool locked = false;\n', '\n', '  modifier whenUnlocked() {\n', '    require(!locked);\n', '    _;\n', '  }\n', '\n', '  function issue(address[] memory addr, uint256[] memory amount) public onlyOwner whenUnlocked {\n', '    require(addr.length == amount.length);\n', '    uint8 i;\n', '    uint256 sum = 0;\n', '    for (i = 0; i < addr.length; ++i) {\n', '      balanceOf[addr[i]] = amount[i];\n', '      emit Transfer(address(0x0), addr[i], amount[i]);\n', '      sum += amount[i];\n', '    }\n', '    totalSupply += sum;\n', '  }\n', '\n', '  function lock() internal onlyOwner whenUnlocked {\n', '    locked = true;\n', '  }\n', '}\n', '\n', 'contract WisdomToken is ERCTransferFrom, Pausable, Issuable {\n', '  constructor() {\n', "    name = 'Wisdom Token';\n", "    symbol = 'WIS';\n", '    decimals = 18;\n', '    totalSupply = 0;\n', '  }\n', '\n', '  function _transfer(address sender, address recipient, uint256 amount) internal whenNotPaused override returns (bool) {\n', '    return _transfer(sender, recipient, amount);\n', '  }\n', '\n', '  function alive(address owner) public {\n', '    lock();\n', '    unpause();\n', '    transferOwnership(owner);\n', '  }\n', '}']