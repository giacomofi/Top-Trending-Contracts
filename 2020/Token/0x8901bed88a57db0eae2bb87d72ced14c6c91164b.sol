['pragma solidity ^0.4.11;\n', 'contract YFIProductToken { // set contract name to token name\n', '   \n', 'string public name; \n', 'string public symbol; \n', 'uint8 public decimals;\n', 'uint256 public totalSupply;\n', ' \n', '// Balances for each account\n', 'mapping(address => uint256) balances;\n', 'address devAddress;\n', '// Events\n', 'event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', 'event Transfer(address indexed from, address indexed to, uint256 value);\n', ' \n', '// Owner of account approves the transfer of an amount to another account\n', 'mapping(address => mapping (address => uint256)) allowed;\n', '// This is the constructor and automatically runs when the smart contract is uploaded\n', 'function YFIProductToken() { // Set the constructor to the same name as the contract name\n', '    name = "YFI Product token"; // set the token name here\n', '    symbol = "YFIP"; // set the Symbol here\n', '    decimals = 18; // set the number of decimals\n', '    devAddress=0xCcceEe536f050f821a52a8bb3A00d19118C7387D; // Add the address that you will distribute tokens from here\n', '    uint initialBalance=1000000000000000000*100000; // 1M tokens\n', '    balances[devAddress]=initialBalance;\n', '    totalSupply+=initialBalance; // Set the total suppy\n', '}\n', 'function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '}\n', "// Transfer the balance from owner's account to another account\n", 'function transfer(address _to, uint256 _amount) returns (bool success) {\n', '    if (balances[msg.sender] >= _amount \n', '        && _amount > 0\n', '        && balances[_to] + _amount > balances[_to]) {\n', '        balances[msg.sender] -= _amount;\n', '        balances[_to] += _amount;\n', '        Transfer(msg.sender, _to, _amount); \n', '        return true;\n', '    } else {\n', '        return false;\n', '    }\n', '}\n', 'function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _amount\n', ') returns (bool success) {\n', '    if (balances[_from] >= _amount\n', '        && allowed[_from][msg.sender] >= _amount\n', '        && _amount > 0\n', '        && balances[_to] + _amount > balances[_to]) {\n', '        balances[_from] -= _amount;\n', '        allowed[_from][msg.sender] -= _amount;\n', '        balances[_to] += _amount;\n', '        return true;\n', '    } else {\n', '        return false;\n', '    }\n', '}\n', '// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '// If this function is called again it overwrites the current allowance with _value.\n', 'function approve(address _spender, uint256 _amount) returns (bool success) {\n', '    allowed[msg.sender][_spender] = _amount;\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '}\n', '}']