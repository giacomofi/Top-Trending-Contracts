['pragma solidity 0.5.12;\n', '\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y > 0, "ds-math-div-overflow");\n', '        z = x / y;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC20SafeTransfer {\n', '    function doTransferOut(\n', '        address _token,\n', '        address _to,\n', '        uint256 _amount\n', '    ) internal returns (bool) {\n', '        IERC20 token = IERC20(_token);\n', '        bool result;\n', '\n', '        token.transfer(_to, _amount);\n', '\n', '        assembly {\n', '            switch returndatasize()\n', '                case 0 {\n', '                    result := not(0)\n', '                }\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    result := mload(0)\n', '                }\n', '                default {\n', '                    revert(0, 0)\n', '                }\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function doTransferFrom(\n', '        address _token,\n', '        address _from,\n', '        address _to,\n', '        uint256 _amount\n', '    ) internal returns (bool) {\n', '        IERC20 token = IERC20(_token);\n', '        bool result;\n', '\n', '        token.transferFrom(_from, _to, _amount);\n', '\n', '        assembly {\n', '            switch returndatasize()\n', '                case 0 {\n', '                    result := not(0)\n', '                }\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    result := mload(0)\n', '                }\n', '                default {\n', '                    revert(0, 0)\n', '                }\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function doApprove(\n', '        address _token,\n', '        address _to,\n', '        uint256 _amount\n', '    ) internal returns (bool) {\n', '        IERC20 token = IERC20(_token);\n', '        bool result;\n', '\n', '        token.approve(_to, _amount);\n', '\n', '        assembly {\n', '            switch returndatasize()\n', '                case 0 {\n', '                    result := not(0)\n', '                }\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    result := mload(0)\n', '                }\n', '                default {\n', '                    revert(0, 0)\n', '                }\n', '        }\n', '        return result;\n', '    }\n', '}\n', '\n', 'interface DFStore {\n', '    function getFeeRate(uint ct) external view returns (uint);\n', '    function getMinBurnAmount() external view returns (uint);\n', '}\n', '\n', 'interface IUniswapV2Router {\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', '\n', 'interface DFProtocolView {\n', '    function getPrice(uint _tokenIdx) external view returns (uint);\n', '    function getFeeRate(uint _processIdx) external view returns (uint);\n', '}\n', '\n', 'interface DFProtocol{\n', '    function deposit(address _tokenID, uint _feeTokenIdx, uint _tokenAmount) external returns (uint);\n', '    function destroy(uint _feeTokenIdx, uint _usdxAmount) external;\n', '}\n', '\n', 'interface Curve {\n', '    function exchange_underlying(int128 inputIndex, int128 outputIndex, uint256 inputAmount, uint256 minOutput) external;\n', '}\n', '\n', 'interface IChi {\n', '    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n', '}\n', '\n', 'contract Ownable {\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() external view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) external onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract swapUSDx is ERC20SafeTransfer, Ownable {\n', '    using SafeMath for uint256;\n', '    uint256 private BASE = 10 ** 18;\n', '\n', '    event SwapUSDx(address targetToken, uint256 inputAmount, uint256 outputAmount);\n', '\n', '    constructor () public {\n', '        _owner = msg.sender;\n', '    }\n', '\n', '    IChi public chi = IChi(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n', '\n', '    address internal USDx = 0xeb269732ab75A6fD61Ea60b06fE994cD32a83549;\n', '    address internal DF = 0x431ad2ff6a9C365805eBaD47Ee021148d6f7DBe0;\n', '\n', '    address internal DFEngineContract = 0x3ea496977A356024bE096c1068a57Bd0B92c7d7c;\n', '    DFProtocol internal DFProtocolContract = DFProtocol(0x5843F1Ccc5baA448528eb0e8Bc567Cda7eD1A1E8);\n', '    DFProtocolView internal DFProtocolViewContract = DFProtocolView(0x097Dd22173f0e382daE42baAEb9bDBC9fdf3396F);\n', '    DFStore internal DFStoreContract = DFStore(0xD30d06b276867CfA2266542791242fF37C91BA8d);\n', '\n', '    address internal yPool = 0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51;\n', '    address internal paxPool = 0x06364f10B501e868329afBc005b3492902d6C763;\n', '    address internal sUSD = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\n', '\n', '    address internal uniswapRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '\n', '    address[] public underlyingTokens = [\n', '        0x8E870D67F660D95d5be530380D0eC0bd388289E1, // PAX\n', '        0x0000000000085d4780B73119b644AE5ecd22b376, // TUSD\n', '        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48  // USDC\n', '    ];\n', '\n', '    address internal USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '\n', '    modifier discountCHI {\n', '        uint256 gasStart = gasleft();\n', '        _;\n', '        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 *  msg.data.length;\n', '        chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\n', '    }\n', '\n', '    /**\n', '     * @dev Based on current DF price and the amount of USDx, calculate how many DF does the\n', '     *      `msg.sender` need when destroies USDx.\n', '     * @param _amount Total amount of USDx would be destroied.\n', '     */\n', '    function getDFAmount(uint256 _amount) internal view returns (uint256) {\n', '        // 0 means DF\n', '        uint256 _dfPrice =  DFProtocolViewContract.getPrice(uint256(0));\n', '        // 1 means this processing is `destroy`\n', '        uint256 _rate = DFProtocolViewContract.getFeeRate(uint256(1));\n', '        uint256 _dfAmount = _amount.mul(_rate).mul(BASE).div(uint256(10000).mul(_dfPrice));\n', '        return _dfAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate how many USDx will the `msg.sender` cost when wants to get a specific\n', '     *      amount of DF.\n', '     * @param _amount Total amount of DF would be cost.\n', '     */\n', '    function getSpendingUSDxAmount(uint256 _amount) internal view returns (uint256) {\n', '        address[] memory _path = new address[](2);\n', '        _path[0] = USDx;\n', '        _path[1] = DF;\n', '        uint[] memory _returnAmounts = IUniswapV2Router(uniswapRouter).getAmountsIn(_amount, _path);\n', '        return _returnAmounts[0];\n', '    }\n', '\n', '    /**\n', '     * @dev Uses this function to prepare for all authority needed.\n', '     */\n', '    function multiApprove() external onlyOwner discountCHI returns (bool) {\n', '        // When swaps USDx to DF in the uniswap.\n', '        require(doApprove(USDx, uniswapRouter, uint256(-1)), "multiApprove: approve uniswap failed!");\n', '        // When destroy USDx.\n', '        // - 1. DF.approve(DFEngineContract, -1)\n', '        require(doApprove(DF, DFEngineContract, uint256(-1)), "multiApprove: DF approves DFEngine failed!");\n', '        // - 2. USDx.approve(DFEngineContract, -1)\n', '        require(doApprove(USDx, DFEngineContract, uint256(-1)), "multiApprove: USDx approves DFEngine failed!");\n', '        // When swaps token to get USDC\n', '        require(doApprove(underlyingTokens[0], paxPool, uint256(-1)), "multiApprove: PAX approves paxpool failed!");\n', '        require(doApprove(underlyingTokens[1], yPool, uint256(-1)), "multiApprove: TUSD approves ypool failed!");\n', '        // When swaps token to get USDT\n', '        require(doApprove(underlyingTokens[2], sUSD, uint256(-1)), "multiApprove: USDC approves sUSD failed!");\n', '    }\n', '\n', '    /**\n', '     * @dev Swaps USDx to DF in the Uniswap.\n', '     * @param _inputAmount Amount of USDx to swap to get DF.\n', '     */\n', '    function swapUSDxToDF(uint256 _inputAmount) internal {\n', '        uint256 _dfAmount =  getDFAmount(_inputAmount);\n', '        uint256 _expectedUSDxAmount = getSpendingUSDxAmount(_dfAmount);\n', '        uint256 _usdxAmount =  _expectedUSDxAmount % DFStoreContract.getMinBurnAmount() > 0\n', '                              ? (_expectedUSDxAmount / DFStoreContract.getMinBurnAmount() + 1) * DFStoreContract.getMinBurnAmount()\n', '                              : _expectedUSDxAmount ;\n', '\n', '        address[] memory _path = new address[](2);\n', '        _path[0] = USDx;\n', '        _path[1] = DF;\n', '\n', '        // swap parts of USDx to DF.\n', '        IUniswapV2Router(uniswapRouter).swapExactTokensForTokens(\n', '            _usdxAmount,\n', '            _dfAmount,\n', '            _path,\n', '            address(this),\n', '            block.timestamp + 3600\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the final amount of target token when swaps.\n', '     * @param _targetToken Asset that swaps to get.\n', '     * @param _inputAmount Amount to swap.\n', '     * @param _minReturn Minimum amount to get when swaps.\n', '     */\n', '    function getAmountOut(address _targetToken, uint256 _inputAmount, uint256 _minReturn) external returns (uint256) {\n', '        // transfer USDx from user to this contract.\n', '        require(\n', '            doTransferFrom(\n', '                USDx,\n', '                msg.sender,\n', '                address(this),\n', '                _inputAmount\n', '            ),\n', '            "swap: USDx transferFrom failed!"\n', '        );\n', '\n', '        swapUSDxToDF(_inputAmount);\n', '\n', '        // destroy the remaining USDx with DF.\n', '        DFProtocolContract.destroy(0, IERC20(USDx).balanceOf(address(this)));\n', '\n', '        if (_targetToken == underlyingTokens[2]){\n', '            // TUSD -> USDC\n', '            uint256 _totalAmount = IERC20(underlyingTokens[1]).balanceOf(address(this));\n', '            Curve(yPool).exchange_underlying(int128(3), int128(1), _totalAmount,uint256(0));\n', '            // PAX -> USDC\n', '            _totalAmount = IERC20(underlyingTokens[0]).balanceOf(address(this));\n', '            Curve(paxPool).exchange_underlying(int128(3), int128(1), _totalAmount,uint256(0));\n', '        } else if (_targetToken == USDT) {\n', '            // USDC -> USDT\n', '            uint256 _totalAmount = IERC20(underlyingTokens[2]).balanceOf(address(this));\n', '            Curve(sUSD).exchange_underlying(int128(1), int128(2), _totalAmount,uint256(0));\n', '            // TUSD -> USDT\n', '            _totalAmount = IERC20(underlyingTokens[1]).balanceOf(address(this));\n', '            Curve(yPool).exchange_underlying(int128(3), int128(2), _totalAmount,uint256(0));\n', '            // PAX -> USDC\n', '            _totalAmount = IERC20(underlyingTokens[0]).balanceOf(address(this));\n', '            Curve(paxPool).exchange_underlying(int128(3), int128(2), _totalAmount,uint256(0));\n', '        }\n', '\n', '        uint256 _finalBalance = IERC20(_targetToken).balanceOf(address(this));\n', '        // transfer target token to caller`msg.sender`\n', '        require(doTransferOut(_targetToken, msg.sender, _finalBalance), "swap: Transfer targetToken out failed!");\n', '        require(doTransferOut(DF, msg.sender, IERC20(DF).balanceOf(address(this))), "swap: Transfer DF out failed!");\n', '\n', '        emit SwapUSDx(_targetToken, _inputAmount, _finalBalance);\n', '        return _finalBalance;\n', '    }\n', '\n', '    /**\n', '     * @dev Swaps token to get target token.\n', '     * @param _targetToken Asset that swaps to get.\n', '     * @param _inputAmount Amount to swap.\n', '     * @param _minReturn Minimum amount to get when swaps.\n', '     */\n', '    function swapUSDxTo(address _targetToken, uint256 _inputAmount, uint256 _minReturn) public discountCHI returns (uint256) {\n', '        // transfer USDx from user to this contract.\n', '        require(\n', '            doTransferFrom(\n', '                USDx,\n', '                msg.sender,\n', '                address(this),\n', '                _inputAmount\n', '            ),\n', '            "swap: USDx transferFrom failed!"\n', '        );\n', '\n', '        swapUSDxToDF(_inputAmount);\n', '\n', '        // destroy the remaining USDx with DF.\n', '        DFProtocolContract.destroy(0, IERC20(USDx).balanceOf(address(this)));\n', '\n', '        if (_targetToken == underlyingTokens[2]){\n', '            // TUSD -> USDC\n', '            uint256 _totalAmount = IERC20(underlyingTokens[1]).balanceOf(address(this));\n', '            Curve(yPool).exchange_underlying(int128(3), int128(1), _totalAmount, uint256(0));\n', '            // PAX -> USDC\n', '            _totalAmount = IERC20(underlyingTokens[0]).balanceOf(address(this));\n', '            Curve(paxPool).exchange_underlying(int128(3), int128(1), _totalAmount, uint256(0));\n', '        } else if (_targetToken == USDT) {\n', '            // USDC -> USDT\n', '            uint256 _totalAmount = IERC20(underlyingTokens[2]).balanceOf(address(this));\n', '            Curve(sUSD).exchange_underlying(int128(1), int128(2), _totalAmount, uint256(0));\n', '            // TUSD -> USDT\n', '            _totalAmount = IERC20(underlyingTokens[1]).balanceOf(address(this));\n', '            Curve(yPool).exchange_underlying(int128(3), int128(2), _totalAmount, uint256(0));\n', '            // PAX -> USDC\n', '            _totalAmount = IERC20(underlyingTokens[0]).balanceOf(address(this));\n', '            Curve(paxPool).exchange_underlying(int128(3), int128(2), _totalAmount, uint256(0));\n', '        }\n', '\n', '        uint256 _finalBalance = IERC20(_targetToken).balanceOf(address(this));\n', '        require(_finalBalance >= _minReturn, "swap: Too large slippage to succeed!");\n', '        // transfer target token to caller`msg.sender`\n', '        require(doTransferOut(_targetToken, msg.sender, _finalBalance), "swap: Transfer targetToken out failed!");\n', '        require(doTransferOut(DF, msg.sender, IERC20(DF).balanceOf(address(this))), "swap: Transfer DF out failed!");\n', '\n', '        emit SwapUSDx(_targetToken, _inputAmount, _finalBalance);\n', '        return _finalBalance;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer unexpected toke out, but only for owner.\n', '     */\n', '    function transferOut(address _token, address _to, uint256 _amount) external onlyOwner {\n', '        require(\n', '            doTransferOut(\n', '                _token,\n', '                _to,\n', '                _amount\n', '            ),\n', '            "transferOut: Transfer token out failed!"\n', '        );\n', '    }\n', '\n', '}']