['// File: contracts/zeppelin/MerkleProof.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '/**\n', ' * @dev These functions deal with verification of Merkle trees (hash trees),\n', ' */\n', 'library MerkleProof {\n', '    /**\n', '     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n', '     * defined by `root`. For this, a `proof` must be provided, containing\n', '     * sibling hashes on the branch from the leaf to the root of the tree. Each\n', '     * pair of leaves and each pair of pre-images are assumed to be sorted.\n', '     */\n', '    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n', '        bytes32 computedHash = leaf;\n', '\n', '        for (uint256 i = 0; i < proof.length; i++) {\n', '            bytes32 proofElement = proof[i];\n', '\n', '            if (computedHash <= proofElement) {\n', '                // Hash(current computed hash + current element of the proof)\n', '                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n', '            } else {\n', '                // Hash(current element of the proof + current computed hash)\n', '                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n', '            }\n', '        }\n', '\n', '        // Check if the computed hash (root) is equal to the provided root\n', '        return computedHash == root;\n', '    }\n', '}\n', '\n', '// File: contracts/IManager.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', 'contract IManager {\n', '    event SetController(address controller);\n', '    event ParameterUpdate(string param);\n', '\n', '    function setController(address _controller) external;\n', '}\n', '\n', '// File: contracts/zeppelin/Ownable.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/zeppelin/Pausable.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    */\n', '    function pause() public onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to unpause, returns to normal state\n', '    */\n', '    function unpause() public onlyOwner whenPaused {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', '// File: contracts/IController.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', 'contract IController is Pausable {\n', '    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);\n', '\n', '    function setContractInfo(bytes32 _id, address _contractAddress, bytes20 _gitCommitHash) external;\n', '    function updateController(bytes32 _id, address _controller) external;\n', '    function getContract(bytes32 _id) public view returns (address);\n', '}\n', '\n', '// File: contracts/Manager.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', '\n', 'contract Manager is IManager {\n', '    // Controller that contract is registered with\n', '    IController public controller;\n', '\n', '    // Check if sender is controller\n', '    modifier onlyController() {\n', '        require(msg.sender == address(controller), "caller must be Controller");\n', '        _;\n', '    }\n', '\n', '    // Check if sender is controller owner\n', '    modifier onlyControllerOwner() {\n', '        require(msg.sender == controller.owner(), "caller must be Controller owner");\n', '        _;\n', '    }\n', '\n', '    // Check if controller is not paused\n', '    modifier whenSystemNotPaused() {\n', '        require(!controller.paused(), "system is paused");\n', '        _;\n', '    }\n', '\n', '    // Check if controller is paused\n', '    modifier whenSystemPaused() {\n', '        require(controller.paused(), "system is not paused");\n', '        _;\n', '    }\n', '\n', '    constructor(address _controller) public {\n', '        controller = IController(_controller);\n', '    }\n', '\n', '    /**\n', '     * @notice Set controller. Only callable by current controller\n', '     * @param _controller Controller contract address\n', '     */\n', '    function setController(address _controller) external onlyController {\n', '        controller = IController(_controller);\n', '\n', '        emit SetController(_controller);\n', '    }\n', '}\n', '\n', '// File: contracts/snapshots/MerkleSnapshot.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', '\n', 'contract MerkleSnapshot is Manager {\n', '    mapping (bytes32 => bytes32) public snapshot;\n', '\n', '    constructor(address _controller) public Manager(_controller) {}\n', '\n', '    function setSnapshot(bytes32 _id, bytes32 _root) external onlyControllerOwner {\n', '        snapshot[_id] = _root;\n', '    }\n', '\n', '    function verify(bytes32 _id, bytes32[] calldata _proof, bytes32 _leaf) external view returns (bool) {\n', '        return MerkleProof.verify(_proof, snapshot[_id], _leaf);\n', '    }\n', '}']