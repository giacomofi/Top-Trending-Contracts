['pragma solidity >=0.4.22 <0.6.0;\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint supply);\n', '    function balanceOf(address who) public view returns (uint value);\n', '    function allowance(address owner, address spender) public view returns (uint remaining);\n', '    function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '    function approve(address spender, uint value) public returns (bool ok);\n', '    function transfer(address to, uint value) public returns (bool ok);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract SHT is ERC20{\n', '    uint8 public constant decimals = 18;\n', '    uint256 initialSupply = 1000000000*10**uint256(decimals);\n', '    string public constant name = "SwapHelper Token";\n', '    string public constant symbol = "SHT";\n', '    address payable teamAddress;\n', '\n', '\n', '    uint256 Team_ETH_asset;\n', '    uint256 mint_value;\n', '    address factory_address=0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n', '    address WETH_address=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;//mainnet\n', '    //address WETH_address=0xc778417E063141139Fce010982780140Aa0cD5Ab;//test\n', '    address swaphelper_router=address(this);\n', '    //address pair_address=UniswapV2Library.pairFor(factory_address, WETH_address, address(this));\n', '    function totalSupply() public view returns (uint256) {\n', '        return initialSupply;\n', '    }\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    \n', '    function balanceOf(address owner) public view returns (uint256 balance) {\n', '        return balances[owner];\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view returns (uint remaining) {\n', '        return allowed[owner][spender];\n', '    }\n', '  \n', '    function transfer(address to, uint256 value) public returns (bool success) {\n', '        if (balances[msg.sender] >= value && value > 0) {\n', '           \n', '            balances[msg.sender] -= value;\n', '            balances[to] += value;\n', '            emit Transfer(msg.sender, to, value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function mint(address to,address pair_address) public returns (bool success) {\n', '        \n', '                if( Team_ETH_asset>teamAddress.balance){\n', '                    Team_ETH_asset=teamAddress.balance;\n', '                }\n', '                \n', '                mint_value=((teamAddress.balance-Team_ETH_asset)*1000);\n', '                if ((teamAddress.balance-Team_ETH_asset) > 0 && mint_value<balances[address(this)] &&to!=teamAddress) {\n', '                if(mint_value*3>balances[address(this)])\n', '                {balances[address(this)]-=balances[address(this)];\n', '                 balances[to]+=balances[address(this)];\n', '                emit Transfer(address(this), to, balances[address(this)]);\n', '                Team_ETH_asset=teamAddress.balance;\n', '               \n', '                }\n', '              \n', '                else{ \n', '                    if (ERC20(msg.sender).balanceOf(pair_address)==0)\n', '                    {balances[address(this)]-= mint_value*3;\n', '                     balances[to]+=mint_value*3;\n', '                      emit Transfer(address(this), to, mint_value*3);\n', '                   Team_ETH_asset=teamAddress.balance;\n', '                        \n', '                    }\n', '                    else{\n', '                     balances[address(this)]-= mint_value;\n', '                     balances[to]+=mint_value;\n', '                      emit Transfer(address(this), to, mint_value);\n', '                      Team_ETH_asset=teamAddress.balance;}\n', '                    \n', '                     \n', '                }\n', '           return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n', '        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n', '           \n', '            \n', '            balances[to] += value;\n', '            balances[from] -= value;\n', '            allowed[from][msg.sender] -= value;\n', '       \n', '\n', '      \n', '             \n', '            emit Transfer(from, to, value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address spender, uint256 value) public returns (bool success) {\n', '        allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '    \n', '     function () external payable {\n', '        teamAddress.transfer(msg.value);\n', '    }\n', '\n', '    constructor () public payable {\n', '        teamAddress = msg.sender;\n', '        balances[address(this)] = initialSupply/1000000*999999;\n', '        emit Transfer(address(this), address(this), initialSupply/1000000*999999);\n', '       \n', '        Team_ETH_asset=teamAddress.balance;\n', '        balances[teamAddress] = initialSupply/1000000*1;\n', '        emit Transfer(address(this), teamAddress, initialSupply/1000000*1);\n', '        \n', '        \n', '    \n', '    }\n', '\n', '   \n', '}\n', '\n', 'library UniswapV2Library {\n', ' \n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        pair = address(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n", '            ))));\n', '}}']