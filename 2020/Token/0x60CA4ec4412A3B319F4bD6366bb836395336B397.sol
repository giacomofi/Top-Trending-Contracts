['// File: contracts\\thirdParty\\interfaces\\IERC1820Registry.sol\n', '\n', '// From open https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/introspection/IERC1820Registry.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Interface of the global ERC1820 Registry, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n', ' * implementers for interfaces in this registry, as well as query support.\n', ' *\n', ' * Implementers may be shared by multiple accounts, and can also implement more\n', ' * than a single interface for each account. Contracts can implement interfaces\n', ' * for themselves, but externally-owned accounts (EOA) must delegate this to a\n', ' * contract.\n', ' *\n', ' * {IERC165} interfaces can also be queried via the registry.\n', ' *\n', ' * For an in-depth explanation and source code analysis, see the EIP text.\n', ' */\n', 'interface IERC1820Registry {\n', '    /**\n', '     * @dev Sets `newManager` as the manager for `account`. A manager of an\n', '     * account is able to set interface implementers for it.\n', '     *\n', '     * By default, each account is its own manager. Passing a value of `0x0` in\n', '     * `newManager` will reset the manager to this initial state.\n', '     *\n', '     * Emits a {ManagerChanged} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be the current manager for `account`.\n', '     */\n', '    function setManager(address account, address newManager) external;\n', '\n', '    /**\n', '     * @dev Returns the manager for `account`.\n', '     *\n', '     * See {setManager}.\n', '     */\n', '    function getManager(address account) external view returns (address);\n', '\n', '    /**\n', "     * @dev Sets the `implementer` contract as ``account``'s implementer for\n", '     * `interfaceHash`.\n', '     *\n', "     * `account` being the zero address is an alias for the caller's address.\n", '     * The zero address can also be used in `implementer` to remove an old one.\n', '     *\n', '     * See {interfaceHash} to learn how these are created.\n', '     *\n', '     * Emits an {InterfaceImplementerSet} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be the current manager for `account`.\n', '     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n', '     * end in 28 zeroes).\n', '     * - `implementer` must implement {IERC1820Implementer} and return true when\n', '     * queried for support, unless `implementer` is the caller. See\n', '     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n', '     */\n', '    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n', '\n', '    /**\n', '     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n', '     * implementer is registered, returns the zero address.\n', '     *\n', '     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n', '     * zeroes), `account` will be queried for support of it.\n', '     *\n', "     * `account` being the zero address is an alias for the caller's address.\n", '     */\n', '    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n', '     * corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n', '     */\n', '    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n', '\n', '    /**\n', '     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n', '     *  @param account Address of the contract for which to update the cache.\n', '     *  @param interfaceId ERC165 interface for which to update the cache.\n', '     */\n', '    function updateERC165Cache(address account, bytes4 interfaceId) external;\n', '\n', '    /**\n', '     *  @notice Checks whether a contract implements an ERC165 interface or not.\n', '     *  If the result is not cached a direct lookup on the contract address is performed.\n', '     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n', '     *  {updateERC165Cache} with the contract address.\n', '     *  @param account Address of the contract to check.\n', '     *  @param interfaceId ERC165 interface to check.\n', '     *  @return True if `account` implements `interfaceId`, false otherwise.\n', '     */\n', '    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n', '\n', '    /**\n', '     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n', '     *  @param account Address of the contract to check.\n', '     *  @param interfaceId ERC165 interface to check.\n', '     *  @return True if `account` implements `interfaceId`, false otherwise.\n', '     */\n', '    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n', '\n', '    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n', '\n', '    event ManagerChanged(address indexed account, address indexed newManager);\n', '}\n', '\n', '// File: contracts\\interfaces\\IERC777Sender.sol\n', '\n', 'pragma solidity 0.6.7;\n', '\n', "// As defined in the 'ERC777TokensSender And The tokensToSend Hook' section of https://eips.ethereum.org/EIPS/eip-777\n", 'interface IERC777Sender {\n', '  function tokensToSend(address operator, address from, address to, uint256 amount, bytes calldata data,\n', '      bytes calldata operatorData) external;\n', '}\n', '\n', '// File: contracts\\interfaces\\IERC777Recipient.sol\n', '\n', 'pragma solidity 0.6.7;\n', '\n', "// As defined in the 'ERC777TokensRecipient And The tokensReceived Hook' section of https://eips.ethereum.org/EIPS/eip-777\n", 'interface IERC777Recipient {\n', '  function tokensReceived(address operator, address from, address to, uint256 amount, bytes calldata data,\n', '      bytes calldata operatorData) external;\n', '}\n', '\n', '// File: contracts\\thirdParty\\SafeMath.sol\n', '\n', '// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts\\libraries\\LToken.sol\n', '\n', 'pragma solidity 0.6.7;\n', '\n', '\n', '\n', '\n', '\n', 'struct TokenState {\n', '  uint256 totalSupply;\n', '  mapping(address => uint256) balances;\n', '  mapping(address => mapping(address => uint256)) approvals;\n', '  mapping(address => mapping(address => bool)) authorizedOperators;\n', '  address[] defaultOperators;\n', '  mapping(address => bool) defaultOperatorIsRevoked;\n', '  mapping(address => bool) minters;\n', '}\n', '\n', 'library LToken {\n', '  using SafeMath for uint256;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Sent(address indexed operator, address indexed from, address indexed to, uint256 amount, bytes data,\n', '      bytes operatorData);\n', '  event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n', '  event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n', '  event AuthorizedOperator(address indexed operator, address indexed holder);\n', '  event RevokedOperator(address indexed operator, address indexed holder);\n', '\n', '  // Universal address as defined in Registry Contract Address section of https://eips.ethereum.org/EIPS/eip-1820\n', '  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n', '  // precalculated hashes - see https://github.com/ethereum/solidity/issues/4024\n', '  // keccak256("ERC777TokensSender")\n', '  bytes32 constant internal ERC777_TOKENS_SENDER_HASH = 0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n', '  // keccak256("ERC777TokensRecipient")\n', '  bytes32 constant internal ERC777_TOKENS_RECIPIENT_HASH = 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n', '\n', '  modifier checkSenderNotOperator(address _operator) {\n', '    require(_operator != msg.sender, "Cannot be operator for self");\n', '    _;\n', '  }\n', '\n', '  function initState(TokenState storage _tokenState, uint8 _decimals, uint256 _initialSupply)\n', '    external\n', '  {\n', '    _tokenState.defaultOperators.push(address(this));\n', '    _tokenState.totalSupply = _initialSupply.mul(10**uint256(_decimals));\n', '    _tokenState.balances[msg.sender] = _tokenState.totalSupply;\n', '  }\n', '\n', '  function transferFrom(TokenState storage _tokenState, address _from, address _to, uint256 _value)\n', '    external\n', '  {\n', '    _tokenState.approvals[_from][msg.sender] = _tokenState.approvals[_from][msg.sender].sub(_value, "Amount not approved");\n', '    doSend(_tokenState, msg.sender, _from, _to, _value, "", "", false);\n', '  }\n', '\n', '  function approve(TokenState storage _tokenState, address _spender, uint256 _value)\n', '    external\n', '  {\n', '    require(_spender != address(0), "Cannot approve to zero address");\n', '    _tokenState.approvals[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  function authorizeOperator(TokenState storage _tokenState, address _operator)\n', '    checkSenderNotOperator(_operator)\n', '    external\n', '  {\n', '    if (_operator == address(this))\n', '      _tokenState.defaultOperatorIsRevoked[msg.sender] = false;\n', '    else\n', '      _tokenState.authorizedOperators[_operator][msg.sender] = true;\n', '    emit AuthorizedOperator(_operator, msg.sender);\n', '  }\n', '\n', '  function revokeOperator(TokenState storage _tokenState, address _operator)\n', '    checkSenderNotOperator(_operator)\n', '    external\n', '  {\n', '    if (_operator == address(this))\n', '      _tokenState.defaultOperatorIsRevoked[msg.sender] = true;\n', '    else\n', '      _tokenState.authorizedOperators[_operator][msg.sender] = false;\n', '    emit RevokedOperator(_operator, msg.sender);\n', '  }\n', '\n', '  function authorizeMinter(TokenState storage _tokenState, address _minter)\n', '    external\n', '  {\n', '    _tokenState.minters[_minter] = true;\n', '  }\n', '\n', '  function revokeMinter(TokenState storage _tokenState, address _minter)\n', '    external\n', '  {\n', '    _tokenState.minters[_minter] = false;\n', '  }\n', '\n', '  function doMint(TokenState storage _tokenState, address _to, uint256 _amount)\n', '    external\n', '  {\n', '    assert(_to != address(0));\n', '\n', '    _tokenState.totalSupply = _tokenState.totalSupply.add(_amount);\n', '    _tokenState.balances[_to] = _tokenState.balances[_to].add(_amount);\n', '\n', '    // From ERC777: The token contract MUST call the tokensReceived hook after updating the state.\n', '    receiveHook(address(this), address(0), _to, _amount, "", "", true);\n', '\n', '    emit Minted(address(this), _to, _amount, "", "");\n', '    emit Transfer(address(0), _to, _amount);\n', '  }\n', '\n', '  function doBurn(TokenState storage _tokenState, address _operator, address _from, uint256 _amount, bytes calldata _data,\n', '      bytes calldata _operatorData)\n', '    external\n', '  {\n', '    assert(_from != address(0));\n', '    // From ERC777: The token contract MUST call the tokensToSend hook before updating the state.\n', '    sendHook(_operator, _from, address(0), _amount, _data, _operatorData);\n', '\n', '    _tokenState.balances[_from] = _tokenState.balances[_from].sub(_amount, "Cannot burn more than balance");\n', '    _tokenState.totalSupply = _tokenState.totalSupply.sub(_amount);\n', '\n', '    emit Burned(_operator, _from, _amount, _data, _operatorData);\n', '    emit Transfer(_from, address(0), _amount);\n', '  }\n', '\n', '  function doSend(TokenState storage _tokenState, address _operator, address _from, address _to, uint256 _amount,\n', '      bytes memory _data, bytes memory _operatorData, bool _enforceERC777)\n', '    public\n', '  {\n', '    assert(_from != address(0));\n', '\n', '    require(_to != address(0), "Cannot send funds to 0 address");\n', '    // From ERC777: The token contract MUST call the tokensToSend hook before updating the state.\n', '    sendHook(_operator, _from, _to, _amount, _data, _operatorData);\n', '\n', '    _tokenState.balances[_from] = _tokenState.balances[_from].sub(_amount, "Amount exceeds available funds");\n', '    _tokenState.balances[_to] = _tokenState.balances[_to].add(_amount);\n', '\n', '    emit Sent(_operator, _from, _to, _amount, _data, _operatorData);\n', '    emit Transfer(_from, _to, _amount);\n', '\n', '    // From ERC777: The token contract MUST call the tokensReceived hook after updating the state.\n', '    receiveHook(_operator, _from, _to, _amount, _data, _operatorData, _enforceERC777);\n', '  }\n', '\n', '  function receiveHook(address _operator, address _from, address _to, uint256 _amount, bytes memory _data,\n', '      bytes memory _operatorData, bool _enforceERC777)\n', '    public\n', '  {\n', '    address implementer = ERC1820_REGISTRY.getInterfaceImplementer(_to, ERC777_TOKENS_RECIPIENT_HASH);\n', '    if (implementer != address(0))\n', '      IERC777Recipient(implementer).tokensReceived(_operator, _from, _to, _amount, _data, _operatorData);\n', '    else if (_enforceERC777)\n', '      require(!isContract(_to), "Must be registered with ERC1820");\n', '  }\n', '\n', '  function sendHook(address _operator, address _from, address _to, uint256 _amount, bytes memory _data,\n', '      bytes memory _operatorData)\n', '    public\n', '  {\n', '    address implementer = ERC1820_REGISTRY.getInterfaceImplementer(_from, ERC777_TOKENS_SENDER_HASH);\n', '    if (implementer != address(0))\n', '      IERC777Sender(implementer).tokensToSend(_operator, _from, _to, _amount, _data, _operatorData);\n', '  }\n', '\n', '  function isContract(address _account)\n', '    private\n', '    view\n', '    returns (bool isContract_)\n', '  {\n', '    uint256 size;\n', '\n', '    assembly {\n', '      size := extcodesize(_account)\n', '    }\n', '\n', '    isContract_ = size != 0;\n', '  }\n', '}']