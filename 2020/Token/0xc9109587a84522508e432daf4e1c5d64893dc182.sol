['// SPDX-License-Identifier: ECLv2\n', '/**\n', ' * @title TokenHook (THK).\n', ' * @author Currently ANONYMOUS.\n', ' * @notice You may use this code under ECLv2.\n', ' * @dev For new token deployment:\n', ' * 1- Install MetaMask (Chrome/Firefox extension).\n', ' * 2- Connect to Rinkeby (or other private/public chains).\n', ' * 3- Run RemixIDE and set environment as "Injected Web3".\n', ' * 4- Copy and past this code in RemixIDE.\n', ' * 5- Deploy the token contract (ERC20).\n', ' * @dev The code is compatible with version 0.5.x of Solidity complier.\n', ' * Version 0.5.11 has been selected for compatibility with the following auditing tools:\n', ' * 1- EY Review Tool by Ernst & Young Global Limited.\n', ' * 2- SmartCheck by SmartDec.\n', ' * 3- Securify by ChainSecurity.\n', ' * 4- ContractGuard by GuardStrike.\n', ' * 5- MythX by ConsenSys.\n', ' * 6- Slither Analyzer by Crytic.\n', ' * 7- Odin by Sooho.\n', ' */\n', ' \n', 'pragma solidity 0.5.11;\n', '\n', '/**\n', ' * @title ERC20 Interface\n', ' * @author Fabian Vogelsteller, Vitalik Buterin\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', ' */\n', 'interface IERC20 {\n', '    /// Transfers tokens and fires the Transfer event.\n', '    function transfer(address to, uint256 tokens) external returns (bool);\n', '    \n', '    /// Allows to withdraw from your account multiple times, up to the approved tokens.\n', '    function approve(address spender, uint256 tokens) external returns (bool);\n', '    \n', '    /// Transfers approved tokens and fires the Transfer event\n', '    function transferFrom(address from, address to, uint256 tokens) external returns (bool);\n', '\n', '    /// Returns the total token supply\n', '    function totalSupply() external view returns (uint256);\n', '    \n', '    /// Returns token balance of an account\n', '    function balanceOf(address account) external view returns (uint256);\n', '    \n', '    /// Returns the allowed tokens to withdraw from an account\n', '    function allowance(address account, address spender) external view returns (uint256);\n', '\n', '    /// Events\n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '}\n', '\n', '/**\n', " * @title Wrappers over Solidity's arithmetic operations with added overflow checks.\n", ' * @author OpenZeppelin\n', ' * @dev https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.Using this library instead of the unchecked operations\n', " * eliminates an entire class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        /// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        /// benefit is lost if 'b' is also tested.\n", '        /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        /// Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        /// assert(a == b * c + a % b); /// There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 Token contract\n', ' * @dev When verify the code in EtherScan and if you used the default initialSupply,\n', ' * set this value as "Constructor Arguments":\n', ' * 0000000000000000000000000000000000000000000000000000000000000000\n', ' * @dev The token will be created with 18 decimal places,\n', ' * so it takes a balance of 10 ** 18 token units to equal one token.\n', ' * In other word, if we want to have x initial tokens, we need to pass in,\n', ' * x * 10 ** 18 to the constructor.\n', ' */\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\t\t                            /// Attach SafeMath functions with uint256 to mitigate integer overflow\n', '\n', '    string public constant name = "TokenHook";                  /// Token name\n', '    string public constant symbol = "THK";                      /// Token symbol\n', '    uint8 public constant decimals = 18;                        /// Divisible to 18 decimal places\n', '    address payable private owner;                              /// Token owner\n', '    uint256 public exchangeRate = 100;                          /// 100 tokens per 1ETH, default exchange rate\n', '    uint256 private initialSupply = 200e6;                      /// Controls economy of the token by limiting initial supply to 200M\n', '    bool private locked;                                        /// Mutex variable to mitigate re-entrancy attack\n', '    bool private paused;                                        /// Boolean variable to support Fail-Safe mode\n', '    //uint256 private contractBalance = 0;                        /// Can be used for integrity check\n', '\n', '    mapping(address => mapping (address => uint256)) private allowances;\t/// Allowed token to transfer by spenders\n', '    mapping(address => mapping (address => uint256)) private transferred;\t/// Transferred tokens by spenders\n', '    mapping(address => uint256) public balances;                            /// Balance of token holders\n', '\n', '    /**\n', '     * @dev Token constructor that runs only once upon contract creation. The final code of the contract is deployed to the blockchain,\n', '     * after the constructor has run.\n', '     */\n', '    constructor(uint256 supply) public {\n', '        owner = msg.sender;                                                 /// Owner of the token\n', '        initialSupply = (supply != 0) ? supply :                            /// Initialize token supply\n', '                        initialSupply.mul(10 ** uint256(decimals));         /// With 18 zero\n', '        balances[owner] = initialSupply;                                    /// Owner gets all initial tokens\n', '        emit Transfer(address(0), owner, initialSupply);                    /// Logs transferred tokens to the owner\n', '    }\n', '    \n', '    /**\n', '     * @dev Fallback function to accept ETH. It is compatible with 2300 gas for receiving funds via send or transfer methods.\n', '     */\n', '    function() external payable{\n', '        //require(msg.data.length == 0, "Only plain Ether");                  /// Checks for only calls without data\n', '        //contractBalance = contractBalance.add(msg.value);                   /// Adjusting contract balance\n', '        emit Received(msg.sender, msg.value);                               /// Logs received ETH\n', '    }\n', '    \n', '    /**\n', '     * @dev Transfers `tokens` amount of tokens to address `to`, and fires Transfer event. Transferring zero tokens is also allowed.\n', '     */\n', '    function transfer(address to, uint256 tokens) external notPaused validAddress(to) noReentrancy returns (bool success) {\n', '        require(balances[msg.sender] >= tokens, "Not enough balance");          /// Checks the sender\'s balance\n', '        require(balances[to].add(tokens) >= balances[to], "Overflow error");    /// Checks overflows\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);                /// Subtracts from the sender\n', '        balances[to] = balances[to].add(tokens);                                /// Adds to the recipient\n', '        emit Transfer(msg.sender, to, tokens);                                  /// Logs transferred tokens\n', '        return true;\n', '    }\n', ' \n', '    /**\n', '     * @dev Special type of Transfer that makes it possible to give permission to another address for spending tokens on your behalf. \n', '     * It sends `tokens` from address `from` to address `to`. The `transferFrom` method is used for a withdraw work-flow, allowing \n', '     * contracts to send tokens on your behalf, for example to deposit to a contract address and/or to charge fees in sub-currencies.\n', '     * The function call fails unless the `from` account has deliberately authorized the sender of the message via `approve` function.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokens) external notPaused validAddress(to) noReentrancy returns (bool success) {\n', '        require(balances[from] >= tokens, "Not enough tokens");                     /// Checks the sender\'s balance\n', '        require(tokens <= (                                                         /// Prevent token transfer more than allowed\n', '                           (allowances[from][msg.sender] > transferred[from][msg.sender]) ? \n', '                            allowances[from][msg.sender].sub(transferred[from][msg.sender]) : 0)\n', '                            , "Transfer more than allowed");                               \n', '        balances[from] = balances[from].sub(tokens);                                /// Decreases balance of approver\n', '        balances[to] = balances[to].add(tokens);                                    /// Increases balance of spender\n', '        transferred[from][msg.sender] = transferred[from][msg.sender].add(tokens);  /// Tracks transferred tokens\n', '        emit Transfer(from, to, tokens);                                            /// Logs transferred tokens\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev It approves another address to spend tokens on your behalf. It allows `spender` to withdraw from your account, multiple times, \n', '     * up to the `tokens` amount. If this function is called again, it overwrites the current allowance with `tokens`.\n', '     */\n', '    function approve(address spender, uint256 tokens) external notPaused validAddress(spender) noReentrancy returns (bool success) {\n', '        require(spender != msg.sender, "Approver is spender");                      /// Spender cannot approve himself\n', '        require(balances[msg.sender] >= tokens, "Not enough balance");              /// Checks the approver\'s balance\n', '        allowances[msg.sender][spender] = tokens;                                   /// Sets allowance of the spender\n', '        emit Approval(msg.sender, spender, tokens);                                 /// Logs approved tokens\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Implements another way of approving tokens by increasing current approval. It is not defined in the standard.\n', '     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedTokens) external notPaused validAddress(spender) noReentrancy returns (bool success) {\n', '        require(balances[msg.sender] >= addedTokens, "Not enough token");                       /// Checks the approver\'s balance\n', '        allowances[msg.sender][spender] = allowances[msg.sender][spender].add(addedTokens);     /// Adds allowance of the spender\n', '        emit Approval(msg.sender, spender, addedTokens);                                        /// Logs approved tokens\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Implements another way of approving tokens by decreasing current approval. It is not defined in the standard.\n', '     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedTokens) external notPaused validAddress(spender) noReentrancy returns (bool success) {\n', '        require(allowances[msg.sender][spender] >= subtractedTokens, "Not enough token");       /// Checks the spenders\'s allowance\n', '        allowances[msg.sender][spender] = allowances[msg.sender][spender].sub(subtractedTokens);/// Adds allowance of the spender\n', '        emit Approval(msg.sender, spender, subtractedTokens);                                   /// Logs approved tokens\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Supports selling tokens to the contract. It uses msg.sender.call.value() mrthod to be compatible with EIP-1884.\n', '     * In addition to CEI, Mutex (noReentrancy modifier is also used to mitigate cross-function re-entrancy attack (along with same-function re-entrancy).\n', '     */\n', '    function sell(uint256 tokens) external notPaused noReentrancy returns(bool success)\n', '    {\n', '        require(tokens > 0, "No token to sell");                                /// Selling zero token is not allowed\n', '        require(balances[msg.sender] >= tokens, "Not enough token");            /// Checks the seller\'s balance\n', '        uint256 _wei = tokens.div(exchangeRate);                                /// Calculates equivalent of tokens in Wei\n', '        require(address(this).balance >= _wei, "Not enough wei");               /// Checks the contract\'s ETH balance\n', '        //require(contractBalance >= _wei, "Not enough wei");                     /// Contract does not have enough Wei\n', '        \n', '        /// Using Checks-Effects-Interactions (CEI) pattern to mitigate re-entrancy attack\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);                /// Decreases tokens of seller\n', '        balances[owner] = balances[owner].add(tokens);                          /// Increases tokens of owner\n', '        //contractBalance = contractBalance.sub(_wei);                            /// Adjusts contract balance\n', '        \n', '        emit Sell(msg.sender, tokens, address(this), _wei, owner);              /// Logs sell event\n', '        (success, ) = msg.sender.call.value(_wei)("");                          /// Transfers Wei to the seller\n', '        require(success, "Ether transfer failed");                              /// Checks successful transfer\n', '    }\n', '    \n', '    /**\n', '     * @dev Supports buying token by transferring Ether\n', '     */ \n', '    function buy() external payable notPaused noReentrancy returns(bool success){\n', '        require(msg.sender != owner, "Called by the Owner");                /// The owner cannot be seller/buyer\n', '        uint256 _tokens = msg.value.mul(exchangeRate);                      /// Calculates token equivalents\n', '        require(balances[owner] >= _tokens, "Not enough tokens");           /// Checks owner\'s balance\n', '\n', '        balances[msg.sender] = balances[msg.sender].add(_tokens);           /// Increases token balance of buyer\n', '        balances[owner] = balances[owner].sub(_tokens);                     /// Decreases token balance of owner\n', '        //contractBalance = contractBalance.add(msg.value);                   /// Adjustes contract balance\n', '        emit Buy(msg.sender, msg.value, owner, _tokens);                    /// Logs Buy event\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Withdraw Ether from the contract and send it to the address that is specified by the owner. It can be called only by the owner.\n', '     */\n', '    function withdraw(uint256 amount) external onlyOwner returns(bool success){\n', '        require(address(this).balance >= amount, "Not enough fund");        /// Checks the contract\'s ETH balance\n', '        //require(contractBalance >= amount, "Not enough fund");              /// Checks the contract\'s ETH balance\n', '\n', '        emit Withdrawal(msg.sender, address(this), amount);                 /// Logs withdrawal event\n', '        (success, ) = msg.sender.call.value(amount)("");                    /// Transfers amount (EIP-1884 compatible)\n', '        require(success, "Ether transfer failed");                          /// Checks successful transfer\n', '    }\n', '    \n', '    /**\n', '     * @dev Returns balance of the Contract\n', '     *\n', '    function getContractBalance() public view onlyOwner returns(uint256, uint256){\n', '        return (address(this).balance, contractBalance);\n', '    }\n', '    \n', '    /** \n', '     * @dev Checks for unexpected received Ether (forced to the contract without using payable functions)\n', '     *\n', '    function unexpectedEther() public view onlyOwner returns(bool){\n', '        return (contractBalance != address(this).balance);\n', '    }\n', '    */\n', '    \n', '    /**\n', '    /* @dev Creates new tokens and assigns them to the owner, increases the total supply as well.\n', '     */\n', '    function mint(uint256 newTokens) external onlyOwner {\n', '        initialSupply = initialSupply.add(newTokens);               /// Increases token supply\n', '        balances[owner] = balances[owner].add(newTokens);           /// Increases balance of the owner\n', '        emit Mint(msg.sender, newTokens);                           /// Logs Mint event\n', '    }\n', '\n', '    /**\n', '     * @dev Burns tokens from the owner, decreases the total supply as well.\n', '     */\n', '    function burn(uint256 tokens) external onlyOwner {\n', '        require(balances[owner] >= tokens, "Not enough tokens");    /// Checks owner\'s balance\n', '        balances[owner] = balances[owner].sub(tokens);              /// Decreases balance of the owner\n', '        initialSupply = initialSupply.sub(tokens);                  /// Decreases token supply\n', '        emit Burn(msg.sender, tokens);                              /// Logs Burn event\n', '    }\n', '    \n', '    /**\n', '     * @dev Sets new exchange rate. It can be called only by the owner.\n', '     */\n', '    function setExchangeRate(uint256 newRate) external onlyOwner returns(bool success)\n', '    {\n', '        uint256 _currentRate = exchangeRate;\n', '        exchangeRate = newRate;                             /// Sets new exchange rate\n', '        emit Change(_currentRate, exchangeRate);            /// Logs Change event\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Changes owner of the contract\n', '     */\n', '    function changeOwner(address payable newOwner) external onlyOwner validAddress(newOwner) {\n', '        address _current = owner;\n', '        owner = newOwner;\n', '        emit ChangeOwner(_current, owner);\n', '    }\n', '    \n', '    /**\n', '     * @dev Pause the contract as result of self-checks (off-chain computations).\n', '     */\n', '    function pause() external onlyOwner {\n', '        paused = true;                  \n', '        emit Pause(msg.sender, paused);\n', '    }\n', '    \n', '    /**\n', '     * @dev Unpause the contract after self-checks.\n', '     */\n', '    function unpause() external onlyOwner {\n', '        paused = false;\n', '        emit Pause(msg.sender, paused);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the total token supply.\n', '     */\n', '    function totalSupply() external view returns (uint256 tokens) {\n', '        return initialSupply;                       /// Total supply of the token.\n', '    }\n', '    \n', '    /**\n', '     * @dev Returns the account balance of another account with address `tokenHolder`.\n', '     */\n', '    function balanceOf(address tokenHolder) external view returns (uint256 tokens) {\n', '        return balances[tokenHolder];               /// Balance of token holder.\n', '    }\n', '    \n', '    /**\n', "     * @dev Returns the amount of tokens approved by the owner that can be transferred to the spender's account.\n", '     */\n', '    function allowance(address tokenHolder, address spender) external view notPaused returns (uint256 tokens) {\n', '        uint256 _transferred = transferred[tokenHolder][spender];       /// Already transferred tokens by `spender`.\n', '        return allowances[tokenHolder][spender].sub(_transferred);      /// Remained tokens to transfer by `spender`.\n', '    }\n', '    \n', '    /**\n', "     * @dev Returns the amount of transferred tokens by spender's account.\n", '     */\n', '    function transfers(address tokenHolder, address spender) external view notPaused returns (uint256 tokens) {\n', '        return transferred[tokenHolder][spender];    /// Transfers by `spender` (approved by `tokenHolder`).\n', '    }\n', '\n', '    /**\n', '     * @dev Checks whether the caller is the owner. \n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Not the owner");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Checks validity of the address.\n', '     */\n', '    modifier validAddress(address addr){\n', '        require(addr != address(0x0), "Zero address");\n', '        require(addr != address(this), "Contract address");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '    * @author https://solidity.readthedocs.io/en/latest/contracts.html#function-modifiers\n', '    * @dev Mutex modifier to mitigate Re-entrancy Attack. Operation will succeed if and only if the locking thread is the one that already holds the lock.\n', '    */\n', '    modifier noReentrancy() \n', '    {\n', '        require(!locked, "Reentrant call");\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '    \n', '    /**\n', '    * @dev Modifier to support Fail-Safe Mode. In case, it disables most of the toekn features, hands off control to the owner.\n', '    */\n', '    modifier notPaused() \n', '    {\n', '        require(!paused, "Fail-Safe mode");\n', '        _;\n', '    }\n', '    \n', '    /// Events\n', '    event Buy(address indexed _buyer, uint256 _wei, address indexed _owner, uint256 _tokens);\n', '    event Sell(address indexed _seller, uint256 _tokens, address indexed _contract, uint256 _wei, address indexed _owner);\n', '    event Received(address indexed _sender, uint256 _wei);\n', '    event Withdrawal(address indexed _by, address indexed _contract, uint256 _wei);\n', '    event Change(uint256 _current, uint256 _new);\n', '    event ChangeOwner(address indexed _current, address indexed _new);\n', '    event Pause(address indexed _owner, bool _state);\n', '    event Mint(address indexed _owner, uint256 _tokens);\n', '    event Burn(address indexed _owner, uint256 _tokens);\n', '}']