['pragma solidity ^0.5.17;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Removed mul, div, mod\n', ' */\n', 'library SafeMath {\n', '        /**\n', '         * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '         */\n', '        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '                require(b <= a);\n', '                uint256 c = a - b;\n', '\n', '                return c;\n', '        }\n', '\n', '        /**\n', '         * @dev Adds two unsigned integers, reverts on overflow.\n', '         */\n', '        function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '                uint256 c = a + b;\n', '                require(c >= a);\n', '\n', '                return c;\n', '        }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '      function totalSupply() public view returns (uint256);\n', '      function balanceOf(address _who) public view returns (uint256);\n', '      function transfer(address _to, uint256 _value) public returns (bool);\n', '      function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '      function allowance(address _owner, address _spender) public view returns (uint256);\n', '      function approve(address _spender, uint256 _value) public returns (bool);\n', '\n', '      event Transfer(address indexed from, address indexed to, uint256 value);\n', '      event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract StandardToken is ERC20 {\n', '        using SafeMath for uint256;\n', '\n', '        uint256 internal _totalSupply;\n', '        mapping(address => uint256) internal _balances;\n', '        mapping(address => mapping (address => uint256)) internal _allowed;\n', '\n', '        modifier validDestination( address _to )\n', '        {\n', '                require(_to != address(0x0), "Invalid address.");\n', '                require(_to != address(this), "Invalid address.");\n', '                _;\n', '        }\n', '\n', '        function totalSupply() public view returns (uint256) {\n', '                return _totalSupply;\n', '        }\n', '\n', '        function balanceOf(address _who) public view returns (uint256) {\n', '                return _balances[_who];\n', '        }\n', '\n', '        function transfer(address _to, uint256 _value)\n', '                public\n', '                validDestination(_to)\n', '                returns (bool)\n', '        {\n', '                _balances[msg.sender] = _balances[msg.sender].sub(_value);\n', '                _balances[_to] = _balances[_to].add(_value);\n', '                emit Transfer(msg.sender, _to, _value);\n', '                return true;\n', '        }\n', '\n', '        function transferFrom(address _from, address _to, uint256 _value)\n', '                public\n', '                validDestination(_to)\n', '                returns (bool)\n', '        {\n', '                require(_value <= _allowed[_from][msg.sender],"Insufficient allowance.");\n', '\n', '                _balances[_from] = _balances[_from].sub(_value);\n', '                _balances[_to] = _balances[_to].add(_value);\n', '                _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);\n', '\n', '                emit Transfer(_from, _to, _value);\n', '                return true;\n', '        }\n', '\n', '        function burn(uint _value) public returns (bool)\n', '        {\n', '                _balances[msg.sender] = _balances[msg.sender].sub(_value);\n', '                _totalSupply = _totalSupply.sub(_value);\n', '                emit Transfer(msg.sender, address(0x0), _value);\n', '                return true;\n', '        }\n', '\n', '        function burnFrom(address _from, uint256 _value) public validDestination(_from) returns (bool)\n', '        {\n', '                require(_value <= _allowed[_from][msg.sender],"Insufficient allowance.");\n', '                \n', '                _balances[_from] = _balances[_from].sub(_value);\n', '                _totalSupply = _totalSupply.sub(_value);\n', '                _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);\n', '                \n', '                emit Transfer(_from, address(0x0), _value);\n', '\n', '                return true;\n', '        }\n', '\n', '        function approve(address _spender, uint256 _value) public validDestination(_spender) returns (bool) {\n', '\n', '                _allowed[msg.sender][_spender] = _value;\n', '                emit Approval(msg.sender, _spender, _value);\n', '                return true;\n', '        }\n', '\n', '        function allowance(address _owner, address _spender) public view returns (uint256)\n', '        {\n', '                return _allowed[_owner][_spender];\n', '        }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '        address public owner;\n', '\n', '        event OwnershipTransferred(\n', '                address indexed previousOwner,\n', '                address indexed newOwner\n', '        );\n', '\n', '        constructor() public {\n', '                owner = msg.sender;\n', '        }\n', '\n', '        modifier validateAddress(address _to) {\n', '                require(_to != address(0x0));\n', '\t\t\t\trequire(_to != address(this));\n', '                _;\n', '        }\n', '\n', '        modifier onlyOwner() {\n', "                require(msg.sender == owner, 'Permission denied.');\n", '                _;\n', '        }\n', '\t\t\n', '        function transferOwnership(address _newOwner) public onlyOwner validateAddress(_newOwner) {\n', '                owner = _newOwner;\n', '                emit OwnershipTransferred(owner, _newOwner);\n', '        }\n', '}\n', '\n', '\n', 'contract Pausable is Ownable {\n', '        event Pause();\n', '        event Unpause();\n', '\n', '        bool public paused = false;\n', '\n', '        modifier whenNotPaused() {\n', "                require(!paused, 'Paused by owner.');\n", '                _;\n', '        }\n', '\n', '        modifier whenPaused() {\n', "                require(paused, 'Paused requied.');\n", '                _;\n', '        }\n', '\n', '        function pause() public onlyOwner whenNotPaused {\n', '                paused = true;\n', '                emit Pause();\n', '        }\n', '\n', '        function unpause() public onlyOwner whenPaused {\n', '                paused = false;\n', '                emit Unpause();\n', '        }\n', '}\n', '\n', '\n', 'contract Freezable is Ownable {\n', '        mapping (address => bool) public frozenAccount;\n', '\n', '        event Freezed(address indexed target, bool frozen);\n', '        event Unfreezed(address indexed target, bool frozen);\n', '\n', '        modifier isNotFrozen(address _target) {\n', "                require(!frozenAccount[_target], 'Frozen account.');\n", '                _;\n', '        }\n', '\n', '        modifier isFrozen(address _target) {\n', "                require(frozenAccount[_target], 'Not a frozen account.');\n", '                _;\n', '        }\n', '\n', '        function freeze(address _target) public onlyOwner isNotFrozen(_target) validateAddress(_target) {\n', '                frozenAccount[_target] = true;\n', '                emit Freezed(_target, true);\n', '        }\n', '\n', '        function unfreeze(address _target) public onlyOwner isFrozen(_target) validateAddress(_target) {\n', '                frozenAccount[_target] = false;\n', '                emit Unfreezed(_target, false);\n', '        }\n', '\n', '}\n', '\n', 'contract GMEX is StandardToken, Pausable, Freezable {\n', '        using SafeMath for uint256;\n', '\n', '        string  public  name = "GMEX Chain";\n', "        string  public  symbol = 'GMEX';\n", '        uint256 public  constant decimals = 12;\n', '        \n', '        constructor(\n', '                uint256 _initialSupply\n', '        )\n', '                public\n', '        {\n', '                _totalSupply = _initialSupply * 10 ** uint256(decimals);\n', '                _balances[msg.sender] = _totalSupply;     \n', '                emit Transfer(address(0x0), msg.sender, _totalSupply);\n', '        }\n', '\t\t\n', '        function transfer(address _to, uint256 _value)\n', '                public\n', '                whenNotPaused\n', '                isNotFrozen(msg.sender)\n', '                isNotFrozen(_to)\n', '                returns (bool)\n', '        {\n', '                return super.transfer(_to, _value);\n', '        }\n', '\n', '        function transferFrom(address _from, address _to, uint256 _value)\n', '                public\n', '                whenNotPaused\n', '                isNotFrozen(_from)\n', '                isNotFrozen(_to)\n', '                returns (bool)\n', '        {\n', '                return super.transferFrom(_from, _to, _value);\n', '        }\n', '\n', '        function burn(uint256 _value)\n', '                public\n', '                whenNotPaused\n', '                isNotFrozen(msg.sender)\n', '                returns (bool)\n', '        {\n', '                return super.burn(_value);\n', '        }\n', '\n', '        function burnFrom(address _from, uint256 _value)\n', '                public\n', '                whenNotPaused\n', '                isNotFrozen(_from)\n', '                returns (bool)\n', '        {\n', '                return super.burnFrom(_from, _value);\n', '        }\n', '\n', '        function approve(\n', '                address _spender,\n', '                uint256 _value\n', '        )\n', '                public\n', '                whenNotPaused\n', '                isNotFrozen(msg.sender)\n', '                isNotFrozen(_spender)\n', '                returns (bool)\n', '        {\n', '                return super.approve(_spender, _value);\n', '        }\n', '\n', '}']