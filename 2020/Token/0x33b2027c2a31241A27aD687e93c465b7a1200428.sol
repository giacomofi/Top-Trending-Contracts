['// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/utils/PermissionGroups.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.5.12;\n', '\n', 'contract PermissionGroups {\n', '    address public admin;\n', '    address public pendingAdmin;\n', '    mapping(address => bool) internal operators;\n', '    address[] internal operatorsGroup;\n', '    uint256 internal constant MAX_GROUP_SIZE = 50;\n', '\n', '    constructor(address _admin) public {\n', '        require(_admin != address(0), "Admin 0");\n', '        admin = _admin;\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(msg.sender == admin, "Only admin");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOperator() {\n', '        require(operators[msg.sender], "Only operator");\n', '        _;\n', '    }\n', '\n', '    function getOperators() external view returns (address[] memory) {\n', '        return operatorsGroup;\n', '    }\n', '\n', '    event TransferAdminPending(address pendingAdmin);\n', '\n', '    /**\n', '     * @dev Allows the current admin to set the pendingAdmin address.\n', '     * @param newAdmin The address to transfer ownership to.\n', '     */\n', '    function transferAdmin(address newAdmin) public onlyAdmin {\n', '        require(newAdmin != address(0), "New admin 0");\n', '        emit TransferAdminPending(newAdmin);\n', '        pendingAdmin = newAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n', '     * @param newAdmin The address to transfer ownership to.\n', '     */\n', '    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n', '        require(newAdmin != address(0), "Admin 0");\n', '        emit TransferAdminPending(newAdmin);\n', '        emit AdminClaimed(newAdmin, admin);\n', '        admin = newAdmin;\n', '    }\n', '\n', '    event AdminClaimed(address newAdmin, address previousAdmin);\n', '\n', '    /**\n', '     * @dev Allows the pendingAdmin address to finalize the change admin process.\n', '     */\n', '    function claimAdmin() public {\n', '        require(pendingAdmin == msg.sender, "not pending");\n', '        emit AdminClaimed(pendingAdmin, admin);\n', '        admin = pendingAdmin;\n', '        pendingAdmin = address(0);\n', '    }\n', '\n', '    event OperatorAdded(address newOperator, bool isAdd);\n', '\n', '    function addOperator(address newOperator) public onlyAdmin {\n', '        require(!operators[newOperator], "Operator exists"); // prevent duplicates.\n', '        require(operatorsGroup.length < MAX_GROUP_SIZE, "Max operators");\n', '\n', '        emit OperatorAdded(newOperator, true);\n', '        operators[newOperator] = true;\n', '        operatorsGroup.push(newOperator);\n', '    }\n', '\n', '    function removeOperator(address operator) public onlyAdmin {\n', '        require(operators[operator], "Not operator");\n', '        operators[operator] = false;\n', '\n', '        for (uint256 i = 0; i < operatorsGroup.length; ++i) {\n', '            if (operatorsGroup[i] == operator) {\n', '                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n', '                operatorsGroup.pop();\n', '                emit OperatorAdded(operator, false);\n', '                break;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/utils/Withdrawable.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.5.12;\n', '\n', '\n', '\n', 'contract Withdrawable is PermissionGroups {\n', '    mapping(address => bool) internal blacklist;\n', '\n', '    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\n', '\n', '    event EtherWithdraw(uint256 amount, address sendTo);\n', '\n', '    constructor(address _admin) public PermissionGroups(_admin) {}\n', '\n', '    /**\n', '     * @dev Withdraw all IERC20 compatible tokens\n', '     * @param token IERC20 The address of the token contract\n', '     */\n', '    function withdrawToken(\n', '        IERC20 token,\n', '        uint256 amount,\n', '        address sendTo\n', '    ) external onlyAdmin {\n', '        require(!blacklist[address(token)], "forbid to withdraw that token");\n', '        token.transfer(sendTo, amount);\n', '        emit TokenWithdraw(token, amount, sendTo);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw Ethers\n', '     */\n', '    function withdrawEther(uint256 amount, address payable sendTo) external onlyAdmin {\n', '        (bool success, ) = sendTo.call.value(amount)("");\n', '        require(success);\n', '        emit EtherWithdraw(amount, sendTo);\n', '    }\n', '\n', '    function setBlackList(address token) internal {\n', '        blacklist[token] = true;\n', '    }\n', '}\n', '\n', '// File: contracts/Referral.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', 'contract Referral is Withdrawable {\n', '    mapping(address => address) public referrers; // account_address -> referrer_address\n', '    mapping(address => uint256) public referredCount; // referrer_address -> num_of_referred\n', '\n', '    event ReferralSet(address indexed referrer, address indexed farmer);\n', '\n', '    constructor(address _admin) public Withdrawable(_admin) {}\n', '\n', '    function setReferrer(address farmer, address referrer) public onlyOperator {\n', '        if (referrers[farmer] == address(0) && referrer != address(0)) {\n', '            referrers[farmer] = referrer;\n', '            referredCount[referrer] += 1;\n', '            emit ReferralSet(referrer, farmer);\n', '        }\n', '    }\n', '\n', '    function getReferrer(address farmer) public view returns (address) {\n', '        return referrers[farmer];\n', '    }\n', '}']