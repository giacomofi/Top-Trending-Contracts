['pragma solidity ^0.6.6;\n', '\n', '//SPDX-License-Identifier: UNLICENSED\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\t/**\n', '\t* @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '\t* @param newOwner The address to transfer ownership to.\n', '\t*/\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\tif (newOwner != address(0)) {\n', '\t\t\towner = newOwner;\n', '\t\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\t}\n', '\t}\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '//Tokenlock trade\n', '// ----------------------------------------------------------------------------\n', 'contract Tokenlock is Owned {\n', '  uint8 isLocked = 0;\n', '  event Freezed();\n', '  event UnFreezed();\n', '  modifier validLock {\n', '    require(isLocked == 0);\n', '    _;\n', '  }\n', '  function freeze() public onlyOwner {\n', '    isLocked = 1;\n', '    emit Freezed();\n', '  }\n', '  function unfreeze() public onlyOwner {\n', '    isLocked = 0;\n', '    emit UnFreezed();\n', '  }\n', '\n', '\n', '  mapping(address => bool) blacklist;\n', '  event LockUser(address indexed who);\n', '  event UnlockUser(address indexed who);\n', '\n', '  modifier permissionCheck {\n', '    require(!blacklist[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  function lockUser(address who) public onlyOwner {\n', '    blacklist[who] = true;\n', '    emit LockUser(who);\n', '  }\n', '\n', '  function unlockUser(address who) public onlyOwner {\n', '    blacklist[who] = false;\n', '    emit UnlockUser(who);\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Timi is Tokenlock {\n', '\n', '    using SafeMath for uint;\n', '    string public name = "Timi Finance";\n', '    string public symbol = "Timi";\n', '    uint8  public decimals = 18;\n', '    uint  internal _rate=100;\n', '    uint  internal _amount;\n', '    uint256  public totalSupply;\n', '\n', '    //bank\n', '    mapping(address => uint)  bank_balances;\n', '    //eth\n', '    mapping(address => uint) activeBalances;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 value);\n', '    event Burn(address indexed _from, uint256 value);\n', '\t// Called when new token are issued\n', '\tevent Issue(uint amount);\n', '\t// Called when tokens are redeemed\n', '\tevent Redeem(uint amount);\n', '    //Called when sent\n', '    event Sent(address from, address to, uint amount);\n', '    event FallbackCalled(address sent, uint amount);\n', '\n', '    \t/**\n', '\t* @dev Fix for the ERC20 short address attack.\n', '\t*/\n', '\tmodifier onlyPayloadSize(uint size) {\n', '\t\trequire(!(msg.data.length < size + 4));\n', '\t\t_;\n', '\t}\n', '\n', '    constructor (uint totalAmount) public{\n', '        totalSupply =  totalAmount * 10**uint256(decimals);\n', '        balances[msg.sender] = totalSupply;\n', '        emit Transfer(address(0), msg.sender, totalSupply);\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '/*    function totalSupply() public  view returns (uint) {\n', '        return _totalSupply.sub(balances[address(0)]);\n', '    }*/\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOfBank(address tokenOwner) public  view returns (uint balance) {\n', '        return bank_balances[tokenOwner];\n', '    }\n', '\n', '    function balanceOfReg(address tokenOwner) public  view returns (uint balance) {\n', '        return activeBalances[tokenOwner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public  view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', "    // transferred to the spender's account\n", '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public   view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '\n', '\t// ------------------------------------------------------------------------\n', '\t// Issue a new amount of tokens\n', '\t// these tokens are deposited into the owner address\n', '\t// @param _amount Number of tokens to be issued\n', '\t// ------------------------------------------------------------------------\n', '\tfunction issue(uint amount) public onlyOwner {\n', '\t\trequire(totalSupply + amount > totalSupply);\n', '\t\trequire(balances[owner] + amount > balances[owner]);\n', '\n', '\t\tbalances[owner] += amount;\n', '\t\ttotalSupply += amount;\n', '\t\temit Issue(amount);\n', '\t}\n', '\t// ------------------------------------------------------------------------\n', '\t// Redeem tokens.\n', '\t// These tokens are withdrawn from the owner address\n', '\t// if the balance must be enough to cover the redeem\n', '\t// or the call will fail.\n', '\t// @param _amount Number of tokens to be issued\n', '\t// ------------------------------------------------------------------------\n', '\tfunction redeem(uint amount) public onlyOwner {\n', '\t\trequire(totalSupply >= amount);\n', '\t\trequire(balances[owner] >= amount);\n', '\n', '\t\ttotalSupply -= amount;\n', '\t\tbalances[owner] -= amount;\n', '\t\temit Redeem(amount);\n', '\t}\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Transfer the balance from token owner's account to `to` account\n", "    // - Owner's account must have sufficient balance to transfer\n", '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public  validLock permissionCheck onlyPayloadSize(2 * 32) returns (bool success) {\n', '        require(to != address(0));\n', '        require(balances[msg.sender] >= tokens && tokens > 0);\n', '        require(balances[to] + tokens >= balances[to]);\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account\n", '    //\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces\n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    //\n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public  validLock permissionCheck onlyPayloadSize(3 * 32) returns (bool success) {\n', '        require(to != address(0));\n', '\n', '        require(balances[from] >= tokens && tokens > 0);\n', '        require(balances[to] + tokens >= balances[to]);\n', '\n', '\n', '        balances[from] = balances[from].sub(tokens);\n', '        if(allowed[from][msg.sender] > 0)\n', '        {\n', '            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        }\n', '        balances[to] = balances[to].add(tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '        // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    //\n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferStore(address from, address to, uint tokens) public  validLock permissionCheck onlyPayloadSize(3 * 32) returns (bool success) {\n', '        require(to != address(0));\n', '\n', '        require(balances[from] >= tokens && tokens > 0);\n', '        require(balances[to] + tokens >= balances[to]);\n', '\n', '\n', '        balances[from] = balances[from].sub(tokens);\n', '        if(allowed[from][msg.sender] > 0)\n', '        {\n', '            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '        }\n', '        balances[to] = balances[to].add(tokens);\n', '\n', '\n', '        bank_balances[from] = bank_balances[from].add(tokens);\n', '\n', '\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public  onlyOwner {\n', '        // return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '        address(uint160(tokenAddress)).transfer(tokens);\n', '        emit Sent(owner,tokenAddress,tokens);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    //  ERC20 withdraw\n', '    // -----------------------------------------\n', '    function withdraw() onlyOwner public {\n', '        msg.sender.transfer(address(this).balance);\n', '        _amount = 0;\n', '    }\n', '\n', '    function showAmount() onlyOwner public view returns (uint) {\n', '        return _amount;\n', '    }\n', '\n', '    function showBalance() onlyOwner public view returns (uint) {\n', '        return owner.balance;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    //  ERC20 set rate\n', '    // -----------------------------------------\n', '    function set_rate(uint _vlue) public onlyOwner{\n', '        require(_vlue > 0);\n', '        _rate = _vlue;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    //  ERC20 tokens\n', '    // -----------------------------------------\n', '    receive() external  payable{\n', '        /* require(balances[owner] >= msg.value && msg.value > 0);\n', '        balances[msg.sender] = balances[msg.sender].add(msg.value * _rate);\n', '\t\tbalances[owner] = balances[owner].sub(msg.value * _rate); */\n', '        _amount=_amount.add(msg.value);\n', '        activeBalances[msg.sender] = activeBalances[msg.sender].add(msg.value);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    //  ERC20 recharge\n', '    // -----------------------------------------\n', '    function recharge() public payable{\n', '        _amount=_amount.add(msg.value);\n', '        activeBalances[msg.sender] = activeBalances[msg.sender].add(msg.value);\n', '    }\n', '\n', '}']