['// SPDX-License-Identifier: MIT\n', 'pragma experimental ABIEncoderV2;\n', 'pragma solidity 0.6.4;\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a <= b ? a : b;\n', '    }\n', '\n', '    function abs(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a < b) {\n', '            return b - a;\n', '        }\n', '        return a - b;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    function decimals() external view returns (uint8);\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'interface IFToken is IERC20 {\n', '    function mint(address user, uint256 amount) external returns (bytes memory);\n', '\n', '    function borrow(address borrower, uint256 borrowAmount)\n', '        external\n', '        returns (bytes memory);\n', '\n', '    function withdraw(\n', '        address payable withdrawer,\n', '        uint256 withdrawTokensIn,\n', '        uint256 withdrawAmountIn\n', '    ) external returns (uint256, bytes memory);\n', '\n', '    function underlying() external view returns (address);\n', '\n', '    function accrueInterest() external;\n', '\n', '    function getAccountState(address account)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function MonitorEventCallback(\n', '        address who,\n', '        bytes32 funcName,\n', '        bytes calldata payload\n', '    ) external;\n', '\n', '    //用户存借取还操作后的兑换率\n', '    function exchangeRateCurrent() external view returns (uint256 exchangeRate);\n', '\n', '    function repay(address borrower, uint256 repayAmount)\n', '        external\n', '        returns (uint256, bytes memory);\n', '\n', '    function borrowBalanceStored(address account)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function exchangeRateStored() external view returns (uint256 exchangeRate);\n', '\n', '    function liquidateBorrow(\n', '        address liquidator,\n', '        address borrower,\n', '        uint256 repayAmount,\n', '        address fTokenCollateral\n', '    ) external returns (bytes memory);\n', '\n', '    function borrowBalanceCurrent(address account) external returns (uint256);\n', '\n', '    function balanceOfUnderlying(address owner) external returns (uint256);\n', '\n', '    function _reduceReserves(uint256 reduceAmount) external;\n', '\n', '    function _addReservesFresh(uint256 addAmount) external;\n', '\n', '    function cancellingOut(address striker)\n', '        external\n', '        returns (bool strikeOk, bytes memory strikeLog);\n', '\n', '    function APR() external view returns (uint256);\n', '\n', '    function APY() external view returns (uint256);\n', '\n', '    function calcBalanceOfUnderlying(address owner)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function borrowSafeRatio() external view returns (uint256);\n', '\n', '    function tokenCash(address token, address account)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function getBorrowRate() external view returns (uint256);\n', '\n', '    function addTotalCash(uint256 _addAmount) external;\n', '    function subTotalCash(uint256 _subAmount) external;\n', '\n', '    function totalCash() external view returns (uint256);\n', '}\n', '\n', 'interface IBankController {\n', '    function getCashPrior(address underlying) external view returns (uint256);\n', '\n', '    function getCashAfter(address underlying, uint256 msgValue)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function getFTokeAddress(address underlying)\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    function transferToUser(\n', '        address token,\n', '        address payable user,\n', '        uint256 amount\n', '    ) external;\n', '\n', '    function transferIn(\n', '        address account,\n', '        address underlying,\n', '        uint256 amount\n', '    ) external payable;\n', '\n', '    function borrowCheck(\n', '        address account,\n', '        address underlying,\n', '        address fToken,\n', '        uint256 borrowAmount\n', '    ) external;\n', '\n', '    function repayCheck(address underlying) external;\n', '\n', '    function rewardForByType(\n', '        address account,\n', '        uint256 gasSpend,\n', '        uint256 gasPrice,\n', '        uint256 rewardType\n', '    ) external;\n', '\n', '    function liquidateBorrowCheck(\n', '        address fTokenBorrowed,\n', '        address fTokenCollateral,\n', '        address borrower,\n', '        address liquidator,\n', '        uint256 repayAmount\n', '    ) external;\n', '\n', '    function liquidateTokens(\n', '        address fTokenBorrowed,\n', '        address fTokenCollateral,\n', '        uint256 actualRepayAmount\n', '    ) external view returns (uint256);\n', '\n', '    function withdrawCheck(\n', '        address fToken,\n', '        address withdrawer,\n', '        uint256 withdrawTokens\n', '    ) external view returns (uint256);\n', '\n', '    function transferCheck(\n', '        address fToken,\n', '        address src,\n', '        address dst,\n', '        uint256 transferTokens\n', '    ) external;\n', '\n', '    function marketsContains(address fToken) external view returns (bool);\n', '\n', '    function seizeCheck(address cTokenCollateral, address cTokenBorrowed)\n', '        external;\n', '\n', '    function mintCheck(address underlying, address minter) external;\n', '\n', '    function addReserves(address underlying, uint256 addAmount)\n', '        external\n', '        payable;\n', '\n', '    function reduceReserves(\n', '        address underlying,\n', '        address payable account,\n', '        uint256 reduceAmount\n', '    ) external;\n', '\n', '    function calcMaxBorrowAmount(address user, address token)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function calcMaxWithdrawAmount(address user, address token)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function calcMaxCashOutAmount(address user, address token)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function calcMaxBorrowAmountWithRatio(address user, address token)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transferEthGasCost() external view returns (uint256);\n', '\n', '    function isFTokenValid(address fToken) external view returns (bool);\n', '}\n', '\n', 'enum RewardType {\n', '    DefaultType,\n', '    Deposit,\n', '    Borrow,\n', '    Withdraw,\n', '    Repay,\n', '    Liquidation,\n', '    TokenIn, //入金，为还款和存款的组合\n', '    TokenOut //出金， 为取款和借款的组合\n', '}\n', '\n', 'library EthAddressLib {\n', '    /**\n', '     * @dev returns the address used within the protocol to identify ETH\n', '     * @return the address assigned to ETH\n', '     */\n', '    function ethAddress() internal pure returns (address) {\n', '        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    }\n', '}\n', '\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', 'contract Bank is Initializable {\n', '    using SafeMath for uint256;\n', '\n', '    bool public paused;\n', '\n', '    address public mulSig;\n', '\n', '    event MonitorEvent(bytes32 indexed funcName, bytes payload);\n', '    modifier onlyFToken(address fToken) {\n', '        require(\n', '            controller.marketsContains(fToken) ||\n', '                msg.sender == address(controller),\n', '            "only supported ftoken or controller"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function MonitorEventCallback(bytes32 funcName, bytes calldata payload)\n', '        external\n', '        onlyFToken(msg.sender)\n', '    {\n', '        emit MonitorEvent(funcName, payload);\n', '    }\n', '\n', '    IBankController public controller;\n', '\n', '    address public admin;\n', '\n', '    address public proposedAdmin;\n', '    address public pauser;\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin, "OnlyAdmin");\n', '        _;\n', '    }\n', '\n', '    modifier whenUnpaused {\n', '        require(!paused, "System paused");\n', '        _;\n', '    }\n', '\n', '    modifier onlyMulSig {\n', '        require(msg.sender == mulSig, "require mulsig");\n', '        _;\n', '    }\n', '\n', '    modifier onlySelf {\n', '        require(msg.sender == address(this), "require self");\n', '        _;\n', '    }\n', '\n', '    modifier onlyPauser {\n', '        require(msg.sender == pauser, "require pauser");\n', '        _;\n', '    }\n', '\n', '    function initialize(address _controller, address _mulSig)\n', '        public\n', '        initializer\n', '    {\n', '        controller = IBankController(_controller);\n', '        mulSig = _mulSig;\n', '        paused = false;\n', '        admin = msg.sender;\n', '    }\n', '\n', '    function setController(address _controller) public onlyAdmin {\n', '        controller = IBankController(_controller);\n', '    }\n', '\n', '    function setPaused() public onlyPauser {\n', '        paused = true;\n', '    }\n', '\n', '    function setUnpaused() public onlyPauser {\n', '        paused = false;\n', '    }\n', '\n', '    function setPauser(address _pauser) public onlyAdmin {\n', '        pauser = _pauser;\n', '    }\n', '\n', '    function proposeNewAdmin(address admin_) external onlyMulSig {\n', '        proposedAdmin = admin_;\n', '    }\n', '\n', '    function claimAdministration() external {\n', '        require(msg.sender == proposedAdmin, "Not proposed admin.");\n', '        admin = proposedAdmin;\n', '        proposedAdmin = address(0);\n', '    }\n', '\n', '    // 存钱返token\n', '    modifier rewardFor(address usr, RewardType rewardType) {\n', '        uint256 gasStart = gasleft();\n', '        _;\n', '        uint256 gasSpent = gasStart - gasleft();\n', '        controller.rewardForByType(\n', '            usr,\n', '            gasSpent,\n', '            tx.gasprice,\n', '            uint256(rewardType)\n', '        );\n', '    }\n', '\n', '    // 用户存款\n', '    function deposit(address token, uint256 amount)\n', '        public\n', '        payable\n', '        whenUnpaused\n', '        rewardFor(msg.sender, RewardType.Deposit)\n', '    {\n', '        return this._deposit{value: msg.value}(token, amount, msg.sender);\n', '    }\n', '\n', '    // 用户存款\n', '    function _deposit(\n', '        address token,\n', '        uint256 amount,\n', '        address account\n', '    ) external payable whenUnpaused onlySelf {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(token));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        bytes memory flog = fToken.mint(account, amount);\n', '        controller.transferIn{value: msg.value}(account, token, amount);\n', '\n', '        fToken.addTotalCash(amount);\n', '\n', '        emit MonitorEvent("Deposit", flog);\n', '    }\n', '\n', '    // 用户借款\n', '    function borrow(address underlying, uint256 borrowAmount)\n', '        public\n', '        whenUnpaused\n', '        rewardFor(msg.sender, RewardType.Borrow)\n', '    {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(underlying));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        bytes memory flog = fToken.borrow(msg.sender, borrowAmount);\n', '        emit MonitorEvent("Borrow", flog);\n', '    }\n', '\n', '    // 用户取款 取 fToken 的数量\n', '    function withdraw(address underlying, uint256 withdrawTokens)\n', '        public\n', '        whenUnpaused\n', '        rewardFor(msg.sender, RewardType.Withdraw)\n', '        returns (uint256)\n', '    {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(underlying));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        (uint256 amount, bytes memory flog) = fToken.withdraw(\n', '            msg.sender,\n', '            withdrawTokens,\n', '            0\n', '        );\n', '        emit MonitorEvent("Withdraw", flog);\n', '        return amount;\n', '    }\n', '\n', '    // 用户取款 取底层 token 的数量\n', '    function withdrawUnderlying(address underlying, uint256 withdrawAmount)\n', '        public\n', '        whenUnpaused\n', '        rewardFor(msg.sender, RewardType.Withdraw)\n', '        returns (uint256)\n', '    {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(underlying));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        (uint256 amount, bytes memory flog) = fToken.withdraw(\n', '            msg.sender,\n', '            0,\n', '            withdrawAmount\n', '        );\n', '        emit MonitorEvent("WithdrawUnderlying", flog);\n', '        return amount;\n', '    }\n', '\n', '    // 用户还款\n', '    function repay(address token, uint256 repayAmount)\n', '        public\n', '        payable\n', '        whenUnpaused\n', '        rewardFor(msg.sender, RewardType.Repay)\n', '        returns (uint256)\n', '    {\n', '        return this._repay{value: msg.value}(token, repayAmount, msg.sender);\n', '    }\n', '\n', '    // 用户还款\n', '    function _repay(\n', '        address token,\n', '        uint256 repayAmount,\n', '        address account\n', '    ) public payable whenUnpaused onlySelf returns (uint256) {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(token));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        (uint256 actualRepayAmount, bytes memory flog) = fToken.repay(\n', '            account,\n', '            repayAmount\n', '        );\n', '        controller.transferIn{value: msg.value}(\n', '            account,\n', '            token,\n', '            actualRepayAmount\n', '        );\n', '\n', '        fToken.addTotalCash(actualRepayAmount);\n', '\n', '        emit MonitorEvent("Repay", flog);\n', '        return actualRepayAmount;\n', '    }\n', '\n', '    // 用户清算\n', '    function liquidateBorrow(\n', '        address borrower,\n', '        address underlyingBorrow,\n', '        address underlyingCollateral,\n', '        uint256 repayAmount\n', '    ) public payable whenUnpaused {\n', '        require(msg.sender != borrower, "Liquidator cannot be borrower");\n', '        require(repayAmount > 0, "Liquidate amount not valid");\n', '\n', '        IFToken fTokenBorrow = IFToken(\n', '            controller.getFTokeAddress(underlyingBorrow)\n', '        );\n', '        IFToken fTokenCollateral = IFToken(\n', '            controller.getFTokeAddress(underlyingCollateral)\n', '        );\n', '        bytes memory flog = fTokenBorrow.liquidateBorrow(\n', '            msg.sender,\n', '            borrower,\n', '            repayAmount,\n', '            address(fTokenCollateral)\n', '        );\n', '        controller.transferIn{value: msg.value}(\n', '            msg.sender,\n', '            underlyingBorrow,\n', '            repayAmount\n', '        );\n', '\n', '        fTokenBorrow.addTotalCash(repayAmount);\n', '\n', '        emit MonitorEvent("LiquidateBorrow", flog);\n', '    }\n', '\n', '    // 入金token in, 为还款和存款的组合\n', '    //没有借款时，无需还款，有借款时，先还款，单独写一个进行入金，而不是直接调用mint和repay，原因在于在ETH存款时会有bug，msg.value会复用。\n', '    function tokenIn(address token, uint256 amountIn)\n', '        public\n', '        payable\n', '        whenUnpaused\n', '        rewardFor(msg.sender, RewardType.TokenIn)\n', '    {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(token));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        //先进行冲账操作\n', '        cancellingOut(token);\n', '        uint256 curBorrowBalance = fToken.borrowBalanceCurrent(msg.sender);\n', '        uint256 actualRepayAmount;\n', '\n', '        //还清欠款\n', '        if (amountIn == uint256(-1)) {\n', '            require(curBorrowBalance > 0, "no debt to repay");\n', '            if (token != EthAddressLib.ethAddress()) {\n', '                require(\n', '                    msg.value == 0,\n', '                    "msg.value should be 0 for ERC20 repay"\n', '                );\n', '                actualRepayAmount = this._repay{value: 0}(\n', '                    token,\n', '                    amountIn,\n', '                    msg.sender\n', '                );\n', '            } else {\n', '                require(\n', '                    msg.value >= curBorrowBalance,\n', '                    "msg.value need great or equal than current debt"\n', '                );\n', '                actualRepayAmount = this._repay{value: curBorrowBalance}(\n', '                    token,\n', '                    amountIn,\n', '                    msg.sender\n', '                );\n', '                if (msg.value > actualRepayAmount) {\n', '                    (bool result, ) = msg.sender.call{\n', '                        value: msg.value.sub(actualRepayAmount),\n', '                        gas: controller.transferEthGasCost()\n', '                    }("");\n', '                    require(result, "Transfer of exceed ETH failed");\n', '                }\n', '            }\n', '\n', '            emit MonitorEvent("TokenIn", abi.encode(token, actualRepayAmount));\n', '        } else {\n', '            if (curBorrowBalance > 0) {\n', '                uint256 repayEthValue = SafeMath.min(\n', '                    curBorrowBalance,\n', '                    amountIn\n', '                );\n', '                if (token != EthAddressLib.ethAddress()) {\n', '                    repayEthValue = 0;\n', '                }\n', '                actualRepayAmount = this._repay{value: repayEthValue}(\n', '                    token,\n', '                    SafeMath.min(curBorrowBalance, amountIn),\n', '                    msg.sender\n', '                );\n', '            }\n', '\n', '            // 还款数量有剩余，转为存款\n', '            if (actualRepayAmount < amountIn) {\n', '                uint256 exceedAmout = SafeMath.sub(amountIn, actualRepayAmount);\n', '                if (token != EthAddressLib.ethAddress()) {\n', '                    exceedAmout = 0;\n', '                }\n', '                this._deposit{value: exceedAmout}(\n', '                    token,\n', '                    SafeMath.sub(amountIn, actualRepayAmount),\n', '                    msg.sender\n', '                );\n', '            }\n', '\n', '            emit MonitorEvent("TokenIn", abi.encode(token, amountIn));\n', '        }\n', '    }\n', '\n', '    // 出金token out, 为取款和借款的组合,\n', '    // 取款如果该用户有对应的存款(有对应的ftoken)，完全可取出，剩余的部分采用借的逻辑,\n', '    function tokenOut(address token, uint256 amountOut) external whenUnpaused {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(token));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        //先进行冲账操作\n', '        (bool strikeOk, bytes memory strikeLog) = fToken.cancellingOut(\n', '            msg.sender\n', '        );\n', '\n', '        uint256 supplyAmount = 0;\n', '        if (amountOut == uint256(-1)) {\n', '            uint256 fBalance = fToken.balanceOf(msg.sender);\n', '            require(fBalance > 0, "no asset to withdraw");\n', '            supplyAmount = withdraw(token, fBalance);\n', '\n', '            emit MonitorEvent("TokenOut", abi.encode(token, supplyAmount));\n', '        } else {\n', '            uint256 userSupplyBalance = fToken.calcBalanceOfUnderlying(\n', '                msg.sender\n', '            );\n', '            if (userSupplyBalance > 0) {\n', '                if (userSupplyBalance < amountOut) {\n', '                    supplyAmount = withdraw(\n', '                        token,\n', '                        fToken.balanceOf(msg.sender)\n', '                    );\n', '                } else {\n', '                    supplyAmount = withdrawUnderlying(\n', '                        token,\n', '                        SafeMath.min(userSupplyBalance, amountOut)\n', '                    );\n', '                }\n', '            }\n', '\n', '            if (supplyAmount < amountOut) {\n', '                borrow(token, amountOut.sub(supplyAmount));\n', '            }\n', '\n', '            emit MonitorEvent("TokenOut", abi.encode(token, amountOut));\n', '        }\n', '    }\n', '\n', '    function cancellingOut(address token) public whenUnpaused {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(token));\n', '        //先进行冲账操作\n', '        (bool strikeOk, bytes memory strikeLog) = fToken.cancellingOut(\n', '            msg.sender\n', '        );\n', '        if (strikeOk) {\n', '            emit MonitorEvent("CancellingOut", strikeLog);\n', '        }\n', '    }\n', '}']