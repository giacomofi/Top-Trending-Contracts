['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-04\n', '*/\n', '\n', 'pragma solidity ^0.5.8;\n', '\n', '/*\n', ' * 컨트랙트 개요\n', ' * 1. 목적\n', ' *  메인넷 운영이 시작되기 전까지 한시적인 운영을 목적으로 하고 있다.\n', ' *  메인넷이 운영되면 컨트랙트의 거래는 모두 중단되며, 메인넷 코인트로 전환을 시작하며,\n', ' *  전환 절차를 간단하게 수행할 수 있으며, 블록체인 내 기록을 통해 신뢰도를 얻을 수 있도록 설계 되었다.\n', ' * 2. 용어 설명\n', ' *  Owner : 컨트랙트를 생성한 컨트랙트의 주인\n', ' *  Delegator : Owner의 Private Key를 매번 사용하기에는 보안적인 이슈가 발생할 수 있기 때문에 도입된\n', ' *              일부 Owner 권한을 실행할 수 있도록 임명한 대행자\n', ' *              특히, 컨트랙트의 거래가 중단된 상태에서 Delegator만 실행할 수 있는 전용 함수를 실행하여\n', ' *              컨트랙트의 토큰을 회수하고, 메인넷의 코인으로 전환해주는 핵심적인 기능을 수행\n', ' *  Holder : 토큰을 보유할 수 있는 Address를 가지고 있는 계정\n', ' * 3. 운용\n', ' *  3.1. TokenContainer Structure\n', ' *   3.1.1 Charge Amount\n', ' *    Charge Amount는 Holder가 구매하여 충전한 토큰량입니다.\n', ' *    Owner의 경우에는 컨트랙트 전체에 충전된 토큰량. 즉, Total Supply와 같습니다.\n', ' *   3.1.2 Balance\n', ' *    ERC20의 Balance와 같습니다.\n', ' */\n', '/*\n', ' * Contract Overview \n', ' * 1. Purpose\n', ' *  It is intended to operate for a limited time until mainnet launch.\n', ' *  When the mainnet is launched, all transactions of the contract will be suspended from that day on forward and will initiate the token swap to the mainnet.\n', ' * 2. Key Definitions\n', ' *  Owner : An entity from which smart contract is created\n', " *  Delegator : The appointed agent is created to prevent from using the contract owner's private key for every transaction made, since it can cause a serious security issue.  \n", ' *              In particular, it performs core functons at the time of the token swap event, such as executing a dedicated, Delegator-specific function while contract transaction is under suspension and\n', " *              withdraw contract's tokens. \n", ' *  Holder : An account in which tokens can be stored (also referrs to all users of the contract: Owner, Delegator, Spender, ICO buyers, ect.)\n', ' * 3. Operation\n', ' *  3.1. TokenContainer Structure\n', ' *   3.1.1 Charge Amount\n', ' *    Charge Amount is the charged token amount purcahsed by Holder.\n', ' *    In case for the Owner, the total charged amount in the contract equates to the Total Supply.\n', ' *   3.1.2 Balance\n', ' *     Similiar to the ERC20 Balance.\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '}\n', '\n', '/*\n', ' * Owner의 권한 중 일부를 대신 행사할 수 있도록 대행자를 지정/해제 할 수 있는 인터페이스를 정의하고 있다.\n', ' */\n', ' /*\n', " * It defines an interface where the Owner can appoint / dismiss an agent that can partially excercize privileges in lieu of the Owner's \n", ' */\n', 'contract Delegable is Ownable {\n', '    address private _delegator;\n', '    \n', '    event DelegateAppointed(address indexed previousDelegator, address indexed newDelegator);\n', '    \n', '    constructor () internal {\n', '        _delegator = address(0);\n', '    }\n', '    \n', '    /*\n', '     * delegator를 가져옴\n', '     */\n', '    /*\n', '     * Call-up Delegator\n', '     */\n', '    function delegator() public view returns (address) {\n', '        return _delegator;\n', '    }\n', '    \n', '    /*\n', '     * delegator만 실행 가능하도록 지정하는 접근 제한\n', '     */\n', '    /*\n', '     * Access restriction in which only appointed delegator is executable\n', '     */\n', '    modifier onlyDelegator() {\n', '        require(isDelegator());\n', '        _;\n', '    }\n', '    \n', '    /*\n', '     * owner 또는 delegator가 실행 가능하도록 지정하는 접근 제한\n', '     */\n', '    /*\n', '     * Access restriction in which only appointed delegator or Owner are executable\n', '     */\n', '    modifier ownerOrDelegator() {\n', '        require(isOwner() || isDelegator());\n', '        _;\n', '    }\n', '    \n', '    function isDelegator() public view returns (bool) {\n', '        return msg.sender == _delegator;\n', '    }\n', '    \n', '    /*\n', '     * delegator를 임명\n', '     */\n', '    /*\n', '     * Appoint the delegator\n', '     */\n', '    function appointDelegator(address delegator_) public onlyOwner returns (bool) {\n', '        require(delegator_ != address(0));\n', '        require(delegator_ != owner());\n', '        return _appointDelegator(delegator_);\n', '    }\n', '    \n', '    /*\n', '     * 지정된 delegator를 해임\n', '     */\n', '    /*\n', '     * Dimiss the appointed delegator\n', '     */\n', '    function dissmissDelegator() public onlyOwner returns (bool) {\n', '        require(_delegator != address(0));\n', '        return _appointDelegator(address(0));\n', '    }\n', '    \n', '    /*\n', '     * delegator를 변경하는 내부 함수\n', '     */\n', '    /*\n', '     * An internal function that allows delegator changes \n', '     */\n', '    function _appointDelegator(address delegator_) private returns (bool) {\n', '        require(_delegator != delegator_);\n', '        emit DelegateAppointed(_delegator, delegator_);\n', '        _delegator = delegator_;\n', '        return true;\n', '    }\n', '}\n', '\n', '/*\n', ' * ERC20의 기본 인터페이스는 유지하여 일반적인 토큰 전송이 가능하면서,\n', ' * 일부 추가 관리 기능을 구현하기 위한 Struct 및 함수가 추가되어 있습니다.\n', ' */\n', '/*\n', ' * The basic interface of ERC20 is remained untouched therefore basic functions like token transactions will be available. \n', ' * On top of that, Structs and functions have been added to implement some additional management functions.\n', ' */\n', 'contract ERC20Like is IERC20, Delegable {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 internal _totalSupply;  // 총 발행량 // Total Supply\n', '    bool isLock = false;  // 계약 잠금 플래그 // Contract Lock Flag\n', '\n', '    /*\n', '     * 토큰 정보(충전량, 해금량, 가용잔액) 및 Spender 정보를 저장하는 구조체\n', '     */\n', '    /*\n', '     * Structure that stores token information (charge, unlock, balance) as well as Spender information\n', '     */\n', '    struct TokenContainer {\n', '        uint256 balance;  // 가용잔액 // available balance\n', '        mapping (address => uint256) allowed; // Spender\n', '    }\n', '\n', '    mapping (address => TokenContainer) internal _tokenContainers;\n', '    \n', '    // 총 발행량 \n', '    // Total token supply \n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    // 가용잔액 가져오기\n', '    // Call-up available balance\n', '    function balanceOf(address holder) public view returns (uint256) {\n', '        return _tokenContainers[holder].balance;\n', '    }\n', '\n', '    // Spender의 남은 잔액 가져오기\n', "    // Call-up Spender's remaining balance\n", '    function allowance(address holder, address spender) public view returns (uint256) {\n', '        return _tokenContainers[holder].allowed[spender];\n', '    }\n', '\n', '    // 토큰송금\n', '    // Transfer token\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    // Spender 지정 및 금액 지정\n', '    // Appoint a Spender and set an amount \n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '    \n', '    function approveDelegator(address spender, uint256 value) public onlyDelegator returns (bool) {\n', '        require(msg.sender == delegator());\n', '        _approve(owner(), spender, value);\n', '        return true;\n', '    }\n', '\n', '    // Spender 토큰송금\n', '    // Transfer token via Spender \n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        _transfer(from, to, value);\n', '        _approve(from, msg.sender, _tokenContainers[from].allowed[msg.sender].sub(value));\n', '        return true;\n', '    }\n', '    \n', '    // delegator인 경우에는 owner의 잔액을 대신 보낼 수 있음.\n', '    function transferDelegator(address to, uint256 value) public onlyDelegator returns (bool) {\n', '        require(msg.sender == delegator());\n', '        _transfer(owner(), to, value);\n', '        return true;\n', '    }\n', '\n', '    // Spender가 할당 받은 양 증가\n', '    // Increase a Spender amount alloted by the Owner/Delegator\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        require(!isLock);\n', '        uint256 value = _tokenContainers[msg.sender].allowed[spender].add(addedValue);\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '    \n', '    function increaseAllowanceDelegator(address spender, uint256 addedValue) public onlyDelegator returns (bool) {\n', '        require(msg.sender == delegator());\n', '        require(!isLock);\n', '        uint256 value = _tokenContainers[owner()].allowed[spender].add(addedValue);\n', '        _approve(owner(), spender, value);\n', '        return true;\n', '    }\n', '\n', '    // Spender가 할당 받은 양 감소\n', '    // Decrease a Spender amount alloted by the Owner/Delegator\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        require(!isLock);\n', '        // 기존에 할당된 금액의 잔액보다 더 많은 금액을 줄이려고 하는 경우 할당액이 0이 되도록 처리\n', '        //// If you reduce more than the alloted amount in the balance, we made sure the alloted amount is set to zero instead of minus\n', '        if (_tokenContainers[msg.sender].allowed[spender] < subtractedValue) {\n', '            subtractedValue = _tokenContainers[msg.sender].allowed[spender];\n', '        }\n', '        \n', '        uint256 value = _tokenContainers[msg.sender].allowed[spender].sub(subtractedValue);\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '    \n', '    function decreaseAllowanceDelegator(address spender, uint256 subtractedValue) public onlyDelegator returns (bool) {\n', '        require(msg.sender == delegator());\n', '        require(!isLock);\n', '        // 기존에 할당된 금액의 잔액보다 더 많은 금액을 줄이려고 하는 경우 할당액이 0이 되도록 처리\n', '        //// If you reduce more than the alloted amount in the balance, we made sure the alloted amount is set to zero instead of minus\n', '        if (_tokenContainers[owner()].allowed[spender] < subtractedValue) {\n', '            subtractedValue = _tokenContainers[owner()].allowed[spender];\n', '        }\n', '        \n', '        uint256 value = _tokenContainers[owner()].allowed[spender].sub(subtractedValue);\n', '        _approve(owner(), spender, value);\n', '        return true;\n', '    }\n', '\n', '    // 토큰송금 내부 실행 함수 \n', '    // An internal execution function for troken transfer\n', '    function _transfer(address from, address to, uint256 value) private {\n', '        require(!isLock);\n', '        // 3.1. Known vulnerabilities of ERC-20 token\n', '        // 현재 컨트랙트로는 송금할 수 없도록 예외 처리 // Exceptions were added to not allow deposits to be made in the current contract . \n', '        require(to != address(this));\n', '        require(to != address(0));\n', '\n', '        _tokenContainers[from].balance = _tokenContainers[from].balance.sub(value);\n', '        _tokenContainers[to].balance = _tokenContainers[to].balance.add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    // Spender 지정 내부 실행 함수\n', '    // Internal execution function for assigning a Spender\n', '    function _approve(address holder, address spender, uint256 value) private {\n', '        require(!isLock);\n', '        require(spender != address(0));\n', '        require(holder != address(0));\n', '\n', '        _tokenContainers[holder].allowed[spender] = value;\n', '        emit Approval(holder, spender, value);\n', '    }\n', '\n', '    // 전체 유통량 - Owner의 unlockAmount\n', "    // Total circulation supply, or the unlockAmount of the Owner's\n", '    function circulationAmount() external view returns (uint256) {\n', '        return _totalSupply.sub(_tokenContainers[owner()].balance);\n', '    }\n', '\n', '    /*\n', '     * 계약 잠금\n', '     * 계약이 잠기면 컨트랙트의 거래가 중단된 상태가 되며,\n', '     * 거래가 중단된 상태에서는 Owner와 Delegator를 포함한 모든 Holder는 거래를 할 수 없게 된다.\n', '     */\n', '    /*\n', '     * Contract lock\n', '     * If the contract is locked, all transactions will be suspended.\n', '     * All Holders including Owner and Delegator will not be able to make transaction during suspension.\n', '     */\n', '    function lock() external onlyOwner returns (bool) {\n', '        isLock = true;\n', '        return isLock;\n', '    }\n', '\n', '    /*\n', '     * 계약 잠금 해제\n', '     * 잠긴 계약을 해제할 때 사용된다.\n', '     */\n', '    /*\n', '     * Release contract lock\n', '     * The function is used to revert a locked contract to a normal state. \n', '     */\n', '    function unlock() external onlyOwner returns (bool) {\n', '        isLock = false;\n', '        return isLock;\n', '    }\n', '}\n', '\n', 'contract RIDER is ERC20Like {\n', '    string public constant name = "RIDER";\n', '    string public constant symbol = "RDR";\n', '    uint256 public constant decimals = 18;\n', '    \n', '    event CreateToken(address indexed c_owner, string c_name, string c_symbol, uint256 c_totalSupply);\n', '\n', '    constructor () public {\n', '        _totalSupply = 3000000000 * (10 ** decimals);\n', '        _tokenContainers[msg.sender].balance = _totalSupply;\n', '        emit CreateToken(msg.sender, name, symbol, _tokenContainers[msg.sender].balance);\n', '    }\n', '}']