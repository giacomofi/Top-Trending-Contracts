['pragma solidity 0.5.17;\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', ' \n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function transfer(address, uint) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function approve(address, uint) external returns (bool);\n', '    function transferFrom(address, address, uint) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    }\n', '    \n', 'interface POWER {\n', '   \n', '   function scaledPower(uint amount) external returns(bool);\n', '   function totalPopping() external view returns (uint256);\n', ' } \n', '\n', 'interface OPERATORS {\n', '    \n', '   function scaledOperators(uint amount) external returns(bool);\n', '   function totalPopping() external view returns (uint256);\n', '   \n', ' }\n', ' \n', '    \n', '//======================================POPCORN CONTRACT=========================================//\n', 'contract PopcornToken is ERC20 {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '//======================================POPCORN EVENTS=========================================//\n', ' \n', '    event BurnEvent(address indexed pool, address indexed burnaddress, uint amount);\n', '    event AddCornEvent(address indexed _from, address indexed pool, uint value);\n', '    \n', '   \n', '    \n', '    \n', '   // ERC-20 Parameters\n', '    string public name; \n', '    string public symbol;\n', '    uint public decimals; \n', '    uint public totalSupply;\n', '    \n', '    \n', '     //======================================POPPING POOLS=========================================//\n', '    address public pool1;\n', '    address public pool2;\n', '\n', '    uint256 public power;\n', '    uint256 public operators;\n', '    uint256 operatorstotalpopping;\n', '    uint256 powertotalpopping;\n', '    \n', '    // ERC-20 Mappings\n', '    mapping(address => uint) public  balanceOf;\n', '    mapping(address => mapping(address => uint)) public  allowance;\n', '    \n', '    \n', '    // Public Parameters\n', '    uint corns; \n', '    uint  bValue;\n', '    uint  actualValue;\n', '    uint  burnAmount;\n', '    address administrator;\n', ' \n', '    \n', '     \n', '    // Public Mappings\n', '    mapping(address=>bool) public Whitelisted;\n', '    \n', '\n', '    //=====================================CREATION=========================================//\n', '    // Constructor\n', '    constructor() public {\n', '        name = "Popcorn Token"; \n', '        symbol = "CORN"; \n', '        decimals = 18; \n', '        corns = 1*10**decimals; \n', '        totalSupply = 2000000*corns;                                 \n', '        \n', '         \n', '        administrator = msg.sender;\n', '        balanceOf[administrator] = totalSupply; \n', '        emit Transfer(administrator, address(this), totalSupply);                                 \n', '                                                          \n', '        Whitelisted[administrator] = true;                                         \n', '        \n', '        \n', '        \n', '    }\n', '    \n', '//========================================CONFIGURATIONS=========================================//\n', '    \n', '       function machineries(address _power, address _operators) public onlyAdministrator returns (bool success) {\n', '   \n', '        pool1 = _power;\n', '        pool2 = _operators;\n', '        \n', '        return true;\n', '    }\n', '    \n', '    modifier onlyAdministrator() {\n', '        require(msg.sender == administrator, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '    \n', '    modifier onlyOperators() {\n', '        require(msg.sender == pool2, "Authorization: Only the operators pool can call on this");\n', '        _;\n', '    }\n', '    \n', '    function whitelist(address _address) public onlyAdministrator returns (bool success) {\n', '       Whitelisted[_address] = true;\n', '        return true;\n', '    }\n', '    \n', '    function unwhitelist(address _address) public onlyAdministrator returns (bool success) {\n', '      Whitelisted[_address] = false;\n', '        return true;\n', '    }\n', '    \n', '    \n', '    function Burn(uint _amount) public returns (bool success) {\n', '       \n', '       require(balanceOf[msg.sender] >= _amount, "You do not have the amount of tokens you wanna burn in your wallet");\n', '       balanceOf[msg.sender] -= _amount;\n', '       totalSupply -= _amount;\n', '       emit BurnEvent(pool2, address(0x0), _amount);\n', '       return true;\n', '       \n', '    }\n', '    \n', '    \n', '   //========================================ERC20=========================================//\n', '    // ERC20 Transfer function\n', '    function transfer(address to, uint value) public  returns (bool success) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    // ERC20 Approve function\n', '    function approve(address spender, uint value) public  returns (bool success) {\n', '        allowance[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    // ERC20 TransferFrom function\n', '    function transferFrom(address from, address to, uint value) public  returns (bool success) {\n', "        require(value <= allowance[from][msg.sender], 'Must not send more than allowance');\n", '        allowance[from][msg.sender] -= value;\n', '        _transfer(from, to, value);\n', '        return true;\n', '    }\n', '    \n', '  \n', '    \n', '    \n', '    function _transfer(address _from, address _to, uint _value) private {\n', '        \n', "        require(balanceOf[_from] >= _value, 'Must not send more than balance');\n", "        require(balanceOf[_to] + _value >= balanceOf[_to], 'Balance overflow');\n", '        \n', '        balanceOf[_from] -= _value;\n', '        if(Whitelisted[msg.sender]){ \n', '        \n', '          actualValue = _value;\n', '          \n', '        }else{\n', '         \n', '        bValue = mulDiv(_value, 10, 100); \n', '       \n', '        actualValue = _value.sub(bValue); \n', '        \n', '        \n', '        power = mulDiv(bValue, 50, 100);\n', '        powertotalpopping = powerTotalPopping();\n', '        \n', '        if(powertotalpopping > 0){\n', '                    \n', '                POWER(pool1).scaledPower(power);\n', '                balanceOf[pool1] += power;\n', '                emit AddCornEvent(_from, pool1, power);\n', '                emit Transfer(_from, pool1, power);\n', '                \n', '                \n', '                    \n', '                }else{\n', '                  \n', '                 totalSupply -= power; \n', '                 emit BurnEvent(_from, address(0x0), power);\n', '                    \n', '        }\n', '        \n', '        \n', '        \n', '        operators = mulDiv(bValue, 30, 100);\n', '        operatorstotalpopping = OperatorsTotalPopping();\n', '        \n', '        if(operatorstotalpopping > 0){\n', '                    \n', '                OPERATORS(pool2).scaledOperators(operators);\n', '                balanceOf[pool2] += operators;\n', '                emit AddCornEvent(_from, pool2, operators);\n', '                emit Transfer(_from, pool2, operators);\n', '                \n', '                    \n', '                }else{\n', '                  \n', '                totalSupply -= operators; \n', '                emit BurnEvent(_from, address(0x0), operators); \n', '                    \n', '        }\n', '        \n', '        \n', '        \n', '        burnAmount = mulDiv(bValue, 20, 100);\n', '        totalSupply -= burnAmount;\n', '        emit BurnEvent(_from, address(0x0), burnAmount);\n', '       \n', '        }\n', '        \n', '        \n', '       \n', '       balanceOf[_to] += actualValue;\n', '       emit Transfer(_from, _to, _value);\n', '       \n', '       \n', '    }\n', '    \n', ' \n', '  \n', '  \n', '  \n', '    function powerTotalPopping() public view returns(uint){\n', '        \n', '        return POWER(pool1).totalPopping();\n', '       \n', '    }\n', '    \n', '    function OperatorsTotalPopping() public view returns(uint){\n', '        \n', '        return OPERATORS(pool2).totalPopping();\n', '       \n', '    }\n', '    \n', '   \n', '    \n', '     function mulDiv (uint x, uint y, uint z) public pure returns (uint) {\n', '          (uint l, uint h) = fullMul (x, y);\n', '          assert (h < z);\n', '          uint mm = mulmod (x, y, z);\n', '          if (mm > l) h -= 1;\n', '          l -= mm;\n', '          uint pow2 = z & -z;\n', '          z /= pow2;\n', '          l /= pow2;\n', '          l += h * ((-pow2) / pow2 + 1);\n', '          uint r = 1;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          return l * r;\n', '    }\n', '    \n', '     function fullMul (uint x, uint y) private pure returns (uint l, uint h) {\n', '          uint mm = mulmod (x, y, uint (-1));\n', '          l = x * y;\n', '          h = mm - l;\n', '          if (mm < l) h -= 1;\n', '    }\n', '    \n', '   \n', '}']