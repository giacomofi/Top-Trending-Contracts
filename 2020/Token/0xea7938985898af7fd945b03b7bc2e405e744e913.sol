['// File: contracts/interfaces/IAuthority.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract IAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', '// File: contracts/DSAuth.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', '/**\n', ' * @title DSAuth\n', ' * @dev The DSAuth contract is reference implement of https://github.com/dapphub/ds-auth\n', ' * But in the isAuthorized method, the src from address(this) is remove for safty concern.\n', ' */\n', 'contract DSAuth is DSAuthEvents {\n', '    IAuthority   public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(IAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == owner) {\n', '            return true;\n', '        } else if (authority == IAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/PausableDSAuth.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract PausableDSAuth is DSAuth {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() public onlyOwner whenNotPaused {\n', '    paused = true;\n', '    emit Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() public onlyOwner whenPaused {\n', '    paused = false;\n', '    emit Unpause();\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: contracts/interfaces/IBurnableERC20.sol\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', 'contract IBurnableERC20 {\n', '    function burn(address _from, uint _value) public;\n', '}\n', '\n', '// File: contracts/interfaces/ISettingsRegistry.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract ISettingsRegistry {\n', '    enum SettingsValueTypes { NONE, UINT, STRING, ADDRESS, BYTES, BOOL, INT }\n', '\n', '    function uintOf(bytes32 _propertyName) public view returns (uint256);\n', '\n', '    function stringOf(bytes32 _propertyName) public view returns (string);\n', '\n', '    function addressOf(bytes32 _propertyName) public view returns (address);\n', '\n', '    function bytesOf(bytes32 _propertyName) public view returns (bytes);\n', '\n', '    function boolOf(bytes32 _propertyName) public view returns (bool);\n', '\n', '    function intOf(bytes32 _propertyName) public view returns (int);\n', '\n', '    function setUintProperty(bytes32 _propertyName, uint _value) public;\n', '\n', '    function setStringProperty(bytes32 _propertyName, string _value) public;\n', '\n', '    function setAddressProperty(bytes32 _propertyName, address _value) public;\n', '\n', '    function setBytesProperty(bytes32 _propertyName, bytes _value) public;\n', '\n', '    function setBoolProperty(bytes32 _propertyName, bool _value) public;\n', '\n', '    function setIntProperty(bytes32 _propertyName, int _value) public;\n', '\n', '    function getValueTypeOf(bytes32 _propertyName) public view returns (uint /* SettingsValueTypes */ );\n', '\n', '    event ChangeProperty(bytes32 indexed _propertyName, uint256 _type);\n', '}\n', '\n', '// File: contracts/Issuing.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '\n', 'contract Issuing is PausableDSAuth {\n', '    // claimedToken event\n', '    event ClaimedTokens(\n', '        address indexed token,\n', '        address indexed owner,\n', '        uint256 amount\n', '    );\n', '\n', '    event BurnAndRedeem(\n', '        address indexed token,\n', '        address indexed from,\n', '        uint256 amount,\n', '        bytes receiver\n', '    );\n', '\n', '    ISettingsRegistry public registry;\n', '\n', '    mapping(address => bool) public supportedTokens;\n', '\n', '    constructor(address _registry) public{\n', '        registry = ISettingsRegistry(_registry);\n', '    }\n', '\n', '    /**\n', '     * @dev ERC223 fallback function, make sure to check the msg.sender is from target token contracts\n', '     * @param _from - person who transfer token in for deposits or claim deposit with penalty KTON.\n', '     * @param _amount - amount of token.\n', '     * @param _data - data which indicate the operations.\n', '     */\n', '    function tokenFallback(\n', '        address _from,\n', '        uint256 _amount,\n', '        bytes _data\n', '    ) public whenNotPaused {\n', '        bytes32 darwiniaAddress;\n', '\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            calldatacopy(ptr, 0, calldatasize)\n', '            darwiniaAddress := mload(add(ptr, 132))\n', '        }\n', '\n', '        //  Only supported tokens can be called\n', '        require(supportedTokens[msg.sender], "Permission denied");\n', '        require(\n', '            _data.length == 32,\n', '            "The address (Darwinia Network) must be in a 32 bytes hexadecimal format"\n', '        );\n', '        require(\n', '            darwiniaAddress != bytes32(0),\n', '            "Darwinia Network Address can\'t be empty"\n', '        );\n', '\n', '        // SettingIds.UINT_BRIDGE_FEE\n', '        uint256 bridgeFee = registry.uintOf(\n', '            0x55494e545f4252494447455f4645450000000000000000000000000000000000\n', '        );\n', '\n', '        // SettingIds.CONTRACT_BRIDGE_POOL\n', '        address bridgePool = registry.addressOf(\n', '            0x434f4e54524143545f4252494447455f504f4f4c000000000000000000000000\n', '        );\n', '\n', '        // SettingIds.CONTRACT_RING_ERC20_TOKEN\n', '        address ring = registry.addressOf(\n', '            0x434f4e54524143545f52494e475f45524332305f544f4b454e00000000000000\n', '        );\n', '\n', '        // BridgeFee will be paid to the relayer\n', '        if (bridgeFee > 0) {\n', '            require(\n', '                ERC20(ring).transferFrom(_from, bridgePool, bridgeFee),\n', '                "Error when paying transaction fees"\n', '            );\n', '        }\n', '\n', '        IBurnableERC20(msg.sender).burn(address(this), _amount);\n', '        emit BurnAndRedeem(msg.sender, _from, _amount, _data);\n', '    }\n', '\n', '    function addSupportedTokens(address _token) public auth {\n', '        supportedTokens[_token] = true;\n', '    }\n', '\n', '    function removeSupportedTokens(address _token) public auth {\n', '        supportedTokens[_token] = false;\n', '    }\n', '\n', '    /// @notice This method can be used by the owner to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    function claimTokens(address _token) public auth {\n', '        if (_token == 0x0) {\n', '            owner.transfer(address(this).balance);\n', '            return;\n', '        }\n', '        ERC20 token = ERC20(_token);\n', '        uint256 balance = token.balanceOf(address(this));\n', '        token.transfer(owner, balance);\n', '\n', '        emit ClaimedTokens(_token, owner, balance);\n', '    }\n', '}']