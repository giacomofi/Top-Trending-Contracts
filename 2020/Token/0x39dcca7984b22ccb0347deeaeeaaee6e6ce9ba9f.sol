['// SPDX-License-Identifier: MIT\n', '// ----------------------------------------------------------------------------\n', '// yBXTB Utility Token\n', '//\n', '// Symbol        : yBXTB\n', '// Name          : Yield Token BXTB\n', '// Initial supply: 100,000,000.000000\n', '// Decimals      : 6\n', '// ----------------------------------------------------------------------------\n', 'pragma solidity ^0.7.4;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function addSafe(uint _a, uint _b) internal pure returns (uint c) {\n', '        c = _a + _b;\n', '        require(c >= _a);\n', '    }\n', '    function subSafe(uint _a, uint _b) internal pure returns (uint c) {\n', '        require(_b <= _a, "Insufficient balance");\n', '        c = _a - _b;\n', '    }\n', '    function mulSafe(uint _a, uint _b) internal pure returns (uint c) {\n', '        c = _a * _b;\n', '        require(_a == 0 || c / _a == _b);\n', '    }\n', '    function divSafe(uint _a, uint _b) internal pure returns (uint c) {\n', '        require(_b > 0);\n', '        c = _a / _b;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', '// ----------------------------------------------------------------------------\n', 'interface ERC20Interface {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address _tokenOwner) external view returns (uint);\n', '    function allowance(address _tokenOwner, address _spender) external view returns (uint);\n', '    function transfer(address _to, uint _amount) external returns (bool);\n', '    function approve(address _spender, uint _amount) external returns (bool);\n', '    function transferFrom(address _from, address _to, uint _amount) external returns (bool);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _tokens);\n', '    event Approval(address indexed _tokenOwner, address indexed _spender, uint _tokens);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '// ----------------------------------------------------------------------------\n', 'interface ApproveAndCallFallBack {\n', '    function receiveApproval(address _tokenOwner, uint256 _amount, address _token, bytes memory _data) external;\n', '}\n', '\n', 'interface SettlementInterface {\n', '    function disburseCommissions(bool _disburseBackstop) external;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Token, with the addition of symbol, name and decimals and a\n', '// fixed supply\n', '// ----------------------------------------------------------------------------\n', 'contract yBXTBToken is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public constant symbol = "yBXTB";\n', '    string public constant name = "Yield Token for BXTB";\n', '    uint public constant decimals = 6;\n', '    uint totalSupplyAmount;\n', '\n', '    mapping(address => uint) public balances;\n', '    mapping(address => mapping(address => uint)) public allowed;\n', '\n', '    uint public pausedForSettlementBlock;\n', '\n', '    address public settlementAdmin;\n', '    address public serviceContractAddress;\n', '\n', '    bool public pausedForSettlement;\n', '\n', '    constructor() {\n', '        totalSupplyAmount = 100000000 * 10**uint(decimals);\n', '        emit Mint(totalSupplyAmount);\n', '\n', '        balances[owner] = totalSupplyAmount;\n', '        emit Transfer(address(0), owner, totalSupplyAmount);\n', '    }\n', '\n', '    // Fix for the ERC20 short address attack\n', '    modifier onlyPayloadSize(uint _size) {\n', '        require(msg.data.length == _size + 4, "Input length error");\n', '        _;\n', '    }\n', '\n', '    modifier pauseCheck {\n', '        if(pausedForSettlement == true) {\n', '            // Auto release lock after 10 blocks to prevent deadlock\n', '            if(block.number.subSafe(pausedForSettlementBlock) >= 10) pausedForSettlement = false;\n', '            else revert("Paused for settlement");\n', '        }\n', '        _;\n', '    }\n', '\n', '    // When new coins are minted after contract creation\n', '    event Mint(uint _amount);\n', '\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Standard ERC20 implementations\n', '    // ----------------------------------------------------------------------------\n', '    // Read\n', '    function totalSupply() public override view returns (uint) {\n', '        return totalSupplyAmount.subSafe(balances[address(0)]);\n', '    }\n', '    function balanceOf(address _tokenOwner) public override view returns (uint) {\n', '        return balances[_tokenOwner];\n', '    }\n', '    function allowance(address _tokenOwner, address _spender) public override view returns (uint) {\n', '        return allowed[_tokenOwner][_spender];\n', '    }\n', '\n', '    // Write\n', '    function transfer(address _to, uint _amount) public override onlyPayloadSize(2 * 32) pauseCheck returns (bool) {\n', '        require(_to != address(this), "Can not transfer to this");\n', '        if(serviceContractAddress != address(0)) require(_to != serviceContractAddress, "Address not allowed");\n', '\n', '        balances[msg.sender] = balances[msg.sender].subSafe(_amount);\n', '        balances[_to] = balances[_to].addSafe(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '    function approve(address _spender, uint _amount) public override onlyPayloadSize(2 * 32) pauseCheck returns (bool) {\n', '        require(_amount <= balances[msg.sender], "Insufficient balance");\n', '\n', '        // To change the approve amount you first have to reduce the`\n', '        // allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        // already 0 to mitigate the race condition described here:\n', '        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if(_amount > 0) require(allowed[msg.sender][_spender] == 0, "Zero allowance first");\n', '\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '    function transferFrom(address _tokenOwner, address _to, uint _amount) public override onlyPayloadSize(3 * 32) pauseCheck returns (bool) {\n', '        require(_to != address(this), "Can not transfer to this");\n', '        allowed[_tokenOwner][msg.sender] = allowed[_tokenOwner][msg.sender].subSafe(_amount);\n', '        balances[_tokenOwner] = balances[_tokenOwner].subSafe(_amount);\n', '        balances[_to] = balances[_to].addSafe(_amount);\n', '        emit Transfer(_tokenOwner, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Other admin, common and courtesy functions\n', '    // ----------------------------------------------------------------------------\n', '    function approveAndCall(address _spender, uint _amount, bytes memory _data) pauseCheck public returns (bool) {\n', '        // Prevent ERC20 short address attack\n', '        // _data length is not fixed. These bytes are packed into 32 byte chunks\n', '        uint length256;\n', '        if(_data.length > 0) {\n', '            length256 = _data.length / 32;\n', '            if(32 * length256 < _data.length) length256++;\n', '        }\n', '        require(msg.data.length == (((4 + length256) * 32) + 4), "Input length error");\n', '        require(_amount <= balances[msg.sender], "Insufficient balance");\n', '\n', '        // To change the approve amount you first have to reduce the`\n', '        // allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        // already 0 to mitigate the race condition described here:\n', '        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if(_amount > 0) require(allowed[msg.sender][_spender] == 0, "Zero allowance first");\n', '\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _data);\n', '        return true;\n', '    }\n', '    function mint(uint _newTokens) public onlyOwner pauseCheck {\n', '        totalSupplyAmount = totalSupplyAmount.addSafe(_newTokens);\n', '        emit Mint(totalSupplyAmount);\n', '\n', '        balances[owner] = balances[owner].addSafe(_newTokens);\n', '        emit Transfer(address(0), owner, _newTokens);\n', '    }\n', '    function totalOutstanding() public view returns (uint) {\n', '        // Outstanding token = total supply - contract owner - burned\n', '        uint outOfCirculation;\n', '        if(owner == address(0)) outOfCirculation = balances[address(0)];\n', '        else outOfCirculation = balances[address(0)].addSafe(balances[owner]);\n', '        return totalSupplyAmount.subSafe(outOfCirculation);\n', '    }\n', '    function setServiceContractAddress(address _setAddress) public onlyOwner onlyPayloadSize(1 * 32) {\n', '        // Prevent lost coins in companion service contract when user accidentally calls transfer()\n', '        serviceContractAddress = _setAddress;\n', '    }\n', '    function performSettlement(bool _doPause, bool _doDisburseCommission, bool _doDisburseBackstop) external {\n', '        require((msg.sender == settlementAdmin) || (msg.sender == owner), "Caller not authorized");\n', '        // Disable or enable transfer(), transferFrom(), etc. functions\n', '        pausedForSettlement = _doPause;\n', '        if(_doPause == true) pausedForSettlementBlock = block.number;\n', '        if(_doDisburseCommission == true) {\n', '            // Call service contract to disburse commissions and backstop balances\n', '            require(serviceContractAddress != address(0), "Service Contract not set");\n', '            SettlementInterface(serviceContractAddress).disburseCommissions(_doDisburseBackstop);\n', '        }\n', '    }\n', '    // Change Settlement Admin for daily settlements\n', '    function changeSettlementAdmin(address _newAddress) external {\n', '        require(msg.data.length == 32 + 4, "Address error");  // Prevent input error\n', '        require((msg.sender == settlementAdmin) || (msg.sender == owner), "Caller not authorized");\n', '        settlementAdmin = _newAddress;\n', '    }\n', '    // Retrieve any ERC20 tokens accidentally sent to this contract for owner\n', '    function transferAnyERC20Token(address _fromTokenContract, uint _amount) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(_fromTokenContract).transfer(owner, _amount);\n', '    }\n', '\n', '}']