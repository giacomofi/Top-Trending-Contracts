['pragma solidity 0.4.25;\n', '\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address  to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transferFrom(address from, address  to, uint256 value) public returns (bool);\n', '    function approve(address  spender, uint256 value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract DetailedERC20 is ERC20 {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    \n', '    constructor(string _name, string _symbol, uint8 _decimals) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    using SafeMath for uint256;\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    mapping(address => uint256) public balances;\n', '    uint256 public _totalSupply;\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '    \n', '    \n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(_to != address(0) && _value != 0 &&_value <= balances[msg.sender],"Please check the amount of transmission error and the amount you send.");\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '}\n', '\n', 'contract ERC20Token is BasicToken, ERC20 {\n', '    using SafeMath for uint256;\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '    mapping (address => uint256) public freezeOf;\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        \n', '        require(_value == 0 || allowed[msg.sender][_spender] == 0,"Please check the amount you want to approve.");\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '    \n', '    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool success) {\n', '        uint256 oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue >= oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    \n', '    address public owner;\n', '    mapping (address => bool) public admin;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner,"I am not the owner of the wallet.");\n', '        _;\n', '    }\n', '    \n', '    modifier onlyOwnerOrAdmin() {\n', '        require(msg.sender == owner || admin[msg.sender] == true,"It is not the owner or manager wallet address.");\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0) && newOwner != owner && admin[newOwner] == true,"It must be the existing manager wallet, not the existing owner\'s wallet.");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '    \n', '    function setAdmin(address newAdmin) onlyOwner public {\n', '        require(admin[newAdmin] != true && owner != newAdmin,"It is not an existing administrator wallet, and it must not be the owner wallet of the token.");\n', '        admin[newAdmin] = true;\n', '    }\n', '    \n', '    function unsetAdmin(address Admin) onlyOwner public {\n', '        require(admin[Admin] != false && owner != Admin,"This is an existing admin wallet, it must not be a token holder wallet.");\n', '        admin[Admin] = false;\n', '    }\n', '\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '    bool public paused = false;\n', '    \n', '    modifier whenNotPaused() {\n', '        require(!paused,"There is a pause.");\n', '        _;\n', '    }\n', '    \n', '    modifier whenPaused() {\n', '        require(paused,"It is not paused.");\n', '        _;\n', '    }\n', '    \n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '    \n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {return 0; }\t\n', '        uint256 c = a * b;\n', '        require(c / a == b,"An error occurred in the calculation process");\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b !=0,"The number you want to divide must be non-zero.");\n', '        uint256 c = a / b;\n', '        require(c * b == a,"An error occurred in the calculation process");\n', '        return c;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a,"There are more to deduct.");\n', '        return a - b;\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a,"The number did not increase.");\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract BurnableToken is BasicToken, Ownable {\n', '    \n', '    event Burn(address indexed burner, uint256 amount);\n', '\n', '    function burn(uint256 _value) onlyOwner public {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        _totalSupply = _totalSupply.sub(_value);\n', '        emit Burn(msg.sender, _value);\n', '        emit Transfer(msg.sender, address(0), _value);\n', '    }\n', '\n', '    function burnAddress(address _from, uint256 _value) onlyOwner public {\n', '        balances[_from] = balances[_from].sub(_value);\n', '        _totalSupply = _totalSupply.sub(_value);\n', '        emit Burn(_from, _value);\n', '        emit Transfer(_from, address(0), _value);\n', '    }\n', '}\n', '\n', '\n', 'contract FreezeToken is BasicToken, Ownable {\n', '    \n', '    event Freezen(address indexed freezer, uint256 amount);\n', '    event UnFreezen(address indexed freezer, uint256 amount);\n', '    mapping (address => uint256) public freezeOf;\n', '    \n', '    function freeze(uint256 _value) onlyOwner public {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        freezeOf[msg.sender] = freezeOf[msg.sender].add(_value);\n', '        _totalSupply = _totalSupply.sub(_value);\n', '        emit Freezen(msg.sender, _value);\n', '    }\n', '    \n', '    function unfreeze(uint256 _value) onlyOwner public {\n', '        require(_value <= _totalSupply && freezeOf[msg.sender] >= _value,"The number to be processed is more than the total amount and the number currently frozen.");\n', '        balances[msg.sender] = balances[msg.sender].add(_value);\n', '        freezeOf[msg.sender] = freezeOf[msg.sender].sub(_value);\n', '        _totalSupply = _totalSupply.add(_value);\n', '        emit Freezen(msg.sender, _value);\n', '    }\n', '}\n', '\n', '\n', 'contract KhaiInfinityCoin is BurnableToken,FreezeToken, DetailedERC20, ERC20Token,Pausable{\n', '    using SafeMath for uint256;\n', '    \n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event LockerChanged(address indexed owner, uint256 amount);\n', '    event Recall(address indexed owner, uint256 amount);\n', '    event TimeLockerChanged(address indexed owner, uint256 time, uint256 amount);\n', '    event TimeLockerChangedTime(address indexed owner, uint256 time);\n', '    event TimeLockerChangedBalance(address indexed owner, uint256 amount);\n', '    \n', '    mapping(address => uint) public locked;\n', '    mapping(address => uint) public time;\n', '    mapping(address => uint) public timeLocked;\n', '    mapping(address => uint) public unLockAmount;\n', '    \n', '    string public s_symbol = "KHAI";\n', '    string public s_name = "Khai Infinity Coin";\n', '    uint8 public s_decimals = 18;\n', '    uint256 public TOTAL_SUPPLY = 20*(10**8)*(10**uint256(s_decimals));\n', '    \n', '    constructor() DetailedERC20(s_name, s_symbol, s_decimals) public {\n', '        _totalSupply = TOTAL_SUPPLY;\n', '        balances[owner] = _totalSupply;\n', '        emit Transfer(address(0x0), msg.sender, _totalSupply);\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value)  public whenNotPaused returns (bool){\n', '        require(balances[msg.sender].sub(_value) >= locked[msg.sender].add(timeLocked[msg.sender]),"Attempting to send more than the locked number");\n', '        return super.transfer(_to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool){\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        \n', '        return true;\n', '        \n', '    }\n', '    \n', '    function lockOf(address _address) public view returns (uint256 _locker) {\n', '        return locked[_address];\n', '    }\n', '    \n', '    function setLock(address _address, uint256 _value) public onlyOwnerOrAdmin {\n', '        require(_value <= _totalSupply &&_address != address(0),"It is the first wallet or attempted to lock an amount greater than the total holding.");\n', '        locked[_address] = _value;\n', '        emit LockerChanged(_address, _value);\n', '    }\n', '    \n', '    function unlock(address _address, uint256 _value) public onlyOwnerOrAdmin {\n', '        require(_value <= _totalSupply &&_address != address(0),"It is the first wallet or attempted to lock an amount greater than the total holding.");\n', '        locked[_address] = locked[_address].sub(_value);\n', '        emit LockerChanged(_address, _value);\n', '    }\n', '    \n', '    function recall(address _from, uint256 _amount) public onlyOwnerOrAdmin {\n', '        require(_amount != 0 ,"The number you want to retrieve is not zero, it must be greater than zero.");\n', '        uint256 currentLocker = locked[_from];\n', '        uint256 currentBalance = balances[_from];\n', '        require(currentLocker >= _amount && currentBalance >= _amount,"The number you wish to collect must be greater than the holding amount and greater than the locked number.");\n', '        \n', '        uint256 newLock = currentLocker.sub(_amount);\n', '        locked[_from] = newLock;\n', '        emit LockerChanged(_from, newLock);\n', '        \n', '        balances[_from] = balances[_from].sub(_amount);\n', '        balances[owner] = balances[owner].add(_amount);\n', '        emit Transfer(_from, owner, _amount);\n', '        emit Recall(_from, _amount);\n', '        \n', '    }\n', '    \n', '    function transferList(address[] _addresses, uint256[] _balances) public onlyOwnerOrAdmin{\n', '        require(_addresses.length == _balances.length,"The number of wallet arrangements and the number of amounts are different.");\n', '        \n', '        for (uint i=0; i < _addresses.length; i++) {\n', '            balances[msg.sender] = balances[msg.sender].sub(_balances[i]);\n', '            balances[_addresses[i]] = balances[_addresses[i]].add(_balances[i]);\n', '            emit Transfer(msg.sender,_addresses[i],_balances[i]);\n', '        }\n', '    }\n', '    \n', '    function setLockList(address[] _recipients, uint256[] _balances) public onlyOwnerOrAdmin{\n', '        require(_recipients.length == _balances.length,"The number of wallet arrangements and the number of amounts are different.");\n', '        \n', '        for (uint i=0; i < _recipients.length; i++) {\n', '            locked[_recipients[i]] = _balances[i];\n', '            emit LockerChanged(_recipients[i], _balances[i]);\n', '        }\n', '    }\n', '    /**\n', "\t* @dev timeLock 10% of the lock quantity is deducted from the customer's wallet every specific time.\n", '\t* @param _address Lockable wallet\n', '\t* @param _time The time the lock is released\n', '\t* @param _value Number of locks\n', '\t*/\n', ' \n', '\t\n', '    function timeLock(address _address,uint256 _time, uint256 _value) public onlyOwnerOrAdmin{\n', '        require(_address != address(0),"Same as the original wallet address.");\n', '        \n', '\t\t// Divide by 10 to find the number to be subtracted.\n', '        uint256 unlockAmount = _value.div(10);\n', '        \n', '        time[_address] = _time;\n', '\t\t\n', '\t\t//Add the locked count.\n', '        timeLocked[_address] = timeLocked[_address].add(_value);\n', '\t\t\n', '\t\t//unLockAmount Adds the number to be released.\n', '        unLockAmount[_address] = unLockAmount[_address].add(unlockAmount);\n', '\t\t\n', '        emit TimeLockerChanged(_address,_time,_value);\n', '    }\n', '    \n', '    function lockTimeStatus(address _address) public view returns (uint256 _time) {\n', '        return time[_address];\n', '    }\n', '    \n', '    function lockTimeAmountOf(address _address) public view returns (uint256 _value) {\n', '        return unLockAmount[_address];\n', '    }\n', '    \n', '    function lockTimeBalanceOf(address _address) public view returns (uint256 _value) {\n', '        return timeLocked[_address];\n', '    }\n', '    \n', '    function untimeLock(address _address) public onlyOwnerOrAdmin{\n', '        require(_address != address(0),"Same as the original wallet address.");\n', '        \n', '        uint256 unlockAmount = unLockAmount[_address];\n', '        uint256 nextTime = block.timestamp + 30 days;\n', '        time[_address] = nextTime;\n', '        timeLocked[_address] = timeLocked[_address].sub(unlockAmount);\n', '        \n', '        emit TimeLockerChanged(_address,nextTime,unlockAmount);\n', '    }\n', '    \n', '    function timeLockList(address[] _addresses,uint256[] _time, uint256[] _value) public onlyOwnerOrAdmin{\n', '        require(_addresses.length == _value.length && _addresses.length == _time.length); \n', '        \n', '        for (uint i=0; i < _addresses.length; i++) {\n', '            uint256 unlockAmount = _value[i].div(10);\n', '            time[_addresses[i]] = _time[i];\n', '            timeLocked[_addresses[i]] = timeLocked[_addresses[i]].add(_value[i]);\n', '            unLockAmount[_addresses[i]] = unLockAmount[_addresses[i]].add(unlockAmount);\n', '            emit TimeLockerChanged(_addresses[i],_time[i],_value[i]);    \n', '        }\n', '    }\n', '    \n', '    function unTimeLockList(address[] _addresses) public onlyOwnerOrAdmin{\n', '        \n', '        for (uint i=0; i < _addresses.length; i++) {\n', '            uint256 unlockAmount = unLockAmount[_addresses[i]];\n', '            uint256 nextTime = block.timestamp + 30 days;\n', '            time[_addresses[i]] = nextTime;\n', '            timeLocked[_addresses[i]] = timeLocked[_addresses[i]].sub(unlockAmount);\n', '            emit TimeLockerChanged(_addresses[i],nextTime,unlockAmount);\n', '        }\n', '    }\n', '    \n', '    function timeLockSetTime(address _address,uint256 _time) public onlyOwnerOrAdmin{\n', '        require(_address != address(0),"Same as the original wallet address.");\n', '        \n', '        time[_address] = _time;\n', '        emit TimeLockerChangedTime(_address,_time);\n', '\n', '    }\n', '    \n', '    function timeLockSetBalance(address _address,uint256 _value) public onlyOwnerOrAdmin{\n', '        require(_address != address(0),"Same as the original wallet address.");\n', '        \n', '        timeLocked[_address] = _value;\n', '        emit TimeLockerChangedBalance(_address,_value);\n', '    }\n', '    \n', '    function() public payable {\n', '        revert();\n', '    }\n', '}']