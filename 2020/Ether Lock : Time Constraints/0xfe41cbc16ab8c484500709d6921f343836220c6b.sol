['// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address _who) public view returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender)\n', '    public view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    public returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', '// File: @evolutionland/common/contracts/interfaces/ISettingsRegistry.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract ISettingsRegistry {\n', '    enum SettingsValueTypes { NONE, UINT, STRING, ADDRESS, BYTES, BOOL, INT }\n', '\n', '    function uintOf(bytes32 _propertyName) public view returns (uint256);\n', '\n', '    function stringOf(bytes32 _propertyName) public view returns (string);\n', '\n', '    function addressOf(bytes32 _propertyName) public view returns (address);\n', '\n', '    function bytesOf(bytes32 _propertyName) public view returns (bytes);\n', '\n', '    function boolOf(bytes32 _propertyName) public view returns (bool);\n', '\n', '    function intOf(bytes32 _propertyName) public view returns (int);\n', '\n', '    function setUintProperty(bytes32 _propertyName, uint _value) public;\n', '\n', '    function setStringProperty(bytes32 _propertyName, string _value) public;\n', '\n', '    function setAddressProperty(bytes32 _propertyName, address _value) public;\n', '\n', '    function setBytesProperty(bytes32 _propertyName, bytes _value) public;\n', '\n', '    function setBoolProperty(bytes32 _propertyName, bool _value) public;\n', '\n', '    function setIntProperty(bytes32 _propertyName, int _value) public;\n', '\n', '    function getValueTypeOf(bytes32 _propertyName) public view returns (uint /* SettingsValueTypes */ );\n', '\n', '    event ChangeProperty(bytes32 indexed _propertyName, uint256 _type);\n', '}\n', '\n', '// File: @evolutionland/common/contracts/interfaces/IBurnableERC20.sol\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', 'contract IBurnableERC20 {\n', '    function burn(address _from, uint _value) public;\n', '}\n', '\n', '// File: @evolutionland/common/contracts/interfaces/IMintableERC20.sol\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', 'contract IMintableERC20 {\n', '\n', '    function mint(address _to, uint256 _value) public;\n', '}\n', '\n', '// File: @evolutionland/common/contracts/interfaces/IAuthority.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract IAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) public view returns (bool);\n', '}\n', '\n', '// File: @evolutionland/common/contracts/DSAuth.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', '/**\n', ' * @title DSAuth\n', ' * @dev The DSAuth contract is reference implement of https://github.com/dapphub/ds-auth\n', ' * But in the isAuthorized method, the src from address(this) is remove for safty concern.\n', ' */\n', 'contract DSAuth is DSAuthEvents {\n', '    IAuthority   public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(IAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == owner) {\n', '            return true;\n', '        } else if (authority == IAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '}\n', '\n', '// File: @evolutionland/common/contracts/SettingIds.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', '    Id definitions for SettingsRegistry.sol\n', '    Can be used in conjunction with the settings registry to get properties\n', '*/\n', 'contract SettingIds {\n', '    bytes32 public constant CONTRACT_RING_ERC20_TOKEN = "CONTRACT_RING_ERC20_TOKEN";\n', '\n', '    bytes32 public constant CONTRACT_KTON_ERC20_TOKEN = "CONTRACT_KTON_ERC20_TOKEN";\n', '\n', '    bytes32 public constant CONTRACT_GOLD_ERC20_TOKEN = "CONTRACT_GOLD_ERC20_TOKEN";\n', '\n', '    bytes32 public constant CONTRACT_WOOD_ERC20_TOKEN = "CONTRACT_WOOD_ERC20_TOKEN";\n', '\n', '    bytes32 public constant CONTRACT_WATER_ERC20_TOKEN = "CONTRACT_WATER_ERC20_TOKEN";\n', '\n', '    bytes32 public constant CONTRACT_FIRE_ERC20_TOKEN = "CONTRACT_FIRE_ERC20_TOKEN";\n', '\n', '    bytes32 public constant CONTRACT_SOIL_ERC20_TOKEN = "CONTRACT_SOIL_ERC20_TOKEN";\n', '\n', '    bytes32 public constant CONTRACT_OBJECT_OWNERSHIP = "CONTRACT_OBJECT_OWNERSHIP";\n', '\n', '    bytes32 public constant CONTRACT_TOKEN_LOCATION = "CONTRACT_TOKEN_LOCATION";\n', '\n', '    bytes32 public constant CONTRACT_LAND_BASE = "CONTRACT_LAND_BASE";\n', '\n', '    bytes32 public constant CONTRACT_USER_POINTS = "CONTRACT_USER_POINTS";\n', '\n', '    bytes32 public constant CONTRACT_INTERSTELLAR_ENCODER = "CONTRACT_INTERSTELLAR_ENCODER";\n', '\n', '    bytes32 public constant CONTRACT_DIVIDENDS_POOL = "CONTRACT_DIVIDENDS_POOL";\n', '\n', '    bytes32 public constant CONTRACT_TOKEN_USE = "CONTRACT_TOKEN_USE";\n', '\n', '    bytes32 public constant CONTRACT_REVENUE_POOL = "CONTRACT_REVENUE_POOL";\n', '\n', '    bytes32 public constant CONTRACT_ERC721_BRIDGE = "CONTRACT_ERC721_BRIDGE";\n', '\n', '    bytes32 public constant CONTRACT_PET_BASE = "CONTRACT_PET_BASE";\n', '\n', '    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\n', '    // this can be considered as transaction fee.\n', '    // Values 0-10,000 map to 0%-100%\n', '    // set ownerCut to 4%\n', '    // ownerCut = 400;\n', '    bytes32 public constant UINT_AUCTION_CUT = "UINT_AUCTION_CUT";  // Denominator is 10000\n', '\n', '    bytes32 public constant UINT_TOKEN_OFFER_CUT = "UINT_TOKEN_OFFER_CUT";  // Denominator is 10000\n', '\n', '    // Cut referer takes on each auction, measured in basis points (1/100 of a percent).\n', '    // which cut from transaction fee.\n', '    // Values 0-10,000 map to 0%-100%\n', '    // set refererCut to 4%\n', '    // refererCut = 400;\n', '    bytes32 public constant UINT_REFERER_CUT = "UINT_REFERER_CUT";\n', '\n', '    bytes32 public constant CONTRACT_LAND_RESOURCE = "CONTRACT_LAND_RESOURCE";\n', '}\n', '\n', '// File: contracts/BankSettingIds.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract BankSettingIds is SettingIds {\n', '\n', '    // depositing X RING for 12 months, interest is about (1 * _unitInterest * X / 10**7) KTON\n', '    // default: 1000\n', '    bytes32 public constant UINT_BANK_UNIT_INTEREST = "UINT_BANK_UNIT_INTEREST";\n', '\n', '    // penalty multiplier\n', '    // default: 3\n', '    bytes32 public constant UINT_BANK_PENALTY_MULTIPLIER = "UINT_BANK_PENALTY_MULTIPLIER";\n', '}\n', '\n', '// File: contracts/GringottsBankV2.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract  GringottsBank is DSAuth, BankSettingIds {\n', '    /*\n', '     *  Events\n', '     */\n', '    event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\n', '\n', '    event NewDeposit(uint256 indexed _depositID, address indexed _depositor, uint _value, uint _month, uint _interest);\n', '\n', '    event ClaimedDeposit(uint256 indexed _depositID, address indexed _depositor, uint _value, bool isPenalty, uint penaltyAmount);\n', '\n', '    event TransferDeposit(uint256 indexed _depositID, address indexed _oldDepositor, address indexed _newDepositor);\n', '\n', '    event BurnAndRedeem(uint256 indexed _depositID,  address _depositor, uint48 _months, uint48 _startAt, uint64 _unitInterest, uint128 _value, bytes _data);\n', '\n', '    /*\n', '     *  Constants\n', '     */\n', '    uint public constant MONTH = 30 * 1 days;\n', '\n', '    /*\n', '     *  Structs\n', '     */\n', '    struct Deposit {\n', '        address depositor;\n', "        uint48 months; // Length of time from the deposit's beginning to end (in months), For now, months must >= 1 and <= 36\n", '        uint48 startAt;   // when player deposit, timestamp in seconds\n', '        uint128 value;  // amount of ring\n', '        uint64 unitInterest;\n', '        bool claimed;\n', '    }\n', '\n', '\n', '    /*\n', '     *  Storages\n', '     */\n', '\n', '    bool private singletonLock = false;\n', '\n', '\n', '    ISettingsRegistry public registry;\n', '\n', '    mapping (uint256 => Deposit) public deposits;\n', '\n', '    uint public depositCount;\n', '\n', '    mapping (address => uint[]) public userDeposits;\n', '\n', '    // player => totalDepositRING, total number of ring that the player has deposited\n', '    mapping (address => uint256) public userTotalDeposit;\n', '\n', '    /*\n', '     *  Modifiers\n', '     */\n', '    modifier singletonLockCall() {\n', '        require(!singletonLock, "Only can call once");\n', '        _;\n', '        singletonLock = true;\n', '    }\n', '\n', '    modifier canBeStoredWith128Bits(uint256 _value) {\n', '        require(_value < 340282366920938463463374607431768211455);\n', '        _;\n', '    }\n', '\n', '    modifier canBeStoredWith48Bits(uint256 _value) {\n', '        require(_value < 281474976710656);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', "     * @dev Bank's constructor which set the token address and unitInterest_\n", '     */\n', '    constructor () public {\n', '        // initializeContract(_registry);\n', '    }\n', '\n', '    /**\n', '     * @dev Same with constructor, but is used and called by storage proxy as logic contract.\n', '     * @param _registry - address of SettingsRegistry\n', '     */\n', '    function initializeContract(address _registry) public singletonLockCall {\n', "        // call Ownable's constructor\n", '        owner = msg.sender;\n', '\n', '        emit LogSetOwner(msg.sender);\n', '\n', '        registry = ISettingsRegistry(_registry);\n', '    }\n', '\n', '    function getDeposit(uint _id) public view returns (address, uint128, uint128, uint256, uint256, bool ) {\n', '        return (deposits[_id].depositor, deposits[_id].value, deposits[_id].months,\n', '            deposits[_id].startAt, deposits[_id].unitInterest, deposits[_id].claimed);\n', '    }\n', '\n', '    /**\n', '     * @dev ERC223 fallback function, make sure to check the msg.sender is from target token contracts\n', '     * @param _from - person who transfer token in for deposits or claim deposit with penalty KTON.\n', '     * @param _amount - amount of token.\n', '     * @param _data - data which indicate the operations.\n', '     */\n', '    function tokenFallback(address _from, uint256 _amount, bytes _data) public {\n', '        address ring = registry.addressOf(SettingIds.CONTRACT_RING_ERC20_TOKEN);\n', '        address kryptonite = registry.addressOf(SettingIds.CONTRACT_KTON_ERC20_TOKEN);\n', '\n', '        // deposit entrance\n', '        if(ring == msg.sender) {\n', '            uint months = bytesToUint256(_data);\n', '            _deposit(_from, _amount, months);\n', '        }\n', '        //  Early Redemption entrance\n', '\n', '        if (kryptonite == msg.sender) {\n', '            uint _depositID = bytesToUint256(_data);\n', '\n', '            require(_amount >= computePenalty(_depositID), "No enough amount of KTON penalty.");\n', '\n', '            _claimDeposit(_from, _depositID, true, _amount);\n', '\n', '            // burn the KTON transferred in\n', '            IBurnableERC20(kryptonite).burn(address(this), _amount);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @dev transfer of deposit from  Ethereum network to Darwinia Network, params can be obtained by the function 'getDeposit'\n", '     * @param _depositID - ID of deposit.\n', '     * @param _data - receiving address of darwinia network.\n', '\n', '     */\n', '    function burnAndRedeem(uint256 _depositID, bytes _data) public {\n', '        bytes32 darwiniaAddress;\n', '\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            calldatacopy(ptr, 0, calldatasize)\n', '            darwiniaAddress := mload(add(ptr, 100))\n', '        }\n', '\n', '        // Check the validity of the deposit\n', '        require(deposits[_depositID].claimed == false, "Already claimed");\n', '        require(deposits[_depositID].startAt > 0, "Deposit not created.");\n', '        require(deposits[_depositID].depositor == msg.sender, "Permission denied");\n', '\n', '        require(_data.length == 32, "The address (Darwinia Network) must be in a 32 bytes hexadecimal format");\n', '        require(darwiniaAddress != bytes32(0x0), "Darwinia Network Address can\'t be empty");\n', '\n', '        removeUserDepositsByID(_depositID, msg.sender);\n', '\n', '        require(deposits[_depositID].value <= userTotalDeposit[msg.sender], "Subtraction overflow");\n', '        userTotalDeposit[msg.sender] -= deposits[_depositID].value;\n', '\n', '        address ring = registry.addressOf(SettingIds.CONTRACT_RING_ERC20_TOKEN);\n', '        IBurnableERC20(ring).burn(address(this), deposits[_depositID].value);\n', '        \n', '        emit BurnAndRedeem(\n', '            _depositID, \n', '            deposits[_depositID].depositor, \n', '            deposits[_depositID].months, \n', '            deposits[_depositID].startAt, \n', '            deposits[_depositID].unitInterest, \n', '            deposits[_depositID].value, \n', '            _data\n', '        );\n', '\n', '        delete deposits[_depositID];\n', '    }\n', '\n', '    /**\n', '     * @dev Deposit for msg sender, require the token approvement ahead.\n', '     * @param _amount - amount of token.\n', '     * @param _months - the amount of months that the token will be locked in the deposit.\n', '     */\n', '    function deposit(uint256 _amount, uint256 _months) public {\n', '        deposit(msg.sender, _amount, _months);\n', '    }\n', '\n', '    /**\n', '     * @dev Deposit for benificiary, require the token approvement ahead.\n', '     * @param _benificiary - benificiary of the deposit, which will get the KTON and RINGs after deposit being claimed.\n', '     * @param _amount - amount of token.\n', '     * @param _months - the amount of months that the token will be locked in the deposit.\n', '     */\n', '    function deposit(address _benificiary, uint256 _amount, uint256 _months) public {\n', '\n', '        address ring = registry.addressOf(SettingIds.CONTRACT_RING_ERC20_TOKEN);\n', '        require(ERC20(ring).transferFrom(msg.sender, address(this), _amount), "RING token tranfer failed.");\n', '\n', '\n', '        _deposit(_benificiary, _amount, _months);\n', '    }\n', '\n', '    function claimDeposit(uint _depositID) public {\n', '        _claimDeposit(msg.sender, _depositID, false, 0);\n', '    }\n', '\n', '    function claimDepositWithPenalty(uint _depositID) public {\n', '        address kryptonite = ERC20(registry.addressOf(SettingIds.CONTRACT_KTON_ERC20_TOKEN));\n', '        uint256 _penalty = computePenalty(_depositID);\n', '\n', '        require(ERC20(kryptonite).transferFrom(msg.sender, address(this), _penalty));\n', '\n', '        _claimDeposit(msg.sender, _depositID, true, _penalty);\n', '\n', '        IBurnableERC20(kryptonite).burn(address(this), _penalty);\n', '    }\n', '\n', '    function transferDeposit(address _benificiary, uint _depositID) public {\n', '        require(deposits[_depositID].depositor == msg.sender, "Depositor must be the msg.sender");\n', '        require(_benificiary != 0x0, "Benificiary can not be zero");\n', '        require(deposits[_depositID].claimed == false, "Already claimed, can not transfer.");\n', '\n', '        // update the depositor of the deposit.\n', '        deposits[_depositID].depositor = _benificiary;\n', '\n', '        // update the deposit ids of the original user and new user.\n', '        removeUserDepositsByID(_depositID, msg.sender);\n', '        userDeposits[_benificiary].push(_depositID);\n', '\n', '        // update the balance of the original depositor and new depositor.\n', '        require(deposits[_depositID].value <= userTotalDeposit[msg.sender], "Subtraction overflow");\n', '        userTotalDeposit[msg.sender] -= deposits[_depositID].value;\n', '\n', '        userTotalDeposit[_benificiary] += deposits[_depositID].value;\n', '        require(userTotalDeposit[_benificiary] >= deposits[_depositID].value, "Addition overflow");\n', '\n', '        emit TransferDeposit(_depositID, msg.sender, _benificiary);\n', '    }\n', '\n', '    // normal Redemption, withdraw at maturity\n', '    function _claimDeposit(address _depositor, uint _depositID, bool isPenalty, uint _penaltyAmount) internal {\n', '\n', '        address ring = registry.addressOf(SettingIds.CONTRACT_RING_ERC20_TOKEN);\n', '\n', '        require(deposits[_depositID].startAt > 0, "Deposit not created.");\n', '        require(deposits[_depositID].claimed == false, "Already claimed");\n', '        require(deposits[_depositID].depositor == _depositor, "Depositor must match.");\n', '\n', '        if (isPenalty) {\n', '            require(now - deposits[_depositID].startAt < deposits[_depositID].months * MONTH );\n', '        } else {\n', '            require(now - deposits[_depositID].startAt >= deposits[_depositID].months * MONTH );\n', '        }\n', '\n', '        deposits[_depositID].claimed = true;\n', '        userTotalDeposit[_depositor] -= deposits[_depositID].value;\n', '\n', '        require(ERC20(ring).transfer(_depositor, deposits[_depositID].value));\n', '\n', '\n', '        emit ClaimedDeposit(_depositID, _depositor, deposits[_depositID].value, isPenalty, _penaltyAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev deposit actions\n', '     * @param _depositor - person who deposits\n', '     * @param _value - depositor wants to deposit how many tokens\n', "     * @param _month - Length of time from the deposit's beginning to end (in months).\n", '     */\n', '\n', '    function _deposit(address _depositor, uint _value, uint _month)\n', '        canBeStoredWith128Bits(_value) canBeStoredWith128Bits(_month) internal returns (uint _depositId) {\n', '\n', '        address kryptonite = ERC20(registry.addressOf(SettingIds.CONTRACT_KTON_ERC20_TOKEN));\n', '\n', '        require( _value > 0 );  // because the _value is pass in from token transfer, token transfer will help check, so there should not be overflow issues.\n', '        require( _month <= 36 && _month >= 1 );\n', '\n', '        _depositId = depositCount;\n', '\n', '        uint64 _unitInterest = uint64(registry.uintOf(BankSettingIds.UINT_BANK_UNIT_INTEREST));\n', '\n', '        deposits[_depositId] = Deposit({\n', '            depositor: _depositor,\n', '            value: uint128(_value),\n', '            months: uint48(_month),\n', '            startAt: uint48(now),\n', '            unitInterest: uint48(_unitInterest),\n', '            claimed: false\n', '        });\n', '\n', '        depositCount += 1;\n', '\n', '        userDeposits[_depositor].push(_depositId);\n', '\n', '        userTotalDeposit[_depositor] += _value;\n', '        require(userTotalDeposit[_depositor] >= _value, "Addition overflow");\n', '\n', '        // give the player interest immediately\n', '        uint interest = computeInterest(_value, _month, _unitInterest);\n', '        IMintableERC20(kryptonite).mint(_depositor, interest);\n', '\n', '        emit NewDeposit(_depositId, _depositor, _value, _month, interest);\n', '    }\n', '\n', '    /**\n', '     * @dev compute interst based on deposit amount and deposit time\n', '     * @param _value - Amount of ring  (in deceimal units)\n', "     * @param _month - Length of time from the deposit's beginning to end (in months).\n", '     * @param _unitInterest - Parameter of basic interest for deposited RING.(default value is 1000, returns _unitInterest/ 10**7 for one year)\n', '     */\n', '    function computeInterest(uint _value, uint _month, uint _unitInterest)\n', '        public canBeStoredWith128Bits(_value) canBeStoredWith48Bits(_month) pure returns (uint) {\n', '        // these two actually mean the multiplier is 1.015\n', '        uint numerator = 67 ** _month;\n', '        uint denominator = 66 ** _month;\n', '        uint quotient;\n', '        uint remainder;\n', '\n', '        assembly {\n', '            quotient := div(numerator, denominator)\n', '            remainder := mod(numerator, denominator)\n', '        }\n', '        // depositing X RING for 12 months, interest is about (1 * _unitInterest * X / 10**7) KTON\n', '        // and the multiplier is about 3\n', '        // ((quotient - 1) * 1000 + remainder * 1000 / denominator) is 197 when _month is 12.\n', '        return (_unitInterest * uint128(_value)) * ((quotient - 1) * 1000 + remainder * 1000 / denominator) / (197 * 10**7);\n', '    }\n', '\n', '    function isClaimRequirePenalty(uint _depositID) public view returns (bool) {\n', '        return (deposits[_depositID].startAt > 0 &&\n', '                !deposits[_depositID].claimed &&\n', '                (now - deposits[_depositID].startAt < deposits[_depositID].months * MONTH ));\n', '    }\n', '\n', '    function computePenalty(uint _depositID) public view returns (uint256) {\n', '        require(isClaimRequirePenalty(_depositID), "Claim do not need Penalty.");\n', '\n', '        uint256 monthsDuration = (now - deposits[_depositID].startAt) / MONTH;\n', '\n', '        uint256 penalty = registry.uintOf(BankSettingIds.UINT_BANK_PENALTY_MULTIPLIER) *\n', '            (computeInterest(deposits[_depositID].value, deposits[_depositID].months, deposits[_depositID].unitInterest) - computeInterest(deposits[_depositID].value, monthsDuration, deposits[_depositID].unitInterest));\n', '\n', '\n', '        return penalty;\n', '    }\n', '\n', '    function getDepositIds(address _user) public view returns(uint256[]) {\n', '        return userDeposits[_user];\n', '    }\n', '\n', '    function bytesToUint256(bytes _encodedParam) public pure returns (uint256 a) {\n', '        /* solium-disable-next-line security/no-inline-assembly */\n', '        assembly {\n', '            a := mload(add(_encodedParam, /*BYTES_HEADER_SIZE*/32))\n', '        }\n', '    }\n', '\n', '    /// @notice This method can be used by the owner to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    function claimTokens(address _token) public onlyOwner {\n', '        if (_token == 0x0) {\n', '            owner.transfer(address(this).balance);\n', '            return;\n', '        }\n', '        ERC20 token = ERC20(_token);\n', '        uint balance = token.balanceOf(address(this));\n', '        token.transfer(owner, balance);\n', '\n', '        emit ClaimedTokens(_token, owner, balance);\n', '    }\n', '\n', '    function setRegistry(address _registry) public onlyOwner {\n', '        registry = ISettingsRegistry(_registry);\n', '    }\n', '\n', '    function removeUserDepositsByID(uint _depositID, address _depositor) private{\n', '        // update the deposit ids of the original user and new user.\n', '        bool found = false;\n', '        for(uint i = 0 ; i < userDeposits[_depositor].length; i++)\n', '        {\n', '            if (!found && userDeposits[_depositor][i] == _depositID){\n', '                found = true;\n', '                delete userDeposits[_depositor][i];\n', '            }\n', '\n', '            if (found && i < userDeposits[_depositor].length - 1)\n', '            {\n', '                // shifts value to left\n', '                userDeposits[_depositor][i] =  userDeposits[_depositor][i+1];\n', '            }\n', '        }\n', '\n', '        delete userDeposits[_depositor][userDeposits[_depositor].length-1];\n', '        //reducing the length\n', '        userDeposits[_depositor].length--;\n', '    }\n', '\n', '}']