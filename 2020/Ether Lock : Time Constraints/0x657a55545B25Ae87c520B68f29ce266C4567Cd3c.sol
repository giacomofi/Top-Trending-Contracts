['// File: @openzeppelin\\upgrades\\contracts\\Initializable.sol\n', '\n', 'pragma solidity >=0.4.24 <0.7.0;\n', '\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', '// File: @openzeppelin\\contracts-ethereum-package\\contracts\\GSN\\Context.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context is Initializable {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin\\contracts-ethereum-package\\contracts\\ownership\\Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be aplied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Initializable, Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    function initialize(address sender) public initializer {\n', '        _owner = sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: @openzeppelin\\contracts-ethereum-package\\contracts\\math\\SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin\\contracts-ethereum-package\\contracts\\token\\ERC20\\ERC20Detailed.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/**\n', ' * @dev Optional functions from the ERC20 standard.\n', ' */\n', 'contract ERC20Detailed is Initializable, IERC20 {\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    /**\n', '     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n', '     * these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: contracts\\libs\\uniswap\\IUniswapV2Pair.sol\n', '\n', 'pragma solidity ^0.5.5;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// File: contracts\\libs\\uniswap\\UniswapV2Library.sol\n', '\n', 'pragma solidity ^0.5.5;\n', '\n', '\n', '\n', 'library UniswapV2Library {\n', '    using SafeMath for uint;\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        pair = address(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n", '            ))));\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair\n', '    function getReserves(address pair, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '        //(uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n', '        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pair).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n', '    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n', "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n", "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountB = amountA.mul(reserveB) / reserveA;\n', '    }\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = amountIn.mul(997);\n', '        uint numerator = amountInWithFee.mul(reserveOut);\n', '        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n', "        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint numerator = reserveIn.mul(amountOut).mul(1000);\n', '        uint denominator = reserveOut.sub(amountOut).mul(997);\n', '        amountIn = (numerator / denominator).add(1);\n', '    }\n', '\n', '    // performs chained getAmountOut calculations on any number of pairs\n', '    function getAmountsOut(address pair, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(pair, path[i], path[i + 1]);\n', '            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '\n', '    // performs chained getAmountIn calculations on any number of pairs\n', '    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[amounts.length - 1] = amountOut;\n', '        for (uint i = path.length - 1; i > 0; i--) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n', '            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\interfaces\\IVolcieToken.sol\n', '\n', 'pragma solidity ^0.5.5;\n', '\n', '\n', '/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n', '/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\n', 'interface IVolcieToken {\n', '    // Required methods\n', '    function totalSupply() external view returns (uint256 total);\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '    function ownerOf(uint256 _tokenId) external view returns (address owner);\n', '    function allTokenOf(address holder) external view returns(uint256[] memory);\n', '    function approve(address _to, uint256 _tokenId) external;\n', '    function transfer(address _to, uint256 _tokenId) external;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    function burn(uint256 tokenId) external;\n', '    function mint(address to, address lpToken, uint256 lpAmount)  external returns (uint256);\n', '\n', '    // Events\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event Approval(address owner, address approved, uint256 tokenId);\n', '\n', '    // Optional\n', '    // function name() external view returns (string name);\n', '    // function symbol() external view returns (string symbol);\n', '    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n', '    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl);\n', '\n', '    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n', '    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n', '\n', '}\n', '\n', '// File: contracts\\yieldFarming\\YieldFarming.sol\n', '\n', '/**\n', '* @title YieldFarming\n', '* @author @Ola, @ziweidream, @Xaleee\n', '* @notice This contract will track uniswap pool contract and addresses that deposit "UNISWAP pool" tokens \n', '*         and allow each individual address to DEPOSIT and  withdraw percentage of KTY and SDAO tokens \n', '*         according to number of "pool" tokens they own, relative to total pool tokens.\n', '*         This contract contains two tokens in contract KTY and SDAO. The contract will also return \n', '*         certain statistics about rates, availability and timing period of the program.\n', '*/\n', 'pragma solidity ^0.5.5;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '//import "./YieldFarmingHelper.sol";\n', '//import "./YieldsCalculator.sol";\n', '\n', 'contract YieldFarming is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /*                                               GENERAL VARIABLES                                                */\n', '    /* ============================================================================================================== */\n', '\n', '    IVolcieToken public volcie;                          // VolcieToken contract\n', '    IERC20 public kittieFightToken;                      // KittieFightToken contract variable\n', '    IERC20 public superDaoToken;                         // SuperDaoToken contract variable\n', '    YieldFarmingHelper public yieldFarmingHelper;        // YieldFarmingHelper contract variable\n', '    YieldsCalculator public yieldsCalculator;            // YieldFarmingHelper contract variable\n', '\n', '    uint256 constant internal base18 = 1000000000000000000;\n', '    uint256 constant internal base6 = 1000000;\n', '\n', '    uint256 constant public MONTH = 30 days;// 30 * 24 * 60 * 60;  // MONTH duration is 30 days, to keep things standard\n', '    uint256 constant public DAY = 1 days;// 24 * 60 * 60;\n', '\n', '    uint256 public totalNumberOfPairPools;              // Total number of Uniswap V2 pair pools associated with YieldFarming\n', '\n', '    uint256 public EARLY_MINING_BONUS;\n', '    //uint256 public totalLockedLPinEarlyMining;\n', '    uint256 public adjustedTotalLockedLPinEarlyMining;\n', '\n', '    //uint256 public totalDepositedLP;                    // Total Uniswap Liquidity tokens deposited\n', '    uint256 public totalLockedLP;                       // Total Uniswap Liquidity tokens locked\n', '    uint256 public totalRewardsKTY;                     // Total KittieFightToken rewards\n', '    uint256 public totalRewardsSDAO;                    // Total SuperDaoToken rewards\n', '    uint256 public totalRewardsKTYclaimed;              // KittieFightToken rewards already claimed\n', '    uint256 public totalRewardsSDAOclaimed;             // SuperDaoToken rewards already claimed\n', '\n', '    uint256 public programDuration;                     // Total time duration for Yield Farming Program\n', '    uint256 public programStartAt;                      // Start Time of Yield Farming Program \n', '    uint256 public programEndAt;                        // End Time of Yield Farming Program \n', '    uint256[6] public monthsStartAt;                    // an array of the start time of each month.\n', '  \n', '    uint256[6] public KTYunlockRates;                   // Reward Unlock Rates of KittieFightToken for eahc of the 6 months for the entire program duration\n', '    uint256[6] public SDAOunlockRates;                  // Reward Unlock Rates of KittieFightToken for eahc of the 6 months for the entire program duration\n', '\n', '    // Properties of a Staker\n', '    struct Staker {\n', '        uint256[2][] totalDeposits;                      // A 2d array of total deposits [[pairCode, batchNumber], [[pairCode, batchNumber], ...]]\n', '        uint256[][200] batchLockedLPamount;              // A 2d array showing the locked amount of Liquidity tokens in each batch of each Pair Pool\n', '        uint256[][200] adjustedBatchLockedLPamount;      // A 2d array showing the locked amount of Liquidity tokens in each batch of each Pair Pool, adjusted to LP bubbling factor\n', '        uint256[][200] adjustedStartingLPamount;\n', '        uint256[][200] factor;                           // A 2d array showing the LP bubbling factor in each batch of each Pair Pool\n', '        uint256[][200] batchLockedAt;                    // A 2d array showing the locked time of each batch in each Pair Pool\n', '        uint256[200] totalLPlockedbyPairCode;            // Total amount of Liquidity tokens locked by this stader from all pair pools\n', '        //uint256 rewardsKTYclaimed;                     // Total amount of KittieFightToken rewards already claimed by this Staker\n', '        //uint256 rewardsSDAOclaimed;                    // Total amount of SuperDaoToken rewards already claimed by this Staker\n', '        uint256[] depositNumberForEarlyBonus;            // An array of all the deposit number eligible for early bonus for this staker\n', '    }\n', '\n', "    /// @dev a VOLCIE Token NFT's associated properties\n", '    struct VolcieToken {\n', '        address originalOwner;   // the owner of this token at the time of minting\n', '        uint256 generation;      // the generation of this token, between number 0 and 5\n', '        uint256 depositNumber;   // the deposit number associated with this token and the original owner\n', '        uint256 LP;              // the original LP locked in this volcie token\n', '        uint256 pairCode;        // the pair code of the uniswap pair pool from which the LP come from\n', '        uint256 lockedAt;        // the unix time at which this funds is locked\n', '        bool tokenBurnt;         // true if this token has been burnt\n', '        uint256 tokenBurntAt;    // the time when this token was burnt, 0 if token is not burnt\n', '        address tokenBurntBy;    // who burnt this token (if this token was burnt)\n', '        uint256 ktyRewards;      // KTY rewards distributed upon burning this token\n', '        uint256 sdaoRewards;     // SDAO rewards distributed upon burning this token\n', '    }\n', '\n', '    mapping(address => Staker) internal stakers;\n', '\n', '    mapping(uint256 => address) internal pairPoolsInfo;\n', '\n', '    /// @notice mapping volcieToken NFT to its properties\n', '    mapping(uint256 => VolcieToken) internal volcieTokens;\n', '\n', '    /// @notice mapping of every month to the total deposits made during that month, adjusted to the bubbling factor\n', '    mapping(uint256 => uint256) public adjustedMonthlyDeposits;\n', '\n', '    /// @notice mapping staker to the rewards she has already claimed\n', '    mapping(address => uint256[2]) internal rewardsClaimed;\n', '\n', '    /// @notice mapping of pair code to total deposited LPs associated with this pair code\n', '    mapping(uint256 => uint256) internal totalDepositedLPbyPairCode;\n', '\n', '    uint256 private unlocked;\n', '\n', '    uint256 public calculated;\n', '    uint256 public calculated1;\n', '\n', '    /*                                                   MODIFIERS                                                    */\n', '    /* ============================================================================================================== */\n', '    modifier lock() {\n', "        require(unlocked == 1, 'Locked');\n", '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }          \n', '\n', '    /*                                                   INITIALIZER                                                  */\n', '    /* ============================================================================================================== */\n', '    function initialize\n', '    (\n', '        address[] calldata _pairPoolAddr,\n', '        IVolcieToken _volcie,\n', '        IERC20 _kittieFightToken,\n', '        IERC20 _superDaoToken,\n', '        YieldFarmingHelper _yieldFarmingHelper,\n', '        YieldsCalculator _yieldsCalculator,\n', '        uint256[6] calldata _ktyUnlockRates,\n', '        uint256[6] calldata _sdaoUnlockRates,\n', '        uint256 _programStartTime\n', '    )\n', '        external initializer\n', '    {\n', '        Ownable.initialize(_msgSender());\n', '        setVolcieToken(_volcie);\n', '        setRewardsToken(_kittieFightToken, true);\n', '        setRewardsToken(_superDaoToken, false);\n', '\n', '        for (uint256 i = 0; i < _pairPoolAddr.length; i++) {\n', '            addNewPairPool(_pairPoolAddr[i]);\n', '        }\n', '\n', '        // setKittieFightToken(_kittieFightToken);\n', '        // setSuperDaoToken(_superDaoToken);\n', '        setYieldFarmingHelper(_yieldFarmingHelper);\n', '        setYieldsCalculator(_yieldsCalculator);\n', '\n', '        // Set total rewards in KittieFightToken and SuperDaoToken\n', '        totalRewardsKTY = 7000000 * base18; // 7000000 * base18;\n', '        totalRewardsSDAO = 7000000 * base18; //7000000 * base18;\n', '\n', '        // Set early mining bonus\n', '        EARLY_MINING_BONUS = 700000 * base18; //700000 * base18;\n', '\n', '        // Set reward unlock rate for the program duration\n', '        for (uint256 j = 0; j < 6; j++) {\n', '            setRewardUnlockRate(j, _ktyUnlockRates[j], true);\n', '            setRewardUnlockRate(j, _sdaoUnlockRates[j], false);\n', '        }\n', '\n', '        // Set program duration (for a period of 6 months). Month starts at time of program deployment/initialization\n', '        setProgramDuration(6, _programStartTime);\n', '\n', '        //Reentrancy lock\n', '        unlocked = 1;\n', '    }\n', '\n', '    /*                                                      EVENTS                                                    */\n', '    /* ============================================================================================================== */\n', '    event Deposited(\n', '        address indexed sender,\n', '        uint256 indexed volcieTokenID,\n', '        uint256 depositNumber,\n', '        uint256 indexed pairCode,\n', '        uint256 lockedLP,\n', '        uint256 depositTime\n', '    );\n', '\n', '    event VolcieTokenBurnt(\n', '        address indexed burner,\n', '        address originalOwner,\n', '        uint256 indexed volcieTokenID,\n', '        uint256 indexed depositNumber,\n', '        uint256 pairCode,\n', '        uint256 batchNumber,\n', '        uint256 KTYamount,\n', '        uint256 SDAOamount,\n', '        uint256 LPamount,\n', '        uint256 withdrawTime\n', '    );\n', '\n', '    // event WithDrawn(\n', '    //     address indexed sender,\n', '    //     uint256 indexed pairCode,\n', '    //     uint256 KTYamount,\n', '    //     uint256 SDAOamount,\n', '    //     uint256 LPamount,\n', '    //     uint256 startBatchNumber,\n', '    //     uint256 endBatchNumber, \n', '    //     uint256 withdrawTime\n', '    // );\n', '\n', '    /*                                                 YIELD FARMING FUNCTIONS                                        */\n', '    /* ============================================================================================================== */\n', '\n', '    /**\n', '     * @notice Deposit Uniswap Liquidity tokens\n', '     * @param _amountLP the amount of Uniswap Liquidity tokens to be deposited\n', '     * @param _pairCode the Pair Code associated with the Pair Pool of which the Liquidity tokens are to be deposited\n', '     * @return bool true if the deposit is successful\n', '     * @dev    Each new deposit of a staker makes a new deposit with Deposit Number for this staker.\n', '     *         Deposit Number for each staker starts from 0 (for the first deposit), and increment by 1 for \n', '     *         subsequent deposits. Each deposit with a Deposit Number is associated with a Pair Code \n', '     *         and a Batch Number.\n', '     *         For each staker, each Batch Number in each Pair Pool associated with a Pair Code starts \n', '     *         from 0 (for the first deposit), and increment by 1 for subsequent batches each.\n', '     */\n', '    function deposit(uint256 _amountLP, uint256 _pairCode) external lock returns (bool) {\n', '        require(block.timestamp >= programStartAt && block.timestamp <= programEndAt, "Program is not active");\n', '        \n', '        require(_amountLP > 0, "Cannot deposit 0 tokens");\n', '\n', '        require(IUniswapV2Pair(pairPoolsInfo[_pairCode]).transferFrom(msg.sender, address(this), _amountLP), "Fail to deposit liquidity tokens");\n', '\n', '        uint256 _depositNumber = stakers[msg.sender].totalDeposits.length;\n', '\n', '        _addDeposit(msg.sender, _depositNumber, _pairCode, _amountLP, block.timestamp);\n', '\n', '        (,address _LPaddress,) = getPairPool(_pairCode);\n', '\n', '        uint256 _volcieTokenID = _mint(msg.sender, _LPaddress, _amountLP);\n', '\n', '        _updateMint(msg.sender, _depositNumber, _amountLP, _pairCode, _volcieTokenID);\n', '\n', '        emit Deposited(msg.sender, _volcieTokenID, _depositNumber, _pairCode, _amountLP, block.timestamp);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Withdraw Uniswap Liquidity tokens locked in a batch with _batchNumber specified by the staker\n', '     * @notice Three tokens (Uniswap Liquidity Tokens, KittieFightTokens, and SuperDaoTokens) are transferred\n', '     *         to the user upon successful withdraw\n', '     * @param _volcieID the deposit number of the deposit from which the user wishes to withdraw the Uniswap Liquidity tokens locked \n', '     * @return bool true if the withdraw is successful\n', '     */\n', '    function withdrawByVolcieID(uint256 _volcieID) external lock returns (bool) {\n', '        (bool _isPayDay,) = yieldFarmingHelper.isPayDay();\n', '        require(_isPayDay, "Can only withdraw on pay day");\n', '\n', '        address currentOwner = volcie.ownerOf(_volcieID);\n', '        require(currentOwner == msg.sender, "Only the owner of this token can burn it");\n', '\n', '        // require this token has not been burnt already\n', '        require(volcieTokens[_volcieID].tokenBurnt == false, "This Volcie Token has already been burnt");\n', '\n', '        address _originalOwner = volcieTokens[_volcieID].originalOwner;\n', '        uint256 _depositNumber = volcieTokens[_volcieID].depositNumber;\n', '\n', '        uint256 _pairCode = stakers[_originalOwner].totalDeposits[_depositNumber][0];\n', '        uint256 _batchNumber = stakers[_originalOwner].totalDeposits[_depositNumber][1];\n', '\n', '        // get the locked Liquidity token amount in this batch\n', '        uint256 _amountLP = stakers[_originalOwner].batchLockedLPamount[_pairCode][_batchNumber];\n', '        require(_amountLP > 0, "No locked tokens in this deposit");\n', '\n', '        uint256 _lockDuration = block.timestamp.sub(volcieTokens[_volcieID].lockedAt);\n', '        require(_lockDuration > MONTH, "Need to stake at least 30 days");\n', '\n', '        volcie.burn(_volcieID);\n', '\n', '        (uint256 _KTY, uint256 _SDAO) = yieldsCalculator.calculateRewardsByBatchNumber(_originalOwner, _batchNumber, _pairCode);\n', '\n', '        _updateWithdrawByBatchNumber(_originalOwner, _pairCode, _batchNumber, _amountLP, _KTY, _SDAO);\n', '\n', '        _updateBurn(msg.sender, _volcieID, _KTY, _SDAO);\n', '\n', '        _transferTokens(msg.sender, _pairCode, _amountLP, _KTY, _SDAO);\n', '\n', '        emit VolcieTokenBurnt(\n', '            msg.sender, _originalOwner, _volcieID, _depositNumber, _pairCode,\n', '            _batchNumber, _KTY, _SDAO, _amountLP, block.timestamp\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    /*                                                 SETTER FUNCTIONS                                               */\n', '    /* ============================================================================================================== */\n', '    /**\n', '     * @dev Add new pairPool\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function addNewPairPool(address _pairPoolAddr) public onlyOwner {\n', '        uint256 _pairCode = totalNumberOfPairPools;\n', '\n', '        IUniswapV2Pair pair = IUniswapV2Pair(_pairPoolAddr);\n', '        address token0 = pair.token0();\n', '        address token1 = pair.token1();\n', '        require(token0 == address(kittieFightToken) || token1 == address(kittieFightToken), "Pair should contain KTY");\n', '\n', '        pairPoolsInfo[_pairCode] = _pairPoolAddr;\n', '\n', '        totalNumberOfPairPools = totalNumberOfPairPools.add(1);\n', '    }\n', '\n', '    /**\n', '     * @dev Set VOLCIE contract\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setVolcieToken(IVolcieToken _volcie) public onlyOwner {\n', '        volcie = _volcie;\n', '    }\n', '\n', '    /**\n', '     * @dev Set KittieFightToken contract\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setRewardsToken(IERC20 _rewardsToken, bool forKTY) public onlyOwner {\n', '        if (forKTY) {\n', '            kittieFightToken = _rewardsToken;\n', '        } else {\n', '            superDaoToken = _rewardsToken;\n', '        }   \n', '    }\n', '\n', '    /**\n', '     * @dev Set YieldFarmingHelper contract\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setYieldFarmingHelper(YieldFarmingHelper _yieldFarmingHelper) public onlyOwner {\n', '        yieldFarmingHelper = _yieldFarmingHelper;\n', '    }\n', '\n', '    /**\n', '     * @dev Set YieldsCalculator contract\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setYieldsCalculator(YieldsCalculator _yieldsCalculator) public onlyOwner {\n', '        yieldsCalculator = _yieldsCalculator;\n', '    }\n', '\n', '    /**\n', '     * @notice This function transfers tokens out of this contract to a new address\n', '     * @dev This function is used to transfer unclaimed KittieFightToken or SuperDaoToken Rewards to a new address,\n', '     *      or transfer other tokens erroneously tranferred to this contract back to their original owner\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function returnTokens(address _token, uint256 _amount, address _newAddress) external onlyOwner {\n', '        require(block.timestamp > programEndAt.add(MONTH.mul(2)), "Owner can only return tokens after two months after program ends");\n', '        uint256 balance = IERC20(_token).balanceOf(address(this));\n', '        require(_amount <= balance, "Exceeds balance");\n', '        require(IERC20(_token).transfer(_newAddress, _amount), "Fail to transfer tokens");\n', '    }\n', '\n', '    /**\n', '     * @notice Modify Reward Unlock Rate for KittieFightToken and SuperDaoToken for any month (from 0 to 5)\n', '     *         within the program duration (a period of 6 months)\n', '     * @param _month uint256 the month (from 0 to 5) for which the unlock rate is to be modified\n', '     * @param _rate  uint256 the unlock rate\n', '     * @param forKTY bool true if this modification is for KittieFightToken, false if it is for SuperDaoToken\n', '     * @dev    This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setRewardUnlockRate(uint256 _month, uint256 _rate, bool forKTY) public onlyOwner {\n', '        if (forKTY) {\n', '            KTYunlockRates[_month] = _rate;\n', '        } else {\n', '            SDAOunlockRates[_month] = _rate;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Set Yield Farming Program time duration\n', '     * @param _totalNumberOfMonths uint256 total number of months in the entire program duration\n', '     * @param _programStartAt uint256 time when Yield Farming Program starts\n', '     * @dev    This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setProgramDuration(uint256 _totalNumberOfMonths, uint256 _programStartAt) public onlyOwner {\n', '        programDuration = _totalNumberOfMonths.mul(MONTH);\n', '        programStartAt = _programStartAt;\n', '        programEndAt = programStartAt.add(MONTH.mul(6));\n', '\n', '        monthsStartAt[0] = _programStartAt;\n', '        for (uint256 i = 1; i < _totalNumberOfMonths; i++) {\n', '            monthsStartAt[i] = monthsStartAt[i.sub(1)].add(MONTH); \n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Set total KittieFightToken rewards and total SuperDaoToken rewards for the entire program duration\n', '     * @param _rewardsKTY uint256 total KittieFightToken rewards for the entire program duration\n', '     * @param _rewardsSDAO uint256 total SuperDaoToken rewards for the entire program duration\n', '     * @dev    This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setTotalRewards(uint256 _rewardsKTY, uint256 _rewardsSDAO) public onlyOwner {\n', '        totalRewardsKTY = _rewardsKTY;\n', '        totalRewardsSDAO = _rewardsSDAO;\n', '    }\n', '\n', '    /*                                                 GETTER FUNCTIONS                                               */\n', '    /* ============================================================================================================== */\n', '    \n', '    /**\n', '     * @param _pairCode uint256 Pair Code assocated with the Pair Pool \n', '     * @return the address of the pair pool associated with _pairCode\n', '     */\n', '    function getPairPool(uint256 _pairCode)\n', '        public view\n', '        returns (string memory, address, address)\n', '    {\n', '        IUniswapV2Pair pair = IUniswapV2Pair(pairPoolsInfo[_pairCode]);\n', '        address token0 = pair.token0();\n', '        address token1 = pair.token1();\n', '        address otherToken = (token0 == address(kittieFightToken))?token1:token0;\n', '        string memory pairName = string(abi.encodePacked(ERC20Detailed(address(kittieFightToken)).symbol(),"-",ERC20Detailed(address(otherToken)).symbol()));\n', '        return (pairName, pairPoolsInfo[_pairCode], otherToken);\n', '    }\n', '\n', '    /**\n', '     * @param _volcieTokenID uint256 Volcie Token ID \n', '     * @return the properties of this Volcie Token \n', '     */\n', '    function getVolcieToken(uint256 _volcieTokenID) public view\n', '        returns (\n', '            address originalOwner, uint256 depositNumber, uint256 generation,\n', '            uint256 LP, uint256 pairCode, uint256 lockTime, bool tokenBurnt,\n', '            address tokenBurntBy, uint256 ktyRewardsDistributed, uint256 sdaoRewardsDistributed\n', '        )\n', '    {\n', '        originalOwner = volcieTokens[_volcieTokenID].originalOwner;\n', '        depositNumber = volcieTokens[_volcieTokenID].depositNumber;\n', '        generation = volcieTokens[_volcieTokenID].generation;\n', '        LP = volcieTokens[_volcieTokenID].LP;\n', '        pairCode = volcieTokens[_volcieTokenID].pairCode;\n', '        lockTime = volcieTokens[_volcieTokenID].lockedAt;\n', '        tokenBurnt = volcieTokens[_volcieTokenID].tokenBurnt;\n', '        tokenBurntBy = volcieTokens[_volcieTokenID].tokenBurntBy;\n', '        ktyRewardsDistributed = volcieTokens[_volcieTokenID].ktyRewards;\n', '        sdaoRewardsDistributed = volcieTokens[_volcieTokenID].sdaoRewards;\n', '\n', '    }\n', '\n', '    /**\n', '     * @return uint[2][2] a 2d array containing all the deposits made by the staker in this contract,\n', '     *         each item in the 2d array consisting of the Pair Code and the Batch Number associated this\n', '     *         the deposit. The Deposit Number of the deposit is the same as its index in the 2d array.\n', '     */\n', '    function getAllDeposits(address _staker)\n', '        external view returns (uint256[2][] memory)\n', '    {\n', '        return stakers[_staker].totalDeposits;\n', '    }\n', '\n', '    /**\n', '     * @return the total number of deposits this _staker has made\n', '     */\n', '    function getNumberOfDeposits(address _staker)\n', '        external view returns (uint256)\n', '    {\n', '        return stakers[_staker].totalDeposits.length;\n', '    }\n', '\n', '    /**\n', '     * @param _staker address the staker who has deposited Uniswap Liquidity tokens\n', '     * @param _depositNumber deposit number for the _staker\n', '     * @return pair pool code and batch number associated with this _depositNumber for the _staker\n', '     */\n', '\n', '    function getBatchNumberAndPairCode(address _staker, uint256 _depositNumber)\n', '        public view returns (uint256, uint256)\n', '    {\n', '        uint256 _pairCode = stakers[_staker].totalDeposits[_depositNumber][0];\n', '        uint256 _batchNumber = stakers[_staker].totalDeposits[_depositNumber][1];\n', '        return (_pairCode, _batchNumber);\n', '    }\n', '\n', '    /**\n', '     * @param _staker address the staker who has deposited Uniswap Liquidity tokens\n', '     * @param _pairCode uint256 Pair Code assocated with a Pair Pool from whichh the batches are to be shown\n', '     * @return uint256[] an array of the amount of locked Lquidity tokens in every batch of the _staker in\n', '     *         the _pairCode. The index of the array is the Batch Number associated with the batch, since\n', '     *         batch for a stakder starts from batch 0, and increment by 1 for subsequent batches each.\n', '     * @dev    Each new deposit of a staker makes a new batch in _pairCode.\n', '     */\n', '    function getAllBatchesPerPairPool(address _staker, uint256 _pairCode)\n', '        external view returns (uint256[] memory)\n', '    {\n', '        return stakers[_staker].batchLockedLPamount[_pairCode];\n', '    }\n', '\n', '    // function getAllDepositedLPs(address _staker)\n', '    //     external view returns (uint256)\n', '    // {\n', '    //     return stakers[_staker].totalDepositedLPs;\n', '    // }\n', '\n', '    /**\n', '     * @param _staker address the staker who has deposited Uniswap Liquidity tokens\n', '     * @param _pairCode uint256 Pair Code assocated with a Pair Pool \n', '     * @param _batchNumber uint256 the batch number of which deposit the staker wishes to see the locked amount\n', '     * @return uint256 the amount of Uniswap Liquidity tokens locked,\n', '     *         and its adjusted amount, and the time when this batch was locked,\n', '     *         in the batch with _batchNumber in _pairCode by the staker \n', '     */\n', '    function getLPinBatch(address _staker, uint256 _pairCode, uint256 _batchNumber)\n', '        external view returns (uint256, uint256, uint256, uint256)\n', '    {\n', '        uint256 _LP = stakers[_staker].batchLockedLPamount[_pairCode][_batchNumber];\n', '        uint256 _adjustedLP = stakers[_staker].adjustedBatchLockedLPamount[_pairCode][_batchNumber];\n', '        uint256 _adjustedStartingLP = stakers[_staker].adjustedStartingLPamount[_pairCode][_batchNumber];        \n', '        uint256 _lockTime = stakers[_staker].batchLockedAt[_pairCode][_batchNumber];\n', '        \n', '        return (_LP, _adjustedLP, _adjustedStartingLP, _lockTime);\n', '    }\n', '\n', '    /**\n', '     * @param _staker address the staker who has deposited Uniswap Liquidity tokens\n', '     * @param _pairCode uint256 Pair Code assocated with a Pair Pool \n', '     * @param _batchNumber uint256 the batch number of which deposit the staker wishes to see the locked amount\n', '     * @return uint256 the bubble factor of LP associated with this batch\n', '     */\n', '    function getFactorInBatch(address _staker, uint256 _pairCode, uint256 _batchNumber)\n', '        external view returns (uint256)\n', '    {\n', '        return stakers[_staker].factor[_pairCode][_batchNumber];\n', '    }\n', '\n', '    /**\n', '     * @return uint256 the total amount of locked liquidity tokens of a staker assocaited with _pairCode\n', '     */\n', '    function getLockedLPbyPairCode(address _staker, uint256 _pairCode)\n', '        external view returns (uint256)\n', '    {\n', '        return stakers[_staker].totalLPlockedbyPairCode[_pairCode];\n', '    }\n', '\n', '    function getDepositsForEarlyBonus(address _staker) external view returns(uint256[] memory) {\n', '        return stakers[_staker].depositNumberForEarlyBonus;\n', '    }\n', '\n', '    /**\n', '     * @param _staker address the staker who has deposited Uniswap Liquidity tokens\n', '     * @param _batchNumber uint256 the batch number of which deposit the staker wishes to see the locked amount\n', '     * @param _pairCode uint256 Pair Code assocated with a Pair Pool \n', '     * @return bool true if the batch with the _batchNumber in the _pairCode of the _staker is eligible for Early Bonus, false if it is not eligible.\n', '     * @dev    A batch needs to be locked within 7 days since contract deployment to be eligible for claiming yields.\n', '     */\n', '    function isBatchEligibleForEarlyBonus(address _staker, uint256 _batchNumber, uint256 _pairCode)\n', '        public view returns (bool)\n', '    {\n', '        // get locked time\n', '        uint256 lockedAt = stakers[_staker].batchLockedAt[_pairCode][_batchNumber];\n', '        if (lockedAt > 0 && lockedAt <= programStartAt.add(DAY.mul(21))) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @param _staker address the staker who has received the rewards\n', '     * @return uint256 the total amount of KittieFightToken that have been claimed by this _staker\n', '     * @return uint256 the total amount of SuperDaoToken that have been claimed by this _staker\n', '     */\n', '    function getTotalRewardsClaimedByStaker(address _staker) external view returns (uint256[2] memory) {\n', '        return rewardsClaimed[_staker];\n', '    }\n', '\n', '    /**\n', '     * @return unit256 the total monthly deposits of LPs, adjusted to LP factor.\n', '     * @dev    LP factor reflects the difference of the intrinsic value of LP from different uniswap pair contracts\n', '     */\n', '    function getAdjustedTotalMonthlyDeposits(uint256 _month) external view returns (uint256) {\n', '        return adjustedMonthlyDeposits[_month];\n', '    }\n', '\n', '    /**\n', '     * @return unit256 the current month \n', '     * @dev    There are 6 months in this program in total, starting from month 0 to month 5.\n', '     */\n', '    function getCurrentMonth() public view returns (uint256) {\n', '        uint256 currentMonth;\n', '        for (uint256 i = 5; i >= 0; i--) {\n', '            if (block.timestamp >= monthsStartAt[i]) {\n', '                currentMonth = i;\n', '                break;\n', '            }\n', '        }\n', '        return currentMonth;\n', '    }\n', '\n', '    /**\n', '     * @param _month uint256 the month (from 0 to 5) for which the Reward Unlock Rate is returned\n', '     * @return uint256 the Reward Unlock Rate for KittieFightToken for the _month\n', '     * @return uint256 the Reward Unlock Rate for SuperDaoToken for the _month\n', '     */\n', '    function getRewardUnlockRateByMonth(uint256 _month) external view returns (uint256, uint256) {\n', '        uint256 _KTYunlockRate = KTYunlockRates[_month];\n', '        uint256 _SDAOunlockRate = SDAOunlockRates[_month];\n', '        return (_KTYunlockRate, _SDAOunlockRate);\n', '    }\n', '\n', '    /**\n', '     * @return unit256 the starting time of a month\n', '     * @dev    There are 6 months in this program in total, starting from month 0 to month 5.\n', '     */\n', '\n', '    function getMonthStartAt(uint256 month) external view returns (uint256) {\n', '        return monthsStartAt[month];\n', '    }\n', '\n', '    function getTotalDepositsPerPairCode(uint256 _pairCode) external view returns (uint256) {\n', '        return totalDepositedLPbyPairCode[_pairCode];\n', '    }\n', '\n', '    /**\n', '     * This function is returning APY of yieldFarming program.\n', '     * @return uint256 APY\n', '     */\n', '    function getAPY(address _pair_KTY_SDAO) external view returns (uint256) {\n', '        if(totalLockedLP == 0)\n', '            return 0;\n', '        uint256 rateKTYSDAO = getExpectedPrice_KTY_SDAO(_pair_KTY_SDAO);\n', '\n', '        uint256 totalRewardsInKTY = totalRewardsKTY.add(totalRewardsSDAO.mul(rateKTYSDAO).div(base18));\n', '\n', '        uint256 lockedKTYs;\n', '\n', '        for(uint256 i = 0; i < totalNumberOfPairPools; i++) {\n', '            if(totalDepositedLPbyPairCode[i] == 0)\n', '                continue;\n', '            uint256 balance = kittieFightToken.balanceOf(pairPoolsInfo[i]);\n', '            uint256 supply = IERC20(pairPoolsInfo[i]).totalSupply();\n', '            uint256 KTYs = balance.mul(totalDepositedLPbyPairCode[i]).mul(2).div(supply);\n', '            lockedKTYs = lockedKTYs.add(KTYs);\n', '        }\n', '\n', '        return base18.mul(200).mul(lockedKTYs.add(totalRewardsInKTY)).div(lockedKTYs);\n', '    }\n', '\n', '    /**\n', '     * @dev returns the SDAO KTY price on uniswap, that is, how many KTYs for 1 SDAO\n', '     */\n', '    function getExpectedPrice_KTY_SDAO(address _pair_KTY_SDAO) public view returns (uint256) {\n', '        // uint256 KTYbalance = kittieFightToken.balanceOf(_pair_KTY_SDAO);\n', '        // uint256 SDAObalance = superDaoToken.balanceOf(_pair_KTY_SDAO);\n', '        // return KTYbalance.mul(base18).div(SDAObalance);\n', '\n', '        uint256 _amountSDAO = 1e18;  // 1 SDAO\n', '        (uint256 _reserveKTY, uint256 _reserveSDAO) = yieldFarmingHelper.getReserve(\n', '            address(kittieFightToken), address(superDaoToken), _pair_KTY_SDAO\n', '            );\n', '        return UniswapV2Library.getAmountIn(_amountSDAO, _reserveKTY, _reserveSDAO);\n', '    }\n', '\n', '    /*                                                 PRIVATE FUNCTIONS                                             */\n', '    /* ============================================================================================================== */\n', '\n', '    /**\n', '     * @dev    Internal functions used in function deposit()\n', '     * @param _sender address the address of the sender\n', '     * @param _pairCode uint256 Pair Code assocated with a Pair Pool \n', '     * @param _amount uint256 the amount of Uniswap Liquidity tokens to be deposited\n', '     * @param _lockedAt uint256 the time when this depoist is made\n', '     */\n', '    function _addDeposit\n', '    (\n', '        address _sender, uint256 _depositNumber, uint256 _pairCode, uint256 _amount, uint256 _lockedAt\n', '    ) private {\n', '        // uint256 _depositNumber = stakers[_sender].totalDeposits.length;\n', '        uint256 _batchNumber = stakers[_sender].batchLockedLPamount[_pairCode].length;\n', '        uint256 _currentMonth = getCurrentMonth();\n', '        uint256 _factor = yieldFarmingHelper.bubbleFactor(_pairCode);\n', '        uint256 _adjustedAmount = _amount.mul(base6).div(_factor);\n', '\n', '        stakers[_sender].totalDeposits.push([_pairCode, _batchNumber]);\n', '        stakers[_sender].batchLockedLPamount[_pairCode].push(_amount);\n', '        stakers[_sender].adjustedBatchLockedLPamount[_pairCode].push(_adjustedAmount);\n', '        stakers[_sender].factor[_pairCode].push(_factor);\n', '        stakers[_sender].batchLockedAt[_pairCode].push(_lockedAt);\n', '        stakers[_sender].totalLPlockedbyPairCode[_pairCode] = stakers[_sender].totalLPlockedbyPairCode[_pairCode].add(_amount);\n', '        //stakers[_sender].totalDepositedLPs = stakers[_sender].totalDepositedLPs.add(_amount);\n', '\n', '        uint256 _currentDay = yieldsCalculator.getCurrentDay();\n', '\n', '        if (yieldsCalculator.getElapsedDaysInMonth(_currentDay, _currentMonth) > 0) {\n', '            uint256 currentDepositedAmount = yieldsCalculator.getFirstMonthAmount(\n', '                _currentDay,\n', '                _currentMonth,\n', '                adjustedMonthlyDeposits[_currentMonth],\n', '                _adjustedAmount\n', '            );\n', '\n', '            stakers[_sender].adjustedStartingLPamount[_pairCode].push(currentDepositedAmount);\n', '            adjustedMonthlyDeposits[_currentMonth] = adjustedMonthlyDeposits[_currentMonth].add(currentDepositedAmount);\n', '        } else {\n', '            stakers[_sender].adjustedStartingLPamount[_pairCode].push(_adjustedAmount);\n', '            adjustedMonthlyDeposits[_currentMonth] = adjustedMonthlyDeposits[_currentMonth]\n', '                                                     .add(_adjustedAmount);\n', '        }\n', '\n', '        if (_currentMonth < 5) {\n', '            for (uint256 i = _currentMonth.add(1); i < 6; i++) {\n', '                adjustedMonthlyDeposits[i] = adjustedMonthlyDeposits[i]\n', '                                             .add(_adjustedAmount);\n', '            }\n', '        }\n', '\n', '        //totalDepositedLP = totalDepositedLP.add(_amount);\n', '        totalDepositedLPbyPairCode[_pairCode] = totalDepositedLPbyPairCode[_pairCode].add(_amount);\n', '        totalLockedLP = totalLockedLP.add(_amount);\n', '\n', '        if (block.timestamp <= programStartAt.add(DAY.mul(21))) {\n', '            adjustedTotalLockedLPinEarlyMining = adjustedTotalLockedLPinEarlyMining.add(_adjustedAmount);\n', '            stakers[_sender].depositNumberForEarlyBonus.push(_depositNumber);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Updates funder profile when minting a new token to a funder\n', '     */\n', '    function _updateMint\n', '    (\n', '        address _originalOwner,\n', '        uint256 _depositNumber,\n', '        uint256 _LP,\n', '        uint256 _pairCode,\n', '        uint256 _volcieTokenID\n', '    )\n', '        internal\n', '    {\n', '        volcieTokens[_volcieTokenID].generation = getCurrentMonth();\n', '        volcieTokens[_volcieTokenID].depositNumber = _depositNumber;\n', '        volcieTokens[_volcieTokenID].LP = _LP;\n', '        volcieTokens[_volcieTokenID].pairCode = _pairCode;\n', '        volcieTokens[_volcieTokenID].lockedAt = now;\n', '        volcieTokens[_volcieTokenID].originalOwner = _originalOwner;\n', '    }\n', '\n', '    /**\n', '     * @param _sender address the address of the sender\n', '     * @param _pairCode uint256 Pair Code assocated with a Pair Pool \n', '     * @param _KTY uint256 the amount of KittieFightToken\n', '     * @param _SDAO uint256 the amount of SuperDaoToken\n', '     * @param _LP uint256 the amount of Uniswap Liquidity tokens\n', '     */\n', '    function _updateWithdrawByBatchNumber\n', '    (\n', '        address _sender, uint256 _pairCode, uint256 _batchNumber,\n', '        uint256 _LP, uint256 _KTY, uint256 _SDAO\n', '    ) \n', '        private\n', '    {\n', '        // ========= update staker info =========\n', '        // batch info\n', '        uint256 adjustedLP = stakers[_sender].adjustedBatchLockedLPamount[_pairCode][_batchNumber];\n', '        stakers[_sender].batchLockedLPamount[_pairCode][_batchNumber] = 0;\n', '        stakers[_sender].adjustedBatchLockedLPamount[_pairCode][_batchNumber] = 0;\n', '        stakers[_sender].adjustedStartingLPamount[_pairCode][_batchNumber] = 0;\n', '        stakers[_sender].batchLockedAt[_pairCode][_batchNumber] = 0;\n', '\n', '        // all batches in pair code info\n', '        stakers[_sender].totalLPlockedbyPairCode[_pairCode] = stakers[_sender].totalLPlockedbyPairCode[_pairCode].sub(_LP);\n', '\n', '        // ========= update public variables =========\n', '        totalRewardsKTYclaimed = totalRewardsKTYclaimed.add(_KTY);\n', '        totalRewardsSDAOclaimed = totalRewardsSDAOclaimed.add(_SDAO);\n', '        totalLockedLP = totalLockedLP.sub(_LP);\n', '\n', '        uint256 _currentMonth = getCurrentMonth();\n', '\n', '        if (_currentMonth < 5) {\n', '            for (uint i = _currentMonth; i < 6; i++) {\n', '                adjustedMonthlyDeposits[i] = adjustedMonthlyDeposits[i]\n', '                                             .sub(adjustedLP);\n', '            }\n', '        }\n', '\n', '        // if eligible for Early Mining Bonus but unstake before program end, deduct it from totalLockedLPinEarlyMining\n', '        if (block.timestamp < programEndAt && isBatchEligibleForEarlyBonus(_sender, _batchNumber, _pairCode)) {\n', '            adjustedTotalLockedLPinEarlyMining = adjustedTotalLockedLPinEarlyMining.sub(adjustedLP);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Updates funder profile when an existing Ethie Token NFT is burnt\n', '     * @param _burner address who burns this NFT\n', '     * @param _volcieTokenID uint256 the ID of the burnt Ethie Token NFT\n', '     */\n', '    function _updateBurn\n', '    (\n', '        address _burner,\n', '        uint256 _volcieTokenID,\n', '        uint256 _ktyRewards,\n', '        uint256 _sdaoRewards\n', '    )\n', '        internal\n', '    {\n', '        // set values to 0 can get gas refund\n', '        volcieTokens[_volcieTokenID].LP = 0;\n', '        volcieTokens[_volcieTokenID].lockedAt = 0;\n', '        volcieTokens[_volcieTokenID].tokenBurnt = true;\n', '        volcieTokens[_volcieTokenID].tokenBurntAt = now;\n', '        volcieTokens[_volcieTokenID].tokenBurntBy = _burner;\n', '        volcieTokens[_volcieTokenID].ktyRewards = _ktyRewards;\n', '        volcieTokens[_volcieTokenID].sdaoRewards = _sdaoRewards;\n', '\n', '        rewardsClaimed[_burner][0] = rewardsClaimed[_burner][0].add(_ktyRewards);\n', '        rewardsClaimed[_burner][1] = rewardsClaimed[_burner][1].add(_sdaoRewards);\n', '    }\n', '\n', '    /**\n', '     * @param _user address the address of the _user to whom the tokens are transferred\n', '     * @param _pairCode uint256 Pair Code assocated with a Pair Pool \n', '     * @param _amountLP uint256 the amount of Uniswap Liquidity tokens to be transferred to the _user\n', '     * @param _amountKTY uint256 the amount of KittieFightToken to be transferred to the _user\n', '     * @param _amountSDAO uint256 the amount of SuperDaoToken to be transferred to the _user\n', '     */\n', '    function _transferTokens(address _user, uint256 _pairCode, uint256 _amountLP, uint256 _amountKTY, uint256 _amountSDAO)\n', '        private\n', '    {\n', '        // transfer liquidity tokens\n', '        require(IUniswapV2Pair(pairPoolsInfo[_pairCode]).transfer(_user, _amountLP), "Fail to transfer liquidity token");\n', '\n', '        // transfer rewards\n', '        require(kittieFightToken.transfer(_user, _amountKTY), "Fail to transfer KTY");\n', '        require(superDaoToken.transfer(_user, _amountSDAO), "Fail to transfer SDAO");\n', '    }\n', '\n', '     /**\n', '     * @dev Called by deposit(), pass values to generate Volcie Token NFT with all atrributes as listed in params\n', '     * @param _to address who this Ethie Token NFT is minted to\n', '     * @param _LPaddress address of the uniswap pair contract of which the LPs are \n', '     * @param _LPamount uint256 the amount of LPs associated with this NFT\n', '     * @return uint256 ID of the LP Token NFT minted\n', '     */\n', '    function _mint\n', '    (\n', '        address _to,\n', '        address _LPaddress,\n', '        uint256 _LPamount\n', '    )\n', '        private\n', '        returns (uint256)\n', '    {\n', '        return volcie.mint(_to, _LPaddress, _LPamount);\n', '    }\n', '}\n', '\n', 'contract YieldFarmingHelper is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /*                                               GENERAL VARIABLES                                                */\n', '    /* ============================================================================================================== */\n', '\n', '    YieldFarming public yieldFarming;\n', '    YieldsCalculator public yieldsCalculator;\n', '\n', '    address public ktyWethPair;\n', '    address public daiWethPair;\n', '\n', '    address public kittieFightTokenAddr;\n', '    address public superDaoTokenAddr;\n', '    address public wethAddr;\n', '    address public daiAddr;\n', '\n', '    uint256 constant public base18 = 1000000000000000000;\n', '    uint256 constant public base6 = 1000000;\n', '\n', '    uint256 constant public MONTH = 30 days;// 30 * 24 * 60 * 60;  // MONTH duration is 30 days, to keep things standard\n', '    uint256 constant public DAY = 1 days;// 24 * 60 * 60;\n', '\n', '    /*                                                   INITIALIZER                                                  */\n', '    /* ============================================================================================================== */\n', '\n', '    function initialize\n', '    (\n', '        YieldFarming _yieldFarming,\n', '        YieldsCalculator _yieldsCalculator,\n', '        address _ktyWethPair,\n', '        address _daiWethPair,\n', '        address _kittieFightToken,\n', '        address _superDaoToken,\n', '        address _weth,\n', '        address _dai\n', '    ) \n', '        public initializer\n', '    {\n', '        Ownable.initialize(_msgSender());\n', '        setYieldFarming(_yieldFarming);\n', '        setYieldsCalculator(_yieldsCalculator);\n', '        setKtyWethPair(_ktyWethPair);\n', '        setDaiWethPair(_daiWethPair);\n', '        setRwardsTokenAddress(_kittieFightToken, true);\n', '        setRwardsTokenAddress(_superDaoToken, false);\n', '        setWethAddress(_weth);\n', '        setDaiAddress(_dai);\n', '    }\n', '\n', '    /*                                                 SETTER FUNCTIONS                                               */\n', '    /* ============================================================================================================== */\n', '\n', '    /**\n', '     * @dev Set Uniswap KTY-Weth Pair contract\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setYieldFarming(YieldFarming _yieldFarming) public onlyOwner {\n', '        yieldFarming = _yieldFarming;\n', '    }\n', '\n', '    /**\n', '     * @dev Set Uniswap KTY-Weth Pair contract\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setYieldsCalculator(YieldsCalculator _yieldsCalculator) public onlyOwner {\n', '        yieldsCalculator= _yieldsCalculator;\n', '    }\n', '\n', '    /**\n', '     * @dev Set Uniswap KTY-Weth Pair contract address\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setKtyWethPair(address _ktyWethPair) public onlyOwner {\n', '        ktyWethPair = _ktyWethPair;\n', '    }\n', '\n', '    /**\n', '     * @dev Set Uniswap Dai-Weth Pair contract address\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setDaiWethPair(address _daiWethPair) public onlyOwner {\n', '        daiWethPair = _daiWethPair;\n', '    }\n', '\n', '    /**\n', '     * @dev Set tokens address\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setRwardsTokenAddress(address _rewardToken, bool forKTY) public onlyOwner {\n', '        if (forKTY) {\n', '            kittieFightTokenAddr = _rewardToken;\n', '        } else {\n', '            superDaoTokenAddr = _rewardToken;\n', '        }        \n', '    }\n', '\n', '    /**\n', '     * @dev Set Weth contract address\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setWethAddress(address _weth) public onlyOwner {\n', '        wethAddr = _weth;\n', '    }\n', '\n', '    /**\n', '     * @dev Set Dai contract address\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setDaiAddress(address _dai) public onlyOwner {\n', '        daiAddr = _dai;\n', '    }\n', '\n', '    /*                                                 GETTER FUNCTIONS                                               */\n', '    /* ============================================================================================================== */\n', '\n', '    // Getters YieldFarming\n', '\n', '    /**\n', '     * @return KTY reserves and the total supply of LPs from a uniswap pair contract associated with a\n', '              pair code in Yield Farming.\n', '     */\n', '    function getLPinfo(uint256 _pairCode)\n', '        public view returns (uint256 reserveKTY, uint256 totalSupplyLP) \n', '    {\n', '        (,address pairPoolAddress, address _tokenAddr) = yieldFarming.getPairPool(_pairCode);\n', '        (reserveKTY,) = getReserve(kittieFightTokenAddr, _tokenAddr, pairPoolAddress);\n', '        totalSupplyLP = IUniswapV2Pair(pairPoolAddress).totalSupply();\n', '    }\n', '\n', '    /**\n', '     * @return returns the LP Bubble Factor of LP from a uniswap pair contract associate with a pair code. \n', '     * @dev calculation is based on formula: LP1 / LP =  (T1 x R) / (T x R1)\n', '     * @dev returned value is amplified 1000000 times to avoid float imprecision\n', '     */\n', '    function bubbleFactor(uint256 _pairCode) external view returns (uint256)\n', '    {\n', '        (uint256 reserveKTY, uint256 totalSupply) = getLPinfo(0);\n', '        (uint256 reserveKTY_1, uint256 totalSupply_1) = getLPinfo(_pairCode);\n', '\n', '        uint256 factor = totalSupply_1.mul(reserveKTY).mul(base6).div(totalSupply.mul(reserveKTY_1));\n', '        return factor;\n', '    }\n', '\n', '    /**\n', '     * @return true and 0 if now is pay day, false if now is not pay day and the time until next pay day\n', '     * @dev Pay Day is the first day of each month, starting from the second month.\n', '     * @dev After program ends, every day is Pay Day.\n', '     */\n', '    function isPayDay()\n', '        public view\n', '        returns (bool, uint256)\n', '    {\n', '        uint256 month1StartTime = yieldFarming.getMonthStartAt(1);\n', '        if (block.timestamp < month1StartTime) {\n', '            return (false, month1StartTime.sub(block.timestamp));\n', '        }\n', '        if (block.timestamp >= yieldFarming.programEndAt()) {\n', '            return (true, 0);\n', '        }\n', '        uint256 currentMonth = yieldFarming.getCurrentMonth();\n', '        if (block.timestamp >= yieldFarming.getMonthStartAt(currentMonth)\n', '            && block.timestamp <= yieldFarming.getMonthStartAt(currentMonth).add(DAY)) {\n', '            return (true, 0);\n', '        }\n', '        if (block.timestamp > yieldFarming.getMonthStartAt(currentMonth).add(DAY)) {\n', '            uint256 nextPayDay = yieldFarming.getMonthStartAt(currentMonth.add(1));\n', '            return (false, nextPayDay.sub(block.timestamp));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @return uint256 the total amount of Uniswap Liquidity tokens locked in this contract\n', '     */\n', '    function getTotalLiquidityTokenLocked() external view returns (uint256) {\n', '        return yieldFarming.totalLockedLP();\n', '    }\n', '\n', '    /**\n', '     * @return uint256 the total locked LPs in Yield Farming in DAI value\n', '     */\n', '    function totalLockedLPinDAI() external view returns (uint256) {\n', '        uint256 _totalLockedLPinDAI = 0;\n', '        uint256 _LPinDai;\n', '        uint256 totalNumberOfPairPools = yieldFarming.totalNumberOfPairPools();\n', '        for (uint256 i = 0; i < totalNumberOfPairPools; i++) {\n', '            _LPinDai = getTotalLiquidityTokenLockedInDAI(i);\n', '            _totalLockedLPinDAI = _totalLockedLPinDAI.add(_LPinDai);\n', '        }\n', '\n', '        return _totalLockedLPinDAI;\n', '    }\n', '\n', '    /**\n', '     * @return bool true if this _staker has made any deposit, false if this _staker has no deposit\n', '     * @return uint256 the deposit number for this _staker associated with the _batchNumber and _pairCode\n', '     */\n', '    function getDepositNumber(address _staker, uint256 _pairCode, uint256 _batchNumber)\n', '        external view returns (bool, uint256)\n', '    {\n', '        uint256 _pair;\n', '        uint256 _batch;\n', '\n', '        uint256 _totalDeposits = yieldFarming.getNumberOfDeposits(_staker);\n', '        if (_totalDeposits == 0) {\n', '            return (false, 0);\n', '        }\n', '        for (uint256 i = 0; i < _totalDeposits; i++) {\n', '            (_pair, _batch) = yieldFarming.getBatchNumberAndPairCode(_staker, i);\n', '            if (_pair == _pairCode && _batch == _batchNumber) {\n', '                return (true, i);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @return A staker's total LPs locked associated with a pair code, qualifying for claiming early bonus, and its values adjusted\n", '     *         to the LP Bubble Factor.\n', '     */\n', '    function totalLPforEarlyBonusPerPairCode(address _staker, uint256 _pairCode)\n', '        public view returns (uint256, uint256) {\n', '        uint256[] memory depositsEarlyBonus = yieldFarming.getDepositsForEarlyBonus(_staker);\n', '        uint256 totalLPEarlyBonus = 0;\n', '        uint256 adjustedTotalLPEarlyBonus = 0;\n', '        uint256 depositNum;\n', '        uint256 batchNum;\n', '        uint256 pairCode;\n', '        uint256 lockTime;\n', '        uint256 lockedLP;\n', '        uint256 adjustedLockedLP;\n', '        for (uint256 i = 0; i < depositsEarlyBonus.length; i++) {\n', '            depositNum = depositsEarlyBonus[i];\n', '            (pairCode, batchNum) = yieldFarming.getBatchNumberAndPairCode(_staker, depositNum);\n', '            (lockedLP,adjustedLockedLP,, lockTime) = yieldFarming.getLPinBatch(_staker, pairCode, batchNum);\n', '            if (pairCode == _pairCode && lockTime > 0 && lockedLP > 0) {\n', '                totalLPEarlyBonus = totalLPEarlyBonus.add(lockedLP);\n', '                adjustedTotalLPEarlyBonus = adjustedTotalLPEarlyBonus.add(adjustedLockedLP);\n', '            }\n', '        }\n', '\n', '        return (totalLPEarlyBonus, adjustedTotalLPEarlyBonus);\n', '    }\n', '\n', '    /**\n', "     * @return A staker's total LPs locked qualifying for claiming early bonus, and its values adjusted\n", '     *         to the LP Bubble Factor.\n', '     */\n', '    function totalLPforEarlyBonus(address _staker) public view returns (uint256, uint256) {\n', '        uint256[] memory _depositsEarlyBonus = yieldFarming.getDepositsForEarlyBonus(_staker);\n', '        if (_depositsEarlyBonus.length == 0) {\n', '            return (0, 0);\n', '        }\n', '        uint256 _totalLPEarlyBonus = 0;\n', '        uint256 _adjustedTotalLPEarlyBonus = 0;\n', '        uint256 _depositNum;\n', '        uint256 _batchNum;\n', '        uint256 _pair;\n', '        uint256 lockTime;\n', '        uint256 lockedLP;\n', '        uint256 adjustedLockedLP;\n', '        for (uint256 i = 0; i < _depositsEarlyBonus.length; i++) {\n', '            _depositNum = _depositsEarlyBonus[i];\n', '            (_pair, _batchNum) = yieldFarming.getBatchNumberAndPairCode(_staker, _depositNum);\n', '            (lockedLP,adjustedLockedLP,, lockTime) = yieldFarming.getLPinBatch(_staker, _pair, _batchNum);\n', '            if (lockTime > 0 && lockedLP > 0) {\n', '                _totalLPEarlyBonus = _totalLPEarlyBonus.add(lockedLP);\n', '                _adjustedTotalLPEarlyBonus = _adjustedTotalLPEarlyBonus.add(adjustedLockedLP);\n', '            }\n', '        }\n', '\n', '        return (_totalLPEarlyBonus, _adjustedTotalLPEarlyBonus);\n', '    }\n', '\n', '    /**\n', "     * @return uint256, uint256 a staker's total early bonus (KTY and SDAO) he/she has accrued.\n", '     */\n', '    function getTotalEarlyBonus(address _staker) external view returns (uint256, uint256) {\n', '        (, uint256 totalEarlyLP) = totalLPforEarlyBonus(_staker);\n', '        uint256 earlyBonus = yieldsCalculator.getEarlyBonus(totalEarlyLP);\n', '        // early bonus for KTY is the same amount as early bonus for SDAO\n', '        return (earlyBonus, earlyBonus);\n', '    }\n', '\n', '    /**\n', '     * @return uint256 the total amount of KittieFightToken that have been claimed\n', '     * @return uint256 the total amount of SuperDaoToken that have been claimed\n', '     */\n', '    function getTotalRewardsClaimed() external view returns (uint256, uint256) {\n', '        uint256 totalKTYclaimed = yieldFarming.totalRewardsKTYclaimed();\n', '        uint256 totalSDAOclaimed = yieldFarming.totalRewardsSDAOclaimed();\n', '        return (totalKTYclaimed, totalSDAOclaimed);\n', '    }\n', '\n', '    /**\n', '     * @return uint256 the total amount of KittieFightToken rewards\n', '     * @return uint256 the total amount of SuperDaoFightToken rewards\n', '     */\n', '    function getTotalRewards() public view returns (uint256, uint256) {\n', '        uint256 rewardsKTY = yieldFarming.totalRewardsKTY();\n', '        uint256 rewardsSDAO = yieldFarming.totalRewardsSDAO();\n', '        return (rewardsKTY, rewardsSDAO);\n', '    }\n', '\n', '    /**\n', '     * @return uint256 the total amount of Uniswap Liquidity tokens deposited\n', '     *         including both locked tokens and withdrawn tokens\n', '     */\n', '    function getTotalDeposits() public view returns (uint256) {\n', '        uint256 totalPools = yieldFarming.totalNumberOfPairPools();\n', '        uint256 totalDeposits = 0;\n', '        uint256 deposits;\n', '        for (uint256 i = 0; i < totalPools; i++) {\n', '            deposits = yieldFarming.getTotalDepositsPerPairCode(i);\n', '            totalDeposits = totalDeposits.add(deposits);\n', '        }\n', '        return totalDeposits;\n', '    }\n', '\n', '    /**\n', '     * @return uint256 the dai value of the total amount of Uniswap Liquidity tokens deposited \n', '     *         including both locked tokens and withdrawn tokens \n', '     */\n', '    function getTotalDepositsInDai() external view returns (uint256) {\n', '        uint256 totalPools = yieldFarming.totalNumberOfPairPools();\n', '        uint256 totalDepositsInDai = 0;\n', '        uint256 deposits;\n', '        uint256 depositsInDai;\n', '        for (uint256 i = 0; i < totalPools; i++) {\n', '            deposits = yieldFarming.getTotalDepositsPerPairCode(i);\n', '            depositsInDai = deposits > 0 ? getLPvalueInDai(i, deposits) : 0;\n', '            totalDepositsInDai = totalDepositsInDai.add(depositsInDai);\n', '        }\n', '        return totalDepositsInDai;\n', '    }\n', '\n', '    /**\n', '     * @return uint256 the total amount of KittieFightToken rewards yet to be distributed\n', '     * @return uint256 the total amount of SuperDaoFightToken rewards yet to be distributed\n', '     */\n', '    function getLockedRewards() public view returns (uint256, uint256) {\n', '        (uint256 totalRewardsKTY, uint256 totalRewardsSDAO) = getTotalRewards();\n', '        (uint256 unlockedKTY, uint256 unlockedSDAO) = getUnlockedRewards();\n', '        uint256 lockedKTY = totalRewardsKTY.sub(unlockedKTY);\n', '        uint256 lockedSDAO = totalRewardsSDAO.sub(unlockedSDAO);\n', '        return (lockedKTY, lockedSDAO);\n', '    }\n', '\n', '    /**\n', '     * @return uint256 the total amount of KittieFightToken rewards already distributed\n', '     * @return uint256 the total amount of SuperDaoFightToken rewards already distributed\n', '     */\n', '    function getUnlockedRewards() public view returns (uint256, uint256) {\n', '        uint256 unlockedKTY = IERC20(kittieFightTokenAddr).balanceOf(address(yieldFarming));\n', '        uint256 unlockedSDAO = IERC20(superDaoTokenAddr).balanceOf(address(yieldFarming));\n', '        return (unlockedKTY, unlockedSDAO);\n', '    }\n', '\n', '    /**\n', '     * @dev get info on program duration and month\n', '     */\n', '    function getProgramDuration() external view \n', '    returns\n', '    (\n', '        uint256 entireProgramDuration,\n', '        uint256 monthDuration,\n', '        uint256 startMonth,\n', '        uint256 endMonth,\n', '        uint256 currentMonth,\n', '        uint256 daysLeft,\n', '        uint256 elapsedMonths\n', '    ) \n', '    {\n', '        uint256 currentDay = yieldsCalculator.getCurrentDay();\n', '        entireProgramDuration = yieldFarming.programDuration();\n', '        monthDuration = yieldFarming.MONTH();\n', '        startMonth = 0;\n', '        endMonth = 5;\n', '        currentMonth = yieldFarming.getCurrentMonth();\n', '        daysLeft = currentDay >= 180 ? 0 : 180 - currentDay;\n', '        elapsedMonths = currentMonth == 0 ? 0 : currentMonth;\n', '    }\n', '\n', '     /**\n', '     * @return uint256 the amount of total Rewards for KittieFightToken for early mining bonnus\n', '     * @return uint256 the amount of total Rewards for SuperDaoToken for early mining bonnus\n', '     */\n', '    function getTotalEarlyMiningBonus() external view returns (uint256, uint256) {\n', '        // early mining bonus is the same amount in KTY and SDAO\n', '        return (yieldFarming.EARLY_MINING_BONUS(), yieldFarming.EARLY_MINING_BONUS());\n', '    }\n', '\n', '    /**\n', '     * @return uint256 the amount of locked liquidity tokens,\n', '     *         and its adjusted amount, and when this deposit was made,\n', '     *         in a deposit of a staker assocaited with _depositNumber\n', '     */\n', '    function getLockedLPinDeposit(address _staker, uint256 _depositNumber)\n', '        external view returns (uint256, uint256, uint256)\n', '    {\n', '        (uint256 _pairCode, uint256 _batchNumber) = yieldFarming.getBatchNumberAndPairCode(_staker, _depositNumber); \n', '        (uint256 _LP, uint256 _adjustedLP,, uint256 _lockTime) = yieldFarming.getLPinBatch(_staker, _pairCode, _batchNumber);\n', '        return (_LP, _adjustedLP, _lockTime);\n', '    }\n', '\n', '    /**\n', '     * @param _staker address the staker who has deposited Uniswap Liquidity tokens\n', '     * @param _batchNumber uint256 the batch number of which deposit the staker wishes to see the locked amount\n', '     * @param _pairCode uint256 Pair Code assocated with a Pair Pool \n', '     * @return bool true if the batch with the _batchNumber in the _pairCode of the _staker is a valid batch, false if it is non-valid.\n', '     * @dev    A valid batch is a batch which has locked Liquidity tokens in it. \n', '     * @dev    A non-valid batch is an empty batch which has no Liquidity tokens in it.\n', '     */\n', '    function isBatchValid(address _staker, uint256 _pairCode, uint256 _batchNumber)\n', '        public view returns (bool)\n', '    {\n', '        (uint256 _LP,,,) = yieldFarming.getLPinBatch(_staker, _pairCode, _batchNumber);\n', '        return _LP > 0;\n', '    }\n', '\n', '    /**\n', '     * @return uint256 DAI value representation of ETH in uniswap KTY - ETH pool, according to \n', '     *         all Liquidity tokens locked in this contract.\n', '     */\n', '    function getTotalLiquidityTokenLockedInDAI(uint256 _pairCode) public view returns (uint256) {\n', '        (,address pairPoolAddress,) = yieldFarming.getPairPool(_pairCode);\n', '        uint256 balance = IUniswapV2Pair(pairPoolAddress).balanceOf(address(yieldFarming));\n', '        uint256 totalSupply = IUniswapV2Pair(pairPoolAddress).totalSupply();\n', '        uint256 percentLPinYieldFarm = balance.mul(base18).div(totalSupply);\n', '        \n', '        uint256 totalKtyInPairPool = IERC20(kittieFightTokenAddr).balanceOf(pairPoolAddress);\n', '\n', '        return totalKtyInPairPool.mul(2).mul(percentLPinYieldFarm).mul(KTY_DAI_price())\n', '               .div(base18).div(base18);\n', '    }\n', '\n', '    /**\n', '     * @param _pairCode uint256 the pair code of which the LPs are \n', '     * @param _LP uint256 the amount of LPs\n', '     * @return uint256 DAI value of the amount LPs which are from a pair pool associated with the pair code\n', '     * @dev the calculations is as below:\n', '     *      For example, if I have 1 of 1000 LP of KTY-WETH, and there is total 10000 KTY and 300 ETH \n', '     *      staked in this pair, then 1 have 10 KTY + 0.3 ETH. And that is equal to 20 KTY or 0.6 ETH total.\n', '     */\n', '    function getLPvalueInDai(uint256 _pairCode, uint256 _LP) public view returns (uint256) {\n', '        (,address pairPoolAddress,) = yieldFarming.getPairPool(_pairCode);\n', '    \n', '        uint256 totalSupply = IUniswapV2Pair(pairPoolAddress).totalSupply();\n', '        uint256 percentLPinYieldFarm = _LP.mul(base18).div(totalSupply);\n', '        \n', '        uint256 totalKtyInPairPool = IERC20(kittieFightTokenAddr).balanceOf(pairPoolAddress);\n', '\n', '        return totalKtyInPairPool.mul(2).mul(percentLPinYieldFarm).mul(KTY_DAI_price())\n', '               .div(base18).div(base18);\n', '    }\n', '\n', '    function getWalletBalance(address _staker, uint256 _pairCode) external view returns (uint256) {\n', '        (,address pairPoolAddress,) = yieldFarming.getPairPool(_pairCode);\n', '        return IUniswapV2Pair(pairPoolAddress).balanceOf(_staker);\n', '    }\n', '\n', '    function isProgramActive() external view returns (bool) {\n', '        return block.timestamp >= yieldFarming.programStartAt() && block.timestamp <= yieldFarming.programEndAt();\n', '    }\n', '\n', '    // Getters Uniswap\n', '\n', '    /**\n', '     * @dev returns the amount of reserves for the two tokens in uniswap pair contract.\n', '     */\n', '    function getReserve(address _tokenA, address _tokenB, address _pairPool)\n', '        public view returns (uint256 reserveA, uint256 reserveB)\n', '    {\n', '        IUniswapV2Pair pair = IUniswapV2Pair(_pairPool);\n', '        address token0 = pair.token0();\n', '        if (token0 == _tokenA) {\n', '            (reserveA,,) = pair.getReserves();\n', '            (,reserveB,) = pair.getReserves();\n', '        } else if (token0 == _tokenB) {\n', '            (,reserveA,) = pair.getReserves();\n', '            (reserveB,,) = pair.getReserves();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev returns the KTY to ether price on uniswap, that is, how many ether for 1 KTY\n', '     */\n', '    function KTY_ETH_price() public view returns (uint256) {\n', '        uint256 _amountKTY = 1e18;  // 1 KTY\n', '        (uint256 _reserveKTY, uint256 _reserveETH) = getReserve(kittieFightTokenAddr, wethAddr, ktyWethPair);\n', '        return UniswapV2Library.getAmountIn(_amountKTY, _reserveETH, _reserveKTY);\n', '    } \n', '\n', '    /**\n', '     * @dev returns the ether KTY price on uniswap, that is, how many KTYs for 1 ether\n', '     */\n', '    function ETH_KTY_price() public view returns (uint256) {\n', '        uint256 _amountETH = 1e18;  // 1 KTY\n', '        (uint256 _reserveKTY, uint256 _reserveETH) = getReserve(kittieFightTokenAddr, wethAddr, ktyWethPair);\n', '        return UniswapV2Library.getAmountIn(_amountETH, _reserveKTY, _reserveETH);\n', '    }\n', '\n', '    /**\n', '     * @dev returns the DAI to ether price on uniswap, that is, how many ether for 1 DAI\n', '     */\n', '    function DAI_ETH_price() public view returns (uint256) {\n', '        uint256 _amountDAI = 1e18;  // 1 KTY\n', '        (uint256 _reserveDAI, uint256 _reserveETH) = getReserve(daiAddr, wethAddr, daiWethPair);\n', '        return UniswapV2Library.getAmountIn(_amountDAI, _reserveETH, _reserveDAI);\n', '    }\n', '\n', '    /**\n', '     * @dev returns the ether to DAI price on uniswap, that is, how many DAI for 1 ether\n', '     */\n', '    function ETH_DAI_price() public view returns (uint256) {\n', '        uint256 _amountETH = 1e18;  // 1 KTY\n', '        (uint256 _reserveDAI, uint256 _reserveETH) = getReserve(daiAddr, wethAddr, daiWethPair);\n', '        return UniswapV2Library.getAmountIn(_amountETH, _reserveDAI, _reserveETH);\n', '    }\n', '\n', '    /**\n', '     * @dev returns the KTY to DAI price derived from uniswap price in pair contracts, that is, how many DAI for 1 KTY\n', '     */\n', '    function KTY_DAI_price() public view returns (uint256) {\n', '        // get the amount of ethers for 1 KTY\n', '        uint256 etherPerKTY = KTY_ETH_price();\n', '        // get the amount of DAI for 1 ether\n', '        uint256 daiPerEther = ETH_DAI_price();\n', '        // get the amount of DAI for 1 KTY\n', '        uint256 daiPerKTY = etherPerKTY.mul(daiPerEther).div(base18);\n', '        return daiPerKTY;\n', '    }\n', '\n', '    /**\n', '     * @dev returns the DAI to KTY price derived from uniswap price in pair contracts, that is, how many KTY for 1 DAI\n', '     */\n', '    function DAI_KTY_price() public view returns (uint256) {\n', '        // get the amount of ethers for 1 DAI\n', '        uint256 etherPerDAI = DAI_ETH_price();\n', '        // get the amount of KTY for 1 ether\n', '        uint256 ktyPerEther = ETH_KTY_price();\n', '        // get the amount of KTY for 1 DAI\n', '        uint256 ktyPerDAI = etherPerDAI.mul(ktyPerEther).div(base18);\n', '        return ktyPerDAI;\n', '    }\n', '   \n', '}\n', 'contract YieldsCalculator is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /*                                               GENERAL VARIABLES                                                */\n', '    /* ============================================================================================================== */\n', '\n', '    YieldFarming public yieldFarming;\n', '    YieldFarmingHelper public yieldFarmingHelper;\n', '    IVolcieToken public volcie;                                           // VolcieToken contract\n', '\n', '    uint256 constant public base18 = 1000000000000000000;\n', '    uint256 constant public base6 = 1000000;\n', '\n', '    uint256 constant public MONTH = 30 days;// 30 * 24 * 60 * 60;  // MONTH duration is 30 days, to keep things standard\n', '    uint256 constant public DAY = 1 days;// 24 * 60 * 60;\n', '    uint256 constant DAILY_PORTION_IN_MONTH = 33333;\n', '\n', '    // proportionate a month over days\n', '    uint256 constant public monthDays = MONTH / DAY;\n', '\n', '    // total amount of KTY sold\n', '    uint256 internal tokensSold;\n', '\n', '    /*                                                   INITIALIZER                                                  */\n', '    /* ============================================================================================================== */\n', '\n', '    function initialize\n', '    (\n', '        uint256 _tokensSold,\n', '        YieldFarming _yieldFarming,\n', '        YieldFarmingHelper _yieldFarmingHelper,\n', '        IVolcieToken _volcie\n', '    ) \n', '        public initializer\n', '    {\n', '        Ownable.initialize(_msgSender());\n', '        tokensSold = _tokensSold;\n', '        setYieldFarming(_yieldFarming);\n', '        setYieldFarmingHelper(_yieldFarmingHelper);\n', '        setVolcieToken(_volcie);\n', '    }\n', '\n', '    /*                                                 SETTER FUNCTIONS                                               */\n', '    /* ============================================================================================================== */\n', '\n', '    /**\n', '     * @dev Set Uniswap KTY-Weth Pair contract\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setYieldFarming(YieldFarming _yieldFarming) public onlyOwner {\n', '        yieldFarming = _yieldFarming;\n', '    }\n', '\n', '    /**\n', '     * @dev Set Uniswap KTY-Weth Pair contract\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setYieldFarmingHelper(YieldFarmingHelper _yieldFarmingHelper) public onlyOwner {\n', '        yieldFarmingHelper = _yieldFarmingHelper;\n', '    }\n', '\n', '    /**\n', '     * @dev Set VOLCIE contract\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setVolcieToken(IVolcieToken _volcie) public onlyOwner {\n', '        volcie = _volcie;\n', '    }\n', '\n', '    /**\n', '     * @dev Set the amount of tokens sold on private sales\n', '     * @dev This function can only be carreid out by the owner of this contract.\n', '     */\n', '    function setTokensSold(uint256 _tokensSold) public onlyOwner {\n', '        tokensSold = _tokensSold;\n', '    }\n', '\n', '    /*                                                 GETTER FUNCTIONS                                               */\n', '    /* ============================================================================================================== */\n', '\n', '    /**\n', '     * @param _time uint256 The time point for which the month number is enquired\n', '     * @return uint256 the month in which the time point _time is\n', '     */\n', '    function getMonth(uint256 _time) public view returns (uint256) {\n', '        uint256 month;\n', '        uint256 monthStartTime;\n', '\n', '        for (uint256 i = 5; i >= 0; i--) {\n', '            monthStartTime = yieldFarming.getMonthStartAt(i);\n', '            if (_time >= monthStartTime) {\n', '                month = i;\n', '                break;\n', '            }\n', '        }\n', '        return month;\n', '    }\n', '\n', '    /**\n', '     * @param _time uint256 The time point for which the day number is enquired\n', '     * @return uint256 the day in which the time point _time is\n', '     */\n', '    function getDay(uint256 _time) public view returns (uint256) {\n', '        uint256 _programStartAt = yieldFarming.programStartAt();\n', '        if (_time <= _programStartAt) {\n', '            return 0;\n', '        }\n', '        uint256 elapsedTime = _time.sub(_programStartAt);\n', '        return elapsedTime.div(DAY);\n', '    }\n', '\n', '    /**\n', '     * @dev Get the starting month, ending month, and days in starting month during which the locked Liquidity\n', "     *      tokens in _staker's _batchNumber associated with _pairCode are locked and eligible for rewards.\n", '     * @dev The ending month is the month preceding the current month.\n', '     */\n', '    function getLockedPeriod(address _staker, uint256 _batchNumber, uint256 _pairCode)\n', '        public view\n', '        returns (\n', '            uint256 _startingMonth,\n', '            uint256 _endingMonth,\n', '            uint256 _daysInStartMonth\n', '        )\n', '    {\n', '        uint256 _currentMonth = yieldFarming.getCurrentMonth();\n', '        (,,,uint256 _lockedAt) = yieldFarming.getLPinBatch(_staker, _pairCode, _batchNumber);\n', '        uint256 _startingDay = getDay(_lockedAt);\n', '        uint256 _programEndAt = yieldFarming.programEndAt();\n', '\n', '        _startingMonth = getMonth(_lockedAt); \n', '        _endingMonth = _currentMonth == 0 ? 0 : block.timestamp > _programEndAt ? 5 : _currentMonth.sub(1);\n', '        _daysInStartMonth = 30 - getElapsedDaysInMonth(_startingDay, _startingMonth);\n', '    }\n', '\n', '    /**\n', '     * @return unit256 the current day\n', '     * @dev    There are 180 days in this program in total, starting from day 0 to day 179.\n', '     */\n', '    function getCurrentDay() public view returns (uint256) {\n', '        uint256 programStartTime = yieldFarming.programStartAt();\n', '        if (block.timestamp <= programStartTime) {\n', '            return 0;\n', '        }\n', '        uint256 elapsedTime = block.timestamp.sub(programStartTime);\n', '        uint256 currentDay = elapsedTime.div(DAY);\n', '        return currentDay;\n', '    }\n', '\n', '    /**\n', '     * @param _days uint256 which day since this program starts\n', '     * @param _month uint256 which month since this program starts\n', '     * @return unit256 the number of days that have elapsed in this _month\n', '     */\n', '    function getElapsedDaysInMonth(uint256 _days, uint256 _month) public view returns (uint256) {\n', '        // In the first month\n', '        if (_month == 0) {\n', '            return _days;\n', '        }\n', '\n', '        // In the other months\n', '        // Get the unix time for _days\n', '        uint256 month0StartTime = yieldFarming.getMonthStartAt(0);\n', '        uint256 dayInUnix = _days.mul(DAY).add(month0StartTime);\n', '        // If _days are before the start of _month, then no day has been elapsed\n', '        uint256 monthStartTime = yieldFarming.getMonthStartAt(_month);\n', '        if (dayInUnix <= monthStartTime) {\n', '            return 0;\n', '        }\n', '        // get time elapsed in seconds\n', '        uint256 timeElapsed = dayInUnix.sub(monthStartTime);\n', '        return timeElapsed.div(DAY);\n', '    }\n', '\n', '     /**\n', '     * @return unit256 time in seconds until the current month ends\n', '     */\n', '    function timeUntilCurrentMonthEnd() public view returns (uint) {\n', '        uint256 nextMonth = yieldFarming.getCurrentMonth().add(1);\n', '        if (nextMonth > 5) {\n', '            if (block.timestamp >= yieldFarming.getMonthStartAt(5).add(MONTH)) {\n', '                return 0;\n', '            }\n', '            return MONTH.sub(block.timestamp.sub(yieldFarming.getMonthStartAt(5)));\n', '        }\n', '        return yieldFarming.getMonthStartAt(nextMonth).sub(block.timestamp);\n', '    }\n', '\n', '    function calculateYields2(address _staker, uint256 _pairCode, uint256 startBatchNumber, uint256 lockedLP, uint256 startingLP)\n', '        internal view\n', '        returns (uint256 yieldsKTY, uint256 yieldsSDAO) {\n', '        (uint256 _startingMonth, uint256 _endingMonth,) = getLockedPeriod(_staker, startBatchNumber, _pairCode);\n', '        return calculateYields(_startingMonth, _endingMonth, lockedLP, startingLP);\n', '    }\n', '\n', '    /**\n', '     * @return unit256, uint256 the KTY and SDAO rewards calculated based on starting month, ending month,\n', '               locked LP, and starting LP.\n', '     */\n', '    function calculateYields(uint256 startMonth, uint256 endMonth, uint256 lockedLP, uint256 startingLP)\n', '        internal view\n', '        returns (uint256 yieldsKTY, uint256 yieldsSDAO)\n', '    {\n', '        (uint256 yields_part_1_KTY, uint256 yields_part_1_SDAO) = calculateYields_part_1(startMonth, startingLP);\n', '        uint256 yields_part_2_KTY;\n', '        uint256 yields_part_2_SDAO;\n', '        if (endMonth > startMonth) {\n', '            (yields_part_2_KTY, yields_part_2_SDAO) = calculateYields_part_2(startMonth, endMonth, lockedLP);\n', '        }        \n', '        return (yields_part_1_KTY.add(yields_part_2_KTY), yields_part_1_SDAO.add(yields_part_2_SDAO));\n', '    }\n', '\n', '    /**\n', '     * @return unit256, uint256 the KTY and SDAO rewards for the starting month, which are calculated based on\n', '               starting month, and starting LP.\n', '     */\n', '    function calculateYields_part_1(uint256 startMonth, uint256 startingLP)\n', '        internal view\n', '        returns (uint256 yields_part_1_KTY, uint256 yields_part_1_SDAO)\n', '    {\n', '        // yields KTY in startMonth\n', '        uint256 rewardsKTYstartMonth = getTotalKTYRewardsByMonth(startMonth);\n', '        uint256 rewardsSDAOstartMonth = getTotalSDAORewardsByMonth(startMonth);\n', '        uint256 adjustedMonthlyDeposit = yieldFarming.getAdjustedTotalMonthlyDeposits(startMonth);\n', '\n', '        yields_part_1_KTY = rewardsKTYstartMonth.mul(startingLP).div(adjustedMonthlyDeposit);\n', '        yields_part_1_SDAO = rewardsSDAOstartMonth.mul(startingLP).div(adjustedMonthlyDeposit);\n', '    }\n', '\n', '    /**\n', '     * @return unit256, uint256 the KTY and SDAO rewards in the months following the starting month until the end month,\n', '               calculated based on starting month, ending month, and locked LP\n', '     */\n', '    function calculateYields_part_2(uint256 startMonth, uint256 endMonth, uint256 lockedLP)\n', '        internal view\n', '        returns (uint256 yields_part_2_KTY, uint256 yields_part_2_SDAO)\n', '    {\n', '        uint256 adjustedMonthlyDeposit;\n', '        // yields KTY in endMonth and other month between startMonth and endMonth\n', '        for (uint256 i = startMonth.add(1); i <= endMonth; i++) {\n', '            uint256 monthlyRewardsKTY = getTotalKTYRewardsByMonth(i);\n', '            uint256 monthlyRewardsSDAO = getTotalSDAORewardsByMonth(i);\n', '            adjustedMonthlyDeposit = yieldFarming.getAdjustedTotalMonthlyDeposits(i);\n', '            yields_part_2_KTY = yields_part_2_KTY.add(monthlyRewardsKTY.mul(lockedLP).div(adjustedMonthlyDeposit));\n', '            yields_part_2_SDAO = yields_part_2_SDAO.add(monthlyRewardsSDAO.mul(lockedLP).div(adjustedMonthlyDeposit));\n', '        }\n', '         \n', '    }\n', '\n', '    /**\n', '     * @notice Calculate the rewards (KittieFightToken and SuperDaoToken) by the batch number of deposits\n', '     *         made by a staker\n', '     * @param _staker address the address of the staker for whom the rewards are calculated\n', '     * @param _batchNumber the batch number of the deposis made by _staker\n', '     * @param _pairCode uint256 Pair Code assocated with a Pair Pool in this batch\n', '     * @return unit256 the amount of KittieFightToken rewards associated with the _batchNumber of this _staker\n', '     * @return unit256 the amount of SuperDaoToken rewards associated with the _batchNumber of this _staker\n', '     */\n', '    function calculateRewardsByBatchNumber(address _staker, uint256 _batchNumber, uint256 _pairCode)\n', '        public view\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 rewardKTY;\n', '        uint256 rewardSDAO;\n', '\n', '        // If the batch is locked less than 30 days, rewards are 0.\n', '        if (!isBatchEligibleForRewards(_staker, _batchNumber, _pairCode)) {\n', '            return(0, 0);\n', '        }\n', '\n', '        (,uint256 adjustedLockedLP, uint256 adjustedStartingLP,) = yieldFarming.getLPinBatch(_staker, _pairCode, _batchNumber);\n', '\n', '        // calculate KittieFightToken rewards\n', '        (rewardKTY, rewardSDAO) = calculateYields2(_staker, _pairCode, _batchNumber, adjustedLockedLP, adjustedStartingLP);\n', '\n', '        // If the program ends\n', '        if (block.timestamp >= yieldFarming.programEndAt()) {\n', '            // if eligible for Early Mining Bonus, add the rewards for early bonus\n', '            if (yieldFarming.isBatchEligibleForEarlyBonus(_staker, _batchNumber, _pairCode)) {\n', '                uint256 _earlyBonus = getEarlyBonus(adjustedLockedLP);\n', '                rewardKTY = rewardKTY.add(_earlyBonus);\n', '                rewardSDAO = rewardSDAO.add(_earlyBonus);\n', '            }\n', '        }\n', '\n', '        return (rewardKTY, rewardSDAO);\n', '    }\n', '\n', '    /**\n', '     * @param _staker address the staker who has deposited Uniswap Liquidity tokens\n', '     * @param _batchNumber uint256 the batch number of which deposit \n', '     * @param _pairCode uint256 Pair Code assocated with a Pair Pool \n', '     * @return bool true if the batch with the _batchNumber in the _pairCode of the _staker is eligible for claiming yields, false if it is not eligible.\n', '     * @dev    A batch needs to be locked for at least 30 days to be eligible for claiming yields.\n', '     * @dev    A batch locked for less than 30 days has 0 rewards\n', '     */\n', '    function isBatchEligibleForRewards(address _staker, uint256 _batchNumber, uint256 _pairCode)\n', '        public view returns (bool)\n', '    {\n', '        // get locked time\n', '        (,,,uint256 lockedAt) = yieldFarming.getLPinBatch(_staker, _pairCode, _batchNumber);\n', '      \n', '        if (lockedAt == 0) {\n', '            return false;\n', '        }\n', '        // get total locked duration\n', '        uint256 lockedPeriod = block.timestamp.sub(lockedAt);\n', '        // a minimum of 30 days of staking is required to be eligible for claiming rewards\n', '        if (lockedPeriod >= MONTH) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @param _staker address the staker who has deposited Uniswap Liquidity tokens\n', '     * @param _depositNumber uint256 the deposit number of which deposit \n', '     * @dev    A deposit needs to be locked for at least 30 days to be eligible for claiming yields.\n', '     * @dev    A deposit locked for less than 30 days has 0 rewards\n', '     */\n', '    function isDepositEligibleForEarlyBonus(address _staker, uint256 _depositNumber)\n', '        public view returns (bool)\n', '    {\n', '        (uint256 _pairCode, uint256 _batchNumber) = yieldFarming.getBatchNumberAndPairCode(_staker, _depositNumber); \n', '        return yieldFarming.isBatchEligibleForEarlyBonus(_staker, _batchNumber, _pairCode);\n', '    }\n', '\n', '    /**\n', '     * @param _volcieID uint256 the ID of the Volcie Token\n', '     * @dev    A Volcie Token needs to have its associated LP locked for at least 30 days to be eligible \n', '     *         for claiming yields.\n', '     */\n', '    function isVolcieEligibleForEarlyBonus(uint256 _volcieID)\n', '        external view returns (bool)\n', '    {\n', '         (address _originalOwner, uint256 _depositNumber,,,,,,,,) = yieldFarming.getVolcieToken(_volcieID);\n', '         return isDepositEligibleForEarlyBonus(_originalOwner, _depositNumber);\n', '    }\n', '\n', '    /**\n', '     * @return two arrays, the first array contains the monthly KTY rewards for the 6 months, \n', '     *         and the second array contains the monthly SDAO rewards for the 6 months, respectively.\n', '     */\n', '    function getTotalRewards()\n', '        external view\n', '       returns (uint256[6] memory ktyRewards, uint256[6] memory sdaoRewards)\n', '    {\n', '        uint256 _ktyReward;\n', '        uint256 _sdaoReward;\n', '        for (uint256 i = 0; i < 6; i++) {\n', '            _ktyReward = getTotalKTYRewardsByMonth(i);\n', '            _sdaoReward = getTotalSDAORewardsByMonth(i);\n', '            ktyRewards[i] = _ktyReward;\n', '            sdaoRewards[i] = _sdaoReward;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @param _month uint256 the month (from 0 to 5) for which the Reward Unlock Rate is returned\n', '     * @return uint256 the amount of total Rewards for KittieFightToken for the _month\n', '     */\n', '    function getTotalKTYRewardsByMonth(uint256 _month)\n', '        public view \n', '        returns (uint256)\n', '    {\n', '        uint256 _totalRewardsKTY = yieldFarming.totalRewardsKTY();\n', '        (uint256 _KTYunlockRate,) = yieldFarming.getRewardUnlockRateByMonth(_month);\n', '        uint256 _earlyBonus = yieldFarming.EARLY_MINING_BONUS();\n', '        return (_totalRewardsKTY.sub(_earlyBonus)).mul(_KTYunlockRate).div(base6);\n', '    }\n', '\n', '    /**\n', '     * @param _month uint256 the month (from 0 to 5) for which the Reward Unlock Rate is returned\n', '     * @return uint256 the amount of total Rewards for SuperDaoToken for the _month\n', '     */\n', '    function getTotalSDAORewardsByMonth(uint256 _month)\n', '        public view \n', '        returns (uint256)\n', '    {\n', '        uint256 _totalRewardsSDAO = yieldFarming.totalRewardsSDAO();\n', '        (,uint256 _SDAOunlockRate) = yieldFarming.getRewardUnlockRateByMonth(_month);\n', '        uint256 _earlyBonus = yieldFarming.EARLY_MINING_BONUS();\n', '        return (_totalRewardsSDAO.sub(_earlyBonus)).mul(_SDAOunlockRate).div(base6);\n', '    }\n', '\n', '    /**\n', '     * @param _amountLP the amount of locked Liquidity token eligible for claiming early bonus\n', '     * @return uint256 the amount of early bonus for this _staker. Since the amount of early bonus is the same\n', '     *         for KittieFightToken and SuperDaoToken, only one number is returned.\n', '     * @dev    KTY early bonus of the returned value and SDAO early bonus of the returned value are the early bonus accrued for the _amountLP\n', '     */\n', '    function getEarlyBonus(uint256 _amountLP)\n', '        public view returns (uint256)\n', '    {\n', '        uint256 _earlyBonus = yieldFarming.EARLY_MINING_BONUS();\n', '        uint256 _adjustedTotalLockedLPinEarlyMining = yieldFarming.adjustedTotalLockedLPinEarlyMining();\n', '    \n', '        return _amountLP.mul(_earlyBonus).div(_adjustedTotalLockedLPinEarlyMining);\n', '    }\n', '\n', '    /**\n', '     * @param _volcieID the ID of the Volcie token eligible for claiming early bonus\n', '     * @return uint256 the amount of early bonus for this volcie token. Since the amount of early bonus is the same\n', '     *         for KittieFightToken and SuperDaoToken, only one number is returned.\n', '     * @dev    KTY early bonus of the returned value and SDAO early bonus of the returned value are the early bonus accrued for the volcie token\n', '     */\n', '    function getEarlyBonusForVolcie(uint256 _volcieID) external view returns (uint256) {\n', '        (,,,uint256 _LP,,,,,,) = yieldFarming.getVolcieToken(_volcieID);\n', '        return getEarlyBonus(_LP);\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate the rewards (KittieFightToken and SuperDaoToken) by the deposit number of the deposit\n', '     *         made by a staker\n', '     * @param _staker address the address of the staker for whom the rewards are calculated\n', '     * @param _depositNumber the deposit number of the deposits made by _staker\n', '     * @return unit256 the amount of KittieFightToken rewards associated with the _depositNumber of this _staker\n', '     * @return unit256 the amount of SuperDaoToken rewards associated with the _depositNumber of this _staker\n', '     */\n', '    function calculateRewardsByDepositNumber(address _staker, uint256 _depositNumber)\n', '        public view\n', '        returns (uint256, uint256)\n', '    {\n', '        (uint256 _pairCode, uint256 _batchNumber) = yieldFarming.getBatchNumberAndPairCode(_staker, _depositNumber); \n', '        (uint256 _rewardKTY, uint256 _rewardSDAO) = calculateRewardsByBatchNumber(_staker, _batchNumber, _pairCode);\n', '        return (_rewardKTY, _rewardSDAO);\n', '    }\n', '\n', '    function getTotalLPsLocked(address _staker) public view returns (uint256) {\n', '        uint256 _totalPools = yieldFarming.totalNumberOfPairPools();\n', '        uint256 _totalLPs;\n', '        uint256 _LP;\n', '        for (uint256 i = 0; i < _totalPools; i++) {\n', '            _LP = yieldFarming.getLockedLPbyPairCode(_staker, i);\n', '            _totalLPs = _totalLPs.add(_LP);\n', '        }\n', '        return _totalLPs;\n', '    }\n', '\n', '    /**\n', '     * This should actually take users address as parameter to check total LP tokens locked.\n', '       Its same as apy for individual but in number form, i.e Total tokens allocated in the duration\n', '       of the yield farming program, divided by estimated personal allocation based on How much the\n', '       total personal lp tokens locked\n', '     * @return uint256 the Reward Multiplier for KittieFightToken, amplified 1000000 times to avoid float imprecision\n', '     * @return uint256 the Reward Multiplier for SuperDaoFightToken, amplified 1000000 times to avoid float imprecision\n', '     */\n', '    function getRewardMultipliers(address _staker) external view returns (uint256, uint256) {\n', '        uint256 totalLPs = getTotalLPsLocked(_staker);\n', '        if (totalLPs == 0) {\n', '            return (0, 0);\n', '        }\n', '        uint256 totalRewards = yieldFarming.totalRewardsKTY();\n', '        (uint256 rewardsKTY, uint256 rewardsSDAO) = getRewardsToClaim(_staker);\n', '        uint256 rewardMultiplierKTY = rewardsKTY.mul(base6).mul(totalRewards).div(tokensSold).div(totalLPs);\n', '        uint256 rewardMultiplierSDAO = rewardsSDAO.mul(base6).mul(totalRewards).div(tokensSold).div(totalLPs);\n', '        return (rewardMultiplierKTY, rewardMultiplierSDAO);\n', '    }\n', '\n', '    /**\n', '     * @notice This function returns already earned tokens by the _staker\n', '     * @return uint256 the accrued KittieFightToken rewards\n', '     * @return uint256 the accrued SuperDaoFightToken rewards\n', '     */\n', '    function getAccruedRewards(address _staker) public view returns (uint256, uint256) {\n', '        // get rewards already claimed\n', '        uint256[2] memory rewardsClaimed = yieldFarming.getTotalRewardsClaimedByStaker(_staker);\n', '        uint256 _claimedKTY = rewardsClaimed[0];\n', '        uint256 _claimedSDAO = rewardsClaimed[1];\n', '\n', '        // get rewards earned but yet to be claimed\n', '        (uint256 _KTYtoClaim, uint256 _SDAOtoClaim) = getRewardsToClaim(_staker);\n', '\n', '        return (_claimedKTY.add(_KTYtoClaim), _claimedSDAO.add(_SDAOtoClaim));  \n', '    }\n', '\n', '    /**\n', '     * @return the KTY and SDAO rewards earned but yet to claim by a staker\n', '     */\n', '    function getRewardsToClaim(address _staker) internal view returns (uint256, uint256) {\n', '        uint256 _KTY = 0;\n', '        uint256 _SDAO = 0;\n', '        uint256 _ktyRewards;\n', '        uint256 _sdaoRewards;\n', '       \n', '        // get rewards earned but yet to be claimed\n', '        uint256[] memory allVolcies = volcie.allTokenOf(_staker);\n', '        for (uint256 i = 0; i < allVolcies.length; i++) {\n', '            (,, _ktyRewards, _sdaoRewards) = getVolcieValues(allVolcies[i]);\n', '            _KTY = _KTY.add(_ktyRewards);\n', '            _SDAO = _SDAO.add(_sdaoRewards);\n', '        }\n', '\n', '        return (_KTY, _SDAO);  \n', '    }\n', '\n', '    function getFirstMonthAmount(\n', '        uint256 startDay,\n', '        uint256 startMonth,\n', '        uint256 adjustedMonthlyDeposit,\n', '        uint256 _LP\n', '    )\n', '    public view returns(uint256)\n', '    {        \n', '        uint256 monthlyProportion = getElapsedDaysInMonth(startDay, startMonth);\n', '        return adjustedMonthlyDeposit\n', '            .mul(_LP.mul(monthDays.sub(monthlyProportion)))\n', '            .div(adjustedMonthlyDeposit.add(monthlyProportion.mul(_LP).div(monthDays)))\n', '            .div(monthDays);\n', '    }\n', '\n', '    /**\n', '     * @return estimated KTY and SDAO rewards or any hypothetical amount of LPs from a pair code,\n', '     *         if staking starts from now and keep locked until program ends.\n', '     * @dev This function is only used for estimating rewards only\n', '     */\n', '    function estimateRewards(uint256 _LP, uint256 _pairCode) external view returns (uint256, uint256) {\n', '        uint256 startMonth = yieldFarming.getCurrentMonth();\n', '        uint256 startDay = getCurrentDay();\n', '        uint256 factor = yieldFarmingHelper.bubbleFactor(_pairCode);\n', '        uint256 adjustedLP = _LP.mul(base6).div(factor);\n', '        \n', '        uint256 adjustedMonthlyDeposit = yieldFarming.getAdjustedTotalMonthlyDeposits(startMonth);\n', '\n', '        adjustedMonthlyDeposit = adjustedMonthlyDeposit.add(adjustedLP);\n', '\n', '        uint256 currentDepositedAmount = getFirstMonthAmount(startDay, startMonth, adjustedMonthlyDeposit, adjustedLP);\n', '\n', '        (uint256 _KTY, uint256 _SDAO) = estimateYields(startMonth, 5, adjustedLP, currentDepositedAmount, adjustedMonthlyDeposit);\n', '\n', '        // if eligible for Early Mining Bonus, add the rewards for early bonus\n', '        uint256 startTime = yieldFarming.programStartAt();\n', '        if (block.timestamp <= startTime.add(DAY.mul(21))){\n', '            uint256 _earlyBonus = _estimateEarlyBonus(adjustedLP);\n', '            _KTY = _KTY.add(_earlyBonus);\n', '            _SDAO = _SDAO.add(_earlyBonus);\n', '        }\n', '\n', '        return (_KTY, _SDAO);\n', '    }\n', '\n', '    /**\n', '     * @return estimated KTY and SDAO rewards\n', '     * @dev This function is only used for estimating rewards only\n', '     */\n', '    function estimateYields(uint256 startMonth, uint256 endMonth, uint256 lockedLP, uint256 startingLP, uint256 adjustedMonthlyDeposit)\n', '        internal view\n', '        returns (uint256, uint256)\n', '    {\n', '        (uint256 yields_part_1_KTY, uint256 yields_part_1_SDAO)= estimateYields_part_1(startMonth, startingLP, adjustedMonthlyDeposit);\n', '        uint256 yields_part_2_KTY;\n', '        uint256 yields_part_2_SDAO;\n', '        if (endMonth > startMonth) {\n', '            (yields_part_2_KTY, yields_part_2_SDAO) = estimateYields_part_2(startMonth, endMonth, lockedLP, adjustedMonthlyDeposit);\n', '        }\n', '        return (yields_part_1_KTY.add(yields_part_2_KTY), yields_part_1_SDAO.add(yields_part_2_SDAO));\n', '    }\n', '\n', '    /**\n', '     * @return estimated KTY and SDAO rewards for the starting month\n', '     * @dev This function is only used for estimating rewards only\n', '     */\n', '    function estimateYields_part_1(uint256 startMonth, uint256 startingLP, uint256 adjustedMonthlyDeposit)\n', '        internal view\n', '        returns (uint256 yieldsKTY_part_1, uint256 yieldsSDAO_part_1)\n', '    {\n', '        uint256 rewardsKTYstartMonth = getTotalKTYRewardsByMonth(startMonth);\n', '        uint256 rewardsSDAOstartMonth = getTotalSDAORewardsByMonth(startMonth);\n', '\n', '        yieldsKTY_part_1 = rewardsKTYstartMonth.mul(startingLP).div(adjustedMonthlyDeposit);\n', '        yieldsSDAO_part_1 = rewardsSDAOstartMonth.mul(startingLP).div(adjustedMonthlyDeposit);\n', '    }\n', '\n', '    /**\n', '     * @return estimated KTY and SDAO rewards for the for the months following the starting month until the end month\n', '     * @dev This function is only used for estimating rewards only\n', '     */\n', '    function estimateYields_part_2(uint256 startMonth, uint256 endMonth, uint256 lockedLP, uint256 adjustedMonthlyDeposit)\n', '        internal view\n', '        returns (uint256 yieldsKTY_part_2, uint256 yieldsSDAO_part_2)\n', '    {\n', '        for (uint256 i = startMonth.add(1); i <= endMonth; i++) {\n', '            uint256 monthlyRewardsKTY = getTotalKTYRewardsByMonth(i);\n', '            uint256 monthlyRewardsSDAO = getTotalSDAORewardsByMonth(i);\n', '\n', '            yieldsKTY_part_2 = yieldsKTY_part_2\n', '                .add(monthlyRewardsKTY.mul(lockedLP).div(adjustedMonthlyDeposit));\n', '            yieldsSDAO_part_2 = yieldsSDAO_part_2\n', '                .add(monthlyRewardsSDAO.mul(lockedLP).div(adjustedMonthlyDeposit));\n', '        }\n', '         \n', '    }\n', '\n', '    /**\n', '     * @return estimated early bonus for any hypothetical amount of LPs locked\n', '     */\n', '    function estimateEarlyBonus(uint256 _LP, uint256 _pairCode)\n', '        public view returns (uint256)\n', '    {\n', '        uint256 factor = yieldFarmingHelper.bubbleFactor(_pairCode);\n', '        uint256 adjustedLP = _LP.mul(base6).div(factor);\n', '        return _estimateEarlyBonus(adjustedLP);\n', '    }\n', '\n', '    function _estimateEarlyBonus(uint256 adjustedLP)\n', '        internal view returns (uint256)\n', '    {\n', '        uint256 _earlyBonus = yieldFarming.EARLY_MINING_BONUS();\n', '        uint256 _adjustedTotalLockedLPinEarlyMining = yieldFarming.adjustedTotalLockedLPinEarlyMining();\n', '        _adjustedTotalLockedLPinEarlyMining = _adjustedTotalLockedLPinEarlyMining.add(adjustedLP);\n', '        return adjustedLP.mul(_earlyBonus).div(_adjustedTotalLockedLPinEarlyMining);\n', '    }\n', '\n', '    /**\n', '     * @return the LP locked, LP locked value in DAI, accrued KTY rewards, and accrued SDAO rewards \n', '     *         of a Volcie token until the current moment.\n', '     */\n', '    function getVolcieValues(uint256 _volcieID)\n', '        public view returns (uint256, uint256, uint256, uint256)\n', '    {\n', '        (address _originalOwner, uint256 _depositNumber,,uint256 _LP,uint256 _pairCode,,,,,) = yieldFarming.getVolcieToken(_volcieID);\n', '        uint256 _LPvalueInDai = yieldFarmingHelper.getLPvalueInDai(_pairCode, _LP);\n', '        (uint256 _KTY, uint256 _SDAO) = calculateRewardsByDepositNumber(_originalOwner, _depositNumber);\n', '        return (_LP, _LPvalueInDai, _KTY, _SDAO);\n', '    }\n', '\n', '}']