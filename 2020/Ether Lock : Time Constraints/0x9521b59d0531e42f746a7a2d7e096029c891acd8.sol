['/* Keep4r â€“ kp4r.network - 2020 */\n', '\n', 'pragma solidity 0.6.6;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function transfer(address recipient, uint amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function approve(address spender, uint amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        require(b <= a, errorMessage);\n', '        uint c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Keep4rPresale {\n', '    using SafeMath for uint256;\n', '\n', '    // cannot purchase until started\n', '    bool public started;\n', '\n', '    IERC20 KP4R;\n', '    address kp4rAddress;\n', '\n', '    address public manager;\n', '    address public managerPending;\n', '    uint256 constant managerS = 80;\n', '    uint256 public managerWithdrawn;\n', '    address public overseer;\n', '    address public overseerPending;\n', '    uint256 constant overseerS = 20;\n', '    uint256 public overseerWithdrawn;\n', '\n', '    uint256 public unitPrice = 1e18/2;\n', '    uint256 public minimumOrder = 100000;\n', '\n', '    /** @notice the date when purchased KP4R can be claimed */\n', '    uint256 public unlocksOn;\n', '\n', '    /** @notice the date when KP4R can no longer be purchased from the contract */\n', '    uint256 public endsOn;\n', '\n', '    /** @notice percentage bonus actived upon purchasing more than the trigger\n', '    * value. */\n', '    uint256 public bonusTrigger;\n', '    uint256 public bonusPercentage;\n', '\n', '    // Stats:\n', '    uint256 public totalForSale;\n', '    uint256 public totalSold;\n', '    uint256 public totalSettled;\n', '    uint256 public weiRaised;\n', '\n', '    mapping(address => uint256) public balance;\n', '\n', '    event Purchase (address indexed buyer, uint256 amount, uint256 price);\n', '\n', '    constructor(address _kp4r) public {\n', '        manager = msg.sender;\n', '        overseer = msg.sender;\n', '        KP4R = IERC20(_kp4r);\n', '        kp4rAddress = _kp4r;\n', '    }\n', '\n', '    modifier onlyManager {\n', '        require( msg.sender == manager, "Only the manager can call this function." );\n', '        _;\n', '    }\n', '\n', '    modifier onlyOverseer {\n', '        require( msg.sender == overseer, "Only the overseer can call this function.");\n', '        _;\n', '    }\n', '\n', '    function transferRole(address _new) public {\n', '        require(msg.sender == manager || msg.sender == overseer, "!manager or overseer");\n', '        if (msg.sender == manager) { managerPending = _new; return; }\n', '        if (msg.sender == overseer) { overseerPending = _new; return; }\n', '    }\n', '\n', '    function acceptRole() public {\n', '        require(msg.sender == managerPending || msg.sender == overseerPending, "!managerPending or overseerPending");\n', '        if (msg.sender == managerPending) { manager = managerPending; managerPending = address(0); return; }\n', '        if (msg.sender == overseerPending) { overseer = overseerPending; managerPending = address(0); return; }\n', '    }\n', '\n', '    function managerSetPrice(uint256 _price) public onlyManager {\n', '        unitPrice = _price;\n', '    }\n', '\n', '    function managerSetMinimum(uint256 _minimum) public onlyManager {\n', '        minimumOrder = _minimum;\n', '    }\n', '\n', '    function managerSetBonus(uint256 _trigger, uint256 _percentage) public onlyManager {\n', '        bonusTrigger = _trigger;\n', '        bonusPercentage = _percentage;\n', '    }\n', '\n', '    function managerDeposit(uint256 _amount) public onlyManager {\n', '        KP4R.transferFrom(msg.sender, address(this), _amount);\n', '        totalForSale = totalForSale.add(_amount);\n', '    }\n', '\n', '    /** @notice manager can reclaim unsold tokens */\n', '    function managerReclaim(uint256 _amount) public onlyManager {\n', '        // calculate the amount of tokens that haven not been sold\n', '        // and settled and are thus reclaimable:\n', '        uint256 unreclaimable = totalSold.sub(totalSettled);\n', '        uint256 reclaimable = KP4R.balanceOf(address(this)).sub(unreclaimable);\n', '        require(_amount <= reclaimable, "cannot withdraw already sold tokens");\n', '\n', '        // transfer the tokens to the manager\n', '        KP4R.transfer(msg.sender, _amount);\n', '        totalForSale = totalForSale.sub(_amount);\n', '    }\n', '\n', '    function managerWithdraw(uint256 _amount) public onlyManager {\n', '        require(managerWithdrawn.add(_amount) <= weiRaised.mul(managerS).div(100), "cannot withdraw more than the managers share");\n', '        managerWithdrawn = managerWithdrawn.add(_amount);\n', '        msg.sender.transfer(_amount);\n', '    }\n', '\n', '    function overseerWithdraw(uint _amount) public onlyOverseer {\n', '        require(overseerWithdrawn.add(_amount) <= weiRaised.mul(overseerS).div(100), "cannot withdraw more than overseerS");\n', '        overseerWithdrawn = overseerWithdrawn.add(_amount);\n', '        msg.sender.transfer(_amount);\n', '    }\n', '\n', '    function managerClose(uint256 amount) public onlyManager {\n', '        require(block.timestamp > endsOn.add(31536000).mul(2), "must wait until 6 months past end date");\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    function managerForceUnlock() public onlyManager {\n', '        unlocksOn = block.timestamp-1;\n', '    }\n', '\n', '    function start(uint256 _unlocksOn, uint256 _endsOn, uint256 _price, uint256 _minimumOrder) public onlyManager {\n', '        require(!started, "already started");\n', '        unlocksOn = _unlocksOn;\n', '        endsOn = _endsOn;\n', '        unitPrice = _price;\n', '        minimumOrder = _minimumOrder;\n', '        started = true;\n', '    }\n', '\n', '    /** @notice The amount of KP4R remaining */\n', '    function remaining() public view returns (uint256) {\n', '        return KP4R.balanceOf(address(this));\n', '    }\n', '\n', '    /** @notice purchase KP4R at the current unit price */\n', '    function purchase() public payable {\n', '        require(started, "token sale has not yet started");\n', '        require(msg.value > minimumOrder, "amount purchased is too small");\n', '        require(block.timestamp < endsOn, "presale has ended");\n', '\n', '        // calculate the amount of KP4R purchasable\n', '        uint256 _kp4r = calculateAmountPurchased(msg.value);\n', '        require(_kp4r <= KP4R.balanceOf(address(this)), "not enough KP4R left");\n', '\n', '        // update the users balance\n', '        balance[msg.sender] = balance[msg.sender].add(_kp4r);\n', '        totalSold = totalSold.add(_kp4r);\n', '        weiRaised = weiRaised.add(msg.value);\n', '\n', '        emit Purchase(msg.sender, _kp4r, msg.value);\n', '    }\n', '\n', '    /** @notice calculates the amount purchasedfor a given amount of eth */\n', '    function calculateAmountPurchased(uint256 _value) public view returns (uint256) {\n', '        uint256 _kp4r = _value.div(unitPrice).mul(1e18);\n', '        if (_value > bonusTrigger) {\n', '            uint256 _bonus = _kp4r.mul(bonusPercentage).div(1000);\n', '            if (_kp4r.add(_bonus) <= KP4R.balanceOf(address(this))) {\n', '                _kp4r = _kp4r.add(_bonus);\n', '            }\n', '        }\n', '        return _kp4r;\n', '    }\n', '\n', '    /** @notice claim you eth */\n', '    function claim() public {\n', '        require(block.timestamp > unlocksOn, "presale has not unlocked yet");\n', '        require(balance[msg.sender] > 0, "nothing to withdraw");\n', '        KP4R.transfer(msg.sender, balance[msg.sender]);\n', '        totalSettled = totalSettled.add(balance[msg.sender]);\n', '    }\n', '\n', '    // fallbacks to allow users to send to the contract to purchase KP4R\n', '    receive() external payable { purchase(); }\n', '    fallback() external payable { purchase(); }\n', '}']