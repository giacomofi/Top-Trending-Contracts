['pragma solidity ^0.5.16;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        require(b <= a, errorMessage);\n', '        uint c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract JTN is Ownable{\n', '    using SafeMath for uint;\n', '    uint256 public totalStake;\n', '    uint256 public totalVipStake;\n', '    uint32 public currentVipCount;\n', '    uint32 public currentUserCount;\n', '    uint8  public governanceRate = 0;\n', '\n', '    mapping (uint32  => address) public userList;\n', '    mapping (address => bool) public vipMap;\n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => address) public levelToUp;\n', '    mapping (address => address[]) public levelToDown;\n', '    mapping (address => uint) public vipProfit;\n', '\n', '    event NewVip(address indexed from, uint256 amount);\n', '    event Deposit(address indexed from, uint256 amount);\n', '    event AddAdviser(address indexed down, address indexed up);\n', '    event Withdraw(address indexed to, uint256 value);\n', '    event GovWithdraw(address indexed to, uint256 value);\n', '\n', '\n', '    uint constant private minInvestmentLimit = 10 finney;\n', '    uint constant private vipBasePrice = 1 ether;\n', '    uint constant private vipLevelLimit = 100;\n', '\n', '    constructor()public {\n', '    }\n', '\n', '    function buyVip() public payable{\n', '        uint cost = vipPrice();\n', '        require(msg.value == cost, "vip cost mismatch");\n', '        require(!vipMap[msg.sender], "vip already");\n', '        vipMap[msg.sender] = true;\n', '        uint balance = balanceOf(msg.sender);\n', '        if(balance > 0){\n', '            totalVipStake = totalVipStake.add(balance);\n', '        }\n', '        currentVipCount++;\n', '        emit NewVip(msg.sender, msg.value);\n', '    }\n', '    function depositWithAdviser(address _adviser) public payable{\n', '        require(_adviser != address(0) , "zero address input");\n', '        if(_balances[msg.sender] == 0){\n', '            address upper = levelToUp[msg.sender];\n', '            if( upper == address(0) && _adviser != msg.sender && isVip(_adviser)){\n', '                levelToUp[msg.sender] = _adviser;\n', '                levelToDown[_adviser].push(msg.sender);\n', '            }\n', '        }\n', '\n', '        deposit();\n', '        emit AddAdviser(msg.sender,_adviser);\n', '    }\n', '\n', '    function deposit() private {\n', '        if(_balances[msg.sender] == 0){\n', '            require(msg.value >= minInvestmentLimit,"!deposit limit");\n', '            userList[currentUserCount] = msg.sender;\n', '            currentUserCount++;\n', '        }\n', '        require(msg.value > 0, "!value");\n', '        address upper = levelToUp[msg.sender];\n', '\n', '        totalStake = totalStake.add(msg.value);\n', '        if(isVip(msg.sender)){\n', '            totalVipStake = totalVipStake.add(msg.value);\n', '        }\n', '\n', '        if(upper != address(0)){\n', '            uint profit = msg.value.div(100);\n', '            _balances[upper] = _balances[upper].add(profit);\n', '            vipProfit[upper] = vipProfit[upper].add(profit);\n', '        }\n', '        _balances[msg.sender] = _balances[msg.sender].add(msg.value);\n', '        emit Deposit(msg.sender,msg.value);\n', '    }\n', '\n', '    function withdraw(uint256 _amount) public {\n', '        require(_amount > 0, "!value");\n', '        uint reduceAmount = _amount.mul(100).div(100-governanceRate);\n', '        require(reduceAmount <= _balances[msg.sender], "!balance limit");\n', '        _balances[msg.sender] = _balances[msg.sender].sub(reduceAmount, "withdraw amount exceeds balance");\n', '        totalStake = totalStake.sub(reduceAmount);\n', '        if(isVip(msg.sender)){\n', '            totalVipStake = totalVipStake - reduceAmount;\n', '        }\n', '        msg.sender.transfer(_amount);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    function govWithdrawEther(uint256 _amount)onlyOwner public {\n', '        require(_amount > 0, "!zero input");\n', '        msg.sender.transfer(_amount);\n', '        emit GovWithdraw(msg.sender, _amount);\n', '    }\n', '\n', '    function changeRate(uint8 _rate)onlyOwner public {\n', '        require(100 > _rate, "governanceRate big than 100");\n', '        governanceRate = _rate;\n', '    }\n', '\n', '    function() external payable {\n', '        deposit();\n', '    }\n', '\n', '    function vipPrice() public view returns (uint) {\n', '        uint difficult = currentVipCount/vipLevelLimit+1;\n', '        return difficult.mul(vipBasePrice);\n', '    }\n', '    function isVip(address account) public view returns (bool) {\n', '        return vipMap[account];\n', '    }\n', '    function balanceOf(address account) public view returns (uint) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function subCountOf(address account) public view returns (uint) {\n', '        return levelToDown[account].length;\n', '    }\n', '\n', '    function profitOf(address account) public view returns (uint) {\n', '        return vipProfit[account];\n', '    }\n', '\n', '}']