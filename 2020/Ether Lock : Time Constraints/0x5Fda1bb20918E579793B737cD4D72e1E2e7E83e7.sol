['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '   function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newowner;\n', '    address public admin;\n', '    address public dev;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyNewOwner {\n', '        require(msg.sender == newowner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newowner = _newOwner;\n', '    }\n', '    \n', '    function takeOwnership() public onlyNewOwner {\n', '        owner = newowner;\n', '    }    \n', '    \n', '    function setAdmin(address _admin) public onlyOwner {\n', '        admin = _admin;\n', '    }\n', '\n', '    function setDev(address _dev) public onlyOwner {\n', '        dev = _dev;\n', '    }\n', '    \n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin || msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier onlyDev {\n', '        require(msg.sender == dev || msg.sender == admin || msg.sender == owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'abstract contract ContractConn{\n', '    function transfer(address _to, uint _value) virtual public;\n', '    function transferFrom(address _from, address _to, uint _value) virtual public;\n', '    function balanceOf(address who) virtual public view returns (uint);\n', '    function burn(uint256 _value) virtual public returns(bool);\n', '}\n', '\n', 'contract Pledge is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '    \n', '    struct PledgeInfo {\n', '        uint256 id;\n', '        address pledgeor;\n', '        string  coinType;\n', '        uint256 amount;\n', '        uint256 pledgeTime;\n', '        uint256 pledgeBlock;\n', '        uint256 ExpireBlock;\n', '        bool    isValid;\n', '    }\n', '    \n', '    ContractConn public zild;\n', '    \n', '    uint256 public pledgeBlock = 90000;\n', '    uint256 public pledgeBlockChange = 0;\n', '    uint256 public changePledgeTime;\n', '    bool    public needChangeTime = false; \n', '\tuint256 public burnCount = 0;\n', '    uint256 public totalPledge;\n', '    \n', '    mapping(address => PledgeInfo[]) public zild_pledge;\n', '    mapping(address => uint256) public user_pledge_amount;\n', '\n', '    event SetPledgeBlock(uint256 pblock,address indexed who,uint256 time);\n', '    event EffectPledgeBlock(uint256 pblock,address indexed who,uint256 time);\n', '    event WithdrawZILD(address indexed to,uint256 pamount,uint256 time);\n', '    event NeedBurnPledge(address indexed to,uint256 pleid,uint256 pamount);\n', '    event BurnPledge(address  indexed from,uint256 pleid,uint256 pamount);\n', '    event PledgeZILD(address indexed from,uint256 pleid,uint256 pamount,uint256 bblock,uint256 eblock,uint256 time);\n', '    \n', '    constructor(address _zild) public {\n', '        zild = ContractConn(_zild);\n', '    }\n', '\n', '    function setpledgeblock(uint256 _block) public onlyAdmin {\n', '        require(_block > 0,"Pledge: New pledge time must be greater than 0");\n', '        pledgeBlockChange = _block;\n', '        changePledgeTime = block.number;\n', '        needChangeTime = true;\n', '        emit SetPledgeBlock(_block,msg.sender,now);\n', '    }\n', '\n', '    function effectblockchange() public onlyAdmin {\n', '        require(needChangeTime,"Pledge: No new deposit time are set");\n', '        uint256 currentTime = block.number;\n', '        uint256 effectTime = changePledgeTime.add(pledgeBlock);\n', '        if (currentTime < effectTime) return;\n', '        pledgeBlock = pledgeBlockChange;\n', '        needChangeTime = false;\n', '        emit EffectPledgeBlock(pledgeBlockChange,msg.sender,now);\n', '    }\n', '    \n', '\n', '    function burn(uint256 _amount) public onlyAdmin returns(bool) {\n', '        require(_amount > 0 || _amount < burnCount, "pledgeBurnï¼šThe amount exceeds the amount that should be burned");\n', '        zild.burn(_amount);\n', '        burnCount = burnCount.sub(_amount);\n', '        emit BurnPledge(address(msg.sender),_amount,now);\n', '        return true;\n', '    }\n', '\n', '    function pledgeZILD(uint256 _amount) public returns(uint256){\n', '        zild.transferFrom(address(msg.sender), address(this), _amount);\n', '        uint256 length = zild_pledge[msg.sender].length;\n', '        zild_pledge[msg.sender].push(\n', '            PledgeInfo({\n', '                id: length,\n', '                pledgeor: msg.sender,\n', '                coinType: "zild",\n', '                amount: _amount,\n', '                pledgeTime: now,\n', '                pledgeBlock: block.number,\n', '                ExpireBlock: block.number.add(pledgeBlock),\n', '                isValid: true\n', '            })\n', '        );\n', '        user_pledge_amount[msg.sender] = user_pledge_amount[msg.sender].add(_amount); \n', '        totalPledge = totalPledge.add(_amount);\n', '        emit PledgeZILD(msg.sender,length,_amount,block.number,block.number.add(pledgeBlock),now);\n', '        return length;\n', '    }\n', '\n', '    function invalidPledge(address _user, uint256 _id) public onlyDev {\n', '        require(zild_pledge[_user].length > _id);\n', '        zild_pledge[_user][_id].isValid = false;\n', '    }\n', '    \n', '    function validPledge(address _user, uint256 _id) public onlyAdmin{\n', '        require(zild_pledge[_user].length > _id);\n', '        zild_pledge[_user][_id].isValid = true;\n', '    }\n', '    \n', '    function pledgeCount(address _user)  view public returns(uint256) {\n', '        require(msg.sender == _user || msg.sender == owner, "Pledge: Only check your own pledge records");\n', '        return zild_pledge[_user].length;\n', '    }\n', ' \n', '     function pledgeAmount(address _user)  view public returns(uint256) {\n', '        require(msg.sender == _user || msg.sender == owner, "Pledge: Only check your own pledge records");\n', '        return user_pledge_amount[_user];\n', '    }\n', '    \n', '    function clearInvalidOrder(address _user, uint256 _pledgeId) public onlyAdmin{\n', '        PledgeInfo memory pledgeInfo = zild_pledge[address(_user)][_pledgeId];\n', '        if(!pledgeInfo.isValid) {\n', '            burnCount = burnCount.add(pledgeInfo.amount);\n', '            user_pledge_amount[_user] = user_pledge_amount[_user].sub(pledgeInfo.amount); \n', '            totalPledge = totalPledge.sub(pledgeInfo.amount);\n', '            zild_pledge[address(_user)][_pledgeId].amount = 0;\n', '            emit NeedBurnPledge(_user,_pledgeId,pledgeInfo.amount);\n', '        }\n', '    }\n', ' \n', '    function withdrawZILD(uint256 _pledgeId) public returns(bool){\n', '        PledgeInfo memory info = zild_pledge[msg.sender][_pledgeId]; \n', '        require(block.number > info.ExpireBlock, "The withdrawal block has not arrived!");\n', '        require(info.isValid, "The withdrawal pledge has been breached!");\n', '        zild.transfer(msg.sender,info.amount);\n', '        user_pledge_amount[msg.sender] = user_pledge_amount[msg.sender].sub(info.amount); \n', '        totalPledge = totalPledge.sub(info.amount);\n', '        zild_pledge[msg.sender][_pledgeId].amount = 0;\n', '        emit WithdrawZILD(msg.sender,zild_pledge[msg.sender][_pledgeId].amount,now);\n', '        return true;\n', '    }\n', '}']