['// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://eips.ethereum.org/EIPS/eip-20\n', ' * Originally based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' *\n', ' * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n', " * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n", ' * compliant implementations may not do it.\n', ' */\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev Total number of tokens in existence\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param owner The address to query the balance of.\n', '     * @return A uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param owner address The address which owns the funds.\n', '     * @param spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token to a specified address\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another.\n', '     * Note that while this function emits an Approval event, this is not required as per the specification,\n', '     * and other compliant implementations may not emit the event.\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to transfer to\n', '     * @param value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        _transfer(from, to, value);\n', '        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token for a specified addresses\n', '     * @param from The address to transfer from.\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function _transfer(address from, address to, uint256 value) internal {\n', '        require(to != address(0));\n', '\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that mints an amount of the token and assigns it to\n', '     * an account. This encapsulates the modification of balances such that the\n', '     * proper events are emitted.\n', '     * @param account The account that will receive the created tokens.\n', '     * @param value The amount that will be created.\n', '     */\n', '    function _mint(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.add(value);\n', '        _balances[account] = _balances[account].add(value);\n', '        emit Transfer(address(0), account, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account.\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burn(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.sub(value);\n', '        _balances[account] = _balances[account].sub(value);\n', '        emit Transfer(account, address(0), value);\n', '    }\n', '\n', '    /**\n', "     * @dev Approve an address to spend another addresses' tokens.\n", '     * @param owner The address that owns the tokens.\n', '     * @param spender The address that will spend the tokens.\n', '     * @param value The number of tokens that can be spent.\n', '     */\n', '    function _approve(address owner, address spender, uint256 value) internal {\n', '        require(spender != address(0));\n', '        require(owner != address(0));\n', '\n', '        _allowed[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', "     * account, deducting from the sender's allowance for said account. Uses the\n", '     * internal burn function.\n', '     * Emits an Approval event (reflecting the reduced allowance).\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burnFrom(address account, uint256 value) internal {\n', '        _burn(account, value);\n', '        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n', '    }\n', '}\n', '\n', '// File: contracts/common/tokens/ERC20NonTransferable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract ERC20NonTransferable is ERC20 {\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        revert("Disabled");\n', '    }\n', '}\n', '\n', '// File: contracts/common/governance/IGovernance.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'interface IGovernance {\n', '    function update(address target, bytes calldata data) external;\n', '}\n', '\n', '// File: contracts/common/governance/Governable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract Governable {\n', '    IGovernance public governance;\n', '\n', '    constructor(address _governance) public {\n', '        governance = IGovernance(_governance);\n', '    }\n', '\n', '    modifier onlyGovernance() {\n', '        require(\n', '            msg.sender == address(governance),\n', '            "Only governance contract is authorized"\n', '        );\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/root/withdrawManager/IWithdrawManager.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract IWithdrawManager {\n', '    function createExitQueue(address token) external;\n', '\n', '    function verifyInclusion(\n', '        bytes calldata data,\n', '        uint8 offset,\n', '        bool verifyTxInclusion\n', '    ) external view returns (uint256 age);\n', '\n', '    function addExitToQueue(\n', '        address exitor,\n', '        address childToken,\n', '        address rootToken,\n', '        uint256 exitAmountOrTokenId,\n', '        bytes32 txHash,\n', '        bool isRegularExit,\n', '        uint256 priority\n', '    ) external;\n', '\n', '    function addInput(\n', '        uint256 exitId,\n', '        uint256 age,\n', '        address utxoOwner,\n', '        address token\n', '    ) external;\n', '\n', '    function challengeExit(\n', '        uint256 exitId,\n', '        uint256 inputId,\n', '        bytes calldata challengeData,\n', '        address adjudicatorPredicate\n', '    ) external;\n', '}\n', '\n', '// File: contracts/common/Registry.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', 'contract Registry is Governable {\n', '    // @todo hardcode constants\n', '    bytes32 private constant WETH_TOKEN = keccak256("wethToken");\n', '    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");\n', '    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");\n', '    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");\n', '    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");\n', '    bytes32 private constant CHILD_CHAIN = keccak256("childChain");\n', '    bytes32 private constant STATE_SENDER = keccak256("stateSender");\n', '    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");\n', '\n', '    address public erc20Predicate;\n', '    address public erc721Predicate;\n', '\n', '    mapping(bytes32 => address) public contractMap;\n', '    mapping(address => address) public rootToChildToken;\n', '    mapping(address => address) public childToRootToken;\n', '    mapping(address => bool) public proofValidatorContracts;\n', '    mapping(address => bool) public isERC721;\n', '\n', '    enum Type {Invalid, ERC20, ERC721, Custom}\n', '    struct Predicate {\n', '        Type _type;\n', '    }\n', '    mapping(address => Predicate) public predicates;\n', '\n', '    event TokenMapped(address indexed rootToken, address indexed childToken);\n', '    event ProofValidatorAdded(address indexed validator, address indexed from);\n', '    event ProofValidatorRemoved(address indexed validator, address indexed from);\n', '    event PredicateAdded(address indexed predicate, address indexed from);\n', '    event PredicateRemoved(address indexed predicate, address indexed from);\n', '    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\n', '\n', '    constructor(address _governance) public Governable(_governance) {}\n', '\n', '    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\n', '        emit ContractMapUpdated(_key, contractMap[_key], _address);\n', '        contractMap[_key] = _address;\n', '    }\n', '\n', '    /**\n', '     * @dev Map root token to child token\n', '     * @param _rootToken Token address on the root chain\n', '     * @param _childToken Token address on the child chain\n', '     * @param _isERC721 Is the token being mapped ERC721\n', '     */\n', '    function mapToken(\n', '        address _rootToken,\n', '        address _childToken,\n', '        bool _isERC721\n', '    ) external onlyGovernance {\n', '        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");\n', '        rootToChildToken[_rootToken] = _childToken;\n', '        childToRootToken[_childToken] = _rootToken;\n', '        isERC721[_rootToken] = _isERC721;\n', '        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\n', '        emit TokenMapped(_rootToken, _childToken);\n', '    }\n', '\n', '    function addErc20Predicate(address predicate) public onlyGovernance {\n', '        require(predicate != address(0x0), "Can not add null address as predicate");\n', '        erc20Predicate = predicate;\n', '        addPredicate(predicate, Type.ERC20);\n', '    }\n', '\n', '    function addErc721Predicate(address predicate) public onlyGovernance {\n', '        erc721Predicate = predicate;\n', '        addPredicate(predicate, Type.ERC721);\n', '    }\n', '\n', '    function addPredicate(address predicate, Type _type) public onlyGovernance {\n', '        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");\n', '        predicates[predicate]._type = _type;\n', '        emit PredicateAdded(predicate, msg.sender);\n', '    }\n', '\n', '    function removePredicate(address predicate) public onlyGovernance {\n', '        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");\n', '        delete predicates[predicate];\n', '        emit PredicateRemoved(predicate, msg.sender);\n', '    }\n', '\n', '    function getValidatorShareAddress() public view returns (address) {\n', '        return contractMap[VALIDATOR_SHARE];\n', '    }\n', '\n', '    function getWethTokenAddress() public view returns (address) {\n', '        return contractMap[WETH_TOKEN];\n', '    }\n', '\n', '    function getDepositManagerAddress() public view returns (address) {\n', '        return contractMap[DEPOSIT_MANAGER];\n', '    }\n', '\n', '    function getStakeManagerAddress() public view returns (address) {\n', '        return contractMap[STAKE_MANAGER];\n', '    }\n', '\n', '    function getSlashingManagerAddress() public view returns (address) {\n', '        return contractMap[SLASHING_MANAGER];\n', '    }\n', '\n', '    function getWithdrawManagerAddress() public view returns (address) {\n', '        return contractMap[WITHDRAW_MANAGER];\n', '    }\n', '\n', '    function getChildChainAndStateSender() public view returns (address, address) {\n', '        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\n', '    }\n', '\n', '    function isTokenMapped(address _token) public view returns (bool) {\n', '        return rootToChildToken[_token] != address(0x0);\n', '    }\n', '\n', '    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\n', '        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");\n', '        return isERC721[_token];\n', '    }\n', '\n', '    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\n', '        if (isTokenMappedAndIsErc721(_token)) {\n', '            return erc721Predicate;\n', '        }\n', '        return erc20Predicate;\n', '    }\n', '\n', '    function isChildTokenErc721(address childToken) public view returns (bool) {\n', '        address rootToken = childToRootToken[childToken];\n', '        require(rootToken != address(0x0), "Child token is not mapped");\n', '        return isERC721[rootToken];\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/common/lib/BytesLib.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'library BytesLib {\n', '    function concat(bytes memory _preBytes, bytes memory _postBytes)\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        bytes memory tempBytes;\n', '        assembly {\n', '            // Get a location of some free memory and store it in tempBytes as\n', '            // Solidity does for memory variables.\n', '            tempBytes := mload(0x40)\n', '\n', '            // Store the length of the first bytes array at the beginning of\n', '            // the memory for tempBytes.\n', '            let length := mload(_preBytes)\n', '            mstore(tempBytes, length)\n', '\n', '            // Maintain a memory counter for the current write location in the\n', '            // temp bytes array by adding the 32 bytes for the array length to\n', '            // the starting location.\n', '            let mc := add(tempBytes, 0x20)\n', '            // Stop copying when the memory counter reaches the length of the\n', '            // first bytes array.\n', '            let end := add(mc, length)\n', '\n', '            for {\n', '                // Initialize a copy counter to the start of the _preBytes data,\n', '                // 32 bytes into its memory.\n', '                let cc := add(_preBytes, 0x20)\n', '            } lt(mc, end) {\n', '                // Increase both counters by 32 bytes each iteration.\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                // Write the _preBytes data into the tempBytes memory 32 bytes\n', '                // at a time.\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Add the length of _postBytes to the current length of tempBytes\n', '            // and store it as the new length in the first 32 bytes of the\n', '            // tempBytes memory.\n', '            length := mload(_postBytes)\n', '            mstore(tempBytes, add(length, mload(tempBytes)))\n', '\n', '            // Move the memory counter back from a multiple of 0x20 to the\n', '            // actual end of the _preBytes data.\n', '            mc := end\n', '            // Stop copying when the memory counter reaches the new combined\n', '            // length of the arrays.\n', '            end := add(mc, length)\n', '\n', '            for {\n', '                let cc := add(_postBytes, 0x20)\n', '            } lt(mc, end) {\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Update the free-memory pointer by padding our last write location\n', '            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n', '            // next 32 byte block, then round down to the nearest multiple of\n', '            // 32. If the sum of the length of the two arrays is zero then add\n', '            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n', '            mstore(\n', '                0x40,\n', '                and(\n', '                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n', '                    not(31) // Round down to the nearest 32 bytes.\n', '                )\n', '            )\n', '        }\n', '        return tempBytes;\n', '    }\n', '\n', '    function slice(bytes memory _bytes, uint256 _start, uint256 _length)\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        require(_bytes.length >= (_start + _length));\n', '        bytes memory tempBytes;\n', '        assembly {\n', '            switch iszero(_length)\n', '                case 0 {\n', '                    // Get a location of some free memory and store it in tempBytes as\n', '                    // Solidity does for memory variables.\n', '                    tempBytes := mload(0x40)\n', '\n', '                    // The first word of the slice result is potentially a partial\n', '                    // word read from the original array. To read it, we calculate\n', '                    // the length of that partial word and start copying that many\n', '                    // bytes into the array. The first word we copy will start with\n', "                    // data we don't care about, but the last `lengthmod` bytes will\n", '                    // land at the beginning of the contents of the new array. When\n', "                    // we're done copying, we overwrite the full first word with\n", '                    // the actual length of the slice.\n', '                    let lengthmod := and(_length, 31)\n', '\n', '                    // The multiplication in the next line is necessary\n', '                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n', "                    // the following copy loop was copying the origin's length\n", '                    // and then ending prematurely not copying everything it should.\n', '                    let mc := add(\n', '                        add(tempBytes, lengthmod),\n', '                        mul(0x20, iszero(lengthmod))\n', '                    )\n', '                    let end := add(mc, _length)\n', '\n', '                    for {\n', '                        // The multiplication in the next line has the same exact purpose\n', '                        // as the one above.\n', '                        let cc := add(\n', '                            add(\n', '                                add(_bytes, lengthmod),\n', '                                mul(0x20, iszero(lengthmod))\n', '                            ),\n', '                            _start\n', '                        )\n', '                    } lt(mc, end) {\n', '                        mc := add(mc, 0x20)\n', '                        cc := add(cc, 0x20)\n', '                    } {\n', '                        mstore(mc, mload(cc))\n', '                    }\n', '\n', '                    mstore(tempBytes, _length)\n', '\n', '                    //update free-memory pointer\n', '                    //allocating the array padded to 32 bytes like the compiler does now\n', '                    mstore(0x40, and(add(mc, 31), not(31)))\n', '                }\n', "                //if we want a zero-length slice let's just return a zero-length array\n", '                default {\n', '                    tempBytes := mload(0x40)\n', '                    mstore(0x40, add(tempBytes, 0x20))\n', '                }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    // Pad a bytes array to 32 bytes\n', '    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {\n', '        // may underflow if bytes.length < 32. Hence using SafeMath.sub\n', '        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));\n', '        return concat(newBytes, _bytes);\n', '    }\n', '\n', '    function toBytes32(bytes memory b) internal pure returns (bytes32) {\n', '        require(b.length >= 32, "Bytes array should atleast be 32 bytes");\n', '        bytes32 out;\n', '        for (uint256 i = 0; i < 32; i++) {\n', '            out |= bytes32(b[i] & 0xFF) >> (i * 8);\n', '        }\n', '        return out;\n', '    }\n', '\n', '    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {\n', '        assembly {\n', '            result := mload(add(b, 32))\n', '        }\n', '    }\n', '\n', '    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {\n', '        bytes memory b = new bytes(32);\n', '        for (uint256 i = 0; i < 32; i++) {\n', '            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));\n', '        }\n', '        return b;\n', '    }\n', '\n', '    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {\n', '        _ret = new bytes(32);\n', '        assembly {\n', '            mstore(add(_ret, 32), _num)\n', '        }\n', '    }\n', '\n', '    function toUint(bytes memory _bytes, uint256 _start)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(_bytes.length >= (_start + 32));\n', '        uint256 tempUint;\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '        return tempUint;\n', '    }\n', '\n', '    function toAddress(bytes memory _bytes, uint256 _start)\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        require(_bytes.length >= (_start + 20));\n', '        address tempAddress;\n', '        assembly {\n', '            tempAddress := div(\n', '                mload(add(add(_bytes, 0x20), _start)),\n', '                0x1000000000000000000000000\n', '            )\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '}\n', '\n', '// File: contracts/common/lib/ECVerify.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'library ECVerify {\n', '    function ecrecovery(bytes32 hash, bytes memory sig)\n', '        public\n', '        pure\n', '        returns (address)\n', '    {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        if (sig.length != 65) {\n', '            return address(0x0);\n', '        }\n', '\n', '        assembly {\n', '            r := mload(add(sig, 32))\n', '            s := mload(add(sig, 64))\n', '            v := and(mload(add(sig, 65)), 255)\n', '        }\n', '\n', '        // https://github.com/ethereum/go-ethereum/issues/2053\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        if (v != 27 && v != 28) {\n', '            return address(0x0);\n', '        }\n', '\n', '        // get address out of hash and signature\n', '        address result = ecrecover(hash, v, r, s);\n', '\n', '        // ecrecover returns zero on error\n', '        require(result != address(0x0));\n', '\n', '        return result;\n', '    }\n', '\n', '    function ecrecovery(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n', '        public\n', '        pure\n', '        returns (address)\n', '    {\n', '        // get address out of hash and signature\n', '        address result = ecrecover(hash, v, r, s);\n', '\n', '        // ecrecover returns zero on error\n', '        require(result != address(0x0), "signature verification failed");\n', '\n', '        return result;\n', '    }\n', '\n', '    function ecverify(bytes32 hash, bytes memory sig, address signer)\n', '        public\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return signer == ecrecovery(hash, sig);\n', '    }\n', '}\n', '\n', '// File: contracts/staking/StakingInfo.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// dummy interface to avoid cyclic dependency\n', 'contract IStakeManagerLocal {\n', '    enum Status {Inactive, Active, Locked, Unstaked}\n', '\n', '    struct Validator {\n', '        uint256 amount;\n', '        uint256 reward;\n', '        uint256 activationEpoch;\n', '        uint256 deactivationEpoch;\n', '        uint256 jailTime;\n', '        address signer;\n', '        address contractAddress;\n', '        Status status;\n', '    }\n', '\n', '    mapping(uint256 => Validator) public validators;\n', '    bytes32 public accountStateRoot;\n', '    uint256 public activeAmount; // delegation amount from validator contract\n', '    uint256 public validatorRewards;\n', '\n', '    function currentValidatorSetTotalStake() public view returns (uint256);\n', '\n', '    // signer to Validator mapping\n', '    function signerToValidator(address validatorAddress)\n', '        public\n', '        view\n', '        returns (uint256);\n', '\n', '    function isValidator(uint256 validatorId) public view returns (bool);\n', '}\n', '\n', '\n', 'contract StakingInfo is Ownable {\n', '    using SafeMath for uint256;\n', '    mapping(uint256 => uint256) public validatorNonce;\n', '\n', "    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.\n", '    /// @param signer validator address.\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', "    /// @param activationEpoch validator's first epoch as proposer.\n", '    /// @param amount staking amount.\n', '    /// @param total total staking amount.\n', '    /// @param signerPubkey public key of the validator\n', '    event Staked(\n', '        address indexed signer,\n', '        uint256 indexed validatorId,\n', '        uint256 nonce,\n', '        uint256 indexed activationEpoch,\n', '        uint256 amount,\n', '        uint256 total,\n', '        bytes signerPubkey\n', '    );\n', '\n', "    /// @dev Emitted when validator unstakes in 'unstakeClaim()'\n", '    /// @param user address of the validator.\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param amount staking amount.\n', '    /// @param total total staking amount.\n', '    event Unstaked(\n', '        address indexed user,\n', '        uint256 indexed validatorId,\n', '        uint256 amount,\n', '        uint256 total\n', '    );\n', '\n', "    /// @dev Emitted when validator unstakes in '_unstake()'.\n", '    /// @param user address of the validator.\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', '    /// @param deactivationEpoch last epoch for validator.\n', '    /// @param amount staking amount.\n', '    event UnstakeInit(\n', '        address indexed user,\n', '        uint256 indexed validatorId,\n', '        uint256 nonce,\n', '        uint256 deactivationEpoch,\n', '        uint256 indexed amount\n', '    );\n', '\n', "    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.\n", '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', '    /// @param oldSigner old address of the validator.\n', '    /// @param newSigner new address of the validator.\n', '    /// @param signerPubkey public key of the validator.\n', '    event SignerChange(\n', '        uint256 indexed validatorId,\n', '        uint256 nonce,\n', '        address indexed oldSigner,\n', '        address indexed newSigner,\n', '        bytes signerPubkey\n', '    );\n', '    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);\n', '    event Jailed(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed exitEpoch,\n', '        address indexed signer\n', '    );\n', '    event UnJailed(uint256 indexed validatorId, address indexed signer);\n', '    event Slashed(uint256 indexed nonce, uint256 indexed amount);\n', '    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);\n', '    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);\n', '    event ProposerBonusChange(\n', '        uint256 newProposerBonus,\n', '        uint256 oldProposerBonus\n', '    );\n', '\n', '    event RewardUpdate(uint256 newReward, uint256 oldReward);\n', '\n', '    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', '    /// @param newAmount the updated stake amount.\n', '    event StakeUpdate(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed nonce,\n', '        uint256 indexed newAmount\n', '    );\n', '    event ClaimRewards(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed amount,\n', '        uint256 indexed totalAmount\n', '    );\n', '    event StartAuction(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed amount,\n', '        uint256 indexed auctionAmount\n', '    );\n', '    event ConfirmAuction(\n', '        uint256 indexed newValidatorId,\n', '        uint256 indexed oldValidatorId,\n', '        uint256 indexed amount\n', '    );\n', '    event TopUpFee(address indexed user, uint256 indexed fee);\n', '    event ClaimFee(address indexed user, uint256 indexed fee);\n', '    // Delegator events\n', '    event ShareMinted(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed amount,\n', '        uint256 tokens\n', '    );\n', '    event ShareBurned(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed amount,\n', '        uint256 tokens\n', '    );\n', '    event DelegatorClaimedRewards(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed rewards\n', '    );\n', '    event DelegatorRestaked(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed totalStaked\n', '    );\n', '    event DelegatorUnstaked(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 amount\n', '    );\n', '    event UpdateCommissionRate(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed newCommissionRate,\n', '        uint256 indexed oldCommissionRate\n', '    );\n', '\n', '    Registry public registry;\n', '\n', '    modifier onlyValidatorContract(uint256 validatorId) {\n', '        address _contract;\n', '        (, , , , , , _contract, ) = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        )\n', '            .validators(validatorId);\n', '        require(_contract == msg.sender,\n', '        "Invalid sender, not validator");\n', '        _;\n', '    }\n', '\n', '    modifier StakeManagerOrValidatorContract(uint256 validatorId) {\n', '        address _contract;\n', '        address _stakeManager = registry.getStakeManagerAddress();\n', '        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(\n', '            validatorId\n', '        );\n', '        require(_contract == msg.sender || _stakeManager == msg.sender,\n', '        "Invalid sender, not stake manager or validator contract");\n', '        _;\n', '    }\n', '\n', '    modifier onlyStakeManager() {\n', '        require(registry.getStakeManagerAddress() == msg.sender,\n', '        "Invalid sender, not stake manager");\n', '        _;\n', '    }\n', '    modifier onlySlashingManager() {\n', '        require(registry.getSlashingManagerAddress() == msg.sender,\n', '        "Invalid sender, not slashing manager");\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry) public {\n', '        registry = Registry(_registry);\n', '    }\n', '\n', '    function updateNonce(\n', '        uint256[] calldata validatorIds,\n', '        uint256[] calldata nonces\n', '    ) external onlyOwner {\n', '        require(validatorIds.length == nonces.length, "args length mismatch");\n', '\n', '        for (uint256 i = 0; i < validatorIds.length; ++i) {\n', '            validatorNonce[validatorIds[i]] = nonces[i];\n', '        }\n', '    } \n', '\n', '    function logStaked(\n', '        address signer,\n', '        bytes memory signerPubkey,\n', '        uint256 validatorId,\n', '        uint256 activationEpoch,\n', '        uint256 amount,\n', '        uint256 total\n', '    ) public onlyStakeManager {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit Staked(\n', '            signer,\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            activationEpoch,\n', '            amount,\n', '            total,\n', '            signerPubkey\n', '        );\n', '    }\n', '\n', '    function logUnstaked(\n', '        address user,\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        uint256 total\n', '    ) public onlyStakeManager {\n', '        emit Unstaked(user, validatorId, amount, total);\n', '    }\n', '\n', '    function logUnstakeInit(\n', '        address user,\n', '        uint256 validatorId,\n', '        uint256 deactivationEpoch,\n', '        uint256 amount\n', '    ) public onlyStakeManager {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit UnstakeInit(\n', '            user,\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            deactivationEpoch,\n', '            amount\n', '        );\n', '    }\n', '\n', '    function logSignerChange(\n', '        uint256 validatorId,\n', '        address oldSigner,\n', '        address newSigner,\n', '        bytes memory signerPubkey\n', '    ) public onlyStakeManager {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit SignerChange(\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            oldSigner,\n', '            newSigner,\n', '            signerPubkey\n', '        );\n', '    }\n', '\n', '    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit Restaked(validatorId, amount, total);\n', '    }\n', '\n', '    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit Jailed(validatorId, exitEpoch, signer);\n', '    }\n', '\n', '    function logUnjailed(uint256 validatorId, address signer)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit UnJailed(validatorId, signer);\n', '    }\n', '\n', '    function logSlashed(uint256 nonce, uint256 amount)\n', '        public\n', '        onlySlashingManager\n', '    {\n', '        emit Slashed(nonce, amount);\n', '    }\n', '\n', '    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit ThresholdChange(newThreshold, oldThreshold);\n', '    }\n', '\n', '    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit DynastyValueChange(newDynasty, oldDynasty);\n', '    }\n', '\n', '    function logProposerBonusChange(\n', '        uint256 newProposerBonus,\n', '        uint256 oldProposerBonus\n', '    ) public onlyStakeManager {\n', '        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);\n', '    }\n', '\n', '    function logRewardUpdate(uint256 newReward, uint256 oldReward)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit RewardUpdate(newReward, oldReward);\n', '    }\n', '\n', '    function logStakeUpdate(uint256 validatorId)\n', '        public\n', '        StakeManagerOrValidatorContract(validatorId)\n', '    {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit StakeUpdate(\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            totalValidatorStake(validatorId)\n', '        );\n', '    }\n', '\n', '    function logClaimRewards(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        uint256 totalAmount\n', '    ) public onlyStakeManager {\n', '        emit ClaimRewards(validatorId, amount, totalAmount);\n', '    }\n', '\n', '    function logStartAuction(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        uint256 auctionAmount\n', '    ) public onlyStakeManager {\n', '        emit StartAuction(validatorId, amount, auctionAmount);\n', '    }\n', '\n', '    function logConfirmAuction(\n', '        uint256 newValidatorId,\n', '        uint256 oldValidatorId,\n', '        uint256 amount\n', '    ) public onlyStakeManager {\n', '        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);\n', '    }\n', '\n', '    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {\n', '        emit TopUpFee(user, fee);\n', '    }\n', '\n', '    function logClaimFee(address user, uint256 fee) public onlyStakeManager {\n', '        emit ClaimFee(user, fee);\n', '    }\n', '\n', '    function getStakerDetails(uint256 validatorId)\n', '        public\n', '        view\n', '        returns (\n', '            uint256 amount,\n', '            uint256 reward,\n', '            uint256 activationEpoch,\n', '            uint256 deactivationEpoch,\n', '            address signer,\n', '            uint256 _status\n', '        )\n', '    {\n', '        IStakeManagerLocal stakeManager = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        );\n', '        address _contract;\n', '        IStakeManagerLocal.Status status;\n', '        (\n', '            amount,\n', '            reward,\n', '            activationEpoch,\n', '            deactivationEpoch,\n', '            ,\n', '            signer,\n', '            _contract,\n', '            status\n', '        ) = stakeManager.validators(validatorId);\n', '        _status = uint256(status);\n', '        if (_contract != address(0x0)) {\n', '            reward += IStakeManagerLocal(_contract).validatorRewards();\n', '        }\n', '    }\n', '\n', '    function totalValidatorStake(uint256 validatorId)\n', '        public\n', '        view\n', '        returns (uint256 validatorStake)\n', '    {\n', '        address contractAddress;\n', '        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        )\n', '            .validators(validatorId);\n', '        if (contractAddress != address(0x0)) {\n', '            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();\n', '        }\n', '    }\n', '\n', '    function getAccountStateRoot()\n', '        public\n', '        view\n', '        returns (bytes32 accountStateRoot)\n', '    {\n', '        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())\n', '            .accountStateRoot();\n', '    }\n', '\n', '    function getValidatorContractAddress(uint256 validatorId)\n', '        public\n', '        view\n', '        returns (address ValidatorContract)\n', '    {\n', '        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        )\n', '            .validators(validatorId);\n', '    }\n', '\n', '    // validator Share contract logging func\n', '    function logShareMinted(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 amount,\n', '        uint256 tokens\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit ShareMinted(validatorId, user, amount, tokens);\n', '    }\n', '\n', '    function logShareBurned(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 amount,\n', '        uint256 tokens\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit ShareBurned(validatorId, user, amount, tokens);\n', '    }\n', '\n', '    function logDelegatorClaimRewards(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 rewards\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit DelegatorClaimedRewards(validatorId, user, rewards);\n', '    }\n', '\n', '    function logDelegatorRestaked(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 totalStaked\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit DelegatorRestaked(validatorId, user, totalStaked);\n', '    }\n', '\n', '    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)\n', '        public\n', '        onlyValidatorContract(validatorId)\n', '    {\n', '        emit DelegatorUnstaked(validatorId, user, amount);\n', '    }\n', '\n', '    function logUpdateCommissionRate(\n', '        uint256 validatorId,\n', '        uint256 newCommissionRate,\n', '        uint256 oldCommissionRate\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit UpdateCommissionRate(\n', '            validatorId,\n', '            newCommissionRate,\n', '            oldCommissionRate\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/Lockable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract Lockable {\n', '    bool public locked;\n', '\n', '    modifier onlyWhenUnlocked() {\n', '        _assertUnlocked();\n', '        _;\n', '    }\n', '\n', '    function _assertUnlocked() private view {\n', '        require(!locked, "locked");\n', '    }\n', '\n', '    function lock() public {\n', '        locked = true;\n', '    }\n', '\n', '    function unlock() public {\n', '        locked = false;\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/OwnableLockable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract OwnableLockable is Lockable, Ownable {\n', '    function lock() public onlyOwner {\n', '        super.lock();\n', '    }\n', '\n', '    function unlock() public onlyOwner {\n', '        super.unlock();\n', '    }\n', '}\n', '\n', '// File: contracts/staking/stakeManager/IStakeManager.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract IStakeManager {\n', '    // validator replacement\n', '    function startAuction(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        bool acceptDelegation,\n', '        bytes calldata signerPubkey\n', '    ) external;\n', '\n', '    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;\n', '\n', '    function transferFunds(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        address delegator\n', '    ) external returns (bool);\n', '\n', '    function delegationDeposit(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        address delegator\n', '    ) external returns (bool);\n', '\n', '    function stake(\n', '        uint256 amount,\n', '        uint256 heimdallFee,\n', '        bool acceptDelegation,\n', '        bytes calldata signerPubkey\n', '    ) external;\n', '\n', '    function unstake(uint256 validatorId) external;\n', '\n', '    function totalStakedFor(address addr) external view returns (uint256);\n', '\n', '    function stakeFor(\n', '        address user,\n', '        uint256 amount,\n', '        uint256 heimdallFee,\n', '        bool acceptDelegation,\n', '        bytes memory signerPubkey\n', '    ) public;\n', '\n', '    function checkSignatures(\n', '        uint256 blockInterval,\n', '        bytes32 voteHash,\n', '        bytes32 stateRoot,\n', '        address proposer,\n', '        bytes memory sigs\n', '    ) public returns (uint256);\n', '\n', '    function updateValidatorState(uint256 validatorId, int256 amount) public;\n', '\n', '    function ownerOf(uint256 tokenId) public view returns (address);\n', '\n', '    function slash(bytes memory slashingInfoList) public returns (uint256);\n', '\n', '    function validatorStake(uint256 validatorId) public view returns (uint256);\n', '\n', '    function epoch() public view returns (uint256);\n', '\n', '    function withdrawalDelay() public view returns (uint256);\n', '}\n', '\n', '// File: contracts/staking/validatorShare/IValidatorShare.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '// note this contract interface is only for stakeManager use\n', 'contract IValidatorShare {\n', '    function withdrawRewardsValidator() external returns (uint256);\n', '\n', '    function addProposerBonus(uint256 _rewards, uint256 valStake) public;\n', '\n', '    function withdrawRewards() public;\n', '\n', '    function unstakeClaimTokens() public;\n', '\n', '    function getLiquidRewards(address user) public view returns (uint256);\n', '    \n', '    function getActiveAmount() external view returns (uint256);\n', '\n', '    function owner() public view returns (address);\n', '\n', '    function restake() public;\n', '\n', '    function updateRewards(\n', '        uint256 _reward,\n', '        uint256 _totalStake,\n', '        uint256 validatorStake\n', '    ) external returns (uint256);\n', '\n', '    function unlockContract() external returns (uint256);\n', '\n', '    function lockContract() external returns (uint256);\n', '\n', '    function drain(\n', '        address token,\n', '        address payable destination,\n', '        uint256 amount\n', '    ) external;\n', '\n', '    function slash(uint256 valPow, uint256 totalAmountToSlash) external returns (uint256);\n', '\n', '    function updateDelegation(bool delegation) external;\n', '}\n', '\n', '// File: contracts/common/mixin/Initializable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract Initializable {\n', '    bool inited = false;\n', '\n', '    modifier initializer() {\n', '        require(!inited, "already inited");\n', '        inited = true;\n', '        \n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/staking/validatorShare/ValidatorShare.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ValidatorShare is IValidatorShare, ERC20NonTransferable, OwnableLockable, Initializable {\n', '    struct DelegatorUnbond {\n', '        uint256 shares;\n', '        uint256 withdrawEpoch;\n', '    }\n', '\n', '    uint256 constant EXCHANGE_RATE_PRECISION = 100;\n', '    // maximum matic possible, even if rate will be 1 and all matic will be staken in one go, it will result in 10 ^ 58 shares\n', '    uint256 constant EXCHANGE_RATE_HIGH_PRECISION = 10 ** 29; \n', '    uint256 constant MAX_COMMISION_RATE = 100;\n', '    uint256 constant REWARD_PRECISION = 10**25;\n', '\n', '    StakingInfo public stakingLogger;\n', '    IStakeManager public stakeManager;\n', '    uint256 public validatorId;\n', '    uint256 public validatorRewards;\n', '    uint256 public commissionRate;\n', '    //last checkpoint where validator updated commission rate\n', '    uint256 public lastCommissionUpdate;\n', '    uint256 public minAmount = 10**18;\n', '\n', '    // deprecated\n', '    uint256 public __totalStake;\n', '    uint256 public rewardPerShare;\n', '    uint256 public activeAmount;\n', '    bool public delegation = true;\n', '\n', '    uint256 public withdrawPool;\n', '    uint256 public withdrawShares;\n', '\n', '    // deprecated\n', '    mapping(address => uint256) __amountStaked;\n', '    mapping(address => DelegatorUnbond) public unbonds;\n', '    mapping(address => uint256) public initalRewardPerShare;\n', '\n', '    modifier onlyValidator() {\n', '        require(stakeManager.ownerOf(validatorId) == msg.sender, "not validator");\n', '        _;\n', '    }\n', '\n', "    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address\n", '    function initialize(uint256 _validatorId, address _stakingLogger, address _stakeManager) external initializer  {\n', '        validatorId = _validatorId;\n', '        stakingLogger = StakingInfo(_stakingLogger);\n', '        stakeManager = IStakeManager(_stakeManager);\n', '        _transferOwnership(_stakeManager);\n', '\n', '        minAmount = 10**18;\n', '        delegation = true;\n', '    }\n', '\n', '    function updateCommissionRate(uint256 newCommissionRate) external onlyValidator {\n', '        uint256 epoch = stakeManager.epoch();\n', '        uint256 _lastCommissionUpdate = lastCommissionUpdate;\n', '\n', '        require( // withdrawalDelay == dynasty\n', '            (_lastCommissionUpdate.add(stakeManager.withdrawalDelay()) <= epoch) || _lastCommissionUpdate == 0, // For initial setting of commission rate\n', '            "Commission rate update cooldown period"\n', '        );\n', '\n', '        require(newCommissionRate <= MAX_COMMISION_RATE, "Commission rate should be in range of 0-100");\n', '        stakingLogger.logUpdateCommissionRate(validatorId, newCommissionRate, commissionRate);\n', '        commissionRate = newCommissionRate;\n', '        lastCommissionUpdate = epoch;\n', '    }\n', '\n', '    function updateRewards(uint256 reward, uint256 checkpointStakePower, uint256 validatorStake)\n', '        external\n', '        onlyOwner\n', '        returns (uint256)\n', '    {\n', '        uint256 combinedStakePower = validatorStake.add(activeAmount); // validator + delegation stake power\n', '        uint256 rewards = combinedStakePower.mul(reward).div(checkpointStakePower);\n', '\n', '        _updateRewards(rewards, validatorStake, combinedStakePower);\n', '        return combinedStakePower;\n', '    }\n', '\n', '    function addProposerBonus(uint256 rewards, uint256 validatorStake) public onlyOwner {\n', '        uint256 combinedStakePower = validatorStake.add(activeAmount);\n', '        _updateRewards(rewards, validatorStake, combinedStakePower);\n', '    }\n', '\n', '    function _updateRewards(uint256 rewards, uint256 validatorStake, uint256 combinedStakePower) internal {\n', '        uint256 _validatorRewards = validatorStake.mul(rewards).div(combinedStakePower);\n', '\n', '        // add validator commission from delegation rewards\n', '        if (commissionRate > 0) {\n', '            _validatorRewards = _validatorRewards.add(\n', '                rewards.sub(_validatorRewards).mul(commissionRate).div(MAX_COMMISION_RATE)\n', '            );\n', '        }\n', '\n', '        validatorRewards = validatorRewards.add(_validatorRewards);\n', '\n', '        uint256 delegatorsRewards = rewards.sub(_validatorRewards);\n', '        uint256 totalShares = totalSupply();\n', '        if (totalShares > 0) {\n', '            rewardPerShare = rewardPerShare.add(\n', '                delegatorsRewards.mul(REWARD_PRECISION).div(totalShares)\n', '            );\n', '        }\n', '    }\n', '\n', '    function withdrawRewardsValidator() external onlyOwner returns (uint256) {\n', '        uint256 _validatorRewards = validatorRewards;\n', '        validatorRewards = 0;\n', '        return _validatorRewards;\n', '    }\n', '\n', '    function _getRatePrecision() private view returns(uint256) {\n', '        // if foundation validator, use old precision\n', '        if (validatorId < 8) {\n', '            return EXCHANGE_RATE_PRECISION;\n', '        } \n', '\n', '        return EXCHANGE_RATE_HIGH_PRECISION;\n', '    }\n', '\n', '    function exchangeRate() public view returns (uint256) {\n', '        uint256 totalShares = totalSupply();\n', '        uint256 precision = _getRatePrecision();\n', '        return\n', '            totalShares == 0\n', '                ? precision\n', '                : activeAmount.mul(precision).div(totalShares);\n', '    }\n', '\n', '    function withdrawExchangeRate() public view returns (uint256) {\n', '        uint256 precision = _getRatePrecision();\n', '        if (validatorId < 8) {\n', '            // fix of potentially broken withdrawals for future unbonding\n', '            // foundation validators have no slashing enabled and thus we can return default exchange rate\n', '            // because without slashing rate will stay constant\n', '            return precision;\n', '        }\n', '\n', '        uint256 _withdrawShares = withdrawShares;\n', '        return\n', '            _withdrawShares == 0\n', '                ? precision\n', '                : withdrawPool.mul(precision).div(_withdrawShares);\n', '    }\n', '\n', '    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) public {\n', '        _buyVoucher(_amount, _minSharesToMint);\n', '    }\n', '\n', '    function _buyVoucher(uint256 _amount, uint256 _minSharesToMint) internal returns(uint256) {\n', '        _withdrawAndTransferReward();\n', '        uint256 amountToDeposit = _buyShares(_amount, _minSharesToMint);\n', '        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), "deposit failed");\n', '        return amountToDeposit;\n', '    }\n', '\n', '    function _getTotalStake(address user) internal view returns(uint256, uint256) {\n', '        uint256 shares = balanceOf(user);\n', '        uint256 rate = exchangeRate();\n', '        if (shares == 0) {\n', '            return (0, rate);\n', '        }\n', '\n', '        return (rate.mul(shares).div(_getRatePrecision()), rate);\n', '    }\n', '\n', '    function restake() public {\n', '        _restake();\n', '    }\n', '\n', '    function _restake() internal returns(uint256) {\n', '        uint256 liquidReward = _withdrawReward(msg.sender);\n', '        require(liquidReward >= minAmount, "Too small rewards to restake");\n', '\n', '        uint256 amountRestaked = _buyShares(liquidReward, 0);\n', '        if (liquidReward > amountRestaked) {\n', '            // return change to the user\n', '            require(stakeManager.transferFunds(validatorId, liquidReward - amountRestaked, msg.sender), "Insufficent rewards");\n', '            stakingLogger.logDelegatorClaimRewards(validatorId, msg.sender, liquidReward - amountRestaked);\n', '        }\n', '\n', '        (uint256 totalStaked, ) = _getTotalStake(msg.sender);\n', '        stakingLogger.logDelegatorRestaked(validatorId, msg.sender, totalStaked);\n', '\n', '        return amountRestaked;\n', '    }\n', '\n', '    function _buyShares(uint256 _amount, uint256 _minSharesToMint) private onlyWhenUnlocked returns(uint256) {\n', '        require(delegation, "Delegation is disabled");\n', '\n', '        uint256 rate = exchangeRate();\n', '        uint256 precision = _getRatePrecision();\n', '        uint256 shares = _amount.mul(precision).div(rate);\n', '        require(shares >= _minSharesToMint, "Too much slippage");\n', '        require(unbonds[msg.sender].shares == 0, "Ongoing exit");\n', '\n', '        _mint(msg.sender, shares);\n', '\n', '        // clamp amount of tokens in case resulted shares requires less tokens than anticipated\n', '        _amount = _amount.sub(_amount % rate.mul(shares).div(precision));\n', '\n', '        activeAmount = activeAmount.add(_amount);\n', '        stakeManager.updateValidatorState(validatorId, int256(_amount));\n', '\n', '        StakingInfo logger = stakingLogger;\n', '        logger.logShareMinted(validatorId, msg.sender, _amount, shares);\n', '        logger.logStakeUpdate(validatorId);\n', '\n', '        return _amount;\n', '    }\n', '\n', '    function _reduceActiveStake(uint256 activeStakeReduce) private {\n', '        activeAmount = activeAmount.sub(activeStakeReduce);\n', '    }\n', '\n', '    function _reduceWithdrawPool(uint256 withdrawPoolReduce) private {\n', '        withdrawPool = withdrawPool.sub(withdrawPoolReduce);\n', '    }\n', '\n', '    function sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) public {\n', '        // first get how much staked in total and compare to target unstake amount\n', '        (uint256 totalStaked, uint256 rate) = _getTotalStake(msg.sender);\n', '        require(totalStaked > 0 && totalStaked >= claimAmount, "Too much requested");\n', '\n', '        // convert requested amount back to shares\n', '        uint256 precision = _getRatePrecision();\n', '        uint256 shares = claimAmount.mul(precision).div(rate);\n', '        require(shares <= maximumSharesToBurn, "too much slippage");\n', '\n', '        _withdrawAndTransferReward();\n', '        \n', '        _burn(msg.sender, shares);\n', '        stakeManager.updateValidatorState(validatorId, -int256(claimAmount));\n', '\n', '        _reduceActiveStake(claimAmount);\n', '\n', '        uint256 _withdrawPoolShare = claimAmount.mul(precision).div(withdrawExchangeRate());\n', '        withdrawPool = withdrawPool.add(claimAmount);\n', '        withdrawShares = withdrawShares.add(_withdrawPoolShare);\n', '        \n', '        DelegatorUnbond memory unbond = unbonds[msg.sender];\n', '        unbond.shares = unbond.shares.add(_withdrawPoolShare);\n', '        // refresh undond period\n', '        unbond.withdrawEpoch = stakeManager.epoch();\n', '        unbonds[msg.sender] = unbond;\n', '\n', '        StakingInfo logger = stakingLogger;\n', '        logger.logShareBurned(validatorId, msg.sender, claimAmount, shares);\n', '        logger.logStakeUpdate(validatorId);\n', '    }\n', '\n', '    function _withdrawReward(address user) private returns(uint256) {\n', '        uint256 liquidRewards = getLiquidRewards(user);\n', '        initalRewardPerShare[user] = rewardPerShare;\n', '        return liquidRewards;\n', '    }\n', '\n', '    function _withdrawAndTransferReward() private returns(uint256) {\n', '        uint256 liquidRewards = _withdrawReward(msg.sender);\n', '        if (liquidRewards > 0) {\n', '            require(stakeManager.transferFunds(validatorId, liquidRewards, msg.sender), "Insufficent rewards");\n', '            stakingLogger.logDelegatorClaimRewards(validatorId, msg.sender, liquidRewards);\n', '        }\n', '        \n', '        return liquidRewards;\n', '    }\n', '\n', '    function withdrawRewards() public {\n', '        uint256 rewards = _withdrawAndTransferReward();\n', '        require(rewards >= minAmount, "Too small rewards amount");\n', '    }\n', '\n', '    function getLiquidRewards(address user) public view returns (uint256) {\n', '        uint256 shares = balanceOf(user);\n', '        if (shares == 0) {\n', '            return 0;\n', '        }\n', '\n', '        return rewardPerShare.sub(initalRewardPerShare[user]).mul(shares).div(REWARD_PRECISION);\n', '    }\n', '\n', '    function unstakeClaimTokens() public {\n', '        _claimUnstakedTokens();\n', '    }\n', '\n', '    function _claimUnstakedTokens() internal returns(uint256) {\n', '        DelegatorUnbond memory unbond = unbonds[msg.sender];\n', '\n', '        uint256 shares = unbond.shares;\n', '        require(\n', '            unbond.withdrawEpoch.add(stakeManager.withdrawalDelay()) <= stakeManager.epoch() && shares > 0,\n', '            "Incomplete withdrawal period"\n', '        );\n', '\n', '        uint256 _amount = withdrawExchangeRate().mul(shares).div(_getRatePrecision());\n', '        withdrawShares = withdrawShares.sub(shares);\n', '        withdrawPool = withdrawPool.sub(_amount);\n', '\n', '        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), "Insufficent rewards");\n', '        stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, _amount);\n', '        delete unbonds[msg.sender];\n', '\n', '        return _amount;\n', '    }\n', '\n', '    function slash(uint256 valPow, uint256 totalAmountToSlash) external onlyOwner returns (uint256) {\n', '        uint256 _withdrawPool = withdrawPool;\n', '        uint256 delegationAmount = activeAmount.add(_withdrawPool);\n', '        if (delegationAmount == 0) {\n', '            return 0;\n', '        }\n', '        // total amount to be slashed from delegation pool (active + inactive)\n', '        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(valPow.add(delegationAmount));\n', '        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);\n', '\n', '        // slash inactive pool\n', '        _reduceActiveStake(_amountToSlash.sub(_amountToSlashWithdrawalPool));\n', '        _reduceWithdrawPool(_amountToSlashWithdrawalPool);\n', '        return _amountToSlash;\n', '    }\n', '\n', '    function updateDelegation(bool _delegation) external onlyOwner {\n', '        delegation = _delegation;\n', '    }\n', '\n', '    function drain(\n', '        address token,\n', '        address payable destination,\n', '        uint256 amount\n', '    ) external onlyOwner {\n', '        if (token == address(0x0)) {\n', '            destination.transfer(amount);\n', '        } else {\n', '            require(ERC20(token).transfer(destination, amount), "Drain failed");\n', '        }\n', '    }\n', '\n', '    function getActiveAmount() external view returns(uint256) {\n', '        return activeAmount;\n', '    }\n', '\n', '    function unlockContract() external onlyOwner returns (uint256) {\n', '        unlock();\n', '        return activeAmount;\n', '    }\n', '\n', '    function lockContract() external onlyOwner returns (uint256) {\n', '        lock();\n', '        return activeAmount;\n', '    }\n', '}']