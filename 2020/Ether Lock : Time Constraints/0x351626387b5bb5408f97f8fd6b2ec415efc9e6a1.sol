['/**\n', ' *Submitted for verification at Etherscan.io on 2020-11-01\n', '*/\n', '\n', '/*\n', 'B.PROTOCOL TERMS OF USE\n', '=======================\n', '\n', 'THE TERMS OF USE CONTAINED HEREIN (THESE “TERMS”) GOVERN YOUR USE OF B.PROTOCOL, WHICH IS A DECENTRALIZED PROTOCOL ON THE ETHEREUM BLOCKCHAIN (the “PROTOCOL”) THAT enables a backstop liquidity mechanism FOR DECENTRALIZED LENDING PLATFORMS\xa0(“DLPs”).  \n', 'PLEASE READ THESE TERMS CAREFULLY AT https://github.com/backstop-protocol/Terms-and-Conditions, INCLUDING ALL DISCLAIMERS AND RISK FACTORS, BEFORE USING THE PROTOCOL. BY USING THE PROTOCOL, YOU ARE IRREVOCABLY CONSENTING TO BE BOUND BY THESE TERMS. \n', 'IF YOU DO NOT AGREE TO ALL OF THESE TERMS, DO NOT USE THE PROTOCOL. YOUR RIGHT TO USE THE PROTOCOL IS SUBJECT AND DEPENDENT BY YOUR AGREEMENT TO ALL TERMS AND CONDITIONS SET FORTH HEREIN, WHICH AGREEMENT SHALL BE EVIDENCED BY YOUR USE OF THE PROTOCOL.\n', 'Minors Prohibited: The Protocol is not directed to individuals under the age of eighteen (18) or the age of majority in your jurisdiction if the age of majority is greater. If you are under the age of eighteen or the age of majority (if greater), you are not authorized to access or use the Protocol. By using the Protocol, you represent and warrant that you are above such age.\n', '\n', 'License; No Warranties; Limitation of Liability;\n', '(a) The software underlying the Protocol is licensed for use in accordance with the 3-clause BSD License, which can be accessed here: https://opensource.org/licenses/BSD-3-Clause.\n', '(b) THE PROTOCOL IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS", “WITH ALL FAULTS” and “AS AVAILABLE” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n', '(c) IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n', '/*\n', 'B.PROTOCOL TERMS OF USE\n', '=======================\n', '\n', 'THE TERMS OF USE CONTAINED HEREIN (THESE “TERMS”) GOVERN YOUR USE OF B.PROTOCOL, WHICH IS A DECENTRALIZED PROTOCOL ON THE ETHEREUM BLOCKCHAIN (the “PROTOCOL”) THAT enables a backstop liquidity mechanism FOR DECENTRALIZED LENDING PLATFORMS\xa0(“DLPs”).  \n', 'PLEASE READ THESE TERMS CAREFULLY AT https://github.com/backstop-protocol/Terms-and-Conditions, INCLUDING ALL DISCLAIMERS AND RISK FACTORS, BEFORE USING THE PROTOCOL. BY USING THE PROTOCOL, YOU ARE IRREVOCABLY CONSENTING TO BE BOUND BY THESE TERMS. \n', 'IF YOU DO NOT AGREE TO ALL OF THESE TERMS, DO NOT USE THE PROTOCOL. YOUR RIGHT TO USE THE PROTOCOL IS SUBJECT AND DEPENDENT BY YOUR AGREEMENT TO ALL TERMS AND CONDITIONS SET FORTH HEREIN, WHICH AGREEMENT SHALL BE EVIDENCED BY YOUR USE OF THE PROTOCOL.\n', 'Minors Prohibited: The Protocol is not directed to individuals under the age of eighteen (18) or the age of majority in your jurisdiction if the age of majority is greater. If you are under the age of eighteen or the age of majority (if greater), you are not authorized to access or use the Protocol. By using the Protocol, you represent and warrant that you are above such age.\n', '\n', 'License; No Warranties; Limitation of Liability;\n', '(a) The software underlying the Protocol is licensed for use in accordance with the 3-clause BSD License, which can be accessed here: https://opensource.org/licenses/BSD-3-Clause.\n', '(b) THE PROTOCOL IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS", “WITH ALL FAULTS” and “AS AVAILABLE” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n', '(c) IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n', '*/\n', '\n', 'pragma solidity ^0.5.12;\n', '\n', 'contract GemLike {\n', '    function approve(address, uint) public;\n', '    function transfer(address, uint) public;\n', '    function transferFrom(address, address, uint) public;\n', '    function deposit() public payable;\n', '    function withdraw(uint) public;\n', '}\n', '\n', 'contract ManagerLike {\n', '    function cdpCan(address, uint, address) public view returns (uint);\n', '    function ilks(uint) public view returns (bytes32);\n', '    function owns(uint) public view returns (address);\n', '    function urns(uint) public view returns (address);\n', '    function vat() public view returns (address);\n', '    function open(bytes32, address) public returns (uint);\n', '    function give(uint, address) public;\n', '    function cdpAllow(uint, address, uint) public;\n', '    function urnAllow(address, uint) public;\n', '    function frob(uint, int, int) public;\n', '    function flux(uint, address, uint) public;\n', '    function move(uint, address, uint) public;\n', '    function exit(address, uint, address, uint) public;\n', '    function quit(uint, address) public;\n', '    function enter(address, uint) public;\n', '    function shift(uint, uint) public;\n', '}\n', '\n', 'contract VatLike {\n', '    function can(address, address) public view returns (uint);\n', '    function ilks(bytes32) public view returns (uint, uint, uint, uint, uint);\n', '    function dai(address) public view returns (uint);\n', '    function urns(bytes32, address) public view returns (uint, uint);\n', '    function frob(bytes32, address, address, address, int, int) public;\n', '    function hope(address) public;\n', '    function move(address, address, uint) public;\n', '}\n', '\n', 'contract GemJoinLike {\n', '    function dec() public returns (uint);\n', '    function gem() public returns (GemLike);\n', '    function join(address, uint) public payable;\n', '    function exit(address, uint) public;\n', '}\n', '\n', 'contract GNTJoinLike {\n', '    function bags(address) public view returns (address);\n', '    function make(address) public returns (address);\n', '}\n', '\n', 'contract DaiJoinLike {\n', '    function vat() public returns (VatLike);\n', '    function dai() public returns (GemLike);\n', '    function join(address, uint) public payable;\n', '    function exit(address, uint) public;\n', '}\n', '\n', 'contract HopeLike {\n', '    function hope(address) public;\n', '    function nope(address) public;\n', '}\n', '\n', 'contract EndLike {\n', '    function fix(bytes32) public view returns (uint);\n', '    function cash(bytes32, uint) public;\n', '    function free(bytes32) public;\n', '    function pack(uint) public;\n', '    function skim(bytes32, address) public;\n', '}\n', '\n', 'contract JugLike {\n', '    function drip(bytes32) public returns (uint);\n', '}\n', '\n', 'contract PotLike {\n', '    function pie(address) public view returns (uint);\n', '    function drip() public returns (uint);\n', '    function join(uint) public;\n', '    function exit(uint) public;\n', '}\n', '\n', 'contract ProxyRegistryLike {\n', '    function proxies(address) public view returns (address);\n', '    function build(address) public returns (address);\n', '}\n', '\n', 'contract ProxyLike {\n', '    function owner() public view returns (address);\n', '}\n', '\n', '// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n', '// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\n', '// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n', '\n', 'contract Common {\n', '    uint256 constant RAY = 10 ** 27;\n', '\n', '    // Internal functions\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "mul-overflow");\n', '    }\n', '\n', '    // Public functions\n', '\n', '    function daiJoin_join(address apt, address urn, uint wad) public {\n', "        // Gets DAI from the user's wallet\n", '        DaiJoinLike(apt).dai().transferFrom(msg.sender, address(this), wad);\n', '        // Approves adapter to take the DAI amount\n', '        DaiJoinLike(apt).dai().approve(apt, wad);\n', '        // Joins DAI into the vat\n', '        DaiJoinLike(apt).join(urn, wad);\n', '    }\n', '}\n', '\n', 'contract DssProxyActions is Common {\n', '    // Internal functions\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "sub-overflow");\n', '    }\n', '\n', '    function toInt(uint x) internal pure returns (int y) {\n', '        y = int(x);\n', '        require(y >= 0, "int-overflow");\n', '    }\n', '\n', '    function toRad(uint wad) internal pure returns (uint rad) {\n', '        rad = mul(wad, 10 ** 27);\n', '    }\n', '\n', '    function convertTo18(address gemJoin, uint256 amt) internal returns (uint256 wad) {\n', '        // For those collaterals that have less than 18 decimals precision we need to do the conversion before passing to frob function\n', '        // Adapters will automatically handle the difference of precision\n', '        wad = mul(\n', '            amt,\n', '            10 ** (18 - GemJoinLike(gemJoin).dec())\n', '        );\n', '    }\n', '\n', '    function _getDrawDart(\n', '        address vat,\n', '        address jug,\n', '        address urn,\n', '        bytes32 ilk,\n', '        uint wad\n', '    ) internal returns (int dart) {\n', '        // Updates stability fee rate\n', '        uint rate = JugLike(jug).drip(ilk);\n', '\n', '        // Gets DAI balance of the urn in the vat\n', '        uint dai = VatLike(vat).dai(urn);\n', '\n', '        // If there was already enough DAI in the vat balance, just exits it without adding more debt\n', '        if (dai < mul(wad, RAY)) {\n', '            // Calculates the needed dart so together with the existing dai in the vat is enough to exit wad amount of DAI tokens\n', '            dart = toInt(sub(mul(wad, RAY), dai) / rate);\n', '            // This is neeeded due lack of precision. It might need to sum an extra dart wei (for the given DAI wad amount)\n', '            dart = mul(uint(dart), rate) < mul(wad, RAY) ? dart + 1 : dart;\n', '        }\n', '    }\n', '\n', '    function _getWipeDart(\n', '        address vat,\n', '        uint dai,\n', '        address urn,\n', '        bytes32 ilk\n', '    ) internal view returns (int dart) {\n', '        // Gets actual rate from the vat\n', '        (, uint rate,,,) = VatLike(vat).ilks(ilk);\n', '        // Gets actual art value of the urn\n', '        (, uint art) = VatLike(vat).urns(ilk, urn);\n', '\n', '        // Uses the whole dai balance in the vat to reduce the debt\n', '        dart = toInt(dai / rate);\n', '        // Checks the calculated dart is not higher than urn.art (total debt), otherwise uses its value\n', '        dart = uint(dart) <= art ? - dart : - toInt(art);\n', '    }\n', '\n', '    function _getWipeAllWad(\n', '        address vat,\n', '        address usr,\n', '        address urn,\n', '        bytes32 ilk\n', '    ) internal view returns (uint wad) {\n', '        // Gets actual rate from the vat\n', '        (, uint rate,,,) = VatLike(vat).ilks(ilk);\n', '        // Gets actual art value of the urn\n', '        (, uint art) = VatLike(vat).urns(ilk, urn);\n', '        // Gets actual dai amount in the urn\n', '        uint dai = VatLike(vat).dai(usr);\n', '\n', '        uint rad = sub(mul(art, rate), dai);\n', '        wad = rad / RAY;\n', '\n', '        // If the rad precision has some dust, it will need to request for 1 extra wad wei\n', '        wad = mul(wad, RAY) < rad ? wad + 1 : wad;\n', '    }\n', '\n', '    // Public functions\n', '\n', '    function transfer(address gem, address dst, uint amt) public {\n', '        GemLike(gem).transfer(dst, amt);\n', '    }\n', '\n', '    function ethJoin_join(address apt, address urn) public payable {\n', '        // Wraps ETH in WETH\n', '        GemJoinLike(apt).gem().deposit.value(msg.value)();\n', '        // Approves adapter to take the WETH amount\n', '        GemJoinLike(apt).gem().approve(address(apt), msg.value);\n', '        // Joins WETH collateral into the vat\n', '        GemJoinLike(apt).join(urn, msg.value);\n', '    }\n', '\n', '    function gemJoin_join(address apt, address urn, uint amt, bool transferFrom) public {\n', '        // Only executes for tokens that have approval/transferFrom implementation\n', '        if (transferFrom) {\n', "            // Gets token from the user's wallet\n", '            GemJoinLike(apt).gem().transferFrom(msg.sender, address(this), amt);\n', '            // Approves adapter to take the token amount\n', '            GemJoinLike(apt).gem().approve(apt, amt);\n', '        }\n', '        // Joins token collateral into the vat\n', '        GemJoinLike(apt).join(urn, amt);\n', '    }\n', '\n', '    function hope(\n', '        address obj,\n', '        address usr\n', '    ) public {\n', '        HopeLike(obj).hope(usr);\n', '    }\n', '\n', '    function nope(\n', '        address obj,\n', '        address usr\n', '    ) public {\n', '        HopeLike(obj).nope(usr);\n', '    }\n', '\n', '    function open(\n', '        address manager,\n', '        bytes32 ilk,\n', '        address usr\n', '    ) public returns (uint cdp) {\n', '        cdp = ManagerLike(manager).open(ilk, usr);\n', '    }\n', '\n', '    function give(\n', '        address manager,\n', '        uint cdp,\n', '        address usr\n', '    ) public {\n', '        ManagerLike(manager).give(cdp, usr);\n', '    }\n', '\n', '    function giveToProxy(\n', '        address proxyRegistry,\n', '        address manager,\n', '        uint cdp,\n', '        address dst\n', '    ) public {\n', '        // Gets actual proxy address\n', '        address proxy = ProxyRegistryLike(proxyRegistry).proxies(dst);\n', '        // Checks if the proxy address already existed and dst address is still the owner\n', '        if (proxy == address(0) || ProxyLike(proxy).owner() != dst) {\n', '            uint csize;\n', '            assembly {\n', '                csize := extcodesize(dst)\n', '            }\n', '            // We want to avoid creating a proxy for a contract address that might not be able to handle proxies, then losing the CDP\n', '            require(csize == 0, "Dst-is-a-contract");\n', '            // Creates the proxy for the dst address\n', '            proxy = ProxyRegistryLike(proxyRegistry).build(dst);\n', '        }\n', '        // Transfers CDP to the dst proxy\n', '        give(manager, cdp, proxy);\n', '    }\n', '\n', '    function cdpAllow(\n', '        address manager,\n', '        uint cdp,\n', '        address usr,\n', '        uint ok\n', '    ) public {\n', '        ManagerLike(manager).cdpAllow(cdp, usr, ok);\n', '    }\n', '\n', '    function urnAllow(\n', '        address manager,\n', '        address usr,\n', '        uint ok\n', '    ) public {\n', '        ManagerLike(manager).urnAllow(usr, ok);\n', '    }\n', '\n', '    function flux(\n', '        address manager,\n', '        uint cdp,\n', '        address dst,\n', '        uint wad\n', '    ) public {\n', '        ManagerLike(manager).flux(cdp, dst, wad);\n', '    }\n', '\n', '    function move(\n', '        address manager,\n', '        uint cdp,\n', '        address dst,\n', '        uint rad\n', '    ) public {\n', '        ManagerLike(manager).move(cdp, dst, rad);\n', '    }\n', '\n', '    function frob(\n', '        address manager,\n', '        uint cdp,\n', '        int dink,\n', '        int dart\n', '    ) public {\n', '        ManagerLike(manager).frob(cdp, dink, dart);\n', '    }\n', '\n', '    function quit(\n', '        address manager,\n', '        uint cdp,\n', '        address dst\n', '    ) public {\n', '        ManagerLike(manager).quit(cdp, dst);\n', '    }\n', '\n', '    function enter(\n', '        address manager,\n', '        address src,\n', '        uint cdp\n', '    ) public {\n', '        ManagerLike(manager).enter(src, cdp);\n', '    }\n', '\n', '    function shift(\n', '        address manager,\n', '        uint cdpSrc,\n', '        uint cdpOrg\n', '    ) public {\n', '        ManagerLike(manager).shift(cdpSrc, cdpOrg);\n', '    }\n', '\n', '    function makeGemBag(\n', '        address gemJoin\n', '    ) public returns (address bag) {\n', '        bag = GNTJoinLike(gemJoin).make(address(this));\n', '    }\n', '\n', '    function lockETH(\n', '        address manager,\n', '        address ethJoin,\n', '        uint cdp\n', '    ) public payable {\n', '        // Receives ETH amount, converts it to WETH and joins it into the vat\n', '        ethJoin_join(ethJoin, address(this));\n', '        // Locks WETH amount into the CDP\n', '        VatLike(ManagerLike(manager).vat()).frob(\n', '            ManagerLike(manager).ilks(cdp),\n', '            ManagerLike(manager).urns(cdp),\n', '            address(this),\n', '            address(this),\n', '            toInt(msg.value),\n', '            0\n', '        );\n', '    }\n', '\n', '    function safeLockETH(\n', '        address manager,\n', '        address ethJoin,\n', '        uint cdp,\n', '        address owner\n', '    ) public payable {\n', '        require(ManagerLike(manager).owns(cdp) == owner, "owner-missmatch");\n', '        lockETH(manager, ethJoin, cdp);\n', '    }\n', '\n', '    function lockGem(\n', '        address manager,\n', '        address gemJoin,\n', '        uint cdp,\n', '        uint amt,\n', '        bool transferFrom\n', '    ) public {\n', "        // Takes token amount from user's wallet and joins into the vat\n", '        gemJoin_join(gemJoin, address(this), amt, transferFrom);\n', '        // Locks token amount into the CDP\n', '        VatLike(ManagerLike(manager).vat()).frob(\n', '            ManagerLike(manager).ilks(cdp),\n', '            ManagerLike(manager).urns(cdp),\n', '            address(this),\n', '            address(this),\n', '            toInt(convertTo18(gemJoin, amt)),\n', '            0\n', '        );\n', '    }\n', '\n', '    function safeLockGem(\n', '        address manager,\n', '        address gemJoin,\n', '        uint cdp,\n', '        uint amt,\n', '        bool transferFrom,\n', '        address owner\n', '    ) public {\n', '        require(ManagerLike(manager).owns(cdp) == owner, "owner-missmatch");\n', '        lockGem(manager, gemJoin, cdp, amt, transferFrom);\n', '    }\n', '\n', '    function freeETH(\n', '        address manager,\n', '        address ethJoin,\n', '        uint cdp,\n', '        uint wad\n', '    ) public {\n', '        // Unlocks WETH amount from the CDP\n', '        frob(manager, cdp, -toInt(wad), 0);\n', "        // Moves the amount from the CDP urn to proxy's address\n", '        flux(manager, cdp, address(this), wad);\n', '        // Exits WETH amount to proxy address as a token\n', '        GemJoinLike(ethJoin).exit(address(this), wad);\n', '        // Converts WETH to ETH\n', '        GemJoinLike(ethJoin).gem().withdraw(wad);\n', "        // Sends ETH back to the user's wallet\n", '        msg.sender.transfer(wad);\n', '    }\n', '\n', '    function freeGem(\n', '        address manager,\n', '        address gemJoin,\n', '        uint cdp,\n', '        uint amt\n', '    ) public {\n', '        uint wad = convertTo18(gemJoin, amt);\n', '        // Unlocks token amount from the CDP\n', '        frob(manager, cdp, -toInt(wad), 0);\n', "        // Moves the amount from the CDP urn to proxy's address\n", '        flux(manager, cdp, address(this), wad);\n', "        // Exits token amount to the user's wallet as a token\n", '        GemJoinLike(gemJoin).exit(msg.sender, amt);\n', '    }\n', '\n', '    function exitETH(\n', '        address manager,\n', '        address ethJoin,\n', '        uint cdp,\n', '        uint wad\n', '    ) public {\n', "        // Moves the amount from the CDP urn to proxy's address\n", '        flux(manager, cdp, address(this), wad);\n', '\n', '        // Exits WETH amount to proxy address as a token\n', '        GemJoinLike(ethJoin).exit(address(this), wad);\n', '        // Converts WETH to ETH\n', '        GemJoinLike(ethJoin).gem().withdraw(wad);\n', "        // Sends ETH back to the user's wallet\n", '        msg.sender.transfer(wad);\n', '    }\n', '\n', '    function exitGem(\n', '        address manager,\n', '        address gemJoin,\n', '        uint cdp,\n', '        uint amt\n', '    ) public {\n', "        // Moves the amount from the CDP urn to proxy's address\n", '        flux(manager, cdp, address(this), convertTo18(gemJoin, amt));\n', '\n', "        // Exits token amount to the user's wallet as a token\n", '        GemJoinLike(gemJoin).exit(msg.sender, amt);\n', '    }\n', '\n', '    function draw(\n', '        address manager,\n', '        address jug,\n', '        address daiJoin,\n', '        uint cdp,\n', '        uint wad\n', '    ) public {\n', '        address urn = ManagerLike(manager).urns(cdp);\n', '        address vat = ManagerLike(manager).vat();\n', '        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n', '        // Generates debt in the CDP\n', '        frob(manager, cdp, 0, _getDrawDart(vat, jug, urn, ilk, wad));\n', "        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n", '        move(manager, cdp, address(this), toRad(wad));\n', "        // Allows adapter to access to proxy's DAI balance in the vat\n", '        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n', '            VatLike(vat).hope(daiJoin);\n', '        }\n', "        // Exits DAI to the user's wallet as a token\n", '        DaiJoinLike(daiJoin).exit(msg.sender, wad);\n', '    }\n', '\n', '    function wipe(\n', '        address manager,\n', '        address daiJoin,\n', '        uint cdp,\n', '        uint wad\n', '    ) public {\n', '        address vat = ManagerLike(manager).vat();\n', '        address urn = ManagerLike(manager).urns(cdp);\n', '        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n', '\n', '        address own = ManagerLike(manager).owns(cdp);\n', '        if (own == address(this) || ManagerLike(manager).cdpCan(own, cdp, address(this)) == 1) {\n', '            // Joins DAI amount into the vat\n', '            daiJoin_join(daiJoin, urn, wad);\n', '            // Paybacks debt to the CDP\n', '            frob(manager, cdp, 0, _getWipeDart(vat, VatLike(vat).dai(urn), urn, ilk));\n', '        } else {\n', '             // Joins DAI amount into the vat\n', '            daiJoin_join(daiJoin, address(this), wad);\n', '            // Paybacks debt to the CDP\n', '            VatLike(vat).frob(\n', '                ilk,\n', '                urn,\n', '                address(this),\n', '                address(this),\n', '                0,\n', '                _getWipeDart(vat, wad * RAY, urn, ilk)\n', '            );\n', '        }\n', '    }\n', '\n', '    function safeWipe(\n', '        address manager,\n', '        address daiJoin,\n', '        uint cdp,\n', '        uint wad,\n', '        address owner\n', '    ) public {\n', '        require(ManagerLike(manager).owns(cdp) == owner, "owner-missmatch");\n', '        wipe(manager, daiJoin, cdp, wad);\n', '    }\n', '\n', '    function wipeAll(\n', '        address manager,\n', '        address daiJoin,\n', '        uint cdp\n', '    ) public {\n', '        address vat = ManagerLike(manager).vat();\n', '        address urn = ManagerLike(manager).urns(cdp);\n', '        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n', '        (, uint art) = VatLike(vat).urns(ilk, urn);\n', '\n', '        address own = ManagerLike(manager).owns(cdp);\n', '        if (own == address(this) || ManagerLike(manager).cdpCan(own, cdp, address(this)) == 1) {\n', '            // Joins DAI amount into the vat\n', '            daiJoin_join(daiJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\n', '            // Paybacks debt to the CDP\n', '            frob(manager, cdp, 0, -int(art));\n', '        } else {\n', '            // Joins DAI amount into the vat\n', '            daiJoin_join(daiJoin, address(this), _getWipeAllWad(vat, address(this), urn, ilk));\n', '            // Paybacks debt to the CDP\n', '            VatLike(vat).frob(\n', '                ilk,\n', '                urn,\n', '                address(this),\n', '                address(this),\n', '                0,\n', '                -int(art)\n', '            );\n', '        }\n', '    }\n', '\n', '    function safeWipeAll(\n', '        address manager,\n', '        address daiJoin,\n', '        uint cdp,\n', '        address owner\n', '    ) public {\n', '        require(ManagerLike(manager).owns(cdp) == owner, "owner-missmatch");\n', '        wipeAll(manager, daiJoin, cdp);\n', '    }\n', '\n', '    function lockETHAndDraw(\n', '        address manager,\n', '        address jug,\n', '        address ethJoin,\n', '        address daiJoin,\n', '        uint cdp,\n', '        uint wadD\n', '    ) public payable {\n', '        address urn = ManagerLike(manager).urns(cdp);\n', '        address vat = ManagerLike(manager).vat();\n', '        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n', '        // Receives ETH amount, converts it to WETH and joins it into the vat\n', '        ethJoin_join(ethJoin, urn);\n', '        // Locks WETH amount into the CDP and generates debt\n', '        frob(manager, cdp, toInt(msg.value), _getDrawDart(vat, jug, urn, ilk, wadD));\n', "        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n", '        move(manager, cdp, address(this), toRad(wadD));\n', "        // Allows adapter to access to proxy's DAI balance in the vat\n", '        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n', '            VatLike(vat).hope(daiJoin);\n', '        }\n', "        // Exits DAI to the user's wallet as a token\n", '        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n', '    }\n', '\n', '    function openLockETHAndDraw(\n', '        address manager,\n', '        address jug,\n', '        address ethJoin,\n', '        address daiJoin,\n', '        bytes32 ilk,\n', '        uint wadD\n', '    ) public payable returns (uint cdp) {\n', '        cdp = open(manager, ilk, address(this));\n', '        lockETHAndDraw(manager, jug, ethJoin, daiJoin, cdp, wadD);\n', '    }\n', '\n', '    function lockGemAndDraw(\n', '        address manager,\n', '        address jug,\n', '        address gemJoin,\n', '        address daiJoin,\n', '        uint cdp,\n', '        uint amtC,\n', '        uint wadD,\n', '        bool transferFrom\n', '    ) public {\n', '        address urn = ManagerLike(manager).urns(cdp);\n', '        address vat = ManagerLike(manager).vat();\n', '        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n', "        // Takes token amount from user's wallet and joins into the vat\n", '        gemJoin_join(gemJoin, urn, amtC, transferFrom);\n', '        // Locks token amount into the CDP and generates debt\n', '        frob(manager, cdp, toInt(convertTo18(gemJoin, amtC)), _getDrawDart(vat, jug, urn, ilk, wadD));\n', "        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n", '        move(manager, cdp, address(this), toRad(wadD));\n', "        // Allows adapter to access to proxy's DAI balance in the vat\n", '        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n', '            VatLike(vat).hope(daiJoin);\n', '        }\n', "        // Exits DAI to the user's wallet as a token\n", '        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n', '    }\n', '\n', '    function openLockGemAndDraw(\n', '        address manager,\n', '        address jug,\n', '        address gemJoin,\n', '        address daiJoin,\n', '        bytes32 ilk,\n', '        uint amtC,\n', '        uint wadD,\n', '        bool transferFrom\n', '    ) public returns (uint cdp) {\n', '        cdp = open(manager, ilk, address(this));\n', '        lockGemAndDraw(manager, jug, gemJoin, daiJoin, cdp, amtC, wadD, transferFrom);\n', '    }\n', '\n', '    function openLockGNTAndDraw(\n', '        address manager,\n', '        address jug,\n', '        address gntJoin,\n', '        address daiJoin,\n', '        bytes32 ilk,\n', '        uint amtC,\n', '        uint wadD\n', '    ) public returns (address bag, uint cdp) {\n', "        // Creates bag (if doesn't exist) to hold GNT\n", '        bag = GNTJoinLike(gntJoin).bags(address(this));\n', '        if (bag == address(0)) {\n', '            bag = makeGemBag(gntJoin);\n', '        }\n', '        // Transfer funds to the funds which previously were sent to the proxy\n', '        GemLike(GemJoinLike(gntJoin).gem()).transfer(bag, amtC);\n', '        cdp = openLockGemAndDraw(manager, jug, gntJoin, daiJoin, ilk, amtC, wadD, false);\n', '    }\n', '\n', '    function wipeAndFreeETH(\n', '        address manager,\n', '        address ethJoin,\n', '        address daiJoin,\n', '        uint cdp,\n', '        uint wadC,\n', '        uint wadD\n', '    ) public {\n', '        address urn = ManagerLike(manager).urns(cdp);\n', '        // Joins DAI amount into the vat\n', '        daiJoin_join(daiJoin, urn, wadD);\n', '        // Paybacks debt to the CDP and unlocks WETH amount from it\n', '        frob(\n', '            manager,\n', '            cdp,\n', '            -toInt(wadC),\n', '            _getWipeDart(ManagerLike(manager).vat(), VatLike(ManagerLike(manager).vat()).dai(urn), urn, ManagerLike(manager).ilks(cdp))\n', '        );\n', "        // Moves the amount from the CDP urn to proxy's address\n", '        flux(manager, cdp, address(this), wadC);\n', '        // Exits WETH amount to proxy address as a token\n', '        GemJoinLike(ethJoin).exit(address(this), wadC);\n', '        // Converts WETH to ETH\n', '        GemJoinLike(ethJoin).gem().withdraw(wadC);\n', "        // Sends ETH back to the user's wallet\n", '        msg.sender.transfer(wadC);\n', '    }\n', '\n', '    function wipeAllAndFreeETH(\n', '        address manager,\n', '        address ethJoin,\n', '        address daiJoin,\n', '        uint cdp,\n', '        uint wadC\n', '    ) public {\n', '        address vat = ManagerLike(manager).vat();\n', '        address urn = ManagerLike(manager).urns(cdp);\n', '        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n', '        (, uint art) = VatLike(vat).urns(ilk, urn);\n', '\n', '        // Joins DAI amount into the vat\n', '        daiJoin_join(daiJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\n', '        // Paybacks debt to the CDP and unlocks WETH amount from it\n', '        frob(\n', '            manager,\n', '            cdp,\n', '            -toInt(wadC),\n', '            -int(art)\n', '        );\n', "        // Moves the amount from the CDP urn to proxy's address\n", '        flux(manager, cdp, address(this), wadC);\n', '        // Exits WETH amount to proxy address as a token\n', '        GemJoinLike(ethJoin).exit(address(this), wadC);\n', '        // Converts WETH to ETH\n', '        GemJoinLike(ethJoin).gem().withdraw(wadC);\n', "        // Sends ETH back to the user's wallet\n", '        msg.sender.transfer(wadC);\n', '    }\n', '\n', '    function wipeAndFreeGem(\n', '        address manager,\n', '        address gemJoin,\n', '        address daiJoin,\n', '        uint cdp,\n', '        uint amtC,\n', '        uint wadD\n', '    ) public {\n', '        address urn = ManagerLike(manager).urns(cdp);\n', '        // Joins DAI amount into the vat\n', '        daiJoin_join(daiJoin, urn, wadD);\n', '        uint wadC = convertTo18(gemJoin, amtC);\n', '        // Paybacks debt to the CDP and unlocks token amount from it\n', '        frob(\n', '            manager,\n', '            cdp,\n', '            -toInt(wadC),\n', '            _getWipeDart(ManagerLike(manager).vat(), VatLike(ManagerLike(manager).vat()).dai(urn), urn, ManagerLike(manager).ilks(cdp))\n', '        );\n', "        // Moves the amount from the CDP urn to proxy's address\n", '        flux(manager, cdp, address(this), wadC);\n', "        // Exits token amount to the user's wallet as a token\n", '        GemJoinLike(gemJoin).exit(msg.sender, amtC);\n', '    }\n', '\n', '    function wipeAllAndFreeGem(\n', '        address manager,\n', '        address gemJoin,\n', '        address daiJoin,\n', '        uint cdp,\n', '        uint amtC\n', '    ) public {\n', '        address vat = ManagerLike(manager).vat();\n', '        address urn = ManagerLike(manager).urns(cdp);\n', '        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n', '        (, uint art) = VatLike(vat).urns(ilk, urn);\n', '\n', '        // Joins DAI amount into the vat\n', '        daiJoin_join(daiJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\n', '        uint wadC = convertTo18(gemJoin, amtC);\n', '        // Paybacks debt to the CDP and unlocks token amount from it\n', '        frob(\n', '            manager,\n', '            cdp,\n', '            -toInt(wadC),\n', '            -int(art)\n', '        );\n', "        // Moves the amount from the CDP urn to proxy's address\n", '        flux(manager, cdp, address(this), wadC);\n', "        // Exits token amount to the user's wallet as a token\n", '        GemJoinLike(gemJoin).exit(msg.sender, amtC);\n', '    }\n', '}\n', '\n', 'contract DssProxyActionsEnd is Common {\n', '    // Internal functions\n', '\n', '    function _free(\n', '        address manager,\n', '        address end,\n', '        uint cdp\n', '    ) internal returns (uint ink) {\n', '        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n', '        address urn = ManagerLike(manager).urns(cdp);\n', '        VatLike vat = VatLike(ManagerLike(manager).vat());\n', '        uint art;\n', '        (ink, art) = vat.urns(ilk, urn);\n', '\n', '        // If CDP still has debt, it needs to be paid\n', '        if (art > 0) {\n', '            EndLike(end).skim(ilk, urn);\n', '            (ink,) = vat.urns(ilk, urn);\n', '        }\n', "        // Approves the manager to transfer the position to proxy's address in the vat\n", '        if (vat.can(address(this), address(manager)) == 0) {\n', '            vat.hope(manager);\n', '        }\n', '        // Transfers position from CDP to the proxy address\n', '        ManagerLike(manager).quit(cdp, address(this));\n', '        // Frees the position and recovers the collateral in the vat registry\n', '        EndLike(end).free(ilk);\n', '    }\n', '\n', '    // Public functions\n', '    function freeETH(\n', '        address manager,\n', '        address ethJoin,\n', '        address end,\n', '        uint cdp\n', '    ) public {\n', '        uint wad = _free(manager, end, cdp);\n', '        // Exits WETH amount to proxy address as a token\n', '        GemJoinLike(ethJoin).exit(address(this), wad);\n', '        // Converts WETH to ETH\n', '        GemJoinLike(ethJoin).gem().withdraw(wad);\n', "        // Sends ETH back to the user's wallet\n", '        msg.sender.transfer(wad);\n', '    }\n', '\n', '    function freeGem(\n', '        address manager,\n', '        address gemJoin,\n', '        address end,\n', '        uint cdp\n', '    ) public {\n', '        uint amt = _free(manager, end, cdp) / 10 ** (18 - GemJoinLike(gemJoin).dec());\n', "        // Exits token amount to the user's wallet as a token\n", '        GemJoinLike(gemJoin).exit(msg.sender, amt);\n', '    }\n', '\n', '    function pack(\n', '        address daiJoin,\n', '        address end,\n', '        uint wad\n', '    ) public {\n', '        daiJoin_join(daiJoin, address(this), wad);\n', '        VatLike vat = DaiJoinLike(daiJoin).vat();\n', "        // Approves the end to take out DAI from the proxy's balance in the vat\n", '        if (vat.can(address(this), address(end)) == 0) {\n', '            vat.hope(end);\n', '        }\n', '        EndLike(end).pack(wad);\n', '    }\n', '\n', '    function cashETH(\n', '        address ethJoin,\n', '        address end,\n', '        bytes32 ilk,\n', '        uint wad\n', '    ) public {\n', '        EndLike(end).cash(ilk, wad);\n', '        uint wadC = mul(wad, EndLike(end).fix(ilk)) / RAY;\n', '        // Exits WETH amount to proxy address as a token\n', '        GemJoinLike(ethJoin).exit(address(this), wadC);\n', '        // Converts WETH to ETH\n', '        GemJoinLike(ethJoin).gem().withdraw(wadC);\n', "        // Sends ETH back to the user's wallet\n", '        msg.sender.transfer(wadC);\n', '    }\n', '\n', '    function cashGem(\n', '        address gemJoin,\n', '        address end,\n', '        bytes32 ilk,\n', '        uint wad\n', '    ) public {\n', '        EndLike(end).cash(ilk, wad);\n', "        // Exits token amount to the user's wallet as a token\n", '        uint amt = mul(wad, EndLike(end).fix(ilk)) / RAY / 10 ** (18 - GemJoinLike(gemJoin).dec());\n', '        GemJoinLike(gemJoin).exit(msg.sender, amt);\n', '    }\n', '}\n', '\n', 'contract DssProxyActionsDsr is Common {\n', '    function join(\n', '        address daiJoin,\n', '        address pot,\n', '        uint wad\n', '    ) public {\n', '        VatLike vat = DaiJoinLike(daiJoin).vat();\n', '        // Executes drip to get the chi rate updated to rho == now, otherwise join will fail\n', '        uint chi = PotLike(pot).drip();\n', '        // Joins wad amount to the vat balance\n', '        daiJoin_join(daiJoin, address(this), wad);\n', "        // Approves the pot to take out DAI from the proxy's balance in the vat\n", '        if (vat.can(address(this), address(pot)) == 0) {\n', '            vat.hope(pot);\n', '        }\n', '        // Joins the pie value (equivalent to the DAI wad amount) in the pot\n', '        PotLike(pot).join(mul(wad, RAY) / chi);\n', '    }\n', '\n', '    function exit(\n', '        address daiJoin,\n', '        address pot,\n', '        uint wad\n', '    ) public {\n', '        VatLike vat = DaiJoinLike(daiJoin).vat();\n', '        // Executes drip to count the savings accumulated until this moment\n', '        uint chi = PotLike(pot).drip();\n', '        // Calculates the pie value in the pot equivalent to the DAI wad amount\n', '        uint pie = mul(wad, RAY) / chi;\n', '        // Exits DAI from the pot\n', '        PotLike(pot).exit(pie);\n', '        // Checks the actual balance of DAI in the vat after the pot exit\n', '        uint bal = DaiJoinLike(daiJoin).vat().dai(address(this));\n', "        // Allows adapter to access to proxy's DAI balance in the vat\n", '        if (vat.can(address(this), address(daiJoin)) == 0) {\n', '            vat.hope(daiJoin);\n', '        }\n', '        // It is necessary to check if due rounding the exact wad amount can be exited by the adapter.\n', '        // Otherwise it will do the maximum DAI balance in the vat\n', '        DaiJoinLike(daiJoin).exit(\n', '            msg.sender,\n', '            bal >= mul(wad, RAY) ? wad : bal / RAY\n', '        );\n', '    }\n', '\n', '    function exitAll(\n', '        address daiJoin,\n', '        address pot\n', '    ) public {\n', '        VatLike vat = DaiJoinLike(daiJoin).vat();\n', '        // Executes drip to count the savings accumulated until this moment\n', '        uint chi = PotLike(pot).drip();\n', '        // Gets the total pie belonging to the proxy address\n', '        uint pie = PotLike(pot).pie(address(this));\n', '        // Exits DAI from the pot\n', '        PotLike(pot).exit(pie);\n', "        // Allows adapter to access to proxy's DAI balance in the vat\n", '        if (vat.can(address(this), address(daiJoin)) == 0) {\n', '            vat.hope(daiJoin);\n', '        }\n', '        // Exits the DAI amount corresponding to the value of pie\n', '        DaiJoinLike(daiJoin).exit(msg.sender, mul(chi, pie) / RAY);\n', '    }\n', '}\n', '\n', 'contract BManagerLike is ManagerLike {\n', '    function cushion(uint cdp) public returns(uint);\n', '}\n', '\n', 'contract BProxyActions is DssProxyActions {\n', '    function shiftManager(\n', '        address managerSrc,\n', '        address managerDst,\n', '        uint cdpSrc,\n', '        uint cdpDst\n', '    ) public {\n', '        address vat = ManagerLike(managerSrc).vat();\n', '        require(vat == ManagerLike(managerDst).vat(), "vat-mismatch");\n', '\n', '        bool canSrc = (VatLike(vat).can(address(this), managerSrc) != 0);\n', '        bool canDst = (VatLike(vat).can(address(this), managerDst) != 0);\n', '\n', '        if(! canSrc) hope(vat, managerSrc);\n', '        if(! canDst) hope(vat, managerDst);\n', '\n', '        quit(managerSrc, cdpSrc, address(this));\n', '        enter(managerDst, address(this), cdpDst);\n', '\n', '        if(! canSrc) nope(vat, managerSrc);\n', '        if(! canDst) nope(vat, managerDst);\n', '    }\n', '\n', '    function lockETHViaCdp(\n', '        address manager,\n', '        address ethJoin,\n', '        uint cdp\n', '    ) public payable {\n', '        address urn = ManagerLike(manager).urns(cdp);\n', '\n', '        // Receives ETH amount, converts it to WETH and joins it into the vat\n', '        ethJoin_join(ethJoin, urn);\n', '        // Locks WETH amount into the CDP and generates debt\n', '        frob(manager, cdp, toInt(msg.value), 0);\n', '    }\n', '\n', '    function openLockETHAndGiveToProxy(\n', '        address proxyRegistry,\n', '        address manager,\n', '        address ethJoin,\n', '        bytes32 ilk,\n', '        address dst\n', '    ) public payable returns (uint cdp) {\n', '        cdp = open(manager, ilk, address(this));\n', '        lockETHViaCdp(manager,ethJoin,cdp);\n', '        giveToProxy(proxyRegistry,manager,cdp,dst);\n', '    }\n', '\n', '    function openAndImportFromManager(\n', '        address managerSrc,\n', '        address managerDst,\n', '        uint cdpSrc,\n', '        bytes32 ilk\n', '    ) public payable returns (uint cdp) {\n', '        cdp = open(managerDst, ilk, address(this));\n', '        shiftManager(managerSrc,managerDst,cdpSrc,cdp);\n', '    }\n', '\n', '    function beforeWipeAll(address manager, uint cdp) internal {\n', '        if(BManagerLike(manager).cushion(cdp) > 0) ManagerLike(manager).frob(cdp,0,0);\n', '    }\n', '\n', '    function wipeAll(\n', '        address manager,\n', '        address daiJoin,\n', '        uint cdp\n', '    ) public {\n', '        beforeWipeAll(manager, cdp);\n', '        super.wipeAll(manager, daiJoin, cdp);\n', '    }\n', '\n', '    function safeWipeAll(\n', '        address manager,\n', '        address daiJoin,\n', '        uint cdp,\n', '        address owner\n', '    ) public {\n', '        beforeWipeAll(manager, cdp);\n', '        super.safeWipeAll(manager, daiJoin, cdp, owner);\n', '    }\n', '\n', '    function wipeAllAndFreeETH(\n', '        address manager,\n', '        address ethJoin,\n', '        address daiJoin,\n', '        uint cdp,\n', '        uint wadC\n', '    ) public {\n', '        beforeWipeAll(manager, cdp);\n', '        super.wipeAllAndFreeETH(manager, ethJoin, daiJoin, cdp, wadC);\n', '    }\n', '\n', '    function wipeAllAndFreeGem(\n', '        address manager,\n', '        address gemJoin,\n', '        address daiJoin,\n', '        uint cdp,\n', '        uint amtC\n', '    ) public {\n', '        beforeWipeAll(manager, cdp);\n', '        super.wipeAllAndFreeGem(manager, gemJoin, daiJoin, cdp, amtC);\n', '    }\n', '}']