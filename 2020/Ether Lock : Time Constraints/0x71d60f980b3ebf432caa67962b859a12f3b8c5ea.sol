['// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/SafeMath96.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath96 {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint96 a, uint256 b) internal pure returns (uint96) {\n', '        require(uint256(uint96(b)) == b, "SafeMath: addition overflow");\n', '        uint96 c = a + uint96(b);\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint96 a, uint256 b) internal pure returns (uint96) {\n', '        require(uint256(uint96(b)) == b, "SafeMath: subtraction overflow");\n', '        return sub(a, uint96(b), "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n', '        require(b <= a, errorMessage);\n', '        uint96 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/Math.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/spec_interfaces/ICommittee.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title Committee contract interface\n', 'interface ICommittee {\n', '\tevent CommitteeChange(address indexed addr, uint256 weight, bool certification, bool inCommittee);\n', '\tevent CommitteeSnapshot(address[] addrs, uint256[] weights, bool[] certification);\n', '\n', '\t// No external functions\n', '\n', '\t/*\n', '     * External functions\n', '     */\n', '\n', '\t/// Notifies a weight change of a member\n', '\t/// @dev Called only by: Elections contract\n', '\t/// @param addr is the committee member address\n', '\t/// @param weight is the updated weight of the committee member\n', '\tfunction memberWeightChange(address addr, uint256 weight) external /* onlyElectionsContract onlyWhenActive */;\n', '\n', '\t/// Notifies a change in the certification of a member\n', '\t/// @dev Called only by: Elections contract\n', '\t/// @param addr is the committee member address\n', '\t/// @param isCertified is the updated certification state of the member\n', '\tfunction memberCertificationChange(address addr, bool isCertified) external /* onlyElectionsContract onlyWhenActive */;\n', '\n', '\t/// Notifies a member removal for example due to voteOut / voteUnready\n', '\t/// @dev Called only by: Elections contract\n', '\t/// @param memberRemoved is the removed committee member address\n', '\t/// @return memberRemoved indicates whether the member was removed from the committee\n', '\t/// @return removedMemberWeight indicates the removed member weight\n', '\t/// @return removedMemberCertified indicates whether the member was in the certified committee\n', '\tfunction removeMember(address addr) external returns (bool memberRemoved, uint removedMemberWeight, bool removedMemberCertified)/* onlyElectionContract */;\n', '\n', '\t/// Notifies a new member applicable for committee (due to registration, unbanning, certification change)\n', '\t/// The new member will be added only if it is qualified to join the committee \n', '\t/// @dev Called only by: Elections contract\n', '\t/// @param addr is the added committee member address\n', '\t/// @return memberAdded bool indicates whether the member was addded\n', '\tfunction addMember(address addr, uint256 weight, bool isCertified) external returns (bool memberAdded)  /* onlyElectionsContract */;\n', '\n', '\t/// Checks if addMember() would add a the member to the committee (qualified to join)\n', '\t/// @param addr is the candidate committee member address\n', '\t/// @param weight is the candidate committee member weight\n', '\t/// @return wouldAddMember bool indicates whether the member will be addded\n', '\tfunction checkAddMember(address addr, uint256 weight) external view returns (bool wouldAddMember);\n', '\n', '\t/// Returns the committee members and their weights\n', '\t/// @return addrs is the committee members list\n', '\t/// @return weights is an array of uint, indicating committee members list weight\n', '\t/// @return certification is an array of bool, indicating the committee members certification status\n', '\tfunction getCommittee() external view returns (address[] memory addrs, uint256[] memory weights, bool[] memory certification);\n', '\n', '\t/// Returns the currently appointed committee data\n', '\t/// @return generalCommitteeSize is the number of members in the committee\n', '\t/// @return certifiedCommitteeSize is the number of certified members in the committee\n', '\t/// @return totalWeight is the total effective stake / weight of the committee\n', '\tfunction getCommitteeStats() external view returns (uint generalCommitteeSize, uint certifiedCommitteeSize, uint totalWeight);\n', '\n', '\t/// Returns a committee member data\n', '\t/// @param addr is the committee member address\n', '\t/// @return inCommittee indicates whether the queried address is a member in the committee\n', '\t/// @return weight is the committee member weight\n', '\t/// @return isCertified indicates whether the committee member is certified\n', '\t/// @return totalCommitteeWeight is the total weight of the committee.\n', '\tfunction getMemberInfo(address addr) external view returns (bool inCommittee, uint weight, bool isCertified, uint totalCommitteeWeight);\n', '\n', '\t/// Emits a CommitteeSnapshot events with current committee info\n', '\t/// @dev a CommitteeSnapshot is useful on contracts migration or to remove the need to track past events.\n', '\tfunction emitCommitteeSnapshot() external;\n', '\n', '\t/*\n', '\t * Governance functions\n', '\t */\n', '\n', '\tevent MaxCommitteeSizeChanged(uint8 newValue, uint8 oldValue);\n', '\n', '\t/// Sets the maximum number of committee members\n', '\t/// @dev governance function called only by the functional manager\n', '\t/// @dev when reducing the number of members, the bottom ones are removed from the committee\n', '\t/// @param maxCommitteeSize is the maximum number of committee members \n', '\tfunction setMaxCommitteeSize(uint8 maxCommitteeSize) external /* onlyFunctionalManager onlyWhenActive */;\n', '\n', '\t/// Returns the maximum number of committee members\n', '\t/// @return maxCommitteeSize is the maximum number of committee members \n', '\tfunction getMaxCommitteeSize() external view returns (uint8);\n', '\t\n', '\t/// Imports the committee members from a previous committee contract during migration\n', '\t/// @dev initialization function called only by the initializationManager\n', '\t/// @dev does not update the reward contract to avoid incorrect notifications \n', '\t/// @param previousCommitteeContract is the address of the previous committee contract\n', '\tfunction importMembers(ICommittee previousCommitteeContract) external /* onlyInitializationAdmin */;\n', '}\n', '\n', '// File: contracts/spec_interfaces/IProtocolWallet.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/// @title Protocol Wallet interface\n', 'interface IProtocolWallet {\n', '    event FundsAddedToPool(uint256 added, uint256 total);\n', '\n', '    /*\n', '    * External functions\n', '    */\n', '\n', '    /// Returns the address of the underlying staked token\n', '    /// @return balance is the wallet balance\n', '    function getBalance() external view returns (uint256 balance);\n', '\n', '    /// Transfers the given amount of orbs tokens form the sender to this contract an updates the pool\n', '    /// @dev assumes the caller approved the amount prior to calling\n', '    /// @param amount is the amount to add to the wallet\n', '    function topUp(uint256 amount) external;\n', '\n', "    /// Withdraws from pool to the client address, limited by the pool's MaxRate.\n", '    /// @dev may only be called by the wallet client\n', '    /// @dev no more than MaxRate x time period since the last withdraw may be withdrawn\n', "    /// @dev allocation that wasn't withdrawn can not be withdrawn in the next call\n", '    /// @param amount is the amount to withdraw\n', '    function withdraw(uint256 amount) external; /* onlyClient */\n', '\n', '\n', '    /*\n', '    * Governance functions\n', '    */\n', '\n', '    event ClientSet(address client);\n', '    event MaxAnnualRateSet(uint256 maxAnnualRate);\n', '    event EmergencyWithdrawal(address addr, address token);\n', '    event OutstandingTokensReset(uint256 startTime);\n', '\n', '    /// Sets a new annual withdraw rate for the pool\n', '\t/// @dev governance function called only by the migration owner\n', '    /// @dev the rate for a duration is duration x annualRate / 1 year \n', '    /// @param annualRate is the maximum annual rate that can be withdrawn\n', '    function setMaxAnnualRate(uint256 annualRate) external; /* onlyMigrationOwner */\n', '\n', '    /// Returns the annual withdraw rate of the pool\n', '    /// @return annualRate is the maximum annual rate that can be withdrawn\n', '    function getMaxAnnualRate() external view returns (uint256);\n', '\n', '    /// Emergency withdraw the wallet funds\n', '\t/// @dev governance function called only by the migration owner\n', '    /// @dev used in emergencies, when a migration to a new wallet is needed\n', '    /// @param token is the erc20 address of the token to withdraw\n', '    function emergencyWithdraw(address token) external; /* onlyMigrationOwner */\n', '\n', '    /// Sets the address of the client that can withdraw funds\n', '\t/// @dev governance function called only by the functional owner\n', '    /// @param client is the address of the new client\n', '    function setClient(address client) external; /* onlyFunctionalOwner */\n', '\n', '    /// Resets the outstanding tokens to new start time\n', '\t/// @dev governance function called only by the migration owner\n', '    /// @dev the next duration will be calculated starting from the given time\n', '    /// @param startTime is the time to set as the last withdrawal time\n', '    function resetOutstandingTokens(uint256 startTime) external; /* onlyMigrationOwner */\n', '\n', '}\n', '\n', '// File: contracts/spec_interfaces/IStakingRewards.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title Staking rewards contract interface\n', 'interface IStakingRewards {\n', '\n', '    event DelegatorStakingRewardsAssigned(address indexed delegator, uint256 amount, uint256 totalAwarded, address guardian, uint256 delegatorRewardsPerToken, uint256 delegatorRewardsPerTokenDelta);\n', '    event GuardianStakingRewardsAssigned(address indexed guardian, uint256 amount, uint256 totalAwarded, uint256 delegatorRewardsPerToken, uint256 delegatorRewardsPerTokenDelta, uint256 stakingRewardsPerWeight, uint256 stakingRewardsPerWeightDelta);\n', '    event StakingRewardsClaimed(address indexed addr, uint256 claimedDelegatorRewards, uint256 claimedGuardianRewards, uint256 totalClaimedDelegatorRewards, uint256 totalClaimedGuardianRewards);\n', '    event StakingRewardsAllocated(uint256 allocatedRewards, uint256 stakingRewardsPerWeight);\n', '    event GuardianDelegatorsStakingRewardsPercentMilleUpdated(address indexed guardian, uint256 delegatorsStakingRewardsPercentMille);\n', '\n', '    /*\n', '     * External functions\n', '     */\n', '\n', '    /// Returns the currently reward balance of the given address.\n', '    /// @dev calculates the up to date balances (differ from the state)\n', '    /// @param addr is the address to query\n', '    /// @return delegatorStakingRewardsBalance the rewards awarded to the guardian role\n', '    /// @return guardianStakingRewardsBalance the rewards awarded to the guardian role\n', '    function getStakingRewardsBalance(address addr) external view returns (uint256 delegatorStakingRewardsBalance, uint256 guardianStakingRewardsBalance);\n', '\n', "    /// Sets ths guardian's delegators staking reward portion\n", '    /// @dev by default uses the defaultDelegatorsStakingRewardsPercentMille\n', '    /// @param delegatorRewardsPercentMille is the delegators portion in percent-mille (0 - maxDelegatorsStakingRewardsPercentMille)\n', '    function setGuardianDelegatorsStakingRewardsPercentMille(uint32 delegatorRewardsPercentMille) external;\n', '\n', "    /// Returns a guardian's delegators staking reward portion\n", '    /// @dev If not explicitly set, returns the defaultDelegatorsStakingRewardsPercentMille\n', '    /// @return delegatorRewardsRatioPercentMille is the delegators portion in percent-mille\n', '    function getGuardianDelegatorsStakingRewardsPercentMille(address guardian) external view returns (uint256 delegatorRewardsRatioPercentMille);\n', '\n', '    /// Claims the staking rewards balance of an addr, staking the rewards\n', '    /// @dev Claimed rewards are staked in the staking contract using the distributeRewards interface\n', '    /// @dev includes the rewards for both the delegator and guardian roles\n', '    /// @dev calculates the up to date rewards prior to distribute them to the staking contract\n', '    /// @param addr is the address to claim rewards for\n', '    function claimStakingRewards(address addr) external;\n', '\n', '    /// Returns the amount of ORBS tokens in the staking rewards wallet allocated to staking rewards\n', '    /// @dev The staking wallet balance must always larger than the allocated value\n', '    /// @return allocated is the amount of tokens allocated in the staking rewards wallet\n', '    function getStakingRewardsWalletAllocatedTokens() external view returns (uint256 allocated);\n', '\n', '    /// Returns the current guardian staking rewards state\n', '    /// @dev calculated to the latest block, may differ from the state read\n', '    /// @dev notice that the guardian rewards are the rewards for the guardian role as guardian and do not include delegation rewards\n', "    /// @dev use getDelegatorStakingRewardsData to get the guardian's rewards as delegator\n", '    /// @param guardian is the guardian to query\n', '    /// @return balance is the staking rewards balance for the guardian role\n', '    /// @return claimed is the staking rewards for the guardian role that were claimed\n', "    /// @return delegatorRewardsPerToken is the potential reward per token (1E18 units) assigned to a guardian's delegator that delegated from day zero\n", '    /// @return delegatorRewardsPerTokenDelta is the increment in delegatorRewardsPerToken since the last guardian update\n', '    /// @return lastStakingRewardsPerWeight is the up to date stakingRewardsPerWeight used for the guardian state calculation\n', '    /// @return stakingRewardsPerWeightDelta is the increment in stakingRewardsPerWeight since the last guardian update\n', '    function getGuardianStakingRewardsData(address guardian) external view returns (\n', '        uint256 balance,\n', '        uint256 claimed,\n', '        uint256 delegatorRewardsPerToken,\n', '        uint256 delegatorRewardsPerTokenDelta,\n', '        uint256 lastStakingRewardsPerWeight,\n', '        uint256 stakingRewardsPerWeightDelta\n', '    );\n', '\n', '    /// Returns the current delegator staking rewards state\n', '    /// @dev calculated to the latest block, may differ from the state read\n', '    /// @param delegator is the delegator to query\n', '    /// @return balance is the staking rewards balance for the delegator role\n', '    /// @return claimed is the staking rewards for the delegator role that were claimed\n', '    /// @return guardian is the guardian the delegator delegated to receiving a portion of the guardian staking rewards\n', '    /// @return lastDelegatorRewardsPerToken is the up to date delegatorRewardsPerToken used for the delegator state calculation\n', '    /// @return delegatorRewardsPerTokenDelta is the increment in delegatorRewardsPerToken since the last delegator update\n', '    function getDelegatorStakingRewardsData(address delegator) external view returns (\n', '        uint256 balance,\n', '        uint256 claimed,\n', '        address guardian,\n', '        uint256 lastDelegatorRewardsPerToken,\n', '        uint256 delegatorRewardsPerTokenDelta\n', '    );\n', '\n', '    /// Returns an estimation for the delegator and guardian staking rewards for a given duration\n', '    /// @dev the returned value is an estimation, assuming no change in the PoS state\n', '    /// @dev the period calculated for start from the current block time until the current time + duration.\n', '    /// @param addr is the address to estimate rewards for\n', '    /// @param duration is the duration to calculate for in seconds\n', '    /// @return estimatedDelegatorStakingRewards is the estimated reward for the delegator role\n', '    /// @return estimatedGuardianStakingRewards is the estimated reward for the guardian role\n', '    function estimateFutureRewards(address addr, uint256 duration) external view returns (\n', '        uint256 estimatedDelegatorStakingRewards,\n', '        uint256 estimatedGuardianStakingRewards\n', '    );\n', '\n', '    /// Returns the current global staking rewards state\n', '    /// @dev calculated to the latest block, may differ from the state read\n', '    /// @return stakingRewardsPerWeight is the potential reward per 1E18 (TOKEN_BASE) committee weight assigned to a guardian was in the committee from day zero\n', '    /// @return unclaimedStakingRewards is the of tokens that were assigned to participants and not claimed yet\n', '    function getStakingRewardsState() external view returns (\n', '        uint96 stakingRewardsPerWeight,\n', '        uint96 unclaimedStakingRewards\n', '    );\n', '\n', '    /// Returns the current annual staking reward rate\n', '    /// @dev calculated based on the current total committee weight\n', '    /// @return annualRate is the current staking reward rate in percent-mille\n', '    function getCurrentStakingRewardsRatePercentMille() external view returns (uint256 annualRate);\n', '\n', '    /// Notifies an expected change in the committee membership of the guardian\n', '    /// @dev Called only by: the Committee contract\n', '    /// @dev called upon expected change in the committee membership of the guardian\n', '    /// @dev triggers update of the global rewards state and the guardian rewards state\n', '    /// @dev updates the rewards state based on the committee state prior to the change\n', "    /// @param guardian is the guardian who's committee membership is updated\n", '    /// @param weight is the weight of the guardian prior to the change\n', '    /// @param totalCommitteeWeight is the total committee weight prior to the change\n', '    /// @param inCommittee indicates whether the guardian was in the committee prior to the change\n', '    /// @param inCommitteeAfter indicates whether the guardian is in the committee after the change\n', '    function committeeMembershipWillChange(address guardian, uint256 weight, uint256 totalCommitteeWeight, bool inCommittee, bool inCommitteeAfter) external /* onlyCommitteeContract */;\n', '\n', '    /// Notifies an expected change in a delegator and his guardian delegation state\n', '    /// @dev Called only by: the Delegation contract\n', "    /// @dev called upon expected change in a delegator's delegation state\n", '    /// @dev triggers update of the global rewards state, the guardian rewards state and the delegator rewards state\n', "    /// @dev on delegation change, updates also the new guardian and the delegator's lastDelegatorRewardsPerToken accordingly\n", "    /// @param guardian is the delegator's guardian prior to the change\n", "    /// @param delegatedStake is the delegated stake of the delegator's guardian prior to the change\n", '    /// @param delegator is the delegator about to change delegation state\n', '    /// @param delegatorStake is the stake of the delegator\n', "    /// @param nextGuardian is the delegator's guardian after to the change\n", "    /// @param nextGuardianDelegatedStake is the delegated stake of the delegator's guardian after to the change\n", '    function delegationWillChange(address guardian, uint256 delegatedStake, address delegator, uint256 delegatorStake, address nextGuardian, uint256 nextGuardianDelegatedStake) external /* onlyDelegationsContract */;\n', '\n', '    /*\n', '     * Governance functions\n', '     */\n', '\n', '    event AnnualStakingRewardsRateChanged(uint256 annualRateInPercentMille, uint256 annualCap);\n', '    event DefaultDelegatorsStakingRewardsChanged(uint32 defaultDelegatorsStakingRewardsPercentMille);\n', '    event MaxDelegatorsStakingRewardsChanged(uint32 maxDelegatorsStakingRewardsPercentMille);\n', '    event RewardDistributionActivated(uint256 startTime);\n', '    event RewardDistributionDeactivated();\n', '    event StakingRewardsBalanceMigrated(address indexed addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards, address toRewardsContract);\n', '    event StakingRewardsBalanceMigrationAccepted(address from, address indexed addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards);\n', '    event EmergencyWithdrawal(address addr, address token);\n', '\n', '    /// Deactivates fees and bootstrap allocation\n', '    /// @dev governance function called only by the migration manager\n', '    /// @dev guardians updates remain active based on the current perMember value\n', '    function deactivateRewardDistribution() external /* onlyMigrationManager */;\n', '\n', '    /// Activates staking rewards allocation\n', '    /// @dev governance function called only by the initialization manager\n', '    /// @dev On migrations, startTime should be set as the previous contract deactivation time.\n', '    /// @param startTime sets the last assignment time\n', '    function activateRewardDistribution(uint startTime) external /* onlyInitializationAdmin */;\n', '\n', '    /// Sets the default delegators staking reward portion\n', '    /// @dev governance function called only by the functional manager\n', '    /// @param defaultDelegatorsStakingRewardsPercentMille is the default delegators portion in percent-mille(0 - maxDelegatorsStakingRewardsPercentMille)\n', '    function setDefaultDelegatorsStakingRewardsPercentMille(uint32 defaultDelegatorsStakingRewardsPercentMille) external /* onlyFunctionalManager */;\n', '\n', '    /// Returns the default delegators staking reward portion\n', '    /// @return defaultDelegatorsStakingRewardsPercentMille is the default delegators portion in percent-mille\n', '    function getDefaultDelegatorsStakingRewardsPercentMille() external view returns (uint32);\n', '\n', '    /// Sets the maximum delegators staking reward portion\n', '    /// @dev governance function called only by the functional manager\n', '    /// @param maxDelegatorsStakingRewardsPercentMille is the maximum delegators portion in percent-mille(0 - 100,000)\n', '    function setMaxDelegatorsStakingRewardsPercentMille(uint32 maxDelegatorsStakingRewardsPercentMille) external /* onlyFunctionalManager */;\n', '\n', '    /// Returns the default delegators staking reward portion\n', '    /// @return maxDelegatorsStakingRewardsPercentMille is the maximum delegators portion in percent-mille\n', '    function getMaxDelegatorsStakingRewardsPercentMille() external view returns (uint32);\n', '\n', '    /// Sets the annual rate and cap for the staking reward\n', '    /// @dev governance function called only by the functional manager\n', '    /// @param annualRateInPercentMille is the annual rate in percent-mille\n', '    /// @param annualCap is the annual staking rewards cap\n', '    function setAnnualStakingRewardsRate(uint32 annualRateInPercentMille, uint96 annualCap) external /* onlyFunctionalManager */;\n', '\n', '    /// Returns the annual staking reward rate\n', '    /// @return annualStakingRewardsRatePercentMille is the annual rate in percent-mille\n', '    function getAnnualStakingRewardsRatePercentMille() external view returns (uint32);\n', '\n', '    /// Returns the annual staking rewards cap\n', '    /// @return annualStakingRewardsCap is the annual rate in percent-mille\n', '    function getAnnualStakingRewardsCap() external view returns (uint256);\n', '\n', '    /// Checks if rewards allocation is active\n', '    /// @return rewardAllocationActive is a bool that indicates that rewards allocation is active\n', '    function isRewardAllocationActive() external view returns (bool);\n', '\n', "    /// Returns the contract's settings\n", '    /// @return annualStakingRewardsCap is the annual rate in percent-mille\n', '    /// @return annualStakingRewardsRatePercentMille is the annual rate in percent-mille\n', '    /// @return defaultDelegatorsStakingRewardsPercentMille is the default delegators portion in percent-mille\n', '    /// @return maxDelegatorsStakingRewardsPercentMille is the maximum delegators portion in percent-mille\n', '    /// @return rewardAllocationActive is a bool that indicates that rewards allocation is active\n', '    function getSettings() external view returns (\n', '        uint annualStakingRewardsCap,\n', '        uint32 annualStakingRewardsRatePercentMille,\n', '        uint32 defaultDelegatorsStakingRewardsPercentMille,\n', '        uint32 maxDelegatorsStakingRewardsPercentMille,\n', '        bool rewardAllocationActive\n', '    );\n', '\n', '    /// Migrates the staking rewards balance of a given address to a new staking rewards contract\n', '    /// @dev The new rewards contract is determined according to the contracts registry\n', '    /// @dev No impact of the calling contract if the currently configured contract in the registry\n', '    /// @dev may be called also while the contract is locked\n', '    /// @param addr is the address to migrate\n', '    function migrateRewardsBalance(address addr) external;\n', '\n', '    /// Accepts an address balance migration from a previous rewards contract\n', '    /// @dev the function may be called by any caller that approves the amounts provided for transfer\n', '    /// @param addr is the migrated address\n', '    /// @param guardianStakingRewards is the received guardian rewards balance\n', '    /// @param delegatorStakingRewards is the received delegator rewards balance\n', '    function acceptRewardsBalanceMigration(address addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards) external;\n', '\n', '    /// Performs emergency withdrawal of the contract balance\n', '    /// @dev called with a token to withdraw, should be called twice with the fees and bootstrap tokens\n', '    /// @dev governance function called only by the migration manager\n', '    /// @param token is the ERC20 token to withdraw\n', '    function emergencyWithdraw(address token) external /* onlyMigrationManager */;\n', '}\n', '\n', '// File: contracts/spec_interfaces/IDelegations.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title Delegations contract interface\n', 'interface IDelegations /* is IStakeChangeNotifier */ {\n', '\n', '    // Delegation state change events\n', '\tevent DelegatedStakeChanged(address indexed addr, uint256 selfDelegatedStake, uint256 delegatedStake, address indexed delegator, uint256 delegatorContributedStake);\n', '\n', '    // Function calls\n', '\tevent Delegated(address indexed from, address indexed to);\n', '\n', '\t/*\n', '     * External functions\n', '     */\n', '\n', '\t/// Delegate your stake\n', '\t/// @dev updates the election contract on the changes in the delegated stake\n', "\t/// @dev updates the rewards contract on the upcoming change in the delegator's delegation state\n", '\t/// @param to is the address to delegate to\n', '\tfunction delegate(address to) external /* onlyWhenActive */;\n', '\n', '\t/// Refresh the address stake for delegation power based on the staking contract\n', '\t/// @dev Disabled stake change update notifications from the staking contract may create mismatches\n', '\t/// @dev refreshStake re-syncs the stake data with the staking contract\n', '\t/// @param addr is the address to refresh its stake\n', '\tfunction refreshStake(address addr) external /* onlyWhenActive */;\n', '\n', '\t/// Returns the delegated stake of an addr \n', '\t/// @dev an address that is not self delegating has a 0 delegated stake\n', '\t/// @param addr is the address to query\n', '\t/// @return delegatedStake is the address delegated stake\n', '\tfunction getDelegatedStake(address addr) external view returns (uint256);\n', '\n', '\t/// Returns the delegate address of the given address\n', '\t/// @param addr is the address to query\n', '\t/// @return delegation is the address the addr delegated to\n', '\tfunction getDelegation(address addr) external view returns (address);\n', '\n', '\t/// Returns a delegator info\n', '\t/// @param addr is the address to query\n', '\t/// @return delegation is the address the addr delegated to\n', '\t/// @return delegatorStake is the stake of the delegator as reflected in the delegation contract\n', '\tfunction getDelegationInfo(address addr) external view returns (address delegation, uint256 delegatorStake);\n', '\n', '\t/// Returns the total delegated stake\n', '\t/// @dev delegatedStake - the total stake delegated to an address that is self delegating\n', '\t/// @dev the delegated stake of a non self-delegated address is 0\n', '\t/// @return totalDelegatedStake is the total delegatedStake of all the addresses\n', '\tfunction getTotalDelegatedStake() external view returns (uint256) ;\n', '\n', '\t/*\n', '\t * Governance functions\n', '\t */\n', '\n', '\tevent DelegationsImported(address[] from, address indexed to);\n', '\n', '\tevent DelegationInitialized(address indexed from, address indexed to);\n', '\n', '\t/// Imports delegations during initial migration\n', '\t/// @dev initialization function called only by the initializationManager\n', '\t/// @dev Does not update the Rewards or Election contracts\n', '\t/// @dev assumes deactivated Rewards\n', '\t/// @param from is a list of delegator addresses\n', '\t/// @param to is the address the delegators delegate to\n', '\tfunction importDelegations(address[] calldata from, address to) external /* onlyMigrationManager onlyDuringDelegationImport */;\n', '\n', '\t/// Initializes the delegation of an address during initial migration \n', '\t/// @dev initialization function called only by the initializationManager\n', '\t/// @dev behaves identically to a delegate transaction sent by the delegator\n', '\t/// @param from is the delegator addresses\n', '\t/// @param to is the delegator delegates to\n', '\tfunction initDelegation(address from, address to) external /* onlyInitializationAdmin */;\n', '}\n', '\n', '// File: contracts/IMigratableStakingContract.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/// @title An interface for staking contracts which support stake migration.\n', 'interface IMigratableStakingContract {\n', '    /// @dev Returns the address of the underlying staked token.\n', '    /// @return IERC20 The address of the token.\n', '    function getToken() external view returns (IERC20);\n', '\n', '    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\n', '    /// the required amount using ERC20 approve.\n', '    /// @param _stakeOwner address The specified stake owner.\n', '    /// @param _amount uint256 The number of tokens to stake.\n', '    function acceptMigration(address _stakeOwner, uint256 _amount) external;\n', '\n', '    event AcceptedMigration(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n', '}\n', '\n', '// File: contracts/IStakingContract.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/// @title An interface for staking contracts.\n', 'interface IStakingContract {\n', '    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\n', '    /// the required amount using ERC20 approve.\n', '    /// @param _amount uint256 The amount of tokens to stake.\n', '    function stake(uint256 _amount) external;\n', '\n', '    /// @dev Unstakes ORBS tokens from msg.sender. If successful, this will start the cooldown period, after which\n', '    /// msg.sender would be able to withdraw all of his tokens.\n', '    /// @param _amount uint256 The amount of tokens to unstake.\n', '    function unstake(uint256 _amount) external;\n', '\n', '    /// @dev Requests to withdraw all of staked ORBS tokens back to msg.sender. Stake owners can withdraw their ORBS\n', '    /// tokens only after previously unstaking them and after the cooldown period has passed (unless the contract was\n', '    /// requested to release all stakes).\n', '    function withdraw() external;\n', '\n', '    /// @dev Restakes unstaked ORBS tokens (in or after cooldown) for msg.sender.\n', '    function restake() external;\n', '\n', '    /// @dev Distributes staking rewards to a list of addresses by directly adding rewards to their stakes. This method\n', '    /// assumes that the user has already approved at least the required amount using ERC20 approve. Since this is a\n', "    /// convenience method, we aren't concerned about reaching block gas limit by using large lists. We assume that\n", '    /// callers will be able to properly batch/paginate their requests.\n', '    /// @param _totalAmount uint256 The total amount of rewards to distributes.\n', '    /// @param _stakeOwners address[] The addresses of the stake owners.\n', '    /// @param _amounts uint256[] The amounts of the rewards.\n', '    function distributeRewards(uint256 _totalAmount, address[] calldata _stakeOwners, uint256[] calldata _amounts) external;\n', '\n', '    /// @dev Returns the stake of the specified stake owner (excluding unstaked tokens).\n', '    /// @param _stakeOwner address The address to check.\n', '    /// @return uint256 The total stake.\n', '    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256);\n', '\n', '    /// @dev Returns the total amount staked tokens (excluding unstaked tokens).\n', '    /// @return uint256 The total staked tokens of all stake owners.\n', '    function getTotalStakedTokens() external view returns (uint256);\n', '\n', '    /// @dev Returns the time that the cooldown period ends (or ended) and the amount of tokens to be released.\n', '    /// @param _stakeOwner address The address to check.\n', '    /// @return cooldownAmount uint256 The total tokens in cooldown.\n', '    /// @return cooldownEndTime uint256 The time when the cooldown period ends (in seconds).\n', '    function getUnstakeStatus(address _stakeOwner) external view returns (uint256 cooldownAmount,\n', '        uint256 cooldownEndTime);\n', '\n', '    /// @dev Migrates the stake of msg.sender from this staking contract to a new approved staking contract.\n', '    /// @param _newStakingContract IMigratableStakingContract The new staking contract which supports stake migration.\n', '    /// @param _amount uint256 The amount of tokens to migrate.\n', '    function migrateStakedTokens(IMigratableStakingContract _newStakingContract, uint256 _amount) external;\n', '\n', '    event Staked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n', '    event Unstaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n', '    event Withdrew(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n', '    event Restaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n', '    event MigratedStake(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n', '}\n', '\n', '// File: contracts/spec_interfaces/IContractRegistry.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title Contract registry contract interface\n', '/// The contract registry holds Orbs PoS contracts and managers lists\n', '/// @dev The contract registry updates the managed contracts on changes in the contract list\n', '/// @dev Governance functions restricted to managers access the registry to retrieve the manager address \n', '/// @dev The contract registry represents the source of truth for Orbs Ethereum contracts \n', '/// @dev By tracking the registry events or query before interaction, one can access the up to date contracts \n', 'interface IContractRegistry {\n', '\n', '\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\n', '\tevent ManagerChanged(string role, address newManager);\n', '\tevent ContractRegistryUpdated(address newContractRegistry);\n', '\n', '\t/*\n', '\t* External functions\n', '\t*/\n', '\n', '\t/// Updates the contracts address and emits a corresponding event\n', '\t/// @dev governance function called only by the migrationManager or registryAdmin\n', '\t/// @param contractName is the contract name, used to identify it\n', '\t/// @param addr is the contract updated address\n', '\t/// @param managedContract indicates whether the contract is managed by the registry and notified on changes\n', '\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdminOrMigrationManager */;\n', '\n', '\t/// Returns the current address of the given contracts\n', '\t/// @param contractName is the contract name, used to identify it\n', '\t/// @return addr is the contract updated address\n', '\tfunction getContract(string calldata contractName) external view returns (address);\n', '\n', '\t/// Returns the list of contract addresses managed by the registry\n', '\t/// @dev Managed contracts are updated on changes in the registry contracts addresses \n', '\t/// @return addrs is the list of managed contracts\n', '\tfunction getManagedContracts() external view returns (address[] memory);\n', '\n', '\t/// Updates a manager address and emits a corresponding event\n', '\t/// @dev governance function called only by the registryAdmin\n', "\t/// @dev the managers list is a flexible list of role to the manager's address\n", '\t/// @param role is the managers\' role name, for example "functionalManager"\n', '\t/// @param manager is the manager updated address\n', '\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\n', '\n', '\t/// Returns the current address of the given manager\n', '\t/// @param role is the manager name, used to identify it\n', '\t/// @return addr is the manager updated address\n', '\tfunction getManager(string calldata role) external view returns (address);\n', '\n', '\t/// Locks all the managed contracts \n', '\t/// @dev governance function called only by the migrationManager or registryAdmin\n', '\t/// @dev When set all onlyWhenActive functions will revert\n', '\tfunction lockContracts() external /* onlyAdminOrMigrationManager */;\n', '\n', '\t/// Unlocks all the managed contracts \n', '\t/// @dev governance function called only by the migrationManager or registryAdmin\n', '\tfunction unlockContracts() external /* onlyAdminOrMigrationManager */;\n', '\n', '\t/// Sets a new contract registry to migrate to\n', '\t/// @dev governance function called only by the registryAdmin\n', '\t/// @dev updates the registry address record in all the managed contracts\n', '\t/// @dev by tracking the emitted ContractRegistryUpdated, tools can track the up to date contracts\n', '\t/// @param newRegistry is the new registry contract \n', '\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\n', '\n', '\t/// Returns the previous contract registry address \n', '\t/// @dev used when the setting the contract as a new registry to assure a valid registry\n', '\t/// @return previousContractRegistry is the previous contract registry\n', '\tfunction getPreviousContractRegistry() external view returns (address);\n', '}\n', '\n', '// File: @openzeppelin/contracts/GSN/Context.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: contracts/WithClaimableRegistryManagement.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract WithClaimableRegistryManagement is Context {\n', '    address private _registryAdmin;\n', '    address private _pendingRegistryAdmin;\n', '\n', '    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _registryAdmin = msgSender;\n', '        emit RegistryManagementTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current registryAdmin.\n', '     */\n', '    function registryAdmin() public view returns (address) {\n', '        return _registryAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the registryAdmin.\n', '     */\n', '    modifier onlyRegistryAdmin() {\n', '        require(isRegistryAdmin(), "WithClaimableRegistryManagement: caller is not the registryAdmin");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current registryAdmin.\n', '     */\n', '    function isRegistryAdmin() public view returns (bool) {\n', '        return _msgSender() == _registryAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without registryAdmin. It will not be possible to call\n', '     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\n', '     *\n', '     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\n', '     * thereby removing any functionality that is only available to the registryAdmin.\n', '     */\n', '    function renounceRegistryManagement() public onlyRegistryAdmin {\n', '        emit RegistryManagementTransferred(_registryAdmin, address(0));\n', '        _registryAdmin = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\n', '     */\n', '    function _transferRegistryManagement(address newRegistryAdmin) internal {\n', '        require(newRegistryAdmin != address(0), "RegistryAdmin: new registryAdmin is the zero address");\n', '        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\n', '        _registryAdmin = newRegistryAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier throws if called by any account other than the pendingManager.\n', '     */\n', '    modifier onlyPendingRegistryAdmin() {\n', '        require(msg.sender == _pendingRegistryAdmin, "Caller is not the pending registryAdmin");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev Allows the current registryAdmin to set the pendingManager address.\n', '     * @param newRegistryAdmin The address to transfer registryManagement to.\n', '     */\n', '    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\n', '        _pendingRegistryAdmin = newRegistryAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\n', '     */\n', '    function claimRegistryManagement() external onlyPendingRegistryAdmin {\n', '        _transferRegistryManagement(_pendingRegistryAdmin);\n', '        _pendingRegistryAdmin = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current pendingRegistryAdmin\n', '    */\n', '    function pendingRegistryAdmin() public view returns (address) {\n', '       return _pendingRegistryAdmin;  \n', '    }\n', '}\n', '\n', '// File: contracts/Initializable.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'contract Initializable {\n', '\n', '    address private _initializationAdmin;\n', '\n', '    event InitializationComplete();\n', '\n', '    constructor() public{\n', '        _initializationAdmin = msg.sender;\n', '    }\n', '\n', '    modifier onlyInitializationAdmin() {\n', '        require(msg.sender == initializationAdmin(), "sender is not the initialization admin");\n', '\n', '        _;\n', '    }\n', '\n', '    /*\n', '    * External functions\n', '    */\n', '\n', '    function initializationAdmin() public view returns (address) {\n', '        return _initializationAdmin;\n', '    }\n', '\n', '    function initializationComplete() external onlyInitializationAdmin {\n', '        _initializationAdmin = address(0);\n', '        emit InitializationComplete();\n', '    }\n', '\n', '    function isInitializationComplete() public view returns (bool) {\n', '        return _initializationAdmin == address(0);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/ContractRegistryAccessor.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', 'contract ContractRegistryAccessor is WithClaimableRegistryManagement, Initializable {\n', '\n', '    IContractRegistry private contractRegistry;\n', '\n', '    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {\n', '        require(address(_contractRegistry) != address(0), "_contractRegistry cannot be 0");\n', '        setContractRegistry(_contractRegistry);\n', '        _transferRegistryManagement(_registryAdmin);\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(isAdmin(), "sender is not an admin (registryManger or initializationAdmin)");\n', '\n', '        _;\n', '    }\n', '\n', '    modifier onlyMigrationManager {\n', '        require(isMigrationManager(), "sender is not the migration manager");\n', '\n', '        _;\n', '    }\n', '\n', '    modifier onlyFunctionalManager {\n', '        require(isFunctionalManager(), "sender is not the functional manager");\n', '\n', '        _;\n', '    }\n', '\n', '    function isAdmin() internal view returns (bool) {\n', '        return msg.sender == address(contractRegistry) || msg.sender == registryAdmin() || msg.sender == initializationAdmin();\n', '    }\n', '\n', '    function isManager(string memory role) internal view returns (bool) {\n', '        IContractRegistry _contractRegistry = contractRegistry;\n', '        return isAdmin() || _contractRegistry != IContractRegistry(0) && contractRegistry.getManager(role) == msg.sender;\n', '    }\n', '\n', '    function isMigrationManager() internal view returns (bool) {\n', "        return isManager('migrationManager');\n", '    }\n', '\n', '    function isFunctionalManager() internal view returns (bool) {\n', "        return isManager('functionalManager');\n", '    }\n', '\n', '    function getProtocolContract() internal view returns (address) {\n', '        return contractRegistry.getContract("protocol");\n', '    }\n', '\n', '    function getStakingRewardsContract() internal view returns (address) {\n', '        return contractRegistry.getContract("stakingRewards");\n', '    }\n', '\n', '    function getFeesAndBootstrapRewardsContract() internal view returns (address) {\n', '        return contractRegistry.getContract("feesAndBootstrapRewards");\n', '    }\n', '\n', '    function getCommitteeContract() internal view returns (address) {\n', '        return contractRegistry.getContract("committee");\n', '    }\n', '\n', '    function getElectionsContract() internal view returns (address) {\n', '        return contractRegistry.getContract("elections");\n', '    }\n', '\n', '    function getDelegationsContract() internal view returns (address) {\n', '        return contractRegistry.getContract("delegations");\n', '    }\n', '\n', '    function getGuardiansRegistrationContract() internal view returns (address) {\n', '        return contractRegistry.getContract("guardiansRegistration");\n', '    }\n', '\n', '    function getCertificationContract() internal view returns (address) {\n', '        return contractRegistry.getContract("certification");\n', '    }\n', '\n', '    function getStakingContract() internal view returns (address) {\n', '        return contractRegistry.getContract("staking");\n', '    }\n', '\n', '    function getSubscriptionsContract() internal view returns (address) {\n', '        return contractRegistry.getContract("subscriptions");\n', '    }\n', '\n', '    function getStakingRewardsWallet() internal view returns (address) {\n', '        return contractRegistry.getContract("stakingRewardsWallet");\n', '    }\n', '\n', '    function getBootstrapRewardsWallet() internal view returns (address) {\n', '        return contractRegistry.getContract("bootstrapRewardsWallet");\n', '    }\n', '\n', '    function getGeneralFeesWallet() internal view returns (address) {\n', '        return contractRegistry.getContract("generalFeesWallet");\n', '    }\n', '\n', '    function getCertifiedFeesWallet() internal view returns (address) {\n', '        return contractRegistry.getContract("certifiedFeesWallet");\n', '    }\n', '\n', '    function getStakingContractHandler() internal view returns (address) {\n', '        return contractRegistry.getContract("stakingContractHandler");\n', '    }\n', '\n', '    /*\n', '    * Governance functions\n', '    */\n', '\n', '    event ContractRegistryAddressUpdated(address addr);\n', '\n', '    function setContractRegistry(IContractRegistry newContractRegistry) public onlyAdmin {\n', '        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), "new contract registry must provide the previous contract registry");\n', '        contractRegistry = newContractRegistry;\n', '        emit ContractRegistryAddressUpdated(address(newContractRegistry));\n', '    }\n', '\n', '    function getContractRegistry() public view returns (IContractRegistry) {\n', '        return contractRegistry;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/spec_interfaces/ILockable.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title lockable contract interface, allows to lock a contract\n', 'interface ILockable {\n', '\n', '    event Locked();\n', '    event Unlocked();\n', '\n', '    /// Locks the contract to external non-governance function calls\n', '\t/// @dev governance function called only by the migration manager or an admin\n', '    /// @dev typically called by the registry contract upon locking all managed contracts\n', '    /// @dev getters and migration functions remain active also for locked contracts\n', '    /// @dev checked by the onlyWhenActive modifier\n', '    function lock() external /* onlyMigrationManager */;\n', '\n', '    /// Unlocks the contract \n', '\t/// @dev governance function called only by the migration manager or an admin\n', '    /// @dev typically called by the registry contract upon unlocking all managed contracts\n', '    function unlock() external /* onlyMigrationManager */;\n', '\n', '    /// Returns the contract locking status\n', '    /// @return isLocked is a bool indicating the contract is locked \n', '    function isLocked() view external returns (bool);\n', '\n', '}\n', '\n', '// File: contracts/Lockable.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', 'contract Lockable is ILockable, ContractRegistryAccessor {\n', '\n', '    bool public locked;\n', '\n', '    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}\n', '\n', '    function lock() external override onlyMigrationManager {\n', '        locked = true;\n', '        emit Locked();\n', '    }\n', '\n', '    function unlock() external override onlyMigrationManager {\n', '        locked = false;\n', '        emit Unlocked();\n', '    }\n', '\n', '    function isLocked() external override view returns (bool) {\n', '        return locked;\n', '    }\n', '\n', '    modifier onlyWhenActive() {\n', '        require(!locked, "contract is locked for this operation");\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/ManagedContract.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'contract ManagedContract is Lockable {\n', '\n', '    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}\n', '\n', '    function refreshContracts() virtual external {}\n', '\n', '}\n', '\n', '// File: contracts/StakingRewards.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract StakingRewards is IStakingRewards, ManagedContract {\n', '    using SafeMath for uint256;\n', '    using SafeMath96 for uint96;\n', '\n', '    uint256 constant PERCENT_MILLIE_BASE = 100000;\n', '    uint256 constant TOKEN_BASE = 1e18;\n', '\n', '    struct Settings {\n', '        uint96 annualCap;\n', '        uint32 annualRateInPercentMille;\n', '        uint32 defaultDelegatorsStakingRewardsPercentMille;\n', '        uint32 maxDelegatorsStakingRewardsPercentMille;\n', '        bool rewardAllocationActive;\n', '    }\n', '    Settings settings;\n', '\n', '    IERC20 public token;\n', '\n', '    struct StakingRewardsState {\n', '        uint96 stakingRewardsPerWeight;\n', '        uint96 unclaimedStakingRewards;\n', '        uint32 lastAssigned;\n', '    }\n', '    StakingRewardsState public stakingRewardsState;\n', '\n', '    uint256 public stakingRewardsContractBalance;\n', '\n', '    struct GuardianStakingRewards {\n', '        uint96 delegatorRewardsPerToken;\n', '        uint96 lastStakingRewardsPerWeight;\n', '        uint96 balance;\n', '        uint96 claimed;\n', '    }\n', '    mapping(address => GuardianStakingRewards) public guardiansStakingRewards;\n', '\n', '    struct GuardianRewardSettings {\n', '        uint32 delegatorsStakingRewardsPercentMille;\n', '        bool overrideDefault;\n', '    }\n', '    mapping(address => GuardianRewardSettings) public guardiansRewardSettings;\n', '\n', '    struct DelegatorStakingRewards {\n', '        uint96 balance;\n', '        uint96 lastDelegatorRewardsPerToken;\n', '        uint96 claimed;\n', '    }\n', '    mapping(address => DelegatorStakingRewards) public delegatorsStakingRewards;\n', '\n', '    constructor(\n', '        IContractRegistry _contractRegistry,\n', '        address _registryAdmin,\n', '        IERC20 _token,\n', '        uint32 annualRateInPercentMille,\n', '        uint96 annualCap,\n', '        uint32 defaultDelegatorsStakingRewardsPercentMille,\n', '        uint32 maxDelegatorsStakingRewardsPercentMille,\n', '        IStakingRewards previousRewardsContract,\n', '        address[] memory guardiansToMigrate\n', '    ) ManagedContract(_contractRegistry, _registryAdmin) public {\n', '        require(address(_token) != address(0), "token must not be 0");\n', '\n', '        _setAnnualStakingRewardsRate(annualRateInPercentMille, annualCap);\n', '        setMaxDelegatorsStakingRewardsPercentMille(maxDelegatorsStakingRewardsPercentMille);\n', '        setDefaultDelegatorsStakingRewardsPercentMille(defaultDelegatorsStakingRewardsPercentMille);\n', '\n', '        token = _token;\n', '\n', '        if (address(previousRewardsContract) != address(0)) {\n', '            migrateGuardiansSettings(previousRewardsContract, guardiansToMigrate);\n', '        }\n', '    }\n', '\n', '    modifier onlyCommitteeContract() {\n', '        require(msg.sender == address(committeeContract), "caller is not the elections contract");\n', '\n', '        _;\n', '    }\n', '\n', '    modifier onlyDelegationsContract() {\n', '        require(msg.sender == address(delegationsContract), "caller is not the delegations contract");\n', '\n', '        _;\n', '    }\n', '\n', '    /*\n', '    * External functions\n', '    */\n', '\n', '    function committeeMembershipWillChange(address guardian, uint256 weight, uint256 totalCommitteeWeight, bool inCommittee, bool inCommitteeAfter) external override onlyWhenActive onlyCommitteeContract {\n', '        uint256 delegatedStake = delegationsContract.getDelegatedStake(guardian);\n', '\n', '        Settings memory _settings = settings;\n', '        StakingRewardsState memory _stakingRewardsState = _updateStakingRewardsState(totalCommitteeWeight, _settings);\n', '        _updateGuardianStakingRewards(guardian, inCommittee, inCommitteeAfter, weight, delegatedStake, _stakingRewardsState, _settings);\n', '    }\n', '\n', '    function delegationWillChange(address guardian, uint256 guardianDelegatedStake, address delegator, uint256 delegatorStake, address nextGuardian, uint256 nextGuardianDelegatedStake) external override onlyWhenActive onlyDelegationsContract {\n', '        Settings memory _settings = settings;\n', '        (bool inCommittee, uint256 weight, , uint256 totalCommitteeWeight) = committeeContract.getMemberInfo(guardian);\n', '\n', '        StakingRewardsState memory _stakingRewardsState = _updateStakingRewardsState(totalCommitteeWeight, _settings);\n', '        GuardianStakingRewards memory guardianStakingRewards = _updateGuardianStakingRewards(guardian, inCommittee, inCommittee, weight, guardianDelegatedStake, _stakingRewardsState, _settings);\n', '        _updateDelegatorStakingRewards(delegator, delegatorStake, guardian, guardianStakingRewards);\n', '\n', '        if (nextGuardian != guardian) {\n', '            (inCommittee, weight, , totalCommitteeWeight) = committeeContract.getMemberInfo(nextGuardian);\n', '            GuardianStakingRewards memory nextGuardianStakingRewards = _updateGuardianStakingRewards(nextGuardian, inCommittee, inCommittee, weight, nextGuardianDelegatedStake, _stakingRewardsState, _settings);\n', '            delegatorsStakingRewards[delegator].lastDelegatorRewardsPerToken = nextGuardianStakingRewards.delegatorRewardsPerToken;\n', '        }\n', '    }\n', '\n', '    function getStakingRewardsBalance(address addr) external override view returns (uint256 delegatorStakingRewardsBalance, uint256 guardianStakingRewardsBalance) {\n', '        (DelegatorStakingRewards memory delegatorStakingRewards,,) = getDelegatorStakingRewards(addr, block.timestamp);\n', '        (GuardianStakingRewards memory guardianStakingRewards,,) = getGuardianStakingRewards(addr, block.timestamp); // TODO consider removing, data in state must be up to date at this point\n', '        return (delegatorStakingRewards.balance, guardianStakingRewards.balance);\n', '    }\n', '\n', '    function claimStakingRewards(address addr) external override onlyWhenActive {\n', '        (uint256 guardianRewards, uint256 delegatorRewards) = claimStakingRewardsLocally(addr);\n', '        uint256 total = delegatorRewards.add(guardianRewards);\n', '        if (total == 0) {\n', '            return;\n', '        }\n', '\n', '        uint96 claimedGuardianRewards = guardiansStakingRewards[addr].claimed.add(guardianRewards);\n', '        guardiansStakingRewards[addr].claimed = claimedGuardianRewards;\n', '        uint96 claimedDelegatorRewards = delegatorsStakingRewards[addr].claimed.add(delegatorRewards);\n', '        delegatorsStakingRewards[addr].claimed = claimedDelegatorRewards;\n', '\n', '        require(token.approve(address(stakingContract), total), "claimStakingRewards: approve failed");\n', '\n', '        address[] memory addrs = new address[](1);\n', '        addrs[0] = addr;\n', '        uint256[] memory amounts = new uint256[](1);\n', '        amounts[0] = total;\n', '        stakingContract.distributeRewards(total, addrs, amounts);\n', '\n', '        emit StakingRewardsClaimed(addr, delegatorRewards, guardianRewards, claimedDelegatorRewards, claimedGuardianRewards);\n', '    }\n', '\n', '    function getGuardianStakingRewardsData(address guardian) external override view returns (\n', '        uint256 balance,\n', '        uint256 claimed,\n', '        uint256 delegatorRewardsPerToken,\n', '        uint256 delegatorRewardsPerTokenDelta,\n', '        uint256 lastStakingRewardsPerWeight,\n', '        uint256 stakingRewardsPerWeightDelta\n', '    ) {\n', '        (GuardianStakingRewards memory rewards, uint256 _stakingRewardsPerWeightDelta, uint256 _delegatorRewardsPerTokenDelta) = getGuardianStakingRewards(guardian, block.timestamp);\n', '        return (rewards.balance, rewards.claimed, rewards.delegatorRewardsPerToken, _delegatorRewardsPerTokenDelta, rewards.lastStakingRewardsPerWeight, _stakingRewardsPerWeightDelta);\n', '    }\n', '\n', '    function getDelegatorStakingRewardsData(address delegator) external override view returns (\n', '        uint256 balance,\n', '        uint256 claimed,\n', '        address guardian,\n', '        uint256 lastDelegatorRewardsPerToken,\n', '        uint256 delegatorRewardsPerTokenDelta\n', '    ) {\n', '        (DelegatorStakingRewards memory rewards, address _guardian, uint256 _delegatorRewardsPerTokenDelta) = getDelegatorStakingRewards(delegator, block.timestamp);\n', '        return (rewards.balance, rewards.claimed, _guardian, rewards.lastDelegatorRewardsPerToken, _delegatorRewardsPerTokenDelta);\n', '    }\n', '\n', '    function estimateFutureRewards(address addr, uint256 duration) external override view returns (uint256 estimatedDelegatorStakingRewards, uint256 estimatedGuardianStakingRewards) {\n', '        (GuardianStakingRewards memory guardianRewardsNow,,) = getGuardianStakingRewards(addr, block.timestamp);\n', '        (DelegatorStakingRewards memory delegatorRewardsNow,,) = getDelegatorStakingRewards(addr, block.timestamp);\n', '        (GuardianStakingRewards memory guardianRewardsFuture,,) = getGuardianStakingRewards(addr, block.timestamp.add(duration));\n', '        (DelegatorStakingRewards memory delegatorRewardsFuture,,) = getDelegatorStakingRewards(addr, block.timestamp.add(duration));\n', '\n', '        estimatedDelegatorStakingRewards = delegatorRewardsFuture.balance.sub(delegatorRewardsNow.balance);\n', '        estimatedGuardianStakingRewards = guardianRewardsFuture.balance.sub(guardianRewardsNow.balance);\n', '    }\n', '\n', '    function getStakingRewardsState() public override view returns (\n', '        uint96 stakingRewardsPerWeight,\n', '        uint96 unclaimedStakingRewards\n', '    ) {\n', '        (, , uint totalCommitteeWeight) = committeeContract.getCommitteeStats();\n', '        (StakingRewardsState memory _stakingRewardsState,) = _getStakingRewardsState(totalCommitteeWeight, block.timestamp, settings);\n', '        stakingRewardsPerWeight = _stakingRewardsState.stakingRewardsPerWeight;\n', '        unclaimedStakingRewards = _stakingRewardsState.unclaimedStakingRewards;\n', '    }\n', '\n', '    function getCurrentStakingRewardsRatePercentMille() external override view returns (uint256 annualRate) {\n', '        (, , uint totalCommitteeWeight) = committeeContract.getCommitteeStats();\n', '        annualRate = _getAnnualRewardPerWeight(totalCommitteeWeight, settings).mul(PERCENT_MILLIE_BASE).div(TOKEN_BASE);\n', '    }\n', '    \n', '    function setGuardianDelegatorsStakingRewardsPercentMille(uint32 delegatorRewardsPercentMille) external override onlyWhenActive {\n', '        require(delegatorRewardsPercentMille <= PERCENT_MILLIE_BASE, "delegatorRewardsPercentMille must be 100000 at most");\n', '        require(delegatorRewardsPercentMille <= settings.maxDelegatorsStakingRewardsPercentMille, "delegatorRewardsPercentMille must not be larger than maxDelegatorsStakingRewardsPercentMille");\n', '        updateDelegatorStakingRewards(msg.sender);\n', '        _setGuardianDelegatorsStakingRewardsPercentMille(msg.sender, delegatorRewardsPercentMille);\n', '    }\n', '\n', '    function getGuardianDelegatorsStakingRewardsPercentMille(address guardian) external override view returns (uint256 delegatorRewardsRatioPercentMille) {\n', '        return _getGuardianDelegatorsStakingRewardsPercentMille(guardian, settings);\n', '    }\n', '\n', '    function getStakingRewardsWalletAllocatedTokens() external override view returns (uint256 allocated) {\n', '        (, uint96 unclaimedStakingRewards) = getStakingRewardsState();\n', '        return uint256(unclaimedStakingRewards).sub(stakingRewardsContractBalance);\n', '    }\n', '\n', '    /*\n', '    * Governance functions\n', '    */\n', '\n', '    function migrateRewardsBalance(address addr) external override {\n', '        require(!settings.rewardAllocationActive, "Reward distribution must be deactivated for migration");\n', '\n', '        IStakingRewards currentRewardsContract = IStakingRewards(getStakingRewardsContract());\n', '        require(address(currentRewardsContract) != address(this), "New rewards contract is not set");\n', '\n', '        (uint256 guardianRewards, uint256 delegatorRewards) = claimStakingRewardsLocally(addr);\n', '\n', '        require(token.approve(address(currentRewardsContract), guardianRewards.add(delegatorRewards)), "migrateRewardsBalance: approve failed");\n', '        currentRewardsContract.acceptRewardsBalanceMigration(addr, guardianRewards, delegatorRewards);\n', '\n', '        emit StakingRewardsBalanceMigrated(addr, guardianRewards, delegatorRewards, address(currentRewardsContract));\n', '    }\n', '\n', '    function acceptRewardsBalanceMigration(address addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards) external override {\n', '        guardiansStakingRewards[addr].balance = guardiansStakingRewards[addr].balance.add(guardianStakingRewards);\n', '        delegatorsStakingRewards[addr].balance = delegatorsStakingRewards[addr].balance.add(delegatorStakingRewards);\n', '\n', '        uint orbsTransferAmount = guardianStakingRewards.add(delegatorStakingRewards);\n', '        if (orbsTransferAmount > 0) {\n', '            require(token.transferFrom(msg.sender, address(this), orbsTransferAmount), "acceptRewardBalanceMigration: transfer failed");\n', '        }\n', '\n', '        emit StakingRewardsBalanceMigrationAccepted(msg.sender, addr, guardianStakingRewards, delegatorStakingRewards);\n', '    }\n', '\n', '    function emergencyWithdraw(address erc20) external override onlyMigrationManager {\n', '        IERC20 _token = IERC20(erc20);\n', '        emit EmergencyWithdrawal(msg.sender, address(_token));\n', '        require(_token.transfer(msg.sender, _token.balanceOf(address(this))), "StakingRewards::emergencyWithdraw - transfer failed");\n', '    }\n', '\n', '    function activateRewardDistribution(uint startTime) external override onlyMigrationManager {\n', '        require(!settings.rewardAllocationActive, "reward distribution is already activated");\n', '\n', '        stakingRewardsState.lastAssigned = uint32(startTime);\n', '        settings.rewardAllocationActive = true;\n', '\n', '        emit RewardDistributionActivated(startTime);\n', '    }\n', '\n', '    function deactivateRewardDistribution() external override onlyMigrationManager {\n', '        require(settings.rewardAllocationActive, "reward distribution is already deactivated");\n', '\n', '        StakingRewardsState memory _stakingRewardsState = updateStakingRewardsState();\n', '\n', '        settings.rewardAllocationActive = false;\n', '\n', '        withdrawRewardsWalletAllocatedTokens(_stakingRewardsState);\n', '\n', '        emit RewardDistributionDeactivated();\n', '    }\n', '\n', '    function setDefaultDelegatorsStakingRewardsPercentMille(uint32 defaultDelegatorsStakingRewardsPercentMille) public override onlyFunctionalManager {\n', '        require(defaultDelegatorsStakingRewardsPercentMille <= PERCENT_MILLIE_BASE, "defaultDelegatorsStakingRewardsPercentMille must not be larger than 100000");\n', '        require(defaultDelegatorsStakingRewardsPercentMille <= settings.maxDelegatorsStakingRewardsPercentMille, "defaultDelegatorsStakingRewardsPercentMille must not be larger than maxDelegatorsStakingRewardsPercentMille");\n', '        settings.defaultDelegatorsStakingRewardsPercentMille = defaultDelegatorsStakingRewardsPercentMille;\n', '        emit DefaultDelegatorsStakingRewardsChanged(defaultDelegatorsStakingRewardsPercentMille);\n', '    }\n', '\n', '    function getDefaultDelegatorsStakingRewardsPercentMille() public override view returns (uint32) {\n', '        return settings.defaultDelegatorsStakingRewardsPercentMille;\n', '    }\n', '\n', '    function setMaxDelegatorsStakingRewardsPercentMille(uint32 maxDelegatorsStakingRewardsPercentMille) public override onlyFunctionalManager {\n', '        require(maxDelegatorsStakingRewardsPercentMille <= PERCENT_MILLIE_BASE, "maxDelegatorsStakingRewardsPercentMille must not be larger than 100000");\n', '        settings.maxDelegatorsStakingRewardsPercentMille = maxDelegatorsStakingRewardsPercentMille;\n', '        emit MaxDelegatorsStakingRewardsChanged(maxDelegatorsStakingRewardsPercentMille);\n', '    }\n', '\n', '    function getMaxDelegatorsStakingRewardsPercentMille() public override view returns (uint32) {\n', '        return settings.maxDelegatorsStakingRewardsPercentMille;\n', '    }\n', '\n', '    function setAnnualStakingRewardsRate(uint32 annualRateInPercentMille, uint96 annualCap) external override onlyFunctionalManager {\n', '        updateStakingRewardsState();\n', '        return _setAnnualStakingRewardsRate(annualRateInPercentMille, annualCap);\n', '    }\n', '\n', '    function getAnnualStakingRewardsRatePercentMille() external override view returns (uint32) {\n', '        return settings.annualRateInPercentMille;\n', '    }\n', '\n', '    function getAnnualStakingRewardsCap() external override view returns (uint256) {\n', '        return settings.annualCap;\n', '    }\n', '\n', '    function isRewardAllocationActive() external override view returns (bool) {\n', '        return settings.rewardAllocationActive;\n', '    }\n', '\n', '    function getSettings() external override view returns (\n', '        uint annualStakingRewardsCap,\n', '        uint32 annualStakingRewardsRatePercentMille,\n', '        uint32 defaultDelegatorsStakingRewardsPercentMille,\n', '        uint32 maxDelegatorsStakingRewardsPercentMille,\n', '        bool rewardAllocationActive\n', '    ) {\n', '        Settings memory _settings = settings;\n', '        annualStakingRewardsCap = _settings.annualCap;\n', '        annualStakingRewardsRatePercentMille = _settings.annualRateInPercentMille;\n', '        defaultDelegatorsStakingRewardsPercentMille = _settings.defaultDelegatorsStakingRewardsPercentMille;\n', '        maxDelegatorsStakingRewardsPercentMille = _settings.maxDelegatorsStakingRewardsPercentMille;\n', '        rewardAllocationActive = _settings.rewardAllocationActive;\n', '    }\n', '\n', '    /*\n', '    * Private functions\n', '    */\n', '\n', '    // Global state\n', '\n', '    function _getAnnualRewardPerWeight(uint256 totalCommitteeWeight, Settings memory _settings) private pure returns (uint256) {\n', '        return totalCommitteeWeight == 0 ? 0 : Math.min(uint256(_settings.annualRateInPercentMille).mul(TOKEN_BASE).div(PERCENT_MILLIE_BASE), uint256(_settings.annualCap).mul(TOKEN_BASE).div(totalCommitteeWeight));\n', '    }\n', '\n', '    function calcStakingRewardPerWeightDelta(uint256 totalCommitteeWeight, uint duration, Settings memory _settings) private pure returns (uint256 stakingRewardsPerWeightDelta) {\n', '        stakingRewardsPerWeightDelta = 0;\n', '\n', '        if (totalCommitteeWeight > 0) {\n', '            uint annualRewardPerWeight = _getAnnualRewardPerWeight(totalCommitteeWeight, _settings);\n', '            stakingRewardsPerWeightDelta = annualRewardPerWeight.mul(duration).div(365 days);\n', '        }\n', '    }\n', '\n', '    function _getStakingRewardsState(uint256 totalCommitteeWeight, uint256 currentTime, Settings memory _settings) private view returns (StakingRewardsState memory _stakingRewardsState, uint256 allocatedRewards) {\n', '        _stakingRewardsState = stakingRewardsState;\n', '        if (_settings.rewardAllocationActive) {\n', '            uint delta = calcStakingRewardPerWeightDelta(totalCommitteeWeight, currentTime.sub(stakingRewardsState.lastAssigned), _settings);\n', '            _stakingRewardsState.stakingRewardsPerWeight = stakingRewardsState.stakingRewardsPerWeight.add(delta);\n', '            _stakingRewardsState.lastAssigned = uint32(currentTime);\n', '            allocatedRewards = delta.mul(totalCommitteeWeight).div(TOKEN_BASE);\n', '            _stakingRewardsState.unclaimedStakingRewards = _stakingRewardsState.unclaimedStakingRewards.add(allocatedRewards);\n', '        }\n', '    }\n', '\n', '    function _updateStakingRewardsState(uint256 totalCommitteeWeight, Settings memory _settings) private returns (StakingRewardsState memory _stakingRewardsState) {\n', '        if (!_settings.rewardAllocationActive) {\n', '            return stakingRewardsState;\n', '        }\n', '\n', '        uint allocatedRewards;\n', '        (_stakingRewardsState, allocatedRewards) = _getStakingRewardsState(totalCommitteeWeight, block.timestamp, _settings);\n', '        stakingRewardsState = _stakingRewardsState;\n', '        emit StakingRewardsAllocated(allocatedRewards, _stakingRewardsState.stakingRewardsPerWeight);\n', '    }\n', '\n', '    function updateStakingRewardsState() private returns (StakingRewardsState memory _stakingRewardsState) {\n', '        (, , uint totalCommitteeWeight) = committeeContract.getCommitteeStats();\n', '        return _updateStakingRewardsState(totalCommitteeWeight, settings);\n', '    }\n', '\n', '    // Guardian state\n', '\n', '    function _getGuardianStakingRewards(address guardian, bool inCommittee, bool inCommitteeAfter, uint256 guardianWeight, uint256 guardianDelegatedStake, StakingRewardsState memory _stakingRewardsState, Settings memory _settings) private view returns (GuardianStakingRewards memory guardianStakingRewards, uint256 rewardsAdded, uint256 stakingRewardsPerWeightDelta, uint256 delegatorRewardsPerTokenDelta) {\n', '        guardianStakingRewards = guardiansStakingRewards[guardian];\n', '\n', '        if (inCommittee) {\n', '            stakingRewardsPerWeightDelta = uint256(_stakingRewardsState.stakingRewardsPerWeight).sub(guardianStakingRewards.lastStakingRewardsPerWeight);\n', '            uint256 totalRewards = stakingRewardsPerWeightDelta.mul(guardianWeight);\n', '\n', '            uint256 delegatorRewardsRatioPercentMille = _getGuardianDelegatorsStakingRewardsPercentMille(guardian, _settings);\n', '\n', '            delegatorRewardsPerTokenDelta = guardianDelegatedStake == 0 ? 0 : totalRewards\n', '                .div(guardianDelegatedStake)\n', '                .mul(delegatorRewardsRatioPercentMille)\n', '                .div(PERCENT_MILLIE_BASE);\n', '\n', '            uint256 guardianCutPercentMille = PERCENT_MILLIE_BASE.sub(delegatorRewardsRatioPercentMille);\n', '\n', '            rewardsAdded = totalRewards\n', '                    .mul(guardianCutPercentMille)\n', '                    .div(PERCENT_MILLIE_BASE)\n', '                    .div(TOKEN_BASE);\n', '\n', '            guardianStakingRewards.delegatorRewardsPerToken = guardianStakingRewards.delegatorRewardsPerToken.add(delegatorRewardsPerTokenDelta);\n', '            guardianStakingRewards.balance = guardianStakingRewards.balance.add(rewardsAdded);\n', '        }\n', '\n', '        guardianStakingRewards.lastStakingRewardsPerWeight = inCommitteeAfter ? _stakingRewardsState.stakingRewardsPerWeight : 0;\n', '    }\n', '\n', '    function getGuardianStakingRewards(address guardian, uint256 currentTime) private view returns (GuardianStakingRewards memory guardianStakingRewards, uint256 stakingRewardsPerWeightDelta, uint256 delegatorRewardsPerTokenDelta) {\n', '        Settings memory _settings = settings;\n', '\n', '        (bool inCommittee, uint256 guardianWeight, ,uint256 totalCommitteeWeight) = committeeContract.getMemberInfo(guardian);\n', '        uint256 guardianDelegatedStake = delegationsContract.getDelegatedStake(guardian);\n', '\n', '        (StakingRewardsState memory _stakingRewardsState,) = _getStakingRewardsState(totalCommitteeWeight, currentTime, _settings);\n', '        (guardianStakingRewards,,stakingRewardsPerWeightDelta,delegatorRewardsPerTokenDelta) = _getGuardianStakingRewards(guardian, inCommittee, inCommittee, guardianWeight, guardianDelegatedStake, _stakingRewardsState, _settings);\n', '    }\n', '\n', '    function _updateGuardianStakingRewards(address guardian, bool inCommittee, bool inCommitteeAfter, uint256 guardianWeight, uint256 guardianDelegatedStake, StakingRewardsState memory _stakingRewardsState, Settings memory _settings) private returns (GuardianStakingRewards memory guardianStakingRewards) {\n', '        uint256 guardianStakingRewardsAdded;\n', '        uint256 stakingRewardsPerWeightDelta;\n', '        uint256 delegatorRewardsPerTokenDelta;\n', '        (guardianStakingRewards, guardianStakingRewardsAdded, stakingRewardsPerWeightDelta, delegatorRewardsPerTokenDelta) = _getGuardianStakingRewards(guardian, inCommittee, inCommitteeAfter, guardianWeight, guardianDelegatedStake, _stakingRewardsState, _settings);\n', '        guardiansStakingRewards[guardian] = guardianStakingRewards;\n', '        emit GuardianStakingRewardsAssigned(guardian, guardianStakingRewardsAdded, guardianStakingRewards.claimed.add(guardianStakingRewards.balance), guardianStakingRewards.delegatorRewardsPerToken, delegatorRewardsPerTokenDelta, _stakingRewardsState.stakingRewardsPerWeight, stakingRewardsPerWeightDelta);\n', '    }\n', '\n', '    function updateGuardianStakingRewards(address guardian, StakingRewardsState memory _stakingRewardsState, Settings memory _settings) private returns (GuardianStakingRewards memory guardianStakingRewards) {\n', '        (bool inCommittee, uint256 guardianWeight,,) = committeeContract.getMemberInfo(guardian);\n', '        return _updateGuardianStakingRewards(guardian, inCommittee, inCommittee, guardianWeight, delegationsContract.getDelegatedStake(guardian), _stakingRewardsState, _settings);\n', '    }\n', '\n', '    // Delegator state\n', '\n', '    function _getDelegatorStakingRewards(address delegator, uint256 delegatorStake, GuardianStakingRewards memory guardianStakingRewards) private view returns (DelegatorStakingRewards memory delegatorStakingRewards, uint256 delegatorRewardsAdded, uint256 delegatorRewardsPerTokenDelta) {\n', '        delegatorStakingRewards = delegatorsStakingRewards[delegator];\n', '\n', '        delegatorRewardsPerTokenDelta = uint256(guardianStakingRewards.delegatorRewardsPerToken)\n', '            .sub(delegatorStakingRewards.lastDelegatorRewardsPerToken);\n', '        delegatorRewardsAdded = delegatorRewardsPerTokenDelta\n', '            .mul(delegatorStake)\n', '            .div(TOKEN_BASE);\n', '\n', '        delegatorStakingRewards.balance = delegatorStakingRewards.balance.add(delegatorRewardsAdded);\n', '        delegatorStakingRewards.lastDelegatorRewardsPerToken = guardianStakingRewards.delegatorRewardsPerToken;\n', '    }\n', '\n', '    function getDelegatorStakingRewards(address delegator, uint256 currentTime) private view returns (DelegatorStakingRewards memory delegatorStakingRewards, address guardian, uint256 delegatorStakingRewardsPerTokenDelta) {\n', '        uint256 delegatorStake;\n', '        (guardian, delegatorStake) = delegationsContract.getDelegationInfo(delegator);\n', '        (GuardianStakingRewards memory guardianStakingRewards,,) = getGuardianStakingRewards(guardian, currentTime);\n', '\n', '        (delegatorStakingRewards,,delegatorStakingRewardsPerTokenDelta) = _getDelegatorStakingRewards(delegator, delegatorStake, guardianStakingRewards);\n', '    }\n', '\n', '    function _updateDelegatorStakingRewards(address delegator, uint256 delegatorStake, address guardian, GuardianStakingRewards memory guardianStakingRewards) private {\n', '        uint256 delegatorStakingRewardsAdded;\n', '        uint256 delegatorRewardsPerTokenDelta;\n', '        DelegatorStakingRewards memory delegatorStakingRewards;\n', '        (delegatorStakingRewards, delegatorStakingRewardsAdded, delegatorRewardsPerTokenDelta) = _getDelegatorStakingRewards(delegator, delegatorStake, guardianStakingRewards);\n', '        delegatorsStakingRewards[delegator] = delegatorStakingRewards;\n', '\n', '        emit DelegatorStakingRewardsAssigned(delegator, delegatorStakingRewardsAdded, delegatorStakingRewards.claimed.add(delegatorStakingRewards.balance), guardian, guardianStakingRewards.delegatorRewardsPerToken, delegatorRewardsPerTokenDelta);\n', '    }\n', '\n', '    function updateDelegatorStakingRewards(address delegator) private {\n', '        Settings memory _settings = settings;\n', '\n', '        (, , uint totalCommitteeWeight) = committeeContract.getCommitteeStats();\n', '        StakingRewardsState memory _stakingRewardsState = _updateStakingRewardsState(totalCommitteeWeight, _settings);\n', '\n', '        (address guardian, uint delegatorStake) = delegationsContract.getDelegationInfo(delegator);\n', '        GuardianStakingRewards memory guardianRewards = updateGuardianStakingRewards(guardian, _stakingRewardsState, _settings);\n', '\n', '        _updateDelegatorStakingRewards(delegator, delegatorStake, guardian, guardianRewards);\n', '    }\n', '\n', '    // Guardian settings\n', '\n', '    function _getGuardianDelegatorsStakingRewardsPercentMille(address guardian, Settings memory _settings) private view returns (uint256 delegatorRewardsRatioPercentMille) {\n', '        GuardianRewardSettings memory guardianSettings = guardiansRewardSettings[guardian];\n', '        delegatorRewardsRatioPercentMille =  guardianSettings.overrideDefault ? guardianSettings.delegatorsStakingRewardsPercentMille : _settings.defaultDelegatorsStakingRewardsPercentMille;\n', '        return Math.min(delegatorRewardsRatioPercentMille, _settings.maxDelegatorsStakingRewardsPercentMille);\n', '    }\n', '\n', '    function migrateGuardiansSettings(IStakingRewards previousRewardsContract, address[] memory guardiansToMigrate) private {\n', '        for (uint i = 0; i < guardiansToMigrate.length; i++) {\n', '            _setGuardianDelegatorsStakingRewardsPercentMille(guardiansToMigrate[i], uint32(previousRewardsContract.getGuardianDelegatorsStakingRewardsPercentMille(guardiansToMigrate[i])));\n', '        }\n', '    }\n', '\n', '    // Governance and misc.\n', '\n', '    function _setAnnualStakingRewardsRate(uint32 annualRateInPercentMille, uint96 annualCap) private {\n', '        Settings memory _settings = settings;\n', '        _settings.annualRateInPercentMille = annualRateInPercentMille;\n', '        _settings.annualCap = annualCap;\n', '        settings = _settings;\n', '\n', '        emit AnnualStakingRewardsRateChanged(annualRateInPercentMille, annualCap);\n', '    }\n', '\n', '    function _setGuardianDelegatorsStakingRewardsPercentMille(address guardian, uint32 delegatorRewardsPercentMille) private {\n', '        guardiansRewardSettings[guardian] = GuardianRewardSettings({\n', '            overrideDefault: true,\n', '            delegatorsStakingRewardsPercentMille: delegatorRewardsPercentMille\n', '            });\n', '\n', '        emit GuardianDelegatorsStakingRewardsPercentMilleUpdated(guardian, delegatorRewardsPercentMille);\n', '    }\n', '\n', '    function claimStakingRewardsLocally(address addr) private returns (uint256 guardianRewards, uint256 delegatorRewards) {\n', '        updateDelegatorStakingRewards(addr);\n', '\n', '        guardianRewards = guardiansStakingRewards[addr].balance;\n', '        guardiansStakingRewards[addr].balance = 0;\n', '\n', '        delegatorRewards = delegatorsStakingRewards[addr].balance;\n', '        delegatorsStakingRewards[addr].balance = 0;\n', '\n', '        uint256 total = delegatorRewards.add(guardianRewards);\n', '\n', '        StakingRewardsState memory _stakingRewardsState = stakingRewardsState;\n', '\n', '        uint256 _stakingRewardsContractBalance = stakingRewardsContractBalance;\n', '        if (total > _stakingRewardsContractBalance) {\n', '            _stakingRewardsContractBalance = withdrawRewardsWalletAllocatedTokens(_stakingRewardsState);\n', '        }\n', '\n', '        stakingRewardsContractBalance = _stakingRewardsContractBalance.sub(total);\n', '        stakingRewardsState.unclaimedStakingRewards = _stakingRewardsState.unclaimedStakingRewards.sub(total);\n', '    }\n', '\n', '    function withdrawRewardsWalletAllocatedTokens(StakingRewardsState memory _stakingRewardsState) private returns (uint256 _stakingRewardsContractBalance){\n', '        _stakingRewardsContractBalance = stakingRewardsContractBalance;\n', '        uint256 allocated = _stakingRewardsState.unclaimedStakingRewards.sub(_stakingRewardsContractBalance);\n', '        stakingRewardsWallet.withdraw(allocated);\n', '        _stakingRewardsContractBalance = _stakingRewardsContractBalance.add(allocated);\n', '        stakingRewardsContractBalance = _stakingRewardsContractBalance;\n', '    }\n', '\n', '    /*\n', '     * Contracts topology / registry interface\n', '     */\n', '\n', '    ICommittee committeeContract;\n', '    IDelegations delegationsContract;\n', '    IProtocolWallet stakingRewardsWallet;\n', '    IStakingContract stakingContract;\n', '    function refreshContracts() external override {\n', '        committeeContract = ICommittee(getCommitteeContract());\n', '        delegationsContract = IDelegations(getDelegationsContract());\n', '        stakingRewardsWallet = IProtocolWallet(getStakingRewardsWallet());\n', '        stakingContract = IStakingContract(getStakingContract());\n', '    }\n', '}']