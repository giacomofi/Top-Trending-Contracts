['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-16\n', '*/\n', '\n', 'pragma solidity 0.5.10;\n', '\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) internal _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) internal _allowed;\n', '\n', '    uint256 internal _totalSupply;\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address addr) public view returns (uint256) {\n', '        return _balances[addr];\n', '    }\n', '\n', '    function allowance(address addr, address spender) public view returns (uint256) {\n', '        return _allowed[addr][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = (\n', '        _allowed[msg.sender][spender].add(addedValue));\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = (\n', '        _allowed[msg.sender][spender].sub(subtractedValue));\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '        _transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    function _transfer(address from, address to, uint256 value) internal {\n', '        require(to != address(0));\n', '\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    function _mint(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.add(value);\n', '        _balances[account] = _balances[account].add(value);\n', '        emit Transfer(address(0), account, value);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0));\n', '\n', '        _balances[account] = _balances[account].sub(amount);\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor() internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(msg.sender), "Caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function isOwner(address account) public view returns (bool) {\n', '        return account == _owner;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "New owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract SmartPool250 is ERC20, Ownable {\n', '\n', '    string private _name = "Smartsel";\n', '    string private _symbol = "SATL";\n', '    uint8 private _decimals = 18;\n', '\n', '    struct StartUp {\n', '        address account;\n', '        uint256 goal;\n', '        uint256 time;\n', '        uint256[] accumulated;\n', '    }\n', '\n', '    StartUp startup;\n', '\n', '    struct User {\n', '        bool active;\n', '        uint256 time;\n', '        uint256 checkpoint;\n', '        uint256 reserved;\n', '    }\n', '\n', '    mapping (address => User) holders;\n', '    mapping (uint256 => uint256) activated;\n', '\n', '    uint256 public amountOfStakes;\n', '\n', '    uint256 public stakingRequirement = 10e18;\n', '    uint256 public limitOfStakes = 250;\n', '    uint256 public holderReward = 10e18;\n', '\n', '    uint256 tokenPriceIncremental = 0.00001 ether;\n', '    uint256 magnitude = 1e18;\n', '\n', '    uint256 date;\n', '    uint256 public period = 30 days;\n', '\n', '    address payable public wallet;\n', '    address payable public dev;\n', '\n', '    IERC20 public BITL;\n', '    uint256 public priceBITL = 1e18;\n', '    bool public ownerMode;\n', '    bool public deprecated;\n', '\n', '    event Purchased(address indexed sender, address indexed recipient, uint256 amountSATL);\n', '    event Sold(address indexed sender, address indexed recipient, uint256 amountSATL, uint256 amountETH);\n', '    event StakeActivated(address indexed account, uint256 time);\n', '    event StakeDeactivated(address indexed account, uint256 time);\n', '    event DividendsPayed(address indexed account, address indexed recipient, uint256 amount);\n', '    event ExchangedSATLtoBITL(address indexed from, address indexed recipient,  uint256 amountSATL, uint256 amountBITL);\n', '    event ExchangedBITLtoETH(address indexed from, address indexed recipient, uint256 amountBITL, uint256 amountETH);\n', '    event InitStartUp(address wallet, uint256 goal);\n', '    event EndStartUp(address wallet, uint256 goal);\n', '    event Donate(address indexed sender, uint256 amount);\n', '\n', '    constructor(address BITLAddr, address payable walletAddr, address payable devAddr) public {\n', '        require(BITLAddr != address(0) && walletAddr != address(0) && devAddr != address(0));\n', '\n', '        date = block.timestamp;\n', '        BITL = IERC20(BITLAddr);\n', '        wallet = walletAddr;\n', '        dev = devAddr;\n', '\n', '        ownerMode = true;\n', '\n', '        purchase(msg.sender);\n', '    }\n', '\n', '    function() external payable {\n', '        if (msg.value > 0) {\n', '            purchase(msg.sender);\n', '        } else {\n', '            withdrawDividends(msg.sender);\n', '        }\n', '    }\n', '\n', '    modifier createStake(address account, uint256 value) {\n', '        _;\n', '        if (\n', '            _balances[account] >= stakingRequirement &&\n', '            _balances[account].sub(value) < stakingRequirement &&\n', '            amountOfStakes < limitOfStakes\n', '            ) {\n', '\n', '            if (startup.account != address(0))  {\n', '                accumulate();\n', '            }\n', '\n', '            holders[account].active = true;\n', '            holders[account].time = block.timestamp;\n', '            holders[account].checkpoint = block.timestamp;\n', '\n', '            amountOfStakes++;\n', '\n', '            uint256 idx = (block.timestamp.sub(date)).div(period);\n', '            activated[idx]++;\n', '\n', '            emit StakeActivated(account, block.timestamp);\n', '\n', '        }\n', '    }\n', '\n', '    modifier removeStake(address account, uint256 value) {\n', '        _;\n', '        if (\n', '            _balances[account] < stakingRequirement &&\n', '            _balances[account].add(value) >= stakingRequirement\n', '            ) {\n', '\n', '            if (startup.account != address(0))  {\n', '                accumulate();\n', '            }\n', '\n', '            uint256 divs = getDividends(account);\n', '            if (divs > 0) {\n', '                holders[account].reserved = divs;\n', '            }\n', '            holders[account].active = false;\n', '\n', '            amountOfStakes--;\n', '\n', '            uint256 idx = (block.timestamp.sub(date)).div(period);\n', '            if (idx == (holders[account].time.sub(date)).div(period)) {\n', '                activated[idx]--;\n', '            }\n', '\n', '            emit StakeDeactivated(account, block.timestamp);\n', '        }\n', '    }\n', '\n', '    function accumulate() internal {\n', '        uint256 idx = (block.timestamp - ((startup.time - date) / period * period + date)) / period;\n', '\n', '        if (idx > 0 && startup.accumulated.length < idx) {\n', '            uint256 len = startup.accumulated.length;\n', '            for (uint256 i = 0; i < idx - len; i++) {\n', '                startup.accumulated.push(amountOfStakes * holderReward);\n', '            }\n', '        }\n', '\n', '    }\n', '\n', '    function _transfer(address from, address to, uint256 value) internal removeStake(from, value) createStake(to, value) {\n', '        require(from != to);\n', '\n', '        super._transfer(from, to, value);\n', '\n', '    }\n', '\n', '    function _mint(address account, uint256 value) internal createStake(account, value) {\n', '\n', '        super._mint(account, value);\n', '\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal removeStake(account, amount) {\n', '\n', '        super._burn(account, amount);\n', '\n', '    }\n', '\n', '    function purchase(address recipient) public payable {\n', '\n', '        uint256 value;\n', '        uint256 amount;\n', '        uint256 allowed = BITL.allowance(recipient, address(this));\n', '\n', '        if (msg.value > 0) {\n', '            value = msg.value;\n', '        } else if (allowed > 0) {\n', '            value = allowed.mul(priceBITL).mul(getCurrentPrice()).div(magnitude).div(magnitude);\n', '            BITL.transferFrom(recipient, address(this), allowed);\n', '        }\n', '\n', '        if (amountOfStakes > 0) {\n', '            amount = value.div(getCurrentPrice()).mul(magnitude);\n', '        } else {\n', '            amount = 10e18;\n', '        }\n', '\n', '        _purchase(recipient, amount);\n', '\n', '    }\n', '\n', '    function _purchase(address recipient, uint256 value) internal {\n', '\n', '        _mint(recipient, value);\n', '\n', '        emit Purchased(msg.sender, recipient, value);\n', '    }\n', '\n', '    function sell(address payable recipient, uint256 value) public {\n', '\n', '        uint256 amountETH = value.mul(getCurrentPrice()).div(magnitude);\n', '\n', '        _burn(msg.sender, value);\n', '\n', '        recipient.transfer(amountETH);\n', '\n', '        emit Sold(msg.sender, recipient, value, amountETH);\n', '    }\n', '\n', '    function withdrawDividends(address recipient) public {\n', '        require(holders[msg.sender].active);\n', '\n', '        uint256 reward = getDividends(msg.sender);\n', '\n', '        holders[msg.sender].checkpoint = block.timestamp;\n', '        holders[msg.sender].reserved = 0;\n', '\n', '        _mint(recipient, reward);\n', '\n', '        emit DividendsPayed(msg.sender, recipient, reward);\n', '    }\n', '\n', '    function receiveApproval(address account, uint256 value, address token, bytes memory extraData) public {\n', '        require(token == address(BITL));\n', '        uint256 uintData;\n', '        assembly { uintData := mload(add(extraData, add(0x20, 0))) }\n', '        if (uintData == 0) {\n', '            purchase(account);\n', '        } else {\n', '            exchangeBITLtoETH(account, account, value);\n', '        }\n', '    }\n', '\n', '    function exchangeBITLtoETH(address from, address recipient, uint256 value) public {\n', '        if (ownerMode) {\n', '            require(isOwner(tx.origin));\n', '        }\n', '\n', '        uint256 amountETH = value.mul(priceBITL).mul(getCurrentPrice()).div(magnitude).div(magnitude);\n', '\n', '        BITL.transferFrom(from, address(this), value);\n', '        address(uint160(recipient)).transfer(amountETH);\n', '\n', '        emit ExchangedBITLtoETH(from, recipient, value, amountETH);\n', '    }\n', '\n', '    function exchangeSATLtoBITL(address recipient, uint256 value) public {\n', '\n', '        uint256 amountBITL = value.mul(priceBITL).div(magnitude);\n', '\n', '        _burn(msg.sender, value);\n', '        BITL.transfer(recipient, amountBITL);\n', '\n', '        emit ExchangedSATLtoBITL(msg.sender, recipient, value, amountBITL);\n', '    }\n', '\n', '    function initiateStartUp(address account, uint256 goal) public onlyOwner {\n', '        require(account != address(0));\n', '\n', '        startup.account = account;\n', '        startup.goal = goal;\n', '        startup.time = block.timestamp;\n', '        startup.accumulated.push(payouts().mul(holderReward).mul(nextDate().sub(block.timestamp)).div(period));\n', '\n', '        emit InitStartUp(account, goal);\n', '    }\n', '\n', '    function setStartUpWallet(address payable account) public onlyOwner {\n', '        require(account != address(0));\n', '\n', '        startup.account = account;\n', '    }\n', '\n', '    function setStartUpGoal(uint256 goal) public onlyOwner {\n', '        require(goal != 0);\n', '\n', '        startup.goal = goal;\n', '    }\n', '\n', '    function payToStartUp() public onlyOwner {\n', '\n', '        uint256 amount = getAccumulated();\n', '\n', '        _mint(startup.account, amount.mul(85).div(100));\n', '        _mint(dev, amount.mul(10).div(100));\n', '        _mint(wallet, amount.mul(5).div(100));\n', '\n', '        emit EndStartUp(startup.account, amount);\n', '\n', '        delete startup;\n', '    }\n', '\n', '    function setPriceBITL(uint256 value) public onlyOwner {\n', '        require(value != 0);\n', '        priceBITL = value;\n', '    }\n', '\n', '    function switchOwnerMode() public onlyOwner {\n', '        if (!ownerMode) {\n', '            ownerMode = true;\n', '        } else {\n', '            ownerMode = false;\n', '        }\n', '    }\n', '\n', '    function switchDeprecated() public onlyOwner {\n', '        if (!deprecated) {\n', '            deprecated = true;\n', '        } else {\n', '            deprecated = false;\n', '        }\n', '    }\n', '\n', '    function setWallet(address payable account) public onlyOwner {\n', '        require(account != address(0));\n', '\n', '        wallet = account;\n', '    }\n', '\n', '    function withdraw(address payable recipient, uint256 value) public onlyOwner {\n', '\n', '        recipient.transfer(value);\n', '\n', '    }\n', '\n', '    function donate() public payable {\n', '\n', '        uint256 allowed = BITL.allowance(msg.sender, address(this));\n', '\n', '        if (allowed > 0) {\n', '            BITL.transferFrom(msg.sender, address(this), allowed);\n', '        }\n', '\n', '        emit Donate(msg.sender, msg.value);\n', '\n', '    }\n', '\n', '    function getDividends(address account) public view returns(uint256) {\n', '        if (deprecated) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 reward = holders[account].reserved;\n', '\n', '        if (holders[account].active) {\n', '            if (holders[account].time == holders[account].checkpoint) {\n', '\n', '                if (block.timestamp < (holders[account].time - date) / period * period + period + date) {\n', '\n', '                    reward = 0;\n', '\n', '                } else {\n', '                    uint256 next = ((holders[account].time - date) / period * period + period + date);\n', '\n', '                    uint256 multiplier = (block.timestamp - next) / period;\n', '\n', '                    reward = holderReward * (next - holders[account].time) / period + holderReward * multiplier;\n', '\n', '                    return reward;\n', '                }\n', '\n', '            } else {\n', '\n', '                if (block.timestamp < (holders[account].checkpoint - date) / period * period + period + date) {\n', '\n', '                    reward = 0;\n', '\n', '                } else {\n', '                    uint256 multiplier = (block.timestamp - ((holders[account].checkpoint - date) / period * period + date)) / period;\n', '\n', '                    reward = holderReward * multiplier;\n', '                }\n', '\n', '            }\n', '        }\n', '\n', '        return reward;\n', '\n', '    }\n', '\n', '    function getAccumulated() public view returns(uint256) {\n', '        if (startup.account == address(0)) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 payout;\n', '\n', '        uint256 idx = (block.timestamp - ((startup.time - date) / period * period + date)) / period;\n', '        if (idx == 0) {\n', '            return 0;\n', '        }\n', '\n', '        for (uint256 i = 0; i < startup.accumulated.length; i++) {\n', '\n', '            payout += startup.accumulated[i];\n', '\n', '        }\n', '\n', '        if (idx > startup.accumulated.length) {\n', '            for (uint256 i = 0; i < idx - startup.accumulated.length; i++) {\n', '\n', '                payout += amountOfStakes * holderReward;\n', '\n', '            }\n', '        }\n', '\n', '        if (payout < startup.goal) {\n', '            return payout;\n', '        } else {\n', '            return startup.goal;\n', '        }\n', '\n', '    }\n', '\n', '    function activatedStakes() public view returns(uint256) {\n', '        return activated[(block.timestamp - date) / period];\n', '    }\n', '\n', '    function payouts() public view returns(uint256) {\n', '        return amountOfStakes - activatedStakes();\n', '    }\n', '\n', '    function getCurrentPrice() public view returns(uint256) {\n', '        uint256 price = ((5e16 + activatedStakes() * tokenPriceIncremental) - (5e16 - payouts() * tokenPriceIncremental)) * magnitude / (5e16 + activatedStakes() * tokenPriceIncremental);\n', '        uint256 inaccuracy = price % tokenPriceIncremental;\n', '        if (inaccuracy > 0) {\n', '            price = price - inaccuracy + tokenPriceIncremental;\n', '        }\n', '        return price;\n', '    }\n', '\n', '    function getBalance() public view returns(uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function getAmountOfFreeStakes() public view returns(uint256) {\n', '        return limitOfStakes - amountOfStakes;\n', '    }\n', '\n', '    function nextDate() public view returns(uint256) {\n', '        return(date + period + (block.timestamp - date) / period * period);\n', '    }\n', '\n', '    function getStartUpInfo() public view returns(address, uint256) {\n', '        return(startup.account, startup.goal);\n', '    }\n', '\n', '    function name() public view returns(string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns(string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view returns(uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '}']