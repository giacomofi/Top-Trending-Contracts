['pragma solidity ^0.5.17;\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) public pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    \n', '    function sub(uint a, uint b) public pure returns (uint c) {\n', '        require(b <= a); \n', '        c = a - b; \n', '    } \n', '    \n', '    function mul(uint a, uint b) public pure returns (uint c) {\n', '        c = a * b; \n', '        require(a == 0 || c / a == b); \n', '    } \n', '    \n', '    function div(uint a, uint b) public pure returns (uint c) { \n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    constructor () public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender == owner)\n', '            _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        if (newOwner != address(0)) owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address tokenOwner) public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', 'contract sZAC is Ownable {\n', '    using SafeMath for uint;\n', '    \n', '    struct StakingInfo {\n', '        uint amount;\n', '        uint depositDate;\n', '        uint rewardPercent;\n', '    }\n', '    \n', '    uint minStakeAmount = 30 * 10**18; // ZAC token has 18 decimals\n', '    uint REWARD_DIVIDER = 10**8;\n', '    \n', '    ERC20Interface stakingToken;\n', '    uint rewardPercent; //  percent value for per second  -> set 192 if you want 5% per month reward (because it will be divided by 10^8 for getting the small float number)\n', '    string name = "sZAC";\n', '    \n', '    uint ownerTokensAmount;\n', '    address[] internal stakeholders;\n', '    mapping(address => StakingInfo[]) internal stakes;\n', '\n', '    //  percent value for per second  \n', '    //  set 192 if you want 5% per month reward (because it will be divided by 10^8 for getting the small float number)\n', '    //  5% per month = 5 / (30 * 24 * 60 * 60) ~ 0.00000192 (192 / 10^8)\n', '    constructor(ERC20Interface _stakingToken, uint _rewardPercent) public {\n', '        stakingToken = _stakingToken;\n', '        rewardPercent = _rewardPercent;\n', '    }\n', '    \n', '    event Staked(address staker, uint amount);\n', '    event Unstaked(address staker, uint amount);\n', '    \n', '    function changeRewardPercent(uint _rewardPercent) public onlyOwner {\n', '        rewardPercent = _rewardPercent;\n', '    }\n', '    \n', '    function changeMinStakeAmount(uint _minStakeAmount) public onlyOwner {\n', '        minStakeAmount = _minStakeAmount;\n', '    }\n', '    \n', '    function totalStakes() public view returns(uint256) {\n', '        uint _totalStakes = 0;\n', '        for (uint i = 0; i < stakeholders.length; i += 1) {\n', '            for (uint j = 0; j < stakes[stakeholders[i]].length; j += 1)\n', '             _totalStakes = _totalStakes.add(stakes[stakeholders[i]][j].amount);\n', '        }\n', '        return _totalStakes;\n', '    }\n', '    \n', '    function isStakeholder(address _address) public view returns(bool, uint256) {\n', '        for (uint256 s = 0; s < stakeholders.length; s += 1) {\n', '            if (_address == stakeholders[s]) \n', '                return (true, s);\n', '        }\n', '        return (false, 0);\n', '    }\n', '\n', '    function addStakeholder(address _stakeholder) internal {\n', '        (bool _isStakeholder, ) = isStakeholder(_stakeholder);\n', '        if (!_isStakeholder)\n', '            stakeholders.push(_stakeholder);\n', '    }\n', '\n', '    function removeStakeholder(address _stakeholder) internal {\n', '        (bool _isStakeholder, uint256 s) = isStakeholder(_stakeholder);\n', '        if (_isStakeholder) {\n', '            stakeholders[s] = stakeholders[stakeholders.length - 1];\n', '            stakeholders.pop();\n', '        }\n', '    }\n', '    \n', '    function stake(uint256 _amount) public {\n', '        require(_amount >= minStakeAmount);\n', '        require(stakingToken.transferFrom(msg.sender, address(this), _amount), "Stake required!");\n', '        if (stakes[msg.sender].length == 0) {\n', '            addStakeholder(msg.sender);\n', '        }\n', '        stakes[msg.sender].push(StakingInfo(_amount, now, rewardPercent));\n', '        emit Staked(msg.sender, _amount);\n', '    }\n', '\n', '    function unstake() public {\n', '        uint withdrawAmount = 0;\n', '        for (uint j = 0; j < stakes[msg.sender].length; j += 1) {\n', '            uint amount = stakes[msg.sender][j].amount;\n', '            withdrawAmount = withdrawAmount.add(amount);\n', '            \n', '            uint rewardAmount = amount.mul((now - stakes[msg.sender][j].depositDate).mul(stakes[msg.sender][j].rewardPercent));\n', '            rewardAmount = rewardAmount.div(REWARD_DIVIDER);\n', '            withdrawAmount = withdrawAmount.add(rewardAmount.div(100));\n', '        }\n', '        \n', '        require(stakingToken.transfer(msg.sender, withdrawAmount), "Not enough tokens in contract!");\n', '        delete stakes[msg.sender];\n', '        removeStakeholder(msg.sender);\n', '        emit Unstaked(msg.sender, withdrawAmount);\n', '    }\n', '    \n', '    function sendTokens(uint _amount) public onlyOwner {\n', '        require(stakingToken.transferFrom(msg.sender, address(this), _amount), "Transfering not approved!");\n', '        ownerTokensAmount = ownerTokensAmount.add(_amount);\n', '    }\n', '    \n', '    function withdrawTokens(address receiver, uint _amount) public onlyOwner {\n', '        ownerTokensAmount = ownerTokensAmount.sub(_amount);\n', '        require(stakingToken.transfer(receiver, _amount), "Not enough tokens on contract!");\n', '    }\n', '}']