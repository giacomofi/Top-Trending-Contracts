['pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an account access to this role\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(!has(role, account));\n', '\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev remove an account's access to this role\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(has(role, account));\n', '\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an account has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0));\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '/*\n', ' * This code has not been reviewed.\n', ' * Do not use or deploy this code before reviewing it personally first.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title PauserRole\n', ' * @dev Pausers are responsible for pausing/unpausing transfers.\n', ' */\n', 'contract PauserRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event PauserAdded(address indexed token, address indexed account);\n', '    event PauserRemoved(address indexed token, address indexed account);\n', '\n', '    // Mapping from token to token pausers.\n', '    mapping(address => Roles.Role) private _pausers;\n', '\n', '    constructor () internal {}\n', '\n', '    modifier onlyPauser(address token) {\n', '        require(isPauser(token, msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isPauser(address token, address account) public view returns (bool) {\n', '        return _pausers[token].has(account);\n', '    }\n', '\n', '    function addPauser(address token, address account) public onlyPauser(token) {\n', '        _addPauser(token, account);\n', '    }\n', '\n', '    function renouncePauser(address token) public {\n', '        _removePauser(token, msg.sender);\n', '    }\n', '\n', '    function _addPauser(address token, address account) internal {\n', '        _pausers[token].add(account);\n', '        emit PauserAdded(token, account);\n', '    }\n', '\n', '    function _removePauser(address token, address account) internal {\n', '        _pausers[token].remove(account);\n', '        emit PauserRemoved(token, account);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is PauserRole {\n', '    event Paused(address indexed token, address account);\n', '    event Unpaused(address indexed token, address account);\n', '\n', '    // Mapping from token to token paused status.\n', '    mapping(address => bool) private _paused;\n', '\n', '    /**\n', '     * @return true if the contract is paused, false otherwise.\n', '     */\n', '    function paused(address token) public view returns (bool) {\n', '        return _paused[token];\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused(address token) {\n', '        require(!_paused[token]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused(address token) {\n', '        require(_paused[token]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause(address token) public onlyPauser(token) whenNotPaused(token) {\n', '        _paused[token] = true;\n', '        emit Paused(token, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause(address token) public onlyPauser(token) whenPaused(token) {\n', '        _paused[token] = false;\n', '        emit Unpaused(token, msg.sender);\n', '    }\n', '}\n', '\n', '/*\n', ' * This code has not been reviewed.\n', ' * Do not use or deploy this code before reviewing it personally first.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AllowlistAdminRole\n', ' * @dev AllowlistAdmins are responsible for assigning and removing Allowlisted accounts.\n', ' */\n', 'contract AllowlistAdminRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event AllowlistAdminAdded(address indexed token, address indexed account);\n', '    event AllowlistAdminRemoved(address indexed token, address indexed account);\n', '\n', '    // Mapping from token to token allowlist admins.\n', '    mapping(address => Roles.Role) private _allowlistAdmins;\n', '\n', '    constructor () internal {}\n', '\n', '    modifier onlyAllowlistAdmin(address token) {\n', '        require(isAllowlistAdmin(token, msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isAllowlistAdmin(address token, address account) public view returns (bool) {\n', '        return _allowlistAdmins[token].has(account);\n', '    }\n', '\n', '    function addAllowlistAdmin(address token, address account) public onlyAllowlistAdmin(token) {\n', '        _addAllowlistAdmin(token, account);\n', '    }\n', '\n', '    function renounceAllowlistAdmin(address token) public {\n', '        _removeAllowlistAdmin(token, msg.sender);\n', '    }\n', '\n', '    function _addAllowlistAdmin(address token, address account) internal {\n', '        _allowlistAdmins[token].add(account);\n', '        emit AllowlistAdminAdded(token, account);\n', '    }\n', '\n', '    function _removeAllowlistAdmin(address token, address account) internal {\n', '        _allowlistAdmins[token].remove(account);\n', '        emit AllowlistAdminRemoved(token, account);\n', '    }\n', '}\n', '\n', '/*\n', ' * This code has not been reviewed.\n', ' * Do not use or deploy this code before reviewing it personally first.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AllowlistedRole\n', ' * @dev Allowlisted accounts have been forbidden by a AllowlistAdmin to perform certain actions (e.g. participate in a\n', ' * crowdsale). This role is special in that the only accounts that can add it are AllowlistAdmins (who can also remove\n', ' * it), and not Allowlisteds themselves.\n', ' */\n', 'contract AllowlistedRole is AllowlistAdminRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event AllowlistedAdded(address indexed token, address indexed account);\n', '    event AllowlistedRemoved(address indexed token, address indexed account);\n', '\n', '    // Mapping from token to token allowlisteds.\n', '    mapping(address => Roles.Role) private _allowlisteds;\n', '\n', '    modifier onlyNotAllowlisted(address token) {\n', '        require(!isAllowlisted(token, msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isAllowlisted(address token, address account) public view returns (bool) {\n', '        return _allowlisteds[token].has(account);\n', '    }\n', '\n', '    function addAllowlisted(address token, address account) public onlyAllowlistAdmin(token) {\n', '        _addAllowlisted(token, account);\n', '    }\n', '\n', '    function removeAllowlisted(address token, address account) public onlyAllowlistAdmin(token) {\n', '        _removeAllowlisted(token, account);\n', '    }\n', '\n', '    function _addAllowlisted(address token, address account) internal {\n', '        _allowlisteds[token].add(account);\n', '        emit AllowlistedAdded(token, account);\n', '    }\n', '\n', '    function _removeAllowlisted(address token, address account) internal {\n', '        _allowlisteds[token].remove(account);\n', '        emit AllowlistedRemoved(token, account);\n', '    }\n', '}\n', '\n', '/*\n', ' * This code has not been reviewed.\n', ' * Do not use or deploy this code before reviewing it personally first.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title BlocklistAdminRole\n', ' * @dev BlocklistAdmins are responsible for assigning and removing Blocklisted accounts.\n', ' */\n', 'contract BlocklistAdminRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event BlocklistAdminAdded(address indexed token, address indexed account);\n', '    event BlocklistAdminRemoved(address indexed token, address indexed account);\n', '\n', '    // Mapping from token to token blocklist admins.\n', '    mapping(address => Roles.Role) private _blocklistAdmins;\n', '\n', '    constructor () internal {}\n', '\n', '    modifier onlyBlocklistAdmin(address token) {\n', '        require(isBlocklistAdmin(token, msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isBlocklistAdmin(address token, address account) public view returns (bool) {\n', '        return _blocklistAdmins[token].has(account);\n', '    }\n', '\n', '    function addBlocklistAdmin(address token, address account) public onlyBlocklistAdmin(token) {\n', '        _addBlocklistAdmin(token, account);\n', '    }\n', '\n', '    function renounceBlocklistAdmin(address token) public {\n', '        _removeBlocklistAdmin(token, msg.sender);\n', '    }\n', '\n', '    function _addBlocklistAdmin(address token, address account) internal {\n', '        _blocklistAdmins[token].add(account);\n', '        emit BlocklistAdminAdded(token, account);\n', '    }\n', '\n', '    function _removeBlocklistAdmin(address token, address account) internal {\n', '        _blocklistAdmins[token].remove(account);\n', '        emit BlocklistAdminRemoved(token, account);\n', '    }\n', '}\n', '\n', '/*\n', ' * This code has not been reviewed.\n', ' * Do not use or deploy this code before reviewing it personally first.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title BlocklistedRole\n', ' * @dev Blocklisted accounts have been forbidden by a BlocklistAdmin to perform certain actions (e.g. participate in a\n', ' * crowdsale). This role is special in that the only accounts that can add it are BlocklistAdmins (who can also remove\n', ' * it), and not Blocklisteds themselves.\n', ' */\n', 'contract BlocklistedRole is BlocklistAdminRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event BlocklistedAdded(address indexed token, address indexed account);\n', '    event BlocklistedRemoved(address indexed token, address indexed account);\n', '\n', '    // Mapping from token to token blocklisteds.\n', '    mapping(address => Roles.Role) private _blocklisteds;\n', '\n', '    modifier onlyNotBlocklisted(address token) {\n', '        require(!isBlocklisted(token, msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isBlocklisted(address token, address account) public view returns (bool) {\n', '        return _blocklisteds[token].has(account);\n', '    }\n', '\n', '    function addBlocklisted(address token, address account) public onlyBlocklistAdmin(token) {\n', '        _addBlocklisted(token, account);\n', '    }\n', '\n', '    function removeBlocklisted(address token, address account) public onlyBlocklistAdmin(token) {\n', '        _removeBlocklisted(token, account);\n', '    }\n', '\n', '    function _addBlocklisted(address token, address account) internal {\n', '        _blocklisteds[token].add(account);\n', '        emit BlocklistedAdded(token, account);\n', '    }\n', '\n', '    function _removeBlocklisted(address token, address account) internal {\n', '        _blocklisteds[token].remove(account);\n', '        emit BlocklistedRemoved(token, account);\n', '    }\n', '}\n', '\n', 'contract ERC1820Registry {\n', '    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n', '    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);\n', '    function setManager(address _addr, address _newManager) external;\n', '    function getManager(address _addr) public view returns (address);\n', '}\n', '\n', '\n', '/// Base client to interact with the registry.\n', 'contract ERC1820Client {\n', '    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n', '\n', '    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\n', '        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n', '        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\n', '    }\n', '\n', '    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\n', '        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n', '        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\n', '    }\n', '\n', '    function delegateManagement(address _newManager) internal {\n', '        ERC1820REGISTRY.setManager(address(this), _newManager);\n', '    }\n', '}\n', '\n', '/*\n', ' * This code has not been reviewed.\n', ' * Do not use or deploy this code before reviewing it personally first.\n', ' */\n', '\n', '\n', '\n', 'contract ERC1820Implementer {\n', '  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));\n', '\n', '  mapping(bytes32 => bool) internal _interfaceHashes;\n', '\n', '  function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\n', '    external\n', '    view\n', '    returns(bytes32)\n', '  {\n', '    if(_interfaceHashes[interfaceHash]) {\n', '      return ERC1820_ACCEPT_MAGIC;\n', '    } else {\n', '      return "";\n', '    }\n', '  }\n', '\n', '  function _setInterface(string memory interfaceLabel) internal {\n', '    _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\n', '  }\n', '\n', '}\n', '\n', '/*\n', ' * This code has not been reviewed.\n', ' * Do not use or deploy this code before reviewing it personally first.\n', ' */\n', '\n', '\n', '/**\n', ' * @title IERC1400 security token standard\n', ' * @dev See https://github.com/SecurityTokenStandard/EIP-Spec/blob/master/eip/eip-1400.md\n', ' */\n', 'interface IERC1400 /*is IERC20*/ { // Interfaces can currently not inherit interfaces, but IERC1400 shall include IERC20\n', '\n', '  // ****************** Document Management *******************\n', '  function getDocument(bytes32 name) external view returns (string memory, bytes32);\n', '  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external;\n', '\n', '  // ******************* Token Information ********************\n', '  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256);\n', '  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory);\n', '\n', '  // *********************** Transfers ************************\n', '  function transferWithData(address to, uint256 value, bytes calldata data) external;\n', '  function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external;\n', '\n', '  // *************** Partition Token Transfers ****************\n', '  function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32);\n', '  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\n', '\n', '  // ****************** Controller Operation ******************\n', '  function isControllable() external view returns (bool);\n', '  // function controllerTransfer(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with "operatorTransferByPartition"\n', '  // function controllerRedeem(address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with "operatorRedeemByPartition"\n', '\n', '  // ****************** Operator Management *******************\n', '  function authorizeOperator(address operator) external;\n', '  function revokeOperator(address operator) external;\n', '  function authorizeOperatorByPartition(bytes32 partition, address operator) external;\n', '  function revokeOperatorByPartition(bytes32 partition, address operator) external;\n', '\n', '  // ****************** Operator Information ******************\n', '  function isOperator(address operator, address tokenHolder) external view returns (bool);\n', '  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool);\n', '\n', '  // ********************* Token Issuance *********************\n', '  function isIssuable() external view returns (bool);\n', '  function issue(address tokenHolder, uint256 value, bytes calldata data) external;\n', '  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external;\n', '\n', '  // ******************** Token Redemption ********************\n', '  function redeem(uint256 value, bytes calldata data) external;\n', '  function redeemFrom(address tokenHolder, uint256 value, bytes calldata data) external;\n', '  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external;\n', '  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData) external;\n', '\n', '  // ******************* Transfer Validity ********************\n', "  // We use different transfer validity functions because those described in the interface don't allow to verify the certificate's validity.\n", "  // Indeed, verifying the ecrtificate's validity requires to keeps the function's arguments in the exact same order as the transfer function.\n", '  //\n', '  // function canTransfer(address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\n', '  // function canTransferFrom(address from, address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\n', '  // function canTransferByPartition(address from, address to, bytes32 partition, uint256 value, bytes calldata data) external view returns (byte, bytes32, bytes32);    \n', '\n', '  // ******************* Controller Events ********************\n', '  // We don\'t use this event as we don\'t use "controllerTransfer"\n', '  //   event ControllerTransfer(\n', '  //       address controller,\n', '  //       address indexed from,\n', '  //       address indexed to,\n', '  //       uint256 value,\n', '  //       bytes data,\n', '  //       bytes operatorData\n', '  //   );\n', '  //\n', '  // We don\'t use this event as we don\'t use "controllerRedeem"\n', '  //   event ControllerRedemption(\n', '  //       address controller,\n', '  //       address indexed tokenHolder,\n', '  //       uint256 value,\n', '  //       bytes data,\n', '  //       bytes operatorData\n', '  //   );\n', '\n', '  // ******************** Document Events *********************\n', '  event Document(bytes32 indexed name, string uri, bytes32 documentHash);\n', '\n', '  // ******************** Transfer Events *********************\n', '  event TransferByPartition(\n', '      bytes32 indexed fromPartition,\n', '      address operator,\n', '      address indexed from,\n', '      address indexed to,\n', '      uint256 value,\n', '      bytes data,\n', '      bytes operatorData\n', '  );\n', '\n', '  event ChangedPartition(\n', '      bytes32 indexed fromPartition,\n', '      bytes32 indexed toPartition,\n', '      uint256 value\n', '  );\n', '\n', '  // ******************** Operator Events *********************\n', '  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n', '  event RevokedOperator(address indexed operator, address indexed tokenHolder);\n', '  event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n', '  event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\n', '\n', '  // ************** Issuance / Redemption Events **************\n', '  event Issued(address indexed operator, address indexed to, uint256 value, bytes data);\n', '  event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data);\n', '  event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\n', '  event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes operatorData);\n', '\n', '}\n', '\n', '/**\n', ' * Reason codes - ERC-1066\n', ' *\n', ' * To improve the token holder experience, canTransfer MUST return a reason byte code\n', ' * on success or failure based on the ERC-1066 application-specific status codes specified below.\n', ' * An implementation can also return arbitrary data as a bytes32 to provide additional\n', ' * information not captured by the reason code.\n', ' * \n', ' * Code\tReason\n', ' * 0x50\ttransfer failure\n', ' * 0x51\ttransfer success\n', ' * 0x52\tinsufficient balance\n', ' * 0x53\tinsufficient allowance\n', ' * 0x54\ttransfers halted (contract paused)\n', ' * 0x55\tfunds locked (lockup period)\n', ' * 0x56\tinvalid sender\n', ' * 0x57\tinvalid receiver\n', ' * 0x58\tinvalid operator (transfer agent)\n', ' * 0x59\t\n', ' * 0x5a\t\n', ' * 0x5b\t\n', ' * 0x5a\t\n', ' * 0x5b\t\n', ' * 0x5c\t\n', ' * 0x5d\t\n', ' * 0x5e\t\n', ' * 0x5f\ttoken meta or info\n', ' *\n', ' * These codes are being discussed at: https://ethereum-magicians.org/t/erc-1066-ethereum-status-codes-esc/283/24\n', ' */\n', '\n', '/*\n', ' * This code has not been reviewed.\n', ' * Do not use or deploy this code before reviewing it personally first.\n', ' */\n', '\n', '\n', '/**\n', ' * @title IERC1400TokensValidator\n', ' * @dev ERC1400TokensValidator interface\n', ' */\n', 'interface IERC1400TokensValidator {\n', '\n', '  function canValidate(\n', '    address token,\n', '    bytes4 functionSig,\n', '    bytes32 partition,\n', '    address operator,\n', '    address from,\n', '    address to,\n', '    uint value,\n', '    bytes calldata data,\n', '    bytes calldata operatorData\n', '  ) external view returns(bool);\n', '\n', '  function tokensToValidate(\n', '    bytes4 functionSig,\n', '    bytes32 partition,\n', '    address operator,\n', '    address from,\n', '    address to,\n', '    uint value,\n', '    bytes calldata data,\n', '    bytes calldata operatorData\n', '  ) external;\n', '\n', '}\n', '\n', '/*\n', ' * This code has not been reviewed.\n', ' * Do not use or deploy this code before reviewing it personally first.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @notice Interface to the Minterrole contract\n', ' */\n', 'interface IMinterRole {\n', '  function isMinter(address account) external view returns (bool);\n', '}\n', '\n', '\n', 'contract ERC1400TokensValidator is IERC1400TokensValidator, Pausable, AllowlistedRole, BlocklistedRole, ERC1820Client, ERC1820Implementer {\n', '  using SafeMath for uint256;\n', '\n', '  string constant internal ERC1400_TOKENS_VALIDATOR = "ERC1400TokensValidator";\n', '\n', '  bytes4 constant internal ERC20_TRANSFER_FUNCTION_ID = bytes4(keccak256("transfer(address,uint256)"));\n', '  bytes4 constant internal ERC20_TRANSFERFROM_FUNCTION_ID = bytes4(keccak256("transferFrom(address,address,uint256)"));\n', '\n', '  // Mapping from token to allowlist activation status.\n', '  mapping(address => bool) internal _allowlistActivated;\n', '\n', '  // Mapping from token to blocklist activation status.\n', '  mapping(address => bool) internal _blocklistActivated;\n', '\n', '  // Mapping from token to partition granularity activation status.\n', '  mapping(address => bool) internal _granularityByPartitionActivated;\n', '\n', '  // Mapping from token to holds activation status.\n', '  mapping(address => bool) internal _holdsActivated;\n', '\n', '  // Mapping from token to self-holds activation status.\n', '  mapping(address => bool) internal _selfHoldsActivated;\n', '\n', '  // Mapping from token to token controllers.\n', '  mapping(address => address[]) internal _tokenControllers;\n', '\n', '  // Mapping from (token, operator) to token controller status.\n', '  mapping(address => mapping(address => bool)) internal _isTokenController;\n', '\n', '  enum HoldStatusCode {\n', '    Nonexistent,\n', '    Ordered,\n', '    Executed,\n', '    ExecutedAndKeptOpen,\n', '    ReleasedByNotary,\n', '    ReleasedByPayee,\n', '    ReleasedOnExpiration\n', '  }\n', '\n', '  struct Hold {\n', '    bytes32 partition;\n', '    address sender;\n', '    address recipient;\n', '    address notary;\n', '    uint256 value;\n', '    uint256 expiration;\n', '    bytes32 secretHash;\n', '    bytes32 secret;\n', '    HoldStatusCode status;\n', '  }\n', '\n', '  // Mapping from (token, partition) to partition granularity.\n', '  mapping(address => mapping(bytes32 => uint256)) internal _granularityByPartition;\n', '  \n', '  // Mapping from (token, holdId) to hold.\n', '  mapping(address => mapping(bytes32 => Hold)) internal _holds;\n', '\n', '  // Mapping from (token, tokenHolder) to balance on hold.\n', '  mapping(address => mapping(address => uint256)) internal _heldBalance;\n', '\n', '  // Mapping from (token, tokenHolder, partition) to balance on hold of corresponding partition.\n', '  mapping(address => mapping(address => mapping(bytes32 => uint256))) internal _heldBalanceByPartition;\n', '\n', '  // Mapping from (token, partition) to global balance on hold of corresponding partition.\n', '  mapping(address => mapping(bytes32 => uint256)) internal _totalHeldBalanceByPartition;\n', '\n', '  // Total balance on hold.\n', '  mapping(address => uint256) internal _totalHeldBalance;\n', '\n', "  // Mapping from hold parameter's hash to hold's nonce.\n", '  mapping(bytes32 => uint256) internal _hashNonce;\n', '\n', '  // Mapping from (hash, nonce) to hold ID.\n', '  mapping(bytes32 => mapping(uint256 => bytes32)) internal _holdIds;\n', '\n', '  event HoldCreated(\n', '    address indexed token,\n', '    bytes32 indexed holdId,\n', '    bytes32 partition,\n', '    address sender,\n', '    address recipient,\n', '    address indexed notary,\n', '    uint256 value,\n', '    uint256 expiration,\n', '    bytes32 secretHash\n', '  );\n', '  event HoldReleased(address indexed token, bytes32 holdId, address indexed notary, HoldStatusCode status);\n', '  event HoldRenewed(address indexed token, bytes32 holdId, address indexed notary, uint256 oldExpiration, uint256 newExpiration);\n', '  event HoldExecuted(address indexed token, bytes32 holdId, address indexed notary, uint256 heldValue, uint256 transferredValue, bytes32 secret);\n', '  event HoldExecutedAndKeptOpen(address indexed token, bytes32 holdId, address indexed notary, uint256 heldValue, uint256 transferredValue, bytes32 secret);\n', '  \n', '  /**\n', '   * @dev Modifier to verify if sender is a token controller.\n', '   */\n', '  modifier onlyTokenController(address token) {\n', '    require(\n', '      msg.sender == token ||\n', '      msg.sender == Ownable(token).owner() ||\n', '      _isTokenController[token][msg.sender],\n', '      "Sender is not a token controller."\n', '    );\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to verify if sender is a pauser.\n', '   */\n', '  modifier onlyPauser(address token) {\n', '    require(\n', '      msg.sender == Ownable(token).owner() ||\n', '      _isTokenController[token][msg.sender] ||\n', '      isPauser(token, msg.sender),\n', '      "Sender is not a pauser"\n', '    );\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to verify if sender is an allowlist admin.\n', '   */\n', '  modifier onlyAllowlistAdmin(address token) {\n', '    require(\n', '      msg.sender == Ownable(token).owner() ||\n', '      _isTokenController[token][msg.sender] ||\n', '      isAllowlistAdmin(token, msg.sender),\n', '      "Sender is not an allowlist admin"\n', '    );\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to verify if sender is a blocklist admin.\n', '   */\n', '  modifier onlyBlocklistAdmin(address token) {\n', '    require(\n', '      msg.sender == Ownable(token).owner() ||\n', '      _isTokenController[token][msg.sender] ||\n', '      isBlocklistAdmin(token, msg.sender),\n', '      "Sender is not a blocklist admin"\n', '    );\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    ERC1820Implementer._setInterface(ERC1400_TOKENS_VALIDATOR);\n', '  }\n', '\n', '  /**\n', '   * @dev Get the list of token controllers for a given token.\n', '   * @return Setup of a given token.\n', '   */\n', '  function retrieveTokenSetup(address token) external view returns (bool, bool, bool, bool, bool, address[] memory) {\n', '    return (\n', '      _allowlistActivated[token],\n', '      _blocklistActivated[token],\n', '      _granularityByPartitionActivated[token],\n', '      _holdsActivated[token],\n', '      _selfHoldsActivated[token],\n', '      _tokenControllers[token]\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Register token setup.\n', '   */\n', '  function registerTokenSetup(\n', '    address token,\n', '    bool allowlistActivated,\n', '    bool blocklistActivated,\n', '    bool granularityByPartitionActivated,\n', '    bool holdsActivated,\n', '    bool selfHoldsActivated,\n', '    address[] calldata operators\n', '  ) external onlyTokenController(token) {\n', '    _allowlistActivated[token] = allowlistActivated;\n', '    _blocklistActivated[token] = blocklistActivated;\n', '    _granularityByPartitionActivated[token] = granularityByPartitionActivated;\n', '    _holdsActivated[token] = holdsActivated;\n', '    _selfHoldsActivated[token] = selfHoldsActivated;\n', '    _setTokenControllers(token, operators);\n', '  }\n', '\n', '  /**\n', '   * @dev Set list of token controllers for a given token.\n', '   * @param token Token address.\n', '   * @param operators Operators addresses.\n', '   */\n', '  function _setTokenControllers(address token, address[] memory operators) internal {\n', '    for (uint i = 0; i<_tokenControllers[token].length; i++){\n', '      _isTokenController[token][_tokenControllers[token][i]] = false;\n', '    }\n', '    for (uint j = 0; j<operators.length; j++){\n', '      _isTokenController[token][operators[j]] = true;\n', '    }\n', '    _tokenControllers[token] = operators;\n', '  }\n', '\n', '  /**\n', "   * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n", '   * @param token Address of the token.\n', '   * @param functionSig ID of the function that is called.\n', '   * @param partition Name of the partition (left empty for ERC20 transfer).\n', '   * @param operator Address which triggered the balance decrease (through transfer or redemption).\n', '   * @param from Token holder.\n', '   * @param to Token recipient for a transfer and 0x for a redemption.\n', '   * @param value Number of tokens the token holder balance is decreased by.\n', '   * @param data Extra information.\n', '   * @param operatorData Extra information, attached by the operator (if any).\n', "   * @return 'true' if the token transfer can be validated, 'false' if not.\n", '   */\n', '  function canValidate(\n', '    address token,\n', '    bytes4 functionSig,\n', '    bytes32 partition,\n', '    address operator,\n', '    address from,\n', '    address to,\n', '    uint value,\n', '    bytes calldata data,\n', '    bytes calldata operatorData\n', '  ) // Comments to avoid compilation warnings for unused variables.\n', '    external\n', '    view \n', '    returns(bool)\n', '  {\n', '    (bool canValidateToken,) = _canValidate(token, functionSig, partition, operator, from, to, value, data, operatorData);\n', '    return canValidateToken;\n', '  }\n', '\n', '  /**\n', '   * @dev Function called by the token contract before executing a transfer.\n', '   * @param functionSig ID of the function that is called.\n', '   * @param partition Name of the partition (left empty for ERC20 transfer).\n', '   * @param operator Address which triggered the balance decrease (through transfer or redemption).\n', '   * @param from Token holder.\n', '   * @param to Token recipient for a transfer and 0x for a redemption.\n', '   * @param value Number of tokens the token holder balance is decreased by.\n', '   * @param data Extra information.\n', '   * @param operatorData Extra information, attached by the operator (if any).\n', "   * @return 'true' if the token transfer can be validated, 'false' if not.\n", '   */\n', '  function tokensToValidate(\n', '    bytes4 functionSig,\n', '    bytes32 partition,\n', '    address operator,\n', '    address from,\n', '    address to,\n', '    uint value,\n', '    bytes calldata data,\n', '    bytes calldata operatorData\n', '  ) // Comments to avoid compilation warnings for unused variables.\n', '    external\n', '  {\n', '    (bool canValidateToken, bytes32 holdId) = _canValidate(msg.sender, functionSig, partition, operator, from, to, value, data, operatorData);\n', '    require(canValidateToken, "55"); // 0x55\tfunds locked (lockup period)\n', '\n', '    if (_holdsActivated[msg.sender] && holdId != "") {\n', '      Hold storage executableHold = _holds[msg.sender][holdId];\n', '      _setHoldToExecuted(\n', '        msg.sender,\n', '        executableHold,\n', '        holdId,\n', '        value,\n', '        executableHold.value,\n', '        ""\n', '      );\n', '    }\n', '  }\n', '\n', '  /**\n', "   * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\n", "   * @return 'true' if the token transfer can be validated, 'false' if not.\n", '   * @return hold ID in case a hold can be executed for the given parameters.\n', '   */\n', '  function _canValidate(\n', '    address token,\n', '    bytes4 functionSig,\n', '    bytes32 partition,\n', '    address operator,\n', '    address from,\n', '    address to,\n', '    uint value,\n', '    bytes memory /*data*/,\n', '    bytes memory /*operatorData*/\n', '  ) // Comments to avoid compilation warnings for unused variables.\n', '    internal\n', '    view\n', '    whenNotPaused(token)\n', '    returns(bool, bytes32)\n', '  {\n', '    if(_functionRequiresValidation(functionSig)) {\n', '      if(_allowlistActivated[token]) {\n', '        if(!isAllowlisted(token, from) || !isAllowlisted(token, to)) {\n', '          return (false, "");\n', '        }\n', '      }\n', '      if(_blocklistActivated[token]) {\n', '        if(isBlocklisted(token, from) || isBlocklisted(token, to)) {\n', '          return (false, "");\n', '        }\n', '      }\n', '    }\n', '\n', '    if(_granularityByPartitionActivated[token]) {\n', '      if(\n', '        _granularityByPartition[token][partition] > 0 &&\n', '        !_isMultiple(_granularityByPartition[token][partition], value)\n', '      ) {\n', '        return (false, "");\n', '      } \n', '    }\n', '\n', '    if (_holdsActivated[token]) {\n', '      if(functionSig == ERC20_TRANSFERFROM_FUNCTION_ID) {\n', '        (,, bytes32 holdId) = _retrieveHoldHashNonceId(token, partition, operator, from, to, value);\n', '        Hold storage hold = _holds[token][holdId];\n', '        \n', '        if (_holdCanBeExecutedAsNotary(hold, operator, value) && value <= IERC1400(token).balanceOfByPartition(partition, from)) {\n', '          return (true, holdId);\n', '        }\n', '      }\n', '      \n', '      if(value > _spendableBalanceOfByPartition(token, partition, from)) {\n', '        return (false, "");\n', '      }\n', '    }\n', '    \n', '    return (true, "");\n', '  }\n', '\n', '  /**\n', '   * @dev Get granularity for a given partition.\n', '   * @param token Address of the token.\n', '   * @param partition Name of the partition.\n', '   * @return Granularity of the partition.\n', '   */\n', '  function granularityByPartition(address token, bytes32 partition) external view returns (uint256) {\n', '    return _granularityByPartition[token][partition];\n', '  }\n', '  \n', '  /**\n', '   * @dev Set partition granularity\n', '   */\n', '  function setGranularityByPartition(\n', '    address token,\n', '    bytes32 partition,\n', '    uint256 granularity\n', '  )\n', '    external\n', '    onlyTokenController(token)\n', '  {\n', '    _granularityByPartition[token][partition] = granularity;\n', '  }\n', '\n', '  /**\n', '   * @dev Create a new token pre-hold.\n', '   */\n', '  function preHoldFor(\n', '    address token,\n', '    bytes32 holdId,\n', '    address recipient,\n', '    address notary,\n', '    bytes32 partition,\n', '    uint256 value,\n', '    uint256 timeToExpiration,\n', '    bytes32 secretHash\n', '  )\n', '    external\n', '    returns (bool)\n', '  {\n', '    return _createHold(\n', '      token,\n', '      holdId,\n', '      address(0),\n', '      recipient,\n', '      notary,\n', '      partition,\n', '      value,\n', '      _computeExpiration(timeToExpiration),\n', '      secretHash\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Create a new token pre-hold with expiration date.\n', '   */\n', '  function preHoldForWithExpirationDate(\n', '    address token,\n', '    bytes32 holdId,\n', '    address recipient,\n', '    address notary,\n', '    bytes32 partition,\n', '    uint256 value,\n', '    uint256 expiration,\n', '    bytes32 secretHash\n', '  )\n', '    external\n', '    returns (bool)\n', '  {\n', '    _checkExpiration(expiration);\n', '\n', '    return _createHold(\n', '      token,\n', '      holdId,\n', '      address(0),\n', '      recipient,\n', '      notary,\n', '      partition,\n', '      value,\n', '      expiration,\n', '      secretHash\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Create a new token hold.\n', '   */\n', '  function hold(\n', '    address token,\n', '    bytes32 holdId,\n', '    address recipient,\n', '    address notary,\n', '    bytes32 partition,\n', '    uint256 value,\n', '    uint256 timeToExpiration,\n', '    bytes32 secretHash\n', '  ) \n', '    external\n', '    returns (bool)\n', '  {\n', '    return _createHold(\n', '      token,\n', '      holdId,\n', '      msg.sender,\n', '      recipient,\n', '      notary,\n', '      partition,\n', '      value,\n', '      _computeExpiration(timeToExpiration),\n', '      secretHash\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Create a new token hold on behalf of the token holder.\n', '   */\n', '  function holdFrom(\n', '    address token,\n', '    bytes32 holdId,\n', '    address sender,\n', '    address recipient,\n', '    address notary,\n', '    bytes32 partition,\n', '    uint256 value,\n', '    uint256 timeToExpiration,\n', '    bytes32 secretHash\n', '  )\n', '    external\n', '    returns (bool)\n', '  {\n', '    require(sender != address(0), "Payer address must not be zero address");\n', '    return _createHold(\n', '      token,\n', '      holdId,\n', '      sender,\n', '      recipient,\n', '      notary,\n', '      partition,\n', '      value,\n', '      _computeExpiration(timeToExpiration),\n', '      secretHash\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Create a new token hold with expiration date.\n', '   */\n', '  function holdWithExpirationDate(\n', '    address token,\n', '    bytes32 holdId,\n', '    address recipient,\n', '    address notary,\n', '    bytes32 partition,\n', '    uint256 value,\n', '    uint256 expiration,\n', '    bytes32 secretHash\n', '  )\n', '    external\n', '    returns (bool)\n', '  {\n', '    _checkExpiration(expiration);\n', '\n', '    return _createHold(\n', '      token,\n', '      holdId,\n', '      msg.sender,\n', '      recipient,\n', '      notary,\n', '      partition,\n', '      value,\n', '      expiration,\n', '      secretHash\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Create a new token hold with expiration date on behalf of the token holder.\n', '   */\n', '  function holdFromWithExpirationDate(\n', '    address token,\n', '    bytes32 holdId,\n', '    address sender,\n', '    address recipient,\n', '    address notary,\n', '    bytes32 partition,\n', '    uint256 value,\n', '    uint256 expiration,\n', '    bytes32 secretHash\n', '  )\n', '    external\n', '    returns (bool)\n', '  {\n', '    _checkExpiration(expiration);\n', '    require(sender != address(0), "Payer address must not be zero address");\n', '\n', '    return _createHold(\n', '      token,\n', '      holdId,\n', '      sender,\n', '      recipient,\n', '      notary,\n', '      partition,\n', '      value,\n', '      expiration,\n', '      secretHash\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Create a new token hold.\n', '   */\n', '  function _createHold(\n', '    address token,\n', '    bytes32 holdId,\n', '    address sender,\n', '    address recipient,\n', '    address notary,\n', '    bytes32 partition,\n', '    uint256 value,\n', '    uint256 expiration,\n', '    bytes32 secretHash\n', '  ) internal returns (bool)\n', '  {\n', '    Hold storage newHold = _holds[token][holdId];\n', '\n', '    require(recipient != address(0), "Payee address must not be zero address");\n', '    require(value != 0, "Value must be greater than zero");\n', '    require(newHold.value == 0, "This holdId already exists");\n', '    require(notary != address(0), "Notary address must not be zero address");\n', '    \n', '    if (sender == address(0)) { // pre-hold (tokens do not already exist)\n', '      require(\n', '        _canPreHold(token, msg.sender),\n', '        "The pre-hold can only be created by the minter"\n', '      );\n', '    } else { // post-hold (tokens already exist)\n', '      require(value <= _spendableBalanceOfByPartition(token, partition, sender), "Amount of the hold can\'t be greater than the spendable balance of the sender");\n', '      require(\n', '        _canPostHold(token, partition, msg.sender, sender),\n', '        "The hold can only be renewed by the issuer or the payer"\n', '      );\n', '    }\n', '    \n', '    newHold.partition = partition;\n', '    newHold.sender = sender;\n', '    newHold.recipient = recipient;\n', '    newHold.notary = notary;\n', '    newHold.value = value;\n', '    newHold.expiration = expiration;\n', '    newHold.secretHash = secretHash;\n', '    newHold.status = HoldStatusCode.Ordered;\n', '\n', '    if(sender != address(0)) {\n', '      // In case tokens already exist, increase held balance\n', '      _increaseHeldBalance(token, newHold, holdId);\n', '    }\n', '\n', '    emit HoldCreated(\n', '      token,\n', '      holdId,\n', '      partition,\n', '      sender,\n', '      recipient,\n', '      notary,\n', '      value,\n', '      expiration,\n', '      secretHash\n', '    );\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Release token hold.\n', '   */\n', '  function releaseHold(address token, bytes32 holdId) external returns (bool) {\n', '    return _releaseHold(token, holdId);\n', '  }\n', '\n', '  /**\n', '   * @dev Release token hold.\n', '   */\n', '  function _releaseHold(address token, bytes32 holdId) internal returns (bool) {\n', '    Hold storage releasableHold = _holds[token][holdId];\n', '\n', '    require(\n', '        releasableHold.status == HoldStatusCode.Ordered || releasableHold.status == HoldStatusCode.ExecutedAndKeptOpen,\n', '        "A hold can only be released in status Ordered or ExecutedAndKeptOpen"\n', '    );\n', '    require(\n', '        _isExpired(releasableHold.expiration) ||\n', '        (msg.sender == releasableHold.notary) ||\n', '        (msg.sender == releasableHold.recipient),\n', '        "A not expired hold can only be released by the notary or the payee"\n', '    );\n', '\n', '    if (_isExpired(releasableHold.expiration)) {\n', '        releasableHold.status = HoldStatusCode.ReleasedOnExpiration;\n', '    } else {\n', '        if (releasableHold.notary == msg.sender) {\n', '            releasableHold.status = HoldStatusCode.ReleasedByNotary;\n', '        } else {\n', '            releasableHold.status = HoldStatusCode.ReleasedByPayee;\n', '        }\n', '    }\n', '\n', '    if(releasableHold.sender != address(0)) { // In case tokens already exist, decrease held balance\n', '      _decreaseHeldBalance(token, releasableHold, releasableHold.value);\n', '    }\n', '\n', '    emit HoldReleased(token, holdId, releasableHold.notary, releasableHold.status);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Renew hold.\n', '   */\n', '  function renewHold(address token, bytes32 holdId, uint256 timeToExpiration) external returns (bool) {\n', '    return _renewHold(token, holdId, _computeExpiration(timeToExpiration));\n', '  }\n', '\n', '  /**\n', '   * @dev Renew hold with expiration time.\n', '   */\n', '  function renewHoldWithExpirationDate(address token, bytes32 holdId, uint256 expiration) external returns (bool) {\n', '    _checkExpiration(expiration);\n', '\n', '    return _renewHold(token, holdId, expiration);\n', '  }\n', '\n', '  /**\n', '   * @dev Renew hold.\n', '   */\n', '  function _renewHold(address token, bytes32 holdId, uint256 expiration) internal returns (bool) {\n', '    Hold storage renewableHold = _holds[token][holdId];\n', '\n', '    require(\n', '      renewableHold.status == HoldStatusCode.Ordered\n', '      || renewableHold.status == HoldStatusCode.ExecutedAndKeptOpen,\n', '      "A hold can only be renewed in status Ordered or ExecutedAndKeptOpen"\n', '    );\n', '    require(!_isExpired(renewableHold.expiration), "An expired hold can not be renewed");\n', '\n', '    if (renewableHold.sender == address(0)) { // pre-hold (tokens do not already exist)\n', '      require(\n', '        _canPreHold(token, msg.sender),\n', '        "The pre-hold can only be renewed by the minter"\n', '      );\n', '    } else { // post-hold (tokens already exist)\n', '      require(\n', '        _canPostHold(token, renewableHold.partition, msg.sender, renewableHold.sender),\n', '        "The hold can only be renewed by the issuer or the payer"\n', '      );\n', '    }\n', '    \n', '    uint256 oldExpiration = renewableHold.expiration;\n', '    renewableHold.expiration = expiration;\n', '\n', '    emit HoldRenewed(\n', '      token,\n', '      holdId,\n', '      renewableHold.notary,\n', '      oldExpiration,\n', '      expiration\n', '    );\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Execute hold.\n', '   */\n', '  function executeHold(address token, bytes32 holdId, uint256 value, bytes32 secret) external returns (bool) {\n', '    return _executeHold(\n', '      token,\n', '      holdId,\n', '      msg.sender,\n', '      value,\n', '      secret,\n', '      false\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Execute hold and keep open.\n', '   */\n', '  function executeHoldAndKeepOpen(address token, bytes32 holdId, uint256 value, bytes32 secret) external returns (bool) {\n', '    return _executeHold(\n', '      token,\n', '      holdId,\n', '      msg.sender,\n', '      value,\n', '      secret,\n', '      true\n', '    );\n', '  }\n', '  \n', '  /**\n', '   * @dev Execute hold.\n', '   */\n', '  function _executeHold(\n', '    address token,\n', '    bytes32 holdId,\n', '    address operator,\n', '    uint256 value,\n', '    bytes32 secret,\n', '    bool keepOpenIfHoldHasBalance\n', '  ) internal returns (bool)\n', '  {\n', '    Hold storage executableHold = _holds[token][holdId];\n', '\n', '    bool canExecuteHold;\n', '    if(secret != "" && _holdCanBeExecutedAsSecretHolder(executableHold, value, secret)) {\n', '      executableHold.secret = secret;\n', '      canExecuteHold = true;\n', '    } else if(_holdCanBeExecutedAsNotary(executableHold, operator, value)) {\n', '      canExecuteHold = true;\n', '    }\n', '\n', '    if(canExecuteHold) {\n', '      if (keepOpenIfHoldHasBalance && ((executableHold.value - value) > 0)) {\n', '        _setHoldToExecutedAndKeptOpen(\n', '          token,\n', '          executableHold,\n', '          holdId,\n', '          value,\n', '          value,\n', '          secret\n', '        );\n', '      } else {\n', '        _setHoldToExecuted(\n', '          token,\n', '          executableHold,\n', '          holdId,\n', '          value,\n', '          executableHold.value,\n', '          secret\n', '        );\n', '      }\n', '\n', '      if (executableHold.sender == address(0)) { // pre-hold (tokens do not already exist)\n', '        IERC1400(token).issueByPartition(executableHold.partition, executableHold.recipient, value, "");\n', '      } else { // post-hold (tokens already exist)\n', '        IERC1400(token).operatorTransferByPartition(executableHold.partition, executableHold.sender, executableHold.recipient, value, "", "");\n', '      }\n', '      \n', '    } else {\n', '      revert("hold can not be executed");\n', '    }\n', '\n', '  }\n', '\n', '  /**\n', '   * @dev Set hold to executed.\n', '   */\n', '  function _setHoldToExecuted(\n', '    address token,\n', '    Hold storage executableHold,\n', '    bytes32 holdId,\n', '    uint256 value,\n', '    uint256 heldBalanceDecrease,\n', '    bytes32 secret\n', '  ) internal\n', '  {\n', '    if(executableHold.sender != address(0)) { // In case tokens already exist, decrease held balance\n', '      _decreaseHeldBalance(token, executableHold, heldBalanceDecrease);\n', '    }\n', '\n', '    executableHold.status = HoldStatusCode.Executed;\n', '\n', '    emit HoldExecuted(\n', '      token,\n', '      holdId,\n', '      executableHold.notary,\n', '      executableHold.value,\n', '      value,\n', '      secret\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Set hold to executed and kept open.\n', '   */\n', '  function _setHoldToExecutedAndKeptOpen(\n', '    address token,\n', '    Hold storage executableHold,\n', '    bytes32 holdId,\n', '    uint256 value,\n', '    uint256 heldBalanceDecrease,\n', '    bytes32 secret\n', '  ) internal\n', '  {\n', '    if(executableHold.sender != address(0)) { // In case tokens already exist, decrease held balance\n', '      _decreaseHeldBalance(token, executableHold, heldBalanceDecrease);\n', '    } \n', '\n', '    executableHold.status = HoldStatusCode.ExecutedAndKeptOpen;\n', '    executableHold.value = executableHold.value.sub(value);\n', '\n', '    emit HoldExecutedAndKeptOpen(\n', '      token,\n', '      holdId,\n', '      executableHold.notary,\n', '      executableHold.value,\n', '      value,\n', '      secret\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Increase held balance.\n', '   */\n', '  function _increaseHeldBalance(address token, Hold storage executableHold, bytes32 holdId) private {\n', '    _heldBalance[token][executableHold.sender] = _heldBalance[token][executableHold.sender].add(executableHold.value);\n', '    _totalHeldBalance[token] = _totalHeldBalance[token].add(executableHold.value);\n', '\n', '    _heldBalanceByPartition[token][executableHold.sender][executableHold.partition] = _heldBalanceByPartition[token][executableHold.sender][executableHold.partition].add(executableHold.value);\n', '    _totalHeldBalanceByPartition[token][executableHold.partition] = _totalHeldBalanceByPartition[token][executableHold.partition].add(executableHold.value);\n', '\n', '    _increaseNonce(token, executableHold, holdId);\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease held balance.\n', '   */\n', '  function _decreaseHeldBalance(address token, Hold storage executableHold, uint256 value) private {\n', '    _heldBalance[token][executableHold.sender] = _heldBalance[token][executableHold.sender].sub(value);\n', '    _totalHeldBalance[token] = _totalHeldBalance[token].sub(value);\n', '\n', '    _heldBalanceByPartition[token][executableHold.sender][executableHold.partition] = _heldBalanceByPartition[token][executableHold.sender][executableHold.partition].sub(value);\n', '    _totalHeldBalanceByPartition[token][executableHold.partition] = _totalHeldBalanceByPartition[token][executableHold.partition].sub(value);\n', '\n', '    if(executableHold.status == HoldStatusCode.Ordered) {\n', '      _decreaseNonce(token, executableHold);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Increase nonce.\n', '   */\n', '  function _increaseNonce(address token, Hold storage executableHold, bytes32 holdId) private {\n', '    (bytes32 holdHash, uint256 nonce,) = _retrieveHoldHashNonceId(\n', '      token, executableHold.partition,\n', '      executableHold.notary,\n', '      executableHold.sender,\n', '      executableHold.recipient,\n', '      executableHold.value\n', '    );\n', '    _hashNonce[holdHash] = nonce.add(1);\n', '    _holdIds[holdHash][nonce.add(1)] = holdId;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease nonce.\n', '   */\n', '  function _decreaseNonce(address token, Hold storage executableHold) private {\n', '    (bytes32 holdHash, uint256 nonce,) = _retrieveHoldHashNonceId(\n', '      token,\n', '      executableHold.partition,\n', '      executableHold.notary,\n', '      executableHold.sender,\n', '      executableHold.recipient,\n', '      executableHold.value\n', '    );\n', '    _holdIds[holdHash][nonce] = "";\n', '    _hashNonce[holdHash] = _hashNonce[holdHash].sub(1);\n', '  }\n', '\n', '  /**\n', '   * @dev Check secret.\n', '   */\n', '  function _checkSecret(Hold storage executableHold, bytes32 secret) internal view returns (bool) {\n', '    if(executableHold.secretHash == sha256(abi.encodePacked(secret))) {\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Compute expiration time.\n', '   */\n', '  function _computeExpiration(uint256 timeToExpiration) internal view returns (uint256) {\n', '    uint256 expiration = 0;\n', '\n', '    if (timeToExpiration != 0) {\n', '        expiration = now.add(timeToExpiration);\n', '    }\n', '\n', '    return expiration;\n', '  }\n', '\n', '  /**\n', '   * @dev Check expiration time.\n', '   */\n', '  function _checkExpiration(uint256 expiration) private view {\n', '    require(expiration > now || expiration == 0, "Expiration date must be greater than block timestamp or zero");\n', '  }\n', '\n', '  /**\n', '   * @dev Check is expiration date is past.\n', '   */\n', '  function _isExpired(uint256 expiration) internal view returns (bool) {\n', '    return expiration != 0 && (now >= expiration);\n', '  }\n', '\n', '  /**\n', '   * @dev Retrieve hold hash, nonce, and ID for given parameters\n', '   */\n', '  function _retrieveHoldHashNonceId(address token, bytes32 partition, address notary, address sender, address recipient, uint value) internal view returns (bytes32, uint256, bytes32) {\n', '    // Pack and hash hold parameters\n', '    bytes32 holdHash = keccak256(abi.encodePacked(\n', '      token,\n', '      partition,\n', '      sender,\n', '      recipient,\n', '      notary,\n', '      value\n', '    ));\n', '    uint256 nonce = _hashNonce[holdHash];\n', '    bytes32 holdId = _holdIds[holdHash][nonce];\n', '\n', '    return (holdHash, nonce, holdId);\n', '  }  \n', '\n', '  /**\n', '   * @dev Check if hold can be executed\n', '   */\n', '  function _holdCanBeExecuted(Hold storage executableHold, uint value) internal view returns (bool) {\n', '    if(!(executableHold.status == HoldStatusCode.Ordered || executableHold.status == HoldStatusCode.ExecutedAndKeptOpen)) {\n', '      return false; // A hold can only be executed in status Ordered or ExecutedAndKeptOpen\n', '    } else if(value == 0) {\n', '      return false; // Value must be greater than zero\n', '    } else if(_isExpired(executableHold.expiration)) {\n', '      return false; // The hold has already expired\n', '    } else if(value > executableHold.value) {\n', '      return false; // The value should be equal or less than the held amount\n', '    } else {\n', '      return true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Check if hold can be executed as secret holder\n', '   */\n', '  function _holdCanBeExecutedAsSecretHolder(Hold storage executableHold, uint value, bytes32 secret) internal view returns (bool) {\n', '    if(\n', '      _checkSecret(executableHold, secret)\n', '      && _holdCanBeExecuted(executableHold, value)) {\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Check if hold can be executed as notary\n', '   */\n', '  function _holdCanBeExecutedAsNotary(Hold storage executableHold, address operator, uint value) internal view returns (bool) {\n', '    if(\n', '      executableHold.notary == operator\n', '      && _holdCanBeExecuted(executableHold, value)) {\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }  \n', '\n', '  /**\n', '   * @dev Retrieve hold data.\n', '   */\n', '  function retrieveHoldData(address token, bytes32 holdId) external view returns (\n', '    bytes32 partition,\n', '    address sender,\n', '    address recipient,\n', '    address notary,\n', '    uint256 value,\n', '    uint256 expiration,\n', '    bytes32 secretHash,\n', '    bytes32 secret,\n', '    HoldStatusCode status)\n', '  {\n', '    Hold storage retrievedHold = _holds[token][holdId];\n', '    return (\n', '      retrievedHold.partition,\n', '      retrievedHold.sender,\n', '      retrievedHold.recipient,\n', '      retrievedHold.notary,\n', '      retrievedHold.value,\n', '      retrievedHold.expiration,\n', '      retrievedHold.secretHash,\n', '      retrievedHold.secret,\n', '      retrievedHold.status\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Total supply on hold.\n', '   */\n', '  function totalSupplyOnHold(address token) external view returns (uint256) {\n', '    return _totalHeldBalance[token];\n', '  }\n', '\n', '  /**\n', '   * @dev Total supply on hold for a specific partition.\n', '   */\n', '  function totalSupplyOnHoldByPartition(address token, bytes32 partition) external view returns (uint256) {\n', '    return _totalHeldBalanceByPartition[token][partition];\n', '  }\n', '\n', '  /**\n', '   * @dev Get balance on hold of a tokenholder.\n', '   */\n', '  function balanceOnHold(address token, address account) external view returns (uint256) {\n', '    return _heldBalance[token][account];\n', '  }\n', '\n', '  /**\n', '   * @dev Get balance on hold of a tokenholder for a specific partition.\n', '   */\n', '  function balanceOnHoldByPartition(address token, bytes32 partition, address account) external view returns (uint256) {\n', '    return _heldBalanceByPartition[token][account][partition];\n', '  }\n', '\n', '  /**\n', '   * @dev Get spendable balance of a tokenholder.\n', '   */\n', '  function spendableBalanceOf(address token, address account) external view returns (uint256) {\n', '    return _spendableBalanceOf(token, account);\n', '  }\n', '\n', '  /**\n', '   * @dev Get spendable balance of a tokenholder for a specific partition.\n', '   */\n', '  function spendableBalanceOfByPartition(address token, bytes32 partition, address account) external view returns (uint256) {\n', '    return _spendableBalanceOfByPartition(token, partition, account);\n', '  }\n', '\n', '  /**\n', '   * @dev Get spendable balance of a tokenholder.\n', '   */\n', '  function _spendableBalanceOf(address token, address account) internal view returns (uint256) {\n', '    return IERC20(token).balanceOf(account) - _heldBalance[token][account];\n', '  }\n', '\n', '  /**\n', '   * @dev Get spendable balance of a tokenholder for a specific partition.\n', '   */\n', '  function _spendableBalanceOfByPartition(address token, bytes32 partition, address account) internal view returns (uint256) {\n', '    return IERC1400(token).balanceOfByPartition(partition, account) - _heldBalanceByPartition[token][account][partition];\n', '  }\n', '\n', '  /************************** TOKEN CONTROLLERS *******************************/\n', '\n', '  /**\n', '   * @dev Check if operator can create pre-holds.\n', "   * @return 'true' if the operator can create pre-holds, 'false' if not.\n", '   */\n', '  function _canPreHold(address token, address operator) internal view returns(bool) { \n', '    return IMinterRole(token).isMinter(operator);\n', '  }\n', '\n', '  /**\n', '   * @dev Check if operator can create/update holds.\n', "   * @return 'true' if the operator can create/update holds, 'false' if not.\n", '   */\n', '  function _canPostHold(address token, bytes32 partition, address operator, address sender) internal view returns(bool) {    \n', '    if (_selfHoldsActivated[token]) {\n', '      return IERC1400(token).isOperatorForPartition(partition, operator, sender);\n', '    } else {\n', '      return _isTokenController[token][operator];\n', '    }\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Check if validator is activated for the function called in the smart contract.\n', '   * @param functionSig ID of the function that is called.\n', "   * @return 'true' if the function requires validation, 'false' if not.\n", '   */\n', '  function _functionRequiresValidation(bytes4 functionSig) internal pure returns(bool) {\n', '    if(_areEqual(functionSig, ERC20_TRANSFER_FUNCTION_ID) || _areEqual(functionSig, ERC20_TRANSFERFROM_FUNCTION_ID)) {\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Check if 2 variables of type bytes4 are identical.\n', "   * @return 'true' if 2 variables are identical, 'false' if not.\n", '   */\n', '  function _areEqual(bytes4 a, bytes4 b) internal pure returns(bool) {\n', '    for (uint256 i = 0; i < a.length; i++) {\n', '      if(a[i] != b[i]) {\n', '        return false;\n', '      }\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', "   * @dev Check if 'value' is multiple of 'granularity'.\n", "   * @param granularity The granularity that want's to be checked.\n", "   * @param value The quantity that want's to be checked.\n", "   * @return 'true' if 'value' is a multiple of 'granularity'.\n", '   */\n', '  function _isMultiple(uint256 granularity, uint256 value) internal pure returns(bool) {\n', '    return(value.div(granularity).mul(granularity) == value);\n', '  }\n', '\n', '}']