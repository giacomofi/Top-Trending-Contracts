['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-30\n', '*/\n', '\n', 'pragma solidity 0.4.24;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public pendingOwner;\n', '    mapping(address => bool) public managers;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event SetManager(address indexed owner, address indexed newManager);\n', '    event RemoveManager(address indexed owner, address indexed previousManager);\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "non-owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than a manager.\n', '     */\n', '    modifier onlyManager() {\n', '        require(managers[msg.sender], "non-manager");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () public {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the user(`account`) is the a manager.\n', '     */\n', '    function isManager(address _account) public view returns (bool) {\n', '        return managers[_account];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner_`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address _newOwner) external onlyOwner {\n', '        require(_newOwner != owner, "transferOwnership: the same owner.");\n', '        require(pendingOwner != _newOwner, "transferOwnership : the same pendingOwner.");\n', '        pendingOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Accepts ownership of the contract.\n', '     * Can only be called by the settting new owner(`pendingOwner`).\n', '     */\n', '    function acceptOwnership() external {\n', '        require(msg.sender == pendingOwner, "AcceptOwnership: only new owner do this.");\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Set a new user(`account`) as a manager.\n', '     * Can only be called by the current owner.\n', '     */\n', '    function setManager(address _account) external onlyOwner {\n', '        require(_account != address(0), "setManager: account cannot be a zero address.");\n', '        require(!isManager(_account), "setManager: Already a manager address.");\n', '        managers[_account] = true;\n', '        emit SetManager(owner, _account);\n', '    }\n', '\n', '    /**\n', '     * @dev Remove a previous manager account.\n', '     * Can only be called by the current owner.\n', '     */\n', '    function removeManager(address _account) external onlyOwner {\n', '        require(_account != address(0), "RemoveManager: _account cannot be a zero address.");\n', '        require(isManager(_account), "RemoveManager: Not an admin address.");\n', '        managers[_account] = false;\n', '        emit RemoveManager(owner, _account);\n', '    }\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '    bool public paused;\n', '\n', '    /**\n', '     * @dev Emitted when the pause is triggered by a pauser (`account`).\n', '     */\n', '    event Paused(address account);\n', '\n', '    /**\n', '     * @dev Emitted when the pause is lifted by a pauser (`account`).\n', '     */\n', '    event Unpaused(address account);\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused, "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused, "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n', '     * to the deployer.\n', '     */\n', '    constructor () internal {\n', '        paused = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Called by the contract owner to pause, triggers stopped state.\n', '     */\n', '    function pause() public whenNotPaused onlyOwner {\n', '        paused = true;\n', '        emit Paused(owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Called by the contract owner to unpause, returns to normal state.\n', '     */\n', '    function unpause() public whenPaused onlyOwner {\n', '        paused = false;\n', '        emit Unpaused(owner);\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function transfer(address _to, uint _value) external;\n', '    function transferFrom(address _from, address _to, uint _value) external;\n', '    function approve(address _spender, uint _value) external;\n', '    function balanceOf(address account) external view returns (uint);\n', '    function decimals() external view returns (uint);\n', '}\n', '\n', 'contract ERC20SafeTransfer {\n', '    function doTransferOut(address _token, address _to, uint _amount) internal returns (bool) {\n', '        IERC20 token = IERC20(_token);\n', '        bool result;\n', '\n', '        token.transfer(_to, _amount);\n', '\n', '        assembly {\n', '            switch returndatasize()\n', '                case 0 {\n', '                    result := not(0)\n', '                }\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    result := mload(0)\n', '                }\n', '                default {\n', '                    revert(0, 0)\n', '                }\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function doTransferFrom(address _token, address _from, address _to, uint _amount) internal returns (bool) {\n', '        IERC20 token = IERC20(_token);\n', '        bool result;\n', '\n', '        token.transferFrom(_from, _to, _amount);\n', '\n', '        assembly {\n', '            switch returndatasize()\n', '                case 0 {\n', '                    result := not(0)\n', '                }\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    result := mload(0)\n', '                }\n', '                default {\n', '                    revert(0, 0)\n', '                }\n', '        }\n', '        return result;\n', '    }\n', '}\n', '\n', 'contract ILendfMeData {\n', '    function getLiquidity(address account) public view returns (int);\n', '}\n', '\n', 'library DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '    function div(uint x, uint y) internal pure returns (uint z) {\n', '        require(y > 0, "ds-math-div-overflow");\n', '        z = x / y;\n', '    }\n', '}\n', '\n', 'contract Distribution is Pausable, ERC20SafeTransfer {\n', '    using DSMath for uint;\n', '    // --- Data ---\n', '    bool private initialized;                   // Flag of initialize data.\n', '\n', '    address public DF;\n', '    address public LendfMeData;\n', '\n', '    uint public start;                          // When will the contract start.\n', '    uint public step;                           // Duration of each period.\n', '\n', '    uint[] public distributionRatio;            // Accumulated distribution ratio based on every period.\n', '    uint public totalRatio;\n', '\n', '    uint public totalAmount;                    // Total amount of asset to distribute.\n', '    uint public totalLockedValue;               // Total net value.\n', '    mapping (address => uint) public claimed;   // Amount that user has claimed.\n', '    uint public totalClaimed;                   // Total amount of asset has claimed.\n', '\n', '    /**\n', '     * @dev emitted when user cliams.\n', '     */\n', '    event Claim(address _src, uint _amount);\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not expired.\n', '     */\n', '    modifier unclocked() {\n', '        require(start + step * distributionRatio.length.sub(1) >= now, "unclocked: Contract has been locked!");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * The constructor is used here to ensure that the implementation contract is initialized.\n', '     * An uncontrolled implementation contract might lead to misleading state for users who\n', '     * accidentally interact with it.\n', '     */\n', '    constructor(\n', '        address _token,\n', '        uint _totalAmount,\n', '        address _lendfMeData,\n', '        uint _totalLockedValue,\n', '        uint _start,\n', '        uint _step,\n', '        uint[] memory _distributionRatio\n', '    ) public {\n', '        initialize(_token, _totalAmount, _lendfMeData, _totalLockedValue, _start, _step, _distributionRatio);\n', '    }\n', '\n', '    // --- Init ---\n', '    // This function is used with contract proxy, do not modify this function.\n', '    function initialize(\n', '        address _token,\n', '        uint _totalAmount,\n', '        address _lendfMeData,\n', '        uint _totalLockedValue,\n', '        uint _start,\n', '        uint _step,\n', '        uint[] memory _distributionRatio\n', '    ) public {\n', '        require(!initialized, "initialize: Already initialized.");\n', '        owner = msg.sender;\n', '        managers[msg.sender] = true;\n', '        initialized = true;\n', '        DF = _token;\n', '        totalAmount = _totalAmount;\n', '        LendfMeData = _lendfMeData;\n', '        totalLockedValue = _totalLockedValue;\n', '        start = _start;\n', '        step = _step;\n', '        setDistributionRatio(_distributionRatio);\n', '    }\n', '\n', '    // ***************************\n', '    // **** Manager functions ****\n', '    // ***************************\n', '\n', '    /**\n', '     * @dev Manager function to set which asset will be distributed.\n', '     * @param _token Asset that users will get by claiming.\n', '     */\n', '    function setToken(address _token) external onlyManager {\n', '        require(DF != _token, "setToken: Asset is same as the previous!");\n', '        DF = _token;\n', '    }\n', '\n', '    function setTotalAmount(uint _totalAmount) external onlyManager {\n', '        require(totalAmount < _totalAmount, "setTotalAmount: New total amount should be greater than previous!");\n', '        totalAmount = _totalAmount;\n', '    }\n', '\n', '    function setLendfMeData(address _lendfMeData) external onlyManager {\n', '        require(LendfMeData != _lendfMeData, "setLendfMeData: New data contract should be different!");\n', '        LendfMeData = _lendfMeData;\n', '    }\n', '\n', '    function setTotalLiquidity(uint _totalLockedValue) external onlyManager {\n', '        require(totalLockedValue < _totalLockedValue,\n', '                "setTotalLiquidity: New locked value should be greater than previous!");\n', '        totalLockedValue = _totalLockedValue;\n', '    }\n', '\n', '    function setStartTime(uint _start) external onlyManager {\n', '        require(start != _start, "setStartTime: New start time should be different!");\n', '        start = _start;\n', '    }\n', '\n', '    function setStep(uint _step) external onlyManager {\n', '        require(step != _step, "setStep:  New step should be different!");\n', '        step = _step;\n', '    }\n', '\n', '    /**\n', '     * @dev Manager function to set distribution ratio.\n', '     * @param _distributionRatio Array that distribution ratio at each period.\n', '     */\n', '    function setDistributionRatio(uint[] memory _distributionRatio) public onlyManager {\n', '        delete distributionRatio;\n', '        // first set to 0, cause contract does not support claim yet.\n', '        distributionRatio.push(0);\n', '        uint _sum;\n', '        for (uint i = 0; i < _distributionRatio.length; i++) {\n', '            _sum = _sum.add(_distributionRatio[i]);\n', '            distributionRatio.push(_sum);\n', '        }\n', '        // last set to 0, cause contract has experid.\n', '        distributionRatio.push(0);\n', '        totalRatio = _sum;\n', '    }\n', '\n', '    // ***************************\n', '    // ***** Owner functions *****\n', '    // ***************************\n', '\n', '    /**\n', '     * @dev Owner function to transfer asset`_token` out when contract has expired.\n', '     * @param _token Reserve asset, generally spaking it should be DF.\n', '     * @param _recipient Account to receive asset.\n', '     * @param _amount Amount of asset to withdraw.\n', '     */\n', '    function removeReserve(address _token, address _recipient, uint _amount) external onlyOwner {\n', '        require(start + step * distributionRatio.length.sub(1) < now, "removeReserve: Too early to remove!");\n', '        require(doTransferOut(_token, _recipient, _amount), "removeReserve: Transfer out failed!");\n', '    }\n', '\n', '    /**\n', '     * @dev Owner function to transfer asset`_token` to this contract to start or move on.\n', '     * @param _amount Amount of asset to add.\n', '     */\n', '    function addReserve(uint _amount) external onlyOwner {\n', '\t\trequire(doTransferFrom(DF, msg.sender, address(this), _amount), "addReserve: TransferFrom failed!");\n', '\t}\n', '\n', '    // **************************\n', '    // *** Internal functions ***\n', '    // **************************\n', '\n', '    /**\n', '     * @dev Claims to get specified amount of asset, but only when the contract is not paused and not expired.\n', '     * @param _src Account who will receive distributed asset.\n', '     * @param _amount Amount to claim, scaled by 1e18.\n', '     */\n', '    function claim(address _src, uint _amount) internal whenNotPaused unclocked {\n', '        require(_amount > 0, "claim: Amount to claim should be greater than 0!");\n', '        claimed[_src] = claimed[_src].add(_amount);\n', '        totalClaimed = totalClaimed.add(_amount);\n', '        emit Claim(_src, _amount);\n', '\n', '        require(doTransferOut(DF, _src, _amount), "claim(address,uint): Transfer failed!");\n', '    }\n', '\n', '    // **************************\n', '    // **** Public functions ****\n', '    // **************************\n', '\n', '    /**\n', '     * @dev Gets all distributed asset during one distributing period.\n', '     */\n', '    function claim() external {\n', '        address _src = msg.sender;\n', '        claim(_src, getCurrentClaimableAmount(_src));\n', '    }\n', '\n', '    /**\n', '     * @dev Gets some distributed asset.\n', '     * @param _amount Amount that user wants to claim.\n', '     */\n', '    function claim(uint _amount) external {\n', '        address _src = msg.sender;\n', '        require(getCurrentClaimableAmount(_src) >= _amount, "claim(uint): Too large amount to claim!");\n', '        claim(_src, _amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns account liquidity in terms of eth-wei value, scaled by 1e18.\n', '     * @param _src The account to examine.\n', '     */\n', '    function getAccountLiquidity(address _src) public view returns (uint) {\n', '        int _liquidity = ILendfMeData(LendfMeData).getLiquidity(_src);\n', '        if (_liquidity <= 0)\n', '            return 0;\n', '        return uint(_liquidity);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns amount of released asset up to now.\n', '     */\n', '    function getCurrentUnlockedAmount() public view returns (uint) {\n', '        if (step == 0)\n', '            return 0;\n', '        uint _stage = now > start ? (now - start).div(step) : 0;\n', '        if (_stage >= distributionRatio.length)\n', '            return 0;\n', '        return totalAmount.mul(distributionRatio[_stage]).div(totalRatio);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns total amount that user`_src` can claim based on `_unlockAmount`.\n', '     * @param _src The account to examine.\n', '     * @param _unlockAmount Released amount during current period.\n', '     */\n', '    function calculateClaimableAmount(address _src, uint _unlockAmount) public view returns (uint) {\n', '        return getAccountLiquidity(_src).mul(_unlockAmount).div(totalLockedValue);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns maximum valid amount that user`_src` can claim up to now.\n', '     * @param _src The account to examine.\n', '     */\n', '    function getCurrentClaimableAmount(address _src) public view returns (uint) {\n', '        uint _amount = calculateClaimableAmount(_src, getCurrentUnlockedAmount());\n', '        return _amount < claimed[_src] ? 0 : _amount.sub(claimed[_src]);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns total amount that user`_src` can claim at the current period.\n', '     * @param _src The account to examine.\n', '     */\n', '    function getTotalClaimableAmount(address _src) public view returns (uint) {\n', '        uint _amount = calculateClaimableAmount(_src, totalAmount);\n', '        return start + step * distributionRatio.length.sub(1) < now ? 0 : (_amount < claimed[_src] ? 0 : _amount.sub(claimed[_src]));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns remaining amount that user`_src` can claim up to now.\n', '     * @param _src The account to examine.\n', '     */\n', '    function getUnclaimedAmount(address _src) external view returns (uint) {\n', '        return getTotalClaimableAmount(_src).sub(getCurrentClaimableAmount(_src));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns details that user`_src` claims.\n', '     * @param _src The account to examine.\n', '     * @return uint[] Array that start times for each period.\n', '     *         uint[] Array that the maximum amount to claim in every period.\n', '     */\n', '    function getClaimableList(address _src) external view returns (uint[] memory, uint[] memory) {\n', '\n', '        uint _length = distributionRatio.length - 2;\n', '        uint[] memory _timeList = new uint[](_length);\n', '        uint[] memory _amountList = new uint[](_length);\n', '        uint _start = start;\n', '        uint _step = step;\n', '        for (uint i = 1; i <= _length; i++) {\n', '            _timeList[i - 1] = _start + i * _step;\n', '            _amountList[i - 1] = calculateClaimableAmount(_src, totalAmount.mul(distributionRatio[i].sub(distributionRatio[i - 1])).div(totalRatio));\n', '        }\n', '\n', '        return(_timeList, _amountList);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns remaining period details that user`_src` can claim.\n', '     * @param _src The account to examine.\n', '     * @return uint[] Array that start times for each remaining period.\n', '     *         uint[] Array that the maximum amount to claim in every remaining period.\n', '     */\n', '    function getRemainingClaimableList(address _src) external view returns (uint[] memory, uint[] memory) {\n', '\n', '        uint _start = start;\n', '        uint _step = step;\n', '        uint _stage = now > _start.add(_step) ? (now - _start).div(_step) : 0;\n', '        uint _length = distributionRatio.length - 2;\n', '        _length = _length < _stage ? 0 : _length - _stage;\n', '        uint[] memory _timeList = new uint[](_length);\n', '        uint[] memory _amountList = new uint[](_length);\n', '        for (uint i = 1; i <= _length; i++) {\n', '            _timeList[i - 1] = _start + (_stage + i) * _step;\n', '            _amountList[i - 1] = calculateClaimableAmount(_src, totalAmount.mul(distributionRatio[_stage + i].sub(distributionRatio[_stage + i - 1])).div(totalRatio));\n', '        }\n', '\n', '        return(_timeList, _amountList);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns current period.\n', '     */\n', '    function getCurrentStage() external view returns (uint) {\n', '        uint _stage = now > start ? (now - start).div(step) : 0;\n', '        return _stage > distributionRatio.length ? distributionRatio.length : _stage;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns basic contract data.\n', '     * @return uint Total net value of the LendfMe contract.\n', '     *         uint Toal net value of user`_src`.\n', '     *         uint Maximun amount that user`_src` can claim during this distribution.\n', '     *         uint Remaining amount that user`_src` can claim up to now.\n', '     *         uint Amount that user has claimed.\n', '     *         uint Maximum valid amount that user`_src` can claim up to now.\n', '     */\n', '    function getDistributionData(address _src) external view returns (uint, uint, uint, uint, uint, uint) {\n', '        uint _shareAmount = calculateClaimableAmount(_src, totalAmount);\n', '        uint _unlockedAmount = calculateClaimableAmount(_src, getCurrentUnlockedAmount());\n', '        return (\n', '            totalLockedValue,\n', '            getAccountLiquidity(_src),\n', '            _shareAmount,\n', '            _shareAmount > _unlockedAmount ? _shareAmount - _unlockedAmount : 0,\n', '            claimed[_src],\n', '            getCurrentClaimableAmount(_src)\n', '        );\n', '    }\n', '}']