['pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface ConnectorsInterface {\n', '  function chief(address) external view returns (bool);\n', '}\n', '\n', 'interface IndexInterface {\n', '  function master() external view returns (address);\n', '}\n', '\n', 'contract BytesHelper {\n', '  /**\n', '  * @dev Convert String to bytes32.\n', '  */\n', '  function stringToBytes32(string memory str) internal pure returns (bytes32 result) {\n', '    require(bytes(str).length != 0, "String-Empty");\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      result := mload(add(str, 32))\n', '    }\n', '  }\n', '}\n', '\n', 'contract Helpers is BytesHelper {\n', '  address public constant connectors = 0xD6A602C01a023B98Ecfb29Df02FBA380d3B21E0c;\n', '  address public constant instaIndex = 0x2971AdFa57b20E5a416aE5a708A8655A9c74f723;\n', '  uint public version = 1;\n', '\n', '  mapping (bytes32 => GaugeData) public gaugeMapping;\n', '\n', '  struct GaugeData {\n', '    address gaugeAddress;\n', '    bool rewardToken;\n', '  }\n', '\n', '  event LogAddGaugeMapping(\n', '    string gaugeName,\n', '    address gaugeAddress,\n', '    bool rewardToken\n', '  );\n', '\n', '  event LogRemoveGaugeMapping(\n', '    string gaugeName,\n', '    address gaugeAddress\n', '  );\n', '\n', '  modifier isChief virtual {\n', '    require(\n', '      ConnectorsInterface(connectors).chief(msg.sender) ||\n', '      IndexInterface(instaIndex).master() == msg.sender, "not-Chief");\n', '      _;\n', '  }\n', '\n', '  function _addGaugeMapping(\n', '    string memory gaugeName,\n', '    address gaugeAddress,\n', '    bool rewardToken\n', '  ) internal {\n', '    require(gaugeAddress != address(0), "gaugeAddress-not-vaild");\n', '    require(bytes(gaugeName).length <= 32, "Length-exceeds");\n', '    bytes32 gaugeType = stringToBytes32(gaugeName);\n', '    require(gaugeMapping[gaugeType].gaugeAddress == address(0), "gaugePool-already-added");\n', '\n', '    gaugeMapping[gaugeType].gaugeAddress = gaugeAddress;\n', '    gaugeMapping[gaugeType].rewardToken = rewardToken;\n', '\n', '    emit LogAddGaugeMapping(gaugeName, gaugeAddress, rewardToken);\n', '  }\n', '\n', '  function addGaugeMappings(\n', '    string[] memory gaugeNames,\n', '    address[] memory gaugeAddresses,\n', '    bool[] memory rewardTokens\n', '  ) public isChief {\n', '    require(gaugeNames.length == gaugeAddresses.length && gaugeAddresses.length == rewardTokens.length, "length-not-match");\n', '    for (uint32 i; i < gaugeNames.length; i++) {\n', '      _addGaugeMapping(gaugeNames[i], gaugeAddresses[i], rewardTokens[i]);\n', '    }\n', '  }\n', '\n', '  function removeGaugeMapping(string memory gaugeName, address gaugeAddress) public isChief {\n', '    require(gaugeAddress != address(0), "gaugeAddress-not-vaild");\n', '    bytes32 gaugeType = stringToBytes32(gaugeName);\n', '    require(gaugeMapping[gaugeType].gaugeAddress == gaugeAddress, "different-gauge-pool");\n', '\n', '    delete gaugeMapping[gaugeType];\n', '\n', '    emit LogRemoveGaugeMapping(\n', '      gaugeName,\n', '      gaugeAddress\n', '    );\n', '  }\n', '}\n', '\n', 'contract CurveGaugeMapping is Helpers {\n', '  string constant public name = "Curve-Gauge-Mapping-v1";\n', '\n', '  constructor (\n', '    string[] memory gaugeNames,\n', '    address[] memory gaugeAddresses,\n', '    bool[] memory rewardTokens\n', '  ) public {\n', '    require(gaugeNames.length == gaugeAddresses.length && gaugeAddresses.length == rewardTokens.length, "length-not-match");\n', '    for (uint32 i; i < gaugeNames.length; i++) {\n', '      _addGaugeMapping(gaugeNames[i], gaugeAddresses[i], rewardTokens[i]);\n', '    }\n', '  }\n', '}']