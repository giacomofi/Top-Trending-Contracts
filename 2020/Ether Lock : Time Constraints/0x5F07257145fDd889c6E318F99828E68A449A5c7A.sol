['# @version 0.2.4\n', 'from vyper.interfaces import ERC20\n', '\n', 'interface USDT:\n', '    def transferFrom(_from: address, _to: address, _value: uint256): nonpayable\n', '    def approve(_spender: address, _value: uint256): nonpayable\n', '\n', 'interface yCurveDeposit:\n', '    def add_liquidity(uamounts: uint256[4], min_mint_amount: uint256): nonpayable\n', '\n', 'interface yVault:\n', '    def deposit(amount: uint256): nonpayable\n', '\n', 'event Recycled:\n', '    user: indexed(address)\n', '    sent_dai: uint256\n', '    sent_usdc: uint256\n', '    sent_usdt: uint256\n', '    sent_tusd: uint256\n', '    sent_ycrv: uint256\n', '    received_yusd: uint256\n', '\n', '\n', 'ydeposit: constant(address) = 0xbBC81d23Ea2c3ec7e56D39296F0cbB648873a5d3\n', 'ycrv: constant(address) = 0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8\n', 'yusd: constant(address) = 0x5dbcF33D8c2E976c6b560249878e6F1491Bca25c\n', '\n', 'dai: constant(address) = 0x6B175474E89094C44Da98b954EedeAC495271d0F\n', 'usdc: constant(address) = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n', 'usdt: constant(address) = 0xdAC17F958D2ee523a2206206994597C13D831ec7\n', 'tusd: constant(address) = 0x0000000000085d4780B73119b644AE5ecd22b376\n', '\n', '\n', '@external\n', 'def __init__():\n', '    ERC20(dai).approve(ydeposit, MAX_UINT256)\n', '    ERC20(usdc).approve(ydeposit, MAX_UINT256)\n', '    USDT(usdt).approve(ydeposit, MAX_UINT256)\n', '    ERC20(tusd).approve(ydeposit, MAX_UINT256)\n', '    ERC20(ycrv).approve(yusd, MAX_UINT256)\n', '\n', '\n', '@internal\n', 'def recycle_exact_amounts(sender: address, _dai: uint256, _usdc: uint256, _usdt: uint256, _tusd: uint256, _ycrv: uint256):\n', '    if _dai > 0:\n', '        ERC20(dai).transferFrom(sender, self, _dai)\n', '    if _usdc > 0:\n', '        ERC20(usdc).transferFrom(sender, self, _usdc)\n', '    if _usdt > 0:\n', '        USDT(usdt).transferFrom(sender, self, _usdt)\n', '    if _tusd > 0:\n', '        ERC20(tusd).transferFrom(sender, self, _tusd)\n', '    if _ycrv > 0:\n', '        ERC20(ycrv).transferFrom(sender, self, _ycrv)\n', '\n', '    deposit_amounts: uint256[4] = [_dai, _usdc, _usdt, _tusd]\n', '    if _dai + _usdc + _usdt + _tusd > 0:\n', '        yCurveDeposit(ydeposit).add_liquidity(deposit_amounts, 0)\n', '\n', '    ycrv_balance: uint256 = ERC20(ycrv).balanceOf(self)       \n', '    if ycrv_balance > 0:\n', '        yVault(yusd).deposit(ycrv_balance)\n', '\n', '    _yusd: uint256 = ERC20(yusd).balanceOf(self)\n', '    ERC20(yusd).transfer(sender, _yusd)\n', '\n', '    assert ERC20(yusd).balanceOf(self) == 0, "leftover yUSD balance"\n', '\n', '    log Recycled(sender, _dai, _usdc, _usdt, _tusd, _ycrv, _yusd)\n', '\n', '\n', '@external\n', 'def recycle():\n', '    _dai: uint256 = min(ERC20(dai).balanceOf(msg.sender), ERC20(dai).allowance(msg.sender, self))\n', '    _usdc: uint256 = min(ERC20(usdc).balanceOf(msg.sender), ERC20(usdc).allowance(msg.sender, self))\n', '    _usdt: uint256 = min(ERC20(usdt).balanceOf(msg.sender), ERC20(usdt).allowance(msg.sender, self))\n', '    _tusd: uint256 = min(ERC20(tusd).balanceOf(msg.sender), ERC20(tusd).allowance(msg.sender, self))\n', '    _ycrv: uint256 = min(ERC20(ycrv).balanceOf(msg.sender), ERC20(ycrv).allowance(msg.sender, self))\n', '\n', '    self.recycle_exact_amounts(msg.sender, _dai, _usdc, _usdt, _tusd, _ycrv)\n', '\n', '\n', '@external\n', 'def recycle_exact(_dai: uint256, _usdc: uint256, _usdt: uint256, _tusd: uint256, _ycrv: uint256):\n', '    self.recycle_exact_amounts(msg.sender, _dai, _usdc, _usdt, _tusd, _ycrv)']