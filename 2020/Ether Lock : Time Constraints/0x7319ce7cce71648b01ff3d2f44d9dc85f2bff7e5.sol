['pragma solidity 0.6.0;\n', '\n', 'contract TRONPROM {\n', '\tusing SafeMath for uint256;\n', '\n', '\tuint256 constant public MIN_INVEST = 0.1 ether;\n', '\tuint256 constant public BASE_PERCENT = 50;\n', '\tuint256 constant public MARKETING_FEE = 80;\n', '\tuint256 constant public ADMIN_FEE = 30;\n', '\tuint256[] public REFF_PERCENT = [50, 30, 10];\n', '\tuint256 constant public TIMESTEP = 1 days;\n', '\tuint256 constant public PERCENTS_DIVIDER = 1000;\n', '\tuint256 constant public CONTRACT_BALANCE_STEP = 1 ether;\n', '\n', '\tuint256 public totalInvestors;\n', '\tuint256 public totalInvested;\n', '\tuint256 public totalWithdrawn;\n', '\tuint256 public totalDeposits;\n', '\n', '\taddress payable public marketingAddress;\n', '\taddress payable public projectAddress;\n', '\n', '\tstruct Deposit {\n', '\t\tuint256 amount;\n', '\t\tuint256 withdrawn;\n', '\t\tuint256 start;\n', '\t}\n', '\n', '\tstruct User {\n', '\t\tDeposit[] deposits;\n', '\t\tuint256 checkpoint;\n', '\t\taddress referrer;\n', '\t\tuint256 bonus;\n', '\t}\n', '\n', '\tmapping (address => User) internal users;\n', '\n', '\tevent NewDeposit(address indexed user, uint256 amount);\n', '\tevent Withdrawn(address indexed user, uint256 amount);\n', '\tevent RefBonus(address indexed referrer, address indexed referral, uint256 indexed level, uint256 amount);\n', '\n', '\tconstructor(address payable marketingAddr, address payable projectAddr) public {\n', '\t\trequire(!isContract(marketingAddr) && !isContract(projectAddr));\n', '\t\tmarketingAddress = marketingAddr;\n', '\t\tprojectAddress = projectAddr;\n', '\t}\n', '\n', '\tfunction invest(address referrer) public payable {\n', '\t\trequire(msg.value >= MIN_INVEST);\n', '\t\tmarketingAddress.transfer(msg.value.mul(MARKETING_FEE).div(PERCENTS_DIVIDER));\n', '\t\tprojectAddress.transfer(msg.value.mul(ADMIN_FEE).div(PERCENTS_DIVIDER));\n', '\t\tUser storage user = users[msg.sender];\n', '\t\tif (user.referrer == address(0) && users[referrer].deposits.length > 0 && referrer != msg.sender) {\n', '\t\t\tuser.referrer = referrer;\n', '\t\t}\n', '\t\tif (user.referrer != address(0)) {\n', '\t\t\taddress upline = user.referrer;\n', '\t\t\tfor (uint256 i = 0; i < 3; i++) {\n', '\t\t\t\tif (upline != address(0)) {\n', '\t\t\t\t\tuint256 amount = msg.value.mul(REFF_PERCENT[i]).div(PERCENTS_DIVIDER);\n', '\t\t\t\t\tusers[upline].bonus = users[upline].bonus.add(amount);\n', '\t\t\t\t\temit RefBonus(upline, msg.sender, i, amount);\n', '\t\t\t\t\tupline = users[upline].referrer;\n', '\t\t\t\t} else break;\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (user.deposits.length == 0) {\n', '\t\t\tuser.checkpoint = block.timestamp;\n', '\t\t\ttotalInvestors = totalInvestors.add(1);\n', '\t\t}\n', '\t\tuser.deposits.push(Deposit(msg.value, 0, block.timestamp));\n', '\t\ttotalInvested = totalInvested.add(msg.value);\n', '\t\ttotalDeposits = totalDeposits.add(1);\n', '\t\temit NewDeposit(msg.sender, msg.value);\n', '\n', '\t}\n', '\n', '\tfunction withdraw() public {\n', '\t\tUser storage user = users[msg.sender];\n', '\t\tuint256 userPercentRate = getUserPercentRate(msg.sender);\n', '\t\tuint256 totalAmount;\n', '\t\tuint256 dividends;\n', '\n', '\t\tfor (uint256 i = 0; i < user.deposits.length; i++) {\n', '\t\t\tif (user.deposits[i].withdrawn < ((user.deposits[i].amount.mul(2)).add(user.deposits[i].amount.div(2)))) {\n', '\t\t\t\tif (user.deposits[i].start > user.checkpoint) {\n', '\t\t\t\t\tdividends = (user.deposits[i].amount.mul(userPercentRate).div(PERCENTS_DIVIDER))\n', '\t\t\t\t\t\t.mul(block.timestamp.sub(user.deposits[i].start))\n', '\t\t\t\t\t\t.div(TIMESTEP);\n', '\t\t\t\t} else {\n', '\t\t\t\t\tdividends = (user.deposits[i].amount.mul(userPercentRate).div(PERCENTS_DIVIDER))\n', '\t\t\t\t\t\t.mul(block.timestamp.sub(user.checkpoint))\n', '\t\t\t\t\t\t.div(TIMESTEP);\n', '\t\t\t\t}\n', '\t\t\t\tif (user.deposits[i].withdrawn.add(dividends) > ((user.deposits[i].amount.mul(2)).add(user.deposits[i].amount.div(2)))) {\n', '\t\t\t\t\tdividends = (((user.deposits[i].amount.mul(2)).add(user.deposits[i].amount.div(2)))).sub(user.deposits[i].withdrawn);\n', '\t\t\t\t}\n', '\t\t\t\tuser.deposits[i].withdrawn = user.deposits[i].withdrawn.add(dividends);\n', '\t\t\t\ttotalAmount = totalAmount.add(dividends);\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\tuint256 referralBonus = getUserReferralBonus(msg.sender);\n', '\t\tif (referralBonus > 0) {\n', '\t\t\ttotalAmount = totalAmount.add(referralBonus);\n', '\t\t\tuser.bonus = 0;\n', '\t\t}\n', '\n', '\t\trequire(totalAmount > 0, "No dividends");\n', '\n', '\t\tuint256 contractBalance = address(this).balance;\n', '\t\tif (contractBalance < totalAmount) {\n', '\t\t\ttotalAmount = contractBalance;\n', '\t\t}\n', '\t\tuser.checkpoint = block.timestamp;\n', '\t\tmsg.sender.transfer(totalAmount);\n', '\t\ttotalWithdrawn = totalWithdrawn.add(totalAmount);\n', '\t\temit Withdrawn(msg.sender, totalAmount);\n', '\t}\n', '\tfunction getContractBalance() public view returns (uint256) {\n', '\t\treturn address(this).balance;\n', '\t}\n', '\tfunction getContractBalanceRate() public view returns (uint256) {\n', '\t\tuint256 contractBalance = address(this).balance;\n', '\t\tuint256 contractBalancePercent = contractBalance.div(CONTRACT_BALANCE_STEP);\n', '\t\treturn BASE_PERCENT.add(contractBalancePercent);\n', '\t}\n', '\tfunction getUserPercentRate(address userAddress) public view returns (uint256) {\n', '\t\tUser storage user = users[userAddress];\n', '\t\tuint256 contractBalanceRate = getContractBalanceRate();\n', '\t\tif (isActive(userAddress)) {\n', '\t\t\tuint256 timeMultiplier = (now.sub(user.checkpoint)).div(TIMESTEP);\n', '\t\t\treturn contractBalanceRate.add(timeMultiplier);\n', '\t\t} else {\n', '\t\t\treturn contractBalanceRate;\n', '\t\t}\n', '\t}\n', '\tfunction getUserDividends(address userAddress) public view returns (uint256) {\n', '\t\tUser storage user = users[userAddress];\n', '\t\tuint256 userPercentRate = getUserPercentRate(userAddress);\n', '\t\tuint256 totalDividends;\n', '\t\tuint256 dividends;\n', '\n', '\t\tfor (uint256 i = 0; i < user.deposits.length; i++) {\n', '\t\t\tif (user.deposits[i].withdrawn < ((user.deposits[i].amount.mul(2)).add(user.deposits[i].amount.div(2)))) {\n', '\t\t\t\tif (user.deposits[i].start > user.checkpoint) {\n', '\t\t\t\t\tdividends = (user.deposits[i].amount.mul(userPercentRate).div(PERCENTS_DIVIDER))\n', '\t\t\t\t\t\t.mul(block.timestamp.sub(user.deposits[i].start))\n', '\t\t\t\t\t\t.div(TIMESTEP);\n', '\t\t\t\t} else {\n', '\t\t\t\t\tdividends = (user.deposits[i].amount.mul(userPercentRate).div(PERCENTS_DIVIDER))\n', '\t\t\t\t\t\t.mul(block.timestamp.sub(user.checkpoint))\n', '\t\t\t\t\t\t.div(TIMESTEP);\n', '\t\t\t\t}\n', '\t\t\t\tif (user.deposits[i].withdrawn.add(dividends) > ((user.deposits[i].amount.mul(2)).add(user.deposits[i].amount.div(2)))) {\n', '\t\t\t\t\tdividends = (((user.deposits[i].amount.mul(2)).add(user.deposits[i].amount.div(2)))).sub(user.deposits[i].withdrawn);\n', '\t\t\t\t}\n', '\t\t\t\ttotalDividends = totalDividends.add(dividends);\n', '\t\t\t}\n', '\t\t}\n', '\t\treturn totalDividends;\n', '\t}\n', '\tfunction getUserCheckpoint(address userAddress) public view returns(uint256) {\n', '\t\treturn users[userAddress].checkpoint;\n', '\t}\n', '\tfunction getUserReferrer(address userAddress) public view returns(address) {\n', '\t\treturn users[userAddress].referrer;\n', '\t}\n', '\tfunction getUserReferralBonus(address userAddress) public view returns(uint256) {\n', '\t\treturn users[userAddress].bonus;\n', '\t}\n', '\tfunction getUserAvailable(address userAddress) public view returns(uint256) {\n', '\t\treturn getUserReferralBonus(userAddress).add(getUserDividends(userAddress));\n', '\t}\n', '\tfunction isActive(address userAddress) public view returns (bool) {\n', '\t\tUser storage user = users[userAddress];\n', '\t\tif (user.deposits.length > 0) {\n', '\t\t    \n', '\t\t\tif (user.deposits[user.deposits.length-1].withdrawn < ((user.deposits[user.deposits.length-1].amount.mul(2)).add(user.deposits[user.deposits.length-1].amount.div(2)))) {\n', '\t\t\t\treturn true;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\tfunction getUserDepositInfo(address userAddress, uint256 index) public view returns(uint256, uint256, uint256) {\n', '\t    User storage user = users[userAddress];\n', '\t\treturn (user.deposits[index].amount, user.deposits[index].withdrawn, user.deposits[index].start);\n', '\t}\n', '\tfunction getUserAmountOfDeposits(address userAddress) public view returns(uint256) {\n', '\t\treturn users[userAddress].deposits.length;\n', '\t}\n', '\tfunction getUserTotalDeposits(address userAddress) public view returns(uint256) {\n', '\t    User storage user = users[userAddress];\n', '\t\tuint256 amount;\n', '\t\tfor (uint256 i = 0; i < user.deposits.length; i++) {\n', '\t\t\tamount = amount.add(user.deposits[i].amount);\n', '\t\t}\n', '\t\treturn amount;\n', '\t}\n', '\tfunction getUserTotalWithdrawn(address userAddress) public view returns(uint256) {\n', '\t    User storage user = users[userAddress];\n', '\t\tuint256 amount;\n', '\t\tfor (uint256 i = 0; i < user.deposits.length; i++) {\n', '\t\t\tamount = amount.add(user.deposits[i].withdrawn);\n', '\t\t}\n', '\t\treturn amount;\n', '\t}\n', '\tfunction isContract(address addr) internal view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n', '        return div(mul(a, b), base);\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '}']