['pragma solidity ^0.6.6;\n', '\n', 'contract ABDKMathQuad {\n', '/*\n', ' * ABDK Math Quad Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n', ' */\n', '\n', '/**\n', ' * Smart contract library of mathematical functions operating with IEEE 754\n', ' * quadruple-precision binary floating-point numbers (quadruple precision\n', ' * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\n', ' * represented by bytes16 type.\n', ' */\n', '  /**\n', '   * 0.\n', '   */\n', '  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\n', '\n', '  /**\n', '   * -0.\n', '   */\n', '  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\n', '\n', '  /**\n', '   * +Infinity.\n', '   */\n', '  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\n', '\n', '  /**\n', '   * -Infinity.\n', '   */\n', '  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\n', '\n', '  /**\n', '   * Canonical NaN value.\n', '   */\n', '  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\n', '\n', '  /**\n', '   * Convert unsigned 256-bit integer number into quadruple precision number.\n', '   *\n', '   * @param x unsigned 256-bit integer number\n', '   * @return quadruple precision number\n', '   */\n', '  function fromUInt (uint256 x) internal pure returns (bytes16) {\n', '    if (x == 0) return bytes16 (0);\n', '    else {\n', '      uint256 result = x;\n', '\n', '      uint256 msb = msb (result);\n', '      if (msb < 112) result <<= 112 - msb;\n', '      else if (msb > 112) result >>= msb - 112;\n', '\n', '      result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\n', '\n', '      return bytes16 (uint128 (result));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Convert quadruple precision number into unsigned 256-bit integer number\n', '   * rounding towards zero.  Revert on underflow.  Note, that negative floating\n', '   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\n', '   * without error, because they are rounded to zero.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return unsigned 256-bit integer number\n', '   */\n', '  function toUInt (bytes16 x) internal pure returns (uint256) {\n', '    uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n', '\n', '    if (exponent < 16383) return 0; // Underflow\n', '\n', '    require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\n', '\n', '    require (exponent <= 16638); // Overflow\n', '    uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n', '      0x10000000000000000000000000000;\n', '\n', '    if (exponent < 16495) result >>= 16495 - exponent;\n', '    else if (exponent > 16495) result <<= exponent - 16495;\n', '\n', '    return result;\n', '  }\n', '\n', '  /**\n', '   * Calculate x + y.  Special values behave in the following way:\n', '   *\n', '   * NaN + x = NaN for any x.\n', '   * Infinity + x = Infinity for any finite x.\n', '   * -Infinity + x = -Infinity for any finite x.\n', '   * Infinity + Infinity = Infinity.\n', '   * -Infinity + -Infinity = -Infinity.\n', '   * Infinity + -Infinity = -Infinity + Infinity = NaN.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @param y quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function addABDK (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n', '    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n', '    uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\n', '\n', '    if (xExponent == 0x7FFF) {\n', '      if (yExponent == 0x7FFF) { \n', '        if (x == y) return x;\n', '        else return NaN;\n', '      } else return x; \n', '    } else if (yExponent == 0x7FFF) return y;\n', '    else {\n', '      bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\n', '      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (xExponent == 0) xExponent = 1;\n', '      else xSignifier |= 0x10000000000000000000000000000;\n', '\n', '      bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\n', '      uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (yExponent == 0) yExponent = 1;\n', '      else ySignifier |= 0x10000000000000000000000000000;\n', '\n', '      if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\n', '      else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\n', '      else {\n', '        int256 delta = int256 (xExponent) - int256 (yExponent);\n', '  \n', '        if (xSign == ySign) {\n', '          if (delta > 112) return x;\n', '          else if (delta > 0) ySignifier >>= delta;\n', '          else if (delta < -112) return y;\n', '          else if (delta < 0) {\n', '            xSignifier >>= -delta;\n', '            xExponent = yExponent;\n', '          }\n', '  \n', '          xSignifier += ySignifier;\n', '  \n', '          if (xSignifier >= 0x20000000000000000000000000000) {\n', '            xSignifier >>= 1;\n', '            xExponent += 1;\n', '          }\n', '  \n', '          if (xExponent == 0x7FFF)\n', '            return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n', '          else {\n', '            if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\n', '            else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '  \n', '            return bytes16 (uint128 (\n', '                (xSign ? 0x80000000000000000000000000000000 : 0) |\n', '                (xExponent << 112) |\n', '                xSignifier)); \n', '          }\n', '        } else {\n', '          if (delta > 0) {\n', '            xSignifier <<= 1;\n', '            xExponent -= 1;\n', '          } else if (delta < 0) {\n', '            ySignifier <<= 1;\n', '            xExponent = yExponent - 1;\n', '          }\n', '\n', '          if (delta > 112) ySignifier = 1;\n', '          else if (delta > 1) ySignifier = (ySignifier - 1 >> delta - 1) + 1;\n', '          else if (delta < -112) xSignifier = 1;\n', '          else if (delta < -1) xSignifier = (xSignifier - 1 >> -delta - 1) + 1;\n', '\n', '          if (xSignifier >= ySignifier) xSignifier -= ySignifier;\n', '          else {\n', '            xSignifier = ySignifier - xSignifier;\n', '            xSign = ySign;\n', '          }\n', '\n', '          if (xSignifier == 0)\n', '            return POSITIVE_ZERO;\n', '\n', '          uint256 msb = msb (xSignifier);\n', '\n', '          if (msb == 113) {\n', '            xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '            xExponent += 1;\n', '          } else if (msb < 112) {\n', '            uint256 shift = 112 - msb;\n', '            if (xExponent > shift) {\n', '              xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '              xExponent -= shift;\n', '            } else {\n', '              xSignifier <<= xExponent - 1;\n', '              xExponent = 0;\n', '            }\n', '          } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '          if (xExponent == 0x7FFF)\n', '            return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n', '          else return bytes16 (uint128 (\n', '              (xSign ? 0x80000000000000000000000000000000 : 0) |\n', '              (xExponent << 112) |\n', '              xSignifier));\n', '        }\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate x - y.  Special values behave in the following way:\n', '   *\n', '   * NaN - x = NaN for any x.\n', '   * Infinity - x = Infinity for any finite x.\n', '   * -Infinity - x = -Infinity for any finite x.\n', '   * Infinity - -Infinity = Infinity.\n', '   * -Infinity - Infinity = -Infinity.\n', '   * Infinity - Infinity = -Infinity - -Infinity = NaN.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @param y quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function subABDK (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n', '    return addABDK(x, y ^ 0x80000000000000000000000000000000);\n', '  }\n', '\n', '  /**\n', '   * Calculate x * y.  Special values behave in the following way:\n', '   *\n', '   * NaN * x = NaN for any x.\n', '   * Infinity * x = Infinity for any finite positive x.\n', '   * Infinity * x = -Infinity for any finite negative x.\n', '   * -Infinity * x = -Infinity for any finite positive x.\n', '   * -Infinity * x = Infinity for any finite negative x.\n', '   * Infinity * 0 = NaN.\n', '   * -Infinity * 0 = NaN.\n', '   * Infinity * Infinity = Infinity.\n', '   * Infinity * -Infinity = -Infinity.\n', '   * -Infinity * Infinity = -Infinity.\n', '   * -Infinity * -Infinity = Infinity.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @param y quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function mulABDK (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n', '    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n', '    uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\n', '\n', '    if (xExponent == 0x7FFF) {\n', '      if (yExponent == 0x7FFF) {\n', '        if (x == y) return x ^ y & 0x80000000000000000000000000000000;\n', '        else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\n', '        else return NaN;\n', '      } else {\n', '        if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n', '        else return x ^ y & 0x80000000000000000000000000000000;\n', '      }\n', '    } else if (yExponent == 0x7FFF) {\n', '        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n', '        else return y ^ x & 0x80000000000000000000000000000000;\n', '    } else {\n', '      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (xExponent == 0) xExponent = 1;\n', '      else xSignifier |= 0x10000000000000000000000000000;\n', '\n', '      uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (yExponent == 0) yExponent = 1;\n', '      else ySignifier |= 0x10000000000000000000000000000;\n', '\n', '      xSignifier *= ySignifier;\n', '      if (xSignifier == 0)\n', '        return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\n', '            NEGATIVE_ZERO : POSITIVE_ZERO;\n', '\n', '      xExponent += yExponent;\n', '\n', '      uint256 msb =\n', '        xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\n', '        xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\n', '        msb (xSignifier);\n', '\n', '      if (xExponent + msb < 16496) { // Underflow\n', '        xExponent = 0;\n', '        xSignifier = 0;\n', '      } else if (xExponent + msb < 16608) { // Subnormal\n', '        if (xExponent < 16496)\n', '          xSignifier >>= 16496 - xExponent;\n', '        else if (xExponent > 16496)\n', '          xSignifier <<= xExponent - 16496;\n', '        xExponent = 0;\n', '      } else if (xExponent + msb > 49373) {\n', '        xExponent = 0x7FFF;\n', '        xSignifier = 0;\n', '      } else {\n', '        if (msb > 112)\n', '          xSignifier >>= msb - 112;\n', '        else if (msb < 112)\n', '          xSignifier <<= 112 - msb;\n', '\n', '        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '        xExponent = xExponent + msb - 16607;\n', '      }\n', '\n', '      return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\n', '          xExponent << 112 | xSignifier));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate x / y.  Special values behave in the following way:\n', '   *\n', '   * NaN / x = NaN for any x.\n', '   * x / NaN = NaN for any x.\n', '   * Infinity / x = Infinity for any finite non-negative x.\n', '   * Infinity / x = -Infinity for any finite negative x including -0.\n', '   * -Infinity / x = -Infinity for any finite non-negative x.\n', '   * -Infinity / x = Infinity for any finite negative x including -0.\n', '   * x / Infinity = 0 for any finite non-negative x.\n', '   * x / -Infinity = -0 for any finite non-negative x.\n', '   * x / Infinity = -0 for any finite non-negative x including -0.\n', '   * x / -Infinity = 0 for any finite non-negative x including -0.\n', '   * \n', '   * Infinity / Infinity = NaN.\n', '   * Infinity / -Infinity = -NaN.\n', '   * -Infinity / Infinity = -NaN.\n', '   * -Infinity / -Infinity = NaN.\n', '   *\n', '   * Division by zero behaves in the following way:\n', '   *\n', '   * x / 0 = Infinity for any finite positive x.\n', '   * x / -0 = -Infinity for any finite positive x.\n', '   * x / 0 = -Infinity for any finite negative x.\n', '   * x / -0 = Infinity for any finite negative x.\n', '   * 0 / 0 = NaN.\n', '   * 0 / -0 = NaN.\n', '   * -0 / 0 = NaN.\n', '   * -0 / -0 = NaN.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @param y quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function divABDK (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n', '    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n', '    uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\n', '\n', '    if (xExponent == 0x7FFF) {\n', '      if (yExponent == 0x7FFF) return NaN;\n', '      else return x ^ y & 0x80000000000000000000000000000000;\n', '    } else if (yExponent == 0x7FFF) {\n', '      if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\n', '      else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\n', '    } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\n', '      if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n', '      else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\n', '    } else {\n', '      uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (yExponent == 0) yExponent = 1;\n', '      else ySignifier |= 0x10000000000000000000000000000;\n', '\n', '      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (xExponent == 0) {\n', '        if (xSignifier != 0) {\n', '          uint shift = 226 - msb (xSignifier);\n', '\n', '          xSignifier <<= shift;\n', '\n', '          xExponent = 1;\n', '          yExponent += shift - 114;\n', '        }\n', '      }\n', '      else {\n', '        xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\n', '      }\n', '\n', '      xSignifier = xSignifier / ySignifier;\n', '      if (xSignifier == 0)\n', '        return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\n', '            NEGATIVE_ZERO : POSITIVE_ZERO;\n', '\n', '      assert (xSignifier >= 0x1000000000000000000000000000);\n', '\n', '      uint256 msb =\n', '        xSignifier >= 0x80000000000000000000000000000 ? msb (xSignifier) :\n', '        xSignifier >= 0x40000000000000000000000000000 ? 114 :\n', '        xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\n', '\n', '      if (xExponent + msb > yExponent + 16497) { // Overflow\n', '        xExponent = 0x7FFF;\n', '        xSignifier = 0;\n', '      } else if (xExponent + msb + 16380  < yExponent) { // Underflow\n', '        xExponent = 0;\n', '        xSignifier = 0;\n', '      } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\n', '        if (xExponent + 16380 > yExponent)\n', '          xSignifier <<= xExponent + 16380 - yExponent;\n', '        else if (xExponent + 16380 < yExponent)\n', '          xSignifier >>= yExponent - xExponent - 16380;\n', '\n', '        xExponent = 0;\n', '      } else { // Normal\n', '        if (msb > 112)\n', '          xSignifier >>= msb - 112;\n', '\n', '        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '        xExponent = xExponent + msb + 16269 - yExponent;\n', '      }\n', '\n', '      return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\n', '          xExponent << 112 | xSignifier));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate 2^x.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function pow_2 (bytes16 x) internal pure returns (bytes16) {\n', '    bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\n', '    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n', '    uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\n', '    else if (xExponent > 16397)\n', '      return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\n', '    else if (xExponent < 16255)\n', '      return 0x3FFF0000000000000000000000000000;\n', '    else {\n', '      if (xExponent == 0) xExponent = 1;\n', '      else xSignifier |= 0x10000000000000000000000000000;\n', '\n', '      if (xExponent > 16367)\n', '        xSignifier <<= xExponent - 16367;\n', '      else if (xExponent < 16367)\n', '        xSignifier >>= 16367 - xExponent;\n', '\n', '      if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\n', '        return POSITIVE_ZERO;\n', '\n', '      if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '        return POSITIVE_INFINITY;\n', '\n', '      uint256 resultExponent = xSignifier >> 128;\n', '      xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (xNegative && xSignifier != 0) {\n', '        xSignifier = ~xSignifier;\n', '        resultExponent += 1;\n', '      }\n', '\n', '      uint256 resultSignifier = 0x80000000000000000000000000000000;\n', '      if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n', '      if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n', '      if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n', '      if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n', '      if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n', '      if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n', '      if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n', '      if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n', '      if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n', '      if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n', '      if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n', '      if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n', '      if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n', '      if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n', '      if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\n', '      if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n', '      if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n', '      if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n', '      if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n', '      if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n', '      if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n', '      if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n', '      if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n', '      if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n', '      if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n', '      if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n', '      if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n', '      if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n', '      if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n', '      if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n', '      if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n', '      if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n', '      if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n', '      if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n', '      if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n', '      if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n', '      if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n', '      if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n', '      if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n', '      if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n', '      if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n', '      if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\n', '      if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\n', '      if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\n', '      if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n', '      if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n', '      if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n', '      if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n', '      if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n', '      if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n', '      if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\n', '      if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n', '      if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n', '      if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\n', '      if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n', '      if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\n', '      if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n', '      if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n', '      if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\n', '      if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n', '      if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n', '      if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n', '      if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\n', '      if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\n', '      if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\n', '      if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\n', '      if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\n', '      if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\n', '      if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\n', '      if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\n', '      if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\n', '      if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\n', '      if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\n', '      if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\n', '      if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\n', '      if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\n', '      if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\n', '      if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\n', '      if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\n', '      if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\n', '      if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\n', '      if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\n', '      if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\n', '      if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\n', '      if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\n', '      if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\n', '      if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\n', '      if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\n', '      if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\n', '      if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\n', '      if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\n', '      if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\n', '      if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\n', '      if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\n', '      if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\n', '      if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\n', '      if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\n', '      if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\n', '      if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\n', '      if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\n', '      if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\n', '      if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\n', '      if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\n', '      if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\n', '      if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\n', '      if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\n', '      if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\n', '      if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\n', '      if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\n', '      if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\n', '      if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\n', '      if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\n', '      if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\n', '      if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\n', '      if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\n', '      if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\n', '      if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\n', '      if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\n', '      if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\n', '      if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\n', '      if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\n', '      if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\n', '      if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\n', '      if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\n', '      if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\n', '      if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\n', '\n', '      if (!xNegative) {\n', '        resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '        resultExponent += 0x3FFF;\n', '      } else if (resultExponent <= 0x3FFE) {\n', '        resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '        resultExponent = 0x3FFF - resultExponent;\n', '      } else {\n', '        resultSignifier = resultSignifier >> resultExponent - 16367;\n', '        resultExponent = 0;\n', '      }\n', '\n', '      return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate e^x.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function exp (bytes16 x) internal pure returns (bytes16) {\n', '    return pow_2 (mulABDK (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\n', '  }\n', '  \n', '  function msb (uint256 x) private pure returns (uint256) {\n', '    require (x > 0);\n', '\n', '    uint256 result = 0;\n', '\n', '    if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\n', '    if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\n', '    if (x >= 0x100000000) { x >>= 32; result += 32; }\n', '    if (x >= 0x10000) { x >>= 16; result += 16; }\n', '    if (x >= 0x100) { x >>= 8; result += 8; }\n', '    if (x >= 0x10) { x >>= 4; result += 4; }\n', '    if (x >= 0x4) { x >>= 2; result += 2; }\n', '    if (x >= 0x2) result += 1; // No need to shift x anymore\n', '\n', '    return result;\n', '  }\n', '  \n', '  function totalSupplyAtTime (uint t) internal pure returns (bytes16 fin) {\n', '      bytes16 xQuad = fromUInt(t);\n', '      bytes16 xQuadSub = subABDK(xQuad, 0x4016e133800000000000000000000000);\n', '      bytes16 exponent = mulABDK(xQuadSub, 0xbfea0c6f7a0b5ed8d36b4c7f34938583);\n', '      bytes16 expExp = exp(exponent);\n', '      bytes16 bottom = addABDK(0x3fff0000000000000000000000000000, expExp);\n', '      bytes16 whole = divABDK(0x402a22db571485000000000000000000, bottom);\n', '      fin = addABDK(whole, 0x401f73b9fbd700000000000000000000);\n', '  }\n', '  \n', '}\n', '\n', 'contract SafeMath {\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    \n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '    \n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '    \n', '}\n', '\n', 'contract ERC20wRebase is SafeMath, ABDKMathQuad {\n', '\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '  address public _owner;\n', '  uint private supplyTotal;\n', '  uint private constant _decimals = 9;\n', '  uint private constant uintMax = ~uint256(0);\n', '  uint private constant tokensMax = 10**4 * 10**_decimals;\n', '  uint private tokensInitial = 10**1 * 10**_decimals;\n', '  uint internal unitsPerToken;\n', '  uint private unitsTotal = uintMax - (uintMax % tokensMax);\n', '  uint public tokensCurrent;\n', '\n', '  mapping(address => uint) balances;\n', '  mapping(address => mapping(address => uint)) allowed;\n', '\n', '  event Transfer(address indexed from, address indexed to, uint tokens);\n', '  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '\n', '  modifier onlyOwner() {\n', '    require(_owner == msg.sender, "Ownable: caller is not the owner");\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    name = "Arsu";\n', '    symbol = "ARSU";\n', '    decimals = 9;\n', '    supplyTotal = tokensMax;\n', '    unitsPerToken = div(unitsTotal, supplyTotal);\n', '    uint unitsInitial =  mul(unitsPerToken, tokensInitial);\n', '    tokensCurrent = tokensInitial;\n', '    balances[msg.sender] = unitsInitial;\n', '    _owner = msg.sender;\n', '    emit Transfer(address(0), msg.sender, tokensInitial);\n', '  }\n', '\n', '  function rebase(int supplyDelta) external onlyOwner returns (uint) {\n', '    if (supplyDelta == 0) {\n', '        emit RebaseEvent(supplyDelta);\n', '        return supplyTotal;\n', '    }\n', '    \n', '    if (supplyDelta < 0) {\n', '        tokensCurrent = sub(tokensCurrent, div(mul(uint(-supplyDelta), tokensCurrent), supplyTotal));\n', '        supplyTotal = sub(supplyTotal, uint(-supplyDelta));\n', '    }\n', '    \n', '    if (supplyDelta > 0) {\n', '        tokensCurrent = add(tokensCurrent, div(mul(uint(supplyDelta), tokensCurrent), supplyTotal));\n', '        supplyTotal = add(supplyTotal, uint(supplyDelta));\n', '    }\n', '\n', '    unitsPerToken = div(unitsTotal, supplyTotal);\n', '\n', '    emit RebaseEvent(supplyDelta);\n', '    return supplyTotal;\n', '  }\n', '\n', '  function totalSupply() public view returns (uint) {\n', '    return tokensCurrent;\n', '  }\n', '  \n', '  function balanceOf(address who) public view returns (uint) {\n', '    return div(balances[who], unitsPerToken);\n', '  }\n', '\n', '  function transfer(address to, uint value) public returns (bool) {\n', '    uint unitValue = mul(value, unitsPerToken);\n', '    balances[msg.sender] = sub(balances[msg.sender], unitValue);\n', '    balances[to] = add(balances[to], unitValue);\n', '    emit Transfer(msg.sender, to, value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address owner_, address spender) public view returns (uint) {\n', '    return allowed[owner_][spender];\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '    allowed[from][msg.sender] = sub(allowed[from][msg.sender], value);\n', '\n', '    uint unitValue = mul(value, unitsPerToken);\n', '    balances[from] = sub(balances[from], unitValue);\n', '    balances[to] = add(balances[to], unitValue);\n', '    emit Transfer(from, to, value);\n', '\n', '    return true;\n', '  }\n', '\n', '  function approve(address spender, uint value) public returns (bool) {\n', '    allowed[msg.sender][spender] = value;\n', '    emit Approval(msg.sender, spender, value);\n', '    return true;\n', '  }\n', '\n', '  function increaseAllowance(address spender, uint addedValue) public returns (bool) {\n', '    allowed[msg.sender][spender] = add(allowed[msg.sender][spender], addedValue);\n', '    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\n', '    uint256 oldValue = allowed[msg.sender][spender];\n', '    if (subtractedValue >= oldValue) {\n', '      allowed[msg.sender][spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][spender] = sub(oldValue, subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '\n', '  event RebaseEvent(int supplyDelta);\n', '\n', '}\n', '\n', 'abstract contract TwinContract {\n', '    \n', '    function totalBalanceOf(address _of) virtual public view returns (uint256 amount);\n', '    function mint(address unlocker, uint unlockAmount) virtual external returns (bool);\n', '    function getRewardsGiven() virtual public view returns(uint);\n', '    function rebase(int supplyDelta) virtual external returns (uint);\n', '    function getTokensCurrent() virtual public view returns(uint);\n', '    function getSupplyTotal() virtual public view returns (uint);\n', '    function setTokensCurrent(uint newTokens) virtual external returns(uint);\n', '    function getUnitsPerToken() virtual public view returns (uint);\n', '    \n', '}\n', '\n', 'abstract contract ThirdPartyContract {\n', '    \n', '    function transferFrom(address from, address to, uint256 value) virtual public returns (bool);\n', '    function transfer(address to, uint value) virtual public returns (bool);\n', '    \n', '}\n', '\n', 'contract Arsu is ERC20wRebase {\n', '  \n', '  uint public totalValueTPT;\n', '  uint public totalRewardsGivenTPT;\n', '  \n', '  address public twinAddress;\n', '  TwinContract private twinContract;\n', '  address public thirdPartyTokenAddress;\n', '  ThirdPartyContract private thirdPartyContract;\n', '  uint public lockingEnabledTime;\n', '  bool public lockEnabled = false;\n', '\n', '  event Mint(address mintee, uint amount);\n', '  event Lock(address locker, uint lockAmount, uint duration);\n', '  event Unlock(address unlocker, uint unlockAmount);\n', '  event UpdatePosition(address updater, int amountDelta, int timeDelta);\n', '  event LockTPT(address locker, uint lockAmount, uint duration);\n', '  event UnlockTPT(address unlocker);\n', '  event UpdatePositionTPT(address updater, int amountDelta, int timeDelta);\n', '  event EnableLock();\n', '  event SetTwin(address twinAddress);\n', '  event SetTPT(address tptAddress);\n', '  event ChangeOwner(address newOwner);\n', '  \n', '  modifier onlyTwin() {\n', '    require(msg.sender == twinAddress, "Ownable: caller is not the owner");\n', '    _;\n', '  }\n', '  \n', '  function setTwin(address addr) external onlyOwner returns (bool) {\n', '    require(twinAddress == address(0), "TWIN_ALREADY_SET");\n', '    twinAddress = addr;\n', '    twinContract = TwinContract(addr);\n', '    emit SetTwin(addr);\n', '    return true;\n', '  }\n', '  \n', '  function setTPT(address addr) external onlyOwner returns (bool) {\n', '      thirdPartyTokenAddress = addr;\n', '      thirdPartyContract = ThirdPartyContract(addr);\n', '      emit SetTPT(addr);\n', '      return true;\n', '  }\n', '  \n', '  function changeOwner(address addr) external onlyOwner returns (bool) {\n', '    _owner = addr;\n', '    emit ChangeOwner(addr);\n', '    return true;\n', '  }\n', '\n', '  mapping(address => lockStruct) public locked;\n', '  mapping(address => lockTPTStruct) public lockedTPT;\n', '  \n', '  struct lockStruct {\n', '    uint amount;\n', '    bytes16 percentSupplyLocked;\n', '    uint unlockTime;\n', '    bool punishmentFlag;\n', '    uint confirmedReward;\n', '    bytes16 supplyWhenLastModified;\n', '  }\n', '  \n', '  struct lockTPTStruct {\n', '    uint amount;\n', '    uint value;\n', '    uint unlockTime;\n', '    bool punishmentFlag;\n', '    uint confirmedReward;\n', '    bytes16 supplyWhenLastModified;\n', '  }\n', '  \n', '  function mint(address unlocker, uint unlockAmount) external onlyTwin returns (bool) {\n', '    uint addedTokens = unlockAmount;\n', '    uint addedUnits = mul(unitsPerToken, addedTokens);\n', '    tokensCurrent = add(tokensCurrent, addedTokens);\n', '    balances[unlocker] = add(balances[unlocker], addedUnits);\n', '    emit Mint(unlocker, unlockAmount);\n', '    return true;\n', '  }\n', '  \n', '  function enableLocking() external onlyOwner returns (bool) {\n', '    require(!lockEnabled, "LOCKING_ALREADY_ENABLED");\n', '    lockEnabled = true;\n', '    lockingEnabledTime = now;\n', '    emit EnableLock();\n', '    return lockEnabled;\n', '  }\n', '  \n', '  function lock(uint amount, uint duration) public returns (bool) {\n', '    require(locked[msg.sender].amount == 0, "POSITION_ALREADY_EXISTS");\n', '    require(amount > 0, "INVALID_AMOUNT");\n', '    require(duration > 0, "INVALID_DURATION");\n', '    require(lockEnabled, "LOCKING_NOT_ENABLED_YET");\n', '    uint unitAmount = mul(amount, unitsPerToken);\n', '    uint unitsCurrent = mul(tokensCurrent, unitsPerToken);\n', '    bytes16 percentSupplyLocked = divABDK(fromUInt(unitAmount), fromUInt(unitsCurrent));\n', '    uint unlockTime = add(now, duration);\n', '    locked[msg.sender] = lockStruct(unitAmount, percentSupplyLocked, unlockTime, false, 0, mulABDK(totalSupplyAtTime(sub(now, lockingEnabledTime)), 0x40d3c25c268497681c2650cb4be40d60));\n', '    transfer(address(this), amount);\n', '    emit Lock(msg.sender, amount, duration);\n', '    return true;\n', '  }\n', '  \n', '  function lockTPT(uint amount, uint duration) public returns (bool) {\n', '    require(lockedTPT[msg.sender].amount == 0, "POSITION_ALREADY_EXISTS");\n', '    require(amount > 0, "INVALID_AMOUNT");\n', '    require(duration > 0, "INVALID_DURATION");\n', '    require(lockEnabled, "LOCKING_NOT_ENABLED_YET");\n', '    uint value = mul(amount, mul(duration, duration));\n', '    totalValueTPT = add(totalValueTPT, value);\n', '    lockedTPT[msg.sender] = lockTPTStruct(amount, value, add(now, duration), false, 0, mulABDK(totalSupplyAtTime(sub(now, lockingEnabledTime)), 0x40d3c25c268497681c2650cb4be40d60));\n', '    thirdPartyContract.transferFrom(msg.sender, address(this), amount);\n', '    emit LockTPT(msg.sender, amount, duration);\n', '    return true;\n', '  }\n', '\n', '  function calculateUnlockReward(address unlocker, uint unlockTime, bool includeConfirmed) private view returns (uint reward) {\n', '    bool pseudoFlag = false;\n', '    if (locked[unlocker].punishmentFlag || locked[unlocker].unlockTime > unlockTime) {\n', '      pseudoFlag = true;\n', '    }\n', '    int timeUnlockTimeDiff = int(unlockTime) - int(locked[unlocker].unlockTime);\n', '    if (timeUnlockTimeDiff < 0) {\n', '      timeUnlockTimeDiff = -timeUnlockTimeDiff;\n', '    }\n', '    uint minNowUnlockTime = (unlockTime + locked[unlocker].unlockTime) / 2 - uint(timeUnlockTimeDiff) / 2;\n', '    require(minNowUnlockTime == unlockTime || minNowUnlockTime == locked[unlocker].unlockTime, "MIN_ERROR");\n', '    reward = toUInt(mulABDK(subABDK(mulABDK(totalSupplyAtTime(sub(minNowUnlockTime, lockingEnabledTime)), 0x40d3c25c268497681c2650cb4be40d60), locked[unlocker].supplyWhenLastModified), locked[unlocker].percentSupplyLocked));\n', '    if (includeConfirmed) {\n', '        reward = add(reward, locked[unlocker].confirmedReward);\n', '    }\n', '    reward = div(reward, 3);\n', '    if (pseudoFlag) {\n', '      reward = div(reward, 2);\n', '    }\n', '  }\n', '  \n', '  function calculateUnlockRewardTPT(address unlocker, uint unlockTime, bool includeConfirmed) private view returns (uint reward) {\n', '    bool pseudoFlag = false;\n', '    if(lockedTPT[unlocker].punishmentFlag || lockedTPT[unlocker].unlockTime > unlockTime) {\n', '      pseudoFlag = true;\n', '    }\n', '    int timeUnlockTimeDiff = int(unlockTime) - int(lockedTPT[unlocker].unlockTime);\n', '    if (timeUnlockTimeDiff < 0) {\n', '      timeUnlockTimeDiff = -timeUnlockTimeDiff;\n', '    }\n', '    uint minNowUnlockTime = (unlockTime + lockedTPT[unlocker].unlockTime) / 2 - uint(timeUnlockTimeDiff) / 2;\n', '    require(minNowUnlockTime == unlockTime || minNowUnlockTime == lockedTPT[unlocker].unlockTime, "MIN_ERROR");\n', '    reward = toUInt(mulABDK(subABDK(mulABDK(totalSupplyAtTime(sub(minNowUnlockTime, lockingEnabledTime)), 0x40d3c25c268497681c2650cb4be40d60), lockedTPT[unlocker].supplyWhenLastModified), divABDK(fromUInt(lockedTPT[unlocker].value), fromUInt(totalValueTPT))));\n', '    if (includeConfirmed) {\n', '        reward = add(reward, lockedTPT[unlocker].confirmedReward);\n', '    }\n', '    reward = toUInt(mulABDK(fromUInt(reward), subABDK(0x3fff0000000000000000000000000000, divABDK(fromUInt(totalRewardsGivenTPT), mulABDK(subABDK(totalSupplyAtTime(sub(now, lockingEnabledTime)), 0x40202a05f20000000000000000000000), 0x40d3c25c268497681c2650cb4be40d60)))));\n', '    reward = toUInt(mulABDK(fromUInt(reward), 0x3ffe5555555555555555555555555555));\n', '    if (pseudoFlag) {\n', '      reward = div(reward, 2);\n', '    }      \n', '  }\n', '  \n', '  function updatePosition(int amountDelta, int durationDelta) public returns (bool) {\n', '    require(locked[msg.sender].amount > 0, "NO_POSITION");\n', '\n', '    uint confirmedReward = calculateUnlockReward(msg.sender, now, false) * 2;\n', '    locked[msg.sender].confirmedReward = add(locked[msg.sender].confirmedReward, confirmedReward);\n', '\n', '    uint unitsCurrent = mul(tokensCurrent, unitsPerToken);\n', '\n', '    if (locked[msg.sender].unlockTime < now) {\n', '        require (durationDelta > 0, "DURATION_DELTA_OF_EXPIRED_POSITION_MUST_BE_POSITIVE");\n', '        require (amountDelta >= 0, "AMOUNT_DELTA_OF_EXPIRE_POSITION_MUST_BE_AT_LEAST_ZERO");\n', '        bytes16 percentSupplyLocked = divABDK(fromUInt(locked[msg.sender].amount), fromUInt(unitsCurrent));\n', '        locked[msg.sender].percentSupplyLocked = percentSupplyLocked;\n', '        locked[msg.sender].unlockTime = now;\n', '    }\n', '\n', '    if (amountDelta > 0) {\n', '      uint unitDelta = mul(uint(amountDelta), unitsPerToken);\n', '      locked[msg.sender].amount = add(locked[msg.sender].amount, unitDelta);\n', '      bytes16 percentSupplyLocked = divABDK(fromUInt(unitDelta), fromUInt(unitsCurrent));\n', '      locked[msg.sender].percentSupplyLocked = addABDK(locked[msg.sender].percentSupplyLocked, percentSupplyLocked);\n', '      transfer(address(this), uint(amountDelta));\n', '    }\n', '    \n', '    if (amountDelta < 0) {\n', '      uint unitDelta = mul(uint(-amountDelta), unitsPerToken);\n', '      locked[msg.sender].amount = sub(locked[msg.sender].amount, unitDelta);\n', '      bytes16 percentSupplyLocked = divABDK(fromUInt(unitDelta), fromUInt(unitsCurrent));\n', '      locked[msg.sender].percentSupplyLocked = subABDK(locked[msg.sender].percentSupplyLocked, percentSupplyLocked);\n', '      locked[msg.sender].punishmentFlag = true;\n', '      this.transfer(msg.sender, uint(-amountDelta));\n', '    }\n', '\n', '    if (durationDelta < 0) {\n', '      locked[msg.sender].unlockTime = sub(locked[msg.sender].unlockTime, uint(-durationDelta));\n', '      locked[msg.sender].punishmentFlag = true;\n', '    }\n', '\n', '    if (durationDelta > 0) {\n', '      locked[msg.sender].unlockTime = add(locked[msg.sender].unlockTime, uint(durationDelta));\n', '    }\n', '    \n', '    locked[msg.sender].supplyWhenLastModified = mulABDK(totalSupplyAtTime(sub(now, lockingEnabledTime)), 0x40d3c25c268497681c2650cb4be40d60);\n', '\n', '    require(locked[msg.sender].amount > 0, "POSITION_AMOUNT_CANNOT_BE_NEGATIVE");\n', '    require(locked[msg.sender].unlockTime > now, "UNLOCKTIME_MUST_BE_IN_FUTURE");\n', '    \n', '    emit UpdatePosition(msg.sender, amountDelta, durationDelta);\n', '    return true;\n', '  }\n', '  \n', '  function updatePositionTPT(int amountDelta, int durationDelta) public returns (bool) {\n', '    require(lockedTPT[msg.sender].amount > 0, "NO_POSITION");\n', '    \n', '    uint confirmedReward = calculateUnlockRewardTPT(msg.sender, now, false) * 2;\n', '    lockedTPT[msg.sender].confirmedReward = add(lockedTPT[msg.sender].confirmedReward, confirmedReward);\n', '\n', '    if (lockedTPT[msg.sender].unlockTime < now) {\n', '        require (durationDelta > 0, "DURATION_DELTA_OF_EXPIRED_POSITION_MUST_BE_POSITIVE");\n', '        require (amountDelta >= 0, "AMOUNT_DELTA_OF_EXPIRE_POSITION_MUST_BE_AT_LEAST_ZERO");\n', '        lockedTPT[msg.sender].unlockTime = now;\n', '    }\n', '\n', '    if (amountDelta > 0) {\n', '      lockedTPT[msg.sender].amount = add(lockedTPT[msg.sender].amount, uint(amountDelta));\n', '      uint timeUntilUnlock = sub(lockedTPT[msg.sender].unlockTime, now);\n', '      uint value = mul(uint(amountDelta), mul(timeUntilUnlock, timeUntilUnlock));\n', '      totalValueTPT = add(totalValueTPT, value);\n', '      lockedTPT[msg.sender].value = add(lockedTPT[msg.sender].value, value);\n', '      thirdPartyContract.transferFrom(msg.sender, address(this), uint(amountDelta));\n', '    }\n', '    \n', '    if (amountDelta < 0) {\n', '      lockedTPT[msg.sender].amount = sub(lockedTPT[msg.sender].amount, uint(-amountDelta));\n', '      uint timeUntilUnlock = sub(lockedTPT[msg.sender].unlockTime, now);\n', '      uint value = mul(uint(-amountDelta), mul(timeUntilUnlock, timeUntilUnlock));\n', '      totalValueTPT = sub(totalValueTPT, value);\n', '      lockedTPT[msg.sender].value = sub(lockedTPT[msg.sender].value, value);\n', '      lockedTPT[msg.sender].punishmentFlag = true;\n', '      thirdPartyContract.transfer(msg.sender, uint(-amountDelta));\n', '    }\n', '\n', '    if (durationDelta < 0) {\n', '      lockedTPT[msg.sender].unlockTime = sub(lockedTPT[msg.sender].unlockTime, uint(-durationDelta));\n', '      uint value = mul(lockedTPT[msg.sender].amount, mul(uint(-durationDelta), uint(-durationDelta)));\n', '      totalValueTPT = sub(totalValueTPT, value);\n', '      lockedTPT[msg.sender].value = sub(lockedTPT[msg.sender].value, value);\n', '      lockedTPT[msg.sender].punishmentFlag = true;\n', '    }\n', '\n', '    if (durationDelta > 0) {\n', '      lockedTPT[msg.sender].unlockTime = add(lockedTPT[msg.sender].unlockTime, uint(durationDelta));\n', '      uint value = mul(lockedTPT[msg.sender].amount, mul(uint(durationDelta), uint(durationDelta)));\n', '      totalValueTPT = add(totalValueTPT, value);\n', '      lockedTPT[msg.sender].value = add(lockedTPT[msg.sender].value, value);\n', '    }\n', '    \n', '    lockedTPT[msg.sender].supplyWhenLastModified = mulABDK(totalSupplyAtTime(sub(now, lockingEnabledTime)), 0x40d3c25c268497681c2650cb4be40d60);\n', '    \n', '    require(lockedTPT[msg.sender].amount > 0, "POSITION_AMOUNT_CANNOT_BE_NEGATIVE");\n', '    require(lockedTPT[msg.sender].unlockTime > now, "UNLOCKTIME_MUST_BE_IN_FUTURE");\n', '    \n', '    emit UpdatePositionTPT(msg.sender, amountDelta, durationDelta);\n', '    return true;\n', '  }\n', '  \n', '  function unlock() public returns (bool success) {\n', '    require(locked[msg.sender].amount > 0, "NO_POSITION");\n', '    uint tokenAmount = div(locked[msg.sender].amount, unitsPerToken);\n', '    this.transfer(msg.sender, tokenAmount);\n', '    uint reward = calculateUnlockReward(msg.sender, now, true);\n', '    uint rewardTokens = div(reward, twinContract.getUnitsPerToken());\n', '    success = twinContract.mint(msg.sender, rewardTokens);\n', '    locked[msg.sender] = lockStruct(0, bytes16(0), 0, false, 0, bytes16(0));\n', '    require(success, "MINT_FAILED");\n', '    emit UnlockTPT(msg.sender);\n', '  }\n', '  \n', '  function unlockTPT() public returns (bool success) {\n', '    require(lockedTPT[msg.sender].amount > 0, "NO_POSITION");\n', '    thirdPartyContract.transfer(msg.sender, lockedTPT[msg.sender].amount);\n', '    uint reward = calculateUnlockRewardTPT(msg.sender, now, true);\n', '    totalRewardsGivenTPT = add(reward, totalRewardsGivenTPT);\n', '    uint rewardTokens = div(reward, twinContract.getUnitsPerToken());\n', '    success = twinContract.mint(msg.sender, rewardTokens);\n', '    totalValueTPT = sub(totalValueTPT, lockedTPT[msg.sender].value);\n', '    lockedTPT[msg.sender] = lockTPTStruct(0, 0, 0, false, 0, bytes16(0));\n', '    require(success, "MINT_FAILED");\n', '    emit UnlockTPT(msg.sender);\n', '  }\n', '  \n', '  function getRewardTokens(address addr, uint time) public view returns (uint) {\n', '    require(locked[addr].amount > 0, "NO_POSITION");\n', '    return div(calculateUnlockReward(addr, time, true), twinContract.getUnitsPerToken());\n', '  }\n', '  \n', '  function getLockedTokens(address addr) public view returns (uint) {\n', '    require(locked[addr].amount > 0, "NO_POSITION");\n', '    return div(locked[addr].amount, unitsPerToken);   \n', '  }\n', '  \n', '  function getRewardTokensTPT(address addr, uint time) public view returns (uint) {\n', '    require(lockedTPT[addr].amount > 0, "NO_POSITION");\n', '    return div(calculateUnlockRewardTPT(addr, time, true), twinContract.getUnitsPerToken());\n', '  }\n', '  \n', '  function getUnitsPerToken() public view returns (uint) {\n', '      return unitsPerToken;\n', '  }\n', '\n', '}']