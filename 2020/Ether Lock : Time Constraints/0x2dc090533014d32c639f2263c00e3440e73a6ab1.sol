['///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '//////////////////////////////////////////////////################################################################/////////////////////////////////////////////////////////////////////////\n', '///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '///////////////////////////////////////////////////THIS IS THE RPEPEBLU POOL OF KEK STAKING - rPepe Token Staking//////////////////////////////////////////////////////////////////////////\n', '///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '//////////////////////////////////////////////////################################################################/////////////////////////////////////////////////////////////////////////\n', '///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' *\n', '*/\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function ceil(uint a, uint m) internal pure returns (uint r) {\n', '    return (a + m - 1) / m * m;\n', '  }\n', '}\n', '\n', 'interface IKEK{\n', '    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\n', '    function transfer(address to, uint256 tokens) external returns (bool success);\n', '    function claimRewards(uint256 rewards, address rewardedTo) external returns(bool);\n', '    function stakingRewardsAvailable() external view returns(uint256 _rewardsAvailable);\n', '}\n', '\n', 'pragma solidity ^0.6.0;\n', 'contract rPepeToKEK {\n', '    using SafeMath for uint256;\n', '    \n', '    uint256 public currentStakingRate;\n', '    address public KEK = 0x31AEe7Db3b390bAaD34213C173A9df0dd11D84bd;\n', '    address public RPepe = 0x0e9b56D2233ea2b5883861754435f9C51Dbca141;\n', '    \n', '    uint256 public totalRewards;\n', '    uint256 private basePercent = 100;\n', '    \n', '    struct DepositedToken{\n', '        uint256 activeDeposit;\n', '        uint256 totalDeposits;\n', '        uint256 startTime;\n', '        uint256 pendingGains;\n', '        uint256 lastClaimedDate;\n', '        uint256 totalGained;\n', '        uint    rate;\n', '    }\n', '    \n', '    mapping(address => DepositedToken) users;\n', '    \n', '    event Staked(address indexed staker, uint256 indexed tokens);\n', '    event StakingRateChanged(uint256 indexed stakingRatePerHour);\n', '    event TokensClaimed(address indexed claimer, uint256 indexed stakedTokens);\n', '    event RewardClaimed(address indexed claimer, uint256 indexed reward);\n', '    \n', '    constructor() public{\n', '        currentStakingRate = 1e16; // 0.01 per hour\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Start staking\n', '    // @param _amount amount of tokens to deposit\n', '    // ------------------------------------------------------------------------\n', '    function Stake(uint256 _amount) external {\n', '        \n', '        // transfer tokens from user to the contract balance\n', '        require(IKEK(RPepe).transferFrom(msg.sender, address(this), _amount));\n', '        \n', '        uint256 tokensBurned = findTwoPointFivePercent(_amount);\n', '        uint256 tokensTransferred = _amount.sub(tokensBurned);\n', '    \n', '        // add new stake\n', '        _addToStake(tokensTransferred);\n', '        \n', '        emit Staked(msg.sender, _amount);\n', '        \n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Claim reward and staked tokens\n', '    // @required user must be a staker\n', '    // @required must be claimable\n', '    // ------------------------------------------------------------------------\n', '    function ClaimStakedTokens() public {\n', '        require(users[msg.sender].activeDeposit > 0, "no running stake");\n', '        \n', '        uint256 _currentDeposit = users[msg.sender].activeDeposit;\n', '        \n', '        // check if we have any pending reward, add it to pendingGains var\n', '        users[msg.sender].pendingGains = PendingReward(msg.sender);\n', '        // update amount \n', '        users[msg.sender].activeDeposit = 0;\n', '        \n', '        // transfer staked tokens\n', '        require(IKEK(RPepe).transfer(msg.sender, _currentDeposit));\n', '        \n', '        emit TokensClaimed(msg.sender, _currentDeposit);\n', '        \n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Claim reward and staked tokens\n', '    // @required user must be a staker\n', '    // @required must be claimable\n', '    // ------------------------------------------------------------------------\n', '    function ClaimReward() public {\n', '        require(PendingReward(msg.sender) > 0, "nothing pending to claim");\n', '    \n', '        uint256 _pendingReward = PendingReward(msg.sender);\n', '        \n', '        // add claimed reward to global stats\n', '        totalRewards = totalRewards.add(_pendingReward);\n', '        // add the reward to total claimed rewards\n', '        users[msg.sender].totalGained = users[msg.sender].totalGained.add(_pendingReward);\n', '        // update lastClaim amount\n', '        users[msg.sender].lastClaimedDate = now;\n', '        // reset previous rewards\n', '        users[msg.sender].pendingGains = 0;\n', '        \n', '        // send tokens from KEK to the user\n', '        require(IKEK(KEK).claimRewards(_pendingReward, msg.sender));\n', '        \n', '        _updateStakingRate();\n', '        // update staking rate\n', '        users[msg.sender].rate = currentStakingRate;\n', '        \n', '        emit RewardClaimed(msg.sender, _pendingReward);\n', '    }\n', '    \n', '    function Exit() external{\n', '        if(PendingReward(msg.sender) > 0)\n', '            ClaimReward();\n', '        if(users[msg.sender].activeDeposit > 0)\n', '            ClaimStakedTokens();\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Private function to update the staking rate\n', '    // ------------------------------------------------------------------------\n', '    function _updateStakingRate() private{\n', '        uint256 originalRewards = 49000000 * 10 ** 18;\n', '        \n', '        // check the current volume of the rewards\n', '        uint256 rewardsAvailable = IKEK(KEK).stakingRewardsAvailable();\n', '        uint256 rewardsRemoved = originalRewards.sub(rewardsAvailable);\n', '        \n', '        if(rewardsRemoved >= 12250000 * 10 ** 18 && rewardsRemoved < 24500000 * 10 ** 18) { // less than 25% but greater than 50%\n', '            currentStakingRate =  5e15; // 0.005 per hour\n', '        }\n', '        else if(rewardsRemoved >= 24500000 * 10 ** 18 && rewardsRemoved < 34300000 * 10 ** 18){ // less than equal to 50% but greater than 70%\n', '            currentStakingRate = 2e15; // 0.002 per hour\n', '        }\n', '        else if(rewardsRemoved >= 34300000 * 10 ** 18 && rewardsRemoved < 44100000 * 10 ** 18){ // less than equal to 70% but greater than 90%\n', '            currentStakingRate = 1e15; // 0.001 per hour\n', '        }\n', '        else if(rewardsRemoved >= 44100000 * 10 ** 18) {\n', '            currentStakingRate = 5e14; // 0.0005 per hour\n', '        }\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Query to get the pending reward\n', '    // ------------------------------------------------------------------------\n', '    function PendingReward(address _caller) public view returns(uint256 _pendingReward){\n', '        uint256 _totalStakedTime = (now.sub(users[_caller].lastClaimedDate)).div(1 hours); // in hours\n', '        \n', '        uint256 reward = ((users[_caller].activeDeposit).mul(_totalStakedTime.mul(users[_caller].rate)));\n', '        reward = reward.div(10 ** 18);\n', '        return reward.add(users[_caller].pendingGains);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Query to get the active stake of the user\n', '    // ------------------------------------------------------------------------\n', '    function YourActiveStake(address _user) external view returns(uint256 _activeStake){\n', '        return users[_user].activeDeposit;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Query to get the total stakes of the user\n', '    // ------------------------------------------------------------------------\n', '    function YourTotalStakes(address _user) external view returns(uint256 _totalStakes){\n', '        return users[_user].totalDeposits;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Query to get total earned rewards from stake\n', '    // ------------------------------------------------------------------------\n', '    function TotalStakeRewardsClaimed(address _user) external view returns(uint256 _totalEarned){\n', '        return users[_user].totalGained;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Query to get the staking rate you staked at\n', '    // ------------------------------------------------------------------------\n', '    function YourStakingRate(address _user) external view returns(uint256 _stakingRate){\n', '        return users[_user].rate;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Internal function to add new deposit\n', '    // ------------------------------------------------------------------------        \n', '    function _addToStake(uint256 _amount) internal{\n', '        _updateStakingRate();\n', '        \n', '        // check if we have any pending reward, add it to pendingGains variable\n', '        users[msg.sender].pendingGains = PendingReward(msg.sender);\n', '        users[msg.sender].rate = currentStakingRate; // rate for stakers will be fixed at time of staking\n', '            \n', '        users[msg.sender].activeDeposit = _amount;\n', '        users[msg.sender].totalDeposits = users[msg.sender].totalDeposits.add(_amount);\n', '        users[msg.sender].startTime = now;\n', '        users[msg.sender].lastClaimedDate = now;\n', '        \n', '    }\n', '    \n', '    //// utility function from RPepe\n', '    function findTwoPointFivePercent(uint256 value) public view returns (uint256)  {\n', '        uint256 roundValue = value.ceil(basePercent);\n', '        uint256 twoPointFivePercent = roundValue.mul(basePercent).div(4000);\n', '        return twoPointFivePercent;\n', '    }\n', '}']