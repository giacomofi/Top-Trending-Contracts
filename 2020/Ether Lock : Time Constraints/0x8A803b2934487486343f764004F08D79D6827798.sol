['// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity >= 0.5.1;\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', 'library Math {\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        z = x < y ? x : y;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '    }\n', '}\n', '\n', 'interface IBSpare {\n', '    function requestSpare(uint amount) external;\n', '}\n', '\n', 'interface IERC20 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', 'contract BMining {\n', '    using SafeMath for uint;\n', '    \n', '    uint public constant CONTRACT_DURATION = 6500 * 365;\n', '    uint public constant INCOME_NUMERATOR  = 136;\n', '    uint public constant INCOME_DENOMINATOR  = 100;\n', '    \n', '    uint public startBlock;\n', '    uint public endBlock;\n', '    address public BETH;\n', '    address public owner;\n', '    address public admin;\n', '    address public BSpare;\n', '\n', '    struct Data {\n', '        uint stakes;\n', '        uint lastAuditBlock;\n', '        uint rewards;\n', '        bool used;\n', '    }\n', '    \n', '    mapping (address => Data) users;\n', '    Data public global;\n', '    uint public sparedReward;\n', '    uint public mintedReward;\n', '    uint public totalIncome;\n', '    uint public userCount;\n', '    \n', '    receive() external payable {\n', '        if(msg.sender != BSpare) {\n', '            totalIncome += msg.value;\n', '        }\n', '    }\n', '    \n', '    constructor(address _BETH) public {\n', '        BETH = _BETH;\n', '        owner = msg.sender;\n', '        admin = msg.sender;\n', '    }\n', '    \n', '    function setupAdmin(address _admin) public {\n', '        require(msg.sender == owner, "REQUIRE OWNER");\n', '        admin = _admin;\n', '    }\n', '    \n', '    function setupSpare(address _spare) public {\n', '        require(msg.sender == owner, "REQUIRE OWNER");\n', '        BSpare = _spare;\n', '    }\n', '    \n', '    function turnOn() public returns (bool) {\n', '        require(BSpare != address(0), "SETUP Spare FIRST");\n', '        require(msg.sender == admin, "REQUIRE ADMIN");\n', '        require(startBlock == 0, "ALREADY TURN ON");\n', '        startBlock = block.number;\n', '        endBlock = startBlock.add(CONTRACT_DURATION);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function isOn() view public returns (bool) {\n', '        return endBlock > 0;\n', '    }\n', '    \n', '    function stake(uint amount) external {\n', '        require(endBlock == 0 || block.number < endBlock, "ALREADY END");\n', '        Data storage data = users[msg.sender];\n', '        _audit(msg.sender);\n', '        TransferHelper.safeTransferFrom(BETH, msg.sender, address(this), amount);\n', '        data.stakes = data.stakes.add(amount);\n', '        global.stakes = global.stakes.add(amount);\n', '        if(!data.used) {\n', '            userCount = userCount.add(1);\n', '            data.used = true;\n', '        }\n', '    }\n', '    \n', '    function withdraw(uint amount) external {\n', '        require(users[msg.sender].stakes >= amount, "INSUFFCIENT WITHDRAW AMOUNT");\n', '        _audit(msg.sender);\n', '        \n', '        TransferHelper.safeTransfer(BETH, msg.sender, amount);\n', '        users[msg.sender].stakes = users[msg.sender].stakes.sub(amount);\n', '        global.stakes = global.stakes.sub(amount);\n', '    }\n', '    \n', '    function mintReward() public returns(uint) {\n', '        _audit(msg.sender);\n', '        return _transferReward();\n', '    }\n', '    \n', '    function queryStakeInfo() public view returns(uint stakeAmount, uint lastAuditBlock, uint rewards, uint blockNumber) {\n', '        Data memory data = users[msg.sender];\n', '        stakeAmount = data.stakes;\n', '        lastAuditBlock = data.lastAuditBlock;\n', '        rewards = data.rewards.add(_getReward(data));\n', '        blockNumber = block.number;\n', '    }\n', '    \n', '    function queryGlobalInfo() public view returns (uint, uint, uint, uint, uint, uint) {\n', '        return (totalIncome, global.rewards.add(_getReward(global)), global.stakes, userCount, endBlock, INCOME_NUMERATOR);\n', '    }\n', '    \n', '    function queryAmountToExtract() view public returns (uint){\n', '        uint globalReward = _getReward(global) + global.rewards;\n', '        require(globalReward >= mintedReward, "UNKNOWN ERROR");\n', '        if(address(this).balance > sparedReward.add(globalReward).sub(mintedReward)) {\n', '            return address(this).balance.sub(sparedReward.add(globalReward).sub(mintedReward));\n', '        }\n', '        \n', '        return 0;\n', '    }\n', '    \n', '    function extractToSpare() public {\n', '        require(msg.sender == admin, "REQUIRE ADMIN");\n', '        uint amount = queryAmountToExtract();\n', '        if(amount > 0) {\n', '            TransferHelper.safeTransferETH(BSpare, amount);\n', '            sparedReward = 0;\n', '        }\n', '    }\n', '    \n', '    // private method\n', '    function _audit(address user) private {\n', '        Data storage data = users[user];\n', '        data.rewards = data.rewards.add(_getReward(data));\n', '        data.lastAuditBlock = Math.min(block.number, endBlock);\n', '        \n', '        _auditGlobal();\n', '    }\n', '    \n', '    function _auditGlobal() private {\n', '        global.rewards = global.rewards.add(_getReward(global));\n', '        global.lastAuditBlock = Math.min(block.number, endBlock);\n', '    }\n', '    \n', '    function _transferReward() private returns(uint rewards){\n', '        Data storage data = users[msg.sender];\n', '        require(data.rewards > 0, "INSUFFCIENT STAKE REWARDS");\n', '        if(address(this).balance < data.rewards) {\n', '            sparedReward = sparedReward.add(data.rewards.sub(address(this).balance));\n', '            IBSpare(BSpare).requestSpare(data.rewards.sub(address(this).balance));\n', '        }\n', '        \n', '        mintedReward = mintedReward.add(data.rewards);\n', '        require(address(this).balance >= data.rewards, "NOT ENOUGH BALANCE NOW");\n', '        \n', '        TransferHelper.safeTransferETH(msg.sender, data.rewards);\n', '        rewards = data.rewards;\n', '        data.rewards = 0;\n', '    }\n', '    \n', '    function _getReward (Data memory data) private view returns(uint reward) {\n', '        if(!isOn()) {\n', '            return 0;\n', '        } \n', '        uint auditBlock = Math.min(block.number, endBlock);\n', '        uint stakeDuration = data.lastAuditBlock > startBlock ? auditBlock.sub(data.lastAuditBlock) : auditBlock.sub(startBlock);\n', '        reward = data.stakes.mul(stakeDuration).mul(INCOME_NUMERATOR) / INCOME_DENOMINATOR / CONTRACT_DURATION;\n', '    }\n', '}']