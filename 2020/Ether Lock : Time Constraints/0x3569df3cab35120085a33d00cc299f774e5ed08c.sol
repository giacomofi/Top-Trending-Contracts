['/**\n', ' *Submitted for verification at Etherscan.io on 2020-11-05\n', '*/\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns(uint supply);\n', '\n', '    function balanceOf(address _owner) external view returns(uint balance);\n', '\n', '    function transfer(address _to, uint _value) external returns(bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\n', '\n', '    function approve(address _spender, uint _value) external returns(bool success);\n', '\n', '    function allowance(address _owner, address _spender) external view returns(uint remaining);\n', '\n', '    function decimals() external view returns(uint digits);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', '\n', 'contract PSandBoxMock{\n', '\n', '    //globals\n', '    mapping (address => mapping (address => uint256)) depositBalances;\n', '    address ETH_TOKEN_ADDRESS  = address(0x0);\n', '    address payable owner;\n', '    address [6] stakableTokensList;\n', '    string [6] stakableTokensByNameList;\n', '    \n', '    \n', '    modifier onlyOwner() {\n', '        if (msg.sender == owner) _;\n', '    }\n', '    \n', '  \n', '  constructor() public payable {\n', '      \n', '        owner= msg.sender;\n', '        \n', '        //Dummy data\n', '        populateData();\n', '         \n', '        \n', '  }\n', '  \n', '  fallback() external payable {\n', '      \n', '    deposit(0x0000000000000000000000000000000000000000, msg.value);\n', '  }\n', '  \n', '    function populateData() public{\n', '        stakableTokensByNameList = ["WETH", "DAI", "USDC", "PLEX", "PLEXUSDCLP", "PLEXETHLP"];\n', '     \n', '         \n', '         \n', '         stakableTokensList = [0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, 0x6B175474E89094C44Da98b954EedeAC495271d0F, 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, 0x0391D2021f89DC339F60Fff84546EA23E337750f, 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984, 0xa0246c9032bC3A600820415aE600c6388619A14D]; \n', '        \n', '       \n', '    }\n', '\n', '\n', '   function deposit(address tokenAddress, uint256 amount) payable public returns (bool){\n', '       \n', '       if(tokenAddress == 0x0000000000000000000000000000000000000000){\n', '           \n', '            depositBalances[msg.sender][tokenAddress] = depositBalances[msg.sender][tokenAddress]  + msg.value;\n', '             emit Deposit(msg.sender, amount, tokenAddress);\n', '            return true;\n', '            \n', '        }\n', '        \n', '        ERC20 thisToken = ERC20(tokenAddress);\n', '        require(thisToken.transferFrom(msg.sender, address(this), amount), "Not enough tokens to transferFrom or no approval");\n', '        \n', '        depositBalances[msg.sender][tokenAddress] = depositBalances[msg.sender][tokenAddress]  + amount;\n', '         emit Deposit(msg.sender, amount, tokenAddress);\n', '        return true;\n', '   }\n', '\n', '   function withdraw(address tokenAddress, uint256 amount) payable public returns(bool){\n', '       \n', '        if(tokenAddress == 0x0000000000000000000000000000000000000000){\n', '            require(depositBalances[msg.sender][tokenAddress] >= amount, "You didnt deposit enough eth");\n', '            depositBalances[msg.sender][tokenAddress] = depositBalances[msg.sender][tokenAddress]  - amount;\n', '            msg.sender.send(amount);\n', '            return true;\n', '            \n', '        }\n', '        \n', '        ERC20 thisToken = ERC20(tokenAddress);\n', '        require(thisToken.balanceOf(msg.sender) >= amount, "You do not have enough tokens to withdraw in balanceOf");\n', '        \n', '        depositBalances[msg.sender][tokenAddress] = depositBalances[msg.sender][tokenAddress]  - amount;\n', '        \n', '        require(thisToken.transfer(msg.sender, amount), "You dont have enough tokens inside this contract to withdraw from deposits");\n', '        emit Withdrawal(msg.sender, amount, tokenAddress);\n', '        return true;\n', '        \n', '   }\n', '   \n', '    function getStakableTokens() view public  returns (address[6] memory, string[6] memory){\n', '        \n', '        return (stakableTokensList, stakableTokensByNameList);\n', '        \n', '    }\n', '   \n', '   function getComposition() view public returns(uint256[] memory compAmounts, address[] memory compTokens, string[] memory compNames){\n', '      \n', '       uint256[] memory compAmounts1;\n', '       address[] memory compTokens1;\n', '       string[] memory compNames1;\n', '       \n', '       compAmounts[0] =3000402303203202;\n', '       compAmounts[1]= 3000402303203202;\n', '       compAmounts[2] = 3000402303203202;\n', '       \n', '       compNames[0] = "FARM";\n', '       compNames[1] = "Picke";\n', '       compNames[2] = "YEARN";\n', '       \n', '       return (compAmounts1, compTokens1, compNames1);\n', '       \n', '   }\n', '\n', '   function getAPY(address tokenAddress) public view returns(uint256){\n', '    \n', '    return random(uint(tokenAddress));\n', '    \n', '   }\n', '   \n', '\n', '   function getTotalValueLockedAggregated() public view returns (uint256){\n', '      return 770567001;\n', '   }\n', '\n', '   function getTotalValueLockedInternalByToken(address tokenAddress) public view returns (uint256){\n', '    return 40203 + random(3);\n', '   }\n', '   function getTotalValueLockedInternal() public view returns (uint256){\n', '    return 5790567;\n', '   }\n', '   function timeLeftInEpoch() public view returns (uint256){\n', '        random(2);\n', '   }\n', '\n', '   function getAmountStakedByUser(address tokenAddress, address userAddress) public view returns(uint256){\n', '        return depositBalances[userAddress][tokenAddress];\n', '   }\n', '   function getThisTokenPrice() view public returns(uint256){\n', '        return random(1);\n', '   }\n', '   \n', '   function getUserCurrentReward(address userAddress) view public returns(uint256){\n', '        return random(uint256(userAddress));\n', '   }\n', '   \n', '   function getUserPotentialReward(address userAddress) view public returns(uint256){\n', '        return random(7);\n', '   }\n', '   \n', ' \n', '   \n', '   function random(uint256 nonce) internal view returns (uint) {\n', '    \n', '    uint randomnumber = uint(keccak256(abi.encodePacked(now, msg.sender, nonce))) % 900;\n', '    randomnumber = randomnumber + 100;\n', '    \n', '    return randomnumber;\n', '}\n', '\n', '\n', '    function getUserWalletBalance(address userAddress, address tokenAddress) public view returns (uint256){\n', '        ERC20 token = ERC20(tokenAddress);\n', '        return token.balanceOf(userAddress);\n', '        \n', '    }\n', '\n', '    function adminWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n', '\n', '         if (address(token) == ETH_TOKEN_ADDRESS) {\n', '             destination.transfer(amount);\n', '         }\n', '         else {\n', '             ERC20 tokenToken = ERC20(token);\n', '             require(tokenToken.transfer(destination, amount));\n', '         }\n', '\n', '         return true;\n', '     }\n', '\n', '\n', '\n', '    function kill() virtual public onlyOwner {\n', '       \n', '            selfdestruct(owner);\n', '         \n', '    }\n', '\n', '\n', '    event Deposit(address indexed user, uint256 amount, address token);\n', '    event Withdrawal(address indexed user, uint256 amount, address token);\n', '    \n', '   \n', '  \n', '}']