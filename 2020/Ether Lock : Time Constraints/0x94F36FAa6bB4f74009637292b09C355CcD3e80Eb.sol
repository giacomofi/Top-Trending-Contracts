['pragma solidity 0.6.0;\n', '\n', '/**\n', ' * @title Price contract\n', ' * @dev Price check and call\n', ' */\n', 'contract Nest_3_OfferPrice{\n', '    using SafeMath for uint256;\n', '    using address_make_payable for address;\n', '    using SafeERC20 for ERC20;\n', '    \n', '    Nest_3_VoteFactory _voteFactory;                                //  Voting contract\n', '    ERC20 _nestToken;                                               //  NestToken\n', '    Nest_NToken_TokenMapping _tokenMapping;                         //  NToken mapping\n', '    Nest_3_OfferMain _offerMain;                                    //  Offering main contract\n', '    Nest_3_Abonus _abonus;                                          //  Bonus pool\n', '    address _nTokeOfferMain;                                        //  NToken offering main contract\n', '    address _destructionAddress;                                    //  Destruction contract address\n', '    address _nTokenAuction;                                         //  NToken auction contract address\n', '    struct PriceInfo {                                              //  Block price\n', '        uint256 ethAmount;                                          //  ETH amount\n', '        uint256 erc20Amount;                                        //  Erc20 amount\n', '        uint256 frontBlock;                                         //  Last effective block\n', '        address offerOwner;                                         //  Offering address\n', '    }\n', '    struct TokenInfo {                                              //  Token offer information\n', '        mapping(uint256 => PriceInfo) priceInfoList;                //  Block price list, block number => block price\n', '        uint256 latestOffer;                                        //  Latest effective block\n', '    }\n', '    uint256 destructionAmount = 0 ether;                            //  Amount of NEST to destroy to call prices\n', '    uint256 effectTime = 0 days;                                    //  Waiting time to start calling prices\n', '    mapping(address => TokenInfo) _tokenInfo;                       //  Token offer information\n', '    mapping(address => bool) _blocklist;                            //  Block list\n', '    mapping(address => uint256) _addressEffect;                     //  Effective time of address to call prices \n', '    mapping(address => bool) _offerMainMapping;                     //  Offering contract mapping\n', '    uint256 _priceCost = 0.01 ether;                                //  Call price fee\n', '\n', '    //  Real-time price  token, ETH amount, erc20 amount\n', '    event NowTokenPrice(address a, uint256 b, uint256 c);\n', '    \n', '    /**\n', '    * @dev Initialization method\n', '    * @param voteFactory Voting contract address\n', '    */\n', '    constructor (address voteFactory) public {\n', '        Nest_3_VoteFactory voteFactoryMap = Nest_3_VoteFactory(address(voteFactory));\n', '        _voteFactory = voteFactoryMap;\n', '        _offerMain = Nest_3_OfferMain(address(voteFactoryMap.checkAddress("nest.v3.offerMain")));\n', '        _nTokeOfferMain = address(voteFactoryMap.checkAddress("nest.nToken.offerMain"));\n', '        _abonus = Nest_3_Abonus(address(voteFactoryMap.checkAddress("nest.v3.abonus")));\n', '        _destructionAddress = address(voteFactoryMap.checkAddress("nest.v3.destruction"));\n', '        _nestToken = ERC20(address(voteFactoryMap.checkAddress("nest")));\n', '        _tokenMapping = Nest_NToken_TokenMapping(address(voteFactoryMap.checkAddress("nest.nToken.tokenMapping")));\n', '        _nTokenAuction = address(voteFactoryMap.checkAddress("nest.nToken.tokenAuction"));\n', '        _offerMainMapping[address(_offerMain)] = true;\n', '        _offerMainMapping[address(_nTokeOfferMain)] = true;\n', '    }\n', '    \n', '    /**\n', '    * @dev Modify voting contract\n', '    * @param voteFactory Voting contract address\n', '    */\n', '    function changeMapping(address voteFactory) public onlyOwner {\n', '        Nest_3_VoteFactory voteFactoryMap = Nest_3_VoteFactory(address(voteFactory));\n', '        _voteFactory = voteFactoryMap;                                   \n', '        _offerMain = Nest_3_OfferMain(address(voteFactoryMap.checkAddress("nest.v3.offerMain")));\n', '        _nTokeOfferMain = address(voteFactoryMap.checkAddress("nest.nToken.offerMain"));\n', '        _abonus = Nest_3_Abonus(address(voteFactoryMap.checkAddress("nest.v3.abonus")));\n', '        _destructionAddress = address(voteFactoryMap.checkAddress("nest.v3.destruction"));\n', '        _nestToken = ERC20(address(voteFactoryMap.checkAddress("nest")));\n', '        _tokenMapping = Nest_NToken_TokenMapping(address(voteFactoryMap.checkAddress("nest.nToken.tokenMapping")));\n', '        _nTokenAuction = address(voteFactoryMap.checkAddress("nest.nToken.tokenAuction"));\n', '        _offerMainMapping[address(_offerMain)] = true;\n', '        _offerMainMapping[address(_nTokeOfferMain)] = true;\n', '    }\n', '    \n', '    /**\n', '    * @dev Initialize token price charge parameters\n', '    * @param tokenAddress Token address\n', '    */\n', '    function addPriceCost(address tokenAddress) public {\n', '       \n', '    }\n', '    \n', '    /**\n', '    * @dev Add price\n', '    * @param ethAmount ETH amount\n', '    * @param tokenAmount Erc20 amount\n', '    * @param endBlock Effective price block\n', '    * @param tokenAddress Erc20 address\n', '    * @param offerOwner Offering address\n', '    */\n', '    function addPrice(uint256 ethAmount, uint256 tokenAmount, uint256 endBlock, address tokenAddress, address offerOwner) public onlyOfferMain{\n', '        // Add effective block price information\n', '        TokenInfo storage tokenInfo = _tokenInfo[tokenAddress];\n', '        PriceInfo storage priceInfo = tokenInfo.priceInfoList[endBlock];\n', '        priceInfo.ethAmount = priceInfo.ethAmount.add(ethAmount);\n', '        priceInfo.erc20Amount = priceInfo.erc20Amount.add(tokenAmount);\n', '        if (endBlock != tokenInfo.latestOffer) {\n', '            // If different block offer\n', '            priceInfo.frontBlock = tokenInfo.latestOffer;\n', '            tokenInfo.latestOffer = endBlock;\n', '        }\n', '    }\n', '    \n', '    /**\n', '    * @dev Price modification in taker orders\n', '    * @param ethAmount ETH amount\n', '    * @param tokenAmount Erc20 amount\n', '    * @param tokenAddress Token address \n', '    * @param endBlock Block of effective price\n', '    */\n', '    function changePrice(uint256 ethAmount, uint256 tokenAmount, address tokenAddress, uint256 endBlock) public onlyOfferMain {\n', '        TokenInfo storage tokenInfo = _tokenInfo[tokenAddress];\n', '        PriceInfo storage priceInfo = tokenInfo.priceInfoList[endBlock];\n', '        priceInfo.ethAmount = priceInfo.ethAmount.sub(ethAmount);\n', '        priceInfo.erc20Amount = priceInfo.erc20Amount.sub(tokenAmount);\n', '    }\n', '    \n', '    /**\n', '    * @dev Update and check the latest price\n', '    * @param tokenAddress Token address\n', '    * @return ethAmount ETH amount\n', '    * @return erc20Amount Erc20 amount\n', '    * @return blockNum Price block\n', '    */\n', '    function updateAndCheckPriceNow(address tokenAddress) public payable returns(uint256 ethAmount, uint256 erc20Amount, uint256 blockNum) {\n', '        require(checkUseNestPrice(address(msg.sender)));\n', '        mapping(uint256 => PriceInfo) storage priceInfoList = _tokenInfo[tokenAddress].priceInfoList;\n', '        uint256 checkBlock = _tokenInfo[tokenAddress].latestOffer;\n', '        while(checkBlock > 0 && (checkBlock >= block.number || priceInfoList[checkBlock].ethAmount == 0)) {\n', '            checkBlock = priceInfoList[checkBlock].frontBlock;\n', '        }\n', '        require(checkBlock != 0);\n', '        PriceInfo memory priceInfo = priceInfoList[checkBlock];\n', '        address nToken = _tokenMapping.checkTokenMapping(tokenAddress);\n', '        if (nToken == address(0x0)) {\n', '            _abonus.switchToEth.value(_priceCost)(address(_nestToken));\n', '        } else {\n', '            _abonus.switchToEth.value(_priceCost)(address(nToken));\n', '        }\n', '        if (msg.value > _priceCost) {\n', '            repayEth(address(msg.sender), msg.value.sub(_priceCost));\n', '        }\n', '        emit NowTokenPrice(tokenAddress,priceInfo.ethAmount, priceInfo.erc20Amount);\n', '        return (priceInfo.ethAmount,priceInfo.erc20Amount, checkBlock);\n', '    }\n', '    \n', '    /**\n', '    * @dev Update and check the latest price-internal use\n', '    * @param tokenAddress Token address\n', '    * @return ethAmount ETH amount\n', '    * @return erc20Amount Erc20 amount\n', '    */\n', '    function updateAndCheckPricePrivate(address tokenAddress) public view onlyOfferMain returns(uint256 ethAmount, uint256 erc20Amount) {\n', '        mapping(uint256 => PriceInfo) storage priceInfoList = _tokenInfo[tokenAddress].priceInfoList;\n', '        uint256 checkBlock = _tokenInfo[tokenAddress].latestOffer;\n', '        while(checkBlock > 0 && (checkBlock >= block.number || priceInfoList[checkBlock].ethAmount == 0)) {\n', '            checkBlock = priceInfoList[checkBlock].frontBlock;\n', '        }\n', '        if (checkBlock == 0) {\n', '            return (0,0);\n', '        }\n', '        PriceInfo memory priceInfo = priceInfoList[checkBlock];\n', '        return (priceInfo.ethAmount,priceInfo.erc20Amount);\n', '    }\n', '    \n', '    /**\n', '    * @dev Update and check the effective price list\n', '    * @param tokenAddress Token address\n', '    * @param num Number of prices to check\n', '    * @return uint256[] price list\n', '    */\n', '    function updateAndCheckPriceList(address tokenAddress, uint256 num) public payable returns (uint256[] memory) {\n', '        require(checkUseNestPrice(address(msg.sender)));\n', '        mapping(uint256 => PriceInfo) storage priceInfoList = _tokenInfo[tokenAddress].priceInfoList;\n', '        // Extract data\n', '        uint256 length = num.mul(3);\n', '        uint256 index = 0;\n', '        uint256[] memory data = new uint256[](length);\n', '        uint256 checkBlock = _tokenInfo[tokenAddress].latestOffer;\n', '        while(index < length && checkBlock > 0){\n', '            if (checkBlock < block.number && priceInfoList[checkBlock].ethAmount != 0) {\n', '                // Add return data\n', '                data[index++] = priceInfoList[checkBlock].ethAmount;\n', '                data[index++] = priceInfoList[checkBlock].erc20Amount;\n', '                data[index++] = checkBlock;\n', '            }\n', '            checkBlock = priceInfoList[checkBlock].frontBlock;\n', '        }\n', '        require(length == data.length);\n', '        // Allocation\n', '        address nToken = _tokenMapping.checkTokenMapping(tokenAddress);\n', '        if (nToken == address(0x0)) {\n', '            _abonus.switchToEth.value(_priceCost)(address(_nestToken));\n', '        } else {\n', '            _abonus.switchToEth.value(_priceCost)(address(nToken));\n', '        }\n', '        if (msg.value > _priceCost) {\n', '            repayEth(address(msg.sender), msg.value.sub(_priceCost));\n', '        }\n', '        return data;\n', '    }\n', '    \n', '    // Activate the price checking function\n', '    function activation() public {\n', '        _nestToken.safeTransferFrom(address(msg.sender), _destructionAddress, destructionAmount);\n', '        _addressEffect[address(msg.sender)] = now.add(effectTime);\n', '    }\n', '    \n', '    // Transfer ETH\n', '    function repayEth(address accountAddress, uint256 asset) private {\n', '        address payable addr = accountAddress.make_payable();\n', '        addr.transfer(asset);\n', '    }\n', '    \n', '    // Check block price - user account only\n', '    function checkPriceForBlock(address tokenAddress, uint256 blockNum) public view returns (uint256 ethAmount, uint256 erc20Amount) {\n', '        require(address(msg.sender) == address(tx.origin), "It can\'t be a contract");\n', '        TokenInfo storage tokenInfo = _tokenInfo[tokenAddress];\n', '        return (tokenInfo.priceInfoList[blockNum].ethAmount, tokenInfo.priceInfoList[blockNum].erc20Amount);\n', '    }    \n', '    \n', '    // Check real-time price - user account only\n', '    function checkPriceNow(address tokenAddress) public view returns (uint256 ethAmount, uint256 erc20Amount, uint256 blockNum) {\n', '        require(address(msg.sender) == address(tx.origin), "It can\'t be a contract");\n', '        mapping(uint256 => PriceInfo) storage priceInfoList = _tokenInfo[tokenAddress].priceInfoList;\n', '        uint256 checkBlock = _tokenInfo[tokenAddress].latestOffer;\n', '        while(checkBlock > 0 && (checkBlock >= block.number || priceInfoList[checkBlock].ethAmount == 0)) {\n', '            checkBlock = priceInfoList[checkBlock].frontBlock;\n', '        }\n', '        if (checkBlock == 0) {\n', '            return (0,0,0);\n', '        }\n', '        PriceInfo storage priceInfo = priceInfoList[checkBlock];\n', '        return (priceInfo.ethAmount,priceInfo.erc20Amount, checkBlock);\n', '    }\n', '    \n', '    // Check whether the price-checking functions can be called\n', '    function checkUseNestPrice(address target) public view returns (bool) {\n', '        if (!_blocklist[target] && _addressEffect[target] < now && _addressEffect[target] != 0) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    // Check whether the address is in the blocklist\n', '    function checkBlocklist(address add) public view returns(bool) {\n', '        return _blocklist[add];\n', '    }\n', '    \n', '    // Check the amount of NEST to destroy to call prices\n', '    function checkDestructionAmount() public view returns(uint256) {\n', '        return destructionAmount;\n', '    }\n', '    \n', '    // Check the waiting time to start calling prices\n', '    function checkEffectTime() public view returns (uint256) {\n', '        return effectTime;\n', '    }\n', '    \n', '    // Check call price fee\n', '    function checkPriceCost() public view returns (uint256) {\n', '        return _priceCost;\n', '    }\n', '    \n', '    // Modify the blocklist \n', '    function changeBlocklist(address add, bool isBlock) public onlyOwner {\n', '        _blocklist[add] = isBlock;\n', '    }\n', '    \n', '    // Amount of NEST to destroy to call price-checking functions\n', '    function changeDestructionAmount(uint256 amount) public onlyOwner {\n', '        destructionAmount = amount;\n', '    }\n', '    \n', '    // Modify the waiting time to start calling prices\n', '    function changeEffectTime(uint256 num) public onlyOwner {\n', '        effectTime = num;\n', '    }\n', '    \n', '    // Modify call price fee\n', '    function changePriceCost(uint256 num) public onlyOwner {\n', '        _priceCost = num;\n', '    }\n', '\n', '    // Offering contract only\n', '    modifier onlyOfferMain(){\n', '        require(_offerMainMapping[address(msg.sender)], "No authority");\n', '        _;\n', '    }\n', '    \n', '    // Vote administrators only\n', '    modifier onlyOwner(){\n', '        require(_voteFactory.checkOwners(msg.sender), "No authority");\n', '        _;\n', '    }\n', '}\n', '\n', '// Voting contract\n', 'interface Nest_3_VoteFactory {\n', '    // Check address\n', '\tfunction checkAddress(string calldata name) external view returns (address contractAddress);\n', '\t// Check whether administrator\n', '\tfunction checkOwners(address man) external view returns (bool);\n', '}\n', '\n', '// NToken mapping contract\n', 'interface Nest_NToken_TokenMapping {\n', '    function checkTokenMapping(address token) external view returns (address);\n', '}\n', '\n', '// NEST offer main contract\n', 'interface Nest_3_OfferMain {\n', '    function checkTokenAllow(address token) external view returns(bool);\n', '}\n', '\n', '// Bonus pool contract\n', 'interface Nest_3_Abonus {\n', '    function switchToEth(address token) external payable;\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library address_make_payable {\n', '   function make_payable(address x) internal pure returns (address payable) {\n', '      return address(uint160(x));\n', '   }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '    function callOptionalReturn(ERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) {\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}']