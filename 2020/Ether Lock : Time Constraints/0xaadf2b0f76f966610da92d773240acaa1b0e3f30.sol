['/*\n', '\n', ' Copyright 2018-2019 RigoBlock, Rigo Investment Sagl, 2020 Rigo Intl.\n', '\n', ' Licensed under the Apache License, Version 2.0 (the "License");\n', ' you may not use this file except in compliance with the License.\n', ' You may obtain a copy of the License at\n', '\n', '     http://www.apache.org/licenses/LICENSE-2.0\n', '\n', ' Unless required by applicable law or agreed to in writing, software\n', ' distributed under the License is distributed on an "AS IS" BASIS,\n', ' WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', ' See the License for the specific language governing permissions and\n', ' limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity 0.6.6;\n', '\n', '/// @title Pool Interface - Interface of pool standard functions.\n', '/// @author Gabriele Rigo - <gab@rigoblock.com>\n', '/// @notice only public view functions are used\n', 'interface IPool {\n', '    /*\n', '     * CONSTANT PUBLIC FUNCTIONS\n', '     */\n', '    function balanceOf(address _who) external view returns (uint256);\n', '    function totalSupply() external view returns (uint256 totaSupply);\n', '    function getEventful() external view returns (address);\n', '    function getData() external view returns (string memory name, string memory symbol, uint256 sellPrice, uint256 buyPrice);\n', '    function calcSharePrice() external view returns (uint256);\n', '    function getAdminData() external view returns (address, address feeCollector, address dragodAO, uint256 ratio, uint256 transactionFee, uint32 minPeriod);\n', '}\n', '\n', '/// @title Drago Registry Interface - Allows external interaction with Drago Registry.\n', '/// @author Gabriele Rigo - <gab@rigoblock.com>\n', '// solhint-disable-next-line\n', 'interface IDragoRegistry {\n', '\n', '    /*\n', '     * CORE FUNCTIONS\n', '     */\n', '    function register(address _drago, string calldata _name, string calldata _symbol, uint256 _dragoId, address _owner) external payable returns (bool);\n', '    function unregister(uint256 _id) external;\n', '    function setMeta(uint256 _id, bytes32 _key, bytes32 _value) external;\n', '    function addGroup(address _group) external;\n', '    function setFee(uint256 _fee) external;\n', '    function updateOwner(uint256 _id) external;\n', '    function updateOwners(uint256[] calldata _id) external;\n', '    function upgrade(address _newAddress) external payable; //payable as there is a transfer of value, otherwise opcode might throw an error\n', '    function setUpgraded(uint256 _version) external;\n', '    function drain() external;\n', '\n', '    /*\n', '     * CONSTANT PUBLIC FUNCTIONS\n', '     */\n', '    function dragoCount() external view returns (uint256);\n', '    function fromId(uint256 _id) external view returns (address drago, string memory name, string memory symbol, uint256 dragoId, address owner, address group);\n', '    function fromAddress(address _drago) external view returns (uint256 id, string memory name, string memory symbol, uint256 dragoId, address owner, address group);\n', '    function fromName(string calldata _name) external view returns (uint256 id, address drago, string memory symbol, uint256 dragoId, address owner, address group);\n', '    function getNameFromAddress(address _pool) external view returns (string memory);\n', '    function getSymbolFromAddress(address _pool) external view returns (string memory);\n', '    function meta(uint256 _id, bytes32 _key) external view returns (bytes32);\n', '    function getGroups() external view returns (address[] memory);\n', '    function getFee() external view returns (uint256);\n', '}\n', '\n', '/// @title Network - Returns data of active pools and network value.\n', '/// @author Gabriele Rigo - <gab@rigoblock.com>\n', 'contract Network {\n', '\n', '    address public DRAGOREGISTRYADDRESS;\n', '\n', '    constructor(\n', '        address dragoRegistryAddress)\n', '        public\n', '    {\n', '        DRAGOREGISTRYADDRESS = dragoRegistryAddress;\n', '    }\n', '\n', '    /*\n', '     * CONSTANT PUBLIC FUNCTIONS\n', '     */\n', '    /// @dev Returns two arrays of prices and total supply\n', '    /// @return poolAddresses Array of addressed of the active pools\n', '    /// @return poolPrices Array of the prices of the active pools\n', '    /// @return totalTokens Array of the number of tokens of each pool\n', '    function getPoolsPrices()\n', '        external view\n', '        returns (\n', '            address[] memory,\n', '            uint256[] memory,\n', '            uint256[] memory\n', '        )\n', '    {\n', '        uint256 length = IDragoRegistry(DRAGOREGISTRYADDRESS).dragoCount();\n', '        address[] memory poolAddresses = new address[](length);\n', '        uint256[] memory poolPrices = new uint256[](length);\n', '        uint256[] memory totalTokens = new uint256[](length);\n', '        for (uint256 i = 0; i < length; ++i) {\n', '            bool active = isActive(i);\n', '            if (!active) {\n', '                continue;\n', '            }\n', '            (poolAddresses[i], ) = addressFromId(i);\n', '            IPool poolInstance = IPool(poolAddresses[i]);\n', '            poolPrices[i] = poolInstance.calcSharePrice();\n', '            totalTokens[i] = poolInstance.totalSupply();\n', '        }\n', '        return (\n', '            poolAddresses,\n', '            poolPrices,\n', '            totalTokens\n', '        );\n', '    }\n', '\n', '    /// @dev Returns the value of the assets in the rigoblock network\n', '    /// @return networkValue alue of the rigoblock network in wei\n', '    /// @return numberOfPools Number of active funds\n', '    function calcNetworkValue()\n', '        external view\n', '        returns (\n', '            uint256 networkValue,\n', '            uint256 numberOfPools\n', '        )\n', '    {\n', '        numberOfPools = IDragoRegistry(DRAGOREGISTRYADDRESS).dragoCount();\n', '        for (uint256 i = 0; i < numberOfPools; ++i) {\n', '            bool active = isActive(i);\n', '            if (!active) {\n', '                continue;\n', '            }\n', '            (uint256 poolValue, ) = calcPoolValue(i);\n', '            networkValue += poolValue;\n', '        }\n', '    }\n', '    \n', '    /// @dev Returns the value of the assets in the rigoblock network given a mock input\n', '    /// @param mockInput Random number, must be 1 for querying data\n', '    /// @return networkValue Value of the rigoblock network in wei\n', '    /// @return numberOfPools Number of active funds\n', '    function calcNetworkValueDuneAnalytics(uint256 mockInput)\n', '        external view\n', '        returns (\n', '            uint256 networkValue,\n', '            uint256 numberOfPools\n', '        )\n', '    {\n', '        if(mockInput > uint256(1)) {\n', '            return (uint256(0), uint256(0));\n', '        }\n', '        numberOfPools = IDragoRegistry(DRAGOREGISTRYADDRESS).dragoCount();\n', '        for (uint256 i = 0; i < numberOfPools; ++i) {\n', '            bool active = isActive(i);\n', '            if (!active) {\n', '                continue;\n', '            }\n', '            (uint256 poolValue, ) = calcPoolValue(i);\n', '            networkValue += poolValue;\n', '        }\n', '    }\n', '\n', '\n', '    /*\n', '     * INTERNAL FUNCTIONS\n', '     */\n', '    /// @dev Checks whether a pool is registered and active\n', '    /// @param poolId Id of the pool\n', '    /// @return Bool the pool is active\n', '    function isActive(uint256 poolId)\n', '        internal view\n', '        returns (bool)\n', '    {\n', '        (address poolAddress, , , , , ) = IDragoRegistry(DRAGOREGISTRYADDRESS).fromId(poolId);\n', '        if (poolAddress != address(0)) {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns the address and the group of a pool from its id\n', '    /// @param poolId Id of the pool\n', '    /// @return poolAddress Address of the target pool\n', "    /// @return groupAddress Address of the pool's group\n", '    function addressFromId(uint256 poolId)\n', '        internal view\n', '        returns (\n', '            address poolAddress,\n', '            address groupAddress\n', '        )\n', '    {\n', '        (poolAddress, , , , , groupAddress) = IDragoRegistry(DRAGOREGISTRYADDRESS).fromId(poolId);\n', '    }\n', '\n', '    /// @dev Returns the price a pool from its id\n', '    /// @param poolId Id of the pool\n', '    /// @return poolPrice Price of the pool in wei\n', '    /// @return totalTokens Number of tokens of a pool (totalSupply)\n', '    function getPoolPrice(uint256 poolId)\n', '        internal view\n', '        returns (\n', '            uint256 poolPrice,\n', '            uint256 totalTokens\n', '        )\n', '    {\n', '        (address poolAddress, ) = addressFromId(poolId);\n', '        IPool poolInstance = IPool(poolAddress);\n', '        poolPrice = poolInstance.calcSharePrice();\n', '        totalTokens = poolInstance.totalSupply();\n', '    }\n', '\n', '    /// @dev Returns the address and the group of a pool from its id\n', '    /// @param poolId Id of the pool\n', '    /// @return aum Address of the target pool\n', "    /// @return success Address of the pool's group\n", '    function calcPoolValue(uint256 poolId)\n', '        internal view\n', '        returns (\n', '            uint256 aum,\n', '            bool success\n', '        )\n', '    {\n', '        (uint256 price, uint256 supply) = getPoolPrice(poolId);\n', '        return (\n', '            aum = (price * supply / 1000000), //1000000 is the base (6 decimals)\n', '            success = true\n', '        );\n', '    }\n', '}']