['pragma solidity ^0.7.1;\n', '\n', 'contract DFOStake {\n', '\n', '    address private constant UNISWAP_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n', '\n', '    address private constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '\n', '    address private WETH_ADDRESS = IUniswapV2Router(UNISWAP_V2_ROUTER).WETH();\n', '\n', '    address[] private TOKENS;\n', '\n', '    mapping(uint256 => uint256) private _totalPoolAmount;\n', '\n', '    uint256[] private TIME_WINDOWS;\n', '\n', '    uint256[] private REWARD_MULTIPLIERS;\n', '\n', '    uint256[] private REWARD_DIVIDERS;\n', '\n', '    uint256[] private REWARD_SPLIT_TRANCHES;\n', '\n', '    address private _doubleProxy;\n', '\n', '    struct StakeInfo {\n', '        address sender;\n', '        uint256 poolPosition;\n', '        uint256 firstAmount;\n', '        uint256 secondAmount;\n', '        uint256 poolAmount;\n', '        uint256 reward;\n', '        uint256 endBlock;\n', '        uint256[] partialRewardBlockTimes;\n', '        uint256 splittedReward;\n', '    }\n', '\n', '    uint256 private _startBlock;\n', '\n', '    mapping(uint256 => mapping(uint256 => StakeInfo)) private _stakeInfo;\n', '    mapping(uint256 => uint256) private _stakeInfoLength;\n', '\n', '    event Staked(address indexed sender, uint256 indexed tier, uint256 indexed poolPosition, uint256 firstAmount, uint256 secondAmount, uint256 poolAmount, uint256 reward, uint256 endBlock, uint256[] partialRewardBlockTimes, uint256 splittedReward);\n', '    event Withdrawn(address sender, address indexed receiver, uint256 indexed tier, uint256 indexed poolPosition, uint256 firstAmount, uint256 secondAmount, uint256 poolAmount, uint256 reward);\n', '    event PartialWithdrawn(address sender, address indexed receiver, uint256 indexed tier, uint256 reward);\n', '\n', '    constructor(uint256 startBlock, address doubleProxy, address[] memory tokens, uint256[] memory timeWindows, uint256[] memory rewardMultipliers, uint256[] memory rewardDividers, uint256[] memory rewardSplitTranches) public {\n', '\n', '        _startBlock = startBlock;\n', '\n', '        _doubleProxy = doubleProxy;\n', '\n', '        for(uint256 i = 0; i < tokens.length; i++) {\n', '            TOKENS.push(tokens[i]);\n', '        }\n', '\n', '        assert(timeWindows.length == rewardMultipliers.length && rewardMultipliers.length == rewardDividers.length && rewardDividers.length == rewardSplitTranches.length);\n', '        for(uint256 i = 0; i < timeWindows.length; i++) {\n', '            TIME_WINDOWS.push(timeWindows[i]);\n', '        }\n', '\n', '        for(uint256 i = 0; i < rewardMultipliers.length; i++) {\n', '            REWARD_MULTIPLIERS.push(rewardMultipliers[i]);\n', '        }\n', '\n', '        for(uint256 i = 0; i < rewardDividers.length; i++) {\n', '            REWARD_DIVIDERS.push(rewardDividers[i]);\n', '        }\n', '\n', '        for(uint256 i = 0; i < rewardSplitTranches.length; i++) {\n', '            REWARD_SPLIT_TRANCHES.push(rewardSplitTranches[i]);\n', '        }\n', '    }\n', '\n', '    function doubleProxy() public view returns(address) {\n', '        return _doubleProxy;\n', '    }\n', '\n', '    function tokens() public view returns(address[] memory) {\n', '        return TOKENS;\n', '    }\n', '\n', '    function tierData() public view returns(uint256[] memory, uint256[] memory, uint256[] memory, uint256[] memory) {\n', '        return (TIME_WINDOWS, REWARD_MULTIPLIERS, REWARD_DIVIDERS, REWARD_SPLIT_TRANCHES);\n', '    }\n', '\n', '    function startBlock() public view returns(uint256) {\n', '        return _startBlock;\n', '    }\n', '\n', '    function totalPoolAmount(uint256 poolPosition) public view returns(uint256) {\n', '        return _totalPoolAmount[poolPosition];\n', '    }\n', '\n', '    function setDoubleProxy(address newDoubleProxy) public {\n', '        require(IMVDFunctionalitiesManager(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDFunctionalitiesManagerAddress()).isAuthorizedFunctionality(msg.sender), "Unauthorized Action!");\n', '        _doubleProxy = newDoubleProxy;\n', '    }\n', '\n', '    function emergencyFlush() public {\n', '        IMVDProxy proxy = IMVDProxy(IDoubleProxy(_doubleProxy).proxy());\n', '        require(IMVDFunctionalitiesManager(proxy.getMVDFunctionalitiesManagerAddress()).isAuthorizedFunctionality(msg.sender), "Unauthorized Action!");\n', '        address walletAddress = proxy.getMVDWalletAddress();\n', '        address tokenAddress = proxy.getToken();\n', '        IERC20 token = IERC20(tokenAddress);\n', '        uint256 balanceOf = token.balanceOf(address(this));\n', '        if(balanceOf > 0) {\n', '            token.transfer(walletAddress, balanceOf);\n', '        }\n', '        balanceOf = 0;\n', '        for(uint256 i = 0; i < TOKENS.length; i++) {\n', '            token = IERC20(IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(tokenAddress, TOKENS[i]));\n', '            balanceOf = token.balanceOf(address(this));\n', '            if(balanceOf > 0) {\n', '                token.transfer(walletAddress, balanceOf);\n', '                _totalPoolAmount[i] = 0;\n', '            }\n', '            balanceOf = 0;\n', '        }\n', '    }\n', '\n', '    function stake(uint256 tier, uint256 poolPosition, uint256 originalFirstAmount, uint256 firstAmountMin, uint256 value, uint256 secondAmountMin) public payable {\n', '        require(block.number >= _startBlock, "Staking is still not available");\n', '        require(poolPosition < TOKENS.length, "Unknown Pool");\n', '        require(tier < TIME_WINDOWS.length, "Unknown tier");\n', '\n', '        require(originalFirstAmount > 0, "First amount must be greater than 0");\n', '\n', '        uint256 originalSecondAmount = TOKENS[poolPosition] == WETH_ADDRESS ? msg.value : value;\n', '        require(originalSecondAmount > 0, "Second amount must be greater than 0");\n', '\n', '        IMVDProxy proxy = IMVDProxy(IDoubleProxy(_doubleProxy).proxy());\n', '        address tokenAddress = proxy.getToken();\n', '\n', '        _transferTokensAndCheckAllowance(tokenAddress, originalFirstAmount);\n', '        _transferTokensAndCheckAllowance(TOKENS[poolPosition], originalSecondAmount);\n', '\n', '        address secondToken = TOKENS[poolPosition];\n', '\n', '        (uint256 firstAmount, uint256 secondAmount, uint256 poolAmount) = _createPoolToken(originalFirstAmount, firstAmountMin, originalSecondAmount, secondAmountMin, tokenAddress, secondToken);\n', '\n', '        _totalPoolAmount[poolPosition] += poolAmount;\n', '\n', '        (uint256 minCap,, uint256 remainingToStake) = getStakingInfo(tier);\n', '        require(firstAmount >= minCap, "Amount to stake is less than the current min cap");\n', '        require(firstAmount <= remainingToStake, "Amount to stake must be less than the current remaining one");\n', '\n', '        calculateRewardAndAddStakingPosition(tier, poolPosition, firstAmount, secondAmount, poolAmount, proxy);\n', '    }\n', '\n', '    function getStakingInfo(uint256 tier) public view returns(uint256 minCap, uint256 hardCap, uint256 remainingToStake) {\n', '        (minCap, hardCap) = getStakingCap(tier);\n', '        remainingToStake = hardCap;\n', '        uint256 length = _stakeInfoLength[tier];\n', '        for(uint256 i = 0; i < length; i++) {\n', '            if(_stakeInfo[tier][i].endBlock > block.number) {\n', '                remainingToStake -= _stakeInfo[tier][i].firstAmount;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getStakingCap(uint256 tier) public view returns(uint256, uint256) {\n', '        IStateHolder stateHolder = IStateHolder(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getStateHolderAddress());\n', '        string memory tierString = _toString(tier);\n', '        string memory addressString = _toLowerCase(_toString(address(this)));\n', '        return (\n', '            stateHolder.getUint256(string(abi.encodePacked("staking.", addressString, ".tiers[", tierString, "].minCap"))),\n', '            stateHolder.getUint256(string(abi.encodePacked("staking.", addressString, ".tiers[", tierString, "].hardCap")))\n', '        );\n', '    }\n', '\n', '    function _transferTokensAndCheckAllowance(address tokenAddress, uint256 value) private {\n', '        if(tokenAddress == WETH_ADDRESS) {\n', '            return;\n', '        }\n', '        IERC20 token = IERC20(tokenAddress);\n', '        token.transferFrom(msg.sender, address(this), value);\n', '        if(token.allowance(address(this), UNISWAP_V2_ROUTER) <= value) {\n', '            token.approve(UNISWAP_V2_ROUTER, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n', '        }\n', '    }\n', '\n', '    function _createPoolToken(uint256 originalFirstAmount, uint256 firstAmountMin, uint256 originalSecondAmount, uint256 secondAmountMin, address firstToken, address secondToken) private returns(uint256 firstAmount, uint256 secondAmount, uint256 poolAmount) {\n', '        if(secondToken == WETH_ADDRESS) {\n', '            (firstAmount, secondAmount, poolAmount) = IUniswapV2Router(UNISWAP_V2_ROUTER).addLiquidityETH{value: originalSecondAmount}(\n', '                firstToken,\n', '                originalFirstAmount,\n', '                firstAmountMin,\n', '                secondAmountMin,\n', '                address(this),\n', '                block.timestamp + 1000\n', '            );\n', '        } else {\n', '            (firstAmount, secondAmount, poolAmount) = IUniswapV2Router(UNISWAP_V2_ROUTER).addLiquidity(\n', '                firstToken,\n', '                secondToken,\n', '                originalFirstAmount,\n', '                originalSecondAmount,\n', '                firstAmountMin,\n', '                secondAmountMin,\n', '                address(this),\n', '                block.timestamp + 1000\n', '            );\n', '        }\n', '        if(firstAmount < originalFirstAmount) {\n', '            IERC20(firstToken).transfer(msg.sender, originalFirstAmount - firstAmount);\n', '        }\n', '        if(secondAmount < originalSecondAmount) {\n', '            if(secondToken == WETH_ADDRESS) {\n', '                payable(msg.sender).transfer(originalSecondAmount - secondAmount);\n', '            } else {\n', '                IERC20(secondToken).transfer(msg.sender, originalSecondAmount - secondAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function calculateRewardAndAddStakingPosition(uint256 tier, uint256 poolPosition, uint256 firstAmount, uint256 secondAmount, uint256 poolAmount, IMVDProxy proxy) private {\n', '        uint256 partialRewardSingleBlockTime = TIME_WINDOWS[tier] / REWARD_SPLIT_TRANCHES[tier];\n', '        uint256[] memory partialRewardBlockTimes = new uint256[](REWARD_SPLIT_TRANCHES[tier]);\n', '        if(partialRewardBlockTimes.length > 0) {\n', '            partialRewardBlockTimes[0] = block.number + partialRewardSingleBlockTime;\n', '            for(uint256 i = 1; i < partialRewardBlockTimes.length; i++) {\n', '                partialRewardBlockTimes[i] = partialRewardBlockTimes[i - 1] + partialRewardSingleBlockTime;\n', '            }\n', '        }\n', '        uint256 reward = firstAmount * REWARD_MULTIPLIERS[tier] / REWARD_DIVIDERS[tier];\n', '        StakeInfo memory stakeInfo = StakeInfo(msg.sender, poolPosition, firstAmount, secondAmount, poolAmount, reward, block.number + TIME_WINDOWS[tier], partialRewardBlockTimes, reward / REWARD_SPLIT_TRANCHES[tier]);\n', '        _add(tier, stakeInfo);\n', '        proxy.submit("stakingTransfer", abi.encode(address(0), 0, reward, address(this)));\n', '        emit Staked(msg.sender, tier, poolPosition, firstAmount, secondAmount, poolAmount, reward, stakeInfo.endBlock, partialRewardBlockTimes, stakeInfo.splittedReward);\n', '    }\n', '\n', '    function _add(uint256 tier, StakeInfo memory element) private returns(uint256, uint256) {\n', '        _stakeInfo[tier][_stakeInfoLength[tier]] = element;\n', '        _stakeInfoLength[tier] = _stakeInfoLength[tier] + 1;\n', '        return (element.reward, element.endBlock);\n', '    }\n', '\n', '    function _remove(uint256 tier, uint256 i) private {\n', '        if(_stakeInfoLength[tier] <= i) {\n', '            return;\n', '        }\n', '        _stakeInfoLength[tier] = _stakeInfoLength[tier] - 1;\n', '        if(_stakeInfoLength[tier] > i) {\n', '            _stakeInfo[tier][i] = _stakeInfo[tier][_stakeInfoLength[tier]];\n', '        }\n', '        delete _stakeInfo[tier][_stakeInfoLength[tier]];\n', '    }\n', '\n', '    function length(uint256 tier) public view returns(uint256) {\n', '        return _stakeInfoLength[tier];\n', '    }\n', '\n', '    function stakeInfo(uint256 tier, uint256 position) public view returns(\n', '        address,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        uint256[] memory,\n', '        uint256\n', '    ) {\n', '        StakeInfo memory tierStakeInfo = _stakeInfo[tier][position];\n', '        return(\n', '            tierStakeInfo.sender,\n', '            tierStakeInfo.poolPosition,\n', '            tierStakeInfo.firstAmount,\n', '            tierStakeInfo.secondAmount,\n', '            tierStakeInfo.poolAmount,\n', '            tierStakeInfo.reward,\n', '            tierStakeInfo.endBlock,\n', '            tierStakeInfo.partialRewardBlockTimes,\n', '            tierStakeInfo.splittedReward\n', '        );\n', '    }\n', '\n', '    function partialReward(uint256 tier, uint256 position) public {\n', '        StakeInfo memory tierStakeInfo = _stakeInfo[tier][position];\n', '        if(block.number >= tierStakeInfo.endBlock) {\n', '            return withdraw(tier, position);\n', '        }\n', '        require(tierStakeInfo.reward > 0, "No more reward for this staking position");\n', '        uint256 reward = 0;\n', '        for(uint256 i = 0; i < tierStakeInfo.partialRewardBlockTimes.length; i++) {\n', '            if(tierStakeInfo.partialRewardBlockTimes[i] > 0 && block.number >= tierStakeInfo.partialRewardBlockTimes[i]) {\n', '                reward += tierStakeInfo.splittedReward;\n', '                tierStakeInfo.partialRewardBlockTimes[i] = 0;\n', '            }\n', '        }\n', '        reward = reward > tierStakeInfo.reward ? tierStakeInfo.reward : reward;\n', '        require(reward > 0, "No reward to redeem");\n', '        IERC20 token = IERC20(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getToken());\n', '        token.transfer(tierStakeInfo.sender, reward);\n', '        tierStakeInfo.reward = tierStakeInfo.reward - reward;\n', '        _stakeInfo[tier][position] = tierStakeInfo;\n', '        emit PartialWithdrawn(msg.sender, tierStakeInfo.sender, tier, reward);\n', '    }\n', '\n', '    function withdraw(uint256 tier, uint256 position) public {\n', '        StakeInfo memory tierStakeInfo = _stakeInfo[tier][position];\n', '        require(block.number >= tierStakeInfo.endBlock, "Cannot actually withdraw this position");\n', '        IERC20 token = IERC20(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getToken());\n', '        if(tierStakeInfo.reward > 0) {\n', '            token.transfer(tierStakeInfo.sender, tierStakeInfo.reward);\n', '        }\n', '        token = IERC20(IUniswapV2Factory(UNISWAP_V2_FACTORY).getPair(address(token), TOKENS[tierStakeInfo.poolPosition]));\n', '        token.transfer(tierStakeInfo.sender, tierStakeInfo.poolAmount);\n', '        _totalPoolAmount[tierStakeInfo.poolPosition] = _totalPoolAmount[tierStakeInfo.poolPosition] - tierStakeInfo.poolAmount;\n', '        emit Withdrawn(msg.sender, tierStakeInfo.sender, tier, tierStakeInfo.poolPosition, tierStakeInfo.firstAmount, tierStakeInfo.secondAmount, tierStakeInfo.poolAmount, tierStakeInfo.reward);\n', '        _remove(tier, position);\n', '    }\n', '\n', '    function _toString(uint _i) private pure returns(string memory) {\n', '        if (_i == 0) {\n', '            return "0";\n', '        }\n', '        uint j = _i;\n', '        uint len;\n', '        while (j != 0) {\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (_i != 0) {\n', '            bstr[k--] = byte(uint8(48 + _i % 10));\n', '            _i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '\n', '    function _toString(address _addr) private pure returns(string memory) {\n', '        bytes32 value = bytes32(uint256(_addr));\n', '        bytes memory alphabet = "0123456789abcdef";\n', '\n', '        bytes memory str = new bytes(42);\n', "        str[0] = '0';\n", "        str[1] = 'x';\n", '        for (uint i = 0; i < 20; i++) {\n', '            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\n', '            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\n', '        }\n', '        return string(str);\n', '    }\n', '\n', '    function _toLowerCase(string memory str) private pure returns(string memory) {\n', '        bytes memory bStr = bytes(str);\n', '        for (uint i = 0; i < bStr.length; i++) {\n', '            bStr[i] = bStr[i] >= 0x41 && bStr[i] <= 0x5A ? bytes1(uint8(bStr[i]) + 0x20) : bStr[i];\n', '        }\n', '        return string(bStr);\n', '    }\n', '}\n', '\n', 'interface IMVDProxy {\n', '    function getToken() external view returns(address);\n', '    function getStateHolderAddress() external view returns(address);\n', '    function getMVDWalletAddress() external view returns(address);\n', '    function getMVDFunctionalitiesManagerAddress() external view returns(address);\n', '    function submit(string calldata codeName, bytes calldata data) external payable returns(bytes memory returnData);\n', '}\n', '\n', 'interface IStateHolder {\n', '    function setUint256(string calldata name, uint256 value) external returns(uint256);\n', '    function getUint256(string calldata name) external view returns(uint256);\n', '    function getBool(string calldata varName) external view returns (bool);\n', '    function clear(string calldata varName) external returns(string memory oldDataType, bytes memory oldVal);\n', '}\n', '\n', 'interface IMVDFunctionalitiesManager {\n', '    function isAuthorizedFunctionality(address functionality) external view returns(bool);\n', '}\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface IUniswapV2Router {\n', '    function WETH() external pure returns (address);\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '}\n', '\n', 'interface IDoubleProxy {\n', '    function proxy() external view returns(address);\n', '}']