['pragma solidity 0.6.12;\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// File: interfaces/IERC20.sol\n', '\n', '// Interface declarations\n', '\n', '/* solhint-disable func-order */\n', '\n', 'interface IERC20 {\n', '    // Emitted when the allowance of a spender for an owner is set by a call to approve.\n', '    // Value is the new allowance\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '    // Emitted when value tokens are moved from one account (from) to another (to).\n', '    // Note that value may be zero\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    // Returns the amount of tokens in existence\n', '    function totalSupply() external view returns (uint);\n', '\n', '    // Returns the amount of tokens owned by account\n', '    function balanceOf(address account) external view returns (uint);\n', '\n', '    // Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner\n', '    // through transferFrom. This is zero by default\n', '    // This value changes when approve or transferFrom are called\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    // Sets amount as the allowance of spender over the caller’s tokens\n', '    // Returns a boolean value indicating whether the operation succeeded\n', '    // Emits an Approval event.\n', '    function approve(address spender, uint amount) external returns (bool);\n', '\n', '    // Moves amount tokens from the caller’s account to recipient\n', '    // Returns a boolean value indicating whether the operation succeeded\n', '    // Emits a Transfer event.\n', '    function transfer(address recipient, uint amount) external returns (bool);\n', '\n', '    // Moves amount tokens from sender to recipient using the allowance mechanism\n', '    // Amount is then deducted from the caller’s allowance\n', '    // Returns a boolean value indicating whether the operation succeeded\n', '    // Emits a Transfer event\n', '    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '}\n', '\n', '// File: interfaces/IConfigurableRightsPool.sol\n', '\n', '// Interface declarations\n', '\n', '// Introduce to avoid circularity (otherwise, the CRP and SmartPoolManager include each other)\n', '// Removing circularity allows flattener tools to work, which enables Etherscan verification\n', 'interface IConfigurableRightsPool {\n', '    function mintPoolShareFromLib(uint amount) external;\n', '    function pushPoolShareFromLib(address to, uint amount) external;\n', '    function pullPoolShareFromLib(address from, uint amount) external;\n', '    function burnPoolShareFromLib(uint amount) external;\n', '    function totalSupply() external view returns (uint);\n', '    function getController() external view returns (address);\n', '}\n', '\n', '// File: contracts/IBFactory.sol\n', '\n', 'interface IBPool {\n', '    function rebind(address token, uint balance, uint denorm) external;\n', '    function setSwapFee(uint swapFee) external;\n', '    function setPublicSwap(bool publicSwap) external;\n', '    function bind(address token, uint balance, uint denorm) external;\n', '    function unbind(address token) external;\n', '    function gulp(address token) external;\n', '    function isBound(address token) external view returns(bool);\n', '    function getBalance(address token) external view returns (uint);\n', '    function totalSupply() external view returns (uint);\n', '    function getSwapFee() external view returns (uint);\n', '    function isPublicSwap() external view returns (bool);\n', '    function getDenormalizedWeight(address token) external view returns (uint);\n', '    function getTotalDenormalizedWeight() external view returns (uint);\n', '    // solhint-disable-next-line func-name-mixedcase\n', '    function EXIT_FEE() external view returns (uint);\n', '\n', '    function calcPoolOutGivenSingleIn(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint tokenAmountIn,\n', '        uint swapFee\n', '    )\n', '        external pure\n', '        returns (uint poolAmountOut);\n', '\n', '    function calcSingleInGivenPoolOut(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint poolAmountOut,\n', '        uint swapFee\n', '    )\n', '        external pure\n', '        returns (uint tokenAmountIn);\n', '\n', '    function calcSingleOutGivenPoolIn(\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint poolAmountIn,\n', '        uint swapFee\n', '    )\n', '        external pure\n', '        returns (uint tokenAmountOut);\n', '\n', '    function calcPoolInGivenSingleOut(\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint tokenAmountOut,\n', '        uint swapFee\n', '    )\n', '        external pure\n', '        returns (uint poolAmountIn);\n', '\n', '    function getCurrentTokens()\n', '        external view\n', '        returns (address[] memory tokens);\n', '}\n', '\n', 'interface IBFactory {\n', '    function newBPool() external returns (IBPool);\n', '    function setBLabs(address b) external;\n', '    function collect(IBPool pool) external;\n', '    function isBPool(address b) external view returns (bool);\n', '    function getBLabs() external view returns (address);\n', '}\n', '\n', '// File: libraries/BalancerConstants.sol\n', '\n', '/**\n', ' * @author Balancer Labs\n', ' * @title Put all the constants in one place\n', ' */\n', '\n', 'library BalancerConstants {\n', '    // State variables (must be constant in a library)\n', '\n', '    // B "ONE" - all math is in the "realm" of 10 ** 18;\n', '    // where numeric 1 = 10 ** 18\n', '    uint public constant BONE = 10**18;\n', '    uint public constant MIN_WEIGHT = BONE;\n', '    uint public constant MAX_WEIGHT = BONE * 50;\n', '    uint public constant MAX_TOTAL_WEIGHT = BONE * 50;\n', '    uint public constant MIN_BALANCE = BONE / 10**6;\n', '    uint public constant MAX_BALANCE = BONE * 10**12;\n', '    uint public constant MIN_POOL_SUPPLY = BONE * 100;\n', '    uint public constant MAX_POOL_SUPPLY = BONE * 10**9;\n', '    uint public constant MIN_FEE = BONE / 10**6;\n', '    uint public constant MAX_FEE = BONE / 10;\n', '    // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\n', '    uint public constant EXIT_FEE = 0;\n', '    uint public constant MAX_IN_RATIO = BONE / 2;\n', '    uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n', '    // Must match BConst.MIN_BOUND_TOKENS and BConst.MAX_BOUND_TOKENS\n', '    uint public constant MIN_ASSET_LIMIT = 2;\n', '    uint public constant MAX_ASSET_LIMIT = 8;\n', '    uint public constant MAX_UINT = uint(-1);\n', '}\n', '\n', '// File: libraries/BalancerSafeMath.sol\n', '\n', '\n', '// Imports\n', '\n', '\n', '/**\n', ' * @author Balancer Labs\n', ' * @title SafeMath - wrap Solidity operators to prevent underflow/overflow\n', ' * @dev badd and bsub are basically identical to OpenZeppelin SafeMath; mul/div have extra checks\n', ' */\n', 'library BalancerSafeMath {\n', '    /**\n', '     * @notice Safe addition\n', '     * @param a - first operand\n', '     * @param b - second operand\n', '     * @dev if we are adding b to a, the resulting sum must be greater than a\n', '     * @return - sum of operands; throws if overflow\n', '     */\n', '    function badd(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "ERR_ADD_OVERFLOW");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @notice Safe unsigned subtraction\n', '     * @param a - first operand\n', '     * @param b - second operand\n', '     * @dev Do a signed subtraction, and check that it produces a positive value\n', '     *      (i.e., a - b is valid if b <= a)\n', '     * @return - a - b; throws if underflow\n', '     */\n', '    function bsub(uint a, uint b) internal pure returns (uint) {\n', '        (uint c, bool negativeResult) = bsubSign(a, b);\n', '        require(!negativeResult, "ERR_SUB_UNDERFLOW");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @notice Safe signed subtraction\n', '     * @param a - first operand\n', '     * @param b - second operand\n', '     * @dev Do a signed subtraction\n', '     * @return - difference between a and b, and a flag indicating a negative result\n', '     *           (i.e., a - b if a is greater than or equal to b; otherwise b - a)\n', '     */\n', '    function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\n', '        if (b <= a) {\n', '            return (a - b, false);\n', '        } else {\n', '            return (b - a, true);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Safe multiplication\n', '     * @param a - first operand\n', '     * @param b - second operand\n', '     * @dev Multiply safely (and efficiently), rounding down\n', '     * @return - product of operands; throws if overflow or rounding error\n', '     */\n', '    function bmul(uint a, uint b) internal pure returns (uint) {\n', '        // Gas optimization (see github.com/OpenZeppelin/openzeppelin-contracts/pull/522)\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        // Standard overflow check: a/a*b=b\n', '        uint c0 = a * b;\n', '        require(c0 / a == b, "ERR_MUL_OVERFLOW");\n', '\n', '        // Round to 0 if x*y < BONE/2?\n', '        uint c1 = c0 + (BalancerConstants.BONE / 2);\n', '        require(c1 >= c0, "ERR_MUL_OVERFLOW");\n', '        uint c2 = c1 / BalancerConstants.BONE;\n', '        return c2;\n', '    }\n', '\n', '    /**\n', '     * @notice Safe division\n', '     * @param dividend - first operand\n', '     * @param divisor - second operand\n', '     * @dev Divide safely (and efficiently), rounding down\n', '     * @return - quotient; throws if overflow or rounding error\n', '     */\n', '    function bdiv(uint dividend, uint divisor) internal pure returns (uint) {\n', '        require(divisor != 0, "ERR_DIV_ZERO");\n', '\n', '        // Gas optimization\n', '        if (dividend == 0){\n', '            return 0;\n', '        }\n', '\n', '        uint c0 = dividend * BalancerConstants.BONE;\n', '        require(c0 / dividend == BalancerConstants.BONE, "ERR_DIV_INTERNAL"); // bmul overflow\n', '\n', '        uint c1 = c0 + (divisor / 2);\n', '        require(c1 >= c0, "ERR_DIV_INTERNAL"); //  badd require\n', '\n', '        uint c2 = c1 / divisor;\n', '        return c2;\n', '    }\n', '\n', '    /**\n', '     * @notice Safe unsigned integer modulo\n', '     * @dev Returns the remainder of dividing two unsigned integers.\n', '     *      Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * @param dividend - first operand\n', '     * @param divisor - second operand -- cannot be zero\n', '     * @return - quotient; throws if overflow or rounding error\n', '     */\n', '    function bmod(uint dividend, uint divisor) internal pure returns (uint) {\n', '        require(divisor != 0, "ERR_MODULO_BY_ZERO");\n', '\n', '        return dividend % divisor;\n', '    }\n', '\n', '    /**\n', '     * @notice Safe unsigned integer max\n', '     * @dev Returns the greater of the two input values\n', '     *\n', '     * @param a - first operand\n', '     * @param b - second operand\n', '     * @return - the maximum of a and b\n', '     */\n', '    function bmax(uint a, uint b) internal pure returns (uint) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @notice Safe unsigned integer min\n', '     * @dev returns b, if b < a; otherwise returns a\n', '     *\n', '     * @param a - first operand\n', '     * @param b - second operand\n', '     * @return - the lesser of the two input values\n', '     */\n', '    function bmin(uint a, uint b) internal pure returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @notice Safe unsigned integer average\n', '     * @dev Guard against (a+b) overflow by dividing each operand separately\n', '     *\n', '     * @param a - first operand\n', '     * @param b - second operand\n', '     * @return - the average of the two values\n', '     */\n', '    function baverage(uint a, uint b) internal pure returns (uint) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '\n', '    /**\n', '     * @notice Babylonian square root implementation\n', '     * @dev (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n', '     * @param y - operand\n', '     * @return z - the square root result\n', '     */\n', '    function sqrt(uint y) internal pure returns (uint z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint x = y / 2 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        }\n', '        else if (y != 0) {\n', '            z = 1;\n', '        }\n', '    }\n', '}\n', '\n', '// File: libraries/SafeApprove.sol\n', '\n', '// Imports\n', '\n', '\n', '// Libraries\n', '\n', '/**\n', ' * @author PieDAO (ported to Balancer Labs)\n', ' * @title SafeApprove - set approval for tokens that require 0 prior approval\n', ' * @dev Perhaps to address the known ERC20 race condition issue\n', ' *      See https://github.com/crytic/not-so-smart-contracts/tree/master/race_condition\n', ' *      Some tokens - notably KNC - only allow approvals to be increased from 0\n', ' */\n', 'library SafeApprove {\n', '    /**\n', '     * @notice handle approvals of tokens that require approving from a base of 0\n', "     * @param token - the token we're approving\n", '     * @param spender - entity the owner (sender) is approving to spend his tokens\n', '     * @param amount - number of tokens being approved\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint amount) internal returns (bool) {\n', '        uint currentAllowance = token.allowance(address(this), spender);\n', '\n', '        // Do nothing if allowance is already set to this value\n', '        if(currentAllowance == amount) {\n', '            return true;\n', '        }\n', '\n', '        // If approval is not zero reset it to zero first\n', '        if(currentAllowance != 0) {\n', '            return token.approve(spender, 0);\n', '        }\n', '\n', '        // do the actual approval\n', '        return token.approve(spender, amount);\n', '    }\n', '}\n', '\n', '// File: libraries/SmartPoolManager.sol\n', '\n', '\n', '// Imports\n', '\n', '\n', '/**\n', ' * @author Balancer Labs\n', ' * @title Factor out the weight updates\n', ' */\n', 'library SmartPoolManager {\n', '    // Type declarations\n', '\n', '    struct NewTokenParams {\n', '        address addr;\n', '        bool isCommitted;\n', '        uint commitBlock;\n', '        uint denorm;\n', '        uint balance;\n', '    }\n', '\n', '    // For blockwise, automated weight updates\n', '    // Move weights linearly from startWeights to endWeights,\n', '    // between startBlock and endBlock\n', '    struct GradualUpdateParams {\n', '        uint startBlock;\n', '        uint endBlock;\n', '        uint[] startWeights;\n', '        uint[] endWeights;\n', '    }\n', '\n', '    // updateWeight and pokeWeights are unavoidably long\n', '    /* solhint-disable function-max-lines */\n', '\n', '    /**\n', '     * @notice Update the weight of an existing token\n', '     * @dev Refactored to library to make CRPFactory deployable\n', '     * @param self - ConfigurableRightsPool instance calling the library\n', '     * @param bPool - Core BPool the CRP is wrapping\n', '     * @param token - token to be reweighted\n', '     * @param newWeight - new weight of the token\n', '    */\n', '    function updateWeight(\n', '        IConfigurableRightsPool self,\n', '        IBPool bPool,\n', '        address token,\n', '        uint newWeight\n', '    )\n', '        external\n', '    {\n', '        require(newWeight >= BalancerConstants.MIN_WEIGHT, "ERR_MIN_WEIGHT");\n', '        require(newWeight <= BalancerConstants.MAX_WEIGHT, "ERR_MAX_WEIGHT");\n', '\n', '        uint currentWeight = bPool.getDenormalizedWeight(token);\n', '        // Save gas; return immediately on NOOP\n', '        if (currentWeight == newWeight) {\n', '             return;\n', '        }\n', '\n', '        uint currentBalance = bPool.getBalance(token);\n', '        uint totalSupply = self.totalSupply();\n', '        uint totalWeight = bPool.getTotalDenormalizedWeight();\n', '        uint poolShares;\n', '        uint deltaBalance;\n', '        uint deltaWeight;\n', '        uint newBalance;\n', '\n', '        if (newWeight < currentWeight) {\n', '            // This means the controller will withdraw tokens to keep price\n', '            // So they need to redeem PCTokens\n', '            deltaWeight = BalancerSafeMath.bsub(currentWeight, newWeight);\n', '\n', '            // poolShares = totalSupply * (deltaWeight / totalWeight)\n', '            poolShares = BalancerSafeMath.bmul(totalSupply,\n', '                                               BalancerSafeMath.bdiv(deltaWeight, totalWeight));\n', '\n', '            // deltaBalance = currentBalance * (deltaWeight / currentWeight)\n', '            deltaBalance = BalancerSafeMath.bmul(currentBalance,\n', '                                                 BalancerSafeMath.bdiv(deltaWeight, currentWeight));\n', '\n', '            // New balance cannot be lower than MIN_BALANCE\n', '            newBalance = BalancerSafeMath.bsub(currentBalance, deltaBalance);\n', '\n', '            require(newBalance >= BalancerConstants.MIN_BALANCE, "ERR_MIN_BALANCE");\n', '\n', '            // First get the tokens from this contract (Pool Controller) to msg.sender\n', '            bPool.rebind(token, newBalance, newWeight);\n', '\n', '            // Now with the tokens this contract can send them to msg.sender\n', '            bool xfer = IERC20(token).transfer(msg.sender, deltaBalance);\n', '            require(xfer, "ERR_ERC20_FALSE");\n', '\n', '            self.pullPoolShareFromLib(msg.sender, poolShares);\n', '            self.burnPoolShareFromLib(poolShares);\n', '        }\n', '        else {\n', '            // This means the controller will deposit tokens to keep the price.\n', '            // They will be minted and given PCTokens\n', '            deltaWeight = BalancerSafeMath.bsub(newWeight, currentWeight);\n', '\n', '            require(BalancerSafeMath.badd(totalWeight, deltaWeight) <= BalancerConstants.MAX_TOTAL_WEIGHT,\n', '                    "ERR_MAX_TOTAL_WEIGHT");\n', '\n', '            // poolShares = totalSupply * (deltaWeight / totalWeight)\n', '            poolShares = BalancerSafeMath.bmul(totalSupply,\n', '                                               BalancerSafeMath.bdiv(deltaWeight, totalWeight));\n', '            // deltaBalance = currentBalance * (deltaWeight / currentWeight)\n', '            deltaBalance = BalancerSafeMath.bmul(currentBalance,\n', '                                                 BalancerSafeMath.bdiv(deltaWeight, currentWeight));\n', '\n', '            // First gets the tokens from msg.sender to this contract (Pool Controller)\n', '            bool xfer = IERC20(token).transferFrom(msg.sender, address(this), deltaBalance);\n', '            require(xfer, "ERR_ERC20_FALSE");\n', '\n', '            // Now with the tokens this contract can bind them to the pool it controls\n', '            bPool.rebind(token, BalancerSafeMath.badd(currentBalance, deltaBalance), newWeight);\n', '\n', '            self.mintPoolShareFromLib(poolShares);\n', '            self.pushPoolShareFromLib(msg.sender, poolShares);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice External function called to make the contract update weights according to plan\n', '     * @param bPool - Core BPool the CRP is wrapping\n', '     * @param gradualUpdate - gradual update parameters from the CRP\n', '    */\n', '    function pokeWeights(\n', '        IBPool bPool,\n', '        GradualUpdateParams storage gradualUpdate\n', '    )\n', '        external\n', '    {\n', '        // Do nothing if we call this when there is no update plan\n', '        if (gradualUpdate.startBlock == 0) {\n', '            return;\n', '        }\n', '\n', '        // Error to call it before the start of the plan\n', '        require(block.number >= gradualUpdate.startBlock, "ERR_CANT_POKE_YET");\n', '        // Proposed error message improvement\n', '        // require(block.number >= startBlock, "ERR_NO_HOKEY_POKEY");\n', '\n', '        // This allows for pokes after endBlock that get weights to endWeights\n', "        // Get the current block (or the endBlock, if we're already past the end)\n", '        uint currentBlock;\n', '        if (block.number > gradualUpdate.endBlock) {\n', '            currentBlock = gradualUpdate.endBlock;\n', '        }\n', '        else {\n', '            currentBlock = block.number;\n', '        }\n', '\n', '        uint blockPeriod = BalancerSafeMath.bsub(gradualUpdate.endBlock, gradualUpdate.startBlock);\n', '        uint blocksElapsed = BalancerSafeMath.bsub(currentBlock, gradualUpdate.startBlock);\n', '        uint weightDelta;\n', '        uint deltaPerBlock;\n', '        uint newWeight;\n', '\n', '        address[] memory tokens = bPool.getCurrentTokens();\n', '\n', '        // This loop contains external calls\n', '        // External calls are to math libraries or the underlying pool, so low risk\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            // Make sure it does nothing if the new and old weights are the same (saves gas)\n', "            // It's a degenerate case if they're *all* the same, but you certainly could have\n", '            // a plan where you only change some of the weights in the set\n', '            if (gradualUpdate.startWeights[i] != gradualUpdate.endWeights[i]) {\n', '                if (gradualUpdate.endWeights[i] < gradualUpdate.startWeights[i]) {\n', '                    // We are decreasing the weight\n', '\n', '                    // First get the total weight delta\n', '                    weightDelta = BalancerSafeMath.bsub(gradualUpdate.startWeights[i],\n', '                                                        gradualUpdate.endWeights[i]);\n', '                    // And the amount it should change per block = total change/number of blocks in the period\n', '                    deltaPerBlock = BalancerSafeMath.bdiv(weightDelta, blockPeriod);\n', '                    //deltaPerBlock = bdivx(weightDelta, blockPeriod);\n', '\n', '                     // newWeight = startWeight - (blocksElapsed * deltaPerBlock)\n', '                    newWeight = BalancerSafeMath.bsub(gradualUpdate.startWeights[i],\n', '                                                      BalancerSafeMath.bmul(blocksElapsed, deltaPerBlock));\n', '                }\n', '                else {\n', '                    // We are increasing the weight\n', '\n', '                    // First get the total weight delta\n', '                    weightDelta = BalancerSafeMath.bsub(gradualUpdate.endWeights[i],\n', '                                                        gradualUpdate.startWeights[i]);\n', '                    // And the amount it should change per block = total change/number of blocks in the period\n', '                    deltaPerBlock = BalancerSafeMath.bdiv(weightDelta, blockPeriod);\n', '                    //deltaPerBlock = bdivx(weightDelta, blockPeriod);\n', '\n', '                     // newWeight = startWeight + (blocksElapsed * deltaPerBlock)\n', '                    newWeight = BalancerSafeMath.badd(gradualUpdate.startWeights[i],\n', '                                                      BalancerSafeMath.bmul(blocksElapsed, deltaPerBlock));\n', '                }\n', '\n', '                uint bal = bPool.getBalance(tokens[i]);\n', '\n', '                bPool.rebind(tokens[i], bal, newWeight);\n', '            }\n', '        }\n', '\n', '        // Reset to allow add/remove tokens, or manual weight updates\n', '        if (block.number >= gradualUpdate.endBlock) {\n', '            gradualUpdate.startBlock = 0;\n', '        }\n', '    }\n', '\n', '    /* solhint-enable function-max-lines */\n', '\n', '    /**\n', '     * @notice Schedule (commit) a token to be added; must call applyAddToken after a fixed\n', '     *         number of blocks to actually add the token\n', '     * @param bPool - Core BPool the CRP is wrapping\n', '     * @param token - the token to be added\n', '     * @param balance - how much to be added\n', '     * @param denormalizedWeight - the desired token weight\n', '     * @param newToken - NewTokenParams struct used to hold the token data (in CRP storage)\n', '     */\n', '    function commitAddToken(\n', '        IBPool bPool,\n', '        address token,\n', '        uint balance,\n', '        uint denormalizedWeight,\n', '        NewTokenParams storage newToken\n', '    )\n', '        external\n', '    {\n', '        require(!bPool.isBound(token), "ERR_IS_BOUND");\n', '\n', '        require(denormalizedWeight <= BalancerConstants.MAX_WEIGHT, "ERR_WEIGHT_ABOVE_MAX");\n', '        require(denormalizedWeight >= BalancerConstants.MIN_WEIGHT, "ERR_WEIGHT_BELOW_MIN");\n', '        require(BalancerSafeMath.badd(bPool.getTotalDenormalizedWeight(),\n', '                                      denormalizedWeight) <= BalancerConstants.MAX_TOTAL_WEIGHT,\n', '                "ERR_MAX_TOTAL_WEIGHT");\n', '        require(balance >= BalancerConstants.MIN_BALANCE, "ERR_BALANCE_BELOW_MIN");\n', '\n', '        newToken.addr = token;\n', '        newToken.balance = balance;\n', '        newToken.denorm = denormalizedWeight;\n', '        newToken.commitBlock = block.number;\n', '        newToken.isCommitted = true;\n', '    }\n', '\n', '    /**\n', '     * @notice Add the token previously committed (in commitAddToken) to the pool\n', '     * @param self - ConfigurableRightsPool instance calling the library\n', '     * @param bPool - Core BPool the CRP is wrapping\n', '     * @param addTokenTimeLockInBlocks -  Wait time between committing and applying a new token\n', '     * @param newToken - NewTokenParams struct used to hold the token data (in CRP storage)\n', '     */\n', '    function applyAddToken(\n', '        IConfigurableRightsPool self,\n', '        IBPool bPool,\n', '        uint addTokenTimeLockInBlocks,\n', '        NewTokenParams storage newToken\n', '    )\n', '        external\n', '    {\n', '        require(newToken.isCommitted, "ERR_NO_TOKEN_COMMIT");\n', '        require(BalancerSafeMath.bsub(block.number, newToken.commitBlock) >= addTokenTimeLockInBlocks,\n', '                                      "ERR_TIMELOCK_STILL_COUNTING");\n', '\n', '        uint totalSupply = self.totalSupply();\n', '\n', '        // poolShares = totalSupply * newTokenWeight / totalWeight\n', '        uint poolShares = BalancerSafeMath.bdiv(BalancerSafeMath.bmul(totalSupply, newToken.denorm),\n', '                                                bPool.getTotalDenormalizedWeight());\n', '\n', '        // Clear this to allow adding more tokens\n', '        newToken.isCommitted = false;\n', '\n', '        // First gets the tokens from msg.sender to this contract (Pool Controller)\n', '        bool returnValue = IERC20(newToken.addr).transferFrom(self.getController(), address(self), newToken.balance);\n', '        require(returnValue, "ERR_ERC20_FALSE");\n', '\n', '        // Now with the tokens this contract can bind them to the pool it controls\n', '        // Approves bPool to pull from this controller\n', '        // Approve unlimited, same as when creating the pool, so they can join pools later\n', '        returnValue = SafeApprove.safeApprove(IERC20(newToken.addr), address(bPool), BalancerConstants.MAX_UINT);\n', '        require(returnValue, "ERR_ERC20_FALSE");\n', '\n', '        bPool.bind(newToken.addr, newToken.balance, newToken.denorm);\n', '\n', '        self.mintPoolShareFromLib(poolShares);\n', '        self.pushPoolShareFromLib(msg.sender, poolShares);\n', '    }\n', '\n', '     /**\n', '     * @notice Remove a token from the pool\n', '     * @dev Logic in the CRP controls when ths can be called. There are two related permissions:\n', '     *      AddRemoveTokens - which allows removing down to the underlying BPool limit of two\n', '     *      RemoveAllTokens - which allows completely draining the pool by removing all tokens\n', '     *                        This can result in a non-viable pool with 0 or 1 tokens (by design),\n', '     *                        meaning all swapping or binding operations would fail in this state\n', '     * @param self - ConfigurableRightsPool instance calling the library\n', '     * @param bPool - Core BPool the CRP is wrapping\n', '     * @param token - token to remove\n', '     */\n', '    function removeToken(\n', '        IConfigurableRightsPool self,\n', '        IBPool bPool,\n', '        address token\n', '    )\n', '        external\n', '    {\n', '        uint totalSupply = self.totalSupply();\n', '\n', '        // poolShares = totalSupply * tokenWeight / totalWeight\n', '        uint poolShares = BalancerSafeMath.bdiv(BalancerSafeMath.bmul(totalSupply,\n', '                                                                      bPool.getDenormalizedWeight(token)),\n', '                                                bPool.getTotalDenormalizedWeight());\n', '\n', '        // this is what will be unbound from the pool\n', '        // Have to get it before unbinding\n', '        uint balance = bPool.getBalance(token);\n', '\n', '        // Unbind and get the tokens out of balancer pool\n', '        bPool.unbind(token);\n', '\n', '        // Now with the tokens this contract can send them to msg.sender\n', '        bool xfer = IERC20(token).transfer(self.getController(), balance);\n', '        require(xfer, "ERR_ERC20_FALSE");\n', '\n', '        self.pullPoolShareFromLib(self.getController(), poolShares);\n', '        self.burnPoolShareFromLib(poolShares);\n', '    }\n', '\n', '    /**\n', "     * @notice Non ERC20-conforming tokens are problematic; don't allow them in pools\n", '     * @dev Will revert if invalid\n', '     * @param token - The prospective token to verify\n', '     */\n', '    function verifyTokenCompliance(address token) external {\n', '        verifyTokenComplianceInternal(token);\n', '    }\n', '\n', '    /**\n', "     * @notice Non ERC20-conforming tokens are problematic; don't allow them in pools\n", '     * @dev Will revert if invalid - overloaded to save space in the main contract\n', '     * @param tokens - The prospective tokens to verify\n', '     */\n', '    function verifyTokenCompliance(address[] calldata tokens) external {\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            verifyTokenComplianceInternal(tokens[i]);\n', '         }\n', '    }\n', '\n', '    /**\n', '     * @notice Update weights in a predetermined way, between startBlock and endBlock,\n', '     *         through external cals to pokeWeights\n', '     * @param bPool - Core BPool the CRP is wrapping\n', '     * @param newWeights - final weights we want to get to\n', '     * @param startBlock - when weights should start to change\n', '     * @param endBlock - when weights will be at their final values\n', '     * @param minimumWeightChangeBlockPeriod - needed to validate the block period\n', '    */\n', '    function updateWeightsGradually(\n', '        IBPool bPool,\n', '        GradualUpdateParams storage gradualUpdate,\n', '        uint[] calldata newWeights,\n', '        uint startBlock,\n', '        uint endBlock,\n', '        uint minimumWeightChangeBlockPeriod\n', '    )\n', '        external\n', '    {\n', '        // Enforce a minimum time over which to make the changes\n', '        // The also prevents endBlock <= startBlock\n', '        require(BalancerSafeMath.bsub(endBlock, startBlock) >= minimumWeightChangeBlockPeriod,\n', '                "ERR_WEIGHT_CHANGE_TIME_BELOW_MIN");\n', '        require(block.number < endBlock, "ERR_GRADUAL_UPDATE_TIME_TRAVEL");\n', '\n', '        address[] memory tokens = bPool.getCurrentTokens();\n', '\n', '        // Must specify weights for all tokens\n', '        require(newWeights.length == tokens.length, "ERR_START_WEIGHTS_MISMATCH");\n', '\n', '        uint weightsSum = 0;\n', '        gradualUpdate.startWeights = new uint[](tokens.length);\n', '\n', '        // Check that endWeights are valid now to avoid reverting in a future pokeWeights call\n', '        //\n', '        // This loop contains external calls\n', '        // External calls are to math libraries or the underlying pool, so low risk\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            require(newWeights[i] <= BalancerConstants.MAX_WEIGHT, "ERR_WEIGHT_ABOVE_MAX");\n', '            require(newWeights[i] >= BalancerConstants.MIN_WEIGHT, "ERR_WEIGHT_BELOW_MIN");\n', '\n', '            weightsSum = BalancerSafeMath.badd(weightsSum, newWeights[i]);\n', '            gradualUpdate.startWeights[i] = bPool.getDenormalizedWeight(tokens[i]);\n', '        }\n', '        require(weightsSum <= BalancerConstants.MAX_TOTAL_WEIGHT, "ERR_MAX_TOTAL_WEIGHT");\n', '\n', '        if (block.number > startBlock && block.number < endBlock) {\n', '            // This means the weight update should start ASAP\n', '            // Moving the start block up prevents a big jump/discontinuity in the weights\n', '            //\n', '            // Only valid within the startBlock - endBlock period!\n', "            // Should not happen, but defensively check that we aren't\n", '            // setting the start point past the end point\n', '            gradualUpdate.startBlock = block.number;\n', '        }\n', '        else{\n', '            gradualUpdate.startBlock = startBlock;\n', '        }\n', '\n', '        gradualUpdate.endBlock = endBlock;\n', '        gradualUpdate.endWeights = newWeights;\n', '    }\n', '\n', '    /**\n', '     * @notice Join a pool\n', '     * @param self - ConfigurableRightsPool instance calling the library\n', '     * @param bPool - Core BPool the CRP is wrapping\n', '     * @param poolAmountOut - number of pool tokens to receive\n', '     * @param maxAmountsIn - Max amount of asset tokens to spend\n', '     * @return actualAmountsIn - calculated values of the tokens to pull in\n', '     */\n', '    function joinPool(\n', '        IConfigurableRightsPool self,\n', '        IBPool bPool,\n', '        uint poolAmountOut,\n', '        uint[] calldata maxAmountsIn\n', '    )\n', '         external\n', '         view\n', '         returns (uint[] memory actualAmountsIn)\n', '    {\n', '        address[] memory tokens = bPool.getCurrentTokens();\n', '\n', '        require(maxAmountsIn.length == tokens.length, "ERR_AMOUNTS_MISMATCH");\n', '\n', '        uint poolTotal = self.totalSupply();\n', '        // Subtract  1 to ensure any rounding errors favor the pool\n', '        uint ratio = BalancerSafeMath.bdiv(poolAmountOut,\n', '                                           BalancerSafeMath.bsub(poolTotal, 1));\n', '\n', '        require(ratio != 0, "ERR_MATH_APPROX");\n', '\n', '        // We know the length of the array; initialize it, and fill it below\n', '        // Cannot do "push" in memory\n', '        actualAmountsIn = new uint[](tokens.length);\n', '\n', '        // This loop contains external calls\n', '        // External calls are to math libraries or the underlying pool, so low risk\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            address t = tokens[i];\n', '            uint bal = bPool.getBalance(t);\n', '            // Add 1 to ensure any rounding errors favor the pool\n', '            uint tokenAmountIn = BalancerSafeMath.bmul(ratio,\n', '                                                       BalancerSafeMath.badd(bal, 1));\n', '\n', '            require(tokenAmountIn != 0, "ERR_MATH_APPROX");\n', '            require(tokenAmountIn <= maxAmountsIn[i], "ERR_LIMIT_IN");\n', '\n', '            actualAmountsIn[i] = tokenAmountIn;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Exit a pool - redeem pool tokens for underlying assets\n', '     * @param self - ConfigurableRightsPool instance calling the library\n', '     * @param bPool - Core BPool the CRP is wrapping\n', '     * @param poolAmountIn - amount of pool tokens to redeem\n', '     * @param minAmountsOut - minimum amount of asset tokens to receive\n', '     * @return exitFee - calculated exit fee\n', '     * @return pAiAfterExitFee - final amount in (after accounting for exit fee)\n', '     * @return actualAmountsOut - calculated amounts of each token to pull\n', '     */\n', '    function exitPool(\n', '        IConfigurableRightsPool self,\n', '        IBPool bPool,\n', '        uint poolAmountIn,\n', '        uint[] calldata minAmountsOut\n', '    )\n', '        external\n', '        view\n', '        returns (uint exitFee, uint pAiAfterExitFee, uint[] memory actualAmountsOut)\n', '    {\n', '        address[] memory tokens = bPool.getCurrentTokens();\n', '\n', '        require(minAmountsOut.length == tokens.length, "ERR_AMOUNTS_MISMATCH");\n', '\n', '        uint poolTotal = self.totalSupply();\n', '\n', '        // Calculate exit fee and the final amount in\n', '        exitFee = BalancerSafeMath.bmul(poolAmountIn, BalancerConstants.EXIT_FEE);\n', '        pAiAfterExitFee = BalancerSafeMath.bsub(poolAmountIn, exitFee);\n', '\n', '        uint ratio = BalancerSafeMath.bdiv(pAiAfterExitFee,\n', '                                           BalancerSafeMath.badd(poolTotal, 1));\n', '\n', '        require(ratio != 0, "ERR_MATH_APPROX");\n', '\n', '        actualAmountsOut = new uint[](tokens.length);\n', '\n', '        // This loop contains external calls\n', '        // External calls are to math libraries or the underlying pool, so low risk\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            address t = tokens[i];\n', '            uint bal = bPool.getBalance(t);\n', '            // Subtract 1 to ensure any rounding errors favor the pool\n', '            uint tokenAmountOut = BalancerSafeMath.bmul(ratio,\n', '                                                        BalancerSafeMath.bsub(bal, 1));\n', '\n', '            require(tokenAmountOut != 0, "ERR_MATH_APPROX");\n', '            require(tokenAmountOut >= minAmountsOut[i], "ERR_LIMIT_OUT");\n', '\n', '            actualAmountsOut[i] = tokenAmountOut;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Join by swapping a fixed amount of an external token in (must be present in the pool)\n', '     *         System calculates the pool token amount\n', '     * @param self - ConfigurableRightsPool instance calling the library\n', '     * @param bPool - Core BPool the CRP is wrapping\n', "     * @param tokenIn - which token we're transferring in\n", '     * @param tokenAmountIn - amount of deposit\n', '     * @param minPoolAmountOut - minimum of pool tokens to receive\n', '     * @return poolAmountOut - amount of pool tokens minted and transferred\n', '     */\n', '    function joinswapExternAmountIn(\n', '        IConfigurableRightsPool self,\n', '        IBPool bPool,\n', '        address tokenIn,\n', '        uint tokenAmountIn,\n', '        uint minPoolAmountOut\n', '    )\n', '        external\n', '        view\n', '        returns (uint poolAmountOut)\n', '    {\n', '        require(bPool.isBound(tokenIn), "ERR_NOT_BOUND");\n', '        require(tokenAmountIn <= BalancerSafeMath.bmul(bPool.getBalance(tokenIn),\n', '                                                       BalancerConstants.MAX_IN_RATIO),\n', '                                                       "ERR_MAX_IN_RATIO");\n', '\n', '        poolAmountOut = bPool.calcPoolOutGivenSingleIn(\n', '                            bPool.getBalance(tokenIn),\n', '                            bPool.getDenormalizedWeight(tokenIn),\n', '                            self.totalSupply(),\n', '                            bPool.getTotalDenormalizedWeight(),\n', '                            tokenAmountIn,\n', '                            bPool.getSwapFee()\n', '                        );\n', '\n', '        require(poolAmountOut >= minPoolAmountOut, "ERR_LIMIT_OUT");\n', '    }\n', '\n', '    /**\n', '     * @notice Join by swapping an external token in (must be present in the pool)\n', '     *         To receive an exact amount of pool tokens out. System calculates the deposit amount\n', '     * @param self - ConfigurableRightsPool instance calling the library\n', '     * @param bPool - Core BPool the CRP is wrapping\n', "     * @param tokenIn - which token we're transferring in (system calculates amount required)\n", '     * @param poolAmountOut - amount of pool tokens to be received\n', '     * @param maxAmountIn - Maximum asset tokens that can be pulled to pay for the pool tokens\n', '     * @return tokenAmountIn - amount of asset tokens transferred in to purchase the pool tokens\n', '     */\n', '    function joinswapPoolAmountOut(\n', '        IConfigurableRightsPool self,\n', '        IBPool bPool,\n', '        address tokenIn,\n', '        uint poolAmountOut,\n', '        uint maxAmountIn\n', '    )\n', '        external\n', '        view\n', '        returns (uint tokenAmountIn)\n', '    {\n', '        require(bPool.isBound(tokenIn), "ERR_NOT_BOUND");\n', '\n', '        tokenAmountIn = bPool.calcSingleInGivenPoolOut(\n', '                            bPool.getBalance(tokenIn),\n', '                            bPool.getDenormalizedWeight(tokenIn),\n', '                            self.totalSupply(),\n', '                            bPool.getTotalDenormalizedWeight(),\n', '                            poolAmountOut,\n', '                            bPool.getSwapFee()\n', '                        );\n', '\n', '        require(tokenAmountIn != 0, "ERR_MATH_APPROX");\n', '        require(tokenAmountIn <= maxAmountIn, "ERR_LIMIT_IN");\n', '\n', '        require(tokenAmountIn <= BalancerSafeMath.bmul(bPool.getBalance(tokenIn),\n', '                                                       BalancerConstants.MAX_IN_RATIO),\n', '                                                       "ERR_MAX_IN_RATIO");\n', '    }\n', '\n', '    /**\n', '     * @notice Exit a pool - redeem a specific number of pool tokens for an underlying asset\n', '     *         Asset must be present in the pool, and will incur an EXIT_FEE (if set to non-zero)\n', '     * @param self - ConfigurableRightsPool instance calling the library\n', '     * @param bPool - Core BPool the CRP is wrapping\n', '     * @param tokenOut - which token the caller wants to receive\n', '     * @param poolAmountIn - amount of pool tokens to redeem\n', '     * @param minAmountOut - minimum asset tokens to receive\n', '     * @return exitFee - calculated exit fee\n', '     * @return tokenAmountOut - amount of asset tokens returned\n', '     */\n', '    function exitswapPoolAmountIn(\n', '        IConfigurableRightsPool self,\n', '        IBPool bPool,\n', '        address tokenOut,\n', '        uint poolAmountIn,\n', '        uint minAmountOut\n', '    )\n', '        external\n', '        view\n', '        returns (uint exitFee, uint tokenAmountOut)\n', '    {\n', '        require(bPool.isBound(tokenOut), "ERR_NOT_BOUND");\n', '\n', '        tokenAmountOut = bPool.calcSingleOutGivenPoolIn(\n', '                            bPool.getBalance(tokenOut),\n', '                            bPool.getDenormalizedWeight(tokenOut),\n', '                            self.totalSupply(),\n', '                            bPool.getTotalDenormalizedWeight(),\n', '                            poolAmountIn,\n', '                            bPool.getSwapFee()\n', '                        );\n', '\n', '        require(tokenAmountOut >= minAmountOut, "ERR_LIMIT_OUT");\n', '        require(tokenAmountOut <= BalancerSafeMath.bmul(bPool.getBalance(tokenOut),\n', '                                                        BalancerConstants.MAX_OUT_RATIO),\n', '                                                        "ERR_MAX_OUT_RATIO");\n', '\n', '        exitFee = BalancerSafeMath.bmul(poolAmountIn, BalancerConstants.EXIT_FEE);\n', '    }\n', '\n', '    /**\n', '     * @notice Exit a pool - redeem pool tokens for a specific amount of underlying assets\n', '     *         Asset must be present in the pool\n', '     * @param self - ConfigurableRightsPool instance calling the library\n', '     * @param bPool - Core BPool the CRP is wrapping\n', '     * @param tokenOut - which token the caller wants to receive\n', '     * @param tokenAmountOut - amount of underlying asset tokens to receive\n', '     * @param maxPoolAmountIn - maximum pool tokens to be redeemed\n', '     * @return exitFee - calculated exit fee\n', '     * @return poolAmountIn - amount of pool tokens redeemed\n', '     */\n', '    function exitswapExternAmountOut(\n', '        IConfigurableRightsPool self,\n', '        IBPool bPool,\n', '        address tokenOut,\n', '        uint tokenAmountOut,\n', '        uint maxPoolAmountIn\n', '    )\n', '        external\n', '        view\n', '        returns (uint exitFee, uint poolAmountIn)\n', '    {\n', '        require(bPool.isBound(tokenOut), "ERR_NOT_BOUND");\n', '        require(tokenAmountOut <= BalancerSafeMath.bmul(bPool.getBalance(tokenOut),\n', '                                                        BalancerConstants.MAX_OUT_RATIO),\n', '                                                        "ERR_MAX_OUT_RATIO");\n', '        poolAmountIn = bPool.calcPoolInGivenSingleOut(\n', '                            bPool.getBalance(tokenOut),\n', '                            bPool.getDenormalizedWeight(tokenOut),\n', '                            self.totalSupply(),\n', '                            bPool.getTotalDenormalizedWeight(),\n', '                            tokenAmountOut,\n', '                            bPool.getSwapFee()\n', '                        );\n', '\n', '        require(poolAmountIn != 0, "ERR_MATH_APPROX");\n', '        require(poolAmountIn <= maxPoolAmountIn, "ERR_LIMIT_IN");\n', '\n', '        exitFee = BalancerSafeMath.bmul(poolAmountIn, BalancerConstants.EXIT_FEE);\n', '    }\n', '\n', '    // Internal functions\n', '\n', '    // Check for zero transfer, and make sure it returns true to returnValue\n', '    function verifyTokenComplianceInternal(address token) internal {\n', '        bool returnValue = IERC20(token).transfer(msg.sender, 0);\n', '        require(returnValue, "ERR_NONCONFORMING_TOKEN");\n', '    }\n', '}']