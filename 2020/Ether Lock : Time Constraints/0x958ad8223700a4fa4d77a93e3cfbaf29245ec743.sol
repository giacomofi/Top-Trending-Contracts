['// File: contracts/sol6/IERC20.sol\n', '\n', 'pragma solidity 0.6.6;\n', '\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    ) external returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    function decimals() external view returns (uint8 digits);\n', '\n', '    function totalSupply() external view returns (uint256 supply);\n', '}\n', '\n', '\n', '// to support backward compatible contract name -- so function signature remains same\n', 'abstract contract ERC20 is IERC20 {\n', '\n', '}\n', '\n', '// File: contracts/sol6/IKyberReserve.sol\n', '\n', 'pragma solidity 0.6.6;\n', '\n', '\n', '\n', 'interface IKyberReserve {\n', '    function trade(\n', '        IERC20 srcToken,\n', '        uint256 srcAmount,\n', '        IERC20 destToken,\n', '        address payable destAddress,\n', '        uint256 conversionRate,\n', '        bool validate\n', '    ) external payable returns (bool);\n', '\n', '    function getConversionRate(\n', '        IERC20 src,\n', '        IERC20 dest,\n', '        uint256 srcQty,\n', '        uint256 blockNumber\n', '    ) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/sol6/utils/Utils5.sol\n', '\n', 'pragma solidity 0.6.6;\n', '\n', '\n', '\n', '/**\n', ' * @title Kyber utility file\n', ' * mostly shared constants and rate calculation helpers\n', ' * inherited by most of kyber contracts.\n', ' * previous utils implementations are for previous solidity versions.\n', ' */\n', 'contract Utils5 {\n', '    IERC20 internal constant ETH_TOKEN_ADDRESS = IERC20(\n', '        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n', '    );\n', '    uint256 internal constant PRECISION = (10**18);\n', '    uint256 internal constant MAX_QTY = (10**28); // 10B tokens\n', '    uint256 internal constant MAX_RATE = (PRECISION * 10**7); // up to 10M tokens per eth\n', '    uint256 internal constant MAX_DECIMALS = 18;\n', '    uint256 internal constant ETH_DECIMALS = 18;\n', '    uint256 constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\n', '    uint256 internal constant MAX_ALLOWANCE = uint256(-1); // token.approve inifinite\n', '\n', '    mapping(IERC20 => uint256) internal decimals;\n', '\n', '    function getUpdateDecimals(IERC20 token) internal returns (uint256) {\n', '        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\n', '        uint256 tokenDecimals = decimals[token];\n', '        // moreover, very possible that old tokens have decimals 0\n', '        // these tokens will just have higher gas fees.\n', '        if (tokenDecimals == 0) {\n', '            tokenDecimals = token.decimals();\n', '            decimals[token] = tokenDecimals;\n', '        }\n', '\n', '        return tokenDecimals;\n', '    }\n', '\n', '    function setDecimals(IERC20 token) internal {\n', '        if (decimals[token] != 0) return; //already set\n', '\n', '        if (token == ETH_TOKEN_ADDRESS) {\n', '            decimals[token] = ETH_DECIMALS;\n', '        } else {\n', '            decimals[token] = token.decimals();\n', '        }\n', '    }\n', '\n', '    /// @dev get the balance of a user.\n', '    /// @param token The token type\n', '    /// @return The balance\n', '    function getBalance(IERC20 token, address user) internal view returns (uint256) {\n', '        if (token == ETH_TOKEN_ADDRESS) {\n', '            return user.balance;\n', '        } else {\n', '            return token.balanceOf(user);\n', '        }\n', '    }\n', '\n', '    function getDecimals(IERC20 token) internal view returns (uint256) {\n', '        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\n', '        uint256 tokenDecimals = decimals[token];\n', '        // moreover, very possible that old tokens have decimals 0\n', '        // these tokens will just have higher gas fees.\n', '        if (tokenDecimals == 0) return token.decimals();\n', '\n', '        return tokenDecimals;\n', '    }\n', '\n', '    function calcDestAmount(\n', '        IERC20 src,\n', '        IERC20 dest,\n', '        uint256 srcAmount,\n', '        uint256 rate\n', '    ) internal view returns (uint256) {\n', '        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\n', '    }\n', '\n', '    function calcSrcAmount(\n', '        IERC20 src,\n', '        IERC20 dest,\n', '        uint256 destAmount,\n', '        uint256 rate\n', '    ) internal view returns (uint256) {\n', '        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\n', '    }\n', '\n', '    function calcDstQty(\n', '        uint256 srcQty,\n', '        uint256 srcDecimals,\n', '        uint256 dstDecimals,\n', '        uint256 rate\n', '    ) internal pure returns (uint256) {\n', '        require(srcQty <= MAX_QTY, "srcQty > MAX_QTY");\n', '        require(rate <= MAX_RATE, "rate > MAX_RATE");\n', '\n', '        if (dstDecimals >= srcDecimals) {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, "dst - src > MAX_DECIMALS");\n', '            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n', '        } else {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, "src - dst > MAX_DECIMALS");\n', '            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n', '        }\n', '    }\n', '\n', '    function calcSrcQty(\n', '        uint256 dstQty,\n', '        uint256 srcDecimals,\n', '        uint256 dstDecimals,\n', '        uint256 rate\n', '    ) internal pure returns (uint256) {\n', '        require(dstQty <= MAX_QTY, "dstQty > MAX_QTY");\n', '        require(rate <= MAX_RATE, "rate > MAX_RATE");\n', '\n', '        //source quantity is rounded up. to avoid dest quantity being too low.\n', '        uint256 numerator;\n', '        uint256 denominator;\n', '        if (srcDecimals >= dstDecimals) {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, "src - dst > MAX_DECIMALS");\n', '            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n', '            denominator = rate;\n', '        } else {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, "dst - src > MAX_DECIMALS");\n', '            numerator = (PRECISION * dstQty);\n', '            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n', '        }\n', '        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n', '    }\n', '\n', '    function calcRateFromQty(\n', '        uint256 srcAmount,\n', '        uint256 destAmount,\n', '        uint256 srcDecimals,\n', '        uint256 dstDecimals\n', '    ) internal pure returns (uint256) {\n', '        require(srcAmount <= MAX_QTY, "srcAmount > MAX_QTY");\n', '        require(destAmount <= MAX_QTY, "destAmount > MAX_QTY");\n', '\n', '        if (dstDecimals >= srcDecimals) {\n', '            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, "dst - src > MAX_DECIMALS");\n', '            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\n', '        } else {\n', '            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, "src - dst > MAX_DECIMALS");\n', '            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\n', '        }\n', '    }\n', '\n', '    function minOf(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        return x > y ? y : x;\n', '    }\n', '}\n', '\n', '// File: contracts/sol6/utils/PermissionGroupsNoModifiers.sol\n', '\n', 'pragma solidity 0.6.6;\n', '\n', '\n', 'contract PermissionGroupsNoModifiers {\n', '    address public admin;\n', '    address public pendingAdmin;\n', '    mapping(address => bool) internal operators;\n', '    mapping(address => bool) internal alerters;\n', '    address[] internal operatorsGroup;\n', '    address[] internal alertersGroup;\n', '    uint256 internal constant MAX_GROUP_SIZE = 50;\n', '\n', '    event AdminClaimed(address newAdmin, address previousAdmin);\n', '    event AlerterAdded(address newAlerter, bool isAdd);\n', '    event OperatorAdded(address newOperator, bool isAdd);\n', '    event TransferAdminPending(address pendingAdmin);\n', '\n', '    constructor(address _admin) public {\n', '        require(_admin != address(0), "admin 0");\n', '        admin = _admin;\n', '    }\n', '\n', '    function getOperators() external view returns (address[] memory) {\n', '        return operatorsGroup;\n', '    }\n', '\n', '    function getAlerters() external view returns (address[] memory) {\n', '        return alertersGroup;\n', '    }\n', '\n', '    function addAlerter(address newAlerter) public {\n', '        onlyAdmin();\n', '        require(!alerters[newAlerter], "alerter exists"); // prevent duplicates.\n', '        require(alertersGroup.length < MAX_GROUP_SIZE, "max alerters");\n', '\n', '        emit AlerterAdded(newAlerter, true);\n', '        alerters[newAlerter] = true;\n', '        alertersGroup.push(newAlerter);\n', '    }\n', '\n', '    function addOperator(address newOperator) public {\n', '        onlyAdmin();\n', '        require(!operators[newOperator], "operator exists"); // prevent duplicates.\n', '        require(operatorsGroup.length < MAX_GROUP_SIZE, "max operators");\n', '\n', '        emit OperatorAdded(newOperator, true);\n', '        operators[newOperator] = true;\n', '        operatorsGroup.push(newOperator);\n', '    }\n', '\n', '    /// @dev Allows the pendingAdmin address to finalize the change admin process.\n', '    function claimAdmin() public {\n', '        require(pendingAdmin == msg.sender, "not pending");\n', '        emit AdminClaimed(pendingAdmin, admin);\n', '        admin = pendingAdmin;\n', '        pendingAdmin = address(0);\n', '    }\n', '\n', '    function removeAlerter(address alerter) public {\n', '        onlyAdmin();\n', '        require(alerters[alerter], "not alerter");\n', '        delete alerters[alerter];\n', '\n', '        for (uint256 i = 0; i < alertersGroup.length; ++i) {\n', '            if (alertersGroup[i] == alerter) {\n', '                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\n', '                alertersGroup.pop();\n', '                emit AlerterAdded(alerter, false);\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    function removeOperator(address operator) public {\n', '        onlyAdmin();\n', '        require(operators[operator], "not operator");\n', '        delete operators[operator];\n', '\n', '        for (uint256 i = 0; i < operatorsGroup.length; ++i) {\n', '            if (operatorsGroup[i] == operator) {\n', '                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n', '                operatorsGroup.pop();\n', '                emit OperatorAdded(operator, false);\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Allows the current admin to set the pendingAdmin address\n', '    /// @param newAdmin The address to transfer ownership to\n', '    function transferAdmin(address newAdmin) public {\n', '        onlyAdmin();\n', '        require(newAdmin != address(0), "new admin 0");\n', '        emit TransferAdminPending(newAdmin);\n', '        pendingAdmin = newAdmin;\n', '    }\n', '\n', '    /// @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n', '    /// @param newAdmin The address to transfer ownership to.\n', '    function transferAdminQuickly(address newAdmin) public {\n', '        onlyAdmin();\n', '        require(newAdmin != address(0), "admin 0");\n', '        emit TransferAdminPending(newAdmin);\n', '        emit AdminClaimed(newAdmin, admin);\n', '        admin = newAdmin;\n', '    }\n', '\n', '    function onlyAdmin() internal view {\n', '        require(msg.sender == admin, "only admin");\n', '    }\n', '\n', '    function onlyAlerter() internal view {\n', '        require(alerters[msg.sender], "only alerter");\n', '    }\n', '\n', '    function onlyOperator() internal view {\n', '        require(operators[msg.sender], "only operator");\n', '    }\n', '}\n', '\n', '// File: contracts/sol6/utils/WithdrawableNoModifiers.sol\n', '\n', 'pragma solidity 0.6.6;\n', '\n', '\n', '\n', '\n', 'contract WithdrawableNoModifiers is PermissionGroupsNoModifiers {\n', '    constructor(address _admin) public PermissionGroupsNoModifiers(_admin) {}\n', '\n', '    event EtherWithdraw(uint256 amount, address sendTo);\n', '    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\n', '\n', '    /// @dev Withdraw Ethers\n', '    function withdrawEther(uint256 amount, address payable sendTo) external {\n', '        onlyAdmin();\n', '        (bool success, ) = sendTo.call{value: amount}("");\n', '        require(success);\n', '        emit EtherWithdraw(amount, sendTo);\n', '    }\n', '\n', '    /// @dev Withdraw all IERC20 compatible tokens\n', '    /// @param token IERC20 The address of the token contract\n', '    function withdrawToken(\n', '        IERC20 token,\n', '        uint256 amount,\n', '        address sendTo\n', '    ) external {\n', '        onlyAdmin();\n', '        token.transfer(sendTo, amount);\n', '        emit TokenWithdraw(token, amount, sendTo);\n', '    }\n', '}\n', '\n', '// File: contracts/sol6/wrappers/KyberRatesQueryHelper.sol\n', '\n', 'pragma solidity 0.6.6;\n', '\n', '\n', '\n', '\n', '\n', 'contract KyberRateQueryHelper is WithdrawableNoModifiers, Utils5 {\n', '    \n', '    \n', '    constructor(address _admin) public WithdrawableNoModifiers(_admin) {\n', '        /* empty body */\n', '    }\n', '    \n', '    function getRateWithEth(address reserve, IERC20 token, uint256 weiAmount) public view \n', '        returns(uint256 sellRate, uint256 buyRate, uint256 tweiAmount) \n', '    {\n', '        buyRate = IKyberReserve(reserve).getConversionRate(\n', '                    ETH_TOKEN_ADDRESS,\n', '                    token,\n', '                    weiAmount,\n', '                    block.number\n', '                );\n', '\n', '        tweiAmount = calcDestAmount(ETH_TOKEN_ADDRESS, token, weiAmount, buyRate);\n', '\n', '        sellRate = IKyberReserve(reserve).getConversionRate(\n', '                    token,\n', '                    ETH_TOKEN_ADDRESS,\n', '                    tweiAmount,\n', '                    block.number\n', '                );\n', '    }\n', '\n', '    function getRatesWithEth(address reserve, IERC20[] calldata tokens, uint256 weiAmount) external view \n', '        returns(uint256[] memory sellRates, uint256[] memory buyRates)\n', '    {\n', '        uint256 numTokens = tokens.length;\n', '     \n', '        buyRates = new uint256[](numTokens);\n', '        sellRates = new uint256[](numTokens);\n', '        for (uint256 i = 0; i < numTokens; i++) {\n', '            (buyRates[i], sellRates[i], ) = getRateWithEth(reserve, tokens[i], weiAmount);\n', '        }   \n', '    }\n', '    \n', '    function getRateWithToken(address reserve, IERC20 token, uint256 tweiAmount) public view \n', '        returns(uint256 buyRate, uint256 sellRate, uint weiAmount) \n', '    {\n', '        // uint reserveFee = getFeeForReserve(reserve);\n', '        // uint256 weiAmountDeductedFee = weiAmount - ((weiAmount * reserveFee) / BPS);\n', '\n', '        sellRate = IKyberReserve(reserve).getConversionRate(\n', '                    token,\n', '                    ETH_TOKEN_ADDRESS,\n', '                    tweiAmount,\n', '                    block.number\n', '                );\n', '\n', '        weiAmount = calcDestAmount(token, ETH_TOKEN_ADDRESS, tweiAmount, sellRate);\n', '\n', '        buyRate = IKyberReserve(reserve).getConversionRate(\n', '                    ETH_TOKEN_ADDRESS,\n', '                    token,\n', '                    weiAmount,\n', '                    block.number\n', '                );\n', '    }\n', '\n', '    function getRatesWithToken(address reserve, IERC20[] calldata tokens, uint256 tweiAmount) external view \n', '        returns(uint256[] memory sellRates, uint256[] memory buyRates)\n', '    {\n', '        uint256 numTokens = tokens.length;\n', '     \n', '        buyRates = new uint256[](numTokens);\n', '        sellRates = new uint256[](numTokens);\n', '        for (uint256 i = 0; i < numTokens; i++) {\n', '            (buyRates[i], sellRates[i], ) = getRateWithEth(reserve, tokens[i], tweiAmount);\n', '        }   \n', '    }\n', '    \n', '    // function getFeeForReserve(address reserve) public view returns (uint256 feeBps) {\n', '    //     address[] memory reserves = new address[](1);\n', '    //     reserves[0] = reserve;\n', '    //     bool[] memory isFeeAccountedFlags = kyberStorage.getFeeAccountedData(reserves);\n', '    //     (uint256 networkFeeBps, ) = kyberDao.getLatestNetworkFeeData();\n', '\n', '    //     if (reserves[0] == true) return networkFeeBps;\n', '    //     return 0;\n', '    // }\n', '}']