['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-10\n', '*/\n', '\n', 'pragma solidity ^0.4.23;\n', '/*\n', ' *             ╔═╗┌─┐┌─┐┬┌─┐┬┌─┐┬   ┌─────────────────────────┐ ╦ ╦┌─┐┌┐ ╔═╗┬┌┬┐┌─┐\n', ' *             ║ ║├┤ ├┤ ││  │├─┤│   │ KOL Community Foundation│ │ ║║║├┤ ├┴┐╚═╗│ │ ├┤\n', ' *             ╚═╝└  └  ┴└─┘┴┴ ┴┴─┘ └─┬─────────────────────┬─┘ ╚╩╝└─┘└─┘╚═╝┴ ┴ └─┘\n', ' *   ┌────────────────────────────────┘                     └──────────────────────────────┐\n', ' *   │    ┌─────────────────────────────────────────────────────────────────────────────┐  │\n', ' *   └────┤ Dev:Jack Koe ├─────────────┤ Special for: KOL  ├───────────────┤ 20200513   ├──┘\n', ' *        └─────────────────────────────────────────────────────────────────────────────┘\n', ' */\n', '\n', ' library SafeMath {\n', '   function mul(uint a, uint b) internal pure  returns (uint) {\n', '     uint c = a * b;\n', '     require(a == 0 || c / a == b);\n', '     return c;\n', '   }\n', '   function div(uint a, uint b) internal pure returns (uint) {\n', '     require(b > 0);\n', '     uint c = a / b;\n', '     require(a == b * c + a % b);\n', '     return c;\n', '   }\n', '   function sub(uint a, uint b) internal pure returns (uint) {\n', '     require(b <= a);\n', '     return a - b;\n', '   }\n', '   function add(uint a, uint b) internal pure returns (uint) {\n', '     uint c = a + b;\n', '     require(c >= a);\n', '     return c;\n', '   }\n', '   function max64(uint64 a, uint64 b) internal  pure returns (uint64) {\n', '     return a >= b ? a : b;\n', '   }\n', '   function min64(uint64 a, uint64 b) internal  pure returns (uint64) {\n', '     return a < b ? a : b;\n', '   }\n', '   function max256(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '     return a >= b ? a : b;\n', '   }\n', '   function min256(uint256 a, uint256 b) internal  pure returns (uint256) {\n', '     return a < b ? a : b;\n', '   }\n', ' }\n', '\n', ' /**\n', '  * title KOL Promotion Withdraw contract\n', '  * dev visit: https://github.com/jackoelv/KOL/\n', ' */\n', '\n', ' contract ERC20Basic {\n', '   uint public totalSupply;\n', '   function balanceOf(address who) public constant returns (uint);\n', '   function transfer(address to, uint value) public;\n', '   event Transfer(address indexed from, address indexed to, uint value);\n', ' }\n', '\n', ' contract ERC20 is ERC20Basic {\n', '   function allowance(address owner, address spender) public constant returns (uint);\n', '   function transferFrom(address from, address to, uint value) public;\n', '   function approve(address spender, uint value) public;\n', '   event Approval(address indexed owner, address indexed spender, uint value);\n', ' }\n', '\n', ' /**\n', '  * title KOL Promotion Withdraw contract\n', '  * dev visit: https://github.com/jackoelv/KOL/\n', ' */\n', '\n', ' contract BasicToken is ERC20Basic {\n', '\n', '   using SafeMath for uint;\n', '\n', '   mapping(address => uint) balances;\n', '\n', '   function transfer(address _to, uint _value) public{\n', '     balances[msg.sender] = balances[msg.sender].sub(_value);\n', '     balances[_to] = balances[_to].add(_value);\n', '     emit Transfer(msg.sender, _to, _value);\n', '   }\n', '\n', '   function balanceOf(address _owner) public constant returns (uint balance) {\n', '     return balances[_owner];\n', '   }\n', ' }\n', '\n', ' /**\n', '  * title KOL Promotion Withdraw contract\n', '  * dev visit: https://github.com/jackoelv/KOL/\n', ' */\n', '\n', ' contract StandardToken is BasicToken, ERC20 {\n', '   mapping (address => mapping (address => uint)) allowed;\n', '   uint256 public userSupplyed;\n', '\n', '   function transferFrom(address _from, address _to, uint _value) public {\n', '     balances[_to] = balances[_to].add(_value);\n', '     balances[_from] = balances[_from].sub(_value);\n', '     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '     emit Transfer(_from, _to, _value);\n', '   }\n', '\n', '   function approve(address _spender, uint _value) public{\n', '     require((_value == 0) || (allowed[msg.sender][_spender] == 0)) ;\n', '     allowed[msg.sender][_spender] = _value;\n', '     emit Approval(msg.sender, _spender, _value);\n', '   }\n', '\n', '   function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '     return allowed[_owner][_spender];\n', '   }\n', ' }\n', ' contract KOL is StandardToken {\n', '   function queryNode(address _addr) public view returns(bool);\n', '   function querySuperNode(address _addr) public view returns(bool);\n', ' }\n', ' contract KOLP is StandardToken {\n', '\n', '   address public draw;\n', '   bool public going;\n', '   struct lock{\n', '     uint256 begin;\n', '     uint256 amount;\n', '     uint256 end;\n', '     bool withDrawed;\n', '   }\n', '   struct teamRate{\n', '     uint8 rate;\n', '     uint256 changeTime;\n', '\n', '   }\n', '   struct inviteBonus{\n', '     uint256 begin;\n', '     uint256 dayBonus;\n', '     uint256 hisTotalBonus;\n', '   }\n', '   struct withDraws{\n', '     uint256 time;\n', '     uint256 amount;\n', '   }\n', '   struct dayTeamBonus{\n', '     uint256 theDayLastSecond;\n', '     uint256 theDayTeamBonus;\n', '     uint256 totalTeamBonus;\n', '     uint8 theDayRate;\n', '   }\n', '   struct dayInviteBonus{\n', '     uint256 theDayLastSecond;\n', '     uint256 theDayInviteBonus;\n', '     uint256 totalInviteBonus;\n', '   }\n', '   mapping (address => dayTeamBonus[]) public LockTeamBonus;\n', '   mapping (address => dayInviteBonus[]) public LockInviteBonus;\n', '\n', '\n', '   mapping (address => address[]) public InviteList;\n', '   mapping (address => address[]) public ChildAddrs;\n', '   mapping (address => lock[]) public LockHistory;\n', '   mapping (address => uint256) public LockBalance;\n', '\n', '   mapping (address => uint256) public InviteHistoryBonus;\n', '   mapping (address => uint256) public InviteCurrentDayBonus;\n', '\n', '   mapping (uint256 => uint256) public ClosePrice;\n', '   mapping (address => uint256) public TotalUsers;\n', '   mapping (address => uint256) public TotalLockingAmount;\n', '   mapping (uint256 => address) public InviteCode;\n', '   mapping (address => uint256) public RInviteCode;\n', '\n', '   mapping (address => uint8) public isLevelN;\n', '   mapping (uint8 => uint8) public levelRate;\n', '   mapping (address => bool) public USDTOrCoin;\n', '\n', '   //GAS优化\n', '   modifier onlyContract {\n', '       require(msg.sender == draw);\n', '       _;\n', '   }\n', '   function qsLevel(address _addr) onlyContract public ;\n', '   /* function queryAndSetLevelN(address _addr) public; */\n', '   function queryLockBalance(address _addr,uint256 _queryTime) public view returns(uint256);\n', '   function getYestodayLastSecond(uint256 _queryTime) public view returns(uint256);\n', '   function clearLock(address _addr) onlyContract public ;\n', '   function pushInvite(address _addr,\n', '                       uint256 _theDayLastSecond,\n', '                       uint256 _theDayInviteBonus,\n', '                       uint256 _totalInviteBonus) onlyContract public ;\n', '   function setLastInvite(address _addr,\n', '                       uint256 _theDayInviteBonus,\n', '                       uint256 _totalInviteBonus) onlyContract public ;\n', '   function pushTeam(address _addr,\n', '                       uint256 _theDayLastSecond,\n', '                       uint256 _theDayTeamBonus,\n', '                       uint256 _totalTeamBonus,\n', '                       uint8 _theDayRate) onlyContract public ;\n', '   function setLastTeam(address _addr,\n', '                       uint256 _theDayTeamBonus,\n', '                       uint256 _totalTeamBonus,\n', '                       uint8 _theDayRate) onlyContract public ;\n', '\n', '   function subTotalUsers(address _addr) onlyContract public ;\n', '   function subTotalLockingAmount(address _addr,uint256 _amount) onlyContract public ;\n', '   function subTotalBalance(uint256 _amount) onlyContract public ;\n', '   function setInviteTeam(address _addr) onlyContract public ;\n', '   function getLockLen(address _addr) public view returns(uint256);\n', '   function getFathersLength(address _addr) public view returns(uint256);\n', '   function getLockTeamBonusLen(address _addr) public view returns(uint256);\n', '   function getLockInviteBonusLen(address _addr) public view returns(uint256);\n', '\n', '}\n', '\n', ' /**\n', '  * title KOL Promotion Withdraw contract\n', '  * dev visit: https://github.com/jackoelv/KOL/\n', ' */\n', '\n', ' contract Ownable {\n', '     address public owner;\n', '\n', '     constructor() public{\n', '         owner = msg.sender;\n', '     }\n', '\n', '     modifier onlyOwner {\n', '         require(msg.sender == owner);\n', '         _;\n', '     }\n', '     function transferOwnership(address newOwner) onlyOwner public{\n', '         if (newOwner != address(0)) {\n', '             owner = newOwner;\n', '         }\n', '     }\n', ' }\n', ' /**\n', '  * title KOL Promotion Withdraw contract\n', '  * dev visit: https://github.com/jackoelv/KOL/\n', ' */\n', 'contract KOLWithDraw is Ownable{\n', '  using SafeMath for uint256;\n', '  string public name = "KOL Withdraw";\n', '  KOL public kol;\n', '  KOLP public kolp;\n', '\n', '  uint256 public every = 1 days;\n', '  uint256 public minBonus = 30 * (10 ** 18);\n', '  uint256 public leftBonus = 0;\n', '  address public reciever;\n', '  uint256 public etherFee = 0.005 ether;\n', '  uint8 public fee = 5;\n', '\n', '\n', '  struct dayTeamBonus{\n', '    uint256 theDayLastSecond;\n', '    uint256 theDayTeamBonus;\n', '    uint256 totalTeamBonus;\n', '    uint8 theDayRate;\n', '  }\n', '  struct dayInviteBonus{\n', '    uint256 theDayLastSecond;\n', '    uint256 theDayInviteBonus;\n', '    uint256 totalInviteBonus;\n', '  }\n', '\n', '  mapping (address => uint256) public TotalWithDraws;\n', '\n', '  mapping (address => uint256) public DrawTime;\n', '  event WithDrawed(address _user,uint256 _amount);\n', '\n', '  constructor(address _kolAddress,address _kolpAddress,address _reciever) public {\n', '    kol = KOL(_kolAddress);\n', '    kolp = KOLP(_kolpAddress);\n', '    reciever = _reciever;\n', '  }\n', '\n', '  function querySelfBonus(address _addr) public view returns(uint256){\n', '    uint256 len = kolp.getLockLen(_addr);\n', '    uint256 selfBonus;\n', '    if(len >0){\n', '      uint256 begin;\n', '      uint256 end;\n', '      uint256 amount;\n', '      bool withDrawed;\n', '      for (uint i=0; i<len; i++){\n', '        (begin,amount,end,withDrawed) = kolp.LockHistory(_addr,i);\n', '        if (!withDrawed){\n', '          if (DrawTime[_addr] > begin) begin = DrawTime[_addr];\n', '          uint256 lastingDays = (kolp.getYestodayLastSecond(now) - kolp.getYestodayLastSecond(begin)) / every;\n', '          if (kolp.USDTOrCoin(_addr)){\n', '            begin = kolp.getYestodayLastSecond(begin) + every;\n', '            for (uint j=0;j<lastingDays;j++){\n', '              uint256 theTime = begin + j*every;\n', '              selfBonus += amount * 3 / 1000 * kolp.ClosePrice(begin) / kolp.ClosePrice(theTime);\n', '            }\n', '          }else{\n', '            selfBonus += lastingDays * amount * 3 / 1000;\n', '          }\n', '        }\n', '      }\n', '    }\n', '    return (selfBonus);\n', '\n', '  }\n', '\n', '  function queryInviteBonus(address _addr) public view returns(uint256){\n', '    uint256 last = kolp.getLockInviteBonusLen(_addr);\n', '    if(last>0){\n', '      uint256 yestodayLastSecond = kolp.getYestodayLastSecond(now);\n', '      uint256 lastingDays;\n', '      uint256 newDayInviteTotalBonus;\n', '      dayInviteBonus memory theDayIB = dayInviteBonus(0,0,0);\n', '      while(last>=1){\n', '        (theDayIB.theDayLastSecond,theDayIB.theDayInviteBonus,theDayIB.totalInviteBonus) = kolp.LockInviteBonus(_addr,last-1);\n', '        last--;\n', '        if (theDayIB.theDayLastSecond <= yestodayLastSecond){\n', '          lastingDays = (yestodayLastSecond - theDayIB.theDayLastSecond) / every;\n', '          newDayInviteTotalBonus = (lastingDays * theDayIB.theDayInviteBonus) + theDayIB.totalInviteBonus;\n', '          return (newDayInviteTotalBonus);\n', '        }\n', '      }\n', '      return 0;\n', '    }else\n', '      return 0;\n', '  }\n', '  function queryTeamBonus(address _addr) public view returns(uint256){\n', '    uint256 last = kolp.getLockTeamBonusLen(_addr);\n', '    if(last>0){\n', '      uint256 yestodayLastSecond = kolp.getYestodayLastSecond(now);\n', '      uint256 lastingDays;\n', '      uint256 newDayTeamTotalBonus;\n', '      dayTeamBonus memory theDayTB =dayTeamBonus(0,0,0,0);\n', '      while(last>=1){\n', '        (theDayTB.theDayLastSecond,theDayTB.theDayTeamBonus,theDayTB.totalTeamBonus,theDayTB.theDayRate) = kolp.LockTeamBonus(_addr,last-1);\n', '        last--;\n', '        if (theDayTB.theDayLastSecond <= yestodayLastSecond){\n', '          lastingDays = (yestodayLastSecond - theDayTB.theDayLastSecond) / every;\n', '          newDayTeamTotalBonus = (lastingDays * theDayTB.theDayTeamBonus * theDayTB.theDayRate / 100 ) + theDayTB.totalTeamBonus;\n', '          return (newDayTeamTotalBonus);\n', '        }\n', '      }\n', '      return 0;\n', '    }else\n', '      return 0;\n', '\n', '  }\n', '  function afterWithdraw(address _addr,uint256 _amount) private {\n', '    address father;\n', '    uint256 fathersLen = kolp.getFathersLength(_addr);\n', '    for (uint i = 0; i<fathersLen; i++){\n', '      father = kolp.InviteList(_addr,i);\n', '      kolp.subTotalUsers(father);\n', '      kolp.subTotalLockingAmount(father,_amount);\n', '      kolp.qsLevel(father);\n', '      kolp.setInviteTeam(_addr);\n', '    }\n', '\n', '  }\n', '  function withdraw(bool _onlyBonus) payable public{\n', '    //true: bonus;false:balance & bonus;\n', '    require(msg.value >= etherFee);\n', '    uint256 bonus = querySelfBonus(msg.sender);\n', '    DrawTime[msg.sender] = now;\n', '    uint256 last = kolp.getLockInviteBonusLen(msg.sender);\n', '    uint256 yestodayLastSecond = kolp.getYestodayLastSecond(now);\n', '    uint256 lastingDays;\n', '\n', '    if(last>0){\n', '      dayInviteBonus memory theDayIB = dayInviteBonus(0,0,0);\n', '      uint256 realLast = last;\n', '      while(realLast>=1){\n', '        (theDayIB.theDayLastSecond,theDayIB.theDayInviteBonus,theDayIB.totalInviteBonus) = kolp.LockInviteBonus(msg.sender,realLast-1);\n', '        realLast--;\n', '        if (theDayIB.theDayLastSecond <= yestodayLastSecond){\n', '          lastingDays = (yestodayLastSecond - theDayIB.theDayLastSecond) / every;\n', '          bonus += (lastingDays * theDayIB.theDayInviteBonus) + theDayIB.totalInviteBonus;\n', '          if(theDayIB.theDayLastSecond < yestodayLastSecond){\n', '            kolp.pushInvite(msg.sender,yestodayLastSecond,theDayIB.theDayInviteBonus,0);\n', '          }else if(theDayIB.theDayLastSecond == yestodayLastSecond){\n', '            kolp.setLastInvite(msg.sender,theDayIB.theDayInviteBonus,0);\n', '          }\n', '        }\n', '      }\n', '    }\n', '\n', '    last = kolp.getLockTeamBonusLen(msg.sender);\n', '\n', '    if(last>0){\n', '      dayTeamBonus memory theDayTB =dayTeamBonus(0,0,0,0);\n', '      while(last>=1){\n', '        (theDayTB.theDayLastSecond,theDayTB.theDayTeamBonus,theDayTB.totalTeamBonus,theDayTB.theDayRate) = kolp.LockTeamBonus(msg.sender,last-1);\n', '        last--;\n', '        if (theDayTB.theDayLastSecond <= yestodayLastSecond){\n', '          lastingDays = (yestodayLastSecond - theDayTB.theDayLastSecond) / every;\n', '          bonus += (lastingDays * theDayTB.theDayTeamBonus * theDayTB.theDayRate / 100 ) + theDayTB.totalTeamBonus;\n', '          if(theDayTB.theDayLastSecond < yestodayLastSecond){\n', '            kolp.pushTeam(msg.sender,yestodayLastSecond,theDayTB.theDayTeamBonus,0,theDayTB.theDayRate);\n', '          }else if(theDayTB.theDayLastSecond == yestodayLastSecond){\n', '            kolp.setLastTeam(msg.sender,theDayTB.theDayTeamBonus,0,theDayTB.theDayRate);\n', '          }\n', '        }\n', '      }\n', '\n', '    }\n', '    uint256 realBonus = bonus;\n', '    if (leftBonus == 0){\n', '      _onlyBonus = false;\n', '      realBonus =0;\n', '    }else if(bonus >= leftBonus){\n', '      realBonus = leftBonus;\n', '    }\n', '    uint256 subLeft = realBonus;\n', '    /* leftBonus = leftBonus.sub(realBonus); */\n', '    uint256 tax = realBonus*fee/100;\n', '    realBonus = realBonus.sub(tax);\n', '\n', '    if (!_onlyBonus){\n', '      uint256 balance = kolp.LockBalance(msg.sender);\n', '      if (bonus < minBonus){\n', '        realBonus = balance;\n', '        tax = 0;\n', '        subLeft = 0;\n', '      }else{\n', '        realBonus += balance;\n', '      }\n', '      kolp.subTotalBalance(balance);\n', '      kolp.clearLock(msg.sender);\n', '      afterWithdraw(msg.sender,balance);\n', '\n', '    }else{\n', '      require(bonus >= minBonus);\n', '    }\n', '    if (realBonus > 0) {\n', '      kol.transfer(msg.sender,realBonus);\n', '      TotalWithDraws[msg.sender] += realBonus;\n', '      emit WithDrawed(msg.sender,realBonus);\n', '    }\n', '    if (tax > 0) kol.transfer(reciever,tax);\n', '    leftBonus = leftBonus.sub(subLeft);\n', '\n', '  }\n', '  function calcuAllBonus(bool _onlyBonus) public view returns(uint256){\n', '    //true: Only Bonus;false: balance & bonus;\n', '    uint256 bonus = querySelfBonus(msg.sender);\n', '    bonus += queryInviteBonus(msg.sender);\n', '    bonus += queryTeamBonus(msg.sender);\n', '    if (leftBonus == 0){\n', '      bonus =0;\n', '    }else if(bonus >= leftBonus){\n', '      bonus = leftBonus;\n', '    }\n', '    bonus = bonus * (100-fee) /100;\n', '\n', '    if (!_onlyBonus){\n', '      uint256 balance = kolp.LockBalance(msg.sender);\n', '      bonus += balance;\n', '    }\n', '    return bonus;\n', '  }\n', '  function addBonus(uint256 _amount) onlyOwner public{\n', '    leftBonus = leftBonus.add(_amount);\n', '  }\n', '  function setFee(uint8 _fee) onlyOwner public{\n', '    fee = _fee;\n', '  }\n', '  function setKOLP(address _paddr) onlyOwner public{\n', '    kolp = KOLP(_paddr);\n', '  }\n', '  function draw() onlyOwner public{\n', '    reciever.send(address(this).balance);\n', '  }\n', '  function setetherFee(uint256 _fee) onlyOwner public{\n', '    etherFee = _fee;\n', '  }\n', '  function setReciever(address _reciever) onlyOwner public{\n', '    reciever = _reciever;\n', '  }\n', '}']