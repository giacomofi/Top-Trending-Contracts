['/*\n', '/ _\\_ __ ___   __ _ _ __| |_/ / /\\ \\ \\___ | |_   _____  ___\n', "\\ \\| '_ ` _ \\ / _` | '__| __\\ \\/  \\/ / _ \\| \\ \\ / / _ \\/ __|\n", '_\\ \\ | | | | | (_| | |  | |_ \\  /\\  / (_) | |\\ V /  __/\\__ \\\n', '\\__/_| |_| |_|\\__,_|_|   \\__| \\/  \\/ \\___/|_| \\_/ \\___||___/\n', '*/\n', '\n', '// SPDX-License-Identifier: Unlicensed\n', '\n', 'pragma solidity >= 0.6.12;\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract SmartWolves {\n', '    using SafeMath for uint;\n', '\n', '    uint status;\n', '\n', '    uint registrationFee;\n', '\n', '    address payable public companyAccount;\n', '\n', '    event Enrolled(\n', '        uint8 indexed pool,\n', '        address indexed payerAddress,\n', '        string indexed username,\n', '        uint amount\n', '    );\n', '\n', '    event PoolPurchased(\n', '        uint8 indexed pool,\n', '        address indexed payerAddress,\n', '        uint amount,\n', '        string indexed username\n', '    );\n', '\n', '    event PayoutSuccess(\n', '        address indexed payee,\n', '        string indexed username,\n', '        uint amount\n', '    );\n', '\n', '    event NewDeposit(\n', '        address indexed payer,\n', '        uint amount\n', '    );\n', '\n', '    event CompanyAccountChanged(\n', '        address indexed oldAccount,\n', '        address indexed newAccount\n', '    );\n', '\n', '    struct User {\n', '        bool status;\n', '        uint8 pool;\n', '        address paymentAddress;\n', '        string userName;\n', '    }\n', '\n', '    mapping(uint8 => uint) public pools;\n', '\n', '    mapping(string => User) public users;\n', '\n', '    constructor(uint _registrationFee) public {\n', '        registrationFee = _registrationFee;\n', '        companyAccount = msg.sender;\n', '\n', '        pools[1] = 50000000000000000;\n', '        pools[2] = 200000000000000000;\n', '        pools[3] = 500000000000000000;\n', '        pools[4] = 1000000000000000000;\n', '        pools[5] = 2000000000000000000;\n', '        pools[6] = 5000000000000000000;\n', '        pools[7] = 10000000000000000000;\n', '        pools[8] = 20000000000000000000;\n', '        pools[9] = 30000000000000000000;\n', '        pools[10] = 50000000000000000000;\n', '        pools[11] = 100000000000000000000;\n', '    }\n', '\n', '    modifier onlyOwner(){\n', "        require(msg.sender == companyAccount, 'Sorry this can be only by the admin account!');\n", '        _;\n', '    }\n', '\n', '    modifier noContract(address _address){\n', "        require(!isContract(_address), 'Payment to a contract is not allowed!');\n", '        _;\n', '    }\n', '\n', '    modifier notEnrolledAlready(string memory _username){\n', "        require(users[_username].status == false, 'You seems like have been enrolled already!');\n", '        _;\n', '    }\n', '\n', '    function enrol(string calldata _username, uint8 _pool) external payable notEnrolledAlready(_username) {\n', "        require(msg.value >= pools[_pool].add(registrationFee), 'Please send the correct amount!');\n", '\n', '        depositAmount(companyAccount, msg.value);\n', '        // Enrol user\n', '        users[_username] = User(true, _pool, msg.sender, _username);\n', '        // Emit event telling that there is a new enrolment\n', '        emit Enrolled(_pool, msg.sender, _username, msg.value);\n', '    }\n', '\n', '    function withdrawToUserAccount(address _userAddress, string calldata __userName, uint _amount) external payable onlyOwner noContract(_userAddress) {\n', '        depositAmount(_userAddress, _amount);\n', '        // Emit success payout event\n', '        emit PayoutSuccess(_userAddress, __userName, _amount);\n', '    }\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {size := extcodesize(account)}\n', '        return size > 0;\n', '    }\n', '\n', '    function depositAmount(address _user, uint256 _amount) internal {\n', '        require(address(this).balance >= _amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success,) = _user.call{value : _amount}("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    function changeCompanyAccount(address payable _newAccount) external onlyOwner {\n', '        address oldAccount = companyAccount;\n', '        companyAccount = _newAccount;\n', '        emit CompanyAccountChanged(oldAccount, _newAccount);\n', '    }\n', '\n', '    function purchasePool(string calldata _username, uint8 _pool) external payable noContract(msg.sender) {\n', "        require(msg.value >= pools[_pool], 'Please send the correct pool upgrade amount!');\n", '\n', '        depositAmount(companyAccount, msg.value);\n', '        User storage user = users[_username];\n', '        user.pool = _pool;\n', '        // emit pool purchase event\n', '        emit PoolPurchased(_pool, msg.sender, msg.value, _username);\n', '    }\n', '\n', '    receive() external payable {\n', '        emit NewDeposit(msg.sender, msg.value);\n', '    }\n', '\n', '    fallback() external payable {\n', '        emit NewDeposit(msg.sender, msg.value);\n', '    }\n', '}']