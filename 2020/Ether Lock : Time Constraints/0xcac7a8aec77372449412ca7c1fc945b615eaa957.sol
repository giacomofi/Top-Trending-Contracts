['// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.4.21 <0.7.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '//...................................................................................\n', '\n', 'abstract contract ERC20Basic {\n', '  function totalSupply() public virtual view returns (uint256);\n', '  function balanceOf(address who) public virtual view returns (uint256);\n', '  function transfer(address to, uint256 value) public virtual returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', '//..............................................................................................\n', '\n', 'abstract contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public virtual view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\n', '  function approve(address spender, uint256 value) public virtual returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '//..................................................................................................\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  uint256 totalSupply_;\n', '\n', '  /**\n', '  * @dev total number of tokens in existence\n', '  */\n', '  function totalSupply() public override view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '   \n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public override returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public  override view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '//........................................................................................\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    balances[_from] = balances[_from].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public override returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) public override view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To increment\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n', '    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * approve should be called when allowed[_spender] == 0. To decrement\n', '   * allowed value is better to use this function to avoid 2 calls (and wait until\n', '   * the first transaction is mined)\n', '   * From MonolithDAO Token.sol\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n', '    uint oldValue = allowed[msg.sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      allowed[msg.sender][_spender] = 0;\n', '    } else {\n', '      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '    return true;\n', '  }\n', '\n', '}\n', '//....................................................................................\n', '\n', 'contract YexToken is StandardToken {\n', '  address public administrator;\n', '  string public constant name = "Yolex.io";\n', '  string public constant symbol = "YEX";\n', '  uint public constant decimals = 18;\n', '  uint256 public constant INITIAL_SUPPLY = 100 * (10 ** decimals);\n', '\n', '\n', '   modifier onlyAdminstrator(){\n', '     require(administrator == msg.sender, "requires admin priviledge");\n', '     _;\n', '   }\n', '\n', '}\n', '\n', '\n', 'contract TokenStakingReward is YexToken {\n', '   address public yolexController;\n', '   mapping(string => RewardPackage) public rewardPackages;\n', '   MintedTokensRecord[] public tokenMintsRecord;\n', '   mapping(address => Staker) public stackers;\n', '   RewardPackage[] public listOfPackages;\n', '   uint public salePrice = 5 ether;\n', '   uint public presaleCount = 0;\n', '   string prePackage = "PRESALE";\n', '   \n', '   \n', '   constructor() public {\n', '    totalSupply_ = INITIAL_SUPPLY;\n', '    administrator = msg.sender;\n', '    balances[administrator] = INITIAL_SUPPLY;\n', '  }\n', '   \n', '   \n', '\n', '   modifier onlyController(){\n', '     require(\n', '     administrator == msg.sender || \n', '     yolexController == msg.sender,\n', '     "requires controller or admin priviledge");\n', '     _;\n', '   }\n', '  \n', '\n', '   event AdminChange (\n', '       string indexed message,\n', '       address indexed newAdminAddress\n', '   );\n', '   \n', '   \n', '   struct MintedTokensRecord {\n', '      uint amount;\n', '      uint timeStamp;\n', '   }\n', '\n', '   struct RewardPackage {\n', '      uint id;\n', '      string symbol;\n', '      string packageName;\n', '      string rebasePercent;\n', '      string rewardPercent;\n', '      uint256 durationInDays;\n', '      uint256 rewardCapPercent;\n', '      bool isActive;\n', '   }\n', '\n', '\n', '   struct Staker {\n', '      uint id;\n', '      address stakerAddress;\n', '      uint256 amountStaked;\n', '      bool isActive;\n', '      bool isMatured;\n', '      uint256 startDate;\n', '      uint256 endDate;\n', '      string stakingPackage;\n', '      uint256 rewards;\n', '      uint256 rewardCap;\n', '      string rewardPercent;\n', '      uint256 rewardCapPercent;\n', '   }\n', '\n', '   struct Rewards {\n', '      address stakerAddress;\n', '      uint256 reward;\n', '      bool isMatured;\n', '   }\n', '   \n', '   address newAdminAddress;\n', '   address newControllerAddress;\n', '   \n', '   function changeRate(uint _newRate) external onlyAdminstrator returns(bool){\n', '       salePrice = _newRate;\n', '       return true;\n', '   }\n', '\n', ' \n', '   function assignNewAdministrator(address _newAdminAddress) external onlyAdminstrator {\n', '     newAdminAddress = _newAdminAddress;\n', '     emit AdminChange("confirming new Adminstrator address", newAdminAddress);\n', '   }\n', '\n', '\n', '   function acceptAdminRights() external {\n', '     require(msg.sender == newAdminAddress, "new admistrator address mismatch");\n', '     uint256 _value = balances[administrator];\n', '     balances[administrator] = balances[administrator].sub(_value);\n', '     balances[newAdminAddress] = balances[newAdminAddress].add(_value);\n', '     administrator = newAdminAddress;\n', '     emit AdminChange("New Adminstrator address", administrator);\n', '   }\n', '\n', '\n', '   function assignNewController(address _newControllerAddress) external onlyAdminstrator {\n', '     newControllerAddress = _newControllerAddress;\n', '     emit AdminChange("confirming new controller address", newControllerAddress);\n', '   }\n', '\n', '\n', '   function acceptControllerRights() external {\n', '     require(msg.sender == newControllerAddress, "new controller address mismatch");\n', '     yolexController = newControllerAddress;\n', '     emit AdminChange("New controller address", yolexController);\n', '   }\n', '\n', '   function presale() external payable {\n', '       require(msg.value >= salePrice, "sent eth too small");\n', '       require(presaleCount < 45, "presale closed.");\n', '       uint _amount = msg.value.div(salePrice);\n', '       uint _amountToken = _amount.mul(10 ** decimals);\n', '       balances[administrator] = balances[administrator].sub(_amountToken);\n', '       balances[msg.sender] = balances[msg.sender].add(_amountToken);\n', '       presaleCount = presaleCount.add(_amount);\n', '       createStaking(_amountToken, prePackage);\n', '   }\n', '\n', '   uint stakingID;\n', '   uint packageID;\n', '   function createStaking(uint256 _amount,\n', '     string memory _packageSymbol\n', '   )\n', '   public returns(Staker memory) {\n', '       RewardPackage memory _package = rewardPackages[_packageSymbol];\n', '       require(_amount <= balances[msg.sender], "insuffient funds");\n', '       require(!stackers[msg.sender].isActive, "You already have an active stake");\n', '       require(_package.isActive, "You can only stake on a active reward package");\n', '       uint256 _rewardCap = _amount.mul(_package.rewardCapPercent).div(100);\n', '       uint256 _endDate = numberDaysToTimestamp(_package.durationInDays);\n', '       transfer(address(this), _amount);\n', '       Staker memory _staker = Staker(stakingID, msg.sender, _amount, true, false, now, _endDate, _packageSymbol, 0, _rewardCap, _package.rewardPercent, _package.rewardCapPercent);\n', '       stakingID++;\n', '       stackers[msg.sender] = _staker;\n', '       return _staker;\n', '   }\n', '   \n', '\n', '   function unstake() external returns(bool success){\n', '     Staker memory _staker = stackers[msg.sender];\n', '     require(_staker.endDate <= now, "cannot unstake yet");\n', '     require(_staker.isMatured, "reward is not matured for withdrawal");\n', '     require(_staker.isActive, "staking should still be active");\n', '     uint256 _amount = _staker.amountStaked;\n', '     balances[address(this)] = balances[address(this)].sub(_amount);\n', '     uint256 totalRewards = _amount.add(_staker.rewards);\n', '     balances[msg.sender] = balances[msg.sender].add(totalRewards);\n', '     stackers[msg.sender].isActive = false;\n', '     mintTokens(_staker.rewards);\n', '     emit Transfer(address(this), msg.sender, totalRewards);\n', '     return true;\n', '   }\n', ' \n', ' \n', '\n', '   function distributeStakingRewards(Rewards[] calldata _rewards) external onlyController returns(bool){\n', '      for (uint index = 0; index < _rewards.length; index++) {\n', '          uint totalRewards = stackers[_rewards[index].stakerAddress].rewards.add(_rewards[index].reward);\n', '          if (stackers[_rewards[index].stakerAddress].isActive == true &&\n', '               totalRewards <= stackers[_rewards[index].stakerAddress].rewardCap) {\n', '               stackers[_rewards[index].stakerAddress].rewards = totalRewards;\n', '               if(_rewards[index].isMatured){\n', '                   indicateMaturity(_rewards[index].stakerAddress, _rewards[index].isMatured);\n', '               }\n', '          }\n', '      }\n', '      return true;\n', '   }\n', '    \n', ' \n', '    function indicateMaturity(address _accountAddress, bool status) internal  returns(bool success) {\n', '       require(_accountAddress != address(0), "the stacker address is needed");\n', '       stackers[_accountAddress].isMatured = status;\n', '       return true;\n', '    }\n', '    \n', '\n', '\n', '   function createPackage(\n', '     string memory _packageName,\n', '     string memory _symbol,\n', '     string memory _rebasePercent,\n', '     string memory _rewardPercent,\n', '     uint256 _rewardCapPercent,\n', '     uint256 _durationInDays\n', '     )\n', '   public onlyController returns(RewardPackage memory) {\n', '       numberDaysToTimestamp(_durationInDays);\n', '       RewardPackage memory _package = RewardPackage(\n', '         packageID,\n', '         _symbol,\n', '         _packageName,\n', '         _rebasePercent,\n', '         _rewardPercent,\n', '         _durationInDays,\n', '         _rewardCapPercent,\n', '         true\n', '         );\n', '         if (rewardPackages[_symbol].isActive) {\n', '             revert("package symbol should be unique");\n', '            } else {\n', '              packageID++;\n', '              rewardPackages[_symbol] = _package;\n', '              listOfPackages.push(_package);\n', '              return _package;\n', '          }\n', '   }\n', '   \n', '\n', '   function numberDaysToTimestamp (uint _numberOfDays) private view returns(uint256 time){\n', '        if (_numberOfDays == 3) {\n', '             return now + 4 days;\n', '        } else if(_numberOfDays == 7){\n', '            return now.add(8 days);\n', '        }else if(_numberOfDays == 30){\n', '            return now.add(31 days);\n', '        }else if(_numberOfDays == 60){\n', '            return now.add(61 days);\n', '        }else if(_numberOfDays == 90){\n', '            return now.add(91 days);\n', '        }else if(_numberOfDays == 180){\n', '            return now.add(181 days);\n', '        }\n', '        else {\n', '          revert("The number of days should be either 3, 7, 30, 60 90, or 180 days");\n', '        }\n', '    }\n', '   \n', '\n', '    function increaseStakingAmount(uint _amount) external returns(bool success){\n', '       require(stackers[msg.sender].isActive, "should have an active stake");\n', '       transfer(address(this), _amount);\n', '       stackers[msg.sender].amountStaked = stackers[msg.sender].amountStaked.add(_amount);\n', '       uint256 _amountStaked = stackers[msg.sender].amountStaked;\n', '       uint256 _rewardCap = _amountStaked.mul(stackers[msg.sender].rewardCapPercent).div(100);\n', '       stackers[msg.sender].rewardCap = _rewardCap;\n', '       return true;\n', '    }\n', '\n', '\n', '    function deactivatePackage(string calldata _symbol) external onlyController returns(RewardPackage memory){\n', '       bytes memory strToByte = bytes(_symbol);\n', '       require(strToByte.length > 1, "The package symbol should be specified");\n', '       rewardPackages[_symbol].isActive = false;\n', '       listOfPackages[rewardPackages[_symbol].id].isActive = false;\n', '       return rewardPackages[_symbol];\n', '    }\n', '    \n', '    function mintTokens(uint256 _amount) private returns(bool, uint) { \n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        tokenMintsRecord.push(MintedTokensRecord(_amount, now));\n', '        return(true, totalSupply_);\n', '    }\n', '    \n', '    function updatePrePackage(string calldata _packageSymbol) external onlyAdminstrator {\n', '        prePackage = _packageSymbol;\n', '    }\n', '    \n', '    function transferToWallet(uint _amount, address payable _receipient) external onlyAdminstrator returns(bool){\n', '        _receipient.transfer(_amount);\n', '        return true;\n', '     }\n', '    \n', '    receive() payable external {}\n', '}']