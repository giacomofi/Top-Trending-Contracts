['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', 'library Date {\n', '    struct _Date {\n', '        uint16 year;\n', '        uint8 month;\n', '        uint8 day;\n', '    }\n', '\n', '    uint constant DAY_IN_SECONDS = 86400;\n', '    uint constant YEAR_IN_SECONDS = 31536000;\n', '    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '    uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '    function isLeapYear(uint16 year) public pure returns (bool) {\n', '        if (year % 4 != 0) {\n', '                return false;\n', '        }\n', '        if (year % 100 != 0) {\n', '                return true;\n', '        }\n', '        if (year % 400 != 0) {\n', '                return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function leapYearsBefore(uint year) public pure returns (uint) {\n', '        year -= 1;\n', '        return year / 4 - year / 100 + year / 400;\n', '    }\n', '\n', '    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n', '        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '                return 31;\n', '        }\n', '        else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '                return 30;\n', '        }\n', '        else if (isLeapYear(year)) {\n', '                return 29;\n', '        }\n', '        else {\n', '                return 28;\n', '        }\n', '    }\n', '\n', '    function parseTimestamp(uint timestamp) internal pure returns (_Date memory dt) {\n', '        uint secondsAccountedFor = 0;\n', '        uint buf;\n', '        uint8 i;\n', '\n', '        // Year\n', '        dt.year = getYear(timestamp);\n', '        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '        // Month\n', '        uint secondsInMonth;\n', '        for (i = 1; i <= 12; i++) {\n', '                secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '                if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                        dt.month = i;\n', '                        break;\n', '                }\n', '                secondsAccountedFor += secondsInMonth;\n', '        }\n', '\n', '        // Day\n', '        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '                if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                        dt.day = i;\n', '                        break;\n', '                }\n', '                secondsAccountedFor += DAY_IN_SECONDS;\n', '        }\n', '    }\n', '\n', '    function getYear(uint timestamp) public pure returns (uint16) {\n', '        uint secondsAccountedFor = 0;\n', '        uint16 year;\n', '        uint numLeapYears;\n', '\n', '        // Year\n', '        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '        while (secondsAccountedFor > timestamp) {\n', '                if (isLeapYear(uint16(year - 1))) {\n', '                        secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '                }\n', '                else {\n', '                        secondsAccountedFor -= YEAR_IN_SECONDS;\n', '                }\n', '                year -= 1;\n', '        }\n', '        return year;\n', '    }\n', '\n', '    function getMonth(uint timestamp) public pure returns (uint8) {\n', '        return parseTimestamp(timestamp).month;\n', '    }\n', '\n', '    function getDay(uint timestamp) public pure returns (uint8) {\n', '        return parseTimestamp(timestamp).day;\n', '    }\n', '\n', '    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n', '        uint16 i;\n', '\n', '        // Year\n', '        for (i = ORIGIN_YEAR; i < year; i++) {\n', '                if (isLeapYear(i)) {\n', '                        timestamp += LEAP_YEAR_IN_SECONDS;\n', '                }\n', '                else {\n', '                        timestamp += YEAR_IN_SECONDS;\n', '                }\n', '        }\n', '\n', '        // Month\n', '        uint8[12] memory monthDayCounts;\n', '        monthDayCounts[0] = 31;\n', '        if (isLeapYear(year)) {\n', '                monthDayCounts[1] = 29;\n', '        }\n', '        else {\n', '                monthDayCounts[1] = 28;\n', '        }\n', '        monthDayCounts[2] = 31;\n', '        monthDayCounts[3] = 30;\n', '        monthDayCounts[4] = 31;\n', '        monthDayCounts[5] = 30;\n', '        monthDayCounts[6] = 31;\n', '        monthDayCounts[7] = 31;\n', '        monthDayCounts[8] = 30;\n', '        monthDayCounts[9] = 31;\n', '        monthDayCounts[10] = 30;\n', '        monthDayCounts[11] = 31;\n', '\n', '        for (i = 1; i < month; i++) {\n', '                timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '        }\n', '\n', '        // Day\n', '        timestamp += DAY_IN_SECONDS * (day - 1);\n', '\n', '        return timestamp;\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner || tx.origin == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract StakingPool is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    IERC20 token;\n', '    uint256 decimals = 18;\n', '    uint256 minimumStakeAmount = 1000;\n', '    address ZERO_ADDRESS = 0x0000000000000000000000000000000000000000;\n', '    address BURN_ADDRESS;\n', '\n', '    //Stats\n', '    uint256 public totalStakes = 0;\n', '    uint256 public totalStaked = 0;\n', '    uint256 public adminCanWithdraw = 0;\n', '    mapping(uint8 => uint256) public totalByLockup;\n', '    uint256 public totalCompounding = 0;\n', '    uint256 public totalNotCompounding = 0;\n', '\n', '    struct Stake {\n', '        bool exists;\n', '        uint256 createdOn;\n', '        uint256 initialAmount;\n', '        bool compound;\n', '        uint8 lockupPeriod;\n', '        uint256 withdrawn;\n', '        address referrer;\n', '    }\n', '    \n', '    mapping(address => Stake) public stakes;\n', '    \n', '    uint256 DEFAULT_ROI1 = 13; //0.13% daily ROI, equivalent to 4% monthly\n', '    uint256 DEFAULT_ROI2 = 15; //0.15% daily ROI\n', '    uint256 DEFAULT_ROI3 = 17; //0.17% daily ROI\n', '    uint256 DEFAULT_ROI6 = 19; //0.19% daily ROI\n', '    \n', '    bool isValidLockup1 = true;\n', '    bool isValidLockup2 = false;\n', '    bool isValidLockup3 = false;\n', '    bool isValidLockup6 = false;\n', '\n', '    struct ROI {\n', '        bool exists;\n', '        uint256 roi1;   \n', '        uint256 roi2;\n', '        uint256 roi3;\n', '        uint256 roi6;\n', '    }\n', '\n', '    //Year to Month to ROI\n', '    mapping (uint256 => mapping (uint256 => ROI)) private rois;\n', '    \n', '    event NewStake(address indexed staker, uint256 totalStaked, uint8 lockupPeriod, bool compound, address referrer);\n', '    event StakeIncreasedForReferral(address indexed staker, uint256 initialAmount, uint256 delta);\n', '    event RewardsWithdrawn(address indexed staker, uint256 total);\n', '    event StakeFinished(address indexed staker, uint256 totalReturned, uint256 totalDeducted);\n', '    event TokensBurnt(address indexed staker, uint256 totalBurnt);\n', '    \n', '    constructor(IERC20 _token, address _burnAddress) public {\n', '        token = _token;\n', '        BURN_ADDRESS = _burnAddress;\n', '    }\n', '    \n', '    function createStake(uint256 _amount, uint8 _lockupPeriod, bool _compound, address _referrer) public {\n', '        require(!stakes[msg.sender].exists, "You already have a stake");\n', '        require(_isValidLockupPeriod(_lockupPeriod), "Invalid lockup period");\n', '        require(_amount >= getMinimumStakeAmount(), "Invalid minimum");\n', '        \n', '        require(IERC20(token).transferFrom(msg.sender, address(this), calculateTotalWithDecimals(_amount)), "Couldn\'t take the tokens");\n', '        \n', '        if (_referrer != address(0) && stakes[_referrer].exists) {\n', '            uint256 amountToIncrease = stakes[_referrer].initialAmount.mul(1).div(100);\n', '            emit StakeIncreasedForReferral(_referrer, stakes[_referrer].initialAmount, amountToIncrease);\n', '            stakes[_referrer].initialAmount += amountToIncrease;\n', '            totalStaked = totalStaked.add(amountToIncrease); \n', '        }\n', '        else {\n', '            _referrer = ZERO_ADDRESS;\n', '        }\n', '\n', '        Stake memory stake = Stake({exists:true,\n', '                                    createdOn: now, \n', '                                    initialAmount:_amount, \n', '                                    compound:_compound, \n', '                                    lockupPeriod:_lockupPeriod, \n', '                                    withdrawn:0,\n', '                                    referrer:_referrer\n', '        });\n', '                                    \n', '        stakes[msg.sender] = stake;\n', '        totalStakes = totalStakes.add(1);\n', '        totalStaked = totalStaked.add(_amount);\n', '        totalByLockup[_lockupPeriod] += 1;\n', '        if (_compound) {\n', '            totalCompounding = totalCompounding.add(1);\n', '        } else {\n', '            totalNotCompounding = totalNotCompounding.add(1);\n', '        }\n', '        \n', '        emit NewStake(msg.sender, _amount, _lockupPeriod, _compound, _referrer);\n', '    }\n', '    \n', '    function withdraw() public {\n', '        require(stakes[msg.sender].exists, "Invalid stake");\n', '        require(!stakes[msg.sender].compound, "Compounders can\'t withdraw before they finish their stake");\n', '\n', '        Stake storage stake = stakes[msg.sender];\n', '        uint256 total = getPartialToWidthdrawForNotCompounders(msg.sender, now);\n', '        stake.withdrawn += total;\n', '        \n', '        require(token.transfer(msg.sender, calculateTotalWithDecimals(total)), "Couldn\'t withdraw");\n', '\n', '        emit RewardsWithdrawn(msg.sender, total);\n', '    }\n', '    \n', '    function finishStake() public {\n', '        require(stakes[msg.sender].exists, "Invalid stake");\n', '        \n', '        Stake memory stake = stakes[msg.sender];\n', '        \n', '        uint256 finishesOn = _calculateFinishTimestamp(stake.createdOn, stake.lockupPeriod);\n', '        require(now > finishesOn || !stake.compound, "Can\'t be finished yet");\n', '        \n', '        uint256 totalRewards;\n', '        uint256 totalFees;\n', '        uint256 totalPenalty;\n', '        \n', '        if (stake.compound) {\n', '            totalRewards = getTotalToWidthdrawForCompounders(msg.sender); //This includes the initial amount\n', '            totalRewards = totalRewards.sub(stake.initialAmount);\n', '            totalFees = totalRewards.mul(5).div(100); //Flat fee of 5%\n', '        }\n', '        else {\n', '            if (now > finishesOn) {\n', '                totalRewards = getTotalToWidthdrawForNotCompounders(msg.sender);\n', '            }  \n', '            else {\n', '                totalRewards = getPartialToWidthdrawForNotCompounders(msg.sender, now);\n', "                //As it didn't finish, pay a fee of 10% (before first half) or 5% (after first half)\n", '                uint8 penalty = _isFirstHalf(stake.createdOn, stake.lockupPeriod) ? 10 : 5;\n', '                totalPenalty = totalRewards.mul(penalty).div(100);\n', '            }\n', '            totalFees = totalRewards.mul(2).div(100); //Flat fee of 2%\n', '        }\n', '        \n', '        uint256 totalToDeduct = totalFees.add(totalPenalty);\n', '        uint256 totalToTransfer = totalRewards.add(stake.initialAmount).sub(totalToDeduct);\n', '        \n', '        //10% of the fees are for the Admin.\n', '        adminCanWithdraw = adminCanWithdraw.add(totalToDeduct.div(10));\n', '        //The rest are burnt\n', '        uint256 totalToBurn = totalToDeduct.mul(9).div(10);\n', '        \n', '        require(token.transfer(BURN_ADDRESS, calculateTotalWithDecimals(totalToBurn)), "Couldn\'t burn the tokens");\n', '        emit TokensBurnt(msg.sender, totalToBurn);\n', '\n', '        totalStakes = totalStakes.sub(1);\n', '        totalStaked = totalStaked.sub(stake.initialAmount);\n', '        totalByLockup[stake.lockupPeriod] = totalByLockup[stake.lockupPeriod].sub(1);\n', '        if (stake.compound) {\n', '            totalCompounding = totalCompounding.sub(1);\n', '        } else {\n', '            totalNotCompounding = totalNotCompounding.sub(1);\n', '        }\n', '        delete stakes[msg.sender];\n', '\n', '        require(token.transfer(msg.sender, calculateTotalWithDecimals(totalToTransfer)), "Couldn\'t transfer the tokens");\n', '        \n', '        emit StakeFinished(msg.sender, totalToTransfer, totalToDeduct);\n', '    }\n', '    \n', '    function calculateTotalWithDecimals(uint256 _amount) internal view returns (uint256) {\n', '        return _amount * 10 ** decimals;\n', '    }\n', '    \n', '    function _isFirstHalf(uint256 _createdOn, uint8 _lockupPeriod) internal view returns (bool) {\n', '        uint256 day = 60 * 60 * 24;\n', '        \n', '        if (_lockupPeriod == 1) {\n', '            return _createdOn + day.mul(15) > now;\n', '        }\n', '        if (_lockupPeriod == 2) {\n', '            return _createdOn + day.mul(30) > now;\n', '        }\n', '        if (_lockupPeriod == 3) {\n', '            return _createdOn + day.mul(45) > now;\n', '        }\n', '        return _createdOn + day.mul(90) > now;\n', '    }\n', '    \n', '    function calcPartialRewardsForInitialMonth(Stake memory stake, uint8 _todayDay, Date._Date memory _initial, bool compounding) internal view returns (uint256) {\n', '        uint256 roi = getRoi(_initial.month, _initial.year, stake.lockupPeriod);\n', '        uint8 totalDays = _todayDay - _initial.day;\n', '        return calculateRewards(stake.initialAmount, totalDays, roi, compounding);\n', '    }\n', '\n', '    function calcFullRewardsForInitialMonth(Stake memory stake, Date._Date memory _initial, bool compounding) internal view returns (uint256) {\n', '        uint8 totalDays = Date.getDaysInMonth(_initial.month, _initial.year);\n', '        uint256 roi = getRoi(_initial.month, _initial.year, stake.lockupPeriod);\n', '        uint8 countDays = totalDays - _initial.day;\n', '        return calculateRewards(stake.initialAmount, countDays, roi, compounding);\n', '    }\n', '    \n', '    function calcFullRewardsForMonth(uint256 _currentTotal, uint256 _roi, uint16 _year, uint8 _month, bool compounding) internal pure returns (uint256) {\n', '        uint256 totalDays = Date.getDaysInMonth(_month, _year);\n', '        return calculateRewards(_currentTotal, totalDays, _roi, compounding);\n', '    }\n', '    \n', '    function calculateRewards(uint256 currentTotal, uint256 totalDays, uint256 roi, bool compounding) internal pure returns (uint256) {\n', '        if (compounding) {\n', '            uint256 divFactor = 10000 ** 10;\n', '            while(totalDays > 10) {\n', '                currentTotal = currentTotal.mul(roi.add(10000) ** 10).div(divFactor);\n', '                totalDays -= 10;\n', '            }\n', '            return currentTotal = currentTotal.mul(roi.add(10000) ** totalDays).div(10000 ** totalDays);\n', '        }\n', '        \n', '        //Not compounding\n', '        return currentTotal.mul(totalDays).mul(roi).div(10000);\n', '    }\n', '    \n', '    //This function is meant to be called internally when finishing your stake\n', '    function getTotalToWidthdrawForNotCompounders(address _account) internal view returns (uint256) {\n', '        Stake memory stake = stakes[_account];\n', '        \n', '        Date._Date memory initial = Date.parseTimestamp(stake.createdOn);\n', '        \n', '        uint256 total = calcFullRewardsForInitialMonth(stake, initial, false);\n', '        \n', '        uint256 finishTimestamp = _calculateFinishTimestamp(stake.createdOn, stake.lockupPeriod);\n', '        Date._Date memory finishes = Date.parseTimestamp(finishTimestamp);\n', '        \n', '        for(uint8 i=1;i<=stake.lockupPeriod;i++) {\n', '            uint8 currentMonth = initial.month + i;\n', '            uint16 currentYear = initial.year;\n', '            if (currentMonth > 12) {\n', '                currentYear += 1;\n', '                currentMonth = currentMonth % 12;\n', '            }\n', '\n', '            uint256 roi = getRoi(currentMonth, currentYear ,stake.lockupPeriod);\n', '\n', '            //This is the month it finishes on\n', '            if (currentMonth == finishes.month) {\n', '                //Calculates partial rewards for month\n', '                total += calculateRewards(stake.initialAmount, finishes.day, roi, false);\n', '                break;\n', '            }\n', '            \n', '            //This is a complete month I need to add\n', '            total += calcFullRewardsForMonth(stake.initialAmount, roi, currentYear, currentMonth, false);\n', '        }\n', '        \n', '        total = total.sub(stake.withdrawn);\n', '        return total;\n', '    }\n', '    \n', '    //This function is meant to be called internally when withdrawing as much as you can, or by the UI\n', '    function getPartialToWidthdrawForNotCompounders(address _account, uint256 _now) public view returns (uint256) {\n', '        Stake memory stake = stakes[_account];\n', '        \n', '        Date._Date memory initial = Date.parseTimestamp(stake.createdOn);\n', '        Date._Date memory today = Date.parseTimestamp(_now);\n', '        \n', '        //I am still in my first month of staking\n', '        if (initial.month == today.month) {\n', '            uint256 total = calcPartialRewardsForInitialMonth(stake, today.day, initial, false);\n', '            total = total.sub(stake.withdrawn);\n', '            return total;\n', '        }\n', '        \n', '        //I am in a month after my first month of staking\n', '        uint256 total = calcFullRewardsForInitialMonth(stake, initial, false);\n', '        \n', '        uint256 finishTimestamp = _calculateFinishTimestamp(stake.createdOn, stake.lockupPeriod);\n', '        Date._Date memory finishes = Date.parseTimestamp(finishTimestamp);\n', '        \n', '        for(uint8 i=1;i<=stake.lockupPeriod;i++) {\n', '            uint8 currentMonth = initial.month + i;\n', '            uint16 currentYear = initial.year;\n', '            if (currentMonth > 12) {\n', '                currentYear += 1;\n', '                currentMonth = currentMonth % 12;\n', '            }\n', '\n', '            uint256 roi = getRoi(currentMonth, currentYear, stake.lockupPeriod);\n', '\n', '            //This is the month it finishes\n', '            if (currentMonth == finishes.month) {\n', '                uint8 upToDay = _getMin(finishes.day, today.day);\n', '                //Calculates partial rewards for month\n', '                total += calculateRewards(stake.initialAmount, upToDay, roi, false);\n', '                break;\n', '            }\n', '            else if (currentMonth == today.month) { // We reached the current month\n', '                //Calculates partial rewards for month\n', '                total += calculateRewards(stake.initialAmount, today.day, roi, false);\n', '                break;\n', '            }\n', '            \n', '            //This is a complete month I need to add\n', '            total += calcFullRewardsForMonth(stake.initialAmount, roi, currentYear, currentMonth, false);\n', '        }\n', '        \n', '        total = total.sub(stake.withdrawn);\n', '        return total;\n', '    }\n', '    \n', '    //This function is meant to be called internally on finishing your stake\n', '    function getTotalToWidthdrawForCompounders(address _account) internal view returns (uint256) {\n', '        Stake memory stake = stakes[_account];\n', '        \n', '        Date._Date memory initial = Date.parseTimestamp(stake.createdOn);\n', '        \n', '        uint256 total = calcFullRewardsForInitialMonth(stake, initial, true);\n', '        \n', '        uint256 finishTimestamp = _calculateFinishTimestamp(stake.createdOn, stake.lockupPeriod);\n', '        Date._Date memory finishes = Date.parseTimestamp(finishTimestamp);\n', '        \n', '        for(uint8 i=1;i<=stake.lockupPeriod;i++) {\n', '            uint8 currentMonth = initial.month + i;\n', '            uint16 currentYear = initial.year;\n', '            if (currentMonth > 12) {\n', '                currentYear += 1;\n', '                currentMonth = currentMonth % 12;\n', '            }\n', '\n', '            uint256 roi = getRoi(currentMonth, currentYear, stake.lockupPeriod);\n', '\n', '            //This is the month it finishes on\n', '            if (currentMonth == finishes.month) {\n', '                //Calculates partial rewards for month\n', '                return calculateRewards(total, finishes.day, roi, true);\n', '            }\n', '            \n', '            //This is a complete month I need to add\n', '            total = calcFullRewardsForMonth(total, roi, currentYear, currentMonth, true);\n', '        }\n', '    }\n', '    \n', '    //This function is meant to be called from the UI\n', '    function getPartialRewardsForCompounders(address _account, uint256 _now) public view returns (uint256) {\n', '        Stake memory stake = stakes[_account];\n', '        \n', '        Date._Date memory initial = Date.parseTimestamp(stake.createdOn);\n', '        Date._Date memory today = Date.parseTimestamp(_now);\n', '        \n', '        //I am still in my first month of staking\n', '        if (initial.month == today.month) {\n', '            uint256 total = calcPartialRewardsForInitialMonth(stake, today.day, initial, true);\n', '            total = total.sub(stake.withdrawn);\n', '            return total;\n', '        }\n', '        \n', '        //I am in a month after my first month of staking\n', '        uint256 total = calcFullRewardsForInitialMonth(stake, initial, true);\n', '        \n', '        uint256 finishTimestamp = _calculateFinishTimestamp(stake.createdOn, stake.lockupPeriod);\n', '        Date._Date memory finishes = Date.parseTimestamp(finishTimestamp);\n', '        \n', '        for(uint8 i=1;i<=stake.lockupPeriod;i++) {\n', '            uint8 currentMonth = initial.month + i;\n', '            uint16 currentYear = initial.year;\n', '            if (currentMonth > 12) {\n', '                currentYear += 1;\n', '                currentMonth = currentMonth % 12;\n', '            }\n', '\n', '            uint256 roi = getRoi(currentMonth, currentYear, stake.lockupPeriod);\n', '\n', '            //This is the month it finishes\n', '            if (currentMonth == finishes.month) {\n', '                uint8 upToDay = _getMin(finishes.day, today.day);\n', '                //Calculates partial rewards for month\n', '                return calculateRewards(total, upToDay, roi, true);\n', '            }\n', '            else if (currentMonth == today.month) { // We reached the current month\n', '                //Calculates partial rewards for month\n', '                return calculateRewards(total, today.day, roi, true);\n', '            }\n', '            \n', '            //This is a complete month I need to add\n', '            total = calcFullRewardsForMonth(total, roi, currentYear, currentMonth, true);\n', '        }\n', '    }\n', '    \n', '    function _getMin(uint8 num1, uint8 num2) internal pure returns (uint8) {\n', '        if (num1 < num2) {\n', '            return num1;\n', '        }\n', '        \n', '        return num2;\n', '    }\n', '    \n', '    function calculateFinishTimestamp(address account) public view returns (uint256) {\n', '        return _calculateFinishTimestamp(stakes[account].createdOn, stakes[account].lockupPeriod);\n', '    }\n', '    \n', '    function _calculateFinishTimestamp(uint256 _timestamp, uint8 _lockupPeriod) internal pure returns (uint256) {\n', '        uint16 year = Date.getYear(_timestamp);\n', '        uint8 month = Date.getMonth(_timestamp);\n', '        month += _lockupPeriod;\n', '        if (month > 12) {\n', '            year += 1;\n', '            month = month % 12;\n', '        }\n', '        uint8 day = Date.getDay(_timestamp);\n', '        return Date.toTimestamp(year, month, day);\n', '    }\n', '    \n', '    function _isValidLockupPeriod(uint8 n) public view returns (bool) {\n', '        return (isValidLockup1 && n == 1) || (isValidLockup2 && n == 2) || (isValidLockup3 && n == 3) || (isValidLockup6 && n == 6);\n', '    }\n', '    \n', '    function _setValidLockups(bool _isValidLockup1, bool _isValidLockup2, bool _isValidLockup3, bool _isValidLockup6) public onlyOwner {\n', '        isValidLockup1 = _isValidLockup1;\n', '        isValidLockup2 = _isValidLockup2;\n', '        isValidLockup3 = _isValidLockup3;\n', '        isValidLockup6 = _isValidLockup6;\n', '    }\n', '    \n', '    function _adminWithdraw() public onlyOwner {\n', '        uint256 amount = adminCanWithdraw;\n', '        adminCanWithdraw = 0;\n', '        require(token.transfer(msg.sender, calculateTotalWithDecimals(amount)), "Couldn\'t withdraw");\n', '    }\n', '\n', '    function _extractDESTSentByMistake(uint256 amount, address _sendTo) public onlyOwner {\n', '        require(token.transfer(_sendTo, amount));\n', '    }\n', '    \n', '    function _setMinimumStakeAmount(uint256 _minimumStakeAmount) public onlyOwner {\n', '        minimumStakeAmount = _minimumStakeAmount;\n', '    }\n', '\n', '    function getMinimumStakeAmount() public view returns (uint256) {\n', '        return minimumStakeAmount;\n', '    }\n', '    \n', '    function _setRoi(uint256 _month, uint256 _year, uint256 _roi1, uint256 _roi2, uint256 _roi3, uint256 _roi6) public onlyOwner {\n', '        uint256 today_year = Date.getYear(now);\n', '        uint256 today_month = Date.getMonth(now);\n', '        \n', '        require((_month >= today_month  && _year == today_year) || _year > today_year, "You can only set it for this month or a future month");\n', '        \n', '        rois[_year][_month].exists = true;\n', '        rois[_year][_month].roi1 = _roi1;\n', '        rois[_year][_month].roi2 = _roi2;\n', '        rois[_year][_month].roi3 = _roi3;\n', '        rois[_year][_month].roi6 = _roi6;\n', '    }\n', '    \n', '    function _setDefaultRoi(uint256 _roi1, uint256 _roi2, uint256 _roi3, uint256 _roi6) public onlyOwner {\n', '        DEFAULT_ROI1 = _roi1;\n', '        DEFAULT_ROI2 = _roi2;\n', '        DEFAULT_ROI3 = _roi3;\n', '        DEFAULT_ROI6 = _roi6;\n', '    }\n', '    \n', '    function getRoi(uint256 month, uint256 year, uint8 lockupPeriod) public view returns (uint256) {\n', '        if (rois[year][month].exists) {\n', '            if (lockupPeriod == 1) {\n', '                return rois[year][month].roi1;\n', '            }\n', '            else if (lockupPeriod == 2) {\n', '                return rois[year][month].roi2;\n', '            }\n', '            else if (lockupPeriod == 3) {\n', '                return rois[year][month].roi3;\n', '            }\n', '            else if (lockupPeriod == 6) {\n', '                return rois[year][month].roi6;\n', '            }\n', '        }\n', '        \n', '        if (lockupPeriod == 1) {\n', '            return DEFAULT_ROI1;\n', '        }\n', '        else if (lockupPeriod == 2) {\n', '            return DEFAULT_ROI2;\n', '        }\n', '        else if (lockupPeriod == 3) {\n', '            return DEFAULT_ROI3;\n', '        }\n', '        else if (lockupPeriod == 6) {\n', '            return DEFAULT_ROI6;\n', '        }\n', '        \n', '        return 0;\n', '    }\n', '}']