['/**\n', ' *Submitted for verification at Etherscan.io on 2020-09-18\n', '*/\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IMasterAware.sol\n', '\n', '/* Copyright (C) 2020 NexusMutual.io\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', 'interface IMasterAware {\n', '\n', '  function changeDependentContractAddress() external;\n', '\n', '  function changeMasterAddress(address _masterAddress) external;\n', '}\n', '\n', '// File: contracts/interfaces/INXMMaster.sol\n', '\n', '/* Copyright (C) 2020 NexusMutual.io\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', 'interface INXMMaster {\n', '\n', '  function delegateCallBack(bytes32 myid) external;\n', '\n', '  function masterInitialized() external view returns (bool);\n', '\n', '  function isInternal(address _add) external view returns (bool);\n', '\n', '  function isPause() external view returns (bool check);\n', '\n', '  function isOwner(address _add) external view returns (bool);\n', '\n', '  function isMember(address _add) external view returns (bool);\n', '\n', '  function checkIsAuthToGoverned(address _add) external view returns (bool);\n', '\n', '  function updatePauseTime(uint _time) external;\n', '\n', '  function dAppLocker() external view returns (address _add);\n', '\n', '  function dAppToken() external view returns (address _add);\n', '\n', '  function tokenAddress() external view returns (address);\n', '\n', '  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);\n', '}\n', '\n', '// File: contracts/abstract/MasterAware.sol\n', '\n', '/*\n', '    Copyright (C) 2020 NexusMutual.io\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/\n', '*/\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', 'contract MasterAware is IMasterAware {\n', '\n', '  INXMMaster public master;\n', '\n', '  modifier onlyMember {\n', '    require(master.isMember(msg.sender), "Caller is not a member");\n', '    _;\n', '  }\n', '\n', '  modifier onlyInternal {\n', '    require(master.isInternal(msg.sender), "Caller is not an internal contract");\n', '    _;\n', '  }\n', '\n', '  modifier onlyMaster {\n', '    if (address(master) != address(0)) {\n', '      require(address(master) == msg.sender, "Not master");\n', '    }\n', '    _;\n', '  }\n', '\n', '  modifier onlyGovernance {\n', '    require(\n', '      master.checkIsAuthToGoverned(msg.sender),\n', '      "Caller is not authorized to govern"\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused {\n', '    require(master.isPause(), "System is not paused");\n', '    _;\n', '  }\n', '\n', '  modifier whenNotPaused {\n', '    require(!master.isPause(), "System is paused");\n', '    _;\n', '  }\n', '\n', '  function changeMasterAddress(address masterAddress) public onlyMaster {\n', '    master = INXMMaster(masterAddress);\n', '  }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/abstract/NXMToken.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '/*\n', ' * This file and directory exists because interface inheritance is not allowed in solidity 0.5\n', ' * This was implemented in solidity > 0.6.1\n', ' */\n', '\n', 'contract NXMToken is IERC20 {\n', '\n', '  function burn(uint256 amount) public returns (bool);\n', '\n', '  function burnFrom(address from, uint256 value) public returns (bool);\n', '\n', '  function operatorTransfer(address from, uint256 value) public returns (bool);\n', '\n', '  function mint(address account, uint256 amount) public;\n', '}\n', '\n', '// File: contracts/interfaces/ITokenController.sol\n', '\n', '/* Copyright (C) 2020 NexusMutual.io\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', 'interface ITokenController {\n', '\n', '  function addToWhitelist(address _member) external;\n', '  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\n', '  function mint(address _member, uint256 _amount) external;\n', '  function operatorTransfer(address _from, address _to, uint _value) external returns (bool);\n', '  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\n', '  function tokensLocked(address _of, bytes32 _reason) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/PooledStaking.sol\n', '\n', '/*\n', '    Copyright (C) 2020 NexusMutual.io\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/\n', '*/\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', '\n', '\n', 'contract PooledStaking is MasterAware {\n', '  using SafeMath for uint;\n', '\n', '  /* Data types */\n', '\n', '  struct Staker {\n', '    uint deposit; // total amount of deposit nxm\n', '    uint reward; // total amount that is ready to be claimed\n', '    address[] contracts; // list of contracts the staker has staked on\n', '\n', '    // staked amounts for each contract\n', '    mapping(address => uint) stakes;\n', '\n', '    // amount pending to be subtracted after all unstake requests will be processed\n', '    mapping(address => uint) pendingUnstakeRequestsTotal;\n', '\n', '    // flag to indicate the presence of this staker in the array of stakers of each contract\n', '    mapping(address => bool) isInContractStakers;\n', '  }\n', '\n', '  struct Burn {\n', '    uint amount;\n', '    uint burnedAt;\n', '    address contractAddress;\n', '  }\n', '\n', '  struct Reward {\n', '    uint amount;\n', '    uint rewardedAt;\n', '    address contractAddress;\n', '  }\n', '\n', '  struct UnstakeRequest {\n', '    uint amount;\n', '    uint unstakeAt;\n', '    address contractAddress;\n', '    address stakerAddress;\n', '    uint next; // id of the next unstake request in the linked list\n', '  }\n', '\n', '  struct ContractReward {\n', '    uint amount;\n', '    uint lastDistributionRound;\n', '  }\n', '\n', '  /* Events */\n', '\n', '  // deposits\n', '  event Deposited(address indexed staker, uint amount);\n', '  event Withdrawn(address indexed staker, uint amount);\n', '\n', '  // stakes\n', '  event Staked(address indexed contractAddress, address indexed staker, uint amount);\n', '  event UnstakeRequested(address indexed contractAddress, address indexed staker, uint amount, uint unstakeAt);\n', '  event Unstaked(address indexed contractAddress, address indexed staker, uint amount);\n', '\n', '  // burns\n', '  event BurnRequested(address indexed contractAddress, uint amount);\n', '  event Burned(address indexed contractAddress, uint amount, uint contractStakeBeforeBurn);\n', '\n', '  // rewards\n', '  event RewardAdded(address indexed contractAddress, uint amount);\n', '  event RewardRequested(address indexed contractAddress, uint amount);\n', '  event Rewarded(address indexed contractAddress, uint amount, uint contractStake);\n', '  event RewardWithdrawn(address indexed staker, uint amount);\n', '\n', '  // pending actions processing\n', '  event PendingActionsProcessed(bool finished);\n', '\n', '  /* Storage variables */\n', '\n', '  bool public initialized;\n', '\n', '  NXMToken public token;\n', '  ITokenController public tokenController;\n', '\n', '  uint public MIN_STAKE;         // Minimum allowed stake per contract\n', '  uint public MAX_EXPOSURE;      // Stakes sum must be less than the deposit amount times this\n', '  uint public MIN_UNSTAKE;       // Forbid unstake of small amounts to prevent spam\n', '  uint public UNSTAKE_LOCK_TIME; // Lock period in seconds before unstaking takes place\n', '\n', '  mapping(address => Staker) stakers;     // stakerAddress => Staker\n', '\n', '  // temporary variables\n', '  uint contractStaked;   // used when processing burns and rewards\n', '  uint contractBurned;   // used when processing burns\n', '  uint contractRewarded; // used when processing rewards\n', '\n', '  // list of stakers for all contracts\n', '  mapping(address => address[]) contractStakers;\n', '\n', '  // there can be only one pending burn\n', '  Burn public burn;\n', '\n', '  mapping(uint => Reward) public rewards; // reward id => Reward\n', '  uint public firstReward;\n', '  uint public lastRewardId;\n', '\n', '  mapping(uint => UnstakeRequest) public unstakeRequests; // unstake id => UnstakeRequest\n', '  // firstUnstakeRequest is stored at unstakeRequests[0].next\n', '  uint public lastUnstakeRequestId;\n', '\n', '  uint public processedToStakerIndex; // we processed the action up this staker\n', '  bool public isContractStakeCalculated; // flag to indicate whether staked amount is up to date or not\n', '\n', '  /* state vars for rewards groupping upgrade */\n', '\n', '  // rewards to be distributed at the end of the current round\n', '  // contract address => ContractRewards\n', '  mapping(address => ContractReward) public accumulatedRewards;\n', '\n', '  uint public REWARD_ROUND_DURATION;\n', '  uint public REWARD_ROUNDS_START;\n', '\n', '  /* Modifiers */\n', '\n', '  modifier noPendingActions {\n', "    require(!hasPendingActions(), 'Unable to execute request with unprocessed actions');\n", '    _;\n', '  }\n', '\n', '  modifier noPendingBurns {\n', "    require(!hasPendingBurns(), 'Unable to execute request with unprocessed burns');\n", '    _;\n', '  }\n', '\n', '  modifier noPendingUnstakeRequests {\n', "    require(!hasPendingUnstakeRequests(), 'Unable to execute request with unprocessed unstake requests');\n", '    _;\n', '  }\n', '\n', '  modifier noPendingRewards {\n', "    require(!hasPendingRewards(), 'Unable to execute request with unprocessed rewards');\n", '    _;\n', '  }\n', '\n', '  modifier whenNotPausedAndInitialized {\n', '    require(!master.isPause(), "System is paused");\n', '    require(initialized, "Contract is not initialized");\n', '    _;\n', '  }\n', '\n', '  /* Getters and view functions */\n', '\n', '  function contractStakerCount(address contractAddress) external view returns (uint) {\n', '    return contractStakers[contractAddress].length;\n', '  }\n', '\n', '  function contractStakerAtIndex(address contractAddress, uint stakerIndex) external view returns (address) {\n', '    return contractStakers[contractAddress][stakerIndex];\n', '  }\n', '\n', '  function contractStakersArray(address contractAddress) external view returns (address[] memory _stakers) {\n', '    return contractStakers[contractAddress];\n', '  }\n', '\n', '  function contractStake(address contractAddress) public view returns (uint) {\n', '\n', '    address[] storage _stakers = contractStakers[contractAddress];\n', '    uint stakerCount = _stakers.length;\n', '    uint stakedOnContract;\n', '\n', '    for (uint i = 0; i < stakerCount; i++) {\n', '      Staker storage staker = stakers[_stakers[i]];\n', '      uint deposit = staker.deposit;\n', '      uint stake = staker.stakes[contractAddress];\n', '\n', '      // add the minimum of the two\n', '      stake = deposit < stake ? deposit : stake;\n', '      stakedOnContract = stakedOnContract.add(stake);\n', '    }\n', '\n', '    return stakedOnContract;\n', '  }\n', '\n', '  function stakerContractCount(address staker) external view returns (uint) {\n', '    return stakers[staker].contracts.length;\n', '  }\n', '\n', '  function stakerContractAtIndex(address staker, uint contractIndex) external view returns (address) {\n', '    return stakers[staker].contracts[contractIndex];\n', '  }\n', '\n', '  function stakerContractsArray(address staker) external view returns (address[] memory) {\n', '    return stakers[staker].contracts;\n', '  }\n', '\n', '  function stakerContractStake(address staker, address contractAddress) external view returns (uint) {\n', '    uint stake = stakers[staker].stakes[contractAddress];\n', '    uint deposit = stakers[staker].deposit;\n', '    return stake < deposit ? stake : deposit;\n', '  }\n', '\n', '  function stakerContractPendingUnstakeTotal(address staker, address contractAddress) external view returns (uint) {\n', '    return stakers[staker].pendingUnstakeRequestsTotal[contractAddress];\n', '  }\n', '\n', '  function stakerReward(address staker) external view returns (uint) {\n', '    return stakers[staker].reward;\n', '  }\n', '\n', '  function stakerDeposit(address staker) external view returns (uint) {\n', '    return stakers[staker].deposit;\n', '  }\n', '\n', '  function stakerMaxWithdrawable(address stakerAddress) public view returns (uint) {\n', '\n', '    Staker storage staker = stakers[stakerAddress];\n', '    uint deposit = staker.deposit;\n', '    uint totalStaked;\n', '    uint maxStake;\n', '\n', '    for (uint i = 0; i < staker.contracts.length; i++) {\n', '\n', '      address contractAddress = staker.contracts[i];\n', '      uint initialStake = staker.stakes[contractAddress];\n', '      uint stake = deposit < initialStake ? deposit : initialStake;\n', '      totalStaked = totalStaked.add(stake);\n', '\n', '      if (stake > maxStake) {\n', '        maxStake = stake;\n', '      }\n', '    }\n', '\n', '    uint minRequired = totalStaked.div(MAX_EXPOSURE);\n', '    uint locked = maxStake > minRequired ? maxStake : minRequired;\n', '\n', '    return deposit.sub(locked);\n', '  }\n', '\n', '  function unstakeRequestAtIndex(uint unstakeRequestId) external view returns (\n', '    uint amount, uint unstakeAt, address contractAddress, address stakerAddress, uint next\n', '  ) {\n', '    UnstakeRequest storage unstakeRequest = unstakeRequests[unstakeRequestId];\n', '    amount = unstakeRequest.amount;\n', '    unstakeAt = unstakeRequest.unstakeAt;\n', '    contractAddress = unstakeRequest.contractAddress;\n', '    stakerAddress = unstakeRequest.stakerAddress;\n', '    next = unstakeRequest.next;\n', '  }\n', '\n', '  function hasPendingActions() public view returns (bool) {\n', '    return hasPendingBurns() || hasPendingUnstakeRequests() || hasPendingRewards();\n', '  }\n', '\n', '  function hasPendingBurns() public view returns (bool) {\n', '    return burn.burnedAt != 0;\n', '  }\n', '\n', '  function hasPendingUnstakeRequests() public view returns (bool){\n', '\n', '    uint nextRequestIndex = unstakeRequests[0].next;\n', '\n', '    if (nextRequestIndex == 0) {\n', '      return false;\n', '    }\n', '\n', '    return unstakeRequests[nextRequestIndex].unstakeAt <= now;\n', '  }\n', '\n', '  function hasPendingRewards() public view returns (bool){\n', '    return rewards[firstReward].rewardedAt != 0;\n', '  }\n', '\n', '  /* State-changing functions */\n', '\n', '  function depositAndStake(\n', '    uint amount,\n', '    address[] calldata _contracts,\n', '    uint[] calldata _stakes\n', '  ) external whenNotPausedAndInitialized onlyMember noPendingActions {\n', '\n', '    Staker storage staker = stakers[msg.sender];\n', '    uint oldLength = staker.contracts.length;\n', '\n', '    require(\n', '      _contracts.length >= oldLength,\n', '      "Staking on fewer contracts is not allowed"\n', '    );\n', '\n', '    require(\n', '      _contracts.length == _stakes.length,\n', '      "Contracts and stakes arrays should have the same length"\n', '    );\n', '\n', '    uint totalStaked;\n', '\n', '    // cap old stakes to this amount\n', '    uint oldDeposit = staker.deposit;\n', '    uint newDeposit = oldDeposit.add(amount);\n', '\n', '    staker.deposit = newDeposit;\n', '    tokenController.operatorTransfer(msg.sender, address(this), amount);\n', '\n', '    for (uint i = 0; i < _contracts.length; i++) {\n', '\n', '      address contractAddress = _contracts[i];\n', '\n', '      for (uint j = 0; j < i; j++) {\n', '        require(_contracts[j] != contractAddress, "Contracts array should not contain duplicates");\n', '      }\n', '\n', '      uint initialStake = staker.stakes[contractAddress];\n', '      uint oldStake = oldDeposit < initialStake ? oldDeposit : initialStake;\n', '      uint newStake = _stakes[i];\n', '      bool isNewStake = i >= oldLength;\n', '\n', '      if (!isNewStake) {\n', '        require(contractAddress == staker.contracts[i], "Unexpected contract order");\n', '        require(oldStake <= newStake, "New stake is less than previous stake");\n', '      } else {\n', '        require(newStake > 0, "New stakes should be greater than 0");\n', '        staker.contracts.push(contractAddress);\n', '      }\n', '\n', '      if (oldStake == newStake) {\n', '\n', '        // if there were burns but the stake was not updated, update it now\n', '        if (initialStake != newStake) {\n', '          staker.stakes[contractAddress] = newStake;\n', '        }\n', '\n', '        totalStaked = totalStaked.add(newStake);\n', '\n', '        // no other changes to this contract\n', '        continue;\n', '      }\n', '\n', '      require(newStake >= MIN_STAKE, "Minimum stake amount not met");\n', '      require(newStake <= newDeposit, "Cannot stake more than deposited");\n', '\n', '      if (isNewStake || !staker.isInContractStakers[contractAddress]) {\n', '        staker.isInContractStakers[contractAddress] = true;\n', '        contractStakers[contractAddress].push(msg.sender);\n', '      }\n', '\n', '      staker.stakes[contractAddress] = newStake;\n', '      totalStaked = totalStaked.add(newStake);\n', '      uint increase = newStake.sub(oldStake);\n', '\n', '      emit Staked(contractAddress, msg.sender, increase);\n', '    }\n', '\n', '    require(\n', '      totalStaked <= staker.deposit.mul(MAX_EXPOSURE),\n', '      "Total stake exceeds maximum allowed"\n', '    );\n', '\n', '    if (amount > 0) {\n', '      emit Deposited(msg.sender, amount);\n', '    }\n', '\n', '    // cleanup zero-amount contracts\n', '    uint lastContractIndex = _contracts.length - 1;\n', '\n', '    for (uint i = oldLength; i > 0; i--) {\n', '      if (_stakes[i - 1] == 0) {\n', '        staker.contracts[i - 1] = staker.contracts[lastContractIndex];\n', '        staker.contracts.pop();\n', '        --lastContractIndex;\n', '      }\n', '    }\n', '  }\n', '\n', '  function withdraw(uint amount) external whenNotPausedAndInitialized onlyMember noPendingBurns {\n', '    uint limit = stakerMaxWithdrawable(msg.sender);\n', '    require(limit >= amount, "Requested amount exceeds max withdrawable amount");\n', '    stakers[msg.sender].deposit = stakers[msg.sender].deposit.sub(amount);\n', '    token.transfer(msg.sender, amount);\n', '    emit Withdrawn(msg.sender, amount);\n', '  }\n', '\n', '  function requestUnstake(\n', '    address[] calldata _contracts,\n', '    uint[] calldata _amounts,\n', '    uint _insertAfter // unstake request id after which the new unstake request will be inserted\n', '  ) external whenNotPausedAndInitialized onlyMember {\n', '\n', '    require(\n', '      _contracts.length == _amounts.length,\n', '      "Contracts and amounts arrays should have the same length"\n', '    );\n', '\n', "    require(_insertAfter <= lastUnstakeRequestId, 'Invalid unstake request id provided');\n", '\n', '    Staker storage staker = stakers[msg.sender];\n', '    uint deposit = staker.deposit;\n', '    uint previousId = _insertAfter;\n', '    uint unstakeAt = now.add(UNSTAKE_LOCK_TIME);\n', '\n', '    UnstakeRequest storage previousRequest = unstakeRequests[previousId];\n', '\n', '    // Forbid insertion after an empty slot when there are non-empty slots\n', '    // previousId != 0 allows inserting on the first position (in case lock time has been reduced)\n', '    if (previousId != 0) {\n', '      require(previousRequest.unstakeAt != 0, "Provided unstake request id should not be an empty slot");\n', '    }\n', '\n', '    for (uint i = 0; i < _contracts.length; i++) {\n', '\n', '      address contractAddress = _contracts[i];\n', '      uint stake = staker.stakes[contractAddress];\n', '\n', '      if (stake > deposit) {\n', '        stake = deposit;\n', '      }\n', '\n', '      uint pendingUnstakeAmount = staker.pendingUnstakeRequestsTotal[contractAddress];\n', '      uint requestedAmount = _amounts[i];\n', '      uint max = pendingUnstakeAmount > stake ? 0 : stake.sub(pendingUnstakeAmount);\n', '\n', '      require(max > 0, "Nothing to unstake on this contract");\n', '      require(requestedAmount <= max, "Cannot unstake more than staked");\n', '\n', '      // To prevent spam, small stakes and unstake requests are not allowed\n', '      // However, we allow the user to unstake the entire amount\n', '      if (requestedAmount != max) {\n', '        require(requestedAmount >= MIN_UNSTAKE, "Unstaked amount cannot be less than minimum unstake amount");\n', '        require(max.sub(requestedAmount) >= MIN_STAKE, "Remaining stake cannot be less than minimum unstake amount");\n', '      }\n', '\n', '      require(\n', '        unstakeAt >= previousRequest.unstakeAt,\n', '        "Unstake request time must be greater or equal to previous unstake request"\n', '      );\n', '\n', '      if (previousRequest.next != 0) {\n', '        UnstakeRequest storage nextRequest = unstakeRequests[previousRequest.next];\n', '        require(\n', '          nextRequest.unstakeAt > unstakeAt,\n', '          "Next unstake request time must be greater than new unstake request time"\n', '        );\n', '      }\n', '\n', '      // Note: We previously had an `id` variable that was assigned immediately to `previousId`.\n', '      //   It was removed in order to save some memory and previousId used instead.\n', '      //   This makes the next section slightly harder to read but you can read "previousId" as "newId" instead.\n', '\n', '      // get next available unstake request id. our new unstake request becomes previous for the next loop\n', '      previousId = ++lastUnstakeRequestId;\n', '\n', '      unstakeRequests[previousId] = UnstakeRequest(\n', '        requestedAmount,\n', '        unstakeAt,\n', '        contractAddress,\n', '        msg.sender,\n', '        previousRequest.next\n', '      );\n', '\n', '      // point to our new unstake request\n', '      previousRequest.next = previousId;\n', '\n', '      emit UnstakeRequested(contractAddress, msg.sender, requestedAmount, unstakeAt);\n', '\n', '      // increase pending unstake requests total so we keep track of final stake\n', '      uint newPending = staker.pendingUnstakeRequestsTotal[contractAddress].add(requestedAmount);\n', '      staker.pendingUnstakeRequestsTotal[contractAddress] = newPending;\n', '\n', '      // update the reference to the unstake request at target index for the next loop\n', '      previousRequest = unstakeRequests[previousId];\n', '    }\n', '  }\n', '\n', '  function withdrawReward(address stakerAddress) external whenNotPausedAndInitialized {\n', '\n', '    uint amount = stakers[stakerAddress].reward;\n', '    stakers[stakerAddress].reward = 0;\n', '\n', '    token.transfer(stakerAddress, amount);\n', '\n', '    emit RewardWithdrawn(stakerAddress, amount);\n', '  }\n', '\n', '  function pushBurn(\n', '    address contractAddress, uint amount\n', '  ) public onlyInternal whenNotPausedAndInitialized noPendingBurns {\n', '\n', '    address[] memory contractAddresses = new address[](1);\n', '    contractAddresses[0] = contractAddress;\n', '    _pushRewards(contractAddresses, true);\n', '\n', '    burn.amount = amount;\n', '    burn.burnedAt = now;\n', '    burn.contractAddress = contractAddress;\n', '\n', '    emit BurnRequested(contractAddress, amount);\n', '  }\n', '\n', '  function _getCurrentRewardsRound() internal view returns (uint) {\n', '\n', '    uint roundDuration = REWARD_ROUND_DURATION;\n', '    uint startTime = REWARD_ROUNDS_START;\n', '\n', "    require(startTime != 0, 'REWARD_ROUNDS_START is not initialized');\n", '\n', '    return now <= startTime ? 0 : (now - startTime) / roundDuration;\n', '  }\n', '\n', '  function getCurrentRewardsRound() external view returns (uint) {\n', '    return _getCurrentRewardsRound();\n', '  }\n', '\n', '  /**\n', '   * @dev Pushes accumulated rewards to the processing queue.\n', '   */\n', '  function _pushRewards(address[] memory contractAddresses, bool skipRoundCheck) internal {\n', '\n', '    uint currentRound = _getCurrentRewardsRound();\n', '    uint lastRewardIdCounter = lastRewardId;\n', '    uint pushedRewards = 0;\n', '\n', '    for (uint i = 0; i < contractAddresses.length; i++) {\n', '\n', '      address contractAddress = contractAddresses[i];\n', '      ContractReward storage contractRewards = accumulatedRewards[contractAddress];\n', '      uint lastRound = contractRewards.lastDistributionRound;\n', '      uint amount = contractRewards.amount;\n', '\n', '      bool shouldPush = amount > 0 && (skipRoundCheck || currentRound > lastRound);\n', '\n', '      if (!shouldPush) {\n', '        // prevent unintended distribution of the first reward in round\n', '        if (lastRound != currentRound) {\n', '          contractRewards.lastDistributionRound = currentRound;\n', '        }\n', '        continue;\n', '      }\n', '\n', '      rewards[++lastRewardIdCounter] = Reward(amount, now, contractAddress);\n', '      emit RewardRequested(contractAddress, amount);\n', '\n', '      contractRewards.amount = 0;\n', '      contractRewards.lastDistributionRound = currentRound;\n', '      ++pushedRewards;\n', '\n', '      if (pushedRewards == 1 && firstReward == 0) {\n', '        firstReward = lastRewardIdCounter;\n', '      }\n', '    }\n', '\n', '    if (pushedRewards != 0) {\n', '      lastRewardId = lastRewardIdCounter;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev External function for pushing accumulated rewards in the processing queue.\n', '   * @dev `_pushRewards` checks the current round and will only push if rewards can be distributed.\n', '   */\n', '  function pushRewards(address[] calldata contractAddresses) external whenNotPausedAndInitialized {\n', '    _pushRewards(contractAddresses, false);\n', '  }\n', '\n', '  /**\n', '   * @dev Add reward for contract. Automatically triggers distribution if enough time has passed.\n', '   */\n', '  function accumulateReward(address contractAddress, uint amount) external onlyInternal whenNotPausedAndInitialized {\n', '\n', '    // will push rewards if needed\n', '    address[] memory contractAddresses = new address[](1);\n', '    contractAddresses[0] = contractAddress;\n', '    _pushRewards(contractAddresses, false);\n', '\n', '    ContractReward storage contractRewards = accumulatedRewards[contractAddress];\n', '    contractRewards.amount = contractRewards.amount.add(amount);\n', '    emit RewardAdded(contractAddress, amount);\n', '  }\n', '\n', '  function processPendingActions(uint maxIterations) public whenNotPausedAndInitialized returns (bool finished) {\n', '    (finished,) = _processPendingActions(maxIterations);\n', '  }\n', '\n', '  function processPendingActionsReturnLeft(uint maxIterations) public whenNotPausedAndInitialized returns (bool finished, uint iterationsLeft) {\n', '    (finished, iterationsLeft) = _processPendingActions(maxIterations);\n', '  }\n', '\n', '  function _processPendingActions(uint maxIterations) public whenNotPausedAndInitialized returns (bool finished, uint iterationsLeft) {\n', '\n', '    iterationsLeft = maxIterations;\n', '\n', '    while (true) {\n', '\n', '      uint firstUnstakeRequestIndex = unstakeRequests[0].next;\n', '      UnstakeRequest storage unstakeRequest = unstakeRequests[firstUnstakeRequestIndex];\n', '      Reward storage reward = rewards[firstReward];\n', '\n', '      // read storage and cache in memory\n', '      uint burnedAt = burn.burnedAt;\n', '      uint rewardedAt = reward.rewardedAt;\n', '      uint unstakeAt = unstakeRequest.unstakeAt;\n', '\n', '      bool canUnstake = firstUnstakeRequestIndex > 0 && unstakeAt <= now;\n', '      bool canBurn = burnedAt != 0;\n', '      bool canReward = firstReward != 0;\n', '\n', '      if (!canBurn && !canUnstake && !canReward) {\n', '        // everything is processed\n', '        break;\n', '      }\n', '\n', '      if (\n', '        canBurn &&\n', '        (!canUnstake || burnedAt < unstakeAt) &&\n', '        (!canReward || burnedAt < rewardedAt)\n', '      ) {\n', '\n', '        (finished, iterationsLeft) = _processBurn(iterationsLeft);\n', '\n', '        if (!finished) {\n', '          emit PendingActionsProcessed(false);\n', '          return (false, iterationsLeft);\n', '        }\n', '\n', '        continue;\n', '      }\n', '\n', '      if (\n', '        canUnstake &&\n', '        (!canReward || unstakeAt < rewardedAt)\n', '      ) {\n', '\n', "        // _processFirstUnstakeRequest is O(1) so we'll handle the iteration checks here\n", '        if (iterationsLeft == 0) {\n', '          emit PendingActionsProcessed(false);\n', '          return (false, iterationsLeft);\n', '        }\n', '\n', '        _processFirstUnstakeRequest();\n', '        --iterationsLeft;\n', '        continue;\n', '      }\n', '\n', '      (finished, iterationsLeft) = _processFirstReward(iterationsLeft);\n', '\n', '      if (!finished) {\n', '        emit PendingActionsProcessed(false);\n', '        return (false, iterationsLeft);\n', '      }\n', '    }\n', '\n', '    // everything is processed!\n', '    emit PendingActionsProcessed(true);\n', '    return (true, iterationsLeft);\n', '  }\n', '\n', '  function _processBurn(uint maxIterations) internal returns (bool finished, uint iterationsLeft) {\n', '\n', '    iterationsLeft = maxIterations;\n', '\n', '    address _contractAddress = burn.contractAddress;\n', '    uint _stakedOnContract;\n', '\n', '    (_stakedOnContract, finished, iterationsLeft) = _calculateContractStake(_contractAddress, iterationsLeft);\n', '\n', '    if (!finished) {\n', '      return (false, iterationsLeft);\n', '    }\n', '\n', '    address[] storage _contractStakers = contractStakers[_contractAddress];\n', '    uint _stakerCount = _contractStakers.length;\n', '\n', '    uint _totalBurnAmount = burn.amount;\n', '    uint _actualBurnAmount = contractBurned;\n', '\n', '    if (_totalBurnAmount > _stakedOnContract) {\n', '      _totalBurnAmount = _stakedOnContract;\n', '    }\n', '\n', '    for (uint i = processedToStakerIndex; i < _stakerCount; i++) {\n', '\n', '      if (iterationsLeft == 0) {\n', '        contractBurned = _actualBurnAmount;\n', '        processedToStakerIndex = i;\n', '        return (false, iterationsLeft);\n', '      }\n', '\n', '      --iterationsLeft;\n', '\n', '      Staker storage staker = stakers[_contractStakers[i]];\n', '      uint _stakerBurnAmount;\n', '      uint _newStake;\n', '\n', '      (_stakerBurnAmount, _newStake) = _burnStaker(staker, _contractAddress, _stakedOnContract, _totalBurnAmount);\n', '      _actualBurnAmount = _actualBurnAmount.add(_stakerBurnAmount);\n', '\n', '      if (_newStake != 0) {\n', '        continue;\n', '      }\n', '\n', '      // if we got here, the stake is explicitly set to 0\n', '      // the staker is removed from the contract stakers array\n', '      // and we will add the staker back if he stakes again\n', '      staker.isInContractStakers[_contractAddress] = false;\n', '      _contractStakers[i] = _contractStakers[_stakerCount - 1];\n', '      _contractStakers.pop();\n', '\n', '      // i-- might underflow to MAX_UINT\n', "      // but that's fine since it will be incremented back to 0 on the next loop\n", '      i--;\n', '      _stakerCount--;\n', '    }\n', '\n', '    delete burn;\n', '    contractBurned = 0;\n', '    processedToStakerIndex = 0;\n', '    isContractStakeCalculated = false;\n', '\n', '    token.burn(_actualBurnAmount);\n', '    emit Burned(_contractAddress, _actualBurnAmount, _stakedOnContract);\n', '\n', '    return (true, iterationsLeft);\n', '  }\n', '\n', '  function _burnStaker(\n', '    Staker storage staker, address _contractAddress, uint _stakedOnContract, uint _totalBurnAmount\n', '  ) internal returns (\n', '    uint _stakerBurnAmount, uint _newStake\n', '  ) {\n', '\n', '    uint _currentDeposit;\n', '    uint _currentStake;\n', '\n', '    // silence compiler warning\n', '    _newStake = 0;\n', '\n', '    // do we need a storage read?\n', '    if (_stakedOnContract != 0) {\n', '      _currentDeposit = staker.deposit;\n', '      _currentStake = staker.stakes[_contractAddress];\n', '\n', '      if (_currentStake > _currentDeposit) {\n', '        _currentStake = _currentDeposit;\n', '      }\n', '    }\n', '\n', '    if (_stakedOnContract != _totalBurnAmount) {\n', '      // formula: staker_burn = staker_stake / total_contract_stake * contract_burn\n', '      // reordered for precision loss prevention\n', '      _stakerBurnAmount = _currentStake.mul(_totalBurnAmount).div(_stakedOnContract);\n', '      _newStake = _currentStake.sub(_stakerBurnAmount);\n', '    } else {\n', "      // it's the whole stake\n", '      _stakerBurnAmount = _currentStake;\n', '    }\n', '\n', '    if (_stakerBurnAmount != 0) {\n', '      staker.deposit = _currentDeposit.sub(_stakerBurnAmount);\n', '    }\n', '\n', '    staker.stakes[_contractAddress] = _newStake;\n', '  }\n', '\n', '  function _calculateContractStake(\n', '    address _contractAddress, uint maxIterations\n', '  ) internal returns (\n', '    uint _stakedOnContract, bool finished, uint iterationsLeft\n', '  ) {\n', '\n', '    iterationsLeft = maxIterations;\n', '\n', '    if (isContractStakeCalculated) {\n', '      // use previously calculated staked amount\n', '      return (contractStaked, true, iterationsLeft);\n', '    }\n', '\n', '    address[] storage _contractStakers = contractStakers[_contractAddress];\n', '    uint _stakerCount = _contractStakers.length;\n', '    uint startIndex = processedToStakerIndex;\n', '\n', '    if (startIndex != 0) {\n', '      _stakedOnContract = contractStaked;\n', '    }\n', '\n', '    // calculate amount staked on contract\n', '    for (uint i = startIndex; i < _stakerCount; i++) {\n', '\n', '      if (iterationsLeft == 0) {\n', '        processedToStakerIndex = i;\n', '        contractStaked = _stakedOnContract;\n', '        return (_stakedOnContract, false, iterationsLeft);\n', '      }\n', '\n', '      --iterationsLeft;\n', '\n', '      Staker storage staker = stakers[_contractStakers[i]];\n', '      uint deposit = staker.deposit;\n', '      uint stake = staker.stakes[_contractAddress];\n', '      stake = deposit < stake ? deposit : stake;\n', '      _stakedOnContract = _stakedOnContract.add(stake);\n', '    }\n', '\n', '    contractStaked = _stakedOnContract;\n', '    isContractStakeCalculated = true;\n', '    processedToStakerIndex = 0;\n', '\n', '    return (_stakedOnContract, true, iterationsLeft);\n', '  }\n', '\n', '  function _processFirstUnstakeRequest() internal {\n', '\n', '    uint firstRequest = unstakeRequests[0].next;\n', '    UnstakeRequest storage unstakeRequest = unstakeRequests[firstRequest];\n', '    address stakerAddress = unstakeRequest.stakerAddress;\n', '    Staker storage staker = stakers[stakerAddress];\n', '\n', '    address contractAddress = unstakeRequest.contractAddress;\n', '    uint deposit = staker.deposit;\n', '    uint initialStake = staker.stakes[contractAddress];\n', '    uint stake = deposit < initialStake ? deposit : initialStake;\n', '\n', '    uint requestedAmount = unstakeRequest.amount;\n', '    uint actualUnstakedAmount = stake < requestedAmount ? stake : requestedAmount;\n', '    staker.stakes[contractAddress] = stake.sub(actualUnstakedAmount);\n', '\n', '    uint pendingUnstakeRequestsTotal = staker.pendingUnstakeRequestsTotal[contractAddress];\n', '    staker.pendingUnstakeRequestsTotal[contractAddress] = pendingUnstakeRequestsTotal.sub(requestedAmount);\n', '\n', '    // update pointer to first unstake request\n', '    unstakeRequests[0].next = unstakeRequest.next;\n', '    delete unstakeRequests[firstRequest];\n', '\n', '    emit Unstaked(contractAddress, stakerAddress, requestedAmount);\n', '  }\n', '\n', '  function _processFirstReward(uint maxIterations) internal returns (bool finished, uint iterationsLeft) {\n', '\n', '    iterationsLeft = maxIterations;\n', '\n', '    Reward storage reward = rewards[firstReward];\n', '    address _contractAddress = reward.contractAddress;\n', '    uint _totalRewardAmount = reward.amount;\n', '\n', '    uint _stakedOnContract;\n', '\n', '    (_stakedOnContract, finished, iterationsLeft) = _calculateContractStake(_contractAddress, iterationsLeft);\n', '\n', '    if (!finished) {\n', '      return (false, iterationsLeft);\n', '    }\n', '\n', '    address[] storage _contractStakers = contractStakers[_contractAddress];\n', '    uint _stakerCount = _contractStakers.length;\n', '    uint _actualRewardAmount = contractRewarded;\n', '\n', '    for (uint i = processedToStakerIndex; i < _stakerCount; i++) {\n', '\n', '      if (iterationsLeft == 0) {\n', '        contractRewarded = _actualRewardAmount;\n', '        processedToStakerIndex = i;\n', '        return (false, iterationsLeft);\n', '      }\n', '\n', '      --iterationsLeft;\n', '\n', '      address _stakerAddress = _contractStakers[i];\n', '\n', '      (uint _stakerRewardAmount, uint _stake) = _rewardStaker(\n', '        _stakerAddress, _contractAddress, _totalRewardAmount, _stakedOnContract\n', '      );\n', '\n', "      // remove 0-amount stakers, similar to what we're doing when processing burns\n", '      if (_stake == 0) {\n', '\n', '        // mark the user as not present in contract stakers array\n', '        Staker storage staker = stakers[_stakerAddress];\n', '        staker.isInContractStakers[_contractAddress] = false;\n', '\n', '        // remove the staker from the contract stakers array\n', '        _contractStakers[i] = _contractStakers[_stakerCount - 1];\n', '        _contractStakers.pop();\n', '        i--;\n', '        _stakerCount--;\n', '\n', "        // since the stake is 0, there's no reward to give\n", '        continue;\n', '      }\n', '\n', '      _actualRewardAmount = _actualRewardAmount.add(_stakerRewardAmount);\n', '    }\n', '\n', '    delete rewards[firstReward];\n', '    contractRewarded = 0;\n', '    processedToStakerIndex = 0;\n', '    isContractStakeCalculated = false;\n', '\n', '    if (++firstReward > lastRewardId) {\n', '      firstReward = 0;\n', '    }\n', '\n', '    tokenController.mint(address(this), _actualRewardAmount);\n', '    emit Rewarded(_contractAddress, _actualRewardAmount, _stakedOnContract);\n', '\n', '    return (true, iterationsLeft);\n', '  }\n', '\n', '  function _rewardStaker(\n', '    address stakerAddress, address contractAddress, uint totalRewardAmount, uint totalStakedOnContract\n', '  ) internal returns (uint rewardedAmount, uint stake) {\n', '\n', '    Staker storage staker = stakers[stakerAddress];\n', '    uint deposit = staker.deposit;\n', '    stake = staker.stakes[contractAddress];\n', '\n', '    if (stake > deposit) {\n', '      stake = deposit;\n', '    }\n', '\n', '    // prevent division by zero and set stake to zero\n', '    if (totalStakedOnContract == 0 || stake == 0) {\n', '      staker.stakes[contractAddress] = 0;\n', '      return (0, 0);\n', '    }\n', '\n', '    // reward = staker_stake / total_contract_stake * total_reward\n', '    rewardedAmount = totalRewardAmount.mul(stake).div(totalStakedOnContract);\n', '    staker.reward = staker.reward.add(rewardedAmount);\n', '  }\n', '\n', '  function updateUintParameters(bytes8 code, uint value) external onlyGovernance {\n', '\n', '    if (code == "MIN_STAK") {\n', '      MIN_STAKE = value;\n', '      return;\n', '    }\n', '\n', '    if (code == "MAX_EXPO") {\n', '      MAX_EXPOSURE = value;\n', '      return;\n', '    }\n', '\n', '    if (code == "MIN_UNST") {\n', '      MIN_UNSTAKE = value;\n', '      return;\n', '    }\n', '\n', '    if (code == "UNST_LKT") {\n', '      UNSTAKE_LOCK_TIME = value;\n', '      return;\n', '    }\n', '  }\n', '\n', '  function initialize() public {\n', '    require(!initialized, "Contract is already initialized");\n', '    tokenController.addToWhitelist(address(this));\n', '    initialized = true;\n', '  }\n', '\n', '  function initializeRewardRoundsStart() public {\n', "    require(REWARD_ROUNDS_START == 0, 'REWARD_ROUNDS_START already initialized');\n", '    REWARD_ROUNDS_START = 1600074000;\n', '    REWARD_ROUND_DURATION = 7 days;\n', '\n', '    bytes32 location = MIGRATION_LAST_ID_POSITION;\n', '    uint lastRewardIdValue = lastRewardId;\n', '    assembly {\n', '      sstore(location, lastRewardIdValue)\n', '    }\n', '  }\n', '\n', '  function changeDependentContractAddress() public {\n', '\n', '    token = NXMToken(master.tokenAddress());\n', '    tokenController = ITokenController(master.getLatestAddress("TC"));\n', '\n', '    if (!initialized) {\n', '      initialize();\n', '    }\n', '\n', '    if (REWARD_ROUNDS_START == 0) {\n', '      initializeRewardRoundsStart();\n', '    }\n', '  }\n', '\n', '  event RewardsMigrationCompleted(\n', '    bool finished,\n', '    uint firstReward,\n', '    uint iterationsLeft\n', '  );\n', '\n', '  bytes32 private constant MIGRATION_LAST_ID_POSITION = keccak256("nexusmutual.pooledstaking.MIGRATION_LAST_ID_POINTER");\n', '\n', '  function migrateRewardsToAccumulatedRewards(uint maxIterations) external returns (bool finished, uint iterationsLeft)  {\n', '    require(firstReward != 0, "Nothing to migrate");\n', '\n', '    uint ACCUMULATED_REWARDS_MIGRATION_LAST_ID;\n', '    bytes32 location = MIGRATION_LAST_ID_POSITION;\n', '    assembly {\n', '      ACCUMULATED_REWARDS_MIGRATION_LAST_ID := sload(location)\n', '    }\n', '\n', '    require(firstReward <= ACCUMULATED_REWARDS_MIGRATION_LAST_ID, "Exceeded last migration id");\n', '\n', '\n', '    iterationsLeft = maxIterations;\n', '\n', '    while (!finished && iterationsLeft > 0) {\n', '\n', '      iterationsLeft--;\n', '\n', '      Reward storage reward = rewards[firstReward];\n', '      ContractReward storage accumulatedReward = accumulatedRewards[reward.contractAddress];\n', '      accumulatedReward.amount = accumulatedReward.amount.add(reward.amount);\n', '      emit RewardAdded(reward.contractAddress, reward.amount);\n', '\n', '      delete rewards[firstReward];\n', '      firstReward++;\n', '\n', '      if (firstReward > ACCUMULATED_REWARDS_MIGRATION_LAST_ID) {\n', '        finished = true;\n', '      }\n', '      if (firstReward > lastRewardId) {\n', '        firstReward = 0;\n', '        finished = true;\n', '      }\n', '    }\n', '\n', '    if (finished) {\n', '      assembly {\n', '        sstore(location, 0)\n', '      }\n', '    }\n', '\n', '    emit RewardsMigrationCompleted(finished, firstReward, iterationsLeft);\n', '    return (finished, iterationsLeft);\n', '  }\n', '}']