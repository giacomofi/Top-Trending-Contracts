['// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/Math.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the average of two numbers. Since these are integers,\n', '     * averages of an even and odd number cannot be represented, and will be\n', '     * rounded down.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: solidity-rlp/contracts/RLPReader.sol\n', '\n', '/*\n', '* @author Hamdi Allam hamdi.allam97@gmail.com\n', '* Please reach out with any questions or concerns\n', '*/\n', 'pragma solidity ^0.5.0;\n', '\n', 'library RLPReader {\n', '    uint8 constant STRING_SHORT_START = 0x80;\n', '    uint8 constant STRING_LONG_START  = 0xb8;\n', '    uint8 constant LIST_SHORT_START   = 0xc0;\n', '    uint8 constant LIST_LONG_START    = 0xf8;\n', '    uint8 constant WORD_SIZE = 32;\n', '\n', '    struct RLPItem {\n', '        uint len;\n', '        uint memPtr;\n', '    }\n', '\n', '    struct Iterator {\n', "        RLPItem item;   // Item that's being iterated over.\n", '        uint nextPtr;   // Position of the next item in the list.\n', '    }\n', '\n', '    /*\n', '    * @dev Returns the next element in the iteration. Reverts if it has not next element.\n', '    * @param self The iterator.\n', '    * @return The next element in the iteration.\n', '    */\n', '    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n', '        require(hasNext(self));\n', '\n', '        uint ptr = self.nextPtr;\n', '        uint itemLength = _itemLength(ptr);\n', '        self.nextPtr = ptr + itemLength;\n', '\n', '        return RLPItem(itemLength, ptr);\n', '    }\n', '\n', '    /*\n', '    * @dev Returns true if the iteration has more elements.\n', '    * @param self The iterator.\n', '    * @return true if the iteration has more elements.\n', '    */\n', '    function hasNext(Iterator memory self) internal pure returns (bool) {\n', '        RLPItem memory item = self.item;\n', '        return self.nextPtr < item.memPtr + item.len;\n', '    }\n', '\n', '    /*\n', '    * @param item RLP encoded bytes\n', '    */\n', '    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n', '        uint memPtr;\n', '        assembly {\n', '            memPtr := add(item, 0x20)\n', '        }\n', '\n', '        return RLPItem(item.length, memPtr);\n', '    }\n', '\n', '    /*\n', '    * @dev Create an iterator. Reverts if item is not a list.\n', '    * @param self The RLP item.\n', "    * @return An 'Iterator' over the item.\n", '    */\n', '    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n', '        require(isList(self));\n', '\n', '        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\n', '        return Iterator(self, ptr);\n', '    }\n', '\n', '    /*\n', '    * @param item RLP encoded bytes\n', '    */\n', '    function rlpLen(RLPItem memory item) internal pure returns (uint) {\n', '        return item.len;\n', '    }\n', '\n', '    /*\n', '    * @param item RLP encoded bytes\n', '    */\n', '    function payloadLen(RLPItem memory item) internal pure returns (uint) {\n', '        return item.len - _payloadOffset(item.memPtr);\n', '    }\n', '\n', '    /*\n', '    * @param item RLP encoded list in bytes\n', '    */\n', '    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n', '        require(isList(item));\n', '\n', '        uint items = numItems(item);\n', '        RLPItem[] memory result = new RLPItem[](items);\n', '\n', '        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n', '        uint dataLen;\n', '        for (uint i = 0; i < items; i++) {\n', '            dataLen = _itemLength(memPtr);\n', '            result[i] = RLPItem(dataLen, memPtr); \n', '            memPtr = memPtr + dataLen;\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    // @return indicator whether encoded payload is a list. negate this function call for isData.\n', '    function isList(RLPItem memory item) internal pure returns (bool) {\n', '        if (item.len == 0) return false;\n', '\n', '        uint8 byte0;\n', '        uint memPtr = item.memPtr;\n', '        assembly {\n', '            byte0 := byte(0, mload(memPtr))\n', '        }\n', '\n', '        if (byte0 < LIST_SHORT_START)\n', '            return false;\n', '        return true;\n', '    }\n', '\n', '    /** RLPItem conversions into data types **/\n', '\n', '    // @returns raw rlp encoding in bytes\n', '    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n', '        bytes memory result = new bytes(item.len);\n', '        if (result.length == 0) return result;\n', '        \n', '        uint ptr;\n', '        assembly {\n', '            ptr := add(0x20, result)\n', '        }\n', '\n', '        copy(item.memPtr, ptr, item.len);\n', '        return result;\n', '    }\n', '\n', '    // any non-zero byte is considered true\n', '    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n', '        require(item.len == 1);\n', '        uint result;\n', '        uint memPtr = item.memPtr;\n', '        assembly {\n', '            result := byte(0, mload(memPtr))\n', '        }\n', '\n', '        return result == 0 ? false : true;\n', '    }\n', '\n', '    function toAddress(RLPItem memory item) internal pure returns (address) {\n', '        // 1 byte for the length prefix\n', '        require(item.len == 21);\n', '\n', '        return address(toUint(item));\n', '    }\n', '\n', '    function toUint(RLPItem memory item) internal pure returns (uint) {\n', '        require(item.len > 0 && item.len <= 33);\n', '\n', '        uint offset = _payloadOffset(item.memPtr);\n', '        uint len = item.len - offset;\n', '\n', '        uint result;\n', '        uint memPtr = item.memPtr + offset;\n', '        assembly {\n', '            result := mload(memPtr)\n', '\n', '            // shfit to the correct location if neccesary\n', '            if lt(len, 32) {\n', '                result := div(result, exp(256, sub(32, len)))\n', '            }\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    // enforces 32 byte length\n', '    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\n', '        // one byte prefix\n', '        require(item.len == 33);\n', '\n', '        uint result;\n', '        uint memPtr = item.memPtr + 1;\n', '        assembly {\n', '            result := mload(memPtr)\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n', '        require(item.len > 0);\n', '\n', '        uint offset = _payloadOffset(item.memPtr);\n', '        uint len = item.len - offset; // data length\n', '        bytes memory result = new bytes(len);\n', '\n', '        uint destPtr;\n', '        assembly {\n', '            destPtr := add(0x20, result)\n', '        }\n', '\n', '        copy(item.memPtr + offset, destPtr, len);\n', '        return result;\n', '    }\n', '\n', '    /*\n', '    * Private Helpers\n', '    */\n', '\n', '    // @return number of payload items inside an encoded list.\n', '    function numItems(RLPItem memory item) private pure returns (uint) {\n', '        if (item.len == 0) return 0;\n', '\n', '        uint count = 0;\n', '        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\n', '        uint endPtr = item.memPtr + item.len;\n', '        while (currPtr < endPtr) {\n', '           currPtr = currPtr + _itemLength(currPtr); // skip over an item\n', '           count++;\n', '        }\n', '\n', '        return count;\n', '    }\n', '\n', '    // @return entire rlp item byte length\n', '    function _itemLength(uint memPtr) private pure returns (uint) {\n', '        uint itemLen;\n', '        uint byte0;\n', '        assembly {\n', '            byte0 := byte(0, mload(memPtr))\n', '        }\n', '\n', '        if (byte0 < STRING_SHORT_START)\n', '            itemLen = 1;\n', '        \n', '        else if (byte0 < STRING_LONG_START)\n', '            itemLen = byte0 - STRING_SHORT_START + 1;\n', '\n', '        else if (byte0 < LIST_SHORT_START) {\n', '            assembly {\n', '                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n', '                memPtr := add(memPtr, 1) // skip over the first byte\n', '                \n', '                /* 32 byte word size */\n', '                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n', '                itemLen := add(dataLen, add(byteLen, 1))\n', '            }\n', '        }\n', '\n', '        else if (byte0 < LIST_LONG_START) {\n', '            itemLen = byte0 - LIST_SHORT_START + 1;\n', '        } \n', '\n', '        else {\n', '            assembly {\n', '                let byteLen := sub(byte0, 0xf7)\n', '                memPtr := add(memPtr, 1)\n', '\n', '                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n', '                itemLen := add(dataLen, add(byteLen, 1))\n', '            }\n', '        }\n', '\n', '        return itemLen;\n', '    }\n', '\n', '    // @return number of bytes until the data\n', '    function _payloadOffset(uint memPtr) private pure returns (uint) {\n', '        uint byte0;\n', '        assembly {\n', '            byte0 := byte(0, mload(memPtr))\n', '        }\n', '\n', '        if (byte0 < STRING_SHORT_START) \n', '            return 0;\n', '        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\n', '            return 1;\n', '        else if (byte0 < LIST_SHORT_START)  // being explicit\n', '            return byte0 - (STRING_LONG_START - 1) + 1;\n', '        else\n', '            return byte0 - (LIST_LONG_START - 1) + 1;\n', '    }\n', '\n', '    /*\n', '    * @param src Pointer to source\n', '    * @param dest Pointer to destination\n', '    * @param len Amount of memory to copy from the source\n', '    */\n', '    function copy(uint src, uint dest, uint len) private pure {\n', '        if (len == 0) return;\n', '\n', '        // copy as many word sizes as possible\n', '        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '\n', '            src += WORD_SIZE;\n', '            dest += WORD_SIZE;\n', '        }\n', '\n', '        // left over bytes. Mask is used to remove unwanted bytes from the word\n', '        uint mask = 256 ** (WORD_SIZE - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask)) // zero out src\n', '            let destpart := and(mload(dest), mask) // retrieve the bytes\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/common/lib/BytesLib.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'library BytesLib {\n', '    function concat(bytes memory _preBytes, bytes memory _postBytes)\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        bytes memory tempBytes;\n', '        assembly {\n', '            // Get a location of some free memory and store it in tempBytes as\n', '            // Solidity does for memory variables.\n', '            tempBytes := mload(0x40)\n', '\n', '            // Store the length of the first bytes array at the beginning of\n', '            // the memory for tempBytes.\n', '            let length := mload(_preBytes)\n', '            mstore(tempBytes, length)\n', '\n', '            // Maintain a memory counter for the current write location in the\n', '            // temp bytes array by adding the 32 bytes for the array length to\n', '            // the starting location.\n', '            let mc := add(tempBytes, 0x20)\n', '            // Stop copying when the memory counter reaches the length of the\n', '            // first bytes array.\n', '            let end := add(mc, length)\n', '\n', '            for {\n', '                // Initialize a copy counter to the start of the _preBytes data,\n', '                // 32 bytes into its memory.\n', '                let cc := add(_preBytes, 0x20)\n', '            } lt(mc, end) {\n', '                // Increase both counters by 32 bytes each iteration.\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                // Write the _preBytes data into the tempBytes memory 32 bytes\n', '                // at a time.\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Add the length of _postBytes to the current length of tempBytes\n', '            // and store it as the new length in the first 32 bytes of the\n', '            // tempBytes memory.\n', '            length := mload(_postBytes)\n', '            mstore(tempBytes, add(length, mload(tempBytes)))\n', '\n', '            // Move the memory counter back from a multiple of 0x20 to the\n', '            // actual end of the _preBytes data.\n', '            mc := end\n', '            // Stop copying when the memory counter reaches the new combined\n', '            // length of the arrays.\n', '            end := add(mc, length)\n', '\n', '            for {\n', '                let cc := add(_postBytes, 0x20)\n', '            } lt(mc, end) {\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Update the free-memory pointer by padding our last write location\n', '            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n', '            // next 32 byte block, then round down to the nearest multiple of\n', '            // 32. If the sum of the length of the two arrays is zero then add\n', '            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n', '            mstore(\n', '                0x40,\n', '                and(\n', '                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n', '                    not(31) // Round down to the nearest 32 bytes.\n', '                )\n', '            )\n', '        }\n', '        return tempBytes;\n', '    }\n', '\n', '    function slice(bytes memory _bytes, uint256 _start, uint256 _length)\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        require(_bytes.length >= (_start + _length));\n', '        bytes memory tempBytes;\n', '        assembly {\n', '            switch iszero(_length)\n', '                case 0 {\n', '                    // Get a location of some free memory and store it in tempBytes as\n', '                    // Solidity does for memory variables.\n', '                    tempBytes := mload(0x40)\n', '\n', '                    // The first word of the slice result is potentially a partial\n', '                    // word read from the original array. To read it, we calculate\n', '                    // the length of that partial word and start copying that many\n', '                    // bytes into the array. The first word we copy will start with\n', "                    // data we don't care about, but the last `lengthmod` bytes will\n", '                    // land at the beginning of the contents of the new array. When\n', "                    // we're done copying, we overwrite the full first word with\n", '                    // the actual length of the slice.\n', '                    let lengthmod := and(_length, 31)\n', '\n', '                    // The multiplication in the next line is necessary\n', '                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n', "                    // the following copy loop was copying the origin's length\n", '                    // and then ending prematurely not copying everything it should.\n', '                    let mc := add(\n', '                        add(tempBytes, lengthmod),\n', '                        mul(0x20, iszero(lengthmod))\n', '                    )\n', '                    let end := add(mc, _length)\n', '\n', '                    for {\n', '                        // The multiplication in the next line has the same exact purpose\n', '                        // as the one above.\n', '                        let cc := add(\n', '                            add(\n', '                                add(_bytes, lengthmod),\n', '                                mul(0x20, iszero(lengthmod))\n', '                            ),\n', '                            _start\n', '                        )\n', '                    } lt(mc, end) {\n', '                        mc := add(mc, 0x20)\n', '                        cc := add(cc, 0x20)\n', '                    } {\n', '                        mstore(mc, mload(cc))\n', '                    }\n', '\n', '                    mstore(tempBytes, _length)\n', '\n', '                    //update free-memory pointer\n', '                    //allocating the array padded to 32 bytes like the compiler does now\n', '                    mstore(0x40, and(add(mc, 31), not(31)))\n', '                }\n', "                //if we want a zero-length slice let's just return a zero-length array\n", '                default {\n', '                    tempBytes := mload(0x40)\n', '                    mstore(0x40, add(tempBytes, 0x20))\n', '                }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    // Pad a bytes array to 32 bytes\n', '    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {\n', '        // may underflow if bytes.length < 32. Hence using SafeMath.sub\n', '        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));\n', '        return concat(newBytes, _bytes);\n', '    }\n', '\n', '    function toBytes32(bytes memory b) internal pure returns (bytes32) {\n', '        require(b.length >= 32, "Bytes array should atleast be 32 bytes");\n', '        bytes32 out;\n', '        for (uint256 i = 0; i < 32; i++) {\n', '            out |= bytes32(b[i] & 0xFF) >> (i * 8);\n', '        }\n', '        return out;\n', '    }\n', '\n', '    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {\n', '        assembly {\n', '            result := mload(add(b, 32))\n', '        }\n', '    }\n', '\n', '    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {\n', '        bytes memory b = new bytes(32);\n', '        for (uint256 i = 0; i < 32; i++) {\n', '            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));\n', '        }\n', '        return b;\n', '    }\n', '\n', '    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {\n', '        _ret = new bytes(32);\n', '        assembly {\n', '            mstore(add(_ret, 32), _num)\n', '        }\n', '    }\n', '\n', '    function toUint(bytes memory _bytes, uint256 _start)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(_bytes.length >= (_start + 32));\n', '        uint256 tempUint;\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '        return tempUint;\n', '    }\n', '\n', '    function toAddress(bytes memory _bytes, uint256 _start)\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        require(_bytes.length >= (_start + 20));\n', '        address tempAddress;\n', '        assembly {\n', '            tempAddress := div(\n', '                mload(add(add(_bytes, 0x20), _start)),\n', '                0x1000000000000000000000000\n', '            )\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '}\n', '\n', '// File: contracts/common/lib/ECVerify.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'library ECVerify {\n', '    function ecrecovery(bytes32 hash, bytes memory sig)\n', '        public\n', '        pure\n', '        returns (address)\n', '    {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        if (sig.length != 65) {\n', '            return address(0x0);\n', '        }\n', '\n', '        assembly {\n', '            r := mload(add(sig, 32))\n', '            s := mload(add(sig, 64))\n', '            v := and(mload(add(sig, 65)), 255)\n', '        }\n', '\n', '        // https://github.com/ethereum/go-ethereum/issues/2053\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        if (v != 27 && v != 28) {\n', '            return address(0x0);\n', '        }\n', '\n', '        // get address out of hash and signature\n', '        address result = ecrecover(hash, v, r, s);\n', '\n', '        // ecrecover returns zero on error\n', '        require(result != address(0x0));\n', '\n', '        return result;\n', '    }\n', '\n', '    function ecrecovery(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n', '        public\n', '        pure\n', '        returns (address)\n', '    {\n', '        // get address out of hash and signature\n', '        address result = ecrecover(hash, v, r, s);\n', '\n', '        // ecrecover returns zero on error\n', '        require(result != address(0x0), "signature verification failed");\n', '\n', '        return result;\n', '    }\n', '\n', '    function ecverify(bytes32 hash, bytes memory sig, address signer)\n', '        public\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return signer == ecrecovery(hash, sig);\n', '    }\n', '}\n', '\n', '// File: contracts/common/lib/Merkle.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'library Merkle {\n', '    function checkMembership(\n', '        bytes32 leaf,\n', '        uint256 index,\n', '        bytes32 rootHash,\n', '        bytes memory proof\n', '    ) public pure returns (bool) {\n', '        require(proof.length % 32 == 0, "Invalid proof length");\n', '        uint256 proofHeight = proof.length / 32;\n', '        // Proof of size n means, height of the tree is n+1.\n', '        // In a tree of height n+1, max #leafs possible is 2 ^ n\n', '        require(index < 2 ** proofHeight, "Leaf index is too big");\n', '\n', '        bytes32 proofElement;\n', '        bytes32 computedHash = leaf;\n', '        for (uint256 i = 32; i <= proof.length; i += 32) {\n', '            assembly {\n', '                proofElement := mload(add(proof, i))\n', '            }\n', '\n', '            if (index % 2 == 0) {\n', '                computedHash = keccak256(\n', '                    abi.encodePacked(computedHash, proofElement)\n', '                );\n', '            } else {\n', '                computedHash = keccak256(\n', '                    abi.encodePacked(proofElement, computedHash)\n', '                );\n', '            }\n', '\n', '            index = index / 2;\n', '        }\n', '        return computedHash == rootHash;\n', '    }\n', '}\n', '\n', '// File: contracts/common/governance/IGovernance.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'interface IGovernance {\n', '    function update(address target, bytes calldata data) external;\n', '}\n', '\n', '// File: contracts/common/governance/Governable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract Governable {\n', '    IGovernance public governance;\n', '\n', '    constructor(address _governance) public {\n', '        governance = IGovernance(_governance);\n', '    }\n', '\n', '    modifier onlyGovernance() {\n', '        require(\n', '            msg.sender == address(governance),\n', '            "Only governance contract is authorized"\n', '        );\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/Lockable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract Lockable {\n', '    bool public locked;\n', '\n', '    modifier onlyWhenUnlocked() {\n', '        _assertUnlocked();\n', '        _;\n', '    }\n', '\n', '    function _assertUnlocked() private view {\n', '        require(!locked, "locked");\n', '    }\n', '\n', '    function lock() public {\n', '        locked = true;\n', '    }\n', '\n', '    function unlock() public {\n', '        locked = false;\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/GovernanceLockable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract GovernanceLockable is Lockable, Governable {\n', '    constructor(address governance) public Governable(governance) {}\n', '\n', '    function lock() public onlyGovernance {\n', '        super.lock();\n', '    }\n', '\n', '    function unlock() public onlyGovernance {\n', '        super.unlock();\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/RootChainable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title RootChainable\n', ' */\n', 'contract RootChainable is Ownable {\n', '    address public rootChain;\n', '\n', '    // Rootchain changed\n', '    event RootChainChanged(\n', '        address indexed previousRootChain,\n', '        address indexed newRootChain\n', '    );\n', '\n', '    //\n', '    // Only root chain\n', '    //\n', '\n', '    // only root chain\n', '    modifier onlyRootChain() {\n', '        require(msg.sender == rootChain);\n', '        _;\n', '    }\n', '\n', '    /**\n', '   * @dev Allows the current owner to change root chain address.\n', '   * @param newRootChain The address to new rootchain.\n', '   */\n', '    function changeRootChain(address newRootChain) public onlyOwner {\n', '        require(newRootChain != address(0));\n', '        emit RootChainChanged(rootChain, newRootChain);\n', '        rootChain = newRootChain;\n', '    }\n', '}\n', '\n', '// File: contracts/root/withdrawManager/IWithdrawManager.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract IWithdrawManager {\n', '    function createExitQueue(address token) external;\n', '\n', '    function verifyInclusion(\n', '        bytes calldata data,\n', '        uint8 offset,\n', '        bool verifyTxInclusion\n', '    ) external view returns (uint256 age);\n', '\n', '    function addExitToQueue(\n', '        address exitor,\n', '        address childToken,\n', '        address rootToken,\n', '        uint256 exitAmountOrTokenId,\n', '        bytes32 txHash,\n', '        bool isRegularExit,\n', '        uint256 priority\n', '    ) external;\n', '\n', '    function addInput(\n', '        uint256 exitId,\n', '        uint256 age,\n', '        address utxoOwner,\n', '        address token\n', '    ) external;\n', '\n', '    function challengeExit(\n', '        uint256 exitId,\n', '        uint256 inputId,\n', '        bytes calldata challengeData,\n', '        address adjudicatorPredicate\n', '    ) external;\n', '}\n', '\n', '// File: contracts/common/Registry.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', 'contract Registry is Governable {\n', '    // @todo hardcode constants\n', '    bytes32 private constant WETH_TOKEN = keccak256("wethToken");\n', '    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");\n', '    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");\n', '    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");\n', '    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");\n', '    bytes32 private constant CHILD_CHAIN = keccak256("childChain");\n', '    bytes32 private constant STATE_SENDER = keccak256("stateSender");\n', '    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");\n', '\n', '    address public erc20Predicate;\n', '    address public erc721Predicate;\n', '\n', '    mapping(bytes32 => address) public contractMap;\n', '    mapping(address => address) public rootToChildToken;\n', '    mapping(address => address) public childToRootToken;\n', '    mapping(address => bool) public proofValidatorContracts;\n', '    mapping(address => bool) public isERC721;\n', '\n', '    enum Type {Invalid, ERC20, ERC721, Custom}\n', '    struct Predicate {\n', '        Type _type;\n', '    }\n', '    mapping(address => Predicate) public predicates;\n', '\n', '    event TokenMapped(address indexed rootToken, address indexed childToken);\n', '    event ProofValidatorAdded(address indexed validator, address indexed from);\n', '    event ProofValidatorRemoved(address indexed validator, address indexed from);\n', '    event PredicateAdded(address indexed predicate, address indexed from);\n', '    event PredicateRemoved(address indexed predicate, address indexed from);\n', '    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\n', '\n', '    constructor(address _governance) public Governable(_governance) {}\n', '\n', '    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\n', '        emit ContractMapUpdated(_key, contractMap[_key], _address);\n', '        contractMap[_key] = _address;\n', '    }\n', '\n', '    /**\n', '     * @dev Map root token to child token\n', '     * @param _rootToken Token address on the root chain\n', '     * @param _childToken Token address on the child chain\n', '     * @param _isERC721 Is the token being mapped ERC721\n', '     */\n', '    function mapToken(\n', '        address _rootToken,\n', '        address _childToken,\n', '        bool _isERC721\n', '    ) external onlyGovernance {\n', '        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");\n', '        rootToChildToken[_rootToken] = _childToken;\n', '        childToRootToken[_childToken] = _rootToken;\n', '        isERC721[_rootToken] = _isERC721;\n', '        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\n', '        emit TokenMapped(_rootToken, _childToken);\n', '    }\n', '\n', '    function addErc20Predicate(address predicate) public onlyGovernance {\n', '        require(predicate != address(0x0), "Can not add null address as predicate");\n', '        erc20Predicate = predicate;\n', '        addPredicate(predicate, Type.ERC20);\n', '    }\n', '\n', '    function addErc721Predicate(address predicate) public onlyGovernance {\n', '        erc721Predicate = predicate;\n', '        addPredicate(predicate, Type.ERC721);\n', '    }\n', '\n', '    function addPredicate(address predicate, Type _type) public onlyGovernance {\n', '        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");\n', '        predicates[predicate]._type = _type;\n', '        emit PredicateAdded(predicate, msg.sender);\n', '    }\n', '\n', '    function removePredicate(address predicate) public onlyGovernance {\n', '        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");\n', '        delete predicates[predicate];\n', '        emit PredicateRemoved(predicate, msg.sender);\n', '    }\n', '\n', '    function getValidatorShareAddress() public view returns (address) {\n', '        return contractMap[VALIDATOR_SHARE];\n', '    }\n', '\n', '    function getWethTokenAddress() public view returns (address) {\n', '        return contractMap[WETH_TOKEN];\n', '    }\n', '\n', '    function getDepositManagerAddress() public view returns (address) {\n', '        return contractMap[DEPOSIT_MANAGER];\n', '    }\n', '\n', '    function getStakeManagerAddress() public view returns (address) {\n', '        return contractMap[STAKE_MANAGER];\n', '    }\n', '\n', '    function getSlashingManagerAddress() public view returns (address) {\n', '        return contractMap[SLASHING_MANAGER];\n', '    }\n', '\n', '    function getWithdrawManagerAddress() public view returns (address) {\n', '        return contractMap[WITHDRAW_MANAGER];\n', '    }\n', '\n', '    function getChildChainAndStateSender() public view returns (address, address) {\n', '        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\n', '    }\n', '\n', '    function isTokenMapped(address _token) public view returns (bool) {\n', '        return rootToChildToken[_token] != address(0x0);\n', '    }\n', '\n', '    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\n', '        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");\n', '        return isERC721[_token];\n', '    }\n', '\n', '    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\n', '        if (isTokenMappedAndIsErc721(_token)) {\n', '            return erc721Predicate;\n', '        }\n', '        return erc20Predicate;\n', '    }\n', '\n', '    function isChildTokenErc721(address childToken) public view returns (bool) {\n', '        address rootToken = childToRootToken[childToken];\n', '        require(rootToken != address(0x0), "Child token is not mapped");\n', '        return isERC721[rootToken];\n', '    }\n', '}\n', '\n', '// File: contracts/staking/stakeManager/IStakeManager.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract IStakeManager {\n', '    // validator replacement\n', '    function startAuction(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        bool acceptDelegation,\n', '        bytes calldata signerPubkey\n', '    ) external;\n', '\n', '    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;\n', '\n', '    function transferFunds(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        address delegator\n', '    ) external returns (bool);\n', '\n', '    function delegationDeposit(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        address delegator\n', '    ) external returns (bool);\n', '\n', '    function stake(\n', '        uint256 amount,\n', '        uint256 heimdallFee,\n', '        bool acceptDelegation,\n', '        bytes calldata signerPubkey\n', '    ) external;\n', '\n', '    function unstake(uint256 validatorId) external;\n', '\n', '    function totalStakedFor(address addr) external view returns (uint256);\n', '\n', '    function stakeFor(\n', '        address user,\n', '        uint256 amount,\n', '        uint256 heimdallFee,\n', '        bool acceptDelegation,\n', '        bytes memory signerPubkey\n', '    ) public;\n', '\n', '    function checkSignatures(\n', '        uint256 blockInterval,\n', '        bytes32 voteHash,\n', '        bytes32 stateRoot,\n', '        address proposer,\n', '        bytes memory sigs\n', '    ) public returns (uint256);\n', '\n', '    function updateValidatorState(uint256 validatorId, int256 amount) public;\n', '\n', '    function ownerOf(uint256 tokenId) public view returns (address);\n', '\n', '    function slash(bytes memory slashingInfoList) public returns (uint256);\n', '\n', '    function validatorStake(uint256 validatorId) public view returns (uint256);\n', '\n', '    function epoch() public view returns (uint256);\n', '\n', '    function withdrawalDelay() public view returns (uint256);\n', '}\n', '\n', '// File: contracts/staking/validatorShare/IValidatorShare.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '// note this contract interface is only for stakeManager use\n', 'contract IValidatorShare {\n', '    function withdrawRewardsValidator() external returns (uint256);\n', '\n', '    function addProposerBonus(uint256 _rewards, uint256 valStake) public;\n', '\n', '    function withdrawRewards() public;\n', '\n', '    function unstakeClaimTokens() public;\n', '\n', '    function getLiquidRewards(address user) public view returns (uint256);\n', '    \n', '    function getActiveAmount() external view returns (uint256);\n', '\n', '    function owner() public view returns (address);\n', '\n', '    function restake() public;\n', '\n', '    function updateRewards(\n', '        uint256 _reward,\n', '        uint256 _totalStake,\n', '        uint256 validatorStake\n', '    ) external returns (uint256);\n', '\n', '    function unlockContract() external returns (uint256);\n', '\n', '    function lockContract() external returns (uint256);\n', '\n', '    function drain(\n', '        address token,\n', '        address payable destination,\n', '        uint256 amount\n', '    ) external;\n', '\n', '    function slash(uint256 valPow, uint256 totalAmountToSlash) external returns (uint256);\n', '\n', '    function updateDelegation(bool delegation) external;\n', '\n', '    function migrateOut(address user, uint256 amount) external;\n', '\n', '    function migrateIn(address user, uint256 amount) external;\n', '}\n', '\n', '// File: contracts/staking/StakingInfo.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// dummy interface to avoid cyclic dependency\n', 'contract IStakeManagerLocal {\n', '    enum Status {Inactive, Active, Locked, Unstaked}\n', '\n', '    struct Validator {\n', '        uint256 amount;\n', '        uint256 reward;\n', '        uint256 activationEpoch;\n', '        uint256 deactivationEpoch;\n', '        uint256 jailTime;\n', '        address signer;\n', '        address contractAddress;\n', '        Status status;\n', '    }\n', '\n', '    mapping(uint256 => Validator) public validators;\n', '    bytes32 public accountStateRoot;\n', '    uint256 public activeAmount; // delegation amount from validator contract\n', '    uint256 public validatorRewards;\n', '\n', '    function currentValidatorSetTotalStake() public view returns (uint256);\n', '\n', '    // signer to Validator mapping\n', '    function signerToValidator(address validatorAddress)\n', '        public\n', '        view\n', '        returns (uint256);\n', '\n', '    function isValidator(uint256 validatorId) public view returns (bool);\n', '}\n', '\n', '\n', 'contract StakingInfo is Ownable {\n', '    using SafeMath for uint256;\n', '    mapping(uint256 => uint256) public validatorNonce;\n', '\n', "    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.\n", '    /// @param signer validator address.\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', "    /// @param activationEpoch validator's first epoch as proposer.\n", '    /// @param amount staking amount.\n', '    /// @param total total staking amount.\n', '    /// @param signerPubkey public key of the validator\n', '    event Staked(\n', '        address indexed signer,\n', '        uint256 indexed validatorId,\n', '        uint256 nonce,\n', '        uint256 indexed activationEpoch,\n', '        uint256 amount,\n', '        uint256 total,\n', '        bytes signerPubkey\n', '    );\n', '\n', "    /// @dev Emitted when validator unstakes in 'unstakeClaim()'\n", '    /// @param user address of the validator.\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param amount staking amount.\n', '    /// @param total total staking amount.\n', '    event Unstaked(\n', '        address indexed user,\n', '        uint256 indexed validatorId,\n', '        uint256 amount,\n', '        uint256 total\n', '    );\n', '\n', "    /// @dev Emitted when validator unstakes in '_unstake()'.\n", '    /// @param user address of the validator.\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', '    /// @param deactivationEpoch last epoch for validator.\n', '    /// @param amount staking amount.\n', '    event UnstakeInit(\n', '        address indexed user,\n', '        uint256 indexed validatorId,\n', '        uint256 nonce,\n', '        uint256 deactivationEpoch,\n', '        uint256 indexed amount\n', '    );\n', '\n', "    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.\n", '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', '    /// @param oldSigner old address of the validator.\n', '    /// @param newSigner new address of the validator.\n', '    /// @param signerPubkey public key of the validator.\n', '    event SignerChange(\n', '        uint256 indexed validatorId,\n', '        uint256 nonce,\n', '        address indexed oldSigner,\n', '        address indexed newSigner,\n', '        bytes signerPubkey\n', '    );\n', '    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);\n', '    event Jailed(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed exitEpoch,\n', '        address indexed signer\n', '    );\n', '    event UnJailed(uint256 indexed validatorId, address indexed signer);\n', '    event Slashed(uint256 indexed nonce, uint256 indexed amount);\n', '    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);\n', '    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);\n', '    event ProposerBonusChange(\n', '        uint256 newProposerBonus,\n', '        uint256 oldProposerBonus\n', '    );\n', '\n', '    event RewardUpdate(uint256 newReward, uint256 oldReward);\n', '\n', '    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', '    /// @param newAmount the updated stake amount.\n', '    event StakeUpdate(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed nonce,\n', '        uint256 indexed newAmount\n', '    );\n', '    event ClaimRewards(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed amount,\n', '        uint256 indexed totalAmount\n', '    );\n', '    event StartAuction(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed amount,\n', '        uint256 indexed auctionAmount\n', '    );\n', '    event ConfirmAuction(\n', '        uint256 indexed newValidatorId,\n', '        uint256 indexed oldValidatorId,\n', '        uint256 indexed amount\n', '    );\n', '    event TopUpFee(address indexed user, uint256 indexed fee);\n', '    event ClaimFee(address indexed user, uint256 indexed fee);\n', '    // Delegator events\n', '    event ShareMinted(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed amount,\n', '        uint256 tokens\n', '    );\n', '    event ShareBurned(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed amount,\n', '        uint256 tokens\n', '    );\n', '    event DelegatorClaimedRewards(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed rewards\n', '    );\n', '    event DelegatorRestaked(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed totalStaked\n', '    );\n', '    event DelegatorUnstaked(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 amount\n', '    );\n', '    event UpdateCommissionRate(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed newCommissionRate,\n', '        uint256 indexed oldCommissionRate\n', '    );\n', '\n', '    Registry public registry;\n', '\n', '    modifier onlyValidatorContract(uint256 validatorId) {\n', '        address _contract;\n', '        (, , , , , , _contract, ) = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        )\n', '            .validators(validatorId);\n', '        require(_contract == msg.sender,\n', '        "Invalid sender, not validator");\n', '        _;\n', '    }\n', '\n', '    modifier StakeManagerOrValidatorContract(uint256 validatorId) {\n', '        address _contract;\n', '        address _stakeManager = registry.getStakeManagerAddress();\n', '        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(\n', '            validatorId\n', '        );\n', '        require(_contract == msg.sender || _stakeManager == msg.sender,\n', '        "Invalid sender, not stake manager or validator contract");\n', '        _;\n', '    }\n', '\n', '    modifier onlyStakeManager() {\n', '        require(registry.getStakeManagerAddress() == msg.sender,\n', '        "Invalid sender, not stake manager");\n', '        _;\n', '    }\n', '    modifier onlySlashingManager() {\n', '        require(registry.getSlashingManagerAddress() == msg.sender,\n', '        "Invalid sender, not slashing manager");\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry) public {\n', '        registry = Registry(_registry);\n', '    }\n', '\n', '    function updateNonce(\n', '        uint256[] calldata validatorIds,\n', '        uint256[] calldata nonces\n', '    ) external onlyOwner {\n', '        require(validatorIds.length == nonces.length, "args length mismatch");\n', '\n', '        for (uint256 i = 0; i < validatorIds.length; ++i) {\n', '            validatorNonce[validatorIds[i]] = nonces[i];\n', '        }\n', '    } \n', '\n', '    function logStaked(\n', '        address signer,\n', '        bytes memory signerPubkey,\n', '        uint256 validatorId,\n', '        uint256 activationEpoch,\n', '        uint256 amount,\n', '        uint256 total\n', '    ) public onlyStakeManager {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit Staked(\n', '            signer,\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            activationEpoch,\n', '            amount,\n', '            total,\n', '            signerPubkey\n', '        );\n', '    }\n', '\n', '    function logUnstaked(\n', '        address user,\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        uint256 total\n', '    ) public onlyStakeManager {\n', '        emit Unstaked(user, validatorId, amount, total);\n', '    }\n', '\n', '    function logUnstakeInit(\n', '        address user,\n', '        uint256 validatorId,\n', '        uint256 deactivationEpoch,\n', '        uint256 amount\n', '    ) public onlyStakeManager {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit UnstakeInit(\n', '            user,\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            deactivationEpoch,\n', '            amount\n', '        );\n', '    }\n', '\n', '    function logSignerChange(\n', '        uint256 validatorId,\n', '        address oldSigner,\n', '        address newSigner,\n', '        bytes memory signerPubkey\n', '    ) public onlyStakeManager {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit SignerChange(\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            oldSigner,\n', '            newSigner,\n', '            signerPubkey\n', '        );\n', '    }\n', '\n', '    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit Restaked(validatorId, amount, total);\n', '    }\n', '\n', '    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit Jailed(validatorId, exitEpoch, signer);\n', '    }\n', '\n', '    function logUnjailed(uint256 validatorId, address signer)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit UnJailed(validatorId, signer);\n', '    }\n', '\n', '    function logSlashed(uint256 nonce, uint256 amount)\n', '        public\n', '        onlySlashingManager\n', '    {\n', '        emit Slashed(nonce, amount);\n', '    }\n', '\n', '    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit ThresholdChange(newThreshold, oldThreshold);\n', '    }\n', '\n', '    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit DynastyValueChange(newDynasty, oldDynasty);\n', '    }\n', '\n', '    function logProposerBonusChange(\n', '        uint256 newProposerBonus,\n', '        uint256 oldProposerBonus\n', '    ) public onlyStakeManager {\n', '        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);\n', '    }\n', '\n', '    function logRewardUpdate(uint256 newReward, uint256 oldReward)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit RewardUpdate(newReward, oldReward);\n', '    }\n', '\n', '    function logStakeUpdate(uint256 validatorId)\n', '        public\n', '        StakeManagerOrValidatorContract(validatorId)\n', '    {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit StakeUpdate(\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            totalValidatorStake(validatorId)\n', '        );\n', '    }\n', '\n', '    function logClaimRewards(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        uint256 totalAmount\n', '    ) public onlyStakeManager {\n', '        emit ClaimRewards(validatorId, amount, totalAmount);\n', '    }\n', '\n', '    function logStartAuction(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        uint256 auctionAmount\n', '    ) public onlyStakeManager {\n', '        emit StartAuction(validatorId, amount, auctionAmount);\n', '    }\n', '\n', '    function logConfirmAuction(\n', '        uint256 newValidatorId,\n', '        uint256 oldValidatorId,\n', '        uint256 amount\n', '    ) public onlyStakeManager {\n', '        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);\n', '    }\n', '\n', '    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {\n', '        emit TopUpFee(user, fee);\n', '    }\n', '\n', '    function logClaimFee(address user, uint256 fee) public onlyStakeManager {\n', '        emit ClaimFee(user, fee);\n', '    }\n', '\n', '    function getStakerDetails(uint256 validatorId)\n', '        public\n', '        view\n', '        returns (\n', '            uint256 amount,\n', '            uint256 reward,\n', '            uint256 activationEpoch,\n', '            uint256 deactivationEpoch,\n', '            address signer,\n', '            uint256 _status\n', '        )\n', '    {\n', '        IStakeManagerLocal stakeManager = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        );\n', '        address _contract;\n', '        IStakeManagerLocal.Status status;\n', '        (\n', '            amount,\n', '            reward,\n', '            activationEpoch,\n', '            deactivationEpoch,\n', '            ,\n', '            signer,\n', '            _contract,\n', '            status\n', '        ) = stakeManager.validators(validatorId);\n', '        _status = uint256(status);\n', '        if (_contract != address(0x0)) {\n', '            reward += IStakeManagerLocal(_contract).validatorRewards();\n', '        }\n', '    }\n', '\n', '    function totalValidatorStake(uint256 validatorId)\n', '        public\n', '        view\n', '        returns (uint256 validatorStake)\n', '    {\n', '        address contractAddress;\n', '        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        )\n', '            .validators(validatorId);\n', '        if (contractAddress != address(0x0)) {\n', '            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();\n', '        }\n', '    }\n', '\n', '    function getAccountStateRoot()\n', '        public\n', '        view\n', '        returns (bytes32 accountStateRoot)\n', '    {\n', '        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())\n', '            .accountStateRoot();\n', '    }\n', '\n', '    function getValidatorContractAddress(uint256 validatorId)\n', '        public\n', '        view\n', '        returns (address ValidatorContract)\n', '    {\n', '        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        )\n', '            .validators(validatorId);\n', '    }\n', '\n', '    // validator Share contract logging func\n', '    function logShareMinted(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 amount,\n', '        uint256 tokens\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit ShareMinted(validatorId, user, amount, tokens);\n', '    }\n', '\n', '    function logShareBurned(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 amount,\n', '        uint256 tokens\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit ShareBurned(validatorId, user, amount, tokens);\n', '    }\n', '\n', '    function logDelegatorClaimRewards(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 rewards\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit DelegatorClaimedRewards(validatorId, user, rewards);\n', '    }\n', '\n', '    function logDelegatorRestaked(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 totalStaked\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit DelegatorRestaked(validatorId, user, totalStaked);\n', '    }\n', '\n', '    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)\n', '        public\n', '        onlyValidatorContract(validatorId)\n', '    {\n', '        emit DelegatorUnstaked(validatorId, user, amount);\n', '    }\n', '\n', '    function logUpdateCommissionRate(\n', '        uint256 validatorId,\n', '        uint256 newCommissionRate,\n', '        uint256 oldCommissionRate\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit UpdateCommissionRate(\n', '            validatorId,\n', '            newCommissionRate,\n', '            oldCommissionRate\n', '        );\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title IERC165\n', ' * @dev https://eips.ethereum.org/EIPS/eip-165\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'contract IERC721Receiver {\n', '    /**\n', '     * @notice Handle the receipt of an NFT\n', '     * @dev The ERC721 smart contract calls this function on the recipient\n', '     * after a `safeTransfer`. This function MUST return the function selector,\n', '     * otherwise the caller will revert the transaction. The selector to be\n', '     * returned can be obtained as `this.onERC721Received.selector`. This\n', '     * function MAY throw to revert and reject the transfer.\n', '     * Note: the ERC721 contract address is always the message sender.\n', '     * @param operator The address which called `safeTransferFrom` function\n', '     * @param from The address which previously owned the token\n', '     * @param tokenId The NFT identifier which is being transferred\n', '     * @param data Additional data with no specified format\n', '     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n', '    public returns (bytes4);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library Address {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/drafts/Counters.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title Counters\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n', ' * of elements in a mapping, issuing ERC721 ids, or counting request ids\n', ' *\n', ' * Include with `using Counters for Counters.Counter;`\n', ' * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\n', ' * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n', ' * directly accessed.\n', ' */\n', 'library Counters {\n', '    using SafeMath for uint256;\n', '\n', '    struct Counter {\n', '        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n', "        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n", '        // this feature: see https://github.com/ethereum/solidity/issues/4637\n', '        uint256 _value; // default: 0\n', '    }\n', '\n', '    function current(Counter storage counter) internal view returns (uint256) {\n', '        return counter._value;\n', '    }\n', '\n', '    function increment(Counter storage counter) internal {\n', '        counter._value += 1;\n', '    }\n', '\n', '    function decrement(Counter storage counter) internal {\n', '        counter._value = counter._value.sub(1);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title ERC165\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Implements ERC165 using a lookup table.\n', ' */\n', 'contract ERC165 is IERC165 {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '    /*\n', '     * 0x01ffc9a7 ===\n', "     *     bytes4(keccak256('supportsInterface(bytes4)'))\n", '     */\n', '\n', '    /**\n', "     * @dev a mapping of interface id to whether or not it's supported\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    /**\n', '     * @dev A contract implementing SupportsInterfaceWithLookup\n', '     * implement ERC165 itself\n', '     */\n', '    constructor () internal {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    /**\n', '     * @dev implement supportsInterface(bytes4) using a lookup table\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev internal method for registering an interface\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff);\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract ERC721 is ERC165, IERC721 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '    using Counters for Counters.Counter;\n', '\n', '    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n', '    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    // Mapping from token ID to owner\n', '    mapping (uint256 => address) private _tokenOwner;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '\n', '    // Mapping from owner to number of owned token\n', '    mapping (address => Counters.Counter) private _ownedTokensCount;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '    /*\n', '     * 0x80ac58cd ===\n', "     *     bytes4(keccak256('balanceOf(address)')) ^\n", "     *     bytes4(keccak256('ownerOf(uint256)')) ^\n", "     *     bytes4(keccak256('approve(address,uint256)')) ^\n", "     *     bytes4(keccak256('getApproved(uint256)')) ^\n", "     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n", "     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\n", "     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n", '     */\n', '\n', '    constructor () public {\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address\n', '     * @param owner address to query the balance of\n', '     * @return uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        require(owner != address(0));\n', '        return _ownedTokensCount[owner].current();\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the owner of the specified token ID\n', '     * @param tokenId uint256 ID of the token to query the owner of\n', '     * @return address currently marked as the owner of the given token ID\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        address owner = _tokenOwner[tokenId];\n', '        require(owner != address(0));\n', '        return owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Approves another address to transfer the given token ID\n', '     * The zero address indicates there is no approved address.\n', '     * There can only be one approved address per token at a given time.\n', '     * Can only be called by the token owner or an approved operator.\n', '     * @param to address to be approved for the given token ID\n', '     * @param tokenId uint256 ID of the token to be approved\n', '     */\n', '    function approve(address to, uint256 tokenId) public {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner);\n', '        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(owner, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the approved address for a token ID, or zero if no address set\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to query the approval of\n', '     * @return address currently approved for the given token ID\n', '     */\n', '    function getApproved(uint256 tokenId) public view returns (address) {\n', '        require(_exists(tokenId));\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Sets or unsets the approval of a given operator\n', '     * An operator is allowed to transfer all tokens of the sender on their behalf\n', '     * @param to operator address to set the approval\n', '     * @param approved representing the status of the approval to be set\n', '     */\n', '    function setApprovalForAll(address to, bool approved) public {\n', '        require(to != msg.sender);\n', '        _operatorApprovals[msg.sender][to] = approved;\n', '        emit ApprovalForAll(msg.sender, to, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev Tells whether an operator is approved by a given owner\n', '     * @param owner owner address which you want to query the approval of\n', '     * @param operator operator address which you want to query the approval of\n', '     * @return bool whether the given operator is approved by the given owner\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the ownership of a given token ID to another address\n', '     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '     * Requires the msg.sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', '        require(_isApprovedOrOwner(msg.sender, tokenId));\n', '\n', '        _transferFrom(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg.sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg.sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes data to send along with a safe transfer check\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n', '        transferFrom(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the specified token exists\n', '     * @param tokenId uint256 ID of the token to query the existence of\n', '     * @return bool whether the token exists\n', '     */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        address owner = _tokenOwner[tokenId];\n', '        return owner != address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the given spender can transfer a given token ID\n', '     * @param spender address of the spender to query\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @return bool whether the msg.sender is approved for the given token ID,\n', '     * is an operator of the owner, or is the owner of the token\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        address owner = ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to mint a new token\n', '     * Reverts if the given token ID already exists\n', '     * @param to The address that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        require(to != address(0));\n', '        require(!_exists(tokenId));\n', '\n', '        _tokenOwner[tokenId] = to;\n', '        _ownedTokensCount[to].increment();\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * Deprecated, use _burn(uint256) instead.\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == owner);\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[owner].decrement();\n', '        _tokenOwner[tokenId] = address(0);\n', '\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(uint256 tokenId) internal {\n', '        _burn(ownerOf(tokenId), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to transfer ownership of a given token ID to another address.\n', '     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == from);\n', '        require(to != address(0));\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[from].decrement();\n', '        _ownedTokensCount[to].increment();\n', '\n', '        _tokenOwner[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke `onERC721Received` on a target address\n', '     * The call is not executed if the target address is not a contract\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return bool whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        internal returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '\n', '        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '\n', '    /**\n', '     * @dev Private function to clear current approval of a given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _clearApproval(uint256 tokenId) private {\n', '        if (_tokenApprovals[tokenId] != address(0)) {\n', '            _tokenApprovals[tokenId] = address(0);\n', '        }\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract IERC721Enumerable is IERC721 {\n', '    function totalSupply() public view returns (uint256);\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n', '\n', '    function tokenByIndex(uint256 index) public view returns (uint256);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n', '    // Mapping from owner to list of owned token IDs\n', '    mapping(address => uint256[]) private _ownedTokens;\n', '\n', '    // Mapping from token ID to index of the owner tokens list\n', '    mapping(uint256 => uint256) private _ownedTokensIndex;\n', '\n', '    // Array with all token ids, used for enumeration\n', '    uint256[] private _allTokens;\n', '\n', '    // Mapping from token id to position in the allTokens array\n', '    mapping(uint256 => uint256) private _allTokensIndex;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n', '    /*\n', '     * 0x780e9d63 ===\n', "     *     bytes4(keccak256('totalSupply()')) ^\n", "     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n", "     *     bytes4(keccak256('tokenByIndex(uint256)'))\n", '     */\n', '\n', '    /**\n', '     * @dev Constructor function\n', '     */\n', '    constructor () public {\n', '        // register the supported interface to conform to ERC721Enumerable via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token ID at a given index of the tokens list of the requested owner\n', '     * @param owner address owning the tokens list to be accessed\n', '     * @param index uint256 representing the index to be accessed of the requested tokens list\n', '     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n', '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n', '        require(index < balanceOf(owner));\n', '        return _ownedTokens[owner][index];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the total amount of tokens stored by the contract\n', '     * @return uint256 representing the total amount of tokens\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _allTokens.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token ID at a given index of all the tokens in this contract\n', '     * Reverts if the index is greater or equal to the total number of tokens\n', '     * @param index uint256 representing the index to be accessed of the tokens list\n', '     * @return uint256 token ID at the given index of the tokens list\n', '     */\n', '    function tokenByIndex(uint256 index) public view returns (uint256) {\n', '        require(index < totalSupply());\n', '        return _allTokens[index];\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to transfer ownership of a given token ID to another address.\n', '     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        super._transferFrom(from, to, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(from, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to mint a new token\n', '     * Reverts if the given token ID already exists\n', '     * @param to address the beneficiary that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        super._mint(to, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '\n', '        _addTokenToAllTokensEnumeration(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * Deprecated, use _burn(uint256) instead\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        super._burn(owner, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(owner, tokenId);\n', '        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n', '        _ownedTokensIndex[tokenId] = 0;\n', '\n', '        _removeTokenFromAllTokensEnumeration(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the list of token IDs of the requested owner\n', '     * @param owner address owning the tokens\n', '     * @return uint256[] List of token IDs owned by the requested address\n', '     */\n', '    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n', '        return _ownedTokens[owner];\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n", '     * @param to address representing the new owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '     */\n', '    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n', '        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n', '        _ownedTokens[to].push(tokenId);\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to add a token to this extension's token tracking data structures.\n", '     * @param tokenId uint256 ID of the token to be added to the tokens list\n', '     */\n', '    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n', '        _allTokensIndex[tokenId] = _allTokens.length;\n', '        _allTokens.push(tokenId);\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n", '     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n', '     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n', '     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '     */\n', '    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n', "        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n", '        // then delete the last slot (swap and pop).\n', '\n', '        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n', '        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n', '\n', '            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '        }\n', '\n', '        // This also deletes the contents at the last position of the array\n', '        _ownedTokens[from].length--;\n', '\n', "        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n", '        // lastTokenId, or just over the end of the array if the token was the last one).\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's token tracking data structures.\n", '     * This has O(1) time complexity, but alters the order of the _allTokens array.\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list\n', '     */\n', '    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n', '        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n', '        // then delete the last slot (swap and pop).\n', '\n', '        uint256 lastTokenIndex = _allTokens.length.sub(1);\n', '        uint256 tokenIndex = _allTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n', '        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n', "        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n", '        uint256 lastTokenId = _allTokens[lastTokenIndex];\n', '\n', '        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '\n', '        // This also deletes the contents at the last position of the array\n', '        _allTokens.length--;\n', '        _allTokensIndex[tokenId] = 0;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract IERC721Metadata is IERC721 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', 'contract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n', '    // Token name\n', '    string private _name;\n', '\n', '    // Token symbol\n', '    string private _symbol;\n', '\n', '    // Optional mapping for token URIs\n', '    mapping(uint256 => string) private _tokenURIs;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n', '    /*\n', '     * 0x5b5e139f ===\n', "     *     bytes4(keccak256('name()')) ^\n", "     *     bytes4(keccak256('symbol()')) ^\n", "     *     bytes4(keccak256('tokenURI(uint256)'))\n", '     */\n', '\n', '    /**\n', '     * @dev Constructor function\n', '     */\n', '    constructor (string memory name, string memory symbol) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token name\n', '     * @return string representing the token name\n', '     */\n', '    function name() external view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token symbol\n', '     * @return string representing the token symbol\n', '     */\n', '    function symbol() external view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an URI for a given token ID\n', '     * Throws if the token ID does not exist. May return an empty string.\n', '     * @param tokenId uint256 ID of the token to query\n', '     */\n', '    function tokenURI(uint256 tokenId) external view returns (string memory) {\n', '        require(_exists(tokenId));\n', '        return _tokenURIs[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to set the token URI for a given token\n', '     * Reverts if the token ID does not exist\n', '     * @param tokenId uint256 ID of the token to set its URI\n', '     * @param uri string URI to assign\n', '     */\n', '    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n', '        require(_exists(tokenId));\n', '        _tokenURIs[tokenId] = uri;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * Deprecated, use _burn(uint256) instead\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned by the msg.sender\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        super._burn(owner, tokenId);\n', '\n', '        // Clear metadata (if any)\n', '        if (bytes(_tokenURIs[tokenId]).length != 0) {\n', '            delete _tokenURIs[tokenId];\n', '        }\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Full ERC721 Token\n', ' * This implementation includes all the required and some optional functionality of the ERC721 standard\n', ' * Moreover, it includes approve all functionality using operator terminology\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n', '    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n', '        // solhint-disable-previous-line no-empty-blocks\n', '    }\n', '}\n', '\n', '// File: contracts/staking/stakeManager/StakingNFT.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', 'contract StakingNFT is ERC721Full, Ownable {\n', '    constructor(string memory name, string memory symbol)\n', '        public\n', '        ERC721Full(name, symbol)\n', '    {\n', '        // solhint-disable-previous-line no-empty-blocks\n', '    }\n', '\n', '    function mint(address to, uint256 tokenId) public onlyOwner {\n', '        require(\n', '            balanceOf(to) == 0,\n', '            "Validators MUST NOT own multiple stake position"\n', '        );\n', '        _mint(to, tokenId);\n', '    }\n', '\n', '    function burn(uint256 tokenId) public onlyOwner {\n', '        _burn(tokenId);\n', '    }\n', '\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        require(\n', '            balanceOf(to) == 0,\n', '            "Validators MUST NOT own multiple stake position"\n', '        );\n', '        super._transferFrom(from, to, tokenId);\n', '    }\n', '}\n', '\n', '// File: contracts/common/misc/ProxyStorage.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract ProxyStorage is Ownable {\n', '    address internal proxyTo;\n', '}\n', '\n', '// File: contracts/common/misc/ERCProxy.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md\n', '\n', 'interface ERCProxy {\n', '    function proxyType() external pure returns (uint256 proxyTypeId);\n', '    function implementation() external view returns (address codeAddr);\n', '}\n', '\n', '// File: contracts/common/misc/DelegateProxy.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract DelegateProxy is ERCProxy {\n', '    function proxyType() external pure returns (uint256 proxyTypeId) {\n', '        // Upgradeable proxy\n', '        proxyTypeId = 2;\n', '    }\n', '\n', '    function implementation() external view returns (address);\n', '\n', '    function delegatedFwd(address _dst, bytes memory _calldata) internal {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            let result := delegatecall(\n', '                sub(gas, 10000),\n', '                _dst,\n', '                add(_calldata, 0x20),\n', '                mload(_calldata),\n', '                0,\n', '                0\n', '            )\n', '            let size := returndatasize\n', '\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n', '            // if the call returned error data, forward it\n', '            switch result\n', '                case 0 {\n', '                    revert(ptr, size)\n', '                }\n', '                default {\n', '                    return(ptr, size)\n', '                }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/common/misc/UpgradableProxy.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract UpgradableProxy is DelegateProxy {\n', '    event ProxyUpdated(address indexed _new, address indexed _old);\n', '    event OwnerUpdate(address _new, address _old);\n', '\n', '    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");\n', '    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");\n', '\n', '    constructor(address _proxyTo) public {\n', '        setOwner(msg.sender);\n', '        setImplementation(_proxyTo);\n', '    }\n', '\n', '    function() external payable {\n', '        // require(currentContract != 0, "If app code has not been set yet, do not call");\n', '        // Todo: filter out some calls or handle in the end fallback\n', '        delegatedFwd(loadImplementation(), msg.data);\n', '    }\n', '\n', '    modifier onlyProxyOwner() {\n', '        require(loadOwner() == msg.sender, "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    function owner() external view returns(address) {\n', '        return loadOwner();\n', '    }\n', '\n', '    function loadOwner() internal view returns(address) {\n', '        address _owner;\n', '        bytes32 position = OWNER_SLOT;\n', '        assembly {\n', '            _owner := sload(position)\n', '        }\n', '        return _owner;\n', '    }\n', '\n', '    function implementation() external view returns (address) {\n', '        return loadImplementation();\n', '    }\n', '\n', '    function loadImplementation() internal view returns(address) {\n', '        address _impl;\n', '        bytes32 position = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            _impl := sload(position)\n', '        }\n', '        return _impl;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyProxyOwner {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnerUpdate(newOwner, loadOwner());\n', '        setOwner(newOwner);\n', '    }\n', '\n', '    function setOwner(address newOwner) private {\n', '        bytes32 position = OWNER_SLOT;\n', '        assembly {\n', '            sstore(position, newOwner)\n', '        }\n', '    }\n', '\n', '    function updateImplementation(address _newProxyTo) public onlyProxyOwner {\n', '        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");\n', '        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");\n', '\n', '        emit ProxyUpdated(_newProxyTo, loadImplementation());\n', '        \n', '        setImplementation(_newProxyTo);\n', '    }\n', '\n', '    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {\n', '        updateImplementation(_newProxyTo);\n', '\n', '        (bool success, bytes memory returnData) = address(this).call.value(msg.value)(data);\n', '        require(success, string(returnData));\n', '    }\n', '\n', '    function setImplementation(address _newProxyTo) private {\n', '        bytes32 position = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            sstore(position, _newProxyTo)\n', '        }\n', '    }\n', '    \n', '    function isContract(address _target) internal view returns (bool) {\n', '        if (_target == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        uint256 size;\n', '        assembly {\n', '            size := extcodesize(_target)\n', '        }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/staking/validatorShare/ValidatorShareProxy.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract ValidatorShareProxy is UpgradableProxy {\n', '    constructor(address _registry) public UpgradableProxy(_registry) {}\n', '\n', '    function loadImplementation() internal view returns (address) {\n', '        return Registry(super.loadImplementation()).getValidatorShareAddress();\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://eips.ethereum.org/EIPS/eip-20\n', ' * Originally based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' *\n', ' * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n', " * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n", ' * compliant implementations may not do it.\n', ' */\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev Total number of tokens in existence\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param owner The address to query the balance of.\n', '     * @return A uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param owner address The address which owns the funds.\n', '     * @param spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token to a specified address\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another.\n', '     * Note that while this function emits an Approval event, this is not required as per the specification,\n', '     * and other compliant implementations may not emit the event.\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to transfer to\n', '     * @param value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        _transfer(from, to, value);\n', '        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token for a specified addresses\n', '     * @param from The address to transfer from.\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function _transfer(address from, address to, uint256 value) internal {\n', '        require(to != address(0));\n', '\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that mints an amount of the token and assigns it to\n', '     * an account. This encapsulates the modification of balances such that the\n', '     * proper events are emitted.\n', '     * @param account The account that will receive the created tokens.\n', '     * @param value The amount that will be created.\n', '     */\n', '    function _mint(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.add(value);\n', '        _balances[account] = _balances[account].add(value);\n', '        emit Transfer(address(0), account, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account.\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burn(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.sub(value);\n', '        _balances[account] = _balances[account].sub(value);\n', '        emit Transfer(account, address(0), value);\n', '    }\n', '\n', '    /**\n', "     * @dev Approve an address to spend another addresses' tokens.\n", '     * @param owner The address that owns the tokens.\n', '     * @param spender The address that will spend the tokens.\n', '     * @param value The number of tokens that can be spent.\n', '     */\n', '    function _approve(address owner, address spender, uint256 value) internal {\n', '        require(spender != address(0));\n', '        require(owner != address(0));\n', '\n', '        _allowed[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', "     * account, deducting from the sender's allowance for said account. Uses the\n", '     * internal burn function.\n', '     * Emits an Approval event (reflecting the reduced allowance).\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burnFrom(address account, uint256 value) internal {\n', '        _burn(account, value);\n', '        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n', '    }\n', '}\n', '\n', '// File: contracts/common/tokens/ERC20NonTransferable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract ERC20NonTransferable is ERC20 {\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        revert("Disabled");\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/OwnableLockable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract OwnableLockable is Lockable, Ownable {\n', '    function lock() public onlyOwner {\n', '        super.lock();\n', '    }\n', '\n', '    function unlock() public onlyOwner {\n', '        super.unlock();\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/Initializable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract Initializable {\n', '    bool inited = false;\n', '\n', '    modifier initializer() {\n', '        require(!inited, "already inited");\n', '        inited = true;\n', '        \n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/staking/validatorShare/ValidatorShare.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ValidatorShare is IValidatorShare, ERC20NonTransferable, OwnableLockable, Initializable {\n', '    struct DelegatorUnbond {\n', '        uint256 shares;\n', '        uint256 withdrawEpoch;\n', '    }\n', '\n', '    uint256 constant EXCHANGE_RATE_PRECISION = 100;\n', '    // maximum matic possible, even if rate will be 1 and all matic will be staken in one go, it will result in 10 ^ 58 shares\n', '    uint256 constant EXCHANGE_RATE_HIGH_PRECISION = 10 ** 29; \n', '    uint256 constant MAX_COMMISION_RATE = 100;\n', '    uint256 constant REWARD_PRECISION = 10**25;\n', '\n', '    StakingInfo public stakingLogger;\n', '    IStakeManager public stakeManager;\n', '    uint256 public validatorId;\n', '    uint256 public validatorRewards;\n', '    uint256 public commissionRate;\n', '    //last checkpoint where validator updated commission rate\n', '    uint256 public lastCommissionUpdate;\n', '    uint256 public minAmount = 10**18;\n', '\n', '    // deprecated\n', '    uint256 public __totalStake;\n', '    uint256 public rewardPerShare;\n', '    uint256 public activeAmount;\n', '    bool public delegation = true;\n', '\n', '    uint256 public withdrawPool;\n', '    uint256 public withdrawShares;\n', '\n', '    // deprecated\n', '    mapping(address => uint256) __amountStaked;\n', '    mapping(address => DelegatorUnbond) public unbonds;\n', '    mapping(address => uint256) public initalRewardPerShare;\n', '\n', '    modifier onlyValidator() {\n', '        require(stakeManager.ownerOf(validatorId) == msg.sender, "not validator");\n', '        _;\n', '    }\n', '\n', "    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address\n", '    function initialize(uint256 _validatorId, address _stakingLogger, address _stakeManager) external initializer  {\n', '        validatorId = _validatorId;\n', '        stakingLogger = StakingInfo(_stakingLogger);\n', '        stakeManager = IStakeManager(_stakeManager);\n', '        _transferOwnership(_stakeManager);\n', '\n', '        minAmount = 10**18;\n', '        delegation = true;\n', '    }\n', '\n', '    function updateCommissionRate(uint256 newCommissionRate) external onlyValidator {\n', '        uint256 epoch = stakeManager.epoch();\n', '        uint256 _lastCommissionUpdate = lastCommissionUpdate;\n', '\n', '        require( // withdrawalDelay == dynasty\n', '            (_lastCommissionUpdate.add(stakeManager.withdrawalDelay()) <= epoch) || _lastCommissionUpdate == 0, // For initial setting of commission rate\n', '            "Commission rate update cooldown period"\n', '        );\n', '\n', '        require(newCommissionRate <= MAX_COMMISION_RATE, "Commission rate should be in range of 0-100");\n', '        stakingLogger.logUpdateCommissionRate(validatorId, newCommissionRate, commissionRate);\n', '        commissionRate = newCommissionRate;\n', '        lastCommissionUpdate = epoch;\n', '    }\n', '\n', '    function updateRewards(uint256 reward, uint256 checkpointStakePower, uint256 validatorStake)\n', '        external\n', '        onlyOwner\n', '        returns (uint256)\n', '    {\n', '        uint256 combinedStakePower = validatorStake.add(activeAmount); // validator + delegation stake power\n', '        uint256 rewards = combinedStakePower.mul(reward).div(checkpointStakePower);\n', '\n', '        _updateRewards(rewards, validatorStake, combinedStakePower);\n', '        return combinedStakePower;\n', '    }\n', '\n', '    function addProposerBonus(uint256 rewards, uint256 validatorStake) public onlyOwner {\n', '        uint256 combinedStakePower = validatorStake.add(activeAmount);\n', '        _updateRewards(rewards, validatorStake, combinedStakePower);\n', '    }\n', '\n', '    function _updateRewards(uint256 rewards, uint256 validatorStake, uint256 combinedStakePower) internal {\n', '        uint256 _validatorRewards = validatorStake.mul(rewards).div(combinedStakePower);\n', '\n', '        // add validator commission from delegation rewards\n', '        if (commissionRate > 0) {\n', '            _validatorRewards = _validatorRewards.add(\n', '                rewards.sub(_validatorRewards).mul(commissionRate).div(MAX_COMMISION_RATE)\n', '            );\n', '        }\n', '\n', '        validatorRewards = validatorRewards.add(_validatorRewards);\n', '\n', '        uint256 delegatorsRewards = rewards.sub(_validatorRewards);\n', '        uint256 totalShares = totalSupply();\n', '        if (totalShares > 0) {\n', '            rewardPerShare = rewardPerShare.add(\n', '                delegatorsRewards.mul(REWARD_PRECISION).div(totalShares)\n', '            );\n', '        }\n', '    }\n', '\n', '    function withdrawRewardsValidator() external onlyOwner returns (uint256) {\n', '        uint256 _validatorRewards = validatorRewards;\n', '        validatorRewards = 0;\n', '        return _validatorRewards;\n', '    }\n', '\n', '    function _getRatePrecision() private view returns(uint256) {\n', '        // if foundation validator, use old precision\n', '        if (validatorId < 8) {\n', '            return EXCHANGE_RATE_PRECISION;\n', '        } \n', '\n', '        return EXCHANGE_RATE_HIGH_PRECISION;\n', '    }\n', '\n', '    function exchangeRate() public view returns (uint256) {\n', '        uint256 totalShares = totalSupply();\n', '        uint256 precision = _getRatePrecision();\n', '        return\n', '            totalShares == 0\n', '                ? precision\n', '                : activeAmount.mul(precision).div(totalShares);\n', '    }\n', '\n', '    function withdrawExchangeRate() public view returns (uint256) {\n', '        uint256 precision = _getRatePrecision();\n', '        if (validatorId < 8) {\n', '            // fix of potentially broken withdrawals for future unbonding\n', '            // foundation validators have no slashing enabled and thus we can return default exchange rate\n', '            // because without slashing rate will stay constant\n', '            return precision;\n', '        }\n', '\n', '        uint256 _withdrawShares = withdrawShares;\n', '        return\n', '            _withdrawShares == 0\n', '                ? precision\n', '                : withdrawPool.mul(precision).div(_withdrawShares);\n', '    }\n', '\n', '    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) public {\n', '        _buyVoucher(_amount, _minSharesToMint);\n', '    }\n', '\n', '    function _buyVoucher(uint256 _amount, uint256 _minSharesToMint) internal returns(uint256) {\n', '        _withdrawAndTransferReward(msg.sender);\n', '        uint256 amountToDeposit = _buyShares(_amount, _minSharesToMint, msg.sender);\n', '        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), "deposit failed");\n', '        return amountToDeposit;\n', '    }\n', '\n', '    function _getTotalStake(address user) internal view returns(uint256, uint256) {\n', '        uint256 shares = balanceOf(user);\n', '        uint256 rate = exchangeRate();\n', '        if (shares == 0) {\n', '            return (0, rate);\n', '        }\n', '\n', '        return (rate.mul(shares).div(_getRatePrecision()), rate);\n', '    }\n', '\n', '    function restake() public {\n', '        _restake();\n', '    }\n', '\n', '    function _restake() internal returns(uint256) {\n', '        uint256 liquidReward = _withdrawReward(msg.sender);\n', '        require(liquidReward >= minAmount, "Too small rewards to restake");\n', '\n', '        uint256 amountRestaked = _buyShares(liquidReward, 0, msg.sender);\n', '        if (liquidReward > amountRestaked) {\n', '            // return change to the user\n', '            require(stakeManager.transferFunds(validatorId, liquidReward - amountRestaked, msg.sender), "Insufficent rewards");\n', '            stakingLogger.logDelegatorClaimRewards(validatorId, msg.sender, liquidReward - amountRestaked);\n', '        }\n', '\n', '        (uint256 totalStaked, ) = _getTotalStake(msg.sender);\n', '        stakingLogger.logDelegatorRestaked(validatorId, msg.sender, totalStaked);\n', '\n', '        return amountRestaked;\n', '    }\n', '\n', '    function _buyShares(uint256 _amount, uint256 _minSharesToMint, address user) private onlyWhenUnlocked returns(uint256) {\n', '        require(delegation, "Delegation is disabled");\n', '\n', '        uint256 rate = exchangeRate();\n', '        uint256 precision = _getRatePrecision();\n', '        uint256 shares = _amount.mul(precision).div(rate);\n', '        require(shares >= _minSharesToMint, "Too much slippage");\n', '        require(unbonds[user].shares == 0, "Ongoing exit");\n', '\n', '        _mint(user, shares);\n', '\n', '        // clamp amount of tokens in case resulted shares requires less tokens than anticipated\n', '        _amount = _amount.sub(_amount % rate.mul(shares).div(precision));\n', '\n', '        activeAmount = activeAmount.add(_amount);\n', '        stakeManager.updateValidatorState(validatorId, int256(_amount));\n', '\n', '        StakingInfo logger = stakingLogger;\n', '        logger.logShareMinted(validatorId, user, _amount, shares);\n', '        logger.logStakeUpdate(validatorId);\n', '\n', '        return _amount;\n', '    }\n', '\n', '    function _reduceActiveStake(uint256 activeStakeReduce) private {\n', '        activeAmount = activeAmount.sub(activeStakeReduce);\n', '    }\n', '\n', '    function _reduceWithdrawPool(uint256 withdrawPoolReduce) private {\n', '        withdrawPool = withdrawPool.sub(withdrawPoolReduce);\n', '    }\n', '\n', '    function sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) public {\n', '        // first get how much staked in total and compare to target unstake amount\n', '        (uint256 totalStaked, uint256 rate) = _getTotalStake(msg.sender);\n', '        require(totalStaked > 0 && totalStaked >= claimAmount, "Too much requested");\n', '\n', '        // convert requested amount back to shares\n', '        uint256 precision = _getRatePrecision();\n', '        uint256 shares = claimAmount.mul(precision).div(rate);\n', '        require(shares <= maximumSharesToBurn, "too much slippage");\n', '\n', '        _withdrawAndTransferReward(msg.sender);\n', '        \n', '        _burn(msg.sender, shares);\n', '        stakeManager.updateValidatorState(validatorId, -int256(claimAmount));\n', '\n', '        _reduceActiveStake(claimAmount);\n', '\n', '        uint256 _withdrawPoolShare = claimAmount.mul(precision).div(withdrawExchangeRate());\n', '        withdrawPool = withdrawPool.add(claimAmount);\n', '        withdrawShares = withdrawShares.add(_withdrawPoolShare);\n', '        \n', '        DelegatorUnbond memory unbond = unbonds[msg.sender];\n', '        unbond.shares = unbond.shares.add(_withdrawPoolShare);\n', '        // refresh undond period\n', '        unbond.withdrawEpoch = stakeManager.epoch();\n', '        unbonds[msg.sender] = unbond;\n', '\n', '        StakingInfo logger = stakingLogger;\n', '        logger.logShareBurned(validatorId, msg.sender, claimAmount, shares);\n', '        logger.logStakeUpdate(validatorId);\n', '    }\n', '\n', '    function _withdrawReward(address user) private returns(uint256) {\n', '        uint256 liquidRewards = getLiquidRewards(user);\n', '        initalRewardPerShare[user] = rewardPerShare;\n', '        return liquidRewards;\n', '    }\n', '\n', '    function _withdrawAndTransferReward(address user) private returns(uint256) {\n', '        uint256 liquidRewards = _withdrawReward(user);\n', '        if (liquidRewards > 0) {\n', '            require(stakeManager.transferFunds(validatorId, liquidRewards, user), "Insufficent rewards");\n', '            stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidRewards);\n', '        }\n', '        \n', '        return liquidRewards;\n', '    }\n', '\n', '    function withdrawRewards() public {\n', '        uint256 rewards = _withdrawAndTransferReward(msg.sender);\n', '        require(rewards >= minAmount, "Too small rewards amount");\n', '    }\n', '\n', '    function migrateOut(address user, uint256 amount) external onlyOwner {\n', '        _withdrawAndTransferReward(user);\n', '        (uint256 totalStaked, uint256 rate) = _getTotalStake(user);\n', '        require(totalStaked >= amount, "Migrating too much");\n', '\n', '        uint256 precision = _getRatePrecision();\n', '        uint256 shares = amount.mul(precision).div(rate);\n', '        _burn(user, shares);\n', '\n', '        stakeManager.updateValidatorState(validatorId, -int256(amount));\n', '        _reduceActiveStake(amount);\n', '\n', '        stakingLogger.logShareBurned(validatorId, user, amount, shares);\n', '        stakingLogger.logStakeUpdate(validatorId);\n', '        stakingLogger.logDelegatorUnstaked(validatorId, user, amount);\n', '    }\n', '\n', '    function migrateIn(address user, uint256 amount) external onlyOwner {\n', '        _buyShares(amount, 0, user);\n', '    }\n', '\n', '    function getLiquidRewards(address user) public view returns (uint256) {\n', '        uint256 shares = balanceOf(user);\n', '        if (shares == 0) {\n', '            return 0;\n', '        }\n', '\n', '        return rewardPerShare.sub(initalRewardPerShare[user]).mul(shares).div(REWARD_PRECISION);\n', '    }\n', '\n', '    function unstakeClaimTokens() public {\n', '        _claimUnstakedTokens();\n', '    }\n', '\n', '    function _claimUnstakedTokens() internal returns(uint256) {\n', '        DelegatorUnbond memory unbond = unbonds[msg.sender];\n', '\n', '        uint256 shares = unbond.shares;\n', '        require(\n', '            unbond.withdrawEpoch.add(stakeManager.withdrawalDelay()) <= stakeManager.epoch() && shares > 0,\n', '            "Incomplete withdrawal period"\n', '        );\n', '\n', '        uint256 _amount = withdrawExchangeRate().mul(shares).div(_getRatePrecision());\n', '        withdrawShares = withdrawShares.sub(shares);\n', '        withdrawPool = withdrawPool.sub(_amount);\n', '\n', '        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), "Insufficent rewards");\n', '        stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, _amount);\n', '        delete unbonds[msg.sender];\n', '\n', '        return _amount;\n', '    }\n', '\n', '    function slash(uint256 valPow, uint256 totalAmountToSlash) external onlyOwner returns (uint256) {\n', '        uint256 _withdrawPool = withdrawPool;\n', '        uint256 delegationAmount = activeAmount.add(_withdrawPool);\n', '        if (delegationAmount == 0) {\n', '            return 0;\n', '        }\n', '        // total amount to be slashed from delegation pool (active + inactive)\n', '        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(valPow.add(delegationAmount));\n', '        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);\n', '\n', '        // slash inactive pool\n', '        _reduceActiveStake(_amountToSlash.sub(_amountToSlashWithdrawalPool));\n', '        _reduceWithdrawPool(_amountToSlashWithdrawalPool);\n', '        return _amountToSlash;\n', '    }\n', '\n', '    function updateDelegation(bool _delegation) external onlyOwner {\n', '        delegation = _delegation;\n', '    }\n', '\n', '    function drain(\n', '        address token,\n', '        address payable destination,\n', '        uint256 amount\n', '    ) external onlyOwner {\n', '        if (token == address(0x0)) {\n', '            destination.transfer(amount);\n', '        } else {\n', '            require(ERC20(token).transfer(destination, amount), "Drain failed");\n', '        }\n', '    }\n', '\n', '    function getActiveAmount() external view returns(uint256) {\n', '        return activeAmount;\n', '    }\n', '\n', '    function unlockContract() external onlyOwner returns (uint256) {\n', '        unlock();\n', '        return activeAmount;\n', '    }\n', '\n', '    function lockContract() external onlyOwner returns (uint256) {\n', '        lock();\n', '        return activeAmount;\n', '    }\n', '}\n', '\n', '// File: contracts/staking/validatorShare/ValidatorShareFactory.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract ValidatorShareFactory {\n', '    /**\n', '    - factory to create new validatorShare contracts\n', '   */\n', '    function create(uint256 validatorId, address loggerAddress, address registry) public returns (address) {\n', '        ValidatorShareProxy proxy = new ValidatorShareProxy(registry);\n', '\n', '        proxy.transferOwnership(msg.sender);\n', '\n', '        address proxyAddr = address(proxy);\n', '        (bool success, bytes memory data) = proxyAddr.call.gas(gasleft())(\n', '            abi.encodeWithSelector(\n', '                ValidatorShare(proxyAddr).initialize.selector, \n', '                validatorId, \n', '                loggerAddress, \n', '                msg.sender\n', '            )\n', '        );\n', '        require(success, string(data));\n', '\n', '        return proxyAddr;\n', '    }\n', '}\n', '\n', '// File: contracts/staking/stakeManager/StakeManagerStorage.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract StakeManagerStorage is GovernanceLockable, RootChainable {\n', '    IERC20 public token;\n', '    address public registry;\n', '    StakingInfo public logger;\n', '    StakingNFT public NFTContract;\n', '    ValidatorShareFactory public factory;\n', '    uint256 public WITHDRAWAL_DELAY; // unit: epoch\n', '    uint256 public currentEpoch;\n', '\n', '    // genesis/governance variables\n', '    uint256 public dynasty ; // unit: epoch 50 days\n', '    uint256 public CHECKPOINT_REWARD; // update via governance\n', '    uint256 public minDeposit; // in ERC20 token\n', '    uint256 public minHeimdallFee; // in ERC20 token\n', '    uint256 public checkPointBlockInterval;\n', '    uint256 public signerUpdateLimit;\n', '\n', '    uint256 public validatorThreshold; //128\n', '    uint256 public totalStaked;\n', '    uint256 public NFTCounter;\n', '    uint256 public totalRewards;\n', '    uint256 public totalRewardsLiquidated;\n', '    uint256 public auctionPeriod; // 1 week in epochs\n', '    uint256 public proposerBonus; // 10 % of total rewards\n', '    bytes32 public accountStateRoot;\n', '    // Stop validator auction for some time when updating dynasty value\n', '    uint256 public replacementCoolDown;\n', '    bool public delegationEnabled;\n', '\n', '    struct Auction {\n', '        uint256 amount;\n', '        uint256 startEpoch;\n', '        address user;\n', '        bool acceptDelegation;\n', '        bytes signerPubkey;\n', '    }\n', '\n', '    struct State {\n', '        uint256 amount;\n', '        uint256 stakerCount;\n', '    }\n', '\n', '    struct StateChange {\n', '        int256 amount;\n', '        int256 stakerCount;\n', '    }\n', '\n', '    enum Status {Inactive, Active, Locked, Unstaked}\n', '    struct Validator {\n', '        uint256 amount;\n', '        uint256 reward;\n', '        uint256 activationEpoch;\n', '        uint256 deactivationEpoch;\n', '        uint256 jailTime;\n', '        address signer;\n', '        address contractAddress;\n', '        Status status;\n', '    }\n', '\n', '    mapping(uint256 => Validator) public validators;\n', '    // signer to Validator mapping\n', '    mapping(address => uint256) public signerToValidator;\n', '    State public validatorState;\n', '    mapping(uint256 => StateChange) public validatorStateChanges;\n', '\n', '    mapping(address => uint256) public userFeeExit;\n', '    //Ongoing auctions for validatorId\n', '    mapping(uint256 => Auction) public validatorAuction;\n', '    // validatorId to last signer update epoch\n', '    mapping(uint256 => uint256) public latestSignerUpdateEpoch;\n', '\n', '    uint256 public totalHeimdallFee;\n', '}\n', '\n', '// File: contracts/staking/stakeManager/StakeManager.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract StakeManager is IStakeManager, StakeManagerStorage, Initializable {\n', '    using SafeMath for uint256;\n', '    using ECVerify for bytes32;\n', '    using Merkle for bytes32;\n', '    using RLPReader for bytes;\n', '    using RLPReader for RLPReader.RLPItem;\n', '\n', '    uint256 private constant INCORRECT_VALIDATOR_ID = 2**256 - 1;\n', '\n', '    modifier onlyStaker(uint256 validatorId) {\n', '        _assertOnlyStaker(validatorId);\n', '        _;\n', '    }\n', '\n', '    function _assertOnlyStaker(uint256 validatorId) private view {\n', '        require(NFTContract.ownerOf(validatorId) == msg.sender);\n', '    }\n', '\n', '    constructor() public GovernanceLockable(address(0x0)) {}\n', '\n', '    function initialize(\n', '        address _registry,\n', '        address _rootchain,\n', '        address _token,\n', '        address _NFTContract,\n', '        address _stakingLogger,\n', '        address _validatorShareFactory,\n', '        address _governance,\n', '        address _owner\n', '    ) external initializer {\n', '        governance = IGovernance(_governance);\n', '        registry = _registry;\n', '        rootChain = _rootchain;\n', '        token = IERC20(_token);\n', '        NFTContract = StakingNFT(_NFTContract);\n', '        logger = StakingInfo(_stakingLogger);\n', '        factory = ValidatorShareFactory(_validatorShareFactory);\n', '        _transferOwnership(_owner);\n', '\n', '        WITHDRAWAL_DELAY = (2**13); // unit: epoch\n', '        currentEpoch = 1;\n', '        dynasty = 886; // unit: epoch 50 days\n', '        CHECKPOINT_REWARD = 20188 * (10**18); // update via governance\n', '        minDeposit = (10**18); // in ERC20 token\n', '        minHeimdallFee = (10**18); // in ERC20 token\n', '        checkPointBlockInterval = 1024;\n', '        signerUpdateLimit = 100;\n', '\n', '        validatorThreshold = 7; //128\n', '        NFTCounter = 1;\n', '        auctionPeriod = (2**13) / 4; // 1 week in epochs\n', '        proposerBonus = 10; // 10 % of total rewards\n', '        delegationEnabled = true;\n', '    }\n', '\n', '    function setDelegationEnabled(bool enabled) public onlyGovernance {\n', '        delegationEnabled = enabled;\n', '    }\n', '\n', '    // TopUp heimdall fee\n', '    function topUpForFee(address user, uint256 heimdallFee) public onlyWhenUnlocked {\n', '        _transferAndTopUp(user, heimdallFee, 0);\n', '    }\n', '\n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        return NFTContract.ownerOf(tokenId);\n', '    }\n', '\n', '    function epoch() public view returns (uint256) {\n', '        return currentEpoch;\n', '    }\n', '\n', '    function withdrawalDelay() public view returns (uint256) {\n', '        return WITHDRAWAL_DELAY;\n', '    }\n', '\n', '    function validatorStake(uint256 validatorId) public view returns (uint256) {\n', '        return validators[validatorId].amount;\n', '    }\n', '\n', '    function _transferAndTopUp(\n', '        address user,\n', '        uint256 fee,\n', '        uint256 additionalAmount\n', '    ) private {\n', '        require(fee >= minHeimdallFee, "Not enough heimdall fee");\n', '        require(token.transferFrom(msg.sender, address(this), fee.add(additionalAmount)), "Fee transfer failed");\n', '        totalHeimdallFee = totalHeimdallFee.add(fee);\n', '        logger.logTopUpFee(user, fee);\n', '    }\n', '\n', '    function _claimFee(address user, uint256 amount) private {\n', '        totalHeimdallFee = totalHeimdallFee.sub(amount);\n', '        logger.logClaimFee(user, amount);\n', '    }\n', '\n', '    function claimFee(\n', '        uint256 accumFeeAmount,\n', '        uint256 index,\n', '        bytes memory proof\n', '    ) public {\n', '        //Ignoring other params becuase rewards distribution is on chain\n', '        require(\n', '            keccak256(abi.encode(msg.sender, accumFeeAmount)).checkMembership(index, accountStateRoot, proof),\n', '            "Wrong acc proof"\n', '        );\n', '        uint256 withdrawAmount = accumFeeAmount.sub(userFeeExit[msg.sender]);\n', '        _claimFee(msg.sender, withdrawAmount);\n', '        userFeeExit[msg.sender] = accumFeeAmount;\n', '        require(token.transfer(msg.sender, withdrawAmount));\n', '    }\n', '\n', '    function stake(\n', '        uint256 amount,\n', '        uint256 heimdallFee,\n', '        bool acceptDelegation,\n', '        bytes calldata signerPubkey\n', '    ) external {\n', '        stakeFor(msg.sender, amount, heimdallFee, acceptDelegation, signerPubkey);\n', '    }\n', '\n', '    function totalStakedFor(address user) external view returns (uint256) {\n', '        if (user == address(0x0) || NFTContract.balanceOf(user) == 0) {\n', '            return 0;\n', '        }\n', '        return validators[NFTContract.tokenOfOwnerByIndex(user, 0)].amount;\n', '    }\n', '\n', '    function startAuction(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        bool _acceptDelegation,\n', '        bytes calldata _signerPubkey\n', '    ) external onlyWhenUnlocked {\n', '        uint256 currentValidatorAmount = validators[validatorId].amount;\n', '\n', '        require(\n', '            validators[validatorId].deactivationEpoch == 0 && currentValidatorAmount != 0,\n', '            "Invalid validator for an auction"\n', '        );\n', '        uint256 senderValidatorId = signerToValidator[msg.sender];\n', "        // make sure that signer wasn't used already\n", '        require(\n', "            NFTContract.balanceOf(msg.sender) == 0 && // existing validators can't bid\n", '                senderValidatorId != INCORRECT_VALIDATOR_ID,\n', '            "Already used address"\n', '        );\n', '\n', '        uint256 _currentEpoch = currentEpoch;\n', '        uint256 _replacementCoolDown = replacementCoolDown;\n', '        // when dynasty period is updated validators are in cooldown period\n', '        require(_replacementCoolDown == 0 || _replacementCoolDown <= _currentEpoch, "Cooldown period");\n', '        // (auctionPeriod--dynasty)--(auctionPeriod--dynasty)--(auctionPeriod--dynasty)\n', "        // if it's auctionPeriod then will get residue smaller then auctionPeriod\n", '        // from (CurrentPeriod of validator )%(auctionPeriod--dynasty)\n', '        // make sure that its `auctionPeriod` window\n', '        // dynasty = 30, auctionPeriod = 7, activationEpoch = 1, currentEpoch = 39\n', "        // residue 1 = (39-1)% (7+30), if residue <= auctionPeriod it's `auctionPeriod`\n", '\n', '        require(\n', '            (_currentEpoch.sub(validators[validatorId].activationEpoch) % dynasty.add(auctionPeriod)) < auctionPeriod,\n', '            "Invalid auction period"\n', '        );\n', '\n', '        uint256 perceivedStake = currentValidatorAmount;\n', '        address _contract = validators[validatorId].contractAddress;\n', '\n', '        if (_contract != address(0x0)) {\n', '            perceivedStake = perceivedStake.add(IValidatorShare(_contract).getActiveAmount());\n', '        }\n', '\n', '        Auction storage auction = validatorAuction[validatorId];\n', '        uint256 currentAuctionAmount = auction.amount;\n', '\n', '        perceivedStake = Math.max(perceivedStake, currentAuctionAmount);\n', '\n', '        require(perceivedStake < amount, "Must bid higher");\n', '        require(token.transferFrom(msg.sender, address(this), amount), "Transfer amount failed");\n', '\n', '        //replace prev auction\n', '        if (currentAuctionAmount != 0) {\n', '            require(token.transfer(auction.user, currentAuctionAmount), "Bid return failed");\n', '        }\n', '\n', '        // create new auction\n', '        auction.amount = amount;\n', '        auction.user = msg.sender;\n', '        auction.acceptDelegation = _acceptDelegation;\n', '        auction.signerPubkey = _signerPubkey;\n', '\n', '        logger.logStartAuction(validatorId, currentValidatorAmount, amount);\n', '    }\n', '\n', '    function confirmAuctionBid(\n', '        uint256 validatorId,\n', '        uint256 heimdallFee /** for new validator */\n', '    ) external onlyWhenUnlocked {\n', '        Auction storage auction = validatorAuction[validatorId];\n', '        address auctionUser = auction.user;\n', '\n', '        require(\n', '            msg.sender == auctionUser || getValidatorId(msg.sender) == validatorId,\n', '            "Only bidder or validator can confirm"\n', '        );\n', '\n', '        uint256 _currentEpoch = currentEpoch;\n', '        require(\n', '            _currentEpoch.sub(auction.startEpoch) % auctionPeriod.add(dynasty) >= auctionPeriod,\n', '            "Not allowed before auctionPeriod"\n', '        );\n', '        require(auction.user != address(0x0), "Invalid auction");\n', '\n', '        uint256 validatorAmount = validators[validatorId].amount;\n', '        uint256 perceivedStake = validatorAmount;\n', '        uint256 auctionAmount = auction.amount;\n', '        address contractAddr = validators[validatorId].contractAddress;\n', '\n', '        if (contractAddr != address(0x0)) {\n', '            perceivedStake = perceivedStake.add(IValidatorShare(contractAddr).getActiveAmount());\n', '        }\n', '\n', '        // validator is last auctioner\n', '        if (perceivedStake >= auctionAmount && validators[validatorId].deactivationEpoch == 0) {\n', '            require(token.transfer(auctionUser, auctionAmount), "Bid return failed");\n', '            //cleanup auction data\n', '            auction.startEpoch = _currentEpoch;\n', '            logger.logConfirmAuction(validatorId, validatorId, validatorAmount);\n', '        } else {\n', '            // dethrone\n', '            _transferAndTopUp(auctionUser, heimdallFee, 0);\n', '            _unstake(validatorId, _currentEpoch);\n', '\n', '            uint256 newValidatorId = _stakeFor(\n', '                auctionUser,\n', '                auctionAmount,\n', '                auction.acceptDelegation,\n', '                auction.signerPubkey\n', '            );\n', '            logger.logConfirmAuction(newValidatorId, validatorId, auctionAmount);\n', '        }\n', '        uint256 startEpoch = auction.startEpoch;\n', '        delete validatorAuction[validatorId];\n', '        validatorAuction[validatorId].startEpoch = startEpoch;\n', '    }\n', '\n', '    function unstake(uint256 validatorId) external onlyStaker(validatorId) {\n', '        require(validatorAuction[validatorId].amount == 0, "Wait for auction completion");\n', '        require(\n', '            validators[validatorId].activationEpoch > 0 &&\n', '                validators[validatorId].deactivationEpoch == 0 &&\n', '                (validators[validatorId].status == Status.Active || validators[validatorId].status == Status.Locked)\n', '        );\n', '\n', '        uint256 exitEpoch = currentEpoch.add(1); // notice period\n', '        _unstake(validatorId, exitEpoch);\n', '    }\n', '\n', '    // Housekeeping function. @todo remove later\n', '    function forceUnstake(uint256 validatorId) external onlyGovernance {\n', '        _unstake(validatorId, currentEpoch);\n', '    }\n', '\n', '    function setCurrentEpoch(uint256 _currentEpoch) external onlyGovernance {\n', '        currentEpoch = _currentEpoch;\n', '    }\n', '\n', '    function transferFunds(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        address delegator\n', '    ) external returns (bool) {\n', '        require(\n', '            validators[validatorId].contractAddress == msg.sender ||\n', '            Registry(registry).getSlashingManagerAddress() == msg.sender,\n', '            "Invalid contract address"\n', '        );\n', '        return token.transfer(delegator, amount);\n', '    }\n', '\n', '    function delegationDeposit(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        address delegator\n', '    ) external returns (bool) {\n', '        require(validators[validatorId].contractAddress == msg.sender, "Invalid contract address");\n', '        return token.transferFrom(delegator, address(this), amount);\n', '    }\n', '\n', '    function stakeFor(\n', '        address user,\n', '        uint256 amount,\n', '        uint256 heimdallFee,\n', '        bool acceptDelegation,\n', '        bytes memory signerPubkey\n', '    ) public onlyWhenUnlocked {\n', '        require(currentValidatorSetSize() < validatorThreshold, "Validator set Threshold exceeded!");\n', '        require(amount > minDeposit, "min deposit limit failed!");\n', '        _transferAndTopUp(user, heimdallFee, amount);\n', '        _stakeFor(user, amount, acceptDelegation, signerPubkey);\n', '    }\n', '\n', '    function unstakeClaim(uint256 validatorId) public onlyStaker(validatorId) {\n', '        uint256 deactivationEpoch = validators[validatorId].deactivationEpoch;\n', '        // can only claim stake back after WITHDRAWAL_DELAY\n', '        require(\n', '            deactivationEpoch > 0 &&\n', '                deactivationEpoch.add(WITHDRAWAL_DELAY) <= currentEpoch &&\n', '                validators[validatorId].status != Status.Unstaked\n', '        );\n', '\n', '        uint256 amount = validators[validatorId].amount;\n', '        uint256 newTotalStaked = totalStaked.sub(amount);\n', '        totalStaked = newTotalStaked;\n', '\n', '        NFTContract.burn(validatorId);\n', '\n', '        signerToValidator[validators[validatorId].signer] = INCORRECT_VALIDATOR_ID;\n', '        validators[validatorId].status = Status.Unstaked;\n', '        require(token.transfer(msg.sender, amount), "Transfer stake failed");\n', '        logger.logUnstaked(msg.sender, validatorId, amount, newTotalStaked);\n', '    }\n', '\n', '    // slashing and jail interface\n', '    function restake(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        bool stakeRewards\n', '    ) public onlyWhenUnlocked onlyStaker(validatorId) {\n', '        require(validators[validatorId].deactivationEpoch == 0, "No use of restaking");\n', '\n', '        if (amount > 0) {\n', '            require(token.transferFrom(msg.sender, address(this), amount), "Transfer stake failed");\n', '        }\n', '\n', '        if (stakeRewards) {\n', '            amount = amount.add(validators[validatorId].reward);\n', '            address contractAddr = validators[validatorId].contractAddress;\n', '            if (contractAddr != address(0x0)) {\n', '                amount = amount.add(IValidatorShare(contractAddr).withdrawRewardsValidator());\n', '            }\n', '            validators[validatorId].reward = 0;\n', '        }\n', '\n', '        uint256 newTotalStaked = totalStaked.add(amount);\n', '        totalStaked = newTotalStaked;\n', '        validators[validatorId].amount = validators[validatorId].amount.add(amount);\n', '\n', '        updateTimeline(int256(amount), 0, 0);\n', '\n', '        logger.logStakeUpdate(validatorId);\n', '        logger.logRestaked(validatorId, validators[validatorId].amount, newTotalStaked);\n', '    }\n', '\n', '    function _liquidateRewards(uint256 validatorId, address validatorUser, uint256 reward) private {\n', '        totalRewardsLiquidated = totalRewardsLiquidated.add(reward);\n', '        validators[validatorId].reward = 0;\n', '        require(token.transfer(validatorUser, reward), "Insufficent rewards");\n', '        logger.logClaimRewards(validatorId, reward, totalRewardsLiquidated);\n', '    }\n', '\n', '    function withdrawRewards(uint256 validatorId) public onlyStaker(validatorId) {\n', '        uint256 reward = validators[validatorId].reward;\n', '        address contractAddr = validators[validatorId].contractAddress;\n', '        if (contractAddr != address(0x0)) {\n', '            reward = reward.add(IValidatorShare(contractAddr).withdrawRewardsValidator());\n', '        }\n', '\n', '        _liquidateRewards(validatorId, msg.sender, reward);\n', '    }\n', '\n', '    function migrateDelegation(uint256 fromValidatorId, uint256 toValidatorId, uint256 amount) public {\n', '        require(fromValidatorId < 8 && toValidatorId > 7, "Invalid migration");\n', '        IValidatorShare(validators[fromValidatorId].contractAddress).migrateOut(msg.sender, amount);\n', '        IValidatorShare(validators[toValidatorId].contractAddress).migrateIn(msg.sender, amount);\n', '    }\n', '\n', '    function getValidatorId(address user) public view returns (uint256) {\n', '        return NFTContract.tokenOfOwnerByIndex(user, 0);\n', '    }\n', '\n', '    // set staking Token\n', '    function setToken(address _token) public onlyGovernance {\n', '        require(_token != address(0x0));\n', '        token = IERC20(_token);\n', '    }\n', '\n', '    // Change the number of validators required to allow a passed header root\n', '    function updateValidatorThreshold(uint256 newThreshold) public onlyGovernance {\n', '        require(newThreshold > 0);\n', '        logger.logThresholdChange(newThreshold, validatorThreshold);\n', '        validatorThreshold = newThreshold;\n', '    }\n', '\n', '    function updateCheckPointBlockInterval(uint256 _blocks) public onlyGovernance {\n', '        require(_blocks > 0, "Blocks interval must be non-zero");\n', '        checkPointBlockInterval = _blocks;\n', '    }\n', '\n', '    // Change reward for each checkpoint\n', '    function updateCheckpointReward(uint256 newReward) public onlyGovernance {\n', '        require(newReward > 0);\n', '        logger.logRewardUpdate(newReward, CHECKPOINT_REWARD);\n', '        CHECKPOINT_REWARD = newReward;\n', '    }\n', '\n', '    // Change delegation contract for a validator\n', '    // @note: Users must exit before this update or all funds may get lost\n', '    function updateContractAddress(uint256 validatorId, address newContractAddress) public onlyGovernance {\n', '        require(IValidatorShare(newContractAddress).owner() == address(this), "Owner of contract must be stakeManager");\n', '        validators[validatorId].contractAddress = newContractAddress;\n', '    }\n', '\n', '    function updateValidatorState(uint256 validatorId, int256 amount) public {\n', '        if (amount > 0) {\n', '            // deposit during shares purchase\n', '            require(delegationEnabled, "Delegation is disabled");\n', '        }\n', '\n', '        require(validators[validatorId].contractAddress == msg.sender, "Invalid contract address");\n', '        updateTimeline(amount, 0, 0);\n', '    }\n', '\n', '    function updateDynastyValue(uint256 newDynasty) public onlyGovernance {\n', '        require(newDynasty > 0);\n', '        logger.logDynastyValueChange(newDynasty, dynasty);\n', '        dynasty = newDynasty;\n', '        WITHDRAWAL_DELAY = newDynasty;\n', '        auctionPeriod = newDynasty.div(4);\n', '        // set cooldown period\n', '        replacementCoolDown = currentEpoch.add(auctionPeriod);\n', '    }\n', '\n', '    // Housekeeping function. @todo remove later\n', '    function stopAuctions(uint256 forNCheckpoints) public onlyGovernance {\n', '        replacementCoolDown = currentEpoch.add(forNCheckpoints);\n', '    }\n', '\n', '    function updateProposerBonus(uint256 newProposerBonus) public onlyGovernance {\n', '        logger.logProposerBonusChange(newProposerBonus, proposerBonus);\n', '        require(newProposerBonus <= 100, "too big");\n', '        proposerBonus = newProposerBonus;\n', '    }\n', '\n', '    function updateSignerUpdateLimit(uint256 _limit) public onlyGovernance {\n', '        signerUpdateLimit = _limit;\n', '    }\n', '\n', '    function updateMinAmounts(uint256 _minDeposit, uint256 _minHeimdallFee) public onlyGovernance {\n', '        minDeposit = _minDeposit;\n', '        minHeimdallFee = _minHeimdallFee;\n', '    }\n', '\n', '    function updateSigner(uint256 validatorId, bytes memory signerPubkey) public onlyStaker(validatorId) {\n', '        address signer = pubToAddress(signerPubkey);\n', '        require(signer != address(0x0) && signerToValidator[signer] == 0, "Invalid signer");\n', '\n', '        uint256 _currentEpoch = currentEpoch;\n', '        require(\n', '            _currentEpoch >= latestSignerUpdateEpoch[validatorId].add(signerUpdateLimit),\n', '            "Invalid checkpoint number!"\n', '        );\n', '\n', '        address currentSigner = validators[validatorId].signer;\n', '        // update signer event\n', '        logger.logSignerChange(validatorId, currentSigner, signer, signerPubkey);\n', '\n', '        signerToValidator[currentSigner] = INCORRECT_VALIDATOR_ID;\n', '        signerToValidator[signer] = validatorId;\n', '        validators[validatorId].signer = signer;\n', '        // reset update time to current time\n', '        latestSignerUpdateEpoch[validatorId] = _currentEpoch;\n', '    }\n', '\n', '    function currentValidatorSetSize() public view returns (uint256) {\n', '        return validatorState.stakerCount;\n', '    }\n', '\n', '    function currentValidatorSetTotalStake() public view returns (uint256) {\n', '        return validatorState.amount;\n', '    }\n', '\n', '    function getValidatorContract(uint256 validatorId) public view returns (address) {\n', '        return validators[validatorId].contractAddress;\n', '    }\n', '\n', '    function isValidator(uint256 validatorId) public view returns (bool) {\n', '        uint256 activationEpoch = validators[validatorId].activationEpoch;\n', '        uint256 deactivationEpoch = validators[validatorId].deactivationEpoch;\n', '        uint256 amount = validators[validatorId].amount;\n', '        Status status = validators[validatorId].status;\n', '        uint256 _currentEpoch = currentEpoch;\n', '\n', '        return (amount > 0 &&\n', '            (activationEpoch != 0 && activationEpoch <= _currentEpoch) &&\n', '            (deactivationEpoch == 0 || deactivationEpoch > _currentEpoch) &&\n', '            status == Status.Active);\n', '    }\n', '\n', '    function checkSignatures(\n', '        uint256 blockInterval,\n', '        bytes32 voteHash,\n', '        bytes32 stateRoot,\n', '        address proposer,\n', '        bytes memory sigs\n', '    ) public onlyRootChain returns (uint256) {\n', '        // checkpoint rewards are based on BlockInterval multiplied on `CHECKPOINT_REWARD`\n', '        // for bigger checkpoints reward is capped at `CHECKPOINT_REWARD`\n', '        // if interval is 50% of checkPointBlockInterval then reward R is half of `CHECKPOINT_REWARD`\n', '        // and then stakePower is 90% of currentValidatorSetTotalStake then final reward is 90% of R\n', '        uint256 reward = blockInterval.mul(CHECKPOINT_REWARD).div(checkPointBlockInterval);\n', '        reward = Math.min(CHECKPOINT_REWARD, reward);\n', '\n', '        uint256 _proposerBonus = reward.mul(proposerBonus).div(100);\n', '        Validator storage _proposer = validators[signerToValidator[proposer]];\n', '        if (_proposer.contractAddress != address(0x0)) {\n', '            IValidatorShare(_proposer.contractAddress).addProposerBonus(_proposerBonus, _proposer.amount);\n', '        } else {\n', '            _proposer.reward = _proposer.reward.add(_proposerBonus);\n', '        }\n', '\n', '        reward = reward.sub(_proposerBonus);\n', '        uint256 stakePower = currentValidatorSetTotalStake();\n', '        // update stateMerkleTree root for accounts balance on heimdall chain\n', '        accountStateRoot = stateRoot;\n', '        _finalizeCommit();\n', '        return checkSignature(stakePower, reward, voteHash, sigs);\n', '    }\n', '\n', '    function checkSignature(\n', '        uint256 checkpointStakePower,\n', '        uint256 reward,\n', '        bytes32 voteHash,\n', '        bytes memory sigs\n', '    ) internal returns (uint256) {\n', '        // total voting power\n', '        uint256 totalStakePower;\n', '        address lastAdd; // cannot have address(0x0) as an owner\n', '        for (uint64 i = 0; i < sigs.length; i += 65) {\n', '            address signer = voteHash.ecrecovery(BytesLib.slice(sigs, i, 65));\n', '            uint256 validatorId = signerToValidator[signer];\n', '            // check if signer is staker and not proposer\n', '            if (signer == lastAdd) {\n', '                break;\n', '            } else if (isValidator(validatorId) && signer > lastAdd) {\n', '                lastAdd = signer;\n', '\n', '                Validator storage validator = validators[validatorId];\n', '                uint256 valPow;\n', '                // add delegation power\n', '                address contractAddr = validator.contractAddress;\n', '                if (contractAddr != address(0x0)) {\n', '                    valPow = IValidatorShare(contractAddr).updateRewards(\n', '                        reward,\n', '                        checkpointStakePower,\n', '                        validatorStake(validatorId)\n', '                    );\n', '                } else {\n', '                    valPow = validator.amount;\n', '                    validator.reward = validator.reward.add(valPow.mul(reward).div(checkpointStakePower));\n', '                }\n', '                totalStakePower = totalStakePower.add(valPow);\n', '            }\n', '        }\n', '\n', '        reward = CHECKPOINT_REWARD.mul(totalStakePower).div(currentValidatorSetTotalStake());\n', '        totalRewards = totalRewards.add(reward);\n', '        require(totalStakePower >= currentValidatorSetTotalStake().mul(2).div(3).add(1), "2/3+1 non-majority!");\n', '\n', '        return reward;\n', '    }\n', '\n', '    function slash(bytes memory _slashingInfoList) public returns (uint256) {\n', '        require(Registry(registry).getSlashingManagerAddress() == msg.sender, "Sender must be slashing manager!");\n', '        RLPReader.RLPItem[] memory slashingInfoList = _slashingInfoList.toRlpItem().toList();\n', '        int256 valJailed = 0;\n', '        uint256 jailedAmount = 0;\n', '        uint256 totalAmount;\n', '        for (uint256 i = 0; i < slashingInfoList.length; i++) {\n', '            RLPReader.RLPItem[] memory slashData = slashingInfoList[i].toList();\n', '            uint256 validatorId = slashData[0].toUint();\n', '            uint256 _amount = slashData[1].toUint();\n', '            totalAmount = totalAmount.add(_amount);\n', '\n', '            if (validators[validatorId].contractAddress != address(0x0)) {\n', '                uint256 delSlashedAmount = IValidatorShare(validators[validatorId].contractAddress).slash(\n', '                    validators[validatorId].amount,\n', '                    _amount\n', '                );\n', '                _amount = _amount.sub(delSlashedAmount);\n', '            }\n', '\n', '            uint256 validatorStakeSlashed = validators[validatorId].amount.sub(_amount);\n', '            validators[validatorId].amount = validatorStakeSlashed;\n', '\n', '            if (validatorStakeSlashed == 0) {\n', '                _unstake(validatorId, currentEpoch);    \n', '            } else if (slashData[2].toBoolean()) {\n', '                jailedAmount = jailedAmount.add(_jail(validatorId, 1));\n', '                valJailed++;\n', '            }\n', '        }\n', '\n', '        //update timeline\n', '        updateTimeline(-int256(totalAmount.add(jailedAmount)), -valJailed, 0);\n', '\n', '        return totalAmount;\n', '    }\n', '\n', '    function unjail(uint256 validatorId) public onlyStaker(validatorId) {\n', '        require(validators[validatorId].status == Status.Locked, "Validator is not jailed");\n', '        require(validators[validatorId].deactivationEpoch == 0, "Validator already unstaking");\n', '\n', '        uint256 _currentEpoch = currentEpoch;\n', '        require(validators[validatorId].jailTime <= _currentEpoch, "Incomplete jail period");\n', '\n', '        uint256 amount = validators[validatorId].amount;\n', '        require(amount >= minDeposit);\n', '\n', '        uint256 delegationAmount = 0;\n', '        if (validators[validatorId].contractAddress != address(0x0)) {\n', '            delegationAmount = IValidatorShare(validators[validatorId].contractAddress).unlockContract();\n', '        }\n', '\n', '        // undo timline so that validator is normal validator\n', '        updateTimeline(int256(amount.add(delegationAmount)), 1, 0);\n', '\n', '        validators[validatorId].status = Status.Active;\n', '        logger.logUnjailed(validatorId, validators[validatorId].signer);\n', '    }\n', '\n', '    function _jail(uint256 validatorId, uint256 jailCheckpoints) internal returns (uint256) {\n', '        uint256 delegationAmount = 0;\n', '        if (validators[validatorId].contractAddress != address(0x0)) {\n', '            delegationAmount = IValidatorShare(validators[validatorId].contractAddress).lockContract();\n', '        }\n', '\n', '        uint256 _currentEpoch = currentEpoch;\n', '        validators[validatorId].jailTime = _currentEpoch.add(jailCheckpoints);\n', '        validators[validatorId].status = Status.Locked;\n', '        logger.logJailed(validatorId, _currentEpoch, validators[validatorId].signer);\n', '        return validators[validatorId].amount.add(delegationAmount);\n', '    }\n', '\n', '    function _stakeFor(\n', '        address user,\n', '        uint256 amount,\n', '        bool acceptDelegation,\n', '        bytes memory signerPubkey\n', '    ) internal returns (uint256) {\n', '        address signer = pubToAddress(signerPubkey);\n', '        require(signer != address(0x0) && signerToValidator[signer] == 0, "Invalid signer");\n', '\n', '        uint256 _currentEpoch = currentEpoch;\n', '        uint256 validatorId = NFTCounter;\n', '        StakingInfo _logger = logger;\n', '        uint256 newTotalStaked = totalStaked.add(amount);\n', '        totalStaked = newTotalStaked;\n', '\n', '        validators[validatorId] = Validator({\n', '            reward: 0,\n', '            amount: amount,\n', '            activationEpoch: _currentEpoch,\n', '            deactivationEpoch: 0,\n', '            jailTime: 0,\n', '            signer: signer,\n', '            contractAddress: acceptDelegation ? factory.create(validatorId, address(_logger), registry) : address(0x0),\n', '            status: Status.Active\n', '        });\n', '\n', '        latestSignerUpdateEpoch[validatorId] = _currentEpoch;\n', '        NFTContract.mint(user, validatorId);\n', '\n', '        signerToValidator[signer] = validatorId;\n', '        updateTimeline(int256(amount), 1, 0);\n', '        // no Auctions for 1 dynasty\n', '        validatorAuction[validatorId].startEpoch = _currentEpoch;\n', '        _logger.logStaked(signer, signerPubkey, validatorId, _currentEpoch, amount, newTotalStaked);\n', '        NFTCounter = validatorId.add(1);\n', '\n', '        return validatorId;\n', '    }\n', '\n', '    function _unstake(uint256 validatorId, uint256 exitEpoch) internal {\n', '        uint256 amount = validators[validatorId].amount;\n', '        address validator = ownerOf(validatorId);\n', '\n', '        validators[validatorId].deactivationEpoch = exitEpoch;\n', '\n', '        // unbond all delegators in future\n', '        int256 delegationAmount = 0;\n', '        uint256 rewards = validators[validatorId].reward;\n', '        address contractAddr = validators[validatorId].contractAddress;\n', '        if (contractAddr != address(0x0)) {\n', '            IValidatorShare validatorShare = IValidatorShare(contractAddr);\n', '            rewards = rewards.add(validatorShare.withdrawRewardsValidator());\n', '            delegationAmount = int256(validatorShare.lockContract());\n', '        }\n', '\n', '        _liquidateRewards(validatorId, validator, rewards);\n', '\n', '        //  update future\n', '        uint256 targetEpoch = exitEpoch <= currentEpoch ? 0 : exitEpoch;\n', '        updateTimeline(-(int256(amount) + delegationAmount), -1, targetEpoch);\n', '\n', '        logger.logUnstakeInit(validator, validatorId, exitEpoch, amount);\n', '    }\n', '\n', '    function _finalizeCommit() internal {\n', '        uint256 _currentEpoch = currentEpoch;\n', '        uint256 nextEpoch = _currentEpoch.add(1);\n', '\n', '        StateChange memory changes = validatorStateChanges[nextEpoch];\n', '        updateTimeline(changes.amount, changes.stakerCount, 0);\n', '\n', '        delete validatorStateChanges[_currentEpoch];\n', '\n', '        currentEpoch = nextEpoch;\n', '    }\n', '\n', '    function updateTimeline(\n', '        int256 amount,\n', '        int256 stakerCount,\n', '        uint256 targetEpoch\n', '    ) private {\n', '        if (targetEpoch == 0) {\n', '            // update totalstake and validator count\n', '            if (amount > 0) {\n', '                validatorState.amount = validatorState.amount.add(uint256(amount));\n', '            } else if (amount < 0) {\n', '                validatorState.amount = validatorState.amount.sub(uint256(amount * -1));\n', '            }\n', '\n', '            if (stakerCount > 0) {\n', '                validatorState.stakerCount = validatorState.stakerCount.add(uint256(stakerCount));\n', '            } else if (stakerCount < 0) {\n', '                validatorState.stakerCount = validatorState.stakerCount.sub(uint256(stakerCount * -1));\n', '            }\n', '        } else {\n', '            validatorStateChanges[targetEpoch].amount += amount;\n', '            validatorStateChanges[targetEpoch].stakerCount += stakerCount;\n', '        }\n', '    }\n', '\n', '    function pubToAddress(bytes memory pub) private pure returns (address) {\n', '        require(pub.length == 64, "Invalid pubkey");\n', '        return address(uint160(uint256(keccak256(pub))));\n', '    }\n', '\n', '    function reinitialize(\n', '        address _NFTContract,\n', '        address _stakingLogger,\n', '        address _validatorShareFactory\n', '    ) external onlyGovernance {\n', '        NFTContract = StakingNFT(_NFTContract);\n', '        logger = StakingInfo(_stakingLogger);\n', '        factory = ValidatorShareFactory(_validatorShareFactory);\n', '    }\n', '\n', '    function updateValidatorDelegation(bool delegation) external {\n', '        uint256 validatorId = signerToValidator[msg.sender];\n', '        require(isValidator(validatorId), "not a validator");\n', '\n', '        address contractAddr = validators[validatorId].contractAddress;\n', '        require(contractAddr != address(0x0), "delegation not enabled");\n', '\n', '        IValidatorShare(contractAddr).updateDelegation(delegation);\n', '    }\n', '}']