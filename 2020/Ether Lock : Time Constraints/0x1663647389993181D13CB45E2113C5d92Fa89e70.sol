['// SPDX-License-Identifier: Apache-2.0\n', 'pragma solidity ^0.7.0;\n', '// File: contracts/iface/Wallet.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Wallet\n', '/// @dev Base contract for smart wallets.\n', '///      Sub-contracts must NOT use non-default constructor to initialize\n', '///      wallet states, instead, `init` shall be used. This is to enable\n', '///      proxies to be deployed in front of the real wallet contract for\n', '///      saving gas.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'interface Wallet\n', '{\n', '    function version() external pure returns (string memory);\n', '\n', '    function owner() external view returns (address);\n', '\n', '    /// @dev Set a new owner.\n', '    function setOwner(address newOwner) external;\n', '\n', '    /// @dev Adds a new module. The `init` method of the module\n', '    ///      will be called with `address(this)` as the parameter.\n', '    ///      This method must throw if the module has already been added.\n', "    /// @param _module The module's address.\n", '    function addModule(address _module) external;\n', '\n', '    /// @dev Removes an existing module. This method must throw if the module\n', "    ///      has NOT been added or the module is the wallet's only module.\n", "    /// @param _module The module's address.\n", '    function removeModule(address _module) external;\n', '\n', '    /// @dev Checks if a module has been added to this wallet.\n', '    /// @param _module The module to check.\n', '    /// @return True if the module exists; False otherwise.\n', '    function hasModule(address _module) external view returns (bool);\n', '\n', '    /// @dev Binds a method from the given module to this\n', "    ///      wallet so the method can be invoked using this wallet's default\n", '    ///      function.\n', '    ///      Note that this method must throw when the given module has\n', '    ///      not been added to this wallet.\n', "    /// @param _method The method's 4-byte selector.\n", "    /// @param _module The module's address. Use address(0) to unbind the method.\n", '    function bindMethod(bytes4 _method, address _module) external;\n', '\n', '    /// @dev Returns the module the given method has been bound to.\n', "    /// @param _method The method's 4-byte selector.\n", '    /// @return _module The address of the bound module. If no binding exists,\n', '    ///                 returns address(0) instead.\n', '    function boundMethodModule(bytes4 _method) external view returns (address _module);\n', '\n', '    /// @dev Performs generic transactions. Any module that has been added to this\n', '    ///      wallet can use this method to transact on any third-party contract with\n', '    ///      msg.sender as this wallet itself.\n', '    ///\n', '    ///      Note: 1) this method must ONLY allow invocations from a module that has\n', '    ///      been added to this wallet. The wallet owner shall NOT be permitted\n', '    ///      to call this method directly. 2) Reentrancy inside this function should\n', '    ///      NOT cause any problems.\n', '    ///\n', '    /// @param mode The transaction mode, 1 for CALL, 2 for DELEGATECALL.\n', '    /// @param to The desitination address.\n', '    /// @param value The amount of Ether to transfer.\n', '    /// @param data The data to send over using `to.call{value: value}(data)`\n', "    /// @return returnData The transaction's return value.\n", '    function transact(\n', '        uint8    mode,\n', '        address  to,\n', '        uint     value,\n', '        bytes    calldata data\n', '        )\n', '        external\n', '        returns (bytes memory returnData);\n', '}\n', '\n', '// File: contracts/base/DataStore.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title DataStore\n', '/// @dev Modules share states by accessing the same storage instance.\n', '///      Using ModuleStorage will achieve better module decoupling.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'abstract contract DataStore\n', '{\n', '    modifier onlyWalletModule(address wallet)\n', '    {\n', '        requireWalletModule(wallet);\n', '        _;\n', '    }\n', '\n', '    function requireWalletModule(address wallet) view internal\n', '    {\n', '        require(Wallet(wallet).hasModule(msg.sender), "UNAUTHORIZED");\n', '    }\n', '}\n', '\n', '// File: contracts/lib/AddressSet.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title AddressSet\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract AddressSet\n', '{\n', '    struct Set\n', '    {\n', '        address[] addresses;\n', '        mapping (address => uint) positions;\n', '        uint count;\n', '    }\n', '    mapping (bytes32 => Set) private sets;\n', '\n', '    function addAddressToSet(\n', '        bytes32 key,\n', '        address addr,\n', '        bool    maintainList\n', '        ) internal\n', '    {\n', '        Set storage set = sets[key];\n', '        require(set.positions[addr] == 0, "ALREADY_IN_SET");\n', '\n', '        if (maintainList) {\n', '            require(set.addresses.length == set.count, "PREVIOUSLY_NOT_MAINTAILED");\n', '            set.addresses.push(addr);\n', '        } else {\n', '            require(set.addresses.length == 0, "MUST_MAINTAIN");\n', '        }\n', '\n', '        set.count += 1;\n', '        set.positions[addr] = set.count;\n', '    }\n', '\n', '    function removeAddressFromSet(\n', '        bytes32 key,\n', '        address addr\n', '        )\n', '        internal\n', '    {\n', '        Set storage set = sets[key];\n', '        uint pos = set.positions[addr];\n', '        require(pos != 0, "NOT_IN_SET");\n', '\n', '        delete set.positions[addr];\n', '        set.count -= 1;\n', '\n', '        if (set.addresses.length > 0) {\n', '            address lastAddr = set.addresses[set.count];\n', '            if (lastAddr != addr) {\n', '                set.addresses[pos - 1] = lastAddr;\n', '                set.positions[lastAddr] = pos;\n', '            }\n', '            set.addresses.pop();\n', '        }\n', '    }\n', '\n', '    function removeSet(bytes32 key)\n', '        internal\n', '    {\n', '        delete sets[key];\n', '    }\n', '\n', '    function isAddressInSet(\n', '        bytes32 key,\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return sets[key].positions[addr] != 0;\n', '    }\n', '\n', '    function numAddressesInSet(bytes32 key)\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        Set storage set = sets[key];\n', '        return set.count;\n', '    }\n', '\n', '    function addressesInSet(bytes32 key)\n', '        internal\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        Set storage set = sets[key];\n', '        require(set.count == set.addresses.length, "NOT_MAINTAINED");\n', '        return sets[key].addresses;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Ownable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Ownable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable\n', '{\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      new owner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership()\n', '        public\n', '        onlyOwner\n', '    {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Claimable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Claimable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable\n', '{\n', '    address public pendingOwner;\n', '\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0) && newOwner != owner, "INVALID_ADDRESS");\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        public\n', '        onlyPendingOwner\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/OwnerManagable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', 'contract OwnerManagable is Claimable, AddressSet\n', '{\n', '    bytes32 internal constant MANAGER = keccak256("__MANAGED__");\n', '\n', '    event ManagerAdded  (address indexed manager);\n', '    event ManagerRemoved(address indexed manager);\n', '\n', '    modifier onlyManager\n', '    {\n', '        require(isManager(msg.sender), "NOT_MANAGER");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrManager\n', '    {\n', '        require(msg.sender == owner || isManager(msg.sender), "NOT_OWNER_OR_MANAGER");\n', '        _;\n', '    }\n', '\n', '    constructor() Claimable() {}\n', '\n', '    /// @dev Gets the managers.\n', '    /// @return The list of managers.\n', '    function managers()\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        return addressesInSet(MANAGER);\n', '    }\n', '\n', '    /// @dev Gets the number of managers.\n', '    /// @return The numer of managers.\n', '    function numManagers()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return numAddressesInSet(MANAGER);\n', '    }\n', '\n', '    /// @dev Checks if an address is a manger.\n', '    /// @param addr The address to check.\n', '    /// @return True if the address is a manager, False otherwise.\n', '    function isManager(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return isAddressInSet(MANAGER, addr);\n', '    }\n', '\n', '    /// @dev Adds a new manager.\n', '    /// @param manager The new address to add.\n', '    function addManager(address manager)\n', '        public\n', '        onlyOwner\n', '    {\n', '        addManagerInternal(manager);\n', '    }\n', '\n', '    /// @dev Removes a manager.\n', '    /// @param manager The manager to remove.\n', '    function removeManager(address manager)\n', '        public\n', '        onlyOwner\n', '    {\n', '        removeAddressFromSet(MANAGER, manager);\n', '        emit ManagerRemoved(manager);\n', '    }\n', '\n', '    function addManagerInternal(address manager)\n', '        internal\n', '    {\n', '        addAddressToSet(MANAGER, manager, true);\n', '        emit ManagerAdded(manager);\n', '    }\n', '}\n', '\n', '// File: contracts/stores/WhitelistStore.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title WhitelistStore\n', "/// @dev This store maintains a wallet's whitelisted addresses.\n", 'contract WhitelistStore is DataStore, AddressSet, OwnerManagable\n', '{\n', '    bytes32 internal constant DAPPS = keccak256("__DAPPS__");\n', '\n', '    // wallet => whitelisted_addr => effective_since\n', '    mapping(address => mapping(address => uint)) public effectiveTimeMap;\n', '\n', '    event Whitelisted(\n', '        address wallet,\n', '        address addr,\n', '        bool    whitelisted,\n', '        uint    effectiveTime\n', '    );\n', '\n', '    event DappWhitelisted(\n', '        address addr,\n', '        bool    whitelisted\n', '    );\n', '\n', '    constructor() DataStore() {}\n', '\n', '    function addToWhitelist(\n', '        address wallet,\n', '        address addr,\n', '        uint    effectiveTime\n', '        )\n', '        external\n', '        onlyWalletModule(wallet)\n', '    {\n', '        addAddressToSet(_walletKey(wallet), addr, true);\n', '        uint effective = effectiveTime >= block.timestamp ? effectiveTime : block.timestamp;\n', '        effectiveTimeMap[wallet][addr] = effective;\n', '        emit Whitelisted(wallet, addr, true, effective);\n', '    }\n', '\n', '    function removeFromWhitelist(\n', '        address wallet,\n', '        address addr\n', '        )\n', '        external\n', '        onlyWalletModule(wallet)\n', '    {\n', '        removeAddressFromSet(_walletKey(wallet), addr);\n', '        delete effectiveTimeMap[wallet][addr];\n', '        emit Whitelisted(wallet, addr, false, 0);\n', '    }\n', '\n', '    function addDapp(address addr)\n', '        external\n', '        onlyManager\n', '    {\n', '        addAddressToSet(DAPPS, addr, true);\n', '        emit DappWhitelisted(addr, true);\n', '    }\n', '\n', '    function removeDapp(address addr)\n', '        external\n', '        onlyManager\n', '    {\n', '        removeAddressFromSet(DAPPS, addr);\n', '        emit DappWhitelisted(addr, false);\n', '    }\n', '\n', '    function whitelist(address wallet)\n', '        public\n', '        view\n', '        returns (\n', '            address[] memory addresses,\n', '            uint[]    memory effectiveTimes\n', '        )\n', '    {\n', '        addresses = addressesInSet(_walletKey(wallet));\n', '        effectiveTimes = new uint[](addresses.length);\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            effectiveTimes[i] = effectiveTimeMap[wallet][addresses[i]];\n', '        }\n', '    }\n', '\n', '    function isWhitelisted(\n', '        address wallet,\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (\n', '            bool isWhitelistedAndEffective,\n', '            uint effectiveTime\n', '        )\n', '    {\n', '        effectiveTime = effectiveTimeMap[wallet][addr];\n', '        isWhitelistedAndEffective = effectiveTime > 0 && effectiveTime <= block.timestamp;\n', '    }\n', '\n', '    function whitelistSize(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return numAddressesInSet(_walletKey(wallet));\n', '    }\n', '\n', '    function dapps()\n', '        public\n', '        view\n', '        returns (\n', '            address[] memory addresses\n', '        )\n', '    {\n', '        return addressesInSet(DAPPS);\n', '    }\n', '\n', '    function isDapp(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return isAddressInSet(DAPPS, addr);\n', '    }\n', '\n', '    function numDapps()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return numAddressesInSet(DAPPS);\n', '    }\n', '\n', '    function isDappOrWhitelisted(\n', '        address wallet,\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool res)\n', '    {\n', '        (res,) = isWhitelisted(wallet, addr);\n', '        return res || isAddressInSet(DAPPS, addr);\n', '    }\n', '\n', '    function _walletKey(address addr)\n', '        private\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(abi.encodePacked("__WHITELIST__", addr));\n', '    }\n', '\n', '}']