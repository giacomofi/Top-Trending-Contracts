['pragma solidity 0.7.1;\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function burn(uint256 value) external returns (bool);\n', '\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '}\n', '\n', 'contract PoolRewardToken {\n', '    mapping (address => uint256) public _balanceOf;\n', '\n', '    string public constant name = "MalwareChain DAO";\n', '    string public constant symbol = "MDAO";\n', '    uint8 public constant decimals = 18;\n', '    uint256 public totalSupply = 0;\n', '    mapping(address => mapping(address => uint256)) private _allowances;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function balanceOf(address account) public view returns (uint256 value) {\n', '        return _balanceOf[account];\n', '    }\n', '\n', '    function transfer(address to, uint256 value) public returns (bool success) {\n', '        require(_balanceOf[msg.sender] >= value);\n', '\n', "        _balanceOf[msg.sender] -= value;  // deduct from sender's balance\n", "        _balanceOf[to] += value;          // add to recipient's balance\n", '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function transferMultiple(address[] memory to, uint256 value) public returns (bool success) {\n', '        require(_balanceOf[msg.sender] >= value);\n', '\n', '        _balanceOf[msg.sender] -= value;\n', '        value /= to.length;\n', '        for (uint256 i = 0; i < to.length; i++) {\n', '            _balanceOf[to[i]] += value;\n', '            emit Transfer(msg.sender, to[i], value);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 value) public returns (bool success) {\n', '        _allowances[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n', '        require(value <= _balanceOf[from]);\n', '        require(value <= _allowances[from][msg.sender]);\n', '\n', '        _balanceOf[from] -= value;\n', '        _balanceOf[to] += value;\n', '        _allowances[from][msg.sender] -= value;\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    function mint(address to, uint256 value) internal {\n', '        totalSupply += value;\n', '        _balanceOf[to] += value;\n', '        emit Transfer(address(0), to, value);\n', '    }\n', '\n', '    function burn(uint256 value) public returns (bool success) {\n', '        require(value <= _balanceOf[msg.sender]);\n', '        totalSupply -= value;\n', '        _balanceOf[msg.sender] -= value;\n', '        return true;\n', '    }\n', '}\n', '\n', 'abstract contract Ownable {\n', '    address public owner_;\n', '\n', '    constructor() {\n', '        owner_ = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender == owner_)\n', '            _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        if (newOwner != address(0)) owner_ = newOwner;\n', '    }\n', '}\n', '\n', 'contract MiningPool is PoolRewardToken, Ownable {\n', '    uint8 public constant BLOCK_STEP = 10;\n', '    uint256 public constant BLOCK_FEE_PERCENT = 100000;\n', '\n', '    struct Investor {\n', '        uint256 depositMALW;\n', '        uint256 depositLPETH;\n', '        uint256 depositLPUSDT;\n', '        uint256 lastZeroPtr;\n', '        bool initialized;\n', '    }\n', '\n', '    struct BlockInfo {\n', '        uint256 totalDepositsMALW;\n', '        uint256 totalDepositsLPETH;\n', '        uint256 totalDepositsLPUSDT;\n', '        uint256 lpETHPrice;\n', '        uint256 lpUSDTPrice;\n', '        uint256 blockLength;\n', '        uint256 blockReward;\n', '        uint256 lpPart;\n', '    }\n', '\n', '    uint256 public BLOCK_REWARD = 10**18 * 400;\n', '    uint256 public LP_PART = 10**4 * 80;\n', '    uint256 public deployBlock;\n', '    uint256 public lastRecordedBlock;\n', '    uint256 public totalDepositsMALW;\n', '    uint256 public totalDepositsLPETH;\n', '    uint256 public totalDepositsLPUSDT;\n', '    BlockInfo[1000000] public history;\n', '    uint256 public arrayPointer;\n', '    mapping (address => Investor) public investors;\n', '    bool public miningFinished = false;\n', '    uint256 public masternodeRewardsBalance;\n', '    uint256 public feesBalance;\n', '    mapping (uint256 => uint256) public masternodeRewardsClaimedNonces;\n', '\n', '    IERC20 public _tokenMALW;\n', '    IERC20 public _tokenLPETH;\n', '    IERC20 public _tokenLPUSDT;\n', '\n', '    event Deposit(address indexed investor, uint256 valueMALW, uint256 valueLPETH, uint256 valueLPUSDT);\n', '    event Harvest(address indexed investor, uint256 value);\n', '    event Withdraw(address indexed investor, uint256 valueMALW, uint256 valueLPETH, uint256 valueLPUSDT);\n', '    event MasternodeReward(address indexed owner, uint256 value, uint256 nonce);\n', '    event FeesSpent(address indexed to, uint256 value);\n', '    event RewardChanged(uint256 newValue);\n', '    event LPPartChanged(uint256 newValue);\n', '\n', '    constructor() {\n', '        deployBlock = block.number;\n', '        emit RewardChanged(BLOCK_REWARD);\n', '    }\n', '\n', '    function setMALWToken(address token) public {\n', '        require(address(_tokenMALW) == address(0), "Address was already set");\n', '        _tokenMALW = IERC20(token);\n', '    }\n', '\n', '    function setLPETHToken(address token) public {\n', '        require(address(_tokenLPETH) == address(0), "Address was already set");\n', '        _tokenLPETH = IERC20(token);\n', '    }\n', '\n', '    function setLPUSDTToken(address token) public {\n', '        require(address(_tokenLPUSDT) == address(0), "Address was already set");\n', '        _tokenLPUSDT = IERC20(token);\n', '    }\n', '\n', '    function setBlockReward(uint256 value) public onlyOwner {\n', '        recordHistory();\n', '        BLOCK_REWARD = value;\n', '        emit RewardChanged(value);\n', '    }\n', '\n', '    function setLPPart(uint256 value) public onlyOwner {  // 1% = 10000\n', '        require(value < 90 * 10**4, "Maximum value is 900000 (90%)");\n', '        recordHistory();\n', '        LP_PART = value;\n', '        emit LPPartChanged(value);\n', '    }\n', '\n', '    function currentBlock() public view returns (uint256) {\n', '        return (block.number - deployBlock) / BLOCK_STEP;\n', '    }\n', '\n', '    function recordHistoryNeeded() public view returns (bool) {\n', '        return !miningFinished && lastRecordedBlock < currentBlock();\n', '    }\n', '\n', '    function getBlockTotalDepositsMALW(uint256 blk) public view returns (uint256) {\n', '        if (blk >= arrayPointer)\n', '            return totalDepositsMALW;\n', '        return history[blk].totalDepositsMALW;\n', '    }\n', '\n', '    function getBlockTotalDepositsLPETH(uint256 blk) public view returns (uint256) {\n', '        if (blk >= arrayPointer)\n', '            return totalDepositsLPETH;\n', '        return history[blk].totalDepositsLPETH;\n', '    }\n', '\n', '    function getBlockTotalDepositsLPUSDT(uint256 blk) public view returns (uint256) {\n', '        if (blk >= arrayPointer)\n', '            return totalDepositsLPUSDT;\n', '        return history[blk].totalDepositsLPUSDT;\n', '    }\n', '\n', '    function getBlockLPETHPrice(uint256 blk) public view returns (uint256) {\n', '        if (blk >= arrayPointer)\n', '            return getCurrentLPETHPrice();\n', '        return history[blk].lpETHPrice;\n', '    }\n', '\n', '    function getBlockLPUSDTPrice(uint256 blk) public view returns (uint256) {\n', '        if (blk >= arrayPointer)\n', '            return getCurrentLPUSDTPrice();\n', '        return history[blk].lpUSDTPrice;\n', '    }\n', '\n', '    function getCurrentLPETHPrice() public view returns (uint256) {\n', '        if (address(_tokenLPETH) == address(0))\n', '            return 0;\n', '        return _tokenLPETH.totalSupply() > 0 ? getReserve(_tokenLPETH) / _tokenLPETH.totalSupply() : 0;  // both MALWDAO and UNI-V2 have 18 decimals\n', '    }\n', '\n', '    function getCurrentLPUSDTPrice() public view returns (uint256) {\n', '        if (address(_tokenLPUSDT) == address(0))\n', '            return 0;\n', '        return _tokenLPUSDT.totalSupply() > 0 ? getReserve(_tokenLPUSDT) / _tokenLPUSDT.totalSupply() : 0;  // both MALWDAO and UNI-V2 have 18 decimals\n', '    }\n', '\n', '    function getRewardDistribution(uint256 blk) public view returns (uint256 malw, uint256 lp) {\n', '        if (blk > 787500) {  // 157500000 MALWDAO limit\n', '            return (0, 0);\n', '        }\n', '        lp = (getBlockTotalDepositsLPETH(blk) + getBlockTotalDepositsLPUSDT(blk)) <= 0 ? 0 : getLPPart(blk);\n', '        malw = getBlockTotalDepositsMALW(blk) <= 0 ? 0 : 1000000 - lp - BLOCK_FEE_PERCENT;\n', '    }\n', '\n', '    function recordHistory() public returns (bool) {\n', '        if (recordHistoryNeeded()) {\n', '            _recordHistory();\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function _recordHistory() internal {\n', '        // miningFinished check is in recordHistoryNeeded();\n', '\n', '        uint256 currentBlk = currentBlock();\n', '\n', '        if (currentBlk > 787500) {\n', '            currentBlk = 787500;\n', '            miningFinished = true;\n', '        }\n', '\n', '        uint256 lpETHPrice = getCurrentLPETHPrice();\n', '        uint256 lpUSDTPrice = getCurrentLPUSDTPrice();\n', '\n', '        history[arrayPointer].totalDepositsMALW = totalDepositsMALW;\n', '        history[arrayPointer].totalDepositsLPETH = totalDepositsLPETH;\n', '        history[arrayPointer].totalDepositsLPUSDT = totalDepositsLPUSDT;\n', '        history[arrayPointer].lpETHPrice = lpETHPrice;\n', '        history[arrayPointer].lpUSDTPrice = lpUSDTPrice;\n', '        history[arrayPointer].blockLength = currentBlk - lastRecordedBlock;\n', '        history[arrayPointer].blockReward = BLOCK_REWARD;\n', '        history[arrayPointer].lpPart = LP_PART;\n', '\n', '        masternodeRewardsBalance += BLOCK_REWARD / 20 * (currentBlk - lastRecordedBlock);  // 5%\n', '        feesBalance += BLOCK_REWARD / 20 * (currentBlk - lastRecordedBlock);  // 5%\n', '\n', '        arrayPointer++;\n', '        lastRecordedBlock = currentBlk;\n', '    }\n', '\n', '    function getReserve(IERC20 token) internal view returns (uint256) {\n', '        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = token.getReserves();\n', '        return token.token0() == address(this) ? uint256(reserve0) : uint256(reserve1);\n', '    }\n', '\n', '    function getBlockLength(uint256 blk) internal view returns (uint256) {\n', '        if (blk >= arrayPointer) {\n', '            return currentBlock() - lastRecordedBlock;\n', '        }\n', '        return history[blk].blockLength;\n', '    }\n', '\n', '    function getBlockReward(uint256 blk) internal view returns (uint256) {\n', '        if (blk >= arrayPointer) {\n', '            return BLOCK_REWARD;\n', '        }\n', '        return history[blk].blockReward;\n', '    }\n', '\n', '    function getLPPart(uint256 blk) internal view returns (uint256) {\n', '        if (blk >= arrayPointer) {\n', '            return LP_PART;\n', '        }\n', '        return history[blk].lpPart;\n', '    }\n', '\n', '    function getRewardSum(address sender) public view returns (uint256) {\n', '        if (!investors[sender].initialized || !canHarvest(sender))\n', '            return 0;\n', '\n', '        uint256 reward = 0;\n', '\n', '        for (uint256 i = investors[sender].lastZeroPtr; i <= arrayPointer; i++) {\n', '            (uint256 malwPercent, uint256 lpPercent) = getRewardDistribution(i);\n', '            uint256 lpETHPrice = getBlockLPETHPrice(i);\n', '            uint256 lpUSDTPrice = getBlockLPUSDTPrice(i);\n', '            uint256 totalNormalizedLP = lpETHPrice * getBlockTotalDepositsLPETH(i) + lpUSDTPrice * getBlockTotalDepositsLPUSDT(i);\n', '            uint256 userNormalizedLP = lpETHPrice * investors[sender].depositLPETH + lpUSDTPrice * investors[sender].depositLPUSDT;\n', '\n', '            if (investors[sender].depositMALW > 0)\n', '                reward += getBlockReward(i) * getBlockLength(i) * investors[sender].depositMALW / getBlockTotalDepositsMALW(i) * malwPercent / 1000000;\n', '            if (userNormalizedLP > 0)\n', '                reward += getBlockReward(i) * getBlockLength(i) * userNormalizedLP / totalNormalizedLP * lpPercent / 1000000;\n', '        }\n', '\n', '        return reward;\n', '    }\n', '\n', '    function deposit(uint256 valueMALW, uint256 valueLPETH, uint256 valueLPUSDT) public {\n', '        require(valueMALW + valueLPETH + valueLPUSDT > 0 &&\n', '                valueMALW >= 0 &&\n', '                valueLPETH >= 0 &&\n', '                valueLPUSDT >= 0, "Invalid arguments");\n', '\n', '        if (canHarvest(msg.sender))\n', '            harvestReward();  // history is recorded while harvesting\n', '        else\n', '            recordHistory();\n', '\n', '        if (valueMALW > 0) {\n', '            require(_tokenMALW.allowance(msg.sender, address(this)) >= valueMALW, "Insufficient MALW allowance");\n', '            investors[msg.sender].depositMALW += valueMALW;\n', '            totalDepositsMALW += valueMALW;\n', '            _tokenMALW.transferFrom(msg.sender, address(this), valueMALW);\n', '        }\n', '\n', '        if (valueLPETH > 0) {\n', '            require(_tokenLPETH.allowance(msg.sender, address(this)) >= valueLPETH, "Insufficient LPETH allowance");\n', '            investors[msg.sender].depositLPETH += valueLPETH;\n', '            totalDepositsLPETH += valueLPETH;\n', '            _tokenLPETH.transferFrom(msg.sender, address(this), valueLPETH);\n', '        }\n', '\n', '        if (valueLPUSDT > 0) {\n', '            require(_tokenLPUSDT.allowance(msg.sender, address(this)) >= valueLPUSDT, "Insufficient LPUSDT allowance");\n', '            investors[msg.sender].depositLPUSDT += valueLPUSDT;\n', '            totalDepositsLPUSDT += valueLPUSDT;\n', '            _tokenLPUSDT.transferFrom(msg.sender, address(this), valueLPUSDT);\n', '        }\n', '\n', '        investors[msg.sender].initialized = true;\n', '        investors[msg.sender].lastZeroPtr = arrayPointer;\n', '        emit Deposit(msg.sender, valueMALW, valueLPETH, valueLPUSDT);\n', '    }\n', '\n', '    function canHarvest(address sender) public view returns (bool) {\n', '        return investors[sender].depositMALW + investors[sender].depositLPETH + investors[sender].depositLPUSDT > 0;\n', '    }\n', '\n', '    function harvestReward() public returns (uint256) {\n', '        require(canHarvest(msg.sender));\n', '\n', '        recordHistory();\n', '\n', '        uint256 reward = getRewardSum(msg.sender);\n', '        if (reward > 0)\n', '            mint(msg.sender, reward);\n', '        investors[msg.sender].lastZeroPtr = arrayPointer;\n', '        emit Harvest(msg.sender, reward);\n', '\n', '        return reward;\n', '    }\n', '\n', '    function harvestRewardAndWithdraw() public returns (uint256, uint256, uint256, uint256) {\n', '        uint256 reward = harvestReward();\n', '        uint256 depositMALW = investors[msg.sender].depositMALW;\n', '        uint256 depositLPETH = investors[msg.sender].depositLPETH;\n', '        uint256 depositLPUSDT = investors[msg.sender].depositLPUSDT;\n', '\n', '        if (depositMALW > 0) {\n', '            totalDepositsMALW -= depositMALW;\n', '            investors[msg.sender].depositMALW = 0;\n', '            _tokenMALW.transfer(msg.sender, depositMALW);\n', '        }\n', '\n', '        if (depositLPETH > 0) {\n', '            totalDepositsLPETH -= depositLPETH;\n', '            investors[msg.sender].depositLPETH = 0;\n', '            _tokenLPETH.transfer(msg.sender, depositLPETH);\n', '        }\n', '\n', '        if (depositLPUSDT > 0) {\n', '            totalDepositsLPUSDT -= depositLPUSDT;\n', '            investors[msg.sender].depositLPUSDT = 0;\n', '            _tokenLPUSDT.transfer(msg.sender, depositLPUSDT);\n', '        }\n', '\n', '        emit Withdraw(msg.sender, depositMALW, depositLPETH, depositLPUSDT);\n', '\n', '        return (reward, depositMALW, depositLPETH, depositLPUSDT);\n', '    }\n', '\n', '    function splitSignature(bytes memory sig) internal pure returns (uint8, bytes32, bytes32) {\n', '        require(sig.length == 65);\n', '\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        assembly {\n', '            // first 32 bytes, after the length prefix\n', '            r := mload(add(sig, 32))\n', '            // second 32 bytes\n', '            s := mload(add(sig, 64))\n', '            // final byte (first byte of the next 32 bytes)\n', '            v := byte(0, mload(add(sig, 96)))\n', '        }\n', '\n', '        return (v, r, s);\n', '    }\n', '\n', '    function recoverSigner(bytes32 message, bytes memory sig) internal pure returns (address) {\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '\n', '        (v, r, s) = splitSignature(sig);\n', '\n', '        return ecrecover(message, v, r, s);\n', '    }\n', '\n', '    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '\n', '    function claimMasternodeReward(uint256 amount, uint256 nonce, bytes memory sig) public {\n', '        require(masternodeRewardsClaimedNonces[nonce] == 0, "This signature is already used");\n', '\n', '        recordHistory();\n', '\n', '        require(amount <= masternodeRewardsBalance, "Insufficient reward funds");\n', '\n', '        bytes32 message = prefixed(keccak256(abi.encodePacked(msg.sender, amount, nonce, address(this))));\n', '        require(recoverSigner(message, sig) == owner_);\n', '\n', '        masternodeRewardsClaimedNonces[nonce] = amount;\n', '        _balanceOf[msg.sender] += amount;\n', '        masternodeRewardsBalance -= amount;\n', '        emit MasternodeReward(msg.sender, amount, nonce);\n', '    }\n', '\n', '    function sendFeeFunds(address to, uint256 amount) public onlyOwner {\n', '        require(feesBalance >= amount, "Insufficient funds");\n', '\n', '        _balanceOf[to] += amount;\n', '        feesBalance -= amount;\n', '        emit FeesSpent(to, amount);\n', '    }\n', '}']