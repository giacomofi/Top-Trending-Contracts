['// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity ^0.6.9;\n', '\n', 'contract Owned {\n', '    address payable public owner;\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner() {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address payable newOwner) external onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256 c) {\n', '        require(b <= a, errorMessage);\n', '        c = a - b;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a >= b ? a : b;\n', '    }\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a <= b ? a : b;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address owner) external view returns (uint256);\n', '    function transfer(address to, uint256 amount) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 amount);\n', '    event Approval(address indexed owner, address indexed spender, uint256 amount);\n', '}\n', '\n', '// ----------------------------------------------------------------------------------\n', '// DutchSwap Auction Contract\n', '//\n', '//\n', '// This contract is modified from the contract by (c) Adrian Guerrera. Deepyr Pty Ltd.  \n', '// (https://github.com/apguerrera/DutchSwap)\n', '//                        \n', '// Sep 02 2020                                  \n', '// -----------------------------------------------------------------------------------\n', '\n', 'contract DutchSwapAuction is Owned {\n', '\n', '    using SafeMath for uint256;\n', '    uint256 private constant TENPOW18 = 10 ** 18;\n', '\n', '    uint256 public amountRaised;\n', '    uint256 public startDate;\n', '    uint256 public endDate;\n', '    uint256 public startPrice;\n', '    uint256 public minimumPrice;\n', '    uint256 public tokenSupply;\n', '    uint256 public tokenSold;\n', '    bool public finalised;\n', '    uint256 public withdrawDelay;   // delay in seconds preventing withdraws\n', '    uint256 public tokenWithdrawn;  // the amount of auction tokens already withdrawn by bidders\n', '    IERC20 public auctionToken; \n', '    address payable public wallet;\n', '    mapping(address => uint256) public commitments;\n', '\n', '    uint256 private unlocked = 1;\n', '\n', '    event AddedCommitment(address addr, uint256 commitment, uint256 price);\n', '\n', '    modifier lock() {\n', "        require(unlocked == 1, 'Locked');\n", '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }       \n', '\n', '    /// @dev Init function \n', '    function initDutchAuction(\n', '        address _token, \n', '        uint256 _tokenSupply, \n', '        //uint256 _startDate, \n', '        uint256 _auctionDuration,\n', '        uint256 _startPrice, \n', '        uint256 _minimumPrice,\n', '        uint256 _withdrawDelay,\n', '        address payable _wallet\n', '    ) \n', '        external onlyOwner\n', '    {\n', '        require(_auctionDuration > 0, "Auction duration should be longer than 0 seconds");\n', '        require(_startPrice > _minimumPrice, "Start price should be bigger than minimum price");\n', '        require(_minimumPrice > 0, "Minimum price should be bigger than 0");\n', '\n', '        auctionToken = IERC20(_token);\n', '\n', '        require(IERC20(auctionToken).transferFrom(msg.sender, address(this), _tokenSupply), "Fail to transfer tokens to this contract");\n', '\n', '        // 100 tokens are subtracted from totalSupply to ensure that this contract holds more tokens than tokenSuppy.\n', '        // This is to prevent any reverting of withdrawTokens() in case of any insufficiency of tokens due to programming\n', "        // languages' inability to handle float precisely, which might lead to extremely small insufficiency in tokens\n", '        // to be distributed. This potentail insufficiency is extremely small (far less than 1 token), which is more than\n', '        // sufficiently compensated hence.       \n', '        tokenSupply =_tokenSupply.sub(100000000000000000000);\n', '        startDate = block.timestamp;\n', '        endDate = block.timestamp.add(_auctionDuration);\n', '        startPrice = _startPrice;\n', '        minimumPrice = _minimumPrice; \n', '        withdrawDelay = _withdrawDelay;\n', '        wallet = _wallet;\n', '        finalised = false;\n', '    }\n', '\n', '\n', '    // Dutch Auction Price Function\n', '    // ============================\n', '    //  \n', '    // Start Price ----- \n', '    //                   \\ \n', '    //                    \\\n', '    //                     \\\n', '    //                      \\ ------------ Clearing Price\n', '    //                     / \\            = AmountRaised/TokenSupply\n', '    //      Token Price  --   \\\n', '    //                  /      \\ \n', '    //                --        ----------- Minimum Price\n', '    // Amount raised /          End Time\n', '    //\n', '\n', '    /// @notice The average price of each token from all commitments. \n', '    function tokenPrice() public view returns (uint256) {\n', '        return amountRaised.mul(TENPOW18).div(tokenSold);\n', '    }\n', '\n', '    /// @notice Token price decreases at this rate during auction.\n', '    function priceGradient() public view returns (uint256) {\n', '        uint256 numerator = startPrice.sub(minimumPrice);\n', '        uint256 denominator = endDate.sub(startDate);\n', '        return numerator.div(denominator);\n', '    }\n', '\n', '      /// @notice Returns price during the auction \n', '    function priceFunction() public view returns (uint256) {\n', '        /// @dev Return Auction Price\n', '        if (block.timestamp <= startDate) {\n', '            return startPrice;\n', '        }\n', '        if (block.timestamp >= endDate) {\n', '            return minimumPrice;\n', '        }\n', '        uint256 priceDiff = block.timestamp.sub(startDate).mul(priceGradient());\n', '        uint256 price = startPrice.sub(priceDiff);\n', '        return price;\n', '    }\n', '\n', '    /// @notice How many tokens the user is able to claim\n', '    function tokensClaimable(address _user) public view returns (uint256) {\n', '        if(!auctionEnded()) {\n', '            return 0;\n', '        }\n', '        return commitments[_user].mul(TENPOW18).div(tokenPrice());\n', '    }\n', '\n', '    /// @notice Returns bool if successful or time has ended\n', '    function auctionEnded() public view returns (bool){\n', '        return block.timestamp > endDate;\n', '    }\n', '\n', '    /// @notice Returns true and 0 if delay time is 0, otherwise false and delay time (in seconds) \n', '    function checkWithdraw() public view returns (bool, uint256) {\n', '        if (block.timestamp < endDate) {\n', '            return (false, endDate.sub(block.timestamp).add(withdrawDelay));\n', '        }\n', '\n', '        uint256 _elapsed = block.timestamp.sub(endDate);\n', '        if (_elapsed >= withdrawDelay) {\n', '            return (true, 0);\n', '        } else {\n', '            return (false, withdrawDelay.sub(_elapsed));\n', '        }\n', '    }\n', '\n', '    /// @notice Returns the amount of auction tokens already withdrawn by bidders\n', '    function getTokenWithdrawn() public view returns (uint256) {\n', '        return tokenWithdrawn;\n', '    }\n', '\n', '    /// @notice Returns the amount of auction tokens sold but not yet withdrawn by bidders\n', '    function getTokenNotYetWithdrawn() public view returns (uint256) {\n', '        if (block.timestamp < endDate) {\n', '            return tokenSold;\n', '        }\n', '        uint256 totalTokenSold = amountRaised.mul(TENPOW18).div(tokenPrice());\n', '        return totalTokenSold.sub(tokenWithdrawn);\n', '    }\n', '\n', '    //--------------------------------------------------------\n', '    // Commit to buying tokens \n', '    //--------------------------------------------------------\n', '\n', '    /// @notice Buy Tokens by committing ETH to this contract address \n', '    receive () external payable {\n', '        commitEth(msg.sender);\n', '    }\n', '\n', '    /// @notice Commit ETH to buy tokens on sale\n', '    function commitEth (address payable _from) public payable lock {\n', '        //require(address(paymentCurrency) == ETH_ADDRESS);\n', '        require(block.timestamp >= startDate && block.timestamp <= endDate);\n', '\n', '        uint256 tokensToPurchase = msg.value.mul(TENPOW18).div(priceFunction());\n', '        // Get ETH able to be committed\n', '        uint256 tokensPurchased = calculatePurchasable(tokensToPurchase);\n', '\n', '        tokenSold = tokenSold.add(tokensPurchased);\n', '\n', '        // Accept ETH Payments\n', '        uint256 ethToTransfer = tokensPurchased < tokensToPurchase ? msg.value.mul(tokensPurchased).div(tokensToPurchase) : msg.value;\n', '\n', '        uint256 ethToRefund = msg.value.sub(ethToTransfer);\n', '        if (ethToTransfer > 0) {\n', '            addCommitment(_from, ethToTransfer);\n', '        }\n', '        // Return any ETH to be refunded\n', '        if (ethToRefund > 0) {\n', '            _from.transfer(ethToRefund);\n', '        }\n', '    }\n', '\n', '    /// @notice Commits to an amount during an auction\n', '    function addCommitment(address _addr,  uint256 _commitment) internal {\n', '        commitments[_addr] = commitments[_addr].add(_commitment);\n', '        amountRaised = amountRaised.add(_commitment);\n', '        emit AddedCommitment(_addr, _commitment, tokenPrice());\n', '    }\n', '\n', '    /// @notice Returns the amount able to be committed during an auction\n', '    function calculatePurchasable(uint256 _tokensToPurchase) \n', '        public view returns (uint256)\n', '    {\n', '        uint256 maxPurchasable = tokenSupply.sub(tokenSold);\n', '        if (_tokensToPurchase > maxPurchasable) {\n', '            return maxPurchasable;\n', '        }\n', '        return _tokensToPurchase;\n', '    }\n', '\n', '    //--------------------------------------------------------\n', '    // Modify WithdrawDelay In Auction \n', '    //--------------------------------------------------------\n', '\n', '    /// @notice Removes withdraw delay\n', '    /// @dev This function can only be carreid out by the owner of this contract.\n', '    function removeWithdrawDelay() external onlyOwner {\n', '        withdrawDelay = 0;\n', '    }\n', '    \n', '    /// @notice Add withdraw delay\n', '    /// @dev This function can only be carreid out by the owner of this contract.\n', '    function addWithdrawDelay(uint256 _delay) external onlyOwner {\n', '        withdrawDelay = withdrawDelay.add(_delay);\n', '    }\n', '\n', '\n', '    //--------------------------------------------------------\n', '    // Finalise Auction\n', '    //--------------------------------------------------------\n', '\n', '    /// @notice Auction finishes successfully above the reserve\n', '    /// @dev Transfer contract funds to initialised wallet. \n', '    function finaliseAuction () public {\n', '        require(!finalised && auctionEnded());\n', '        finalised = true;\n', '\n', '        //_tokenPayment(paymentCurrency, wallet, amountRaised);\n', '        wallet.transfer(amountRaised);\n', '    }\n', '\n', '    /// @notice Withdraw your tokens once the Auction has ended.\n', '    function withdrawTokens() public lock {\n', '        require(auctionEnded(), "DutchSwapAuction: Auction still live");\n', '        (bool canWithdraw,) = checkWithdraw();\n', '        require(canWithdraw == true, "DutchSwapAuction: Withdraw Delay");\n', '        uint256 fundsCommitted = commitments[ msg.sender];\n', '        require(fundsCommitted > 0, "You have no bidded tokens");\n', '        uint256 tokensToClaim = tokensClaimable(msg.sender);\n', '        commitments[ msg.sender] = 0;\n', '        tokenWithdrawn = tokenWithdrawn.add(tokensToClaim);\n', '\n', '        /// @notice Successful auction! Transfer tokens bought.\n', '        if (tokensToClaim > 0 ) {\n', '            _tokenPayment(auctionToken, msg.sender, tokensToClaim);\n', '        }\n', '    }\n', '\n', '    /// @notice Transfer unbidded auction token to a new address after auction ends\n', '    /// @dev This function can only be carreid out by the owner of this contract.\n', '    function transferLeftOver(uint256 _amount, address payable _addr) external onlyOwner returns (bool) {\n', '        require(block.timestamp > endDate.add(withdrawDelay).add(7 * 24 * 60 * 60), "Cannot transfer auction tokens within 7 days after withdraw day");\n', '        require(_amount > 0, "Cannot transfer 0 tokens");\n', '        _tokenPayment(auctionToken, _addr, _amount);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Helper function to handle ERC20 payments\n', '    function _tokenPayment(IERC20 _token, address payable _to, uint256 _amount) internal {\n', '        require(_token.transfer(_to, _amount), "Fail to transfer tokens");\n', '    }\n', '\n', '}']