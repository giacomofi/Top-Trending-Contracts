['# @version 0.2.7\n', '"""\n', '@title Curve Registry\n', '@license MIT\n', '@author Curve.Fi\n', '"""\n', '\n', 'MAX_COINS: constant(int128) = 8\n', 'CALC_INPUT_SIZE: constant(int128) = 100\n', '\n', '\n', 'struct PoolArray:\n', '    location: uint256\n', '    decimals: uint256\n', '    underlying_decimals: uint256\n', '    rate_method_id: bytes32\n', '    base_pool: address\n', '    coins: address[MAX_COINS]\n', '    ul_coins: address[MAX_COINS]\n', '    n_coins: uint256  # [coins, underlying coins] tightly packed as uint128[2]\n', '    has_initial_A: bool\n', '    is_v1: bool\n', '\n', 'struct PoolParams:\n', '    A: uint256\n', '    future_A: uint256\n', '    fee: uint256\n', '    admin_fee: uint256\n', '    future_fee: uint256\n', '    future_admin_fee: uint256\n', '    future_owner: address\n', '    initial_A: uint256\n', '    initial_A_time: uint256\n', '    future_A_time: uint256\n', '\n', '\n', 'interface AddressProvider:\n', '    def admin() -> address: view\n', '\n', 'interface ERC20:\n', '    def balanceOf(_addr: address) -> uint256: view\n', '    def decimals() -> uint256: view\n', '    def totalSupply() -> uint256: view\n', '\n', 'interface CurvePool:\n', '    def A() -> uint256: view\n', '    def future_A() -> uint256: view\n', '    def fee() -> uint256: view\n', '    def admin_fee() -> uint256: view\n', '    def future_fee() -> uint256: view\n', '    def future_admin_fee() -> uint256: view\n', '    def future_owner() -> address: view\n', '    def initial_A() -> uint256: view\n', '    def initial_A_time() -> uint256: view\n', '    def future_A_time() -> uint256: view\n', '    def coins(i: uint256) -> address: view\n', '    def underlying_coins(i: uint256) -> address: view\n', '    def balances(i: uint256) -> uint256: view\n', '    def get_virtual_price() -> uint256: view\n', '\n', 'interface CurvePoolV1:\n', '    def coins(i: int128) -> address: view\n', '    def underlying_coins(i: int128) -> address: view\n', '    def balances(i: int128) -> uint256: view\n', '\n', 'interface CurveMetapool:\n', '    def base_pool() -> address: view\n', '\n', 'interface GasEstimator:\n', '    def estimate_gas_used(_pool: address, _from: address, _to: address) -> uint256: view\n', '\n', 'interface LiquidityGauge:\n', '    def lp_token() -> address: view\n', '\n', 'interface GaugeController:\n', '    def gauge_types(gauge: address) -> int128: view\n', '\n', '\n', 'event PoolAdded:\n', '    pool: indexed(address)\n', '    rate_method_id: Bytes[4]\n', '\n', 'event PoolRemoved:\n', '    pool: indexed(address)\n', '\n', '\n', 'address_provider: public(AddressProvider)\n', 'gauge_controller: public(address)\n', 'pool_list: public(address[65536])   # master list of pools\n', 'pool_count: public(uint256)         # actual length of pool_list\n', '\n', 'pool_data: HashMap[address, PoolArray]\n', '\n', '# lp token -> pool\n', 'get_pool_from_lp_token: public(HashMap[address, address])\n', '\n', '# pool -> lp token\n', 'get_lp_token: public(HashMap[address, address])\n', '\n', '# mapping of estimated gas costs for pools and coins\n', '# for a pool the values are [wrapped exchange, underlying exchange]\n', '# for a coin the values are [transfer cost, 0]\n', 'gas_estimate_values: HashMap[address, uint256[2]]\n', '\n', '# pool -> gas estimation contract\n', '# used when gas costs for a pool are too complex to be handled by summing\n', '# values in `gas_estimate_values`\n', 'gas_estimate_contracts: HashMap[address, address]\n', '\n', '# mapping of coins -> pools for trading\n', '# a mapping key is generated for each pair of addresses via\n', '# `bitwise_xor(convert(a, uint256), convert(b, uint256))`\n', 'markets: HashMap[uint256, address[65536]]\n', 'market_counts: HashMap[uint256, uint256]\n', '\n', 'liquidity_gauges: HashMap[address, address[10]]\n', '\n', '\n', '@external\n', 'def __init__(_address_provider: address, _gauge_controller: address):\n', '    """\n', '    @notice Constructor function\n', '    """\n', '    self.address_provider = AddressProvider(_address_provider)\n', '    self.gauge_controller = _gauge_controller\n', '\n', '\n', '# internal functionality for getters\n', '\n', '@view\n', '@internal\n', 'def _unpack_decimals(_packed: uint256, _n_coins: uint256) -> uint256[MAX_COINS]:\n', '    # decimals are tightly packed as a series of uint8 within a little-endian bytes32\n', '    # the packed value is stored as uint256 to simplify unpacking via shift and modulo\n', '    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\n', '    n_coins: int128 = convert(_n_coins, int128)\n', '    for i in range(MAX_COINS):\n', '        if i == n_coins:\n', '            break\n', '        decimals[i] = shift(_packed, -8 * i) % 256\n', '\n', '    return decimals\n', '\n', '\n', '@view\n', '@internal\n', 'def _get_rates(_pool: address) -> uint256[MAX_COINS]:\n', '    rates: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\n', '    base_pool: address = self.pool_data[_pool].base_pool\n', '    if base_pool == ZERO_ADDRESS:\n', '        rate_method_id: Bytes[4] = slice(self.pool_data[_pool].rate_method_id, 28, 4)\n', '\n', '        for i in range(MAX_COINS):\n', '            coin: address = self.pool_data[_pool].coins[i]\n', '            if coin == ZERO_ADDRESS:\n', '                break\n', '            if coin == self.pool_data[_pool].ul_coins[i]:\n', '                rates[i] = 10 ** 18\n', '            else:\n', '                rates[i] = convert(\n', '                    raw_call(coin, rate_method_id, max_outsize=32, is_static_call=True), # dev: bad response\n', '                    uint256\n', '                )\n', '    else:\n', '        base_coin_idx: uint256 = shift(self.pool_data[_pool].n_coins, -128) - 1\n', '        rates[base_coin_idx] = CurvePool(base_pool).get_virtual_price()\n', '        for i in range(MAX_COINS):\n', '            if i == base_coin_idx:\n', '                break\n', '            rates[i] = 10 ** 18\n', '\n', '    return rates\n', '\n', '@view\n', '@internal\n', 'def _get_balances(_pool: address) -> uint256[MAX_COINS]:\n', '    is_v1: bool = self.pool_data[_pool].is_v1\n', '\n', '    balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\n', '    for i in range(MAX_COINS):\n', '        if self.pool_data[_pool].coins[i] == ZERO_ADDRESS:\n', '            assert i != 0\n', '            break\n', '\n', '        if is_v1:\n', '            balances[i] = CurvePoolV1(_pool).balances(i)\n', '        else:\n', '            balances[i] = CurvePool(_pool).balances(convert(i, uint256))\n', '\n', '    return balances\n', '\n', '\n', '@view\n', '@internal\n', 'def _get_underlying_balances(_pool: address) -> uint256[MAX_COINS]:\n', '    balances: uint256[MAX_COINS] = self._get_balances(_pool)\n', '    rates: uint256[MAX_COINS] = self._get_rates(_pool)\n', '    decimals: uint256 = self.pool_data[_pool].underlying_decimals\n', '    underlying_balances: uint256[MAX_COINS] = balances\n', '    for i in range(MAX_COINS):\n', '        coin: address = self.pool_data[_pool].coins[i]\n', '        if coin == ZERO_ADDRESS:\n', '            break\n', '        ucoin: address = self.pool_data[_pool].ul_coins[i]\n', '        if ucoin == ZERO_ADDRESS:\n', '            continue\n', '        if ucoin != coin:\n', '            underlying_balances[i] = balances[i] * rates[i] / 10**(shift(decimals, -8 * i) % 256)\n', '\n', '    return underlying_balances\n', '\n', '\n', '@view\n', '@internal\n', 'def _get_meta_underlying_balances(_pool: address, _base_pool: address) -> uint256[MAX_COINS]:\n', '    base_coin_idx: uint256 = shift(self.pool_data[_pool].n_coins, -128) - 1\n', '    is_v1: bool = self.pool_data[_base_pool].is_v1\n', '    base_total_supply: uint256 = ERC20(self.get_lp_token[_base_pool]).totalSupply()\n', '\n', '    underlying_balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\n', '    ul_balance: uint256 = 0\n', '    underlying_pct: uint256 = 0\n', '    if base_total_supply > 0:\n', '        underlying_pct = CurvePool(_pool).balances(base_coin_idx) * 10**36 / base_total_supply\n', '\n', '    for i in range(MAX_COINS):\n', '        if self.pool_data[_pool].ul_coins[i] == ZERO_ADDRESS:\n', '            break\n', '        if i < base_coin_idx:\n', '            ul_balance = CurvePool(_pool).balances(i)\n', '        else:\n', '            if is_v1:\n', '                ul_balance = CurvePoolV1(_base_pool).balances(convert(i - base_coin_idx, int128))\n', '            else:\n', '                ul_balance = CurvePool(_base_pool).balances(i-base_coin_idx)\n', '            ul_balance = ul_balance * underlying_pct / 10**36\n', '        underlying_balances[i] = ul_balance\n', '\n', '    return underlying_balances\n', '\n', '\n', '@view\n', '@internal\n', 'def _get_coin_indices(\n', '    _pool: address,\n', '    _from: address,\n', '    _to: address\n', ') -> uint256[3]:\n', '    """\n', '    Convert coin addresses to indices for use with pool methods.\n', '    """\n', '    # the return value is stored as `uint256[3]` to reduce gas costs\n', '    # from index, to index, is the market underlying?\n', '    result: uint256[3] = empty(uint256[3])\n', '\n', '    found_market: bool = False\n', '\n', '    # check coin markets\n', '    for x in range(MAX_COINS):\n', '        coin: address = self.pool_data[_pool].coins[x]\n', '        if coin == ZERO_ADDRESS:\n', '            # if we reach the end of the coins, reset `found_market` and try again\n', '            # with the underlying coins\n', '            found_market = False\n', '            break\n', '        if coin == _from:\n', '            result[0] = x\n', '        elif coin == _to:\n', '            result[1] = x\n', '        else:\n', '            continue\n', '\n', '        if found_market:\n', '            # the second time we find a match, break out of the loop\n', '            break\n', '        # the first time we find a match, set `found_market` to True\n', '        found_market = True\n', '\n', '    if not found_market:\n', '        # check underlying coin markets\n', '        for x in range(MAX_COINS):\n', '            coin: address = self.pool_data[_pool].ul_coins[x]\n', '            if coin == ZERO_ADDRESS:\n', '                raise "No available market"\n', '            if coin == _from:\n', '                result[0] = x\n', '            elif coin == _to:\n', '                result[1] = x\n', '            else:\n', '                continue\n', '\n', '            if found_market:\n', '                result[2] = 1\n', '                break\n', '            found_market = True\n', '\n', '    return result\n', '\n', '\n', '# targetted external getters, optimized for on-chain calls\n', '\n', '@view\n', '@external\n', 'def find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) -> address:\n', '    """\n', '    @notice Find an available pool for exchanging two coins\n', '    @param _from Address of coin to be sent\n', '    @param _to Address of coin to be received\n', '    @param i Index value. When multiple pools are available\n', "            this value is used to return the n'th address.\n", '    @return Pool address\n', '    """\n', '    key: uint256 = bitwise_xor(convert(_from, uint256), convert(_to, uint256))\n', '    return self.markets[key][i]\n', '\n', '\n', '@view\n', '@external\n', 'def get_n_coins(_pool: address) -> uint256[2]:\n', '    """\n', '    @notice Get the number of coins in a pool\n', '    @dev For non-metapools, both returned values are identical\n', '         even when the pool does not use wrapping/lending\n', '    @param _pool Pool address\n', '    @return Number of wrapped coins, number of underlying coins\n', '    """\n', '    n_coins: uint256 = self.pool_data[_pool].n_coins\n', '    return [shift(n_coins, -128), n_coins % 2**128]\n', '\n', '\n', '@view\n', '@external\n', 'def get_coins(_pool: address) -> address[MAX_COINS]:\n', '    """\n', '    @notice Get the coins within a pool\n', '    @dev For pools using lending, these are the wrapped coin addresses\n', '    @param _pool Pool address\n', '    @return List of coin addresses\n', '    """\n', '    coins: address[MAX_COINS] = empty(address[MAX_COINS])\n', '    n_coins: uint256 = shift(self.pool_data[_pool].n_coins, -128)\n', '    for i in range(MAX_COINS):\n', '        if i == n_coins:\n', '            break\n', '        coins[i] = self.pool_data[_pool].coins[i]\n', '\n', '    return coins\n', '\n', '\n', '@view\n', '@external\n', 'def get_underlying_coins(_pool: address) -> address[MAX_COINS]:\n', '    """\n', '    @notice Get the underlying coins within a pool\n', '    @dev For pools that do not lend, returns the same value as `get_coins`\n', '    @param _pool Pool address\n', '    @return List of coin addresses\n', '    """\n', '    coins: address[MAX_COINS] = empty(address[MAX_COINS])\n', '    n_coins: uint256 = self.pool_data[_pool].n_coins % 2**128\n', '    for i in range(MAX_COINS):\n', '        if i == n_coins:\n', '            break\n', '        coins[i] = self.pool_data[_pool].ul_coins[i]\n', '\n', '    return coins\n', '\n', '\n', '@view\n', '@external\n', 'def get_decimals(_pool: address) -> uint256[MAX_COINS]:\n', '    """\n', '    @notice Get decimal places for each coin within a pool\n', '    @dev For pools using lending, these are the wrapped coin decimal places\n', '    @param _pool Pool address\n', '    @return uint256 list of decimals\n', '    """\n', '    n_coins: uint256 = shift(self.pool_data[_pool].n_coins, -128)\n', '    return self._unpack_decimals(self.pool_data[_pool].decimals, n_coins)\n', '\n', '\n', '@view\n', '@external\n', 'def get_underlying_decimals(_pool: address) -> uint256[MAX_COINS]:\n', '    """\n', '    @notice Get decimal places for each underlying coin within a pool\n', '    @dev For pools that do not lend, returns the same value as `get_decimals`\n', '    @param _pool Pool address\n', '    @return uint256 list of decimals\n', '    """\n', '    n_coins: uint256 = self.pool_data[_pool].n_coins % 2**128\n', '    return self._unpack_decimals(self.pool_data[_pool].underlying_decimals, n_coins)\n', '\n', '\n', '@view\n', '@external\n', 'def get_rates(_pool: address) -> uint256[MAX_COINS]:\n', '    """\n', '    @notice Get rates between coins and underlying coins\n', '    @dev For coins where there is no underlying coin, or where\n', '         the underlying coin cannot be swapped, the rate is\n', '         given as 1e18\n', '    @param _pool Pool address\n', '    @return Rates between coins and underlying coins\n', '    """\n', '    return self._get_rates(_pool)\n', '\n', '\n', '@view\n', '@external\n', 'def get_gauges(_pool: address) -> (address[10], int128[10]):\n', '    """\n', '    @notice Get a list of LiquidityGauge contracts associated with a pool\n', '    @param _pool Pool address\n', '    @return address[10] of gauge addresses, int128[10] of gauge types\n', '    """\n', '    liquidity_gauges: address[10] = empty(address[10])\n', '    gauge_types: int128[10] = empty(int128[10])\n', '    gauge_controller: address = self.gauge_controller\n', '    for i in range(10):\n', '        gauge: address = self.liquidity_gauges[_pool][i]\n', '        if gauge == ZERO_ADDRESS:\n', '            break\n', '        liquidity_gauges[i] = gauge\n', '        gauge_types[i] = GaugeController(gauge_controller).gauge_types(gauge)\n', '\n', '    return liquidity_gauges, gauge_types\n', '\n', '\n', '@view\n', '@external\n', 'def get_balances(_pool: address) -> uint256[MAX_COINS]:\n', '    """\n', '    @notice Get balances for each coin within a pool\n', '    @dev For pools using lending, these are the wrapped coin balances\n', '    @param _pool Pool address\n', '    @return uint256 list of balances\n', '    """\n', '    return self._get_balances(_pool)\n', '\n', '\n', '@view\n', '@external\n', 'def get_underlying_balances(_pool: address) -> uint256[MAX_COINS]:\n', '    """\n', '    @notice Get balances for each underlying coin within a pool\n', '    @dev  For pools that do not lend, returns the same value as `get_balances`\n', '    @param _pool Pool address\n', '    @return uint256 list of underlyingbalances\n', '    """\n', '    base_pool: address = self.pool_data[_pool].base_pool\n', '    if base_pool == ZERO_ADDRESS:\n', '        return self._get_underlying_balances(_pool)\n', '    return self._get_meta_underlying_balances(_pool, base_pool)\n', '\n', '\n', '@view\n', '@external\n', 'def get_virtual_price_from_lp_token(_token: address) -> uint256:\n', '    """\n', '    @notice Get the virtual price of a pool LP token\n', '    @param _token LP token address\n', '    @return uint256 Virtual price\n', '    """\n', '    return CurvePool(self.get_pool_from_lp_token[_token]).get_virtual_price()\n', '\n', '\n', '@view\n', '@external\n', 'def get_A(_pool: address) -> uint256:\n', '    return CurvePool(_pool).A()\n', '\n', '\n', '@view\n', '@external\n', 'def get_parameters(_pool: address) -> PoolParams:\n', '    """\n', '    @notice Get parameters for a pool\n', '    @dev For older pools where `initial_A` is not public, this value is set to 0\n', '    @param _pool Pool address\n', '    @return Pool amp, future amp, fee, admin fee, future fee, future admin fee,\n', '            future owner, initial amp, initial amp time, future amp time\n', '    """\n', '    pool_params: PoolParams = empty(PoolParams)\n', '    pool_params.A = CurvePool(_pool).A()\n', '    pool_params.future_A = CurvePool(_pool).future_A()\n', '    pool_params.fee = CurvePool(_pool).fee()\n', '    pool_params.future_fee = CurvePool(_pool).future_fee()\n', '    pool_params.admin_fee = CurvePool(_pool).admin_fee()\n', '    pool_params.future_admin_fee = CurvePool(_pool).future_admin_fee()\n', '    pool_params.future_owner = CurvePool(_pool).future_owner()\n', '\n', '    if self.pool_data[_pool].has_initial_A:\n', '        pool_params.initial_A = CurvePool(_pool).initial_A()\n', '        pool_params.initial_A_time = CurvePool(_pool).initial_A_time()\n', '        pool_params.future_A_time = CurvePool(_pool).future_A_time()\n', '\n', '    return pool_params\n', '\n', '\n', '@view\n', '@external\n', 'def get_fees(_pool: address) -> uint256[2]:\n', '    """\n', '    @notice Get the fees for a pool\n', '    @dev Fees are expressed as integers\n', '    @return Pool fee as uint256 with 1e10 precision\n', '            Admin fee as 1e10 percentage of pool fee\n', '    """\n', '    return [CurvePool(_pool).fee(), CurvePool(_pool).admin_fee()]\n', '\n', '\n', '@view\n', '@external\n', 'def get_admin_balances(_pool: address) -> uint256[MAX_COINS]:\n', '    """\n', '    @notice Get the current admin balances (uncollected fees) for a pool\n', '    @param _pool Pool address\n', '    @return List of uint256 admin balances\n', '    """\n', '    balances: uint256[MAX_COINS] = self._get_balances(_pool)\n', '    n_coins: uint256 = shift(self.pool_data[_pool].n_coins, -128)\n', '    for i in range(MAX_COINS):\n', '        coin: address = self.pool_data[_pool].coins[i]\n', '        if i == n_coins:\n', '            break\n', '        if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\n', '            balances[i] = _pool.balance - balances[i]\n', '        else:\n', '            balances[i] = ERC20(coin).balanceOf(_pool) - balances[i]\n', '\n', '    return balances\n', '\n', '\n', '@view\n', '@external\n', 'def get_coin_indices(\n', '    _pool: address,\n', '    _from: address,\n', '    _to: address\n', ') -> (int128, int128, bool):\n', '    """\n', '    @notice Convert coin addresses to indices for use with pool methods\n', '    @param _from Coin address to be used as `i` within a pool\n', '    @param _to Coin address to be used as `j` within a pool\n', '    @return int128 `i`, int128 `j`, boolean indicating if `i` and `j` are underlying coins\n', '    """\n', '    result: uint256[3] = self._get_coin_indices(_pool, _from, _to)\n', '    return convert(result[0], int128), convert(result[1], int128), result[2] > 0\n', '\n', '\n', '@view\n', '@external\n', 'def estimate_gas_used(_pool: address, _from: address, _to: address) -> uint256:\n', '    """\n', '    @notice Estimate the gas used in an exchange.\n', '    @param _pool Pool address\n', '    @param _from Address of coin to be sent\n', '    @param _to Address of coin to be received\n', '    @return Upper-bound gas estimate, in wei\n', '    """\n', '    estimator: address = self.gas_estimate_contracts[_pool]\n', '    if estimator != ZERO_ADDRESS:\n', '        return GasEstimator(estimator).estimate_gas_used(_pool, _from, _to)\n', '\n', '    # here we call `_get_coin_indices` to find out if the exchange involves wrapped\n', '    # or underlying coins, and use the result as an index in `gas_estimate_values`\n', '    # 0 == wrapped   1 == underlying\n', '    idx_underlying: uint256 = self._get_coin_indices(_pool, _from, _to)[2]\n', '\n', '    total: uint256 = self.gas_estimate_values[_pool][idx_underlying]\n', '    assert total != 0  # dev: pool value not set\n', '\n', '    for addr in [_from, _to]:\n', '        _gas: uint256 = self.gas_estimate_values[addr][0]\n', '        assert _gas != 0  # dev: coin value not set\n', '        total += _gas\n', '\n', '    return total\n', '\n', '\n', '# internal functionality used in admin setters\n', '\n', '@internal\n', 'def _add_pool(\n', '    _sender: address,\n', '    _pool: address,\n', '    _n_coins: uint256,\n', '    _lp_token: address,\n', '    _rate_method_id: bytes32,\n', '    _has_initial_A: bool,\n', '    _is_v1: bool,\n', '):\n', '    assert _sender == self.address_provider.admin()  # dev: admin-only function\n', '    assert _lp_token != ZERO_ADDRESS\n', '    assert self.pool_data[_pool].coins[0] == ZERO_ADDRESS  # dev: pool exists\n', '    assert self.get_pool_from_lp_token[_lp_token] == ZERO_ADDRESS\n', '\n', '    # add pool to pool_list\n', '    length: uint256 = self.pool_count\n', '    self.pool_list[length] = _pool\n', '    self.pool_count = length + 1\n', '    self.pool_data[_pool].location = length\n', '    self.pool_data[_pool].rate_method_id = _rate_method_id\n', '    self.pool_data[_pool].has_initial_A = _has_initial_A\n', '    self.pool_data[_pool].is_v1 = _is_v1\n', '    self.pool_data[_pool].n_coins = _n_coins\n', '\n', '    # update public mappings\n', '    self.get_pool_from_lp_token[_lp_token] = _pool\n', '    self.get_lp_token[_pool] = _lp_token\n', '\n', '    log PoolAdded(_pool, slice(_rate_method_id, 28, 4))\n', '\n', '\n', '@internal\n', 'def _get_new_pool_coins(\n', '    _pool: address,\n', '    _n_coins: uint256,\n', '    _is_underlying: bool,\n', '    _is_v1: bool\n', ') -> address[MAX_COINS]:\n', '    coin_list: address[MAX_COINS] = empty(address[MAX_COINS])\n', '    coin: address = ZERO_ADDRESS\n', '    for i in range(MAX_COINS):\n', '        if i == _n_coins:\n', '            break\n', '        if _is_underlying:\n', '            if _is_v1:\n', '                coin = CurvePoolV1(_pool).underlying_coins(convert(i, int128))\n', '            else:\n', '                coin = CurvePool(_pool).underlying_coins(i)\n', '            self.pool_data[_pool].ul_coins[i] = coin\n', '        else:\n', '            if _is_v1:\n', '                coin = CurvePoolV1(_pool).coins(convert(i, int128))\n', '            else:\n', '                coin = CurvePool(_pool).coins(i)\n', '            self.pool_data[_pool].coins[i] = coin\n', '        coin_list[i] = coin\n', '\n', '    for i in range(MAX_COINS):\n', '        if i == _n_coins:\n', '            break\n', '\n', '        # add pool to markets\n', '        i2: uint256 = i + 1\n', '        for x in range(i2, i2 + MAX_COINS):\n', '            if x == _n_coins:\n', '                break\n', '\n', '            key: uint256 = bitwise_xor(convert(coin_list[i], uint256), convert(coin_list[x], uint256))\n', '            length: uint256 = self.market_counts[key]\n', '            self.markets[key][length] = _pool\n', '            self.market_counts[key] = length + 1\n', '\n', '    return coin_list\n', '\n', '\n', '@view\n', '@internal\n', 'def _get_new_pool_decimals(_coins: address[MAX_COINS], _n_coins: uint256) -> uint256:\n', '    packed: uint256 = 0\n', '    value: uint256 = 0\n', '\n', '    n_coins: int128 = convert(_n_coins, int128)\n', '    for i in range(MAX_COINS):\n', '        if i == n_coins:\n', '            break\n', '        coin: address = _coins[i]\n', '        if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\n', '            value = 18\n', '        else:\n', '            value = ERC20(coin).decimals()\n', '            assert value < 256  # dev: decimal overflow\n', '\n', '        packed += shift(value, i * 8)\n', '\n', '    return packed\n', '\n', '\n', '@internal\n', 'def _remove_market(_pool: address, _coina: address, _coinb: address):\n', '    key: uint256 = bitwise_xor(convert(_coina, uint256), convert(_coinb, uint256))\n', '    length: uint256 = self.market_counts[key] - 1\n', '    for i in range(65536):\n', '        if i > length:\n', '            break\n', '        if self.markets[key][i] == _pool:\n', '            if i < length:\n', '                self.markets[key][i] = self.markets[key][length]\n', '            self.markets[key][length] = ZERO_ADDRESS\n', '            self.market_counts[key] = length\n', '            break\n', '\n', '\n', '# admin functions\n', '\n', '@external\n', 'def add_pool(\n', '    _pool: address,\n', '    _n_coins: uint256,\n', '    _lp_token: address,\n', '    _rate_method_id: bytes32,\n', '    _decimals: uint256,\n', '    _underlying_decimals: uint256,\n', '    _has_initial_A: bool,\n', '    _is_v1: bool,\n', '):\n', '    """\n', '    @notice Add a pool to the registry\n', '    @dev Only callable by admin\n', '    @param _pool Pool address to add\n', '    @param _n_coins Number of coins in the pool\n', '    @param _lp_token Pool deposit token address\n', '    @param _rate_method_id Encoded four-byte function signature to query coin rates\n', '    @param _decimals Coin decimal values, tightly packed as uint8 in a little-endian bytes32\n', '    @param _underlying_decimals Underlying coin decimal values, tightly packed\n', '                                as uint8 in a little-endian bytes32\n', '    """\n', '    self._add_pool(\n', '        msg.sender,\n', '        _pool,\n', '        _n_coins + shift(_n_coins, 128),\n', '        _lp_token,\n', '        _rate_method_id,\n', '        _has_initial_A,\n', '        _is_v1,\n', '    )\n', '\n', '    coins: address[MAX_COINS] = self._get_new_pool_coins(_pool, _n_coins, False, _is_v1)\n', '    decimals: uint256 = _decimals\n', '    if decimals == 0:\n', '        decimals = self._get_new_pool_decimals(coins, _n_coins)\n', '    self.pool_data[_pool].decimals = decimals\n', '\n', '    coins = self._get_new_pool_coins(_pool, _n_coins, True, _is_v1)\n', '    decimals = _underlying_decimals\n', '    if decimals == 0:\n', '        decimals = self._get_new_pool_decimals(coins, _n_coins)\n', '    self.pool_data[_pool].underlying_decimals = decimals\n', '\n', '\n', '@external\n', 'def add_pool_without_underlying(\n', '    _pool: address,\n', '    _n_coins: uint256,\n', '    _lp_token: address,\n', '    _rate_method_id: bytes32,\n', '    _decimals: uint256,\n', '    _use_rates: uint256,\n', '    _has_initial_A: bool,\n', '    _is_v1: bool,\n', '):\n', '    """\n', '    @notice Add a pool to the registry\n', '    @dev Only callable by admin\n', '    @param _pool Pool address to add\n', '    @param _n_coins Number of coins in the pool\n', '    @param _lp_token Pool deposit token address\n', '    @param _rate_method_id Encoded four-byte function signature to query coin rates\n', '    @param _decimals Coin decimal values, tightly packed as uint8 in a little-endian bytes32\n', '    @param _use_rates Boolean array indicating which coins use lending rates,\n', '                      tightly packed in a little-endian bytes32\n', '    """\n', '    self._add_pool(\n', '        msg.sender,\n', '        _pool,\n', '        _n_coins + shift(_n_coins, 128),\n', '        _lp_token,\n', '        _rate_method_id,\n', '        _has_initial_A,\n', '        _is_v1,\n', '    )\n', '\n', '    coins: address[MAX_COINS] = self._get_new_pool_coins(_pool, _n_coins, False, _is_v1)\n', '\n', '    decimals: uint256 = _decimals\n', '    if decimals == 0:\n', '        decimals = self._get_new_pool_decimals(coins, _n_coins)\n', '    self.pool_data[_pool].decimals = decimals\n', '\n', '    udecimals: uint256 = 0\n', '    for i in range(MAX_COINS):\n', '        if i == _n_coins:\n', '            break\n', '        offset: int128 = -8 * convert(i, int128)\n', '        if shift(_use_rates, offset) % 256 == 0:\n', '            self.pool_data[_pool].ul_coins[i] = coins[i]\n', '            udecimals += shift(shift(decimals, offset) % 256, -offset)\n', '\n', '    self.pool_data[_pool].underlying_decimals = udecimals\n', '\n', '\n', '\n', '@external\n', 'def add_metapool(\n', '    _pool: address,\n', '    _n_coins: uint256,\n', '    _lp_token: address,\n', '    _decimals: uint256,\n', '):\n', '    """\n', '    @notice Add a pool to the registry\n', '    @dev Only callable by admin\n', '    @param _pool Pool address to add\n', '    @param _n_coins Number of coins in the pool\n', '    @param _lp_token Pool deposit token address\n', '    @param _decimals Coin decimal values, tightly packed as uint8 in a little-endian bytes32\n', '    """\n', '    base_coin_offset: uint256 = _n_coins - 1\n', '    base_pool: address = CurveMetapool(_pool).base_pool()\n', '    base_n_coins: uint256 = shift(self.pool_data[base_pool].n_coins, -128)\n', '    assert base_n_coins > 0  # dev: base pool unknown\n', '\n', '    self._add_pool(\n', '        msg.sender,\n', '        _pool,\n', '        base_n_coins + base_coin_offset + shift(_n_coins, 128),\n', '        _lp_token,\n', '        EMPTY_BYTES32,\n', '        True,\n', '        False,\n', '    )\n', '\n', '    coins: address[MAX_COINS] = self._get_new_pool_coins(_pool, _n_coins, False, False)\n', '\n', '    decimals: uint256 = _decimals\n', '    if decimals == 0:\n', '        decimals = self._get_new_pool_decimals(coins, _n_coins)\n', '\n', '    self.pool_data[_pool].decimals = decimals\n', '    self.pool_data[_pool].base_pool = base_pool\n', '\n', '    base_coins: address[MAX_COINS] = empty(address[MAX_COINS])\n', '    coin: address = ZERO_ADDRESS\n', '    for i in range(MAX_COINS):\n', '        if i == base_n_coins + base_coin_offset:\n', '            break\n', '        if i < base_coin_offset:\n', '            coin = coins[i]\n', '        else:\n', '            x: uint256 = i - base_coin_offset\n', '            coin = self.pool_data[base_pool].coins[x]\n', '            base_coins[x] = coin\n', '        self.pool_data[_pool].ul_coins[i] = coin\n', '\n', '    underlying_decimals: uint256 = shift(\n', '        self.pool_data[base_pool].decimals, 8 * convert(base_coin_offset, int128)\n', '    )\n', '    underlying_decimals += decimals % 256 ** base_coin_offset\n', '\n', '    self.pool_data[_pool].underlying_decimals = underlying_decimals\n', '\n', '    for i in range(MAX_COINS):\n', '        if i == base_coin_offset:\n', '            break\n', '        for x in range(MAX_COINS):\n', '            if x == base_n_coins:\n', '                break\n', '            key: uint256 = bitwise_xor(convert(coins[i], uint256), convert(base_coins[x], uint256))\n', '            length: uint256 = self.market_counts[key]\n', '            self.markets[key][length] = _pool\n', '            self.market_counts[key] = length + 1\n', '\n', '\n', '@external\n', 'def remove_pool(_pool: address):\n', '    """\n', '    @notice Remove a pool to the registry\n', '    @dev Only callable by admin\n', '    @param _pool Pool address to remove\n', '    """\n', '    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\n', '    assert self.pool_data[_pool].coins[0] != ZERO_ADDRESS  # dev: pool does not exist\n', '\n', '\n', '    self.get_pool_from_lp_token[self.get_lp_token[_pool]] = ZERO_ADDRESS\n', '    self.get_lp_token[_pool] = ZERO_ADDRESS\n', '\n', '    # remove _pool from pool_list\n', '    location: uint256 = self.pool_data[_pool].location\n', '    length: uint256 = self.pool_count - 1\n', '\n', '    if location < length:\n', '        # replace _pool with final value in pool_list\n', '        addr: address = self.pool_list[length]\n', '        self.pool_list[location] = addr\n', '        self.pool_data[addr].location = location\n', '\n', '    # delete final pool_list value\n', '    self.pool_list[length] = ZERO_ADDRESS\n', '    self.pool_count = length\n', '\n', '    self.pool_data[_pool].underlying_decimals = 0\n', '    self.pool_data[_pool].decimals = 0\n', '    self.pool_data[_pool].n_coins = 0\n', '    self.pool_data[_pool].base_pool = ZERO_ADDRESS\n', '\n', '    coins: address[MAX_COINS] = empty(address[MAX_COINS])\n', '    ucoins: address[MAX_COINS] = empty(address[MAX_COINS])\n', '\n', '    for i in range(MAX_COINS):\n', '        coins[i] = self.pool_data[_pool].coins[i]\n', '        ucoins[i] = self.pool_data[_pool].ul_coins[i]\n', '        if ucoins[i] == ZERO_ADDRESS and coins[i] == ZERO_ADDRESS:\n', '            break\n', '        if coins[i] != ZERO_ADDRESS:\n', '            # delete coin address from pool_data\n', '            self.pool_data[_pool].coins[i] = ZERO_ADDRESS\n', '        if ucoins[i] != ZERO_ADDRESS:\n', '            # delete underlying_coin from pool_data\n', '            self.pool_data[_pool].ul_coins[i] = ZERO_ADDRESS\n', '\n', '    for i in range(MAX_COINS):\n', '        coin: address = coins[i]\n', '        ucoin: address = ucoins[i]\n', '        if coin == ZERO_ADDRESS:\n', '            break\n', '\n', '        # remove pool from markets\n', '        i2: uint256 = i + 1\n', '        for x in range(i2, i2 + MAX_COINS):\n', '            ucoinx: address = ucoins[x]\n', '            if ucoinx == ZERO_ADDRESS:\n', '                break\n', '\n', '            coinx: address = coins[x]\n', '            if coinx != ZERO_ADDRESS:\n', '                self._remove_market(_pool, coin, coinx)\n', '\n', '            if coin != ucoin or coinx != ucoinx:\n', '                self._remove_market(_pool, ucoin, ucoinx)\n', '\n', '    log PoolRemoved(_pool)\n', '\n', '\n', '@external\n', 'def set_pool_gas_estimates(_addr: address[5], _amount: uint256[2][5]):\n', '    """\n', '    @notice Set gas estimate amounts\n', '    @param _addr Array of pool addresses\n', '    @param _amount Array of gas estimate amounts as `[(wrapped, underlying), ..]`\n', '    """\n', '    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\n', '\n', '    for i in range(5):\n', '        _pool: address = _addr[i]\n', '        if _pool == ZERO_ADDRESS:\n', '            break\n', '        self.gas_estimate_values[_pool] = _amount[i]\n', '\n', '\n', '@external\n', 'def set_coin_gas_estimates(_addr: address[10], _amount: uint256[10]):\n', '    """\n', '    @notice Set gas estimate amounts\n', '    @param _addr Array of coin addresses\n', '    @param _amount Array of gas estimate amounts\n', '    """\n', '    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\n', '\n', '    for i in range(10):\n', '        _coin: address = _addr[i]\n', '        if _coin == ZERO_ADDRESS:\n', '            break\n', '        self.gas_estimate_values[_coin][0] = _amount[i]\n', '\n', '\n', '@external\n', 'def set_gas_estimate_contract(_pool: address, _estimator: address):\n', '    """\n', '    @notice Set gas estimate contract\n', '    @param _pool Pool address\n', '    @param _estimator GasEstimator address\n', '    """\n', '    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\n', '\n', '    self.gas_estimate_contracts[_pool] = _estimator\n', '\n', '\n', '@external\n', 'def set_liquidity_gauges(_pool: address, _liquidity_gauges: address[10]):\n', '    """\n', '    @notice Set liquidity gauge contracts``\n', '    @param _pool Pool address\n', '    @param _liquidity_gauges Liquidity gauge address\n', '    """\n', '    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\n', '\n', '    _lp_token: address = self.get_lp_token[_pool]\n', '    _gauge_controller: address = self.gauge_controller\n', '    for i in range(10):\n', '        _gauge: address = _liquidity_gauges[i]\n', '        if _gauge != ZERO_ADDRESS:\n', '            assert LiquidityGauge(_gauge).lp_token() == _lp_token  # dev: wrong token\n', '            GaugeController(_gauge_controller).gauge_types(_gauge)\n', '            self.liquidity_gauges[_pool][i] = _gauge\n', '        elif self.liquidity_gauges[_pool][i] != ZERO_ADDRESS:\n', '            self.liquidity_gauges[_pool][i] = ZERO_ADDRESS\n', '        else:\n', '            break']