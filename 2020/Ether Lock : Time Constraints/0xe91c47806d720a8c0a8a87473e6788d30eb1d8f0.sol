['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity = 0.7 .0;\n', '\n', 'library SafeMath {\n', '  function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a, "SafeMath: addition overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '    return sub(a, b, "SafeMath: subtraction overflow");\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n', '    require(b <= a, errorMessage);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '    return div(a, b, "SafeMath: division by zero");\n', '  }\n', '\n', '  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n', '    require(b > 0, errorMessage);\n', '    uint256 c = a / b;\n', "    // assert(a == b *c + a % b);\t// There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal pure returns(uint256) {\n', '    return mod(a, b, "SafeMath: modulo by zero");\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n', '    require(b != 0, errorMessage);\n', '    return a % b;\n', '  }\n', '}\n', '\n', 'abstract contract Context {\n', '  function _msgSender() internal view virtual returns(address payable) {\n', '    return msg.sender;\n', '  }\n', '\n', '  function _msgData() internal view virtual returns(bytes memory) {\n', '    this;\n', '    return msg.data;\n', '  }\n', '}\n', '\n', 'contract Ownable is Context {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor() {\n', '    address msgSender = _msgSender();\n', '    _owner = msgSender;\n', '    emit OwnershipTransferred(address(0), msgSender);\n', '  }\n', '\n', '  function owner() public view returns(address) {\n', '    return _owner;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '    _;\n', '  }\n', '\n', '  function renounceOwnership() public virtual onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public virtual onlyOwner {\n', '    require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', 'abstract contract Token {\n', '\n', '  function balanceOf(address account) external view virtual returns(uint256 data);\n', '\n', '}\n', '\n', 'abstract contract Router {\n', '\n', '  function extrenalRouterCall(string memory route, address[2] memory addressArr, uint[2] memory uintArr) external virtual returns(bool success);\n', '\n', '  function updateCurrentSupply(uint[2] memory uintArr) external virtual returns(bool success);\n', '}\n', '\n', '//===============================================================\n', '//MAIN CONTRACT\n', '//===============================================================\n', 'contract SoloMiner is Ownable {\n', '  using SafeMath\n', '  for uint;\n', '\n', '  address private tokenContract;\n', '  address private routerContract;\n', '  uint private totalBurned;\n', '  uint private totalMinted;\n', '  bool private active = true;\n', '\n', '  Token private token;\n', '  Router private router;\n', '  mapping(address => uint) private numerator;\n', '  mapping(address => uint) private denominator;\n', '  mapping(address => uint) private minimumReturn;\n', '  mapping(address => uint) private userBlocks;\n', '  mapping(address => uint) private miners;\n', '  mapping(uint => address) private addressFromId;\n', '  mapping(address => bool) private mutex;\n', '\n', '  uint private pivot = 0;\n', '  uint private rewardConstant = 100000000000000000000;\n', '  uint private totalConstant = 21000000000000000000000000; //we assume that there is a 21 million as a total supply\n', '  uint private currentConstant = 1050000000000000000000000; //we assume that the current supply is 10.5 million tokens\n', '  uint private inflationBuffer = 100000000000000000000; //we are allowing the automated inflation with this\n', '\n', '  address private contractAddress;\n', '\n', '  constructor() {\n', '    contractAddress = address(this);\n', '    setNewTokenContract(address(0x7C131Ab459b874b82f19cdc1254fB66840D021B6));\n', '    setNewRouterContract(address(0x1f773c9344E3caE0AA6fA3c89Ac90701fEa364Fe));\n', '  }\n', '\n', '  modifier isActive() {\n', '    require(active, "Miner is not active.");\n', '    _;\n', '  }\n', '\n', '  //+++++++++++VIEWS++++++++++++++++\n', '  //----------GETTERS---------------\n', '  \n', '  function getPivot() external view virtual returns(uint lastPivot) {\n', '    return pivot;\n', '  }\n', '\n', '  function getAddressFromId(uint id) external view virtual returns(address minerAddress) {\n', '    return addressFromId[id];\n', '  }\n', '\n', '  function getUserNumerator(address minerAddress) external view virtual returns(uint minerNumerator) {\n', '    return numerator[minerAddress];\n', '  }\n', '\n', '  function getUserDenominator(address minerAddress) external view virtual returns(uint minerDenominator) {\n', '    return denominator[minerAddress];\n', '  }\n', '\n', '  function getUserBlocks(address minerAddress) external view virtual returns(uint minerBlocks) {\n', '    return userBlocks[minerAddress];\n', '  }\n', '\n', '  function getContractAddress() external view virtual returns(address tokenAddress) {\n', '    return contractAddress;\n', '  }\n', '\n', '  function getTokenContract() external view virtual returns(address tokenAddress) {\n', '    return tokenContract;\n', '  }\n', '\n', '  function getTotalBurned() external view virtual returns(uint burned) {\n', '    return totalBurned;\n', '  }\n', '\n', '  function getTotalMinted() external view virtual returns(uint burned) {\n', '    return totalMinted;\n', '  }\n', '\n', '  function getLastBlockNumber(address minerAddress) public view virtual returns(uint lastBlock) {\n', '    return userBlocks[minerAddress];\n', '  }\n', '\n', '  function getRouterContract() external view virtual returns(address routerAddress) {\n', '    return routerContract;\n', '  }\n', '\n', '  function getCurrentBlockNumber() public view returns(uint256 blockNumber) {\n', '    return block.number;\n', '  }\n', '\n', '  function getGapSize() public view virtual returns(uint gapSize) {\n', '    return totalConstant.sub(currentConstant);\n', '  }\n', '\n', '  function getRewardConstant() external view virtual returns(uint routerAddress) {\n', '    return rewardConstant;\n', '  }\n', '\n', '  function getTotalConstant() external view virtual returns(uint routerAddress) {\n', '    return totalConstant;\n', '  }\n', '\n', '  function getCurrentConstant() external view virtual returns(uint routerAddress) {\n', '    return currentConstant;\n', '  }\n', '\n', '  function getinflationBuffer() external view virtual returns(uint routerAddress) {\n', '    return inflationBuffer;\n', '  }\n', '\n', '  //----------OTHER VIEWS---------------\n', '  function showReward(address minerAddress) public view virtual returns(uint reward) {\n', '    if (denominator[minerAddress] == 0) {\n', '      return 0;\n', '    } else if (!active) {\n', '      return 0;\n', '    }\n', '\n', '    uint previousBlock = getLastBlockNumber(minerAddress);\n', '    uint currentBlock = getCurrentBlockNumber();\n', '    uint diff = currentBlock.sub(previousBlock);\n', '    uint additionalReward = diff.mul(rewardConstant);\n', '    additionalReward = (numerator[minerAddress].mul(additionalReward)).div(denominator[minerAddress]);\n', '    uint rewardSize = (numerator[minerAddress].mul(getGapSize())).div(denominator[minerAddress]);\n', '\n', '    if (rewardSize.add(currentConstant) > totalConstant) {\n', '      rewardSize = totalConstant.sub(currentConstant);\n', '    }\n', '    if (rewardSize < showMyCurrentRewardTotal()) {\n', '      rewardSize = showMyCurrentRewardTotal();\n', '    }\n', '    rewardSize = rewardSize + additionalReward;\n', '\n', '    return rewardSize;\n', '  }\n', '\n', '  //+++++++++++EXTERNAL++++++++++++++++\n', '  function mine(uint depositAmount) isActive external virtual returns(bool success) {\n', '    require(!mutex[msg.sender]);\n', '    mutex[msg.sender] = true;\n', '\n', '    require(depositAmount > 0,\n', '      "at: solo_miner.sol | contract: SoloMiner | function: mine | message: No zero deposits allowed");\n', '\n', '    uint reward = showReward(msg.sender);\n', '    reward = reward.add(depositAmount);\n', '\n', '    uint gapSize = getGapSize().add(depositAmount);\n', '\n', '    numerator[msg.sender] = reward;\n', '    denominator[msg.sender] = gapSize;\n', '    minimumReturn[msg.sender] = minimumReturn[msg.sender].add(depositAmount);\n', '    userBlocks[msg.sender] = getCurrentBlockNumber();\n', '\n', '    registerMiner();\n', '\n', '    burn(depositAmount);\n', '\n', '    mutex[msg.sender] = false;\n', '\n', '    return true;\n', '  }\n', '\n', '  function getReward(uint tokenAmount) isActive public virtual returns(bool success) {\n', '\n', '    require(!mutex[msg.sender]);\n', '    mutex[msg.sender] = true;\n', '\n', '    uint reward = showReward(msg.sender);\n', '\n', '    require(tokenAmount <= reward,\n', '      "at: solo_miner.sol | contract: SoloMiner | function: getReward | message: Amount too big");\n', '\n', '    reward = reward.sub(tokenAmount);\n', '\n', '    uint gapSize = getGapSize().sub(tokenAmount);\n', '\n', '    numerator[msg.sender] = reward;\n', '    denominator[msg.sender] = gapSize;\n', '    if (minimumReturn[msg.sender] >= tokenAmount) {\n', '      minimumReturn[msg.sender] = minimumReturn[msg.sender].sub(tokenAmount);\n', '    } else {\n', '      minimumReturn[msg.sender] = 0;\n', '    }\n', '    userBlocks[msg.sender] = getCurrentBlockNumber();\n', '\n', '    registerMiner();\n', '\n', '    mint(tokenAmount);\n', '\n', '    mutex[msg.sender] = false;\n', '\n', '    return true;\n', '  }\n', '\n', '  function getFullReward() isActive public virtual returns(bool success) {\n', '\n', '    require(!mutex[msg.sender]);\n', '    mutex[msg.sender] = true;\n', '\n', '    uint amt = showReward(msg.sender);\n', '\n', '    require(amt > 0,\n', '      "at: solo_miner.sol | contract: SoloMiner | function: getFullReward | message: No rewards to give");\n', '\n', '    require(getLastBlockNumber(msg.sender) > 0,\n', '      "at: solo_miner.sol | contract: SoloMiner | function: getFullReward | message: Must mine first");\n', '\n', '    numerator[msg.sender] = 0;\n', '    denominator[msg.sender] = 0;\n', '    minimumReturn[msg.sender] = 0;\n', '    userBlocks[msg.sender] = 0;\n', '\n', '    mint(amt);\n', '\n', '    mutex[msg.sender] = false;\n', '\n', '    return true;\n', '  }\n', '\n', '  //should miner become inactive, we can still get our tokens back\n', '  function recoverOnly() external virtual returns(bool success) {\n', '\n', '    require(!mutex[msg.sender]);\n', '    mutex[msg.sender] = true;\n', '\n', '    require(!active,\n', '      "at: solo_miner.sol | contract: SoloMiner | function: recoverOnly | message: Contract must be deactivated");\n', '    require(minimumReturn[msg.sender] > 0,\n', '      "at: solo_miner.sol | contract: SoloMiner | function: recoverOnly | message: You cannot recover a zero amount");\n', '\n', '    uint amt = minimumReturn[msg.sender];\n', '    minimumReturn[msg.sender] = 0;\n', '    mint(amt);\n', '\n', '    mutex[msg.sender] = false;\n', '\n', '    return true;\n', '  }\n', '\n', '  //in case you want to burn tokens and increase miner rewards\n', '  function burnMyTokens(uint tokenAmount) isActive public virtual returns(bool success) {\n', '\n', '    require(!mutex[msg.sender]);\n', '    mutex[msg.sender] = true;\n', '\n', '    currentConstant = currentConstant.sub(tokenAmount);\n', '    burn(tokenAmount);\n', '\n', '    mutex[msg.sender] = false;\n', '\n', '    return true;\n', '  }\n', '\n', '  //+++++++++++ONLY OWNER++++++++++++++++\n', '  //----------SETTERS--------------------\n', '  function setNewTokenContract(address newTokenAddress) onlyOwner public virtual returns(bool success) {\n', '    tokenContract = newTokenAddress;\n', '    token = Token(newTokenAddress);\n', '    return true;\n', '  }\n', '  \n', '  function setNewRouterContract(address newRouterAddress) onlyOwner public virtual returns(bool success) {\n', '    routerContract = newRouterAddress;\n', '    router = Router(newRouterAddress);\n', '    return true;\n', '  }\n', '\n', '  function setRewardConstant(uint newConstant) onlyOwner public virtual returns(bool success) {\n', '    rewardConstant = newConstant;\n', '    return true;\n', '  }\n', '\n', '  function setInflationBuffer(uint newConstant) onlyOwner public virtual returns(bool success) {\n', '    inflationBuffer = newConstant;\n', '    return true;\n', '  }\n', '\n', '  function setCurrentConstant(uint newConstant) onlyOwner public virtual returns(bool success) {\n', '    currentConstant = newConstant;\n', '    return true;\n', '  }\n', '\n', '  function setTotalConstant(uint newConstant) onlyOwner public virtual returns(bool success) {\n', '    totalConstant = newConstant;\n', '    return true;\n', '  }\n', '\n', '  //----------OTHER--------------------\n', '  function flipSwitch() external onlyOwner returns(bool success) {\n', '    active = !active;\n', '    return true;\n', '  }\n', '\n', '  //+++++++++++PRIVATE++++++++++++++++++++   \n', '  function registerMiner() private {\n', '    if (miners[msg.sender] == 0) {\n', '      pivot = pivot.add(1);\n', '      miners[msg.sender] = pivot;\n', '      addressFromId[pivot] = msg.sender;\n', '    }\n', '  }\n', '\n', '  function showMyCurrentRewardTotal() private view returns(uint reward) {\n', '\n', '    if (denominator[msg.sender] == 0) {\n', '      return 0;\n', '    } else if (!active) {\n', '      return 0;\n', '    }\n', '\n', '    uint gapSize = getGapSize();\n', '    uint rewardSize = (numerator[msg.sender].mul(gapSize)).div(denominator[msg.sender]);\n', '\n', '    if (rewardSize < minimumReturn[msg.sender]) {\n', '      rewardSize = minimumReturn[msg.sender];\n', '    }\n', '    if (rewardSize > getGapSize()) {\n', '      rewardSize = getGapSize();\n', '    }\n', '\n', '    return rewardSize;\n', '  }\n', '\n', '  function burn(uint burnAmount) isActive private returns(bool success) {\n', '    require(burnAmount <= currentConstant,\n', '      "at: solo_miner.sol | contract: SoloMiner | function: burn | message: You cannot burn more tokens than the existing current supply");\n', '    require(burnAmount <= token.balanceOf(msg.sender),\n', '      "at: solo_miner.sol | contract: SoloMiner | function: burn | message: You are trying to burn more than you own");\n', '\n', '    address toAddress = address(0);\n', '    address[2] memory addresseArr = [msg.sender, toAddress];\n', '    uint[2] memory uintArr = [burnAmount, 0];\n', '\n', '    totalBurned = totalBurned.add(burnAmount);\n', '    currentConstant = currentConstant.sub(burnAmount);\n', '\n', '    router.extrenalRouterCall("burn", addresseArr, uintArr);\n', '\n', '    return true;\n', '  }\n', '\n', '  function mint(uint mintAmount) isActive private returns(bool success) {\n', '    address fromAddress = address(0);\n', '    address[2] memory addresseArr = [fromAddress, msg.sender];\n', '    uint[2] memory uintArr = [mintAmount, 0];\n', '\n', '    if (inflationBuffer >= mintAmount && currentConstant >= mintAmount) {\n', '      inflationBuffer = inflationBuffer.sub(mintAmount);\n', '    } else {\n', '      currentConstant = currentConstant.add(mintAmount);\n', '    }\n', '\n', '    totalMinted = totalMinted.add(mintAmount);\n', '\n', '    router.extrenalRouterCall("mint", addresseArr, uintArr);\n', '\n', '    return true;\n', '  }\n', '}']