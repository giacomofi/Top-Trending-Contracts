['// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.6.8;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface iERC20 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '}\n', '\n', 'interface iROUTER {\n', '    function totalStaked() external view returns (uint);\n', '    function totalVolume() external view returns (uint);\n', '    function totalFees() external view returns (uint);\n', '    function unstakeTx() external view returns (uint);\n', '    function stakeTx() external view returns (uint);\n', '    function swapTx() external view returns (uint);\n', '    function tokenCount() external view returns(uint);\n', '    function getToken(uint) external view returns(address);\n', '    function getPool(address) external view returns(address payable);\n', '    function stakeForMember(uint inputBase, uint inputToken, address token, address member) external payable returns (uint units);\n', '}\n', '\n', 'interface iPOOL {\n', '    function genesis() external view returns(uint);\n', '    function baseAmt() external view returns(uint);\n', '    function tokenAmt() external view returns(uint);\n', '    function baseAmtStaked() external view returns(uint);\n', '    function tokenAmtStaked() external view returns(uint);\n', '    function fees() external view returns(uint);\n', '    function volume() external view returns(uint);\n', '    function txCount() external view returns(uint);\n', '    function getBaseAmtStaked(address) external view returns(uint);\n', '    function getTokenAmtStaked(address) external view returns(uint);\n', '    function calcValueInBase(uint) external view returns (uint);\n', '    function calcValueInToken(uint) external view returns (uint);\n', '    function calcTokenPPinBase(uint) external view returns (uint);\n', '    function calcBasePPinToken(uint) external view returns (uint);\n', '}\n', '\n', 'interface iDAO {\n', '    function ROUTER() external view returns(address);\n', '}\n', '\n', '// SafeMath\n', 'library SafeMath {\n', '\n', '    function add(uint a, uint b) internal pure returns (uint)   {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        require(c / a == b, "SafeMath");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Utils_Vether {\n', '\n', '    using SafeMath for uint;\n', '\n', '    address public BASE;\n', '    address public DEPLOYER;\n', '    iDAO public DAO;\n', '\n', '    struct TokenDetails {\n', '        string name;\n', '        string symbol;\n', '        uint decimals;\n', '        uint totalSupply;\n', '        uint balance;\n', '        address tokenAddress;\n', '    }\n', '\n', '    struct ListedAssetDetails {\n', '        string name;\n', '        string symbol;\n', '        uint decimals;\n', '        uint totalSupply;\n', '        uint balance;\n', '        address tokenAddress;\n', '        bool hasClaimed;\n', '    }\n', '\n', '    struct GlobalDetails {\n', '        uint totalStaked;\n', '        uint totalVolume;\n', '        uint totalFees;\n', '        uint unstakeTx;\n', '        uint stakeTx;\n', '        uint swapTx;\n', '    }\n', '\n', '    struct PoolDataStruct {\n', '        address tokenAddress;\n', '        address poolAddress;\n', '        uint genesis;\n', '        uint baseAmt;\n', '        uint tokenAmt;\n', '        uint baseAmtStaked;\n', '        uint tokenAmtStaked;\n', '        uint fees;\n', '        uint volume;\n', '        uint txCount;\n', '        uint poolUnits;\n', '    }\n', '\n', '    // Only Deployer can execute\n', '    modifier onlyDeployer() {\n', '        require(msg.sender == DEPLOYER, "DeployerErr");\n', '        _;\n', '    }\n', '\n', '    constructor () public payable {\n', '        BASE = 0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279;\n', '        DEPLOYER = msg.sender;\n', '    }\n', '\n', '    function setGenesisDao(address dao) public onlyDeployer {\n', '        DAO = iDAO(dao);\n', '    }\n', '\n', '    //====================================DATA-HELPERS====================================//\n', '\n', '    function getTokenDetails(address token) public view returns (TokenDetails memory tokenDetails){\n', '        return getTokenDetailsWithMember(token, msg.sender);\n', '    }\n', '\n', '    function getTokenDetailsWithMember(address token, address member) public view returns (TokenDetails memory tokenDetails){\n', '        if(token == address(0)){\n', "            tokenDetails.name = 'Ethereum';\n", "            tokenDetails.symbol = 'ETH';\n", '            tokenDetails.decimals = 18;\n', '            tokenDetails.totalSupply = 100000000 * 10**18;\n', '            tokenDetails.balance = msg.sender.balance;\n', '        } else {\n', '            tokenDetails.name = iERC20(token).name();\n', '            tokenDetails.symbol = iERC20(token).symbol();\n', '            tokenDetails.decimals = iERC20(token).decimals();\n', '            tokenDetails.totalSupply = iERC20(token).totalSupply();\n', '            tokenDetails.balance = iERC20(token).balanceOf(member);\n', '        }\n', '        tokenDetails.tokenAddress = token;\n', '        return tokenDetails;\n', '    }\n', '\n', '    function getGlobalDetails() public view returns (GlobalDetails memory globalDetails){\n', '        globalDetails.totalStaked = iROUTER(DAO.ROUTER()).totalStaked();\n', '        globalDetails.totalVolume = iROUTER(DAO.ROUTER()).totalVolume();\n', '        globalDetails.totalFees = iROUTER(DAO.ROUTER()).totalFees();\n', '        globalDetails.unstakeTx = iROUTER(DAO.ROUTER()).unstakeTx();\n', '        globalDetails.stakeTx = iROUTER(DAO.ROUTER()).stakeTx();\n', '        globalDetails.swapTx = iROUTER(DAO.ROUTER()).swapTx();\n', '        return globalDetails;\n', '    }\n', '\n', '    function getPool(address token) public view returns(address payable pool){\n', '        return iROUTER(DAO.ROUTER()).getPool(token);\n', '    }\n', '    function tokenCount() public view returns (uint256 count){\n', '        return iROUTER(DAO.ROUTER()).tokenCount();\n', '    }\n', '    function allTokens() public view returns (address[] memory _allTokens){\n', '        return tokensInRange(0, iROUTER(DAO.ROUTER()).tokenCount()) ;\n', '    }\n', '    function tokensInRange(uint start, uint count) public view returns (address[] memory someTokens){\n', '        if(start.add(count) > tokenCount()){\n', '            count = tokenCount().sub(start);\n', '        }\n', '        address[] memory result = new address[](count);\n', '        for (uint i = 0; i < count; i++){\n', '            result[i] = iROUTER(DAO.ROUTER()).getToken(i);\n', '        }\n', '        return result;\n', '    }\n', '    function allPools() public view returns (address[] memory _allPools){\n', '        return poolsInRange(0, tokenCount());\n', '    }\n', '    function poolsInRange(uint start, uint count) public view returns (address[] memory somePools){\n', '        if(start.add(count) > tokenCount()){\n', '            count = tokenCount().sub(start);\n', '        }\n', '        address[] memory result = new address[](count);\n', '        for (uint i = 0; i<count; i++){\n', '            result[i] = getPool(iROUTER(DAO.ROUTER()).getToken(i));\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function getPoolData(address token) public view returns(PoolDataStruct memory poolData){\n', '        address payable pool = getPool(token);\n', '        poolData.poolAddress = pool;\n', '        poolData.tokenAddress = token;\n', '        poolData.genesis = iPOOL(pool).genesis();\n', '        poolData.baseAmt = iPOOL(pool).baseAmt();\n', '        poolData.tokenAmt = iPOOL(pool).tokenAmt();\n', '        poolData.baseAmtStaked = iPOOL(pool).baseAmtStaked();\n', '        poolData.tokenAmtStaked = iPOOL(pool).tokenAmtStaked();\n', '        poolData.fees = iPOOL(pool).fees();\n', '        poolData.volume = iPOOL(pool).volume();\n', '        poolData.txCount = iPOOL(pool).txCount();\n', '        poolData.poolUnits = iERC20(pool).totalSupply();\n', '        return poolData;\n', '    }\n', '\n', '    function getMemberShare(address token, address member) public view returns(uint baseAmt, uint tokenAmt){\n', '        address pool = getPool(token);\n', '        uint units = iERC20(pool).balanceOf(member);\n', '        return getPoolShare(token, units);\n', '    }\n', '\n', '    function getPoolShare(address token, uint units) public view returns(uint baseAmt, uint tokenAmt){\n', '        address payable pool = getPool(token);\n', '        baseAmt = calcShare(units, iERC20(pool).totalSupply(), iPOOL(pool).baseAmt());\n', '        tokenAmt = calcShare(units, iERC20(pool).totalSupply(), iPOOL(pool).tokenAmt());\n', '        return (baseAmt, tokenAmt);\n', '    }\n', '\n', '    function getShareOfBaseAmount(address token, address member) public view returns(uint baseAmt){\n', '        address payable pool = getPool(token);\n', '        uint units = iERC20(pool).balanceOf(member);\n', '        return calcShare(units, iERC20(pool).totalSupply(), iPOOL(pool).baseAmt());\n', '    }\n', '    function getShareOfTokenAmount(address token, address member) public view returns(uint baseAmt){\n', '        address payable pool = getPool(token);\n', '        uint units = iERC20(pool).balanceOf(member);\n', '        return calcShare(units, iERC20(pool).totalSupply(), iPOOL(pool).tokenAmt());\n', '    }\n', '\n', '    function getPoolShareAssym(address token, uint units, bool toBase) public view returns(uint baseAmt, uint tokenAmt, uint outputAmt){\n', '        address payable pool = getPool(token);\n', '        if(toBase){\n', '            baseAmt = calcAsymmetricShare(units, iERC20(pool).totalSupply(), iPOOL(pool).baseAmt());\n', '            tokenAmt = 0;\n', '            outputAmt = baseAmt;\n', '        } else {\n', '            baseAmt = 0;\n', '            tokenAmt = calcAsymmetricShare(units, iERC20(pool).totalSupply(), iPOOL(pool).tokenAmt());\n', '            outputAmt = tokenAmt;\n', '        }\n', '        return (baseAmt, tokenAmt, outputAmt);\n', '    }\n', '\n', '    function getPoolAge(address token) public view returns (uint daysSinceGenesis){\n', '        address payable pool = getPool(token);\n', '        uint genesis = iPOOL(pool).genesis();\n', '        if(now < genesis.add(86400)){\n', '            return 1;\n', '        } else {\n', '            return (now.sub(genesis)).div(86400);\n', '        }\n', '    }\n', '\n', '    function getPoolROI(address token) public view returns (uint roi){\n', '        address payable pool = getPool(token);\n', '        uint _baseStart = iPOOL(pool).baseAmtStaked().mul(2);\n', '        uint _baseEnd = iPOOL(pool).baseAmt().mul(2);\n', '        uint _ROIS = (_baseEnd.mul(10000)).div(_baseStart);\n', '        uint _tokenStart = iPOOL(pool).tokenAmtStaked().mul(2);\n', '        uint _tokenEnd = iPOOL(pool).tokenAmt().mul(2);\n', '        uint _ROIA = (_tokenEnd.mul(10000)).div(_tokenStart);\n', '        return (_ROIS + _ROIA).div(2);\n', '   }\n', '\n', '   function getPoolAPY(address token) public view returns (uint apy){\n', '        uint avgROI = getPoolROI(token);\n', '        uint poolAge = getPoolAge(token);\n', '        return (avgROI.mul(365)).div(poolAge);\n', '   }\n', '\n', '    function isMember(address token, address member) public view returns(bool){\n', '        address payable pool = getPool(token);\n', '        if (iERC20(pool).balanceOf(member) > 0){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    //====================================PRICING====================================//\n', '\n', '    function calcValueInBase(address token, uint amount) public view returns (uint value){\n', '       address payable pool = getPool(token);\n', '       return calcValueInBaseWithPool(pool, amount);\n', '    }\n', '\n', '    function calcValueInToken(address token, uint amount) public view returns (uint value){\n', '        address payable pool = getPool(token);\n', '        return calcValueInTokenWithPool(pool, amount);\n', '    }\n', '\n', '    function calcTokenPPinBase(address token, uint amount) public view returns (uint _output){\n', '        address payable pool = getPool(token);\n', '        return  calcTokenPPinBaseWithPool(pool, amount);\n', '   }\n', '\n', '    function calcBasePPinToken(address token, uint amount) public view returns (uint _output){\n', '        address payable pool = getPool(token);\n', '        return  calcValueInBaseWithPool(pool, amount);\n', '    }\n', '\n', '    function calcValueInBaseWithPool(address payable pool, uint amount) public view returns (uint value){\n', '       uint _baseAmt = iPOOL(pool).baseAmt();\n', '       uint _tokenAmt = iPOOL(pool).tokenAmt();\n', '       return (amount.mul(_baseAmt)).div(_tokenAmt);\n', '    }\n', '\n', '    function calcValueInTokenWithPool(address payable pool, uint amount) public view returns (uint value){\n', '        uint _baseAmt = iPOOL(pool).baseAmt();\n', '        uint _tokenAmt = iPOOL(pool).tokenAmt();\n', '        return (amount.mul(_tokenAmt)).div(_baseAmt);\n', '    }\n', '\n', '    function calcTokenPPinBaseWithPool(address payable pool, uint amount) public view returns (uint _output){\n', '        uint _baseAmt = iPOOL(pool).baseAmt();\n', '        uint _tokenAmt = iPOOL(pool).tokenAmt();\n', '        return  calcSwapOutput(amount, _tokenAmt, _baseAmt);\n', '   }\n', '\n', '    function calcBasePPinTokenWithPool(address payable pool, uint amount) public view returns (uint _output){\n', '        uint _baseAmt = iPOOL(pool).baseAmt();\n', '        uint _tokenAmt = iPOOL(pool).tokenAmt();\n', '        return  calcSwapOutput(amount, _baseAmt, _tokenAmt);\n', '    }\n', '\n', '    //====================================CORE-MATH====================================//\n', '\n', '    function calcPart(uint bp, uint total) public pure returns (uint part){\n', '        // 10,000 basis points = 100.00%\n', '        require((bp <= 10000) && (bp > 0), "Must be correct BP");\n', '        return calcShare(bp, 10000, total);\n', '    }\n', '\n', '    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){\n', '        // share = amount * part/total\n', '        return(amount.mul(part)).div(total);\n', '    }\n', '\n', '    function  calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint output){\n', '        // y = (x * X * Y )/(x + X)^2\n', '        uint numerator = x.mul(X.mul(Y));\n', '        uint denominator = (x.add(X)).mul(x.add(X));\n', '        return numerator.div(denominator);\n', '    }\n', '\n', '    function  calcSwapFee(uint x, uint X, uint Y) public pure returns (uint output){\n', '        // y = (x * x * Y) / (x + X)^2\n', '        uint numerator = x.mul(x.mul(Y));\n', '        uint denominator = (x.add(X)).mul(x.add(X));\n', '        return numerator.div(denominator);\n', '    }\n', '\n', '    function calcStakeUnits(uint b, uint B, uint t, uint T) public pure returns (uint units){\n', '        // units = ((T + B) * (t * B + T * b))/(4 * T * B)\n', '        // (part1 * (part2 + part3)) / part4\n', '        uint part1 = T.add(B);\n', '        uint part2 = t.mul(B);\n', '        uint part3 = T.mul(b);\n', '        uint numerator = part1.mul((part2.add(part3)));\n', '        uint part4 = 4 * (T.mul(B));\n', '        return numerator.div(part4);\n', '    }\n', '\n', '    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint share){\n', '        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3\n', '        // (part1 * (part2 - part3 + part4)) / part5\n', '        uint part1 = u.mul(A);\n', '        uint part2 = U.mul(U).mul(2);\n', '        uint part3 = U.mul(u).mul(2);\n', '        uint part4 = u.mul(u);\n', '        uint numerator = part1.mul(part2.sub(part3).add(part4));\n', '        uint part5 = U.mul(U).mul(U);\n', '        return numerator.div(part5);\n', '    }\n', '\n', '}']