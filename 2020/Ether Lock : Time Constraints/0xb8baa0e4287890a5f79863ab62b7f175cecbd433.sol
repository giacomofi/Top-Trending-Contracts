['# @version 0.2.4\n', '"""\n', '@title Curve DAO Token\n', '@author Curve Finance\n', '@license MIT\n', '@notice ERC20 with piecewise-linear mining supply.\n', '@dev Based on the ERC-20 token standard as defined at\n', '     https://eips.ethereum.org/EIPS/eip-20\n', '"""\n', '\n', 'from vyper.interfaces import ERC20\n', '\n', 'implements: ERC20\n', '\n', '\n', 'event Transfer:\n', '    _from: indexed(address)\n', '    _to: indexed(address)\n', '    _value: uint256\n', '\n', 'event Approval:\n', '    _owner: indexed(address)\n', '    _spender: indexed(address)\n', '    _value: uint256\n', '\n', 'event UpdateMiningParameters:\n', '    time: uint256\n', '    rate: uint256\n', '    supply: uint256\n', '\n', 'event SetMinter:\n', '    minter: address\n', '\n', 'event SetAdmin:\n', '    admin: address\n', '\n', '\n', 'name: public(String[64])\n', 'symbol: public(String[32])\n', 'decimals: public(uint256)\n', '\n', 'balanceOf: public(HashMap[address, uint256])\n', 'allowances: HashMap[address, HashMap[address, uint256]]\n', 'total_supply: uint256\n', '\n', 'minter: public(address)\n', 'admin: public(address)\n', '\n', '# General constants\n', 'HOUR: constant(uint256) = 3600\n', 'DAY: constant(uint256) = 86400\n', 'WEEK: constant(uint256) = 86400 * 7\n', 'YEAR: constant(uint256) = WEEK * 52\n', '\n', '# Allocation:\n', '# ===========\n', '# WE GIVE IT BACK TO YOU ... THE PEOPLE: 100%\n', '\n', '# Supply parameters\n', 'INITIAL_SUPPLY: constant(uint256) = 0\n', 'INFLATION_DELAY: constant(uint256) = 3 * HOUR # Three Hour delay before minting may begin\n', 'RATE_DENOMINATOR: constant(uint256) = 10 ** 18\n', 'RATE_TIME: constant(uint256) = 2 * WEEK # How often the rate goes to the next epoch\n', 'INITIAL_RATE: constant(uint256) = 9_000_000 * 10 ** 18 / (2 * WEEK) # 9 million for the first 2 weeks\n', 'EPOCH_INITIAL_RATE: constant(uint256) = 9_000_000 * 10 ** 18 / YEAR # 9 million for the first year thereafter\n', 'LATE_RATE: constant(uint256) = 3_000_000 * 10 ** 18 / YEAR # 3 million per year after\n', 'INITIAL_RATE_EPOCH_CUTTOF: constant(uint256) = 27 # After 52 Weeks use the late rate\n', 'FINAL_INFLATION_EPOCH: constant(uint256) = 157 # No more inflation after 6 years (0 epoch is the 2 week period)\n', '\n', '# Supply variables\n', 'mining_epoch: public(int128)\n', 'start_epoch_time: public(uint256)\n', 'rate: public(uint256)\n', '\n', 'start_epoch_supply: uint256\n', '\n', '\n', '@external\n', 'def __init__(_name: String[64], _symbol: String[32], _decimals: uint256):\n', '    """\n', '    @notice Contract constructor\n', '    @param _name Token full name\n', '    @param _symbol Token symbol\n', '    @param _decimals Number of decimals for token\n', '    """\n', '    init_supply: uint256 = INITIAL_SUPPLY * 10 ** _decimals\n', '    self.name = _name\n', '    self.symbol = _symbol\n', '    self.decimals = _decimals\n', '    self.balanceOf[msg.sender] = init_supply\n', '    self.total_supply = init_supply\n', '    self.admin = msg.sender\n', '    log Transfer(ZERO_ADDRESS, msg.sender, init_supply)\n', '\n', '    self.start_epoch_time = block.timestamp + INFLATION_DELAY - RATE_TIME\n', '    self.mining_epoch = -1\n', '    self.rate = 0\n', '    self.start_epoch_supply = init_supply\n', '\n', '\n', '@internal\n', 'def _update_mining_parameters():\n', '    """\n', '    @dev Update mining rate and supply at the start of the epoch\n', '         Any modifying mining call must also call this\n', '    """\n', '    _rate: uint256 = self.rate\n', '    _start_epoch_supply: uint256 = self.start_epoch_supply\n', '    \n', '    self.mining_epoch += 1\n', '    self.start_epoch_time += RATE_TIME\n', '\n', '    if self.mining_epoch == 0:\n', '        _rate = INITIAL_RATE\n', '    else:\n', '        _start_epoch_supply += _rate * RATE_TIME\n', '\n', '        if self.mining_epoch < INITIAL_RATE_EPOCH_CUTTOF:\n', '            _rate = EPOCH_INITIAL_RATE\n', '        elif self.mining_epoch >= FINAL_INFLATION_EPOCH:\n', '            _rate = 0\n', '        else:\n', '            _rate = LATE_RATE\n', '\n', '    self.start_epoch_supply = _start_epoch_supply\n', '    self.rate = _rate\n', '\n', '    log UpdateMiningParameters(block.timestamp, _rate, _start_epoch_supply)\n', '\n', '\n', '@external\n', 'def update_mining_parameters():\n', '    """\n', '    @notice Update mining rate and supply at the start of the epoch\n', '    @dev Callable by any address, but only once per epoch\n', '         Total supply becomes slightly larger if this function is called late\n', '    """\n', '    assert block.timestamp >= self.start_epoch_time + RATE_TIME  # dev: too soon!\n', '    self._update_mining_parameters()\n', '\n', '\n', '@external\n', 'def start_epoch_time_write() -> uint256:\n', '    """\n', '    @notice Get timestamp of the current mining epoch start\n', '            while simultaneously updating mining parameters\n', '    @return Timestamp of the epoch\n', '    """\n', '    _start_epoch_time: uint256 = self.start_epoch_time\n', '    if block.timestamp >= _start_epoch_time + RATE_TIME:\n', '        self._update_mining_parameters()\n', '        return self.start_epoch_time\n', '    else:\n', '        return _start_epoch_time\n', '\n', '\n', '@external\n', 'def future_epoch_time_write() -> uint256:\n', '    """\n', '    @notice Get timestamp of the next mining epoch start\n', '            while simultaneously updating mining parameters\n', '    @return Timestamp of the next epoch\n', '    """\n', '    _start_epoch_time: uint256 = self.start_epoch_time\n', '    if block.timestamp >= _start_epoch_time + RATE_TIME:\n', '        self._update_mining_parameters()\n', '        return self.start_epoch_time + RATE_TIME\n', '    else:\n', '        return _start_epoch_time + RATE_TIME\n', '\n', '\n', '@internal\n', '@view\n', 'def _available_supply() -> uint256:\n', '    return self.start_epoch_supply + (block.timestamp - self.start_epoch_time) * self.rate\n', '\n', '\n', '@external\n', '@view\n', 'def available_supply() -> uint256:\n', '    """\n', '    @notice Current number of tokens in existence (claimed or unclaimed)\n', '    """\n', '    return self._available_supply()\n', '\n', '\n', '@external\n', 'def set_minter(_minter: address):\n', '    """\n', '    @notice Set the minter address\n', '    @dev Only callable once, when minter has not yet been set\n', '    @param _minter Address of the minter\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '    assert self.minter == ZERO_ADDRESS  # dev: can set the minter only once, at creation\n', '    self.minter = _minter\n', '    log SetMinter(_minter)\n', '\n', '\n', '@external\n', 'def set_admin(_admin: address):\n', '    """\n', '    @notice Set the new admin.\n', '    @dev After all is set up, admin only can change the token name\n', '    @param _admin New admin address\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '    self.admin = _admin\n', '    log SetAdmin(_admin)\n', '\n', '\n', '@external\n', '@view\n', 'def totalSupply() -> uint256:\n', '    """\n', '    @notice Total number of tokens in existence.\n', '    """\n', '    return self.total_supply\n', '\n', '\n', '@external\n', '@view\n', 'def allowance(_owner : address, _spender : address) -> uint256:\n', '    """\n', '    @notice Check the amount of tokens that an owner allowed to a spender\n', '    @param _owner The address which owns the funds\n', '    @param _spender The address which will spend the funds\n', '    @return uint256 specifying the amount of tokens still available for the spender\n', '    """\n', '    return self.allowances[_owner][_spender]\n', '\n', '\n', '@external\n', 'def transfer(_to : address, _value : uint256) -> bool:\n', '    """\n', '    @notice Transfer `_value` tokens from `msg.sender` to `_to`\n', '    @dev Vyper does not allow underflows, so the subtraction in\n', '         this function will revert on an insufficient balance\n', '    @param _to The address to transfer to\n', '    @param _value The amount to be transferred\n', '    @return bool success\n', '    """\n', '    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\n', '    self.balanceOf[msg.sender] -= _value\n', '    self.balanceOf[_to] += _value\n', '    log Transfer(msg.sender, _to, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def transferFrom(_from : address, _to : address, _value : uint256) -> bool:\n', '    """\n', '     @notice Transfer `_value` tokens from `_from` to `_to`\n', '     @param _from address The address which you want to send tokens from\n', '     @param _to address The address which you want to transfer to\n', '     @param _value uint256 the amount of tokens to be transferred\n', '     @return bool success\n', '    """\n', '    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\n', '    # NOTE: vyper does not allow underflows\n', '    #       so the following subtraction would revert on insufficient balance\n', '    self.balanceOf[_from] -= _value\n', '    self.balanceOf[_to] += _value\n', '    self.allowances[_from][msg.sender] -= _value\n', '    log Transfer(_from, _to, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def approve(_spender : address, _value : uint256) -> bool:\n', '    """\n', '    @notice Approve `_spender` to transfer `_value` tokens on behalf of `msg.sender`\n', '    @dev Approval may only be from zero -> nonzero or from nonzero -> zero in order\n', '        to mitigate the potential race condition described here:\n', '        https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    @param _spender The address which will spend the funds\n', '    @param _value The amount of tokens to be spent\n', '    @return bool success\n', '    """\n', '    assert _value == 0 or self.allowances[msg.sender][_spender] == 0\n', '    self.allowances[msg.sender][_spender] = _value\n', '    log Approval(msg.sender, _spender, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def mint(_to: address, _value: uint256) -> bool:\n', '    """\n', '    @notice Mint `_value` tokens and assign them to `_to`\n', '    @dev Emits a Transfer event originating from 0x00\n', '    @param _to The account that will receive the created tokens\n', '    @param _value The amount that will be created\n', '    @return bool success\n', '    """\n', '    assert msg.sender == self.minter  # dev: minter only\n', '    assert _to != ZERO_ADDRESS  # dev: zero address\n', '\n', '    if block.timestamp >= self.start_epoch_time + RATE_TIME:\n', '        self._update_mining_parameters()\n', '\n', '    _total_supply: uint256 = self.total_supply + _value\n', '    assert _total_supply <= self._available_supply()  # dev: exceeds allowable mint amount\n', '    self.total_supply = _total_supply\n', '\n', '    self.balanceOf[_to] += _value\n', '    log Transfer(ZERO_ADDRESS, _to, _value)\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def burn(_value: uint256) -> bool:\n', '    """\n', '    @notice Burn `_value` tokens belonging to `msg.sender`\n', '    @dev Emits a Transfer event with a destination of 0x00\n', '    @param _value The amount that will be burned\n', '    @return bool success\n', '    """\n', '    self.balanceOf[msg.sender] -= _value\n', '    self.total_supply -= _value\n', '\n', '    log Transfer(msg.sender, ZERO_ADDRESS, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def set_name(_name: String[64], _symbol: String[32]):\n', '    """\n', '    @notice Change the token name and symbol to `_name` and `_symbol`\n', '    @dev Only callable by the admin account\n', '    @param _name New token name\n', '    @param _symbol New token symbol\n', '    """\n', '    assert msg.sender == self.admin, "Only admin is allowed to change name"\n', '    self.name = _name\n', '    self.symbol = _symbol']