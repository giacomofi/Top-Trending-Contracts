['// Dependency file: contracts/modules/Governable.sol\n', '\n', '// pragma solidity >=0.5.16;\n', '\n', 'contract Governable {\n', '    address public governor;\n', '\n', '    event ChangeGovernor(address indexed _old, address indexed _new);\n', '\n', '    modifier onlyGovernor() {\n', "        require(msg.sender == governor, 'Governable: FORBIDDEN');\n", '        _;\n', '    }\n', '\n', '    // called after deployment\n', '    function initGovernorAddress(address _governor) internal {\n', "        require(governor == address(0), 'Governable: INITIALIZED');\n", "        require(_governor != address(0), 'Governable: INPUT_ADDRESS_IS_ZERO');\n", '        governor = _governor;\n', '    }\n', '\n', '    function changeGovernor(address _new) public onlyGovernor {\n', '        _changeGovernor(_new);\n', '    }\n', '\n', '    function _changeGovernor(address _new) internal {\n', "        require(_new != address(0), 'Governable: INVALID_ADDRESS');\n", "        require(_new != governor, 'Governable: NO_CHANGE');\n", '        address old = governor;\n', '        governor = _new;\n', '        emit ChangeGovernor(old, _new);\n', '    }\n', '\n', '}\n', '\n', '// Dependency file: contracts/modules/Ownable.sol\n', '\n', '// pragma solidity >=0.5.16;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnerChanged(address indexed _oldOwner, address indexed _newOwner);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', "        require(msg.sender == owner, 'Ownable: FORBIDDEN');\n", '        _;\n', '    }\n', '\n', '    function changeOwner(address _newOwner) public onlyOwner {\n', "        require(_newOwner != address(0), 'Ownable: INVALID_ADDRESS');\n", '        emit OwnerChanged(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '\n', '}\n', '\n', '// Dependency file: contracts/modules/TokenRegistry.sol\n', '\n', '// pragma solidity >=0.5.16;\n', '\n', "// import './Governable.sol';\n", '\n', '/**\n', '    Business Process\n', '    step 1. publishToken\n', '    step 2. addToken or removeToken\n', ' */\n', '\n', 'contract TokenRegistry is Governable {\n', '    mapping (address => uint) public tokenStatus;\n', '    mapping (address => uint) public publishTime;\n', '    mapping(address => mapping(address => uint)) public pairStatus;\n', '    uint public tokenCount;\n', '    uint public pairCount;\n', '    address[] public tokenList;\n', '    uint public constant NONE = 0;\n', '    uint public constant REGISTERED = 1;\n', '    uint public constant PENDING = 2;\n', '    uint public constant OPENED = 3;\n', '    uint public constant CLOSED = 4;\n', '\n', '    event TokenStatusChanged(address indexed _token, uint _status, uint _block);\n', '    event PairStatusChanged(address indexed _tokenA, address indexed _tokenB, uint _status);\n', '\n', '    function registryToken(address _token) external onlyGovernor returns (bool) {\n', '        return _updateToken(_token, REGISTERED);\n', '    }\n', '\n', '    function publishToken(address _token) external onlyGovernor returns (bool) {\n', '        publishTime[_token] = block.number;\n', '        return _updateToken(_token, PENDING);\n', '    }\n', '\n', '    function updateToken(address _token, uint _status) external onlyGovernor returns (bool) {\n', '        return _updateToken(_token, _status);\n', '    }\n', '\n', '    function validTokens() external view returns (address[] memory) {\n', '        uint count;\n', '        for (uint i; i < tokenList.length; i++) {\n', '            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\n', '                count++;\n', '            }\n', '        }\n', '        address[] memory res = new address[](count);\n', '        uint index = 0;\n', '        for (uint i; i < tokenList.length; i++) {\n', '            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\n', '                res[index] = tokenList[i];\n', '                index++;\n', '            }\n', '        }\n', '        return res;\n', '    }\n', '\n', '    function iterateValidTokens(uint _start, uint _end) external view returns (address[] memory) {\n', '        require(_end <= tokenList.length, "TokenRegistry: OVERFLOW");\n', '        require(_start <= _end && _start >= 0 && _end >= 0, "TokenRegistry: INVAID_PARAMTERS");\n', '        uint count;\n', '        for (uint i = _start; i < _end; i++) {\n', '            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\n', '                count++;\n', '            }\n', '        }\n', '        address[] memory res = new address[](count);\n', '        uint index = 0;\n', '        for (uint i = _start; i < _end; i++) {\n', '            if (tokenStatus[tokenList[i]] == PENDING || tokenStatus[tokenList[i]] == OPENED) {\n', '                res[index] = tokenList[i];\n', '                index++;\n', '            }\n', '        }\n', '        return res;\n', '    }\n', '\n', '    function _updateToken(address _token, uint _status) internal returns (bool) {\n', "        require(_token != address(0), 'TokenRegistry: INVALID_TOKEN');\n", "        require(tokenStatus[_token] != _status, 'TokenRegistry: TOKEN_STATUS_NO_CHANGE');\n", '        if (tokenStatus[_token] == NONE) {\n', '            tokenCount++;\n', "            require(tokenCount <= uint(-1), 'TokenRegistry: OVERFLOW');\n", '            tokenList.push(_token);\n', '        }\n', '        tokenStatus[_token] = _status;\n', '        emit TokenStatusChanged(_token, _status, block.number);\n', '        return true;\n', '    }\n', '\n', '    function updatePair(address tokenA, address tokenB, uint _status) external onlyGovernor returns (bool) {\n', '        return _updatePair(tokenA, tokenB, _status);\n', '    }\n', '\n', '    function _updatePair(address tokenA, address tokenB, uint _status) internal returns (bool) {\n', "        require(pairStatus[tokenA][tokenB] != _status, 'TokenRegistry: PAIR_STATUS_NO_CHANGE');\n", '        pairStatus[tokenA][tokenB] = _status;\n', '        pairStatus[tokenB][tokenA] = _status;\n', '        emit PairStatusChanged(tokenA, tokenB, _status);\n', '        return true;\n', '    }\n', '\n', '    function _checkPair(address tokenA, address tokenB) internal view returns (bool) {\n', '        uint status = pairStatus[tokenA][tokenB];\n', '        if (status == CLOSED) {\n', '            return false;\n', '        }\n', '        return true;\n', '    }\n', '\n', '}\n', '// Dependency file: contracts/libraries/TransferHelper.sol\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', '// pragma solidity >=0.6.0;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', '// Dependency file: contracts/libraries/ConfigNames.sol\n', '\n', '// pragma solidity >=0.5.16;\n', '\n', 'library ConfigNames {\n', "    bytes32 public constant PRODUCE_DGAS_RATE = bytes32('PRODUCE_DGAS_RATE');\n", "    bytes32 public constant SWAP_FEE_PERCENT = bytes32('SWAP_FEE_PERCENT');\n", "    bytes32 public constant LIST_DGAS_AMOUNT = bytes32('LIST_DGAS_AMOUNT');\n", "    bytes32 public constant UNSTAKE_DURATION = bytes32('UNSTAKE_DURATION');\n", "    bytes32 public constant REMOVE_LIQUIDITY_DURATION = bytes32('REMOVE_LIQUIDITY_DURATION');\n", "    bytes32 public constant TOKEN_TO_DGAS_PAIR_MIN_PERCENT = bytes32('TOKEN_TO_DGAS_PAIR_MIN_PERCENT');\n", "    bytes32 public constant LIST_TOKEN_FAILURE_BURN_PRECENT = bytes32('LIST_TOKEN_FAILURE_BURN_PRECENT');\n", "    bytes32 public constant LIST_TOKEN_SUCCESS_BURN_PRECENT = bytes32('LIST_TOKEN_SUCCESS_BURN_PRECENT');\n", "    bytes32 public constant PROPOSAL_DGAS_AMOUNT = bytes32('PROPOSAL_DGAS_AMOUNT');\n", "    bytes32 public constant VOTE_DURATION = bytes32('VOTE_DURATION');\n", "    bytes32 public constant VOTE_REWARD_PERCENT = bytes32('VOTE_REWARD_PERCENT');\n", "    bytes32 public constant PAIR_SWITCH = bytes32('PAIR_SWITCH');\n", "    bytes32 public constant TOKEN_PENGDING_SWITCH = bytes32('TOKEN_PENGDING_SWITCH');\n", "    bytes32 public constant TOKEN_PENGDING_TIME = bytes32('TOKEN_PENGDING_TIME');\n", '}\n', 'pragma solidity >=0.6.6;\n', '\n', "// import './libraries/ConfigNames.sol';\n", "// import './libraries/TransferHelper.sol';\n", "// import './modules/TokenRegistry.sol';\n", "// import './modules/Ownable.sol';\n", '\n', 'contract DemaxConfig is TokenRegistry, Ownable {\n', '    uint public version = 1;\n', '    event ConigValueChanged(bytes32 _name, uint _old, uint _value);\n', '\n', '    struct Config {\n', '        uint minValue;\n', '        uint maxValue;\n', '        uint maxSpan;\n', '        uint value;\n', '        uint enable;  // 0:disable, 1: enable\n', '    }\n', '\n', '    mapping(bytes32 => Config) public configs;\n', '\n', '    address public dgas;                                // DGAS contract address\n', '    uint public constant PERCENT_DENOMINATOR = 10000;\n', '    uint public constant DGAS_DECIMAL = 10 ** 18;\n', '    address[] public defaultListTokens;\n', '    \n', '    modifier notZero(uint amount) {\n', '        require(amount > 0, "DemaxConfig: ZERO AMOUNT");\n', '        _;\n', '    }\n', '\n', '    constructor()  public {\n', '        _initConfig(ConfigNames.PRODUCE_DGAS_RATE, 1 * DGAS_DECIMAL, 300 * DGAS_DECIMAL, 50 * DGAS_DECIMAL, 100 * DGAS_DECIMAL);\n', '        _initConfig(ConfigNames.SWAP_FEE_PERCENT, 5,30,5,30);\n', '        _initConfig(ConfigNames.LIST_DGAS_AMOUNT, 0, 100000 * DGAS_DECIMAL, 1000 * DGAS_DECIMAL, 0  * DGAS_DECIMAL);\n', '        _initConfig(ConfigNames.UNSTAKE_DURATION, 6500, 6500*7, 6500, 6500);\n', '        _initConfig(ConfigNames.REMOVE_LIQUIDITY_DURATION, 0, 6500*7, 6500, 0);\n', '        _initConfig(ConfigNames.TOKEN_TO_DGAS_PAIR_MIN_PERCENT, 200, 500, 10, 200);\n', '        _initConfig(ConfigNames.LIST_TOKEN_FAILURE_BURN_PRECENT, 100, 5000, 500, 1000);\n', '        _initConfig(ConfigNames.LIST_TOKEN_SUCCESS_BURN_PRECENT, 1000, 5000, 500, 5000);\n', '        _initConfig(ConfigNames.PROPOSAL_DGAS_AMOUNT, 100 * DGAS_DECIMAL, 10000 * DGAS_DECIMAL, 100 * DGAS_DECIMAL, 0);\n', '        _initConfig(ConfigNames.VOTE_DURATION, 6500, 6500*7, 6500, 0);\n', '        _initConfig(ConfigNames.VOTE_REWARD_PERCENT, 0, 1000, 100, 500);\n', '        _initConfig(ConfigNames.PAIR_SWITCH, 0, 1, 1, 1);  // 0:off, 1:on\n', '        _initConfig(ConfigNames.TOKEN_PENGDING_SWITCH, 0, 1, 1, 1);  // 0:off, 1:on\n', '        _initConfig(ConfigNames.TOKEN_PENGDING_TIME, 0, 100*6500, 10*6500, 100*6500);\n', '    }\n', '\n', '    function _initConfig(bytes32 _name, uint _minValue, uint _maxValue, uint _maxSpan, uint _value) internal {\n', '        Config storage config = configs[_name];\n', '        config.minValue = _minValue;\n', '        config.maxValue = _maxValue;\n', '        config.maxSpan = _maxSpan;\n', '        config.value = _value;\n', '        config.enable = 1;\n', '    }\n', '\n', '    function initialize(address _dgas, address _governor, address[] memory _listTokens) public onlyOwner {\n', '        require(dgas == address(0), "DemaxConfig: INITIALIZED");\n', '        require(_dgas != address(0), "DemaxConfig: ZERO ADDRESS");\n', '        dgas = _dgas;\n', '        for(uint i = 0 ; i < _listTokens.length; i++){\n', '            _updateToken(_listTokens[i], OPENED);\n', '            defaultListTokens.push(_listTokens[i]);\n', '        }\n', '        initGovernorAddress(_governor);\n', '    }\n', '\n', '    function modifyGovernor(address _new) public onlyOwner {\n', '        _changeGovernor(_new);\n', '    }\n', '\n', '    function getConfig(bytes32 _name) external view returns (uint minValue, uint maxValue, uint maxSpan, uint value, uint enable) {\n', '        Config memory config = configs[_name];\n', '        minValue = config.minValue;\n', '        maxValue = config.maxValue;\n', '        maxSpan = config.maxSpan;\n', '        value = config.value;\n', '        enable = config.enable;\n', '    }\n', '    \n', '    function getConfigValue(bytes32 _name) public view returns (uint) {\n', '        return configs[_name].value;\n', '    }\n', '\n', '    function changeConfigValue(bytes32 _name, uint _value) external onlyGovernor returns (bool) {\n', '        Config storage config = configs[_name];\n', '        require(config.enable == 1, "DemaxConfig: DISABLE");\n', '        require(_value <= config.maxValue && _value >= config.minValue, "DemaxConfig: OVERFLOW");\n', '        uint old = config.value;\n', '        uint span = _value >= old ? (_value - old) : (old - _value);\n', '        require(span <= config.maxSpan, "DemaxConfig: EXCEED MAX ADJUST SPAN");\n', '        config.value = _value;\n', '        emit ConigValueChanged(_name, old, _value);\n', '        return true;\n', '    }\n', '\n', '    function checkToken(address _token) public view returns(bool) {\n', '        if (tokenStatus[_token] == OPENED) {\n', '            return true;\n', '        } else if (tokenStatus[_token] == PENDING ) {\n', '            if (getConfigValue(ConfigNames.TOKEN_PENGDING_SWITCH) == 1 && block.number > publishTime[_token] + getConfigValue(ConfigNames.TOKEN_PENGDING_TIME)) {\n', '                return false;\n', '            } else {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function checkPair(address tokenA, address tokenB) external view returns (bool) {\n', '        if (checkToken(tokenA) && checkToken(tokenB) && _checkPair(tokenA, tokenB)) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function getDefaultListTokens() external view returns (address[] memory) {\n', '        address[] memory res = new address[](defaultListTokens.length);\n', '        for (uint i; i < defaultListTokens.length; i++) {\n', '            res[i] = defaultListTokens[i];\n', '        }\n', '        return res;\n', '    }\n', '\n', '}']