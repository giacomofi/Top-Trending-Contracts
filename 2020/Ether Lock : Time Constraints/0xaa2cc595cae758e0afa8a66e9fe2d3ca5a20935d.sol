['pragma solidity ^0.7.0;\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "add overflow");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "sub underflow");\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "mul overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "div by zero");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract DegensToken {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "Degens Token";\n', '    string public constant symbol = "DEGENS";\n', '    uint8 public constant decimals = 18;\n', '    uint256 immutable public totalSupply;\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    mapping(address => uint256) public nonces;\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");\n', '    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '\n', '    constructor(uint256 amountToDistribute) {\n', '        totalSupply = amountToDistribute;\n', '        balanceOf[msg.sender] = amountToDistribute;\n', '        emit Transfer(address(0), msg.sender, amountToDistribute);\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool) {\n', '        return transferFrom(msg.sender, recipient, amount);\n', '    }\n', '\n', '    function transferFrom(address from, address recipient, uint256 amount) public returns (bool) {\n', '        require(balanceOf[from] >= amount, "insufficient balance");\n', '        if (from != msg.sender && allowance[from][msg.sender] != uint256(-1)) {\n', '            require(allowance[from][msg.sender] >= amount, "insufficient allowance");\n', '            allowance[from][msg.sender] = allowance[from][msg.sender].sub(amount);\n', '        }\n', '        balanceOf[from] = balanceOf[from].sub(amount);\n', '        balanceOf[recipient] = balanceOf[recipient].add(amount);\n', '        emit Transfer(from, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool) {\n', '        allowance[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n', '        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n', '        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n', '        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '\n', '        address signatory = ecrecover(digest, v, r, s);\n', '        require(signatory != address(0), "permit: invalid signature");\n', '        require(signatory == owner, "permit: unauthorized");\n', '        require(block.timestamp <= deadline, "permit: signature expired");\n', '\n', '        allowance[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    function getChainId() private pure returns (uint chainId) {\n', '        assembly { chainId := chainid() }\n', '    }\n', '}\n', '\n', 'contract DegensTokenDistributor {\n', '    using SafeMath for uint256;\n', '\n', '    bytes32 immutable public merkleRoot;\n', '    uint256 public unclaimed;\n', '    mapping(uint256 => uint256) public claimed; // index -> tokens claimed\n', '\n', '    DegensToken immutable public token;\n', '    uint64 immutable public timeDeployed;\n', '\n', '    constructor(bytes32 merkleRoot_, uint256 unclaimed_) {\n', '        merkleRoot = merkleRoot_;\n', '        unclaimed = unclaimed_;\n', '\n', '        token = new DegensToken(unclaimed_);\n', '        timeDeployed = uint64(block.timestamp);\n', '    }\n', '\n', '    function amountClaimable(uint256 index, uint256 allocation, uint256 vestingYears) public view returns (uint256) {\n', '        uint256 yearsElapsed = block.timestamp.sub(timeDeployed).mul(1e18).div(86400 * 365);\n', '\n', '        uint256 fractionVested = vestingYears == 0 ? 1e18 : yearsElapsed.div(vestingYears).min(1e18);\n', '\n', '        uint256 amountVested = allocation.mul(fractionVested).div(1e18).min(allocation);\n', '\n', '        return amountVested.sub(claimed[index]);\n', '    }\n', '\n', '    function claim(uint256 index, address claimer, uint256 allocation, uint256 vestingYears, bytes32[] memory witnesses, uint256 path) public {\n', '        // Validate proof\n', '\n', '        bytes32 node = keccak256(abi.encodePacked(index, claimer, allocation, vestingYears));\n', '\n', '        for (uint256 i = 0; i < witnesses.length; i++) {\n', '            if ((path & 1) == 0) {\n', '                node = keccak256(abi.encodePacked(node, witnesses[i]));\n', '            } else {\n', '                node = keccak256(abi.encodePacked(witnesses[i], node));\n', '            }\n', '\n', '            path >>= 1;\n', '        }\n', '\n', '        require(node == merkleRoot, "incorrect proof");\n', '\n', '        // Compute amount claimable\n', '\n', '        uint256 toClaim = amountClaimable(index, allocation, vestingYears);\n', '        require(toClaim > 0, "nothing claimable");\n', '\n', '        // Update distributor records\n', '\n', '        claimed[index] = claimed[index].add(toClaim);\n', '        unclaimed = unclaimed.sub(toClaim);\n', '\n', '        // Transfer tokens\n', '\n', '        token.transfer(claimer, toClaim);\n', '    }\n', '}']