['/*\n', '██╗     ███████╗██╗  ██╗    \n', '██║     ██╔════╝╚██╗██╔╝    \n', '██║     █████╗   ╚███╔╝     \n', '██║     ██╔══╝   ██╔██╗     \n', '███████╗███████╗██╔╝ ██╗    \n', '╚══════╝╚══════╝╚═╝  ╚═╝                                                                             \n', '██╗      ██████╗  ██████╗██╗  ██╗███████╗██████╗     \n', '██║     ██╔═══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗    \n', '██║     ██║   ██║██║     █████╔╝ █████╗  ██████╔╝    \n', '██║     ██║   ██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗    \n', '███████╗╚██████╔╝╚██████╗██║  ██╗███████╗██║  ██║    \n', '╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝\n', 'DEAR MSG.SENDER(S):\n', '/ LXL is a project in beta.\n', '// Please audit & use at your own risk.\n', '/// Entry into LXL shall not create an attorney/client relationship.\n', '//// Likewise, LXL should not be construed as legal advice or replacement for professional counsel.\n', '///// STEAL THIS C0D3SL4W \n', '~presented by LexDAO LLC \\+|+/ \n', '*/\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity 0.7.4;\n', '\n', 'interface IERC20 { // brief interface for erc20 token tx\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n', '}\n', '\n', 'library Address { // helper for address type - see openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '}\n', '\n', 'library SafeERC20 { // wrapper around erc20 token tx for non-standard contract - see openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\n', '    using Address for address;\n', '    \n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '    \n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '    \n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '        (bool success, bytes memory returnData) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returnData.length > 0) { // return data is optional\n', '            require(abi.decode(returnData, (bool)), "SafeERC20: erc20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath { // arithmetic wrapper for unit under/overflow check\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Context { // describe current contract execution context (metaTX support) - see openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract ReentrancyGuard { // call wrapper for reentrancy check - see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '    uint256 private _status;\n', '\n', '    constructor() {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '        _status = _ENTERED;\n', '        _;\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title LexLocker\n', ' * @author LexDAO LLC\n', ' * @notice Milestone token locker registry with embedded resolution. \n', ' */\n', 'contract LexLocker is Context, ReentrancyGuard { \n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    /*$⚖️\\+LXL+/⚔️️$*/\n', "    address public manager; // account managing LXL settings - see 'Manager Functions' - updateable by manager\n", '    address public swiftResolverToken; // token required to participate as swift resolver - updateable by manager\n', '    address public wETH; // ether token wrapper contract reference - updateable by manager\n', '    uint256 private lockerCount; // lockers counted into LXL registry\n', '    uint256 public MAX_DURATION; // time limit on token lockup - default 63113904 (2-year) - updateable by manager\n', '    uint256 public resolutionRate; // rate to determine resolution fee for disputed locker (e.g., 20 = 5% of remainder) - updateable by manager\n', '    uint256 public swiftResolverTokenBalance; // balance required in swiftResolverToken to participate as swift resolver - updateable by manager\n', '    string public lockerTerms; // general terms wrapping LXL protocol - updateable by manager\n', '    string[] public marketTerms; // market terms stamped by manager\n', '    string[] public resolutions; // locker resolutions stamped by LXL resolver\n', '    \n', '    mapping(address => uint256[]) private clientRegistrations; // tracks registered lockers per client account\n', '    mapping(address => uint256[]) private providerRegistrations; // tracks registered lockers per provider account\n', '    mapping(address => bool) public swiftResolverConfirmed; // tracks registered swift resolvers \n', '    mapping(uint256 => ADR) public adrs; // tracks registered ADR details\n', '    mapping(uint256 => Locker) public lockers; // tracks registered LXL details\n', '    \n', '    event DepositLocker(address indexed client, address clientOracle, address indexed provider, address indexed resolver, address token, uint256[] amount, uint256 registration, uint256 sum, uint256 termination, string details, bool swiftResolver);\n', '    event RegisterLocker(address indexed client, address clientOracle, address indexed provider, address indexed resolver, address token, uint256[] amount, uint256 registration, uint256 sum, uint256 termination, string details, bool swiftResolver);\n', '    event ConfirmLocker(uint256 indexed registration); \n', '    event RequestLockerResolution(address indexed client, address indexed counterparty, address indexed resolver, address token, uint256 deposit, uint256 registration, string details, bool swiftResolver); \n', '    event Release(uint256 indexed milestone, uint256 indexed registration); \n', '    event Withdraw(uint256 indexed registration);\n', '    event AssignClientOracle(address indexed clientOracle, uint256 indexed registration);\n', '    event ClientProposeResolver(address indexed proposedResolver, uint256 indexed registration, string details);\n', '    event ProviderProposeResolver(address indexed proposedResolver, uint256 indexed registration, string details);\n', '    event Lock(address indexed caller, uint256 indexed registration, string details);\n', '    event Resolve(uint256 indexed clientAward, uint256 indexed providerAward, uint256 indexed registration, uint256 resolutionFee, string resolution); \n', '    event AddMarketTerms(uint256 indexed index, string terms);\n', '    event AmendMarketTerms(uint256 indexed index, string terms);\n', '    event UpdateLockerSettings(address indexed manager, address indexed swiftResolverToken, address wETH, uint256 MAX_DURATION, uint256 indexed resolutionRate, uint256 swiftResolverTokenBalance, string lockerTerms);\n', '    event TributeToManager(string details);\n', '    event UpdateSwiftResolverStatus(address indexed swiftResolver, string details, bool confirmed);\n', '\n', '    struct ADR {  \n', '        address proposedResolver;\n', '        address resolver;\n', '        uint8 clientProposedResolver;\n', '        uint8 providerProposedResolver;\n', '\t    uint256 resolutionRate;\n', '\t    bool swiftResolver;\n', '    }\n', '    \n', '    struct Locker {  \n', '        address client; \n', '        address clientOracle;\n', '        address provider;\n', '        address token;\n', '        uint8 confirmed;\n', '        uint8 locked;\n', '        uint256[] amount;\n', '        uint256 currentMilestone;\n', '        uint256 milestones;\n', '        uint256 released;\n', '        uint256 sum;\n', '        uint256 termination;\n', '        string details; \n', '    }\n', '    \n', '    constructor(\n', '        address _manager, \n', '        address _swiftResolverToken, \n', '        address _wETH,\n', '        uint256 _MAX_DURATION,\n', '        uint256 _resolutionRate, \n', '        uint256 _swiftResolverTokenBalance, \n', '        string memory _lockerTerms\n', '    ) {\n', '        manager = _manager;\n', '        swiftResolverToken = _swiftResolverToken;\n', '        wETH = _wETH;\n', '        MAX_DURATION = _MAX_DURATION;\n', '        resolutionRate = _resolutionRate;\n', '        swiftResolverTokenBalance = _swiftResolverTokenBalance;\n', '        lockerTerms = _lockerTerms;\n', '    }\n', '\n', '    /***************\n', '    LOCKER FUNCTIONS\n', '    ***************/\n', '    // ************\n', '    // REGISTRATION\n', '    // ************\n', '    /**\n', '     * @notice LXL can be registered as deposit from `client` for benefit of `provider`.\n', '     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\n', '     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to `client` if unsure).\n', '     * @param provider Account to receive registered `amount`s.\n', '     * @param resolver Account that can call `resolve()` to award sum remainder between LXL parties.\n', '     * @param token Token address for deposit.\n', '     * @param amount Lump sum or array of milestone `amount`s to be sent to `provider` on call of `release()`.\n', '     * @param termination Exact termination date in seconds since epoch.\n', '     * @param details Context re: LXL.\n', '     * @param swiftResolver If `true`, sum remainder can be resolved by holders of `swiftResolverToken`.\n', '     */\n', '    function depositLocker( // CLIENT-TRACK\n', '        address clientOracle, \n', '        address provider,\n', '        address resolver,\n', '        address token,\n', '        uint256[] memory amount, \n', '        uint256 termination, \n', '        string memory details,\n', '        bool swiftResolver \n', '    ) external nonReentrant payable returns (uint256) {\n', '        require(_msgSender() != resolver && clientOracle != resolver && provider != resolver, "client/clientOracle/provider = resolver");\n', '        require(termination <= block.timestamp.add(MAX_DURATION), "duration maxed");\n', '        \n', '        uint256 sum;\n', '        for (uint256 i = 0; i < amount.length; i++) {\n', '            sum = sum.add(amount[i]);\n', '        }\n', '\n', '        if (msg.value > 0) {\n', '            require(token == wETH && msg.value == sum, "!ethBalance");\n', '            (bool success, ) = wETH.call{value: msg.value}("");\n', '            require(success, "!ethCall");\n', '            IERC20(wETH).safeTransfer(address(this), msg.value);\n', '        } else {\n', '            IERC20(token).safeTransferFrom(_msgSender(), address(this), sum);\n', '        }\n', '        \n', '        lockerCount++;\n', '        uint256 registration = lockerCount;\n', '       \n', '        clientRegistrations[_msgSender()].push(registration);\n', '        providerRegistrations[provider].push(registration);\n', '        \n', '        adrs[registration] = ADR( \n', '            address(0),\n', '            resolver,\n', '            0,\n', '            0,\n', '\t        resolutionRate,\n', '\t        swiftResolver);\n', '\n', '        lockers[registration] = Locker( \n', '            _msgSender(), \n', '            clientOracle,\n', '            provider,\n', '            token,\n', '            1,\n', '            0,\n', '            amount,\n', '            1,\n', '            amount.length,\n', '            0,\n', '            sum,\n', '            termination,\n', '            details);\n', '\n', '        emit DepositLocker(_msgSender(), clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \n', '        \n', '\t    return registration;\n', '    }\n', '    \n', '    /**\n', '     * @notice LXL can be registered as `provider` request for `client` deposit (by calling `confirmLocker()`).\n', '     * @param client Account to provide sum deposit and call `release()` of registered `amount`s.\n', '     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to client if unsure).\n', '     * @param provider Account to receive registered `amount`s.\n', '     * @param resolver Account that can call `resolve()` to award sum remainder between LXL parties.\n', '     * @param token Token address for deposit.\n', '     * @param amount Lump sum or array of milestone amounts to be sent to `provider` on call of `release()`.\n', '     * @param termination Exact termination date in seconds since epoch.\n', '     * @param details Context re: LXL.\n', '     * @param swiftResolver If `true`, sum remainder can be resolved by holders of `swiftResolverToken`.\n', '     */\n', '    function registerLocker( // PROVIDER-TRACK\n', '        address client,\n', '        address clientOracle, \n', '        address provider,\n', '        address resolver,\n', '        address token,\n', '        uint256[] memory amount, \n', '        uint256 termination, \n', '        string memory details,\n', '        bool swiftResolver \n', '    ) external nonReentrant returns (uint256) {\n', '        require(client != resolver && clientOracle != resolver && provider != resolver, "client/clientOracle/provider = resolver");\n', '        require(termination <= block.timestamp.add(MAX_DURATION), "duration maxed");\n', '        \n', '        uint256 sum;\n', '        for (uint256 i = 0; i < amount.length; i++) {\n', '            sum = sum.add(amount[i]);\n', '        }\n', ' \n', '        lockerCount++;\n', '        uint256 registration = lockerCount;\n', '        \n', '        clientRegistrations[client].push(registration);\n', '        providerRegistrations[provider].push(registration);\n', '       \n', '        adrs[registration] = ADR( \n', '            address(0),\n', '            resolver,\n', '            0,\n', '            0,\n', '\t        resolutionRate,\n', '\t        swiftResolver);\n', '\n', '        lockers[registration] = Locker( \n', '            client, \n', '            clientOracle,\n', '            provider,\n', '            token,\n', '            0,\n', '            0,\n', '            amount,\n', '            1,\n', '            amount.length,\n', '            0,\n', '            sum,\n', '            termination,\n', '            details);\n', '\n', '        emit RegisterLocker(client, clientOracle, provider, resolver, token, amount, registration, sum, termination, details, swiftResolver); \n', '        \n', '\t    return registration;\n', '    }\n', '    \n', '    /**\n', '     * @notice LXL `client` can confirm after `registerLocker()` is called for their account to deposit sum for `provider`.\n', '     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call.\n', '     * @param registration Registered LXL index.\n', '     */\n', '    function confirmLocker(uint256 registration) external nonReentrant payable { // PROVIDER-TRACK\n', '        Locker storage locker = lockers[registration];\n', '        \n', '        require(_msgSender() == locker.client, "!client");\n', '        require(locker.confirmed == 0, "confirmed");\n', '        \n', '        address token = locker.token;\n', '        uint256 sum = locker.sum;\n', '        \n', '        if (msg.value > 0) {\n', '            require(token == wETH && msg.value == sum, "!ethBalance");\n', '            (bool success, ) = wETH.call{value: msg.value}("");\n', '            require(success, "!ethCall");\n', '            IERC20(wETH).safeTransfer(address(this), msg.value);\n', '        } else {\n', '            IERC20(token).safeTransferFrom(_msgSender(), address(this), sum);\n', '        }\n', '        \n', '        locker.confirmed = 1;\n', '        \n', '        emit ConfirmLocker(registration); \n', '    }\n', '    \n', '    /**\n', '     * @notice LXL depositor (`client`) can request direct resolution between selected `counterparty` over deposit. E.g., staked wager to benefit charity as `counterparty`.\n', '     * @dev If LXL `token` is wETH, msg.value can be wrapped into wETH in single call. \n', '     * @param counterparty Other account (`provider`) that can receive award from `resolver`.\n', '     * @param resolver Account that can call `resolve()` to award deposit between LXL parties.\n', '     * @param token Token address for deposit.\n', '     * @param deposit Lump sum amount for deposit.\n', '     * @param details Context re: resolution request.\n', '     * @param swiftResolver If `true`, deposit can be resolved by holders of `swiftResolverToken`.\n', '     */\n', '    function requestLockerResolution(address counterparty, address resolver, address token, uint256 deposit, string memory details, bool swiftResolver) external nonReentrant payable returns (uint256) {\n', '        require(_msgSender() != resolver && counterparty != resolver, "client/counterparty = resolver");\n', '        \n', '        if (msg.value > 0) {\n', '            require(token == wETH && msg.value == deposit, "!ethBalance");\n', '            (bool success, ) = wETH.call{value: msg.value}("");\n', '            require(success, "!ethCall");\n', '            IERC20(wETH).safeTransfer(address(this), msg.value);\n', '        } else {\n', '            IERC20(token).safeTransferFrom(_msgSender(), address(this), deposit);\n', '        }\n', '        \n', '        uint256[] memory amount = new uint256[](1);\n', '        amount[0] = deposit;\n', '        lockerCount++;\n', '        uint256 registration = lockerCount;\n', '        \n', '        clientRegistrations[_msgSender()].push(registration);\n', '        providerRegistrations[counterparty].push(registration);\n', '        \n', '        adrs[registration] = ADR( \n', '            address(0),\n', '            resolver,\n', '            0,\n', '            0,\n', '\t        resolutionRate,\n', '\t        swiftResolver);\n', '     \n', '        lockers[registration] = Locker( \n', '            _msgSender(), \n', '            address(0),\n', '            counterparty,\n', '            token,\n', '            1,\n', '            1,\n', '            amount,\n', '            0,\n', '            0,\n', '            0,\n', '            deposit,\n', '            0,\n', '            details);\n', '\n', '        emit RequestLockerResolution(_msgSender(), counterparty, resolver, token, deposit, registration, details, swiftResolver); \n', '        \n', '\t    return registration;\n', '    }\n', '    \n', '    // ***********\n', '    // CLIENT MGMT\n', '    // ***********\n', '    /**\n', '     * @notice LXL `client` can assign account as `clientOracle` to help call `release()` and `withdraw()`.\n', '     * @param clientOracle Account that can help call `release()` and `withdraw()` (default to client if unsure).\n', '     * @param registration Registered LXL index.\n', '     */\n', '    function assignClientOracle(address clientOracle, uint256 registration) external nonReentrant {\n', '        Locker storage locker = lockers[registration];\n', '        \n', '        require(_msgSender() == locker.client, "!client");\n', '        require(locker.locked == 0, "locked");\n', '\t    require(locker.released < locker.sum, "released");\n', '        \n', '        locker.clientOracle = clientOracle;\n', '        \n', '        emit AssignClientOracle(clientOracle, registration);\n', '    }\n', '    \n', '    /**\n', '     * @notice LXL `client` or `clientOracle` can release milestone `amount` to `provider` up to `sum` or until `lock()`. \n', '     * @param registration Registered LXL index.\n', '     */\n', '    function release(uint256 registration) external nonReentrant {\n', '    \tLocker storage locker = lockers[registration];\n', '\t    \n', '\t    require(_msgSender() == locker.client || _msgSender() == locker.clientOracle, "!client/oracle");\n', '\t    require(locker.confirmed == 1, "!confirmed");\n', '\t    require(locker.locked == 0, "locked");\n', '\t    require(locker.released < locker.sum, "released");\n', '        \n', '        uint256 milestone = locker.currentMilestone-1;\n', '        uint256 payment = locker.amount[milestone];\n', '        \n', '        IERC20(locker.token).safeTransfer(locker.provider, payment);\n', '        locker.released = locker.released.add(payment);\n', '        if (locker.released < locker.sum) {locker.currentMilestone++;}\n', '        \n', '\t    emit Release(milestone+1, registration); \n', '    }\n', '    \n', '    /**\n', '     * @notice LXL `client` or `clientOracle` can withdraw sum remainder after `termination`. \n', '     * @dev `release()` can still be called by `client` after `termination` to preserve extension option. \n', '     * @param registration Registered LXL index.\n', '     */\n', '    function withdraw(uint256 registration) external nonReentrant {\n', '    \tLocker storage locker = lockers[registration];\n', '        \n', '        require(_msgSender() == locker.client || _msgSender() == locker.clientOracle, "!client/oracle");\n', '        require(locker.confirmed == 1, "!confirmed");\n', '        require(locker.locked == 0, "locked");\n', '        require(locker.released < locker.sum, "released");\n', '        require(locker.termination < block.timestamp, "!terminated");\n', '        \n', '        uint256 remainder = locker.sum.sub(locker.released); \n', '        IERC20(locker.token).safeTransfer(locker.client, remainder);\n', '        locker.released = locker.sum; \n', '        \n', '\t    emit Withdraw(registration); \n', '    }\n', '    \n', '    // **********\n', '    // RESOLUTION\n', '    // **********\n', '    /**\n', '     * @notice LXL `client` or `provider` can lock to freeze release and withdrawal of sum remainder until `resolver` calls `resolve()`. \n', '     * @dev `lock()` can be called repeatedly to allow LXL parties to continue to provide context until resolution. \n', '     * @param registration Registered LXL index.\n', '     * @param details Context re: lock and/or dispute.\n', '     */\n', '    function lock(uint256 registration, string calldata details) external nonReentrant {\n', '        Locker storage locker = lockers[registration]; \n', '        \n', '        require(_msgSender() == locker.client || _msgSender() == locker.provider, "!party"); \n', '        require(locker.confirmed == 1, "!confirmed");\n', '        require(locker.released < locker.sum, "released");\n', '\n', '\t    locker.locked = 1; \n', '\t    \n', '\t    emit Lock(_msgSender(), registration, details);\n', '    }\n', '    \n', '    /**\n', '     * @notice After LXL is locked, selected `resolver` calls to distribute sum remainder between `client` and `provider` minus fee.\n', '     * @param clientAward Remainder amount awarded to `client`.\n', '     * @param providerAward Remainder amount awarded to `provider`.\n', '     * @param registration Registered LXL index.\n', '     * @param resolution Context re: resolution.\n', '     */\n', '    function resolve(uint256 clientAward, uint256 providerAward, uint256 registration, string calldata resolution) external nonReentrant {\n', '        ADR storage adr = adrs[registration];\n', '        Locker storage locker = lockers[registration];\n', '        \n', '        uint256 remainder = locker.sum.sub(locker.released); \n', '\t    uint256 resolutionFee = remainder.div(adr.resolutionRate); // calculate dispute resolution fee as set on registration\n', '\t    \n', '\t    require(_msgSender() != locker.client && _msgSender() != locker.clientOracle && _msgSender() != locker.provider, "client/clientOracle/provider = resolver");\n', '\t    require(locker.locked == 1, "!locked"); \n', '\t    require(locker.released < locker.sum, "released");\n', '\t    require(clientAward.add(providerAward) == remainder.sub(resolutionFee), "awards != remainder - fee");\n', '\t    \n', '\t    if (adr.swiftResolver) {\n', '\t        require(IERC20(swiftResolverToken).balanceOf(_msgSender()) >= swiftResolverTokenBalance && swiftResolverConfirmed[_msgSender()], "!swiftResolverTokenBalance/confirmed");\n', '        } else {\n', '            require(_msgSender() == adr.resolver, "!resolver");\n', '        }\n', '\n', '        IERC20(locker.token).safeTransfer(locker.client, clientAward);\n', '        IERC20(locker.token).safeTransfer(locker.provider, providerAward);\n', '        IERC20(locker.token).safeTransfer(adr.resolver, resolutionFee);\n', '\t    \n', '\t    locker.released = locker.sum; \n', '\t    resolutions.push(resolution);\n', '\t    \n', '\t    emit Resolve(clientAward, providerAward, registration, resolutionFee, resolution);\n', '    }\n', '    \n', '    /**\n', '     * @notice Fallback to allow LXL party to suggest new `resolver` to counterparty.\n', '     * @dev LXL `client` calls to update `resolver` selection. If matches `provider` suggestion or confirmed, `resolver` updates. \n', '     * @param proposedResolver Proposed account to resolve LXL.\n', '     * @param registration Registered LXL index.\n', '     * @param details Context re: proposed resolver.\n', '     */\n', '    function clientProposeResolver(address proposedResolver, uint256 registration, string calldata details) external nonReentrant { \n', '        ADR storage adr = adrs[registration];\n', '        Locker storage locker = lockers[registration]; \n', '        \n', '        require(_msgSender() == locker.client, "!client"); \n', '        require(adr.clientProposedResolver == 0, "pending");\n', '\t    require(locker.released < locker.sum, "released");\n', '        \n', '        if (adr.proposedResolver == proposedResolver) {\n', '            adr.resolver = proposedResolver;\n', '        } else {\n', '            adr.clientProposedResolver = 0;\n', '            adr.providerProposedResolver = 0;\n', '        }\n', '\n', '\t    adr.proposedResolver = proposedResolver; \n', '\t    adr.clientProposedResolver = 1;\n', '\t    \n', '\t    emit ClientProposeResolver(proposedResolver, registration, details);\n', '    }\n', '    \n', '    /**\n', '     * @notice Fallback to allow LXL party to suggest new `resolver` to counterparty.\n', '     * @dev LXL `provider` calls to update `resolver` selection. If matches `client` suggestion or confirmed, `resolver` updates. \n', '     * @param proposedResolver Proposed account to resolve LXL.\n', '     * @param registration Registered LXL index.\n', '     * @param details Context re: proposed resolver.\n', '     */\n', '    function providerProposeResolver(address proposedResolver, uint256 registration, string calldata details) external nonReentrant { \n', '        ADR storage adr = adrs[registration];\n', '        Locker storage locker = lockers[registration]; \n', '        \n', '        require(_msgSender() == locker.provider, "!provider"); \n', '        require(adr.providerProposedResolver == 0, "pending");\n', '\t    require(locker.released < locker.sum, "released");\n', '\n', '\t    if (adr.proposedResolver == proposedResolver) {\n', '            adr.resolver = proposedResolver;\n', '        } else {\n', '            adr.clientProposedResolver = 0;\n', '            adr.providerProposedResolver = 0;\n', '        }\n', '\t    \n', '\t    adr.proposedResolver = proposedResolver;\n', '\t    adr.providerProposedResolver = 1;\n', '\t    \n', '\t    emit ProviderProposeResolver(proposedResolver, registration, details);\n', '    }\n', '    \n', '    /**\n', '     * @notice Swift resolvers can call to update service status.\n', '     * @dev Swift resolvers must first confirm and can continue with details and/or cancel service.  \n', '     * @param details Context re: status update.\n', '     * @param confirmed If `true`, swift resolver can participate in LXL resolution.\n', '     */\n', '    function updateSwiftResolverStatus(string calldata details, bool confirmed) external nonReentrant {\n', '        require(IERC20(swiftResolverToken).balanceOf(_msgSender()) >= swiftResolverTokenBalance, "!swiftResolverTokenBalance");\n', '        swiftResolverConfirmed[_msgSender()] = confirmed;\n', '        emit UpdateSwiftResolverStatus(_msgSender(), details, confirmed);\n', '    }\n', '    \n', '    // *******\n', '    // GETTERS\n', '    // *******\n', '    function getClientRegistrations(address account) external view returns (uint256[] memory) { // get set of `client` registered lockers \n', '        return clientRegistrations[account];\n', '    }\n', '    \n', '    function getLockerCount() external view returns (uint256) { // helper to make it easier to track total lockers\n', '        return lockerCount;\n', '    }\n', '    \n', '    function getLockerMilestones(uint256 registration) external view returns (address, uint256[] memory) { // returns batch of milestone `token` amounts for `provider`\n', '        return (lockers[registration].token, lockers[registration].amount);\n', '    }\n', '    \n', '    function getMarketTermsCount() external view returns (uint256) { // helper to make it easier to track total market terms stamped by `manager`\n', '        return marketTerms.length;\n', '    }\n', '    \n', '    function getProviderRegistrations(address account) external view returns (uint256[] memory) { // get set of `provider` registered lockers \n', '        return providerRegistrations[account];\n', '    }\n', '    \n', '    function getResolutionCount() external view returns (uint256) { // helper to make it easier to track total resolutions passed by LXL `resolver`s\n', '        return resolutions.length;\n', '    }\n', '   \n', '    /****************\n', '    MANAGER FUNCTIONS\n', '    ****************/\n', '    /**\n', '     * @dev Throws if caller is not LXL manager.\n', '     */\n', '    modifier onlyManager {\n', '        require(msg.sender == manager, "!manager");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @notice Updates LXL with new market terms. \n', '     * @param terms New terms to add to LXL market. \n', '     */\n', '    function addMarketTerms(string calldata terms) external nonReentrant onlyManager {\n', '        marketTerms.push(terms);\n', '        emit AddMarketTerms(marketTerms.length-1, terms);\n', '    }\n', '    \n', '    /**\n', '     * @notice Updates LXL with amended market terms. \n', '     * @param index Index in marketTerms array to push amended terms.\n', '     * @param terms Amended terms to add to LXL market. \n', '     */\n', '    function amendMarketTerms(uint256 index, string calldata terms) external nonReentrant onlyManager {\n', '        marketTerms[index] = terms;\n', '        emit AmendMarketTerms(index, terms);\n', '    }\n', '    \n', '    /**\n', '     * @notice General payment function for manager of LXL contract. \n', '     * @param details Describes context for ETH transfer.\n', '     */\n', '    function tributeToManager(string calldata details) external nonReentrant payable {\n', '        (bool success, ) = manager.call{value: msg.value}("");\n', '        require(success, "!ethCall");\n', '        emit TributeToManager(details);\n', '    }\n', '    \n', '    /**\n', '     * @notice Updates LXL management settings.\n', '     * @param _manager Account that governs LXL contract settings.\n', '     * @param _swiftResolverToken Token to mark participants in swift resolution.\n', '     * @param _wETH Contract reference to wrap ether. \n', '     * @param _resolutionRate Common rate to calculate resolution fee for LXL. \n', '     * @param _swiftResolverTokenBalance Token balance required to perform swift resolution. \n', '     * @param _lockerTerms General terms wrapping wrapping LXL protocol.  \n', '     */\n', '    function updateLockerSettings(\n', '        address _manager, \n', '        address _swiftResolverToken, \n', '        address _wETH, \n', '        uint256 _MAX_DURATION, \n', '        uint256 _resolutionRate, \n', '        uint256 _swiftResolverTokenBalance, \n', '        string calldata _lockerTerms\n', '    ) external nonReentrant onlyManager { \n', '        manager = _manager;\n', '        swiftResolverToken = _swiftResolverToken;\n', '        wETH = _wETH;\n', '        MAX_DURATION = _MAX_DURATION;\n', '        resolutionRate = _resolutionRate;\n', '        swiftResolverTokenBalance = _swiftResolverTokenBalance;\n', '        lockerTerms = _lockerTerms;\n', '\t    \n', '\t    emit UpdateLockerSettings(_manager, _swiftResolverToken, _wETH, _MAX_DURATION, _resolutionRate, _swiftResolverTokenBalance, _lockerTerms);\n', '    }\n', '}']