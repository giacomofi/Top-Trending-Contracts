['// File: contracts/libraries/SafeMath.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.6;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '    }\n', '}\n', '\n', '// File: contracts/libraries/Math.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.6;\n', '\n', '// a library for performing various math operations\n', '\n', 'library Math {\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        z = x < y ? x : y;\n', '    }\n', '\n', '    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n', '    function sqrt(uint y) internal pure returns (uint z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint x = y / 2 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IERC20.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IHiposwapV1Callee.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IHiposwapV1Callee {\n', '    function hiposwapV1Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n', '}\n', '\n', '// File: contracts/interfaces/IHiposwapV2Pair.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IHiposwapV2Pair {\n', '    \n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint reserve0, uint reserve1);\n', '    event _Maker(address indexed sender, address token, uint amount, uint time);\n', '\n', '    \n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function currentPoolId0() external view returns (uint);\n', '    function currentPoolId1() external view returns (uint);\n', '    function getMakerPool0(uint poolId) external view returns (uint _balance, uint _swapOut, uint _swapIn);\n', '    function getMakerPool1(uint poolId) external view returns (uint _balance, uint _swapOut, uint _swapIn);\n', '    function getReserves() external view returns (uint reserve0, uint reserve1);\n', '    function getBalance() external view returns (uint _balance0, uint _balance1);\n', '    function getMaker(address mkAddress) external view returns (uint,address,uint,uint);\n', '    function getFees() external view returns (uint _fee0, uint _fee1);\n', '    function getFeeAdmins() external view returns (uint _feeAdmin0, uint _feeAdmin1);\n', '    function getAvgTimes() external view returns (uint _avgTime0, uint _avgTime1);\n', '    function transferFeeAdmin(address to) external;\n', '    function getFeePercents() external view returns (uint _feeAdminPercent, uint _feePercent, uint _totalPercent);\n', '    function setFeePercents(uint _feeAdminPercent, uint _feePercent, uint _totalPercent) external;\n', '    function getRemainPercent() external view returns (uint);\n', '    function getTotalPercent() external view returns (uint);\n', '    \n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function order(address to) external returns (address token, uint amount);\n', '    function retrieve(uint amount0, uint amount1, address sender, address to) external returns (uint, uint);\n', '    function getAmountA(address to, uint amountB) external view returns(uint amountA, uint _amountB, uint rewardsB, uint remainA);\n', '    function getAmountB(address to, uint amountA) external view returns(uint _amountA, uint amountB, uint rewardsB, uint remainA);\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/GSN/Context.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/Ownable.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/HiposwapV2Pair.sol\n', '\n', 'pragma solidity =0.6.6;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract HiposwapV2Pair is IHiposwapV2Pair, Ownable {\n', '    using SafeMath  for uint;\n', '    \n', "    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '    \n', '    address public override factory;\n', '    address public override token0;\n', '    address public override token1;\n', '    \n', '    uint private fee0;\n', '    uint private fee1;\n', '    \n', '    uint private feeAdmin0;\n', '    uint private feeAdmin1;\n', '    \n', '    uint public totalWeightTime0;\n', '    uint public totalWeightTime1;\n', '    \n', '    uint public totalTokens0;\n', '    uint public totalTokens1;\n', '    \n', '    uint private avgTime0;\n', '    uint private avgTime1;\n', '    \n', '    uint private reserve0;\n', '    uint private reserve1;\n', '    \n', '    uint private feeAdminPercent = 5;\n', '    uint private feePercent = 10;\n', '    uint private totalPercent = 10000;\n', '    \n', '    struct MakerPool {\n', '        uint balance; // remain tokenA\n', '        uint swapOut; // swapped tokenA\n', '        uint swapIn; // received tokenB\n', '        uint createTime;\n', '    }\n', '    \n', '    MakerPool[] public makerPools0;\n', '    MakerPool[] public makerPools1;\n', '    \n', '    uint public override currentPoolId0;\n', '    uint public override currentPoolId1;\n', '    \n', '    struct Maker {\n', '        uint poolId;\n', '        address token;\n', '        uint amount;\n', '        uint time;\n', '    }\n', '    mapping(address => Maker) private makers;\n', '    \n', '    uint public constant MINIMUM_SWITCH_POOL_TIME = 30 minutes;\n', '    \n', '    uint private unlocked = 1;\n', '    modifier lock() {\n', "        require(unlocked == 1, 'HiposwapV2Pair: LOCKED');\n", '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '    \n', '    function getReserves() public override view returns (uint _reserve0, uint _reserve1) {\n', '        _reserve0 = reserve0;\n', '        _reserve1 = reserve1;\n', '    }\n', '    \n', '    function getFees() public override view returns (uint _fee0, uint _fee1) {\n', '        _fee0 = fee0;\n', '        _fee1 = fee1;\n', '    }\n', '    \n', '    function getFeeAdmins() public override view returns (uint _feeAdmin0, uint _feeAdmin1) {\n', '        _feeAdmin0 = feeAdmin0;\n', '        _feeAdmin1 = feeAdmin1;\n', '    }\n', '    \n', '    function getAvgTimes() public override view returns (uint _avgTime0, uint _avgTime1) {\n', '        _avgTime0 = avgTime0;\n', '        _avgTime1 = avgTime1;\n', '    }\n', '    \n', '    function getFeePercents() public override view returns (uint _feeAdminPercent, uint _feePercent, uint _totalPercent) {\n', '        _feeAdminPercent = feeAdminPercent;\n', '        _feePercent = feePercent;\n', '        _totalPercent = totalPercent;\n', '    }\n', '    \n', '    function getRemainPercent() public override view returns (uint) {\n', '        return totalPercent.sub(feeAdminPercent).sub(feePercent);\n', '    }\n', '    \n', '    function getTotalPercent() external override view returns (uint) {\n', '        return totalPercent;\n', '    }\n', '    \n', '    function setFeePercents(uint _feeAdminPercent, uint _feePercent, uint _totalPercent) public override onlyOwner {\n', '        require(_feeAdminPercent.add(_feePercent) < _totalPercent, "HiposwapV2Pair: INVALID_PARAM");\n', '        feeAdminPercent = _feeAdminPercent;\n', '        feePercent = _feePercent;\n', '        totalPercent = _totalPercent;\n', '    }\n', '    \n', '    function getBalance() public override view returns (uint _balance0, uint _balance1) {\n', '        _balance0 = IERC20(token0).balanceOf(address(this));\n', '        _balance1 = IERC20(token1).balanceOf(address(this));\n', '    }\n', '    \n', '    function getMaker(address mkAddress) public override view returns (uint,address,uint,uint) {\n', '        Maker memory m = makers[mkAddress];\n', '        return (m.poolId, m.token, m.amount, m.time);\n', '    }\n', '    \n', '    function getMakerPool0(uint poolId) public override view returns (uint _balance, uint _swapOut, uint _swapIn) {\n', '        return _getMakerPool(true, poolId);\n', '    }\n', '    \n', '    function getMakerPool1(uint poolId) public override view returns (uint _balance, uint _swapOut, uint _swapIn) {\n', '        return _getMakerPool(false, poolId);\n', '    }\n', '    \n', '    function _getMakerPool(bool left, uint poolId) private view returns (uint _balance, uint _swapOut, uint _swapIn) {\n', '        MakerPool[] memory mps = left ? makerPools0 : makerPools1;\n', '        if (mps.length > poolId) {\n', '            MakerPool memory mp = mps[poolId];\n', '            return (mp.balance, mp.swapOut, mp.swapIn);\n', '        }\n', '    }\n', '    \n', '    function _safeTransfer(address token, address to, uint value) private {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'HiposwapV2Pair: TRANSFER_FAILED');\n", '    }\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint reserve0, uint reserve1);\n', '    event _Maker(address indexed sender, address token, uint amount, uint time);\n', '    \n', '    constructor() public {\n', '        factory = msg.sender;\n', '    }\n', '\n', '    // called once by the factory at time of deployment\n', '    function initialize(address _token0, address _token1) external override {\n', "        require(msg.sender == factory, 'HiposwapV2Pair: FORBIDDEN'); // sufficient check\n", '        token0 = _token0;\n', '        token1 = _token1;\n', '    }\n', '    \n', '    function checkMakerPool(bool left) private {\n', '        MakerPool[] storage mps = left ? makerPools0 : makerPools1;\n', '        uint currentPoolId = left ? currentPoolId0 : currentPoolId1;\n', '        if (mps.length > 0) {\n', '            MakerPool storage mp = mps[currentPoolId];\n', '            if (mp.swapOut > mp.balance.mul(9) && now > mp.createTime.add(MINIMUM_SWITCH_POOL_TIME)) {\n', '                mps.push(MakerPool(0, 0, 0, now));\n', '                if (left) {\n', '                    currentPoolId0 = currentPoolId0.add(1);\n', '                    mp.swapIn = mp.swapIn.add(fee1);\n', '                    fee1 = 0;\n', '                    totalWeightTime0 = 0;\n', '                    totalTokens0 = 0;\n', '                    avgTime0 = 0;\n', '                } else {\n', '                    currentPoolId1 = currentPoolId1.add(1);\n', '                    mp.swapIn = mp.swapIn.add(fee0);\n', '                    fee0 = 0;\n', '                    totalWeightTime1 = 0;\n', '                    totalTokens1 = 0;\n', '                    avgTime1 = 0;\n', '                }\n', '            }\n', '        } else {\n', '            mps.push(MakerPool(0, 0, 0, now));\n', '        }\n', '    }\n', '    \n', '    function addFee(bool left, uint fee, uint feeAdmin) private {\n', '        if (left) {\n', '            fee1 = fee1.add(fee);\n', '            feeAdmin1 = feeAdmin1.add(feeAdmin);\n', '        } else {\n', '            fee0 = fee0.add(fee);\n', '            feeAdmin0 = feeAdmin0.add(feeAdmin);\n', '        }\n', '    }\n', '    \n', '    \n', '    function checkAvgTime(bool left, uint time) private view returns (bool isChargeFee) {\n', '        if (left) {\n', '            if(avgTime0 > 0){\n', '                isChargeFee = now < time.add(avgTime0);\n', '            }\n', '        } else {\n', '            if(avgTime1 > 0){\n', '                isChargeFee = now < time.add(avgTime1);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function updateAvgTime(bool left, uint time, uint amount) private {\n', '        if(amount > 0 && now > time) {\n', '            uint weight = (now - time).mul(amount);\n', '            if (left) {\n', '                uint _totalWeightTime0 = totalWeightTime0 + weight;\n', '                if (_totalWeightTime0 >= totalWeightTime0) {\n', '                    totalWeightTime0 = _totalWeightTime0;\n', '                    totalTokens0 = totalTokens0.add(amount);\n', '                    avgTime0 = totalWeightTime0 / totalTokens0;\n', '                } else { // reset if overflow\n', '                    totalWeightTime0 = 0;\n', '                    totalTokens0 = 0;\n', '                }\n', '            } else {\n', '                uint _totalWeightTime1 = totalWeightTime1 + weight;\n', '                if (_totalWeightTime1 >= totalWeightTime1) {\n', '                    totalWeightTime1 = _totalWeightTime1;\n', '                    totalTokens1 = totalTokens1.add(amount);\n', '                    avgTime1 = totalWeightTime1 / totalTokens1;\n', '                } else { // reset if overflow\n', '                    totalWeightTime1 = 0;\n', '                    totalTokens1 = 0;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function transferFeeAdmin(address to) external override onlyOwner{\n', '        require(feeAdmin0 > 0 || feeAdmin1 > 0, "HiposwapV2Pair: EMPTY_ADMIN_FEES");\n', '        if (feeAdmin0 > 0) {\n', '            _safeTransfer(token0, to, feeAdmin0);\n', '            feeAdmin0 = 0;\n', '        }\n', '        if (feeAdmin1 > 0) {\n', '            _safeTransfer(token1, to, feeAdmin1);\n', '            feeAdmin1 = 0;\n', '        }\n', '    }\n', '    \n', '    function order(address to) external override lock returns (address token, uint amount){\n', '        uint amount0 = IERC20(token0).balanceOf(address(this)).sub(reserve0);\n', '        uint amount1 = IERC20(token1).balanceOf(address(this)).sub(reserve1);\n', '        require((amount0 > 0 && amount1 == 0) || (amount0 == 0 && amount1 > 0), "HiposwapV2Pair: INVALID_AMOUNT");\n', '        bool left = amount0 > 0;\n', '        checkMakerPool(left);\n', '        Maker memory mk = makers[to];\n', '        if(mk.amount > 0) {\n', '            require(mk.token == token0 || mk.token == token1, "HiposwapV2Pair: INVALID_TOKEN");\n', '            bool _left = mk.token == token0;\n', '            uint _currentPoolId = _left ? currentPoolId0 : currentPoolId1;\n', '            require(_currentPoolId >= mk.poolId, "HiposwapV2Pair: INVALID_POOL_ID");\n', '            if(_currentPoolId > mk.poolId){\n', '                deal(to);\n', '                mk.amount = 0;\n', '            }else{\n', '                require(left == _left, "HiposwapV2Pair: ONLY_ONE_MAKER_ALLOWED");\n', '            }\n', '        }\n', '        uint currentPoolId = left ? currentPoolId0 : currentPoolId1;\n', '        amount = left ? amount0 : amount1;\n', '        token = left ? token0 : token1;\n', '        makers[to] = Maker(currentPoolId, token, mk.amount.add(amount), now);\n', '        emit _Maker(to, token, amount, now);\n', '        MakerPool storage mp = left ? makerPools0[currentPoolId] : makerPools1[currentPoolId];\n', '        mp.balance = mp.balance.add(amount);\n', '        (reserve0, reserve1) = getBalance();\n', '    }\n', '    \n', '    function deal(address to) public {\n', '        Maker storage mk = makers[to];\n', '        require(mk.token == token0 || mk.token == token1, "HiposwapV2Pair: INVALID_TOKEN");\n', '        bool left = mk.token == token0;\n', '        MakerPool storage mp = left ? makerPools0[mk.poolId] : makerPools1[mk.poolId];\n', '        (uint amountA, uint amountB) = (mk.amount, 0);\n', '        if(mp.swapIn > 0 && mp.swapOut > 0){\n', '            amountB = Math.min(mk.amount.mul(mp.swapIn) / mp.swapOut, mp.swapIn);\n', '            uint swapOut = amountB.mul(mp.swapOut) / mp.swapIn;\n', '            amountA = amountA.sub(swapOut);\n', '            mp.swapIn = mp.swapIn.sub(amountB);\n', '            mp.swapOut = mp.swapOut.sub(swapOut);\n', '        }\n', '        if (amountA > mp.balance) {\n', '            // if swapOut, swapIn, balance = 3, 2, 0; mk.amount = 1; then amountB = 0, amountA = 1;\n', '            uint dust = amountA.sub(mp.balance);\n', '            addFee(!left, dust, 0);\n', '            mp.swapOut = mp.swapOut.sub(dust);\n', '            amountA = mp.balance;\n', '        }\n', '        mp.balance = mp.balance.sub(amountA);\n', '        (uint amount0, uint amount1) = left ? (amountA, amountB) : (amountB, amountA);\n', '        if(amount0 > 0){\n', '            _safeTransfer(token0, to, amount0);\n', '            reserve0 = IERC20(token0).balanceOf(address(this));\n', '        }\n', '        if(amount1 > 0){\n', '            _safeTransfer(token1, to, amount1);\n', '            reserve1 = IERC20(token1).balanceOf(address(this));\n', '        }\n', '        delete makers[to];\n', '    }\n', '    \n', '    function retrieve(uint amount0, uint amount1, address sender, address to) external override lock onlyOwner returns (uint, uint){\n', '        require(amount0 > 0 || amount1 > 0, "HiposwapV2Pair: INVALID_AMOUNT");\n', '        Maker storage mk = makers[sender];\n', '        require(mk.token == token0 || mk.token == token1, "HiposwapV2Pair: INVALID_TOKEN");\n', '        bool left = mk.token == token0;\n', '        \n', '        MakerPool storage mp = left ? makerPools0[mk.poolId] : makerPools1[mk.poolId];\n', '        (uint amountA, uint amountB) = left ? (amount0, amount1) : (amount1, amount0);\n', '        \n', '        bool isChargeFee = mk.poolId == (left ? currentPoolId0 : currentPoolId1) && checkAvgTime(left, mk.time);\n', '        uint amountOrigin = mk.amount;\n', '        if (amountA > 0) {\n', '            uint amountAMax = Math.min(mk.amount, mp.balance);\n', '            uint remain = getRemainPercent();\n', '            amountAMax = isChargeFee ? amountAMax.mul(remain) / totalPercent : amountAMax; // 9985/10000\n', '            require(amountA <= amountAMax, "HiposwapV2Pair: INSUFFICIENT_AMOUNT");\n', '            if(isChargeFee){\n', '                uint fee = amountA.mul(feePercent) / remain; // 10/9985\n', '                uint feeAdmin = amountA.mul(feeAdminPercent) / remain; // = 5/9985\n', '                amountA = amountA.add(fee).add(feeAdmin);\n', '                addFee(!left, fee, feeAdmin);\n', '            }\n', '            mk.amount = mk.amount.sub(amountA);\n', '            mp.balance = mp.balance.sub(amountA);\n', '        }\n', '        \n', '        if (amountB > 0) {\n', '            require(mp.swapIn > 0 && mp.swapOut > 0, "HiposwapV2Pair: INSUFFICIENT_SWAP_BALANCE");\n', '            \n', '            uint amountBMax = Math.min(mp.swapIn, mk.amount.mul(mp.swapIn) / mp.swapOut);\n', '            amountBMax = isChargeFee ? amountBMax.mul(getRemainPercent()) / totalPercent : amountBMax; // 9985/10000\n', '            require(amountB <= amountBMax, "HiposwapV2Pair: INSUFFICIENT_SWAP_AMOUNT");\n', '            \n', '            if(isChargeFee){\n', '                uint fee = amountB.mul(feePercent) / getRemainPercent(); // 10/9985\n', '                uint feeAdmin = amountB.mul(feeAdminPercent) / getRemainPercent(); // = 5/9985\n', '                amountB = amountB.add(fee).add(feeAdmin);\n', '                addFee(left, fee, feeAdmin);\n', '            }else if (mk.poolId == (left ? currentPoolId0 : currentPoolId1)) {\n', '                uint rewards = amountB.mul(feePercent) / totalPercent; // 10/10000\n', '                if(left){\n', '                    if (rewards > fee1) {\n', '                        rewards = fee1;\n', '                    }\n', '                    {\n', '                    uint _amount1 = amount1;\n', '                    amount1 = _amount1.add(rewards);\n', '                    fee1 = fee1.sub(rewards);\n', '                    }\n', '                }else{\n', '                    if (rewards > fee0) {\n', '                        rewards = fee0;\n', '                    }\n', '                    {// avoid stack too deep\n', '                    uint _amount0 = amount0;\n', '                    amount0 = _amount0.add(rewards);\n', '                    fee0 = fee0.sub(rewards);\n', '                    }\n', '                }\n', '            }\n', '            uint _amountA = amountB.mul(mp.swapOut) / mp.swapIn;\n', '            mp.swapIn = mp.swapIn.sub(amountB);\n', '            mk.amount = mk.amount.sub(_amountA);\n', '            mp.swapOut = mp.swapOut.sub(_amountA);\n', '        }\n', '        \n', '        updateAvgTime(left, mk.time, amountOrigin.sub(mk.amount));\n', '        \n', '        if (mk.amount == 0) {\n', '            delete makers[sender];\n', '        }\n', '        if(amount0 > 0){\n', '            _safeTransfer(token0, to, amount0);\n', '            reserve0 = IERC20(token0).balanceOf(address(this));\n', '        }\n', '        if(amount1 > 0){\n', '            _safeTransfer(token1, to, amount1);\n', '            reserve1 = IERC20(token1).balanceOf(address(this));\n', '        }\n', '        return (amount0, amount1);\n', '    }\n', '    \n', '    function getMakerAndPool(address to) private view returns (Maker memory mk, MakerPool memory mp){\n', '        mk = makers[to];\n', '        require(mk.token == token0 || mk.token == token1, "HiposwapV2Pair: INVALID_TOKEN");\n', '        bool left = mk.token == token0;\n', '        uint poolId = mk.poolId;\n', '        uint currentPoolId = left ? currentPoolId0 : currentPoolId1;\n', '        require(poolId >= 0 && poolId <= currentPoolId, "HiposwapV2Pair: INVALID_POOL_ID");\n', '        mp = left ? makerPools0[poolId] : makerPools1[poolId];\n', '    }\n', '    // amountB is exact\n', '    function getAmountA(address to, uint amountB) external override view returns(uint amountA, uint _amountB, uint rewardsB, uint remainA){\n', '        (Maker memory mk, MakerPool memory mp) = getMakerAndPool(to);\n', '        bool left = mk.token == token0;\n', '        uint currentPoolId = left ? currentPoolId0 : currentPoolId1;\n', '        bool isChargeFee = mk.poolId == currentPoolId && checkAvgTime(left, mk.time);\n', '        uint remain = getRemainPercent();\n', '        if(amountB > 0){\n', '            if(mp.swapIn > 0 && mp.swapOut > 0){\n', '                uint mkAmount = isChargeFee ? mk.amount.mul(remain) / totalPercent : mk.amount; // 9985/10000\n', '                uint swapIn = isChargeFee ? mp.swapIn.mul(remain) / totalPercent : mp.swapIn;\n', '                uint amountBMax = Math.min(amountB, Math.min(swapIn, mkAmount.mul(mp.swapIn) / mp.swapOut));\n', '                uint amountAMax = amountBMax.mul(mp.swapOut) / mp.swapIn;\n', '                amountAMax = isChargeFee ? amountAMax.mul(totalPercent) / remain : amountAMax;\n', '                mk.amount = mk.amount.sub(amountAMax);\n', '                _amountB = amountBMax;\n', '                if (!isChargeFee && mk.poolId == currentPoolId) {\n', '                    uint tmp = _amountB; // avoid stack too deep\n', '                    uint rewards = tmp.mul(feePercent) / totalPercent;\n', '                    if(left){\n', '                        if (rewards > fee1) {\n', '                            rewards = fee1;\n', '                        }\n', '                    }else{\n', '                        if (rewards > fee0) {\n', '                            rewards = fee0;\n', '                        }\n', '                    }\n', '                    rewardsB = rewards;\n', '                }\n', '            }\n', '        }\n', '        \n', '        amountA = Math.min(mk.amount, mp.balance);\n', '        remainA = mk.amount.sub(amountA);\n', '        amountA = isChargeFee ? amountA.mul(remain) / totalPercent : amountA;\n', '    }\n', '    // amountA is exact\n', '    function getAmountB(address to, uint amountA) external override view returns(uint _amountA, uint amountB, uint rewardsB, uint remainA){\n', '        (Maker memory mk, MakerPool memory mp) = getMakerAndPool(to);\n', '        bool left = mk.token == token0;\n', '        uint currentPoolId = left ? currentPoolId0 : currentPoolId1;\n', '        bool isChargeFee = mk.poolId == currentPoolId && checkAvgTime(left, mk.time);\n', '        uint remain = getRemainPercent();\n', '        if(amountA > 0){\n', '            uint mkAmount = isChargeFee ? mk.amount.mul(remain) / totalPercent : mk.amount;\n', '            uint mpBalance = isChargeFee ? mp.balance.mul(remain) / totalPercent : mp.balance;\n', '            _amountA = Math.min(Math.min(amountA, mkAmount), mpBalance);\n', '            if (_amountA == mkAmount) {\n', '                mk.amount = 0;\n', '            } else {\n', '                mk.amount = mk.amount.sub(isChargeFee ? _amountA.mul(totalPercent) / remain : _amountA);\n', '            }\n', '        }\n', '        if(mp.swapIn > 0 && mp.swapOut > 0){\n', '            amountB = Math.min(mp.swapIn, mk.amount.mul(mp.swapIn) / mp.swapOut);\n', '            mk.amount = mk.amount.sub(amountB.mul(mp.swapOut) / mp.swapIn);\n', '            if (isChargeFee) {\n', '                amountB = amountB.mul(remain) / totalPercent;\n', '            } else if (mk.poolId == currentPoolId) {\n', '                uint rewards = amountB.mul(feePercent) / totalPercent;\n', '                if(left){\n', '                    if (rewards > fee1) {\n', '                        rewards = fee1;\n', '                    }\n', '                }else{\n', '                    if (rewards > fee0) {\n', '                        rewards = fee0;\n', '                    }\n', '                }\n', '                rewardsB = rewards;\n', '            }\n', '        }\n', '        remainA = mk.amount;\n', '    }\n', '    \n', '    function _update(uint balance0, uint balance1) private {\n', "        require(balance0 <= uint(-1) && balance1 <= uint(-1), 'HiposwapV2Pair: OVERFLOW');\n", '        reserve0 = balance0;\n', '        reserve1 = balance1;\n', '        emit Sync(reserve0, reserve1);\n', '    }\n', '    \n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {\n', "        require(amount0Out > 0 || amount1Out > 0, 'HiposwapV2Pair: INSUFFICIENT_OUTPUT_AMOUNT');\n", '        (uint _reserve0, uint _reserve1) = getReserves(); // gas savings\n', "        require(amount0Out <= _reserve0 && amount1Out <= _reserve1, 'HiposwapV2Pair: INSUFFICIENT_LIQUIDITY');\n", '\n', '        uint balance0;\n', '        uint balance1;\n', '        { // scope for _token{0,1}, avoids stack too deep errors\n', '        address _token0 = token0;\n', '        address _token1 = token1;\n', "        require(to != _token0 && to != _token1, 'HiposwapV2Pair: INVALID_TO');\n", '        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n', '        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n', '        if (data.length > 0) IHiposwapV1Callee(to).hiposwapV1Call(msg.sender, amount0Out, amount1Out, data);\n', '        balance0 = IERC20(_token0).balanceOf(address(this));\n', '        balance1 = IERC20(_token1).balanceOf(address(this));\n', '        }\n', '        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n', '        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n', "        require(amount0In > 0 || amount1In > 0, 'HiposwapV2Pair: INSUFFICIENT_INPUT_AMOUNT');\n", '        \n', '        if (amount0In > 0) {\n', '            uint fee = amount0In.mul(feePercent) / totalPercent; //  = 10/10000\n', '            uint feeAdmin = amount0In.mul(feeAdminPercent) / totalPercent; // = 5/10000\n', '            uint swapIn = amount0In.sub(fee).sub(feeAdmin);\n', '            MakerPool storage mp = makerPools1[currentPoolId1];\n', '            mp.swapIn = mp.swapIn.add(swapIn);\n', '            mp.swapOut = mp.swapOut.add(amount1Out);\n', '            mp.balance = mp.balance.sub(amount1Out);\n', '            addFee(false, fee, feeAdmin);\n', '        }\n', '        if (amount1In >0) {\n', '            uint fee = amount1In.mul(feePercent) / totalPercent; //  = 10/10000\n', '            uint feeAdmin = amount1In.mul(feeAdminPercent) / totalPercent; // = 5/10000\n', '            uint swapIn = amount1In.sub(fee).sub(feeAdmin);\n', '            MakerPool storage mp = makerPools0[currentPoolId0];\n', '            mp.swapIn = mp.swapIn.add(swapIn);\n', '            mp.swapOut = mp.swapOut.add(amount0Out);\n', '            mp.balance = mp.balance.sub(amount0Out);\n', '            addFee(true, fee, feeAdmin);\n', '        }\n', '\n', '        _update(balance0, balance1);\n', '        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n', '    }\n', '    \n', '}\n', '\n', '// File: contracts/interfaces/IHiposwapV2Util.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.6;\n', '\n', 'interface IHiposwapV2Util {\n', '    function pairCreationCode() external returns (bytes memory bytecode);\n', '}\n', '\n', '// File: contracts/HiposwapV2Util.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity =0.6.6;\n', '\n', '\n', '\n', 'contract HiposwapV2Util is IHiposwapV2Util {\n', '    function pairCreationCode() external override returns (bytes memory bytecode){\n', '        bytecode = type(HiposwapV2Pair).creationCode;\n', '    }\n', '}']