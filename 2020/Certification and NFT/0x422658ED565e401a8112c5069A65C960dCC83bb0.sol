['// Copyright (C) 2020 Easy Chain. <https://easychain.tech>\n', '//\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', '// GNU General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program. If not, see <https://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.6.5;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'interface ERC20 {\n', '    function approve(address, uint256) external returns (bool);\n', '    function transfer(address, uint256) external returns (bool);\n', '    function transferFrom(address, address, uint256) external returns (bool);\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address) external view returns (uint256);\n', '}\n', '\n', '\n', 'struct ProtocolBalance {\n', '    ProtocolMetadata metadata;\n', '    AdapterBalance[] adapterBalances;\n', '}\n', '\n', '\n', 'struct ProtocolMetadata {\n', '    string name;\n', '    string description;\n', '    string websiteURL;\n', '    string iconURL;\n', '    uint256 version;\n', '}\n', '\n', '\n', 'struct AdapterBalance {\n', '    AdapterMetadata metadata;\n', '    FullTokenBalance[] balances;\n', '}\n', '\n', '\n', 'struct AdapterMetadata {\n', '    address adapterAddress;\n', '    string adapterType; // "Asset", "Debt"\n', '}\n', '\n', '\n', '// token and its underlying tokens (if exist) balances\n', 'struct FullTokenBalance {\n', '    TokenBalance base;\n', '    TokenBalance[] underlying;\n', '}\n', '\n', '\n', 'struct TokenBalance {\n', '    TokenMetadata metadata;\n', '    uint256 amount;\n', '}\n', '\n', '\n', '// ERC20-style token metadata\n', '// 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE address is used for ETH\n', 'struct TokenMetadata {\n', '    address token;\n', '    string name;\n', '    string symbol;\n', '    uint8 decimals;\n', '}\n', '\n', '\n', 'struct Component {\n', '    address token;\n', '    string tokenType;  // "ERC20" by default\n', '    uint256 rate;  // price per full share (1e18)\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Token adapter interface.\n', ' * @dev getMetadata() and getComponents() functions MUST be implemented.\n', ' * @author Igor Sobolev <sobolev@zerion.io>\n', ' */\n', 'interface TokenAdapter {\n', '\n', '    /**\n', '     * @dev MUST return TokenMetadata struct with ERC20-style token info.\n', '     * struct TokenMetadata {\n', '     *     address token;\n', '     *     string name;\n', '     *     string symbol;\n', '     *     uint8 decimals;\n', '     * }\n', '     */\n', '    function getMetadata(address token) external view returns (TokenMetadata memory);\n', '\n', '    /**\n', '     * @dev MUST return array of Component structs with underlying tokens rates for the given token.\n', '     * struct Component {\n', '     *     address token;    // Address of token contract\n', '     *     string tokenType; // Token type ("ERC20" by default)\n', '     *     uint256 rate;     // Price per share (1e18)\n', '     * }\n', '     */\n', '    function getComponents(address token) external view returns (Component[] memory);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Protocol adapter interface.\n', ' * @dev adapterType(), tokenType(), and getBalance() functions MUST be implemented.\n', ' * @author Igor Sobolev <sobolev@zerion.io>\n', ' */\n', 'interface ProtocolAdapter {\n', '\n', '    /**\n', '     * @dev MUST return "Asset" or "Debt".\n', '     * SHOULD be implemented by the public constant state variable.\n', '     */\n', '    function adapterType() external pure returns (string memory);\n', '\n', '    /**\n', '     * @dev MUST return token type (default is "ERC20").\n', '     * SHOULD be implemented by the public constant state variable.\n', '     */\n', '    function tokenType() external pure returns (string memory);\n', '\n', '    /**\n', '     * @dev MUST return amount of the given token locked on the protocol by the given account.\n', '     */\n', '    function getBalance(address token, address account) external view returns (uint256);\n', '}\n', '\n', '\n', 'struct TypedToken {\n', '    string tokenType;\n', '    address token;\n', '}\n', '\n', 'interface IBerezkaTokenAdapterGovernance {\n', '    \n', '    function listTokens() external view returns (TypedToken[] memory);\n', '\n', '    function listProtocols() external view returns (address[] memory);\n', '\n', '    function listEthProtocols() external view returns (address[] memory);\n', '\n', '    function listProducts() external view returns (address[] memory);\n', '\n', '    function getVaults(address _token) external view returns (address[] memory);\n', '}\n', '\n', 'interface IBerezkaTokenAdapterStakingGovernance {\n', '    \n', '    function listStakings() external view returns (address[] memory);\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Token adapter for Berezka DAO.\n', ' * @dev Implementation of TokenAdapter interface.\n', ' * @author Vasin Denis <denis.vasin@easychain.tech>\n', ' */\n', 'contract BerezkaTokenAdapter is TokenAdapter {\n', '\n', '    address internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '\n', '    string internal constant ERC20_TOKEN = "ERC20";\n', '\n', '    IBerezkaTokenAdapterGovernance immutable private governance;\n', '    IBerezkaTokenAdapterStakingGovernance immutable private stakingGovernance;\n', '\n', '    constructor(address _governance, address _stakingGovernance) public {\n', '        governance = IBerezkaTokenAdapterGovernance(_governance);\n', '        stakingGovernance = IBerezkaTokenAdapterStakingGovernance(_stakingGovernance);   \n', '    }\n', '\n', '    /**\n', '     * @return TokenMetadata struct with ERC20-style token info.\n', '     * @dev Implementation of TokenAdapter interface function.\n', '     */\n', '    function getMetadata(address token) \n', '        external \n', '        view \n', '        override \n', '        returns (TokenMetadata memory) \n', '    {\n', '        return TokenMetadata({\n', '            token: token,\n', '            name: ERC20(token).name(),\n', '            symbol: ERC20(token).symbol(),\n', '            decimals: ERC20(token).decimals()\n', '        });\n', '    }\n', '\n', '    /**\n', '     * @return Array of Component structs with underlying tokens rates for the given token.\n', '     * @dev Implementation of TokenAdapter interface function.\n', '     */\n', '    function getComponents(address token)\n', '        external\n', '        view\n', '        override\n', '        returns (Component[] memory)\n', '    {\n', '        address[] memory vaults = governance.getVaults(token);\n', '        TypedToken[] memory assets = governance.listTokens();\n', '        address[] memory debtAdapters = governance.listProtocols();\n', '        address[] memory stakingAdapters = stakingGovernance.listStakings();\n', '        uint256 length = assets.length;\n', '        uint256 totalSupply = ERC20(token).totalSupply();\n', '\n', '        Component[] memory underlyingTokens = new Component[](1 + length);\n', '        \n', '        // Handle ERC20 assets + debt\n', '        for (uint256 i = 0; i < length; i++) {\n', '            Component memory tokenComponent =\n', '                _getTokenComponents(\n', '                    assets[i].token, \n', '                    assets[i].tokenType, \n', '                    vaults, \n', '                    debtAdapters, \n', '                    stakingAdapters,\n', '                    totalSupply\n', '                );\n', '            underlyingTokens[i] = tokenComponent;\n', '        }\n', '\n', '        // Handle ETH\n', '        {\n', '            Component memory ethComponent = _getEthComponents(vaults, totalSupply);\n', '            underlyingTokens[length] = ethComponent;\n', '        }\n', '        \n', '        return underlyingTokens;\n', '    }\n', '\n', '    // Internal functions\n', '\n', '    function _getEthComponents(\n', '        address[] memory _vaults,\n', '        uint256 _totalSupply\n', '    )\n', '        internal\n', '        view\n', '        returns (Component memory)\n', '    {\n', '        address[] memory debtsInEth = governance.listEthProtocols();\n', '\n', '        uint256 ethBalance = 0;\n', '        uint256 ethDebt = 0;\n', '\n', '        // Compute negative amount for a given asset using all debt adapters\n', '        for (uint256 j = 0; j < _vaults.length; j++) {\n', '            address vault = _vaults[j];\n', '            ethBalance += vault.balance;\n', '            ethDebt += _computeDebt(debtsInEth, ETH, vault);\n', '        }\n', '\n', '        return Component({\n', '            token: ETH,\n', '            tokenType: ERC20_TOKEN,\n', '            rate: (ethBalance * 1e18 / _totalSupply) - (ethDebt * 1e18 / _totalSupply)\n', '        });\n', '    }\n', '\n', '    function _getTokenComponents(\n', '        address _asset,\n', '        string memory _type,\n', '        address[] memory _vaults,\n', '        address[] memory _debtAdapters,\n', '        address[] memory _stakingAdapters,\n', '        uint256 _totalSupply\n', '    ) \n', '        internal\n', '        view\n', '        returns (Component memory)\n', '    {\n', '        uint256 componentBalance = 0;\n', '        uint256 componentStakingBalance = 0;\n', '        uint256 componentDebt = 0;\n', '\n', '        // Compute positive amount for a given asset\n', '        uint256 vaultsLength = _vaults.length;\n', '        for (uint256 j = 0; j < vaultsLength; j++) {\n', '            address vault = _vaults[j];\n', '            componentBalance += ERC20(_asset).balanceOf(vault);\n', '            componentStakingBalance += _computeStakingBalance(_stakingAdapters, _asset, vault);\n', '            componentDebt += _computeDebt(_debtAdapters, _asset, vault);\n', '        }\n', '\n', '        // Asset amount\n', '        return(Component({\n', '            token: _asset,\n', '            tokenType: _type,\n', '            rate: (componentBalance * 1e18 / _totalSupply) + (componentStakingBalance * 1e18 / _totalSupply) - (componentDebt * 1e18 / _totalSupply)\n', '        }));\n', '    }\n', '\n', '    function _computeDebt(\n', '        address[] memory _debtAdapters,\n', '        address _asset,\n', '        address _vault\n', '    ) \n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // Compute negative amount for a given asset using all debt adapters\n', '        uint256 componentDebt = 0;\n', '        uint256 debtsLength = _debtAdapters.length;\n', '        for (uint256 k = 0; k < debtsLength; k++) {\n', '            ProtocolAdapter debtAdapter = ProtocolAdapter(_debtAdapters[k]);\n', '            try debtAdapter.getBalance(_asset, _vault) returns (uint256 _amount) {\n', '                componentDebt += _amount;\n', '            } catch {} // solhint-disable-line no-empty-blocks\n', '        }\n', '        return componentDebt;\n', '    }\n', '\n', '    function _computeStakingBalance(\n', '        address[] memory _stakingAdapters,\n', '        address _asset,\n', '        address _vault\n', '    ) \n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // Compute positive staking amount for a given asset using all staking adapters\n', '        uint256 componentStakingBalance = 0;\n', '        uint256 stakingsLength = _stakingAdapters.length;\n', '        for (uint256 k = 0; k < stakingsLength; k++) {\n', '            ProtocolAdapter stakingAdapter = ProtocolAdapter(_stakingAdapters[k]);\n', '            try stakingAdapter.getBalance(_asset, _vault) returns (uint256 _amount) {\n', '                componentStakingBalance += _amount;\n', '            } catch {} // solhint-disable-line no-empty-blocks\n', '        }\n', '        return componentStakingBalance;\n', '    }\n', '}']