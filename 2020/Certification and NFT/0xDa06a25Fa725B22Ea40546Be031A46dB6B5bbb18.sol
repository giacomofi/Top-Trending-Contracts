['pragma solidity ^0.4.21;\n', '\n', '// This is the ETH/ERC20 multisig contract for Ownbit.\n', '//\n', '// For 2-of-3 multisig, to authorize a spend, two signtures must be provided by 2 of the 3 owners.\n', '// To generate the message to be signed, provide the destination address and\n', '// spend amount (in wei) to the generateMessageToSign method.\n', '// The signatures must be provided as the (v, r, s) hex-encoded coordinates.\n', '// The S coordinate must be 0x00 or 0x01 corresponding to 0x1b and 0x1c, respectively.\n', '//\n', '// WARNING: The generated message is only valid until the next spend is executed.\n', '//          after that, a new message will need to be calculated.\n', '//\n', '//\n', '// INFO: This contract is ERC20 compatible.\n', '// This contract can both receive ETH and ERC20 tokens.\n', '// Notice that NFT (ERC721/ERC1155) is not supported yet.\n', '// Add support for DeFi (Compound)\n', '\n', 'interface Erc20 {\n', '    function approve(address, uint256);\n', '\n', '    function transfer(address, uint256);\n', '}\n', '\n', 'interface CErc20 {\n', '    function mint(uint256) external returns (uint256);\n', '\n', '    function redeem(uint) external returns (uint);\n', '\n', '    function redeemUnderlying(uint) external returns (uint);\n', '}\n', '\n', 'interface CEth {\n', '    function mint() external payable;\n', '\n', '    function redeem(uint) external returns (uint);\n', '\n', '    function redeemUnderlying(uint) external returns (uint);\n', '}\n', '\n', 'contract OwnbitMultiSig {\n', '    \n', '    uint constant public MAX_OWNER_COUNT = 9;\n', '\n', '  // The N addresses which control the funds in this contract.  The\n', '  // owners of M of these addresses will need to both sign a message\n', '  // allowing the funds in this contract to be spent.\n', '  mapping(address => bool) private isOwner;\n', '  address[] private owners;\n', '  uint private required;\n', '\n', '  // The contract nonce is not accessible to the contract so we\n', '  // implement a nonce-like variable for replay protection.\n', '  uint256 private spendNonce = 0;\n', '  \n', '  // An event sent when funds are received.\n', '  event Funded(uint new_balance);\n', '  \n', '  // An event sent when a spend is triggered to the given address.\n', '  event Spent(address to, uint transfer);\n', '  \n', '  // An event sent when a spend is triggered to the given address.\n', '  event SpentErc20(address erc20contract, address to, uint transfer);\n', '\n', '  modifier validRequirement(uint ownerCount, uint _required) {\n', '        require (ownerCount <= MAX_OWNER_COUNT\n', '            && _required <= ownerCount\n', '            && _required > 0);\n', '        _;\n', '    }\n', '  \n', '    /// @dev Contract constructor sets initial owners and required number of confirmations.\n', '    /// @param _owners List of initial owners.\n', '    /// @param _required Number of required confirmations.\n', '    constructor(address[] _owners, uint _required) public validRequirement(_owners.length, _required) {\n', '        for (uint i = 0; i < _owners.length; i++) {\n', '            //onwer should be distinct, and non-zero\n', '            if (isOwner[_owners[i]] || _owners[i] == 0) {\n', '                revert();\n', '            }\n', '            isOwner[_owners[i]] = true;\n', '        }\n', '        owners = _owners;\n', '        required = _required;\n', '    }\n', '\n', '\n', '    // The fallback function for this contract.\n', '    function() public payable {\n', '        emit Funded(address(this).balance);\n', '    }\n', '  \n', '    /// @dev Returns list of owners.\n', '    /// @return List of owner addresses.\n', '    function getOwners() public constant returns (address[]) {\n', '        return owners;\n', '    }\n', '    \n', '    function getSpendNonce() public constant returns (uint256) {\n', '        return spendNonce;\n', '    }\n', '    \n', '    function getRequired() public constant returns (uint) {\n', '        return required;\n', '    }\n', '\n', '  // Generates the message to sign given the output destination address and amount.\n', "  // includes this contract's address and a nonce for replay protection.\n", '  // One option to independently verify: https://leventozturk.com/engineering/sha3/ and select keccak\n', '  function generateMessageToSign(address erc20Contract, address destination, uint256 value) public constant returns (bytes32) {\n', '    require(destination != address(this));\n', '    //the sequence should match generateMultiSigV2 in JS\n', '    bytes32 message = keccak256(this, erc20Contract, destination, value, spendNonce);\n', '    return message;\n', '  }\n', '  \n', '  function _messageToRecover(address erc20Contract, address destination, uint256 value) private constant returns (bytes32) {\n', '    bytes32 hashedUnsignedMessage = generateMessageToSign(erc20Contract, destination, value);\n', '    bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '    return keccak256(prefix,hashedUnsignedMessage);\n', '  }\n', '  \n', '  function spend(address destination, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) public {\n', '    // This require is handled by generateMessageToSign()\n', '    // require(destination != address(this));\n', '    require(address(this).balance >= value);\n', '    require(_validSignature(0x0000000000000000000000000000000000000000, destination, value, vs, rs, ss));\n', '    spendNonce = spendNonce + 1;\n', '    //transfer will throw if fails\n', '    destination.transfer(value);\n', '    emit Spent(destination, value);\n', '  }\n', '  \n', '  // @erc20contract: the erc20 contract address.\n', '  // @destination: the token or ether receiver address.\n', '  // @value: the token or ether value, in wei or token minimum unit.\n', '  // @vs, rs, ss: the signatures\n', '  function spendERC20(address destination, address erc20contract, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) public {\n', '    // This require is handled by generateMessageToSign()\n', '    // require(destination != address(this));\n', '    //transfer erc20 token\n', '    //require(ERC20Interface(erc20contract).balanceOf(address(this)) >= value);\n', '    require(_validSignature(erc20contract, destination, value, vs, rs, ss));\n', '    spendNonce = spendNonce + 1;\n', '    // transfer tokens from this contract to the destination address\n', '    Erc20(erc20contract).transfer(destination, value);\n', '    emit SpentErc20(erc20contract, destination, value);\n', '  }\n', '\n', '\n', '    //cErc20Contract is just like the destination\n', '    function compoundAction(address cErc20Contract, address erc20contract, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) public {\n', '        CEth ethToken;\n', '        CErc20 erc20Token;\n', '        \n', '        if (erc20contract == 0x0000000000000000000000000000000000000001) {\n', '            require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss));\n', '            spendNonce = spendNonce + 1;\n', '            \n', '            //supply ETH\n', '            ethToken = CEth(cErc20Contract);\n', '            ethToken.mint.value(value).gas(250000)();\n', '        } else if (erc20contract == 0x0000000000000000000000000000000000000003) {\n', '            require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss));\n', '            spendNonce = spendNonce + 1;\n', '            \n', '            //redeem ETH\n', '            ethToken = CEth(cErc20Contract);\n', '            ethToken.redeem(value);\n', '        } else if (erc20contract == 0x0000000000000000000000000000000000000004) {\n', '            require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss));\n', '            spendNonce = spendNonce + 1;\n', '            \n', '            //redeem token\n', '            erc20Token = CErc20(cErc20Contract);\n', '            erc20Token.redeem(value);\n', '        } else if (erc20contract == 0x0000000000000000000000000000000000000005) {\n', '            require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss));\n', '            spendNonce = spendNonce + 1;\n', '            \n', '            //redeemUnderlying ETH\n', '            ethToken = CEth(cErc20Contract);\n', '            ethToken.redeemUnderlying(value);\n', '        } else if (erc20contract == 0x0000000000000000000000000000000000000006) {\n', '            require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss));\n', '            spendNonce = spendNonce + 1;\n', '            \n', '            //redeemUnderlying token\n', '            erc20Token = CErc20(cErc20Contract);\n', '            erc20Token.redeemUnderlying(value);\n', '        } else {\n', '            //Do not conflict with spendERC20\n', '            require(_validSignature(0x0000000000000000000000000000000000000002, cErc20Contract, value, vs, rs, ss));\n', '            spendNonce = spendNonce + 1;\n', '            \n', '            //supply token\n', '            // Create a reference to the underlying asset contract, like DAI.\n', '            Erc20 underlying = Erc20(erc20contract);\n', '            // Create a reference to the corresponding cToken contract, like cDAI\n', '            erc20Token = CErc20(cErc20Contract);\n', '            // Approve transfer on the ERC20 contract\n', '            underlying.approve(cErc20Contract, value);\n', '            // Mint cTokens\n', '            erc20Token.mint(value);\n', '        } \n', '    }\n', '    \n', '\n', '  // Confirm that the signature triplets (v1, r1, s1) (v2, r2, s2) ...\n', "  // authorize a spend of this contract's funds to the given\n", '  // destination address.\n', '  function _validSignature(address erc20Contract, address destination, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) private constant returns (bool) {\n', '    require(vs.length == rs.length);\n', '    require(rs.length == ss.length);\n', '    require(vs.length <= owners.length);\n', '    require(vs.length >= required);\n', '    bytes32 message = _messageToRecover(erc20Contract, destination, value);\n', '    address[] memory addrs = new address[](vs.length);\n', '    for (uint i = 0; i < vs.length; i++) {\n', '        //recover the address associated with the public key from elliptic curve signature or return zero on error \n', '        addrs[i] = ecrecover(message, vs[i]+27, rs[i], ss[i]);\n', '    }\n', '    require(_distinctOwners(addrs));\n', '    return true;\n', '  }\n', '  \n', '  // Confirm the addresses as distinct owners of this contract.\n', '  function _distinctOwners(address[] addrs) private constant returns (bool) {\n', '    if (addrs.length > owners.length) {\n', '        return false;\n', '    }\n', '    for (uint i = 0; i < addrs.length; i++) {\n', '        if (!isOwner[addrs[i]]) {\n', '            return false;\n', '        }\n', '        //address should be distinct\n', '        for (uint j = 0; j < i; j++) {\n', '            if (addrs[i] == addrs[j]) {\n', '                return false;\n', '            }\n', '        }\n', '    }\n', '    return true;\n', '  }\n', '}']