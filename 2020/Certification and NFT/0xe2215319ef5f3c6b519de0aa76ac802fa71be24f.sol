['// File: contracts\\modules\\Ownable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Managerable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'contract Managerable is Ownable {\n', '\n', '    address private _managerAddress;\n', '    /**\n', '     * @dev modifier, Only manager can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyManager() {\n', '        require(_managerAddress == msg.sender,"Managerable: caller is not the Manager");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev set manager by owner. \n', '     *\n', '     */\n', '    function setManager(address managerAddress)\n', '    public\n', '    onlyOwner\n', '    {\n', '        _managerAddress = managerAddress;\n', '    }\n', '    /**\n', '     * @dev get manager address. \n', '     *\n', '     */\n', '    function getManager()public view returns (address) {\n', '        return _managerAddress;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Halt.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', 'contract Halt is Ownable {\n', '    \n', '    bool private halted = false; \n', '    \n', '    modifier notHalted() {\n', '        require(!halted,"This contract is halted");\n', '        _;\n', '    }\n', '\n', '    modifier isHalted() {\n', '        require(halted,"This contract is not halted");\n', '        _;\n', '    }\n', '    \n', '    /// @notice function Emergency situation that requires \n', '    /// @notice contribution period to stop or not.\n', '    function setHalt(bool halt) \n', '        public \n', '        onlyOwner\n', '    {\n', '        halted = halt;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\whiteList.sol\n', '\n', 'pragma solidity =0.5.16;\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible uint32.\n', '     */\n', 'library whiteListUint32 {\n', '    /**\n', '     * @dev add uint32 into white list.\n', '     * @param whiteList the storage whiteList.\n', '     * @param temp input value\n', '     */\n', '\n', '    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\n', '        if (!isEligibleUint32(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    /**\n', '     * @dev remove uint32 from whitelist.\n', '     */\n', '    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible uint256.\n', '     */\n', 'library whiteListUint256 {\n', '    // add whiteList\n', '    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\n', '        if (!isEligibleUint256(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible address.\n', '     */\n', 'library whiteListAddress {\n', '    // add whiteList\n', '    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\n', '        if (!isEligibleAddress(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\AddressWhiteList.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '    /**\n', '     * @dev Implementation of a whitelist filters a eligible address.\n', '     */\n', 'contract AddressWhiteList is Halt {\n', '\n', '    using whiteListAddress for address[];\n', '    uint256 constant internal allPermission = 0xffffffff;\n', '    uint256 constant internal allowBuyOptions = 1;\n', '    uint256 constant internal allowSellOptions = 1<<1;\n', '    uint256 constant internal allowExerciseOptions = 1<<2;\n', '    uint256 constant internal allowAddCollateral = 1<<3;\n', '    uint256 constant internal allowRedeemCollateral = 1<<4;\n', '    // The eligible adress list\n', '    address[] internal whiteList;\n', '    mapping(address => uint256) internal addressPermission;\n', '    /**\n', '     * @dev Implementation of add an eligible address into the whitelist.\n', '     * @param addAddress new eligible address.\n', '     */\n', '    function addWhiteList(address addAddress)public onlyOwner{\n', '        whiteList.addWhiteListAddress(addAddress);\n', '        addressPermission[addAddress] = allPermission;\n', '    }\n', '    function modifyPermission(address addAddress,uint256 permission)public onlyOwner{\n', '        addressPermission[addAddress] = permission;\n', '    }\n', '    /**\n', '     * @dev Implementation of revoke an invalid address from the whitelist.\n', '     * @param removeAddress revoked address.\n', '     */\n', '    function removeWhiteList(address removeAddress)public onlyOwner returns (bool){\n', '        addressPermission[removeAddress] = 0;\n', '        return whiteList.removeWhiteListAddress(removeAddress);\n', '    }\n', '    /**\n', '     * @dev Implementation of getting the eligible whitelist.\n', '     */\n', '    function getWhiteList()public view returns (address[] memory){\n', '        return whiteList;\n', '    }\n', '    /**\n', '     * @dev Implementation of testing whether the input address is eligible.\n', '     * @param tmpAddress input address for testing.\n', '     */    \n', '    function isEligibleAddress(address tmpAddress) public view returns (bool){\n', '        return whiteList.isEligibleAddress(tmpAddress);\n', '    }\n', '    function checkAddressPermission(address tmpAddress,uint256 state) public view returns (bool){\n', '        return  (addressPermission[tmpAddress]&state) == state;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\ReentrancyGuard.sol\n', '\n', 'pragma solidity =0.5.16;\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancyLock = false;\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancyLock);\n', '    reentrancyLock = true;\n', '    _;\n', '    reentrancyLock = false;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts\\FNXMinePool\\MinePoolData.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '/**\n', ' * @title FPTCoin mine pool, which manager contract is FPTCoin.\n', ' * @dev A smart-contract which distribute some mine coins by FPTCoin balance.\n', ' *\n', ' */\n', 'contract MinePoolData is Managerable,AddressWhiteList,ReentrancyGuard {\n', '    //Special decimals for calculation\n', '    uint256 constant calDecimals = 1e18;\n', "    // miner's balance\n", '    // map mineCoin => user => balance\n', '    mapping(address=>mapping(address=>uint256)) internal minerBalances;\n', "    // miner's origins, specially used for mine distribution\n", '    // map mineCoin => user => balance\n', '    mapping(address=>mapping(address=>uint256)) internal minerOrigins;\n', '    \n', '    // mine coins total worth, specially used for mine distribution\n', '    mapping(address=>uint256) internal totalMinedWorth;\n', '    // total distributed mine coin amount\n', '    mapping(address=>uint256) internal totalMinedCoin;\n', '    // latest time to settlement\n', '    mapping(address=>uint256) internal latestSettleTime;\n', '    //distributed mine amount\n', '    mapping(address=>uint256) internal mineAmount;\n', '    //distributed time interval\n', '    mapping(address=>uint256) internal mineInterval;\n', '    //distributed mine coin amount for buy options user.\n', '    mapping(address=>uint256) internal buyingMineMap;\n', "    // user's Opterator indicator \n", '    uint256 constant internal opBurnCoin = 1;\n', '    uint256 constant internal opMintCoin = 2;\n', '    uint256 constant internal opTransferCoin = 3;\n', '    /**\n', '     * @dev Emitted when `account` mint `amount` miner shares.\n', '     */\n', '    event MintMiner(address indexed account,uint256 amount);\n', '    /**\n', '     * @dev Emitted when `account` burn `amount` miner shares.\n', '     */\n', '    event BurnMiner(address indexed account,uint256 amount);\n', '    /**\n', '     * @dev Emitted when `from` redeem `value` mineCoins.\n', '     */\n', '    event RedeemMineCoin(address indexed from, address indexed mineCoin, uint256 value);\n', '    /**\n', '     * @dev Emitted when `from` transfer to `to` `amount` mineCoins.\n', '     */\n', '    event TranserMiner(address indexed from, address indexed to, uint256 amount);\n', '    /**\n', '     * @dev Emitted when `account` buying options get `amount` mineCoins.\n', '     */\n', '    event BuyingMiner(address indexed account,address indexed mineCoin,uint256 amount);\n', '}\n', '\n', '// File: contracts\\Proxy\\baseProxy.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @title  baseProxy Contract\n', '\n', ' */\n', 'contract baseProxy is Ownable {\n', '    address public implementation;\n', '    constructor(address implementation_) public {\n', '        // Creator of the contract is admin during initialization\n', '        implementation = implementation_; \n', '        (bool success,) = implementation_.delegatecall(abi.encodeWithSignature("initialize()"));\n', '        require(success);\n', '    }\n', '    function getImplementation()public view returns(address){\n', '        return implementation;\n', '    }\n', '    function setImplementation(address implementation_)public onlyOwner{\n', '        implementation = implementation_; \n', '        (bool success,) = implementation_.delegatecall(abi.encodeWithSignature("update()"));\n', '        require(success);\n', '    }\n', '\n', '    /**\n', '     * @notice Delegates execution to the implementation contract\n', '     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n', '     * @param data The raw data to delegatecall\n', '     * @return The returned bytes from the delegatecall\n', '     */\n', '    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n', '        (bool success, bytes memory returnData) = implementation.delegatecall(data);\n', '        assembly {\n', '            if eq(success, 0) {\n', '                revert(add(returnData, 0x20), returndatasize)\n', '            }\n', '        }\n', '        return returnData;\n', '    }\n', '\n', '    /**\n', '     * @notice Delegates execution to an implementation contract\n', '     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n', '     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n', '     * @param data The raw data to delegatecall\n', '     * @return The returned bytes from the delegatecall\n', '     */\n', '    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n', '        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature("delegateToImplementation(bytes)", data));\n', '        assembly {\n', '            if eq(success, 0) {\n', '                revert(add(returnData, 0x20), returndatasize)\n', '            }\n', '        }\n', '        return abi.decode(returnData, (bytes));\n', '    }\n', '\n', '    function delegateToViewAndReturn() internal view returns (bytes memory) {\n', '        (bool success, ) = address(this).staticcall(abi.encodeWithSignature("delegateToImplementation(bytes)", msg.data));\n', '\n', '        assembly {\n', '            let free_mem_ptr := mload(0x40)\n', '            returndatacopy(free_mem_ptr, 0, returndatasize)\n', '\n', '            switch success\n', '            case 0 { revert(free_mem_ptr, returndatasize) }\n', '            default { return(add(free_mem_ptr, 0x40), returndatasize) }\n', '        }\n', '    }\n', '\n', '    function delegateAndReturn() internal returns (bytes memory) {\n', '        (bool success, ) = implementation.delegatecall(msg.data);\n', '\n', '        assembly {\n', '            let free_mem_ptr := mload(0x40)\n', '            returndatacopy(free_mem_ptr, 0, returndatasize)\n', '\n', '            switch success\n', '            case 0 { revert(free_mem_ptr, returndatasize) }\n', '            default { return(free_mem_ptr, returndatasize) }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\FNXMinePool\\MinePoolProxy.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '/**\n', ' * @title FPTCoin mine pool, which manager contract is FPTCoin.\n', ' * @dev A smart-contract which distribute some mine coins by FPTCoin balance.\n', ' *\n', ' */\n', 'contract MinePoolProxy is MinePoolData,baseProxy {\n', '    constructor (address implementation_) baseProxy(implementation_) public{\n', '    }\n', '    /**\n', '     * @dev default function for foundation input miner coins.\n', '     */\n', '    function()external payable{\n', '    }\n', '    /**\n', '     * @dev foundation redeem out mine coins.\n', '     *  mineCoin mineCoin address\n', '     *  amount redeem amount.\n', '     */\n', '    function redeemOut(address /*mineCoin*/,uint256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev retrieve total distributed mine coins.\n', '     *  mineCoin mineCoin address\n', '     */\n', '    function getTotalMined(address /*mineCoin*/)public view returns(uint256){\n', '        delegateToViewAndReturn();\n', '    }\n', '    /**\n', '     * @dev retrieve minecoin distributed informations.\n', '     *  mineCoin mineCoin address\n', '     * @return distributed amount and distributed time interval.\n', '     */\n', '    function getMineInfo(address /*mineCoin*/)public view returns(uint256,uint256){\n', '        delegateToViewAndReturn();\n', '    }\n', '    /**\n', "     * @dev retrieve user's mine balance.\n", "     *  account user's account\n", '     *  mineCoin mineCoin address\n', '     */\n', '    function getMinerBalance(address /*account*/,address /*mineCoin*/)public view returns(uint256){\n', '        delegateToViewAndReturn();\n', '    }\n', '    /**\n', '     * @dev Set mineCoin mine info, only foundation owner can invoked.\n', '     *  mineCoin mineCoin address\n', '     *  _mineAmount mineCoin distributed amount\n', '     *  _mineInterval mineCoin distributied time interval\n', '     */\n', '    function setMineCoinInfo(address /*mineCoin*/,uint256 /*_mineAmount*/,uint256 /*_mineInterval*/)public {\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev Set the reward for buying options.\n', '     *  mineCoin mineCoin address\n', '     *  _mineAmount mineCoin reward amount\n', '     */\n', '    function setBuyingMineInfo(address /*mineCoin*/,uint256 /*_mineAmount*/)public {\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev Get the reward for buying options.\n', '     *  mineCoin mineCoin address\n', '     */\n', '    function getBuyingMineInfo(address /*mineCoin*/)public view returns(uint256){\n', '        delegateToViewAndReturn();\n', '    }\n', '    /**\n', '     * @dev Get the all rewards for buying options.\n', '     */\n', '    function getBuyingMineInfoAll()public view returns(address[] memory,uint256[] memory){\n', '        delegateToViewAndReturn();\n', '    }\n', '    /**\n', '     * @dev transfer mineCoin to recieptor when account transfer amount FPTCoin to recieptor, only manager contract can modify database.\n', '     *  account the account transfer from\n', '     *  recieptor the account transfer to\n', '     *  amount the mine shared amount\n', '     */\n', '    function transferMinerCoin(address /*account*/,address /*recieptor*/,uint256 /*amount*/) public {\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev mint mineCoin to account when account add collateral to collateral pool, only manager contract can modify database.\n', "     *  account user's account\n", '     *  amount the mine shared amount\n', '     */\n', '    function mintMinerCoin(address /*account*/,uint256 /*amount*/) public {\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev Burn mineCoin to account when account redeem collateral to collateral pool, only manager contract can modify database.\n', "     *  account user's account\n", '     *  amount the mine shared amount\n', '     */\n', '    function burnMinerCoin(address /*account*/,uint256 /*amount*/) public {\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev give amount buying reward to account, only manager contract can modify database.\n', "     *  account user's account\n", '     *  amount the buying shared amount\n', '     */\n', '    function addMinerBalance(address /*account*/,uint256 /*amount*/) public {\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev changer mine coin distributed amount , only foundation owner can modify database.\n', '     *  mineCoin mine coin address\n', '     *  _mineAmount the distributed amount.\n', '     */\n', '    function setMineAmount(address /*mineCoin*/,uint256 /*_mineAmount*/)public {\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev changer mine coin distributed time interval , only foundation owner can modify database.\n', '     *  mineCoin mine coin address\n', '     *  _mineInterval the distributed time interval.\n', '     */\n', '    function setMineInterval(address /*mineCoin*/,uint256 /*_mineInterval*/)public {\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev user redeem mine rewards.\n', '     *  mineCoin mine coin address\n', '     *  amount redeem amount.\n', '     */\n', '    function redeemMinerCoin(address /*mineCoin*/,uint256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '}']