['pragma solidity ^0.6.9;\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'abstract contract CalculatorInterface {\n', '    function calculateNumTokens(uint256 balance, uint256 daysStaked, address stakerAddress, uint256 totalSupply) public virtual returns (uint256);\n', '    function randomness() public view virtual returns (uint256);\n', '}\n', '\n', 'abstract contract DepoToken {\n', '    function balanceOf(address account) public view virtual returns (uint256);\n', '    function _burn(address account, uint256 amount) external virtual;\n', '}\n', '\n', '\n', '\n', '/**\n', '*/\n', 'contract StakeDepoToken is Ownable {\n', '    using SafeMath for uint256;\n', '    \n', '    struct staker {\n', '        uint startTimestamp;\n', '        uint lastTimestamp;\n', '    }\n', '    \n', '    struct update {\n', '        uint timestamp;\n', '        uint numerator;\n', '        uint denominator;\n', '        uint price;         // In USD. 0001 is $0.001, 1000 is $1.000, 1001 is $1.001, etc\n', '        uint volume;        // In whole USD (100 = $100)\n', '    }\n', '    \n', '    struct seller {\n', '        address addr;\n', '        uint256 burnAmount;\n', '    }\n', '    \n', '    DepoToken public token;\n', '    \n', '    modifier onlyToken() {\n', '        require(_msgSender() == address(token), "Caller must be DEPO token contract.");\n', '        _;\n', '    }\n', '\n', '    \n', '    mapping (address => staker) public _stakers;\n', '    \n', '    mapping (address => string) public _whitelist;\n', '    \n', '    mapping (address => uint256) public _blacklist;\n', '    \n', '    bool private _enableDelayedSellBurns;\n', '    \n', '    bool private _enableBurns;\n', '    \n', '    bool private _priceTarget1Hit;\n', '    \n', '    bool private _priceTarget2Hit;\n', '    \n', '    address private _uniswapV2Pair;\n', '    \n', '    address private _uniswapV1Pair;\n', '    \n', '    seller[] private _delayedBurns;\n', '    \n', '    uint8 private _uniswapSellerBurnPercent;\n', '\n', '    \n', '    uint256 private _minStake;\n', '    \n', '    uint8 private _minStakeDurationDays;\n', '    \n', '    uint8 private _minPercentIncrease;\n', '    \n', '    uint256 private _inflationAdjustmentFactor;\n', '    \n', '    uint256 private _streak;\n', '    \n', '    update public _lastUpdate;\n', '    \n', '    CalculatorInterface private _externalCalculator;\n', '    \n', '    bool private _useExternalCalc;\n', '    \n', '    bool private _freeze;\n', '    \n', '    bool private _enableHoldersDay;\n', '    \n', '    event StakerRemoved(address StakerAddress);\n', '    \n', '    event StakerAdded(address StakerAddress);\n', '    \n', '    event StakesUpdated(uint Amount);\n', '    \n', '    event MassiveCelebration();\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '    \n', '    constructor (DepoToken newToken) public {\n', '        token = newToken;\n', '        _minStake = 500E18;\n', '        _inflationAdjustmentFactor = 100;\n', '        _streak = 0;\n', '        _minStakeDurationDays = 1;\n', '        _useExternalCalc = false;\n', '        _uniswapSellerBurnPercent = 5;\n', '        _enableDelayedSellBurns = true;\n', '        _enableBurns = false;\n', '        _freeze = false;\n', '        _minPercentIncrease = 10; // 1.0% min increase\n', '    }\n', '    \n', '    \n', '    function updateState(uint numerator, uint denominator, uint256 price, uint256 volume) external onlyOwner {  // when chainlink is integrated a separate contract will call this function (onlyOwner state will be changed as well)\n', '    \n', '        require(numerator != 0 && denominator != 0 && price != 0 && volume != 0, "Parameters cannot be zero");\n', '        \n', '        if (numerator < 2 && denominator == 100 || numerator < 20 && denominator == 1000) {\n', '            require(mulDiv(1000, numerator, denominator) >= _minPercentIncrease, "Increase must be at least _minPercentIncrease to count");\n', '        }\n', '        \n', '        \n', '        \n', '        uint8 daysSinceLastUpdate = uint8((block.timestamp - _lastUpdate.timestamp) / 86400);\n', '        \n', '        if (daysSinceLastUpdate == 0) {\n', '            // should we error here?\n', '            _streak++;\n', '        } else if (daysSinceLastUpdate == 1) {\n', '            _streak++;\n', '        } else {\n', '            _streak = 1;\n', '        }\n', '        \n', '        if (price >= 1000 && _priceTarget1Hit == false) { // 1000 = $1.00\n', '            _priceTarget1Hit = true;\n', '            _streak = 50;\n', '            emit MassiveCelebration();\n', '            \n', '        } else if (price >= 10000 && _priceTarget2Hit == false) {   // It is written, so it shall be done\n', '            _priceTarget2Hit = true;\n', '            _streak = 100;\n', '             _minStake = 100;        // Need $1000 to stake\n', '            emit MassiveCelebration();\n', '        }\n', '        \n', '        _lastUpdate = update(block.timestamp, numerator, denominator, price, volume);\n', '\n', '    }\n', '    \n', '    function updateMyStakes(address stakerAddress, uint256 balance, uint256 totalSupply) external onlyToken returns (uint256) {\n', '        \n', '        require((block.timestamp.sub(_lastUpdate.timestamp)) / 86400 == 0, "Stakes must be updated the same day of the latest update");\n', '        \n', '    \n', '        staker memory thisStaker = _stakers[stakerAddress];\n', '        \n', '        require(block.timestamp > thisStaker.lastTimestamp, "Error: block timestamp is not greater than your last timestamp!");\n', '        //require((block.timestamp.sub(thisStaker.lastTimestamp)) / 86400 != 0, "Error: you can only update stakes once per day. You also cannot update stakes on the same day that you purchased them.");\n', '        require(_lastUpdate.timestamp > thisStaker.lastTimestamp, "Error: you can only update stakes once per day. You also cannot update stakes on the same day that you purchased them.");\n', '        require(thisStaker.lastTimestamp != 0, "Error: your last timestamp cannot be zero.");\n', '        require(thisStaker.startTimestamp != 0, "Error: your start timestamp cannot be zero.");\n', '        \n', '        uint daysStaked = block.timestamp.sub(thisStaker.startTimestamp) / 86400;\n', '        \n', '        require(daysStaked >= _minStakeDurationDays, "You must stake for at least minStakeDurationDays to claim rewards");\n', '        require(balance >= _minStake, "You must have a balance of at least minStake to claim rewards");\n', '        require(thisStaker.startTimestamp > 0, "Your start timestamp must be greater than 0");\n', '\n', '            \n', '        uint numTokens = calculateNumTokens(balance, daysStaked, stakerAddress, totalSupply);\n', '        if (_enableHoldersDay && daysStaked >= 30) {\n', '            numTokens = mulDiv(balance, daysStaked, 600);   // Once a month, holders get a nice bump\n', '        }\n', '        \n', '        _stakers[stakerAddress].lastTimestamp = block.timestamp;\n', '        emit StakesUpdated(numTokens);\n', '        \n', '        return numTokens;\n', '    \n', '        \n', '    }\n', '    // need to limit days staked multiplier and max percentage daily gain\n', '    function calculateNumTokens(uint256 balance, uint256 daysStaked, address stakerAddress, uint256 totalSupply) internal returns (uint256) {\n', '        \n', '        if (_useExternalCalc) {\n', '            return _externalCalculator.calculateNumTokens(balance, daysStaked, stakerAddress, totalSupply);\n', '        }\n', '        \n', '        uint256 inflationAdjustmentFactor = _inflationAdjustmentFactor;\n', '        \n', '        if (_streak > 1) {\n', '            inflationAdjustmentFactor /= _streak;\n', '        }\n', '        \n', '        if (daysStaked > 60) {\n', '            daysStaked = 60;\n', '        } \n', '        \n', '        uint marketCap = totalSupply.mul(_lastUpdate.price);\n', '        \n', '        uint ratio = marketCap.div(_lastUpdate.volume);\n', '        \n', '        if (ratio > 50) {  // Too little volume. Decrease rewards.\n', '            inflationAdjustmentFactor = inflationAdjustmentFactor.mul(10);\n', "        } else if (ratio > 25) { // Still not enough. Streak doesn't count.\n", '            inflationAdjustmentFactor = _inflationAdjustmentFactor;\n', '        }\n', '        \n', '        uint numTokens = mulDiv(balance, _lastUpdate.numerator * daysStaked, _lastUpdate.denominator * inflationAdjustmentFactor);\n', '        uint tenPercent = mulDiv(balance, 1, 10);\n', '        \n', '        if (numTokens > tenPercent) {\n', '            numTokens = tenPercent;\n', '        }\n', '        \n', '        return numTokens;\n', '    }\n', '    \n', '    function updateTokenAddress(DepoToken newToken) external onlyOwner {\n', '        token = newToken;\n', '    }\n', '    \n', '    function updateCalculator(CalculatorInterface calc) external {\n', '       _externalCalculator = calc;\n', '       _useExternalCalc = true;\n', '    }\n', '    \n', '    \n', '    function updateInflationAdjustmentFactor(uint256 inflationAdjustmentFactor) external onlyOwner {\n', '        _inflationAdjustmentFactor = inflationAdjustmentFactor;\n', '    }\n', '    \n', '    function updateStreak(uint streak) external onlyOwner {\n', '        _streak = streak;\n', '    }\n', '    \n', '    function updateMinStakeDurationDays(uint8 minStakeDurationDays) external onlyOwner {\n', '        _minStakeDurationDays = minStakeDurationDays;\n', '    }\n', '    \n', '    function updateMinStakes(uint minStake) external onlyOwner {\n', '        _minStake = minStake;\n', '    }\n', '    function updateMinPercentIncrease(uint8 minIncrease) external onlyOwner {\n', '        _minPercentIncrease = minIncrease;\n', '    }\n', '    \n', '    function enableBurns(bool enabledBurns) external onlyOwner {\n', '        _enableBurns = enabledBurns;\n', '    }\n', '    function updateHoldersDay(bool enableHoldersDay)   external onlyOwner {\n', '        _enableHoldersDay = enableHoldersDay;\n', '    }\n', '    \n', '    function updateWhitelist(address addr, string calldata reason, bool remove) external onlyOwner returns (bool) {\n', '        if (remove) {\n', '            delete _whitelist[addr];\n', '            return true;\n', '        } else {\n', '            _whitelist[addr] = reason;\n', '            return true;\n', '        }\n', '        return false;        \n', '    }\n', '    \n', '    function updateBlacklist(address addr, uint256 fee, bool remove) external onlyOwner returns (bool) {\n', '        if (remove) {\n', '            delete _blacklist[addr];\n', '            return true;\n', '        } else {\n', '            _blacklist[addr] = fee;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    function updateUniswapPair(address addr, bool V1) external onlyOwner returns (bool) {\n', '        if (V1) {\n', '            _uniswapV1Pair = addr;\n', '            return true;\n', '        } else {\n', '            _uniswapV2Pair = addr;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    function updateDelayedSellBurns(bool enableDelayedSellBurns) external onlyOwner {\n', '        _enableDelayedSellBurns = enableDelayedSellBurns;\n', '    }\n', '    \n', '    function updateUniswapSellerBurnPercent(uint8 sellerBurnPercent) external onlyOwner {\n', '        _uniswapSellerBurnPercent = sellerBurnPercent;\n', '    }\n', '    \n', '    function freeze(bool enableFreeze) external onlyOwner {\n', '        _freeze = enableFreeze;\n', '    }\n', '    \n', '\n', '    function mulDiv (uint x, uint y, uint z) public pure returns (uint) {\n', '          (uint l, uint h) = fullMul (x, y);\n', '          require (h < z);\n', '          uint mm = mulmod (x, y, z);\n', '          if (mm > l) h -= 1;\n', '          l -= mm;\n', '          uint pow2 = z & -z;\n', '          z /= pow2;\n', '          l /= pow2;\n', '          l += h * ((-pow2) / pow2 + 1);\n', '          uint r = 1;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          r *= 2 - z * r;\n', '          return l * r;\n', '    }\n', '    \n', '    function fullMul (uint x, uint y) private pure returns (uint l, uint h) {\n', '          uint mm = mulmod (x, y, uint (-1));\n', '          l = x * y;\n', '          h = mm - l;\n', '          if (mm < l) h -= 1;\n', '    }\n', '    \n', '    function streak() public view returns (uint) {\n', '        return _streak;\n', '    }\n', '\n', '\n', '    // Hooks the transfer() function on DepoToken\n', '    function transferHook(address sender, address recipient, uint256 amount, uint256 senderBalance, uint256 recipientBalance) external onlyToken returns (uint256, uint256, uint256) {\n', '        \n', '        require(_freeze == false, "Contract is frozen.");\n', '        \n', '        uint totalAmount = amount;\n', '        bool shouldAddStaker = true;\n', '        bool addedToDelayedBurns = false;\n', '        uint burnedAmount = 0;\n', '        \n', '        if (_enableBurns && bytes(_whitelist[sender]).length == 0 && bytes(_whitelist[recipient]).length == 0 && bytes(_whitelist[_msgSender()]).length == 0) {\n', '                \n', '            burnedAmount = mulDiv(amount, _randomness(), 100);\n', '            \n', '            \n', '            if (_blacklist[recipient] != 0) {   //Transferring to a blacklisted address incurs a specific fee\n', '                burnedAmount = mulDiv(amount, _blacklist[recipient], 100);\n', '                shouldAddStaker = false;\n', '            }\n', '            \n', '            \n', '            \n', '            if (burnedAmount > 0) {\n', '                if (burnedAmount > amount) {\n', '                    totalAmount = 0;\n', '                } else {\n', '                    totalAmount = amount.sub(burnedAmount);\n', '                }\n', '                senderBalance = senderBalance.sub(burnedAmount, "ERC20: burn amount amount exceeds balance");\n', '            }\n', '        } else if (recipient == _uniswapV2Pair || recipient == _uniswapV1Pair) {    // Uniswap was used\n', '            shouldAddStaker = false;\n', '            if (_enableDelayedSellBurns && bytes(_whitelist[sender]).length == 0) { // delayed burns enabled and sender is not whitelisted\n', '                uint delayedBurnAmount = mulDiv(amount, _uniswapSellerBurnPercent, 100);     // Seller fee\n', '                seller memory _seller;\n', '                _seller.addr = sender;\n', '                _seller.burnAmount = delayedBurnAmount;\n', '                _delayedBurns.push(_seller);\n', '                addedToDelayedBurns = true;\n', '            }\n', '        \n', '        }\n', '        \n', '        if (bytes(_whitelist[recipient]).length != 0) {\n', '            shouldAddStaker = false;\n', '        }\n', '        \n', '        \n', '        if (shouldAddStaker && _stakers[recipient].startTimestamp != 0 && recipientBalance != 0) {  // If you are currently staking, these should all be true\n', '            uint percent = mulDiv(1000000, totalAmount, recipientBalance);\n', '            require(percent > 0, "The amount you are transferring is too low as a percentage of the total balance.");\n', '            if(percent.add(_stakers[recipient].startTimestamp) > block.timestamp) {         \n', '                _stakers[recipient].startTimestamp = block.timestamp;\n', '            } else {\n', '                _stakers[recipient].startTimestamp = _stakers[recipient].startTimestamp.add(percent);               // Receiving too many tokens resets your holding time\n', '            }\n', '            if(percent.add(_stakers[recipient].lastTimestamp) > block.timestamp) {\n', '                _stakers[recipient].lastTimestamp = block.timestamp;\n', '            } else {\n', '                _stakers[recipient].lastTimestamp = _stakers[recipient].lastTimestamp.add(percent);                 // Receiving too many tokens may make you ineligible to claim the next day\n', '            }\n', '        }\n', '        \n', '\n', '        senderBalance = senderBalance.sub(totalAmount, "ERC20: transfer amount exceeds balance");\n', '        recipientBalance = recipientBalance.add(totalAmount);\n', '        \n', '        if (shouldAddStaker && _stakers[recipient].startTimestamp == 0 && (totalAmount >= _minStake || recipientBalance >= _minStake)) {\n', '            _stakers[recipient] = staker(block.timestamp, block.timestamp);\n', '            emit StakerAdded(recipient);\n', '        }\n', '        \n', '        if (senderBalance < _minStake) {\n', '            // Remove staker\n', '            delete _stakers[sender];\n', '            emit StakerRemoved(sender);\n', '        } else {\n', '            _stakers[sender].startTimestamp = block.timestamp;\n', '            if (_stakers[sender].lastTimestamp == 0) {\n', '                _stakers[sender].lastTimestamp = block.timestamp;\n', '            }\n', '        }\n', '        \n', '        if (_enableDelayedSellBurns && _delayedBurns.length > 0 && !addedToDelayedBurns) {\n', '            \n', '             seller memory _seller = _delayedBurns[_delayedBurns.length - 1];\n', '             _delayedBurns.pop();\n', '             \n', '             uint balance = token.balanceOf(_seller.addr);\n', '             \n', '             if(balance >= _seller.burnAmount) {\n', '                 \n', '                 balance = balance.sub(_seller.burnAmount);\n', '                 token._burn(_seller.addr, _seller.burnAmount);\n', '                 \n', '                 if (_stakers[_seller.addr].startTimestamp != 0 && balance < _minStake) {\n', '                     // Remove staker\n', '                    delete _stakers[_seller.addr];\n', '                    emit StakerRemoved(_seller.addr);\n', '                 }\n', '             } else if (balance != 0) {\n', '                token._burn(_seller.addr, balance);\n', '                delete _stakers[_seller.addr];\n', '             }\n', '        }\n', '        \n', '        return (senderBalance, recipientBalance, burnedAmount);\n', '    }\n', '    \n', '    \n', '    function _randomness() internal view returns (uint256) {\n', '        if(_useExternalCalc) {\n', '            return _externalCalculator.randomness();\n', '        }\n', '        return 1 + uint256(keccak256(abi.encodePacked(blockhash(block.number-1), _msgSender())))%4;\n', '    }\n', '\n', '\n', '\n', '}']