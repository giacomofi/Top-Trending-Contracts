['pragma solidity 0.6.12; // optimization runs: 200, evm version: istanbul\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'interface DharmaTradeBotV1Interface {\n', '  event LimitOrderProcessed(\n', '    address indexed account,\n', '    address indexed suppliedAsset, // Ether = address(0)\n', '    address indexed receivedAsset, // Ether = address(0)\n', '    uint256 suppliedAmount,\n', '    uint256 receivedAmount,\n', '    bytes32 orderID\n', '  );\n', '\n', '  event LimitOrderCancelled(bytes32 orderID);\n', '  event RoleModified(Role indexed role, address account);\n', '  event RolePaused(Role indexed role);\n', '  event RoleUnpaused(Role indexed role);\n', '\n', '  enum Role {\n', '    BOT_COMMANDER,\n', '    CANCELLER,\n', '    PAUSER\n', '  }\n', '\n', '  struct RoleStatus {\n', '    address account;\n', '    bool paused;\n', '  }\n', '\n', '  struct LimitOrderArguments {\n', '    address account;\n', '    address assetToSupply;        // Ether = address(0)\n', '    address assetToReceive;       // Ether = address(0)\n', '    uint256 maximumAmountToSupply;\n', '    uint256 maximumPriceToAccept; // represented as a mantissa (n * 10^18)\n', '    uint256 expiration;\n', '    bytes32 salt;\n', '  }\n', '\n', '  struct LimitOrderExecutionArguments {\n', '    uint256 amountToSupply; // will be lower than maximum for partial fills\n', '    bytes signatures;\n', '    address tradeTarget;\n', '    bytes tradeData;\n', '  }\n', '\n', '  function processLimitOrder(\n', '    LimitOrderArguments calldata args,\n', '    LimitOrderExecutionArguments calldata executionArgs\n', '  ) external returns (uint256 amountReceived);\n', '\n', '  function cancelLimitOrder(LimitOrderArguments calldata args) external;\n', '\n', '  function setRole(Role role, address account) external;\n', '\n', '  function removeRole(Role role) external;\n', '\n', '  function pause(Role role) external;\n', '\n', '  function unpause(Role role) external;\n', '\n', '  function isPaused(Role role) external view returns (bool paused);\n', '\n', '  function isRole(Role role) external view returns (bool hasRole);\n', '  \n', '  function getOrderID(\n', '    LimitOrderArguments calldata args\n', '  ) external view returns (bytes32 orderID, bool valid);\n', '\n', '  function getBotCommander() external view returns (address botCommander);\n', '  \n', '  function getCanceller() external view returns (address canceller);\n', '\n', '  function getPauser() external view returns (address pauser);\n', '}\n', '\n', '\n', 'interface SupportingContractInterface {\n', '  function setApproval(address token, uint256 amount) external;\n', '}\n', '\n', '\n', 'interface ERC1271Interface {\n', '  function isValidSignature(\n', '    bytes calldata data, bytes calldata signatures\n', '  ) external view returns (bytes4 magicValue);\n', '}\n', '\n', '\n', 'interface ERC20Interface {\n', '  function transfer(address, uint256) external returns (bool);\n', '  function transferFrom(address, address, uint256) external returns (bool);\n', '  function approve(address, uint256) external returns (bool);\n', '  function balanceOf(address) external view returns (uint256);\n', '  function allowance(address, address) external view returns (uint256);\n', '}\n', '\n', '\n', '\n', 'library SafeMath {\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a, "SafeMath: addition overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a, "SafeMath: subtraction overflow");\n', '\n', '    return a - b;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0, "SafeMath: division by zero");\n', '    return a / b;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @notice Contract module which provides a basic access control mechanism,\n', ' * where there is an account (an owner) that can be granted exclusive access\n', ' * to specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be aplied to your functions to restrict their use to\n', ' * the owner.\n', ' *\n', ' * In order to transfer ownership, a recipient must be specified, at which point\n', ' * the specified recipient can call `acceptOwnership` and take ownership.\n', ' */\n', 'contract TwoStepOwnable {\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  address private _owner;\n', '\n', '  address private _newPotentialOwner;\n', '\n', '  /**\n', '   * @notice Initialize contract with transaction submitter as initial owner.\n', '   */\n', '  constructor() internal {\n', '    _owner = tx.origin;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '  /**\n', '   * @notice Allows a new account (`newOwner`) to accept ownership.\n', '   * Can only be called by the current owner.\n', '   */\n', '  function transferOwnership(address newOwner) external onlyOwner {\n', '    require(\n', '      newOwner != address(0),\n', '      "TwoStepOwnable: new potential owner is the zero address."\n', '    );\n', '\n', '    _newPotentialOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @notice Cancel a transfer of ownership to a new account.\n', '   * Can only be called by the current owner.\n', '   */\n', '  function cancelOwnershipTransfer() external onlyOwner {\n', '    delete _newPotentialOwner;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfers ownership of the contract to the caller.\n', '   * Can only be called by a new potential owner set by the current owner.\n', '   */\n', '  function acceptOwnership() external {\n', '    require(\n', '      msg.sender == _newPotentialOwner,\n', '      "TwoStepOwnable: current owner must set caller as new potential owner."\n', '    );\n', '\n', '    delete _newPotentialOwner;\n', '\n', '    emit OwnershipTransferred(_owner, msg.sender);\n', '\n', '    _owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the address of the current owner.\n', '   */\n', '  function owner() external view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns true if the caller is the current owner.\n', '   */\n', '  function isOwner() public view returns (bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  /**\n', '   * @notice Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner(), "TwoStepOwnable: caller is not the owner.");\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title DharmaTradeBotV1\n', ' * @author 0age\n', ' * @notice DharmaTradeBot is a contract for performing meta-transaction-enabled\n', ' * limit orders against external automated money markets or other sources of\n', ' * on-chain liquidity. Eth-to-Token trades require that `triggerEtherTransfer`\n', ' * is implemented on the account making the trade, and all trades require\n', ' * that the account implements `isValidSignature` as specified by ERC-1271,\n', ' * as well as a `setApproval` function, in order to enable meta-transactions.\n', ' * For Eth-to-token trades, the Eth amount\n', ' */\n', 'contract DharmaTradeBotV1 is DharmaTradeBotV1Interface, TwoStepOwnable {\n', '  using SafeMath for uint256;\n', '\n', '  // Maintain a role status mapping with assigned accounts and paused states.\n', '  mapping(uint256 => RoleStatus) private _roles;\n', '\n', '  // Maintain a mapping of invalid meta-transaction order IDs.\n', '  mapping (bytes32 => bool) private _invalidMetaTxHashes;\n', '\n', '  ERC20Interface private constant _ETHERIZER = ERC20Interface(\n', '    0x723B51b72Ae89A3d0c2a2760f0458307a1Baa191\n', '  );\n', '\n', '  receive() external payable {}\n', '\n', '  /**\n', '   * @notice Only callable by the bot commander or the owner. Enforces the\n', '   * expiration (or skips if it is set to zero) and trade size, validates\n', '   * the execution signatures using ERC-1271 against the account, sets\n', '   * approval to transfer the supplied token on behalf of that account,\n', '   * pulls in the necessary supplied tokens, sets an allowance for the\n', '   * provided trade target, calls the trade target with supplied data,\n', '   * ensures that the call was successful, calculates the required amount\n', '   * that must be received back based on the supplied amount and price,\n', '   * ensures that at least that amount was returned, sends it to the\n', '   * account, and emits an event. Use the null address to signify that\n', '   * the supplied or retained asset is Ether.\n', '   * @return amountReceived The amount received back from the trade.\n', '   */\n', '  function processLimitOrder(\n', '    LimitOrderArguments calldata args,\n', '    LimitOrderExecutionArguments calldata executionArgs\n', '  ) external override onlyOwnerOr(Role.BOT_COMMANDER) returns (\n', '    uint256 amountReceived\n', '  ) {\n', '    _enforceExpiration(args.expiration);\n', '\n', '    require(\n', '      executionArgs.amountToSupply <= args.maximumAmountToSupply,\n', '      "Cannot supply more than the maximum authorized amount."\n', '    );\n', '    \n', '    require(\n', '      args.assetToSupply != args.assetToReceive,\n', '      "Asset to supply and asset to receive cannot be identical."\n', '    );\n', '\n', '    if (executionArgs.tradeData.length >= 4) {\n', '      require(\n', '        abi.decode(\n', '          abi.encodePacked(executionArgs.tradeData[:4], bytes28(0)), (bytes4)\n', '        ) != SupportingContractInterface.setApproval.selector,\n', '        "Trade data has a prohibited function selector."\n', '      );\n', '    }\n', '\n', '    // Construct order\'s "context" and use it to validate meta-transaction.\n', '    bytes memory context = _constructLimitOrderContext(args);\n', '    bytes32 orderID = _validateMetaTransaction(\n', '      args.account, context, executionArgs.signatures\n', '    );\n', '\n', '    // Determine asset supplied (use Etherizer for Ether) and ether value.\n', '    ERC20Interface assetToSupply;\n', '    uint256 etherValue;\n', '    \n', '    if (args.assetToSupply == address(0)) {\n', '      assetToSupply = _ETHERIZER;\n', '      etherValue = executionArgs.amountToSupply;\n', '    } else {\n', '      assetToSupply = ERC20Interface(args.assetToSupply);\n', '      etherValue = 0;\n', '\n', '      // Ensure that target has allowance to transfer tokens.\n', '      _grantApprovalIfNecessary(\n', '        assetToSupply, executionArgs.tradeTarget, executionArgs.amountToSupply\n', '      );\n', '    }\n', '\n', '    // Call `setApproval` on the supplying account.\n', '    SupportingContractInterface(args.account).setApproval(\n', '      address(assetToSupply), executionArgs.amountToSupply\n', '    );\n', '\n', '    // Make the transfer in.\n', '    _transferInToken(\n', '      assetToSupply, args.account, executionArgs.amountToSupply\n', '    );\n', '\n', '    // Call into target, supplying data and value, and revert on failure.\n', '    _performCallToTradeTarget(\n', '      executionArgs.tradeTarget, executionArgs.tradeData, etherValue\n', '    );\n', '\n', '    // Determine amount expected back using supplied amount and price.\n', '    uint256 amountExpected = (\n', '      executionArgs.amountToSupply.mul(1e18)\n', '    ).div(\n', '      args.maximumPriceToAccept\n', '    );\n', ' \n', '    if (args.assetToReceive == address(0)) {\n', '      // Determine ether balance held by this contract.\n', '      amountReceived = address(this).balance;  \n', '      \n', '      // Ensure that enough Ether was received.\n', '      require(\n', '        amountReceived >= amountExpected,\n', '        "Trade did not result in the expected amount of Ether."\n', '      );\n', '      \n', '      // Transfer the Ether out and revert on failure.\n', '      _transferEther(args.account, amountReceived);\n', '    } else {\n', '      ERC20Interface assetToReceive = ERC20Interface(args.assetToReceive);\n', '\n', '      // Determine balance of received tokens held by this contract.\n', '      amountReceived = assetToReceive.balanceOf(address(this));\n', '      \n', '      // Ensure that enough tokens were received.\n', '      require(\n', '        amountReceived >= amountExpected,\n', '        "Trade did not result in the expected amount of tokens."\n', '      );\n', '\n', '      // Transfer the tokens and revert on failure.\n', '      _transferOutToken(assetToReceive, args.account, amountReceived);\n', '    }\n', '\n', '    emit LimitOrderProcessed(\n', '      args.account,\n', '      args.assetToSupply,\n', '      args.assetToReceive,\n', '      executionArgs.amountToSupply,\n', '      amountReceived,\n', '      orderID\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Cancels a potential limit order. Only the owner, the account\n', '   * in question, or the canceller role may call this function.\n', '   */\n', '  function cancelLimitOrder(\n', '    LimitOrderArguments calldata args\n', '  ) external override onlyOwnerOrAccountOr(Role.CANCELLER, args.account) {\n', '    _enforceExpiration(args.expiration);\n', '\n', '    // Construct the order ID using relevant "context" of the limit order.\n', '    bytes32 orderID = keccak256(_constructLimitOrderContext(args));\n', '\n', '    // Ensure the order ID has not been used or cancelled and invalidate it.\n', '    require(\n', '      !_invalidMetaTxHashes[orderID], "Meta-transaction already invalid."\n', '    );\n', '    _invalidMetaTxHashes[orderID] = true;\n', '    \n', '    emit LimitOrderCancelled(orderID);\n', '  }\n', '\n', '  /**\n', '   * @notice Pause a currently unpaused role and emit a `RolePaused` event. Only\n', '   * the owner or the designated pauser may call this function. Also, bear in\n', '   * mind that only the owner may unpause a role once paused.\n', '   * @param role The role to pause.\n', '   */\n', '  function pause(Role role) external override onlyOwnerOr(Role.PAUSER) {\n', '    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n', '    require(!storedRoleStatus.paused, "Role in question is already paused.");\n', '    storedRoleStatus.paused = true;\n', '    emit RolePaused(role);\n', '  }\n', '\n', '  /**\n', '   * @notice Unpause a currently paused role and emit a `RoleUnpaused` event.\n', '   * Only the owner may call this function.\n', '   * @param role The role to pause.\n', '   */\n', '  function unpause(Role role) external override onlyOwner {\n', '    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n', '    require(storedRoleStatus.paused, "Role in question is already unpaused.");\n', '    storedRoleStatus.paused = false;\n', '    emit RoleUnpaused(role);\n', '  }\n', '\n', '  /**\n', '   * @notice Set a new account on a given role and emit a `RoleModified` event\n', '   * if the role holder has changed. Only the owner may call this function.\n', '   * @param role The role that the account will be set for.\n', '   * @param account The account to set as the designated role bearer.\n', '   */\n', '  function setRole(Role role, address account) external override onlyOwner {\n', '    require(account != address(0), "Must supply an account.");\n', '    _setRole(role, account);\n', '  }\n', '\n', '  /**\n', '   * @notice Remove any current role bearer for a given role and emit a\n', '   * `RoleModified` event if a role holder was previously set. Only the owner\n', '   * may call this function.\n', '   * @param role The role that the account will be removed from.\n', '   */\n', '  function removeRole(Role role) external override onlyOwner {\n', '    _setRole(role, address(0));\n', '  }\n', '\n', '  /**\n', "   * @notice View function to determine an order's meta-transaction message hash\n", '   * and to determine if it is still valid (i.e. it has not yet been used and is\n', '   * not expired). The returned order ID will need to be prefixed using EIP-191\n', '   * 0x45 and hashed again in order to generate a final digest for the required\n', '   * signature - in other words, the same procedure utilized by `eth_Sign`.\n', "   * @return orderID The ID corresponding to the limit order's meta-transaction.\n", '   */\n', '  function getOrderID(\n', '    LimitOrderArguments calldata args\n', '  ) external view override returns (bytes32 orderID, bool valid) {\n', '    // Construct the order ID based on relevant context.\n', '    orderID = keccak256(_constructLimitOrderContext(args));\n', '\n', '    // The meta-transaction is valid if it has not been used and is not expired.\n', '    valid = (\n', '      !_invalidMetaTxHashes[orderID] && (\n', '        args.expiration == 0 || block.timestamp <= args.expiration\n', '      )\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check whether or not the functionality\n', '   * associated with a given role is currently paused or not. The owner or the\n', '   * pauser may pause any given role (including the pauser itself), but only the\n', '   * owner may unpause functionality. Additionally, the owner may call paused\n', '   * functions directly.\n', '   * @param role The role to check the pause status on.\n', '   * @return paused A boolean to indicate if the functionality associated with\n', '   * the role in question is currently paused.\n', '   */\n', '  function isPaused(Role role) external view override returns (bool paused) {\n', '    paused = _isPaused(role);\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check whether the caller is the current\n', '   * role holder.\n', '   * @param role The role to check for.\n', '   * @return hasRole A boolean indicating if the caller has the specified role.\n', '   */\n', '  function isRole(Role role) external view override returns (bool hasRole) {\n', '    hasRole = _isRole(role);\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check the account currently holding the\n', '   * bot commander role. The bot commander can execute limit orders.\n', '   * @return botCommander The address of the current bot commander, or the null\n', '   * address if none is set.\n', '   */\n', '  function getBotCommander() external view override returns (\n', '    address botCommander\n', '  ) {\n', '    botCommander = _roles[uint256(Role.BOT_COMMANDER)].account;\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check the account currently holding the\n', '   * canceller role. The canceller can cancel limit orders.\n', '   * @return canceller The address of the current canceller, or the null\n', '   * address if none is set.\n', '   */\n', '  function getCanceller() external view override returns (\n', '    address canceller\n', '  ) {\n', '    canceller = _roles[uint256(Role.CANCELLER)].account;\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check the account currently holding the\n', '   * pauser role. The pauser can pause any role from taking its standard action,\n', '   * though the owner will still be able to call the associated function in the\n', '   * interim and is the only entity able to unpause the given role once paused.\n', '   * @return pauser The address of the current pauser, or the null address if\n', '   * none is set.\n', '   */\n', '  function getPauser() external view override returns (address pauser) {\n', '    pauser = _roles[uint256(Role.PAUSER)].account;\n', '  }\n', '\n', '  /**\n', '   * @notice Private function to enforce that a given meta-transaction\n', '   * has not been used before and that the signature is valid according\n', '   * to the account in question (using ERC-1271).\n', '   * @param account address The account originating the meta-transaction.\n', '   * @param context bytes Information about the meta-transaction.\n', '   * @param signatures bytes Signature or signatures used to validate\n', '   * the meta-transaction.\n', '   */\n', '  function _validateMetaTransaction(\n', '    address account, bytes memory context, bytes memory signatures\n', '  ) private returns (bytes32 orderID) {\n', '    // Construct the order ID using the provided context.\n', '    orderID = keccak256(context);\n', '\n', '    // Ensure ID has not been used or cancelled and invalidate it.\n', '    require(\n', '      !_invalidMetaTxHashes[orderID], "Order is no longer valid."\n', '    );\n', '    _invalidMetaTxHashes[orderID] = true;\n', '\n', '    // Construct the digest to compare signatures against using EIP-191 0x45.\n', '    bytes32 digest = keccak256(\n', '      abi.encodePacked("\\x19Ethereum Signed Message:\\n32", orderID)\n', '    );\n', '\n', '    // Validate via ERC-1271 against the specified account.\n', '    bytes memory data = abi.encode(digest, context);\n', '    bytes4 magic = ERC1271Interface(account).isValidSignature(data, signatures);\n', '    require(magic == bytes4(0x20c13b0b), "Invalid signatures.");\n', '  }\n', '\n', '  /**\n', '   * @notice Private function to set a new account on a given role and emit a\n', '   * `RoleModified` event if the role holder has changed.\n', '   * @param role The role that the account will be set for.\n', '   * @param account The account to set as the designated role bearer.\n', '   */\n', '  function _setRole(Role role, address account) private {\n', '    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n', '\n', '    if (account != storedRoleStatus.account) {\n', '      storedRoleStatus.account = account;\n', '      emit RoleModified(role, account);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Private function to perform a call to a given trade target, supplying\n', '   * given data and value, and revert with reason on failure.\n', '   */\n', '  function _performCallToTradeTarget(\n', '    address target, bytes memory data, uint256 etherValue\n', '  ) private {\n', '    // Call into the provided target, supplying provided data.\n', '    (bool tradeTargetCallSuccess,) = target.call{value: etherValue}(data);\n', '\n', '    // Revert with reason if the call was not successful.\n', '    if (!tradeTargetCallSuccess) {\n', '      assembly {\n', '        returndatacopy(0, 0, returndatasize())\n', '        revert(0, returndatasize())\n', '      }\n', '    } else {\n', '      // Ensure that the target is a contract.\n', '      uint256 returnSize;\n', '      assembly { returnSize := returndatasize() }\n', '      if (returnSize == 0) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(target) }\n', '        require(size > 0, "Specified target does not have contract code.");\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Private function to set approval for a given target to transfer tokens\n', '   * on behalf of this contract. It should generally be assumed that this contract\n', '   * is highly permissive when it comes to approvals.\n', '   */\n', '  function _grantApprovalIfNecessary(\n', '    ERC20Interface token, address target, uint256 amount\n', '  ) private {\n', '    if (token.allowance(address(this), target) < amount) {\n', '      // Try removing approval first as a workaround for unusual tokens.\n', '      (bool success, bytes memory returnData) = address(token).call(\n', '        abi.encodeWithSelector(\n', '          token.approve.selector, target, uint256(0)\n', '        )\n', '      );\n', '\n', '      // Grant approval to transfer tokens on behalf of this contract.\n', '      (success, returnData) = address(token).call(\n', '        abi.encodeWithSelector(\n', '          token.approve.selector, target, type(uint256).max\n', '        )\n', '      );\n', '\n', '      if (!success) {\n', '        // Some really janky tokens only allow setting approval up to current balance.\n', '        (success, returnData) = address(token).call(\n', '          abi.encodeWithSelector(\n', '            token.approve.selector, target, amount\n', '          )\n', '        );\n', '      }\n', '\n', '      require(\n', '        success && (returnData.length == 0 || abi.decode(returnData, (bool))),\n', '        "Token approval to trade against the target failed."\n', '      );\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Private function to transfer tokens out of this contract.\n', '   */\n', '  function _transferOutToken(ERC20Interface token, address to, uint256 amount) private {\n', '    (bool success, bytes memory returnData) = address(token).call(\n', '      abi.encodeWithSelector(token.transfer.selector, to, amount)\n', '    );\n', '\n', '    if (!success) {\n', '      assembly {\n', '        returndatacopy(0, 0, returndatasize())\n', '        revert(0, returndatasize())\n', '      }\n', '    }\n', '    \n', '    if (returnData.length == 0) {\n', '      uint256 size;\n', '      assembly { size := extcodesize(token) }\n', '      require(size > 0, "Token specified to transfer out does not have contract code.");\n', '    } else {\n', "      require(abi.decode(returnData, (bool)), 'Token transfer out failed.');\n", '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Private function to transfer Ether out of this contract.\n', '   */\n', '  function _transferEther(address recipient, uint256 etherAmount) private {\n', '    // Send Ether to recipient and revert with reason on failure.\n', '    (bool ok, ) = recipient.call{value: etherAmount}("");\n', '    if (!ok) {\n', '      assembly {\n', '        returndatacopy(0, 0, returndatasize())\n', '        revert(0, returndatasize())\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Private function to transfer tokens into this contract.\n', '   */\n', '  function _transferInToken(ERC20Interface token, address from, uint256 amount) private {\n', '    (bool success, bytes memory returnData) = address(token).call(\n', '      abi.encodeWithSelector(token.transferFrom.selector, from, address(this), amount)\n', '    );\n', '\n', '    if (!success) {\n', '      assembly {\n', '        returndatacopy(0, 0, returndatasize())\n', '        revert(0, returndatasize())\n', '      }\n', '    }\n', '    \n', '    if (returnData.length == 0) {\n', '      uint256 size;\n', '      assembly { size := extcodesize(token) }\n', '      require(size > 0, "Token specified to transfer in does not have contract code.");\n', '    } else {\n', "      require(abi.decode(returnData, (bool)), 'Token transfer in failed.');\n", '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Private view function to check whether the caller is the current\n', '   * role holder.\n', '   * @param role The role to check for.\n', '   * @return hasRole A boolean indicating if the caller has the specified role.\n', '   */\n', '  function _isRole(Role role) private view returns (bool hasRole) {\n', '    hasRole = msg.sender == _roles[uint256(role)].account;\n', '  }\n', '\n', '  /**\n', '   * @notice Private view function to check whether the given role is paused or\n', '   * not.\n', '   * @param role The role to check for.\n', '   * @return paused A boolean indicating if the specified role is paused or not.\n', '   */\n', '  function _isPaused(Role role) private view returns (bool paused) {\n', '    paused = _roles[uint256(role)].paused;\n', '  }\n', '\n', '  /**\n', '   * @notice Private view function to construct the "context" or details that\n', '   * need to be included when generating the order ID.\n', '   * @return context bytes The context.\n', '   */\n', '  function _constructLimitOrderContext(\n', '    LimitOrderArguments memory args\n', '  ) private view returns (bytes memory context) {\n', '    context = abi.encode(\n', '      address(this),\n', '      args.account,\n', '      args.assetToSupply,\n', '      args.assetToReceive,\n', '      args.maximumAmountToSupply,\n', '      args.maximumPriceToAccept,\n', '      args.expiration,\n', '      args.salt\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Private view function to ensure that a given expiration has\n', '   * not elapsed, or is set to zero (signifying no expiration).\n', '   */\n', '  function _enforceExpiration(uint256 expiration) private view {\n', '    require(\n', '      expiration == 0 || block.timestamp <= expiration,\n', '      "Order has expired."\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Modifier that throws if called by any account other than the owner\n', '   * or the supplied role, or if the caller is not the owner and the role in\n', '   * question is paused.\n', '   * @param role The role to require unless the caller is the owner. Permitted\n', '   * roles are bot commander (0), and canceller (1), and pauser (2).\n', '   */\n', '  modifier onlyOwnerOr(Role role) {\n', '    if (!isOwner()) {\n', '      require(_isRole(role), "Caller does not have a required role.");\n', '      require(!_isPaused(role), "Role in question is currently paused.");\n', '    }\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Modifier that throws if called by any account other than the owner,\n', '   * a specified account, or the supplied role, or if the caller is not the\n', '   * owner or the specified account and the role in question is paused.\n', '   * @param role The role to require unless the caller is the owner or the\n', '   * specified account. Permitted roles are bot commander (0), and canceller (1),\n', '   * and pauser (2).\n', '   */\n', '  modifier onlyOwnerOrAccountOr(Role role, address account) {\n', '    if (!isOwner() && !(msg.sender == account)) {\n', '      require(_isRole(role), "Caller does not have a required role.");\n', '      require(!_isPaused(role), "Role in question is currently paused.");\n', '    }\n', '    _;\n', '  }\n', '}']