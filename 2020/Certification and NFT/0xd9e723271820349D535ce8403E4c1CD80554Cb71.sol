['// File: contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '/// @title Ownable\n', '/// @dev Provide a simple access control with a single authority: the owner\n', 'contract Ownable {\n', '\n', '    // Ethereum address of current owner\n', '    address public owner;\n', '\n', '    // Ethereum address of the next owner\n', '    // (has to claim ownership first to become effective owner)\n', '    address public newOwner;\n', '\n', '    // @dev Log event on ownership transferred\n', '    // @param previousOwner Ethereum address of previous owner\n', '    // @param newOwner Ethereum address of new owner\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev Forbid call by anyone but owner\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Restricted to owner");\n', '        _;\n', '    }\n', '\n', '    /// @dev Deployer account becomes initial owner\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev  Transfer ownership to a new Ethereum account (safe method)\n', '    ///       Note: the new owner has to claim his ownership to become effective owner.\n', '    /// @param _newOwner  Ethereum address to transfer ownership to\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != address(0x0), "New owner is zero");\n', '\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /// @dev  Transfer ownership to a new Ethereum account (unsafe method)\n', "    ///       Note: It's strongly recommended to use the safe variant via transferOwnership\n", '    ///             and claimOwnership, to prevent accidental transfers to a wrong address.\n', '    /// @param _newOwner  Ethereum address to transfer ownership to\n', '    function transferOwnershipUnsafe(address _newOwner) public onlyOwner {\n', '        require(_newOwner != address(0x0), "New owner is zero");\n', '\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    /// @dev  Become effective owner (if dedicated so by previous owner)\n', '    function claimOwnership() public {\n', '        require(msg.sender == newOwner, "Restricted to new owner");\n', '\n', '        _transferOwnership(msg.sender);\n', '    }\n', '\n', '    /// @dev  Transfer ownership (internal method)\n', '    /// @param _newOwner  Ethereum address to transfer ownership to\n', '    function _transferOwnership(address _newOwner) private {\n', '        if (_newOwner != owner) {\n', '            emit OwnershipTransferred(owner, _newOwner);\n', '\n', '            owner = _newOwner;\n', '        }\n', '        newOwner = address(0x0);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/whitelist/Whitelist.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '/// @title Whitelist\n', '/// @author STOKR\n', 'contract Whitelist is Ownable {\n', '\n', '    // Set of admins\n', '    mapping(address => bool) public admins;\n', '\n', '    // Set of Whitelisted addresses\n', '    mapping(address => bool) public isWhitelisted;\n', '\n', '    /// @dev Log entry on admin added to set\n', '    /// @param admin An Ethereum address\n', '    event AdminAdded(address indexed admin);\n', '\n', '    /// @dev Log entry on admin removed from set\n', '    /// @param admin An Ethereum address\n', '    event AdminRemoved(address indexed admin);\n', '\n', '    /// @dev Log entry on investor added set\n', '    /// @param admin An Ethereum address\n', '    /// @param investor An Ethereum address\n', '    event InvestorAdded(address indexed admin, address indexed investor);\n', '\n', '    /// @dev Log entry on investor removed from set\n', '    /// @param admin An Ethereum address\n', '    /// @param investor An Ethereum address\n', '    event InvestorRemoved(address indexed admin, address indexed investor);\n', '\n', '    /// @dev Only admin\n', '    modifier onlyAdmin() {\n', '        require(admins[msg.sender], "Restricted to whitelist admin");\n', '        _;\n', '    }\n', '\n', '    /// @dev Add admin to set\n', '    /// @param _admin An Ethereum address\n', '    function addAdmin(address _admin) public onlyOwner {\n', '        require(_admin != address(0x0), "Whitelist admin is zero");\n', '\n', '        if (!admins[_admin]) {\n', '            admins[_admin] = true;\n', '\n', '            emit AdminAdded(_admin);\n', '        }\n', '    }\n', '\n', '    /// @dev Remove admin from set\n', '    /// @param _admin An Ethereum address\n', '    function removeAdmin(address _admin) public onlyOwner {\n', '        require(_admin != address(0x0), "Whitelist admin is zero");  // Necessary?\n', '\n', '        if (admins[_admin]) {\n', '            admins[_admin] = false;\n', '\n', '            emit AdminRemoved(_admin);\n', '        }\n', '    }\n', '\n', '    /// @dev Add investor to set of whitelisted addresses\n', '    /// @param _investors A list where each entry is an Ethereum address\n', '    function addToWhitelist(address[] calldata _investors) external onlyAdmin {\n', '        for (uint256 i = 0; i < _investors.length; i++) {\n', '            if (!isWhitelisted[_investors[i]]) {\n', '                isWhitelisted[_investors[i]] = true;\n', '\n', '                emit InvestorAdded(msg.sender, _investors[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Remove investor from set of whitelisted addresses\n', '    /// @param _investors A list where each entry is an Ethereum address\n', '    function removeFromWhitelist(address[] calldata _investors) external onlyAdmin {\n', '        for (uint256 i = 0; i < _investors.length; i++) {\n', '            if (isWhitelisted[_investors[i]]) {\n', '                isWhitelisted[_investors[i]] = false;\n', '\n', '                emit InvestorRemoved(msg.sender, _investors[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/whitelist/Whitelisted.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '/// @title Whitelisted\n', '/// @author STOKR\n', 'contract Whitelisted is Ownable {\n', '\n', '    Whitelist public whitelist;\n', '\n', '    /// @dev  Log entry on change of whitelist contract instance\n', '    /// @param previous  Ethereum address of previous whitelist\n', '    /// @param current   Ethereum address of new whitelist\n', '    event WhitelistChange(address indexed previous, address indexed current);\n', '\n', '    /// @dev Ensure only whitelisted addresses can call\n', '    modifier onlyWhitelisted(address _address) {\n', '        require(whitelist.isWhitelisted(_address), "Address is not whitelisted");\n', '        _;\n', '    }\n', '\n', '    /// @dev Constructor\n', '    /// @param _whitelist address of whitelist contract\n', '    constructor(Whitelist _whitelist) public {\n', '        setWhitelist(_whitelist);\n', '    }\n', '\n', '    /// @dev Set the address of whitelist\n', '    /// @param _newWhitelist An Ethereum address\n', '    function setWhitelist(Whitelist _newWhitelist) public onlyOwner {\n', '        require(address(_newWhitelist) != address(0x0), "Whitelist address is zero");\n', '\n', '        if (address(_newWhitelist) != address(whitelist)) {\n', '            emit WhitelistChange(address(whitelist), address(_newWhitelist));\n', '\n', '            whitelist = Whitelist(_newWhitelist);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/token/TokenRecoverable.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '/// @title TokenRecoverable\n', '/// @author STOKR\n', 'contract TokenRecoverable is Ownable {\n', '\n', '    // Address that can do the TokenRecovery\n', '    address public tokenRecoverer;\n', '\n', '    /// @dev  Event emitted when the TokenRecoverer changes\n', '    /// @param previous  Ethereum address of previous token recoverer\n', '    /// @param current   Ethereum address of new token recoverer\n', '    event TokenRecovererChange(address indexed previous, address indexed current);\n', '\n', '    /// @dev Event emitted in case of a TokenRecovery\n', '    /// @param oldAddress Ethereum address of old account\n', '    /// @param newAddress Ethereum address of new account\n', '    event TokenRecovery(address indexed oldAddress, address indexed newAddress);\n', '\n', '    /// @dev Restrict operation to token recoverer\n', '    modifier onlyTokenRecoverer() {\n', '        require(msg.sender == tokenRecoverer, "Restricted to token recoverer");\n', '        _;\n', '    }\n', '\n', '    /// @dev Constructor\n', '    /// @param _tokenRecoverer Ethereum address of token recoverer\n', '    constructor(address _tokenRecoverer) public {\n', '        setTokenRecoverer(_tokenRecoverer);\n', '    }\n', '\n', '    /// @dev Set token recoverer\n', '    /// @param _newTokenRecoverer Ethereum address of new token recoverer\n', '    function setTokenRecoverer(address _newTokenRecoverer) public onlyOwner {\n', '        require(_newTokenRecoverer != address(0x0), "New token recoverer is zero");\n', '\n', '        if (_newTokenRecoverer != tokenRecoverer) {\n', '            emit TokenRecovererChange(tokenRecoverer, _newTokenRecoverer);\n', '\n', '            tokenRecoverer = _newTokenRecoverer;\n', '        }\n', '    }\n', '\n', '    /// @dev Recover token\n', '    /// @param _oldAddress address\n', '    /// @param _newAddress address\n', '    function recoverToken(address _oldAddress, address _newAddress) public;\n', '\n', '}\n', '\n', '// File: contracts/token/ERC20.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '/// @title ERC20 interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', 'interface ERC20 {\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address _owner) external view returns (uint);\n', '    function allowance(address _owner, address _spender) external view returns (uint);\n', '    function approve(address _spender, uint _value) external returns (bool);\n', '    function transfer(address _to, uint _value) external returns (bool);\n', '    function transferFrom(address _from, address _to, uint _value) external returns (bool);\n', '\n', '}\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '/// @title SafeMath\n', '/// @dev Math operations with safety checks that throw on error\n', 'library SafeMath {\n', '\n', '    /// @dev Add two integers\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '\n', '        assert(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /// @dev Subtract two integers\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        assert(b <= a);\n', '\n', '        return a - b;\n', '    }\n', '\n', '    /// @dev Multiply tow integers\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint c = a * b;\n', '\n', '        assert(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /// @dev Floor divide two integers\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        return a / b;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/token/ProfitSharing.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '/// @title ProfitSharing\n', '/// @author STOKR\n', 'contract ProfitSharing is Ownable {\n', '\n', '    using SafeMath for uint;\n', '\n', '\n', "    // An InvestorAccount object keeps track of the investor's\n", '    // - balance: amount of tokens he/she holds (always up-to-date)\n', '    // - profitShare: amount of wei this token owed him/her at the last update\n', '    // - lastTotalProfits: determines when his/her profitShare was updated\n', '    // Note, this construction requires:\n', '    // - totalProfits to never decrease\n', '    // - totalSupply to be fixed\n', '    // - profitShare of all involved parties to get updated prior to any token transfer\n', '    // - lastTotalProfits to be set to current totalProfits upon profitShare update\n', '    struct InvestorAccount {\n', '        uint balance;           // token balance\n', '        uint lastTotalProfits;  // totalProfits [wei] at the time of last profit share update\n', '        uint profitShare;       // profit share [wei] of last update\n', '    }\n', '\n', '\n', '    // Investor account database\n', '    mapping(address => InvestorAccount) public accounts;\n', '\n', '    // Authority who is allowed to deposit profits [wei] on this\n', '    address public profitDepositor;\n', '\n', '    // Authority who is allowed to distribute profit shares [wei] to investors\n', "    // (so, that they don't need to withdraw it by themselves)\n", '    address public profitDistributor;\n', '\n', '    // Amount of total profits [wei] stored to this token\n', '    // In contrast to the wei balance (which may be reduced due to profit share withdrawal)\n', '    // this value will never decrease\n', '    uint public totalProfits;\n', '\n', "    // As long as the total supply isn't fixed, i.e. new tokens can appear out of thin air,\n", "    // the investors' profit shares aren't determined\n", '    bool public totalSupplyIsFixed;\n', '\n', '    // Total amount of tokens\n', '    uint internal totalSupply_;\n', '\n', '\n', '    /// @dev  Log entry on change of profit deposit authority\n', '    /// @param previous  Ethereum address of previous profit depositor\n', '    /// @param current   Ethereum address of new profit depositor\n', '    event ProfitDepositorChange(\n', '        address indexed previous,\n', '        address indexed current\n', '    );\n', '\n', '    /// @dev  Log entry on change of profit distribution authority\n', '    /// @param previous  Ethereum address of previous profit distributor\n', '    /// @param current   Ethereum address of new profit distributor\n', '    event ProfitDistributorChange(\n', '        address indexed previous,\n', '        address indexed current\n', '    );\n', '\n', '    /// @dev Log entry on profit deposit\n', "    /// @param depositor Profit depositor's address\n", '    /// @param amount Deposited profits in wei\n', '    event ProfitDeposit(\n', '        address indexed depositor,\n', '        uint amount\n', '    );\n', '\n', '    /// @dev Log entry on profit share update\n', "    /// @param investor Investor's address\n", '    /// @param amount New wei amount the token owes the investor\n', '    event ProfitShareUpdate(\n', '        address indexed investor,\n', '        uint amount\n', '    );\n', '\n', '    /// @dev Log entry on profit withdrawal\n', "    /// @param investor Investor's address\n", '    /// @param amount Wei amount the investor withdrew from this token\n', '    event ProfitShareWithdrawal(\n', '        address indexed investor,\n', '        address indexed beneficiary,\n', '        uint amount\n', '    );\n', '\n', '\n', '    /// @dev Restrict operation to profit deposit authority only\n', '    modifier onlyProfitDepositor() {\n', '        require(msg.sender == profitDepositor, "Restricted to profit depositor");\n', '        _;\n', '    }\n', '\n', '    /// @dev Restrict operation to profit distribution authority only\n', '    modifier onlyProfitDistributor() {\n', '        require(msg.sender == profitDistributor, "Restricted to profit distributor");\n', '        _;\n', '    }\n', '\n', "    /// @dev Restrict operation to when total supply doesn't change anymore\n", '    modifier onlyWhenTotalSupplyIsFixed() {\n', '        require(totalSupplyIsFixed, "Total supply may change");\n', '        _;\n', '    }\n', '\n', '    /// @dev Constructor\n', '    /// @param _profitDepositor Profit deposit authority\n', '    constructor(address _profitDepositor, address _profitDistributor) public {\n', '        setProfitDepositor(_profitDepositor);\n', '        setProfitDistributor(_profitDistributor);\n', '    }\n', '\n', '    /// @dev Profit deposit if possible via fallback function\n', '    function () external payable {\n', '        require(msg.data.length == 0, "Fallback call with data");\n', '\n', '        depositProfit();\n', '    }\n', '\n', '    /// @dev Change profit depositor\n', '    /// @param _newProfitDepositor An Ethereum address\n', '    function setProfitDepositor(address _newProfitDepositor) public onlyOwner {\n', '        require(_newProfitDepositor != address(0x0), "New profit depositor is zero");\n', '\n', '        if (_newProfitDepositor != profitDepositor) {\n', '            emit ProfitDepositorChange(profitDepositor, _newProfitDepositor);\n', '\n', '            profitDepositor = _newProfitDepositor;\n', '        }\n', '    }\n', '\n', '    /// @dev Change profit distributor\n', '    /// @param _newProfitDistributor An Ethereum address\n', '    function setProfitDistributor(address _newProfitDistributor) public onlyOwner {\n', '        require(_newProfitDistributor != address(0x0), "New profit distributor is zero");\n', '\n', '        if (_newProfitDistributor != profitDistributor) {\n', '            emit ProfitDistributorChange(profitDistributor, _newProfitDistributor);\n', '\n', '            profitDistributor = _newProfitDistributor;\n', '        }\n', '    }\n', '\n', '    /// @dev Deposit profit\n', '    function depositProfit() public payable onlyProfitDepositor onlyWhenTotalSupplyIsFixed {\n', '        require(totalSupply_ > 0, "Total supply is zero");\n', '\n', '        totalProfits = totalProfits.add(msg.value);\n', '\n', '        emit ProfitDeposit(msg.sender, msg.value);\n', '    }\n', '\n', '    /// @dev Profit share owing\n', '    /// @param _investor An Ethereum address\n', '    /// @return A positive number\n', '    function profitShareOwing(address _investor) public view returns (uint) {\n', '        if (!totalSupplyIsFixed || totalSupply_ == 0) {\n', '            return 0;\n', '        }\n', '\n', '        InvestorAccount memory account = accounts[_investor];\n', '\n', '        return totalProfits.sub(account.lastTotalProfits)\n', '                           .mul(account.balance)\n', '                           .div(totalSupply_)\n', '                           .add(account.profitShare);\n', '    }\n', '\n', '    /// @dev Update profit share\n', '    /// @param _investor An Ethereum address\n', '    function updateProfitShare(address _investor) public onlyWhenTotalSupplyIsFixed {\n', '        uint newProfitShare = profitShareOwing(_investor);\n', '\n', '        accounts[_investor].lastTotalProfits = totalProfits;\n', '        accounts[_investor].profitShare = newProfitShare;\n', '\n', '        emit ProfitShareUpdate(_investor, newProfitShare);\n', '    }\n', '\n', '    /// @dev Withdraw profit share\n', '    function withdrawProfitShare() public {\n', '        _withdrawProfitShare(msg.sender, msg.sender);\n', '    }\n', '\n', '    function withdrawProfitShareTo(address payable _beneficiary) public {\n', '        _withdrawProfitShare(msg.sender, _beneficiary);\n', '    }\n', '\n', '    /// @dev Withdraw profit share\n', '    function withdrawProfitShares(address payable[] calldata _investors)\n', '        external\n', '        onlyProfitDistributor\n', '    {\n', '        for (uint i = 0; i < _investors.length; ++i) {\n', '            _withdrawProfitShare(_investors[i], _investors[i]);\n', '        }\n', '    }\n', '\n', '    /// @dev Withdraw profit share\n', '    function _withdrawProfitShare(address _investor, address payable _beneficiary) internal {\n', '        updateProfitShare(_investor);\n', '\n', '        uint withdrawnProfitShare = accounts[_investor].profitShare;\n', '\n', '        accounts[_investor].profitShare = 0;\n', '        _beneficiary.transfer(withdrawnProfitShare);\n', '\n', '        emit ProfitShareWithdrawal(_investor, _beneficiary, withdrawnProfitShare);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/token/MintableToken.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '/// @title MintableToken\n', '/// @author STOKR\n', '/// @dev Extension of the ERC20 compliant ProfitSharing Token\n', '///      that allows the creation of tokens via minting for a\n', '///      limited time period (until minting gets finished).\n', 'contract MintableToken is ERC20, ProfitSharing, Whitelisted {\n', '\n', '    address public minter;\n', '    uint public numberOfInvestors = 0;\n', '\n', '    /// @dev Log entry on mint\n', '    /// @param to Beneficiary who received the newly minted tokens\n', '    /// @param amount The amount of minted token units\n', '    event Minted(address indexed to, uint amount);\n', '\n', '    /// @dev Log entry on mint finished\n', '    event MintFinished();\n', '\n', '    /// @dev Restrict an operation to be callable only by the minter\n', '    modifier onlyMinter() {\n', '        require(msg.sender == minter, "Restricted to minter");\n', '        _;\n', '    }\n', '\n', '    /// @dev Restrict an operation to be executable only while minting was not finished\n', '    modifier canMint() {\n', '        require(!totalSupplyIsFixed, "Total supply has been fixed");\n', '        _;\n', '    }\n', '\n', '    /// @dev Set minter authority\n', '    /// @param _minter Ethereum address of minter authority\n', '    function setMinter(address _minter) public onlyOwner {\n', '        require(minter == address(0x0), "Minter has already been set");\n', '        require(_minter != address(0x0), "Minter is zero");\n', '\n', '        minter = _minter;\n', '    }\n', '\n', '    /// @dev Mint tokens, i.e. create tokens out of thin air\n', '    /// @param _to Beneficiary who will receive the newly minted tokens\n', '    /// @param _amount The amount of minted token units\n', '    function mint(address _to, uint _amount) public onlyMinter canMint onlyWhitelisted(_to) {\n', '        if (accounts[_to].balance == 0) {\n', '            numberOfInvestors++;\n', '        }\n', '\n', '        totalSupply_ = totalSupply_.add(_amount);\n', '        accounts[_to].balance = accounts[_to].balance.add(_amount);\n', '\n', '        emit Minted(_to, _amount);\n', '        emit Transfer(address(0x0), _to, _amount);\n', '    }\n', '\n', '    /// @dev Finish minting -- this should be irreversible\n', '    function finishMinting() public onlyMinter canMint {\n', '        totalSupplyIsFixed = true;\n', '\n', '        emit MintFinished();\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/token/StokrToken.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '/// @title StokrToken\n', '/// @author Stokr\n', 'contract StokrToken is MintableToken, TokenRecoverable {\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public constant decimals = 18;\n', '\n', '    mapping(address => mapping(address => uint)) internal allowance_;\n', '\n', '    /// @dev Log entry on self destruction of the token\n', '    event TokenDestroyed();\n', '\n', '    /// @dev Constructor\n', '    /// @param _whitelist       Ethereum address of whitelist contract\n', '    /// @param _tokenRecoverer  Ethereum address of token recoverer\n', '    constructor(\n', '        string memory _name,\n', '        string memory _symbol,\n', '        Whitelist _whitelist,\n', '        address _profitDepositor,\n', '        address _profitDistributor,\n', '        address _tokenRecoverer\n', '    )\n', '        public\n', '        Whitelisted(_whitelist)\n', '        ProfitSharing(_profitDepositor, _profitDistributor)\n', '        TokenRecoverable(_tokenRecoverer)\n', '    {\n', '        name = _name;\n', '        symbol = _symbol;\n', '    }\n', '\n', "    /// @dev  Self destruct can only be called by crowdsale contract in case the goal wasn't reached\n", '    function destruct() public onlyMinter {\n', '        emit TokenDestroyed();\n', '        selfdestruct(address(uint160(owner)));\n', '    }\n', '\n', '    /// @dev Recover token\n', '    /// @param _oldAddress  address of old account\n', '    /// @param _newAddress  address of new account\n', '    function recoverToken(address _oldAddress, address _newAddress)\n', '        public\n', '        onlyTokenRecoverer\n', '        onlyWhitelisted(_newAddress)\n', '    {\n', '        // Ensure that new address is *not* an existing account.\n', '        // Check for account.profitShare is not needed because of following implication:\n', '        //   (account.lastTotalProfits == 0) ==> (account.profitShare == 0)\n', '        require(accounts[_newAddress].balance == 0 && accounts[_newAddress].lastTotalProfits == 0,\n', '                "New address exists already");\n', '\n', '        updateProfitShare(_oldAddress);\n', '\n', '        accounts[_newAddress] = accounts[_oldAddress];\n', '        delete accounts[_oldAddress];\n', '\n', '        emit TokenRecovery(_oldAddress, _newAddress);\n', '        emit Transfer(_oldAddress, _newAddress, accounts[_newAddress].balance);\n', '    }\n', '\n', '    /// @dev  Total supply of this token\n', '    /// @return  Token amount\n', '    function totalSupply() public view returns (uint) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    /// @dev  Token balance\n', '    /// @param _investor  Ethereum address of token holder\n', '    /// @return           Token amount\n', '    function balanceOf(address _investor) public view returns (uint) {\n', '        return accounts[_investor].balance;\n', '    }\n', '\n', '    /// @dev  Allowed token amount a third party trustee may transfer\n', '    /// @param _investor  Ethereum address of token holder\n', '    /// @param _spender   Ethereum address of third party\n', '    /// @return           Allowed token amount\n', '    function allowance(address _investor, address _spender) public view returns (uint) {\n', '        return allowance_[_investor][_spender];\n', '    }\n', '\n', '    /// @dev  Approve a third party trustee to transfer tokens\n', '    ///       Note: additional requirements are enforced within internal function.\n', '    /// @param _spender  Ethereum address of third party\n', '    /// @param _value    Maximum token amount that is allowed to get transferred\n', '    /// @return          Always true\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        return _approve(msg.sender, _spender, _value);\n', '    }\n', '\n', '    /// @dev  Increase the amount of tokens a third party trustee may transfer\n', '    ///       Note: additional requirements are enforces within internal function.\n', '    /// @param _spender  Ethereum address of third party\n', '    /// @param _amount   Additional token amount that is allowed to get transferred\n', '    /// @return          Always true\n', '    function increaseAllowance(address _spender, uint _amount) public returns (bool) {\n', '        require(allowance_[msg.sender][_spender] + _amount >= _amount, "Allowance overflow");\n', '\n', '        return _approve(msg.sender, _spender, allowance_[msg.sender][_spender].add(_amount));\n', '    }\n', '\n', '    /// @dev  Decrease the amount of tokens a third party trustee may transfer\n', '    ///       Note: additional requirements are enforces within internal function.\n', '    /// @param _spender  Ethereum address of third party\n', '    /// @param _amount   Reduced token amount that is allowed to get transferred\n', '    /// @return          Always true\n', '    function decreaseAllowance(address _spender, uint _amount) public returns (bool) {\n', '        require(_amount <= allowance_[msg.sender][_spender], "Amount exceeds allowance");\n', '\n', '        return _approve(msg.sender, _spender, allowance_[msg.sender][_spender].sub(_amount));\n', '    }\n', '\n', '    /// @dev  Check if a token transfer is possible\n', '    /// @param _from   Ethereum address of token sender\n', '    /// @param _to     Ethereum address of token recipient\n', '    /// @param _value  Token amount to transfer\n', '    /// @return        True iff a transfer with given pramaters would succeed\n', '    function canTransfer(address _from, address _to, uint _value)\n', '        public view returns (bool)\n', '    {\n', '        return totalSupplyIsFixed\n', '            && _from != address(0x0)\n', '            && _to != address(0x0)\n', '            && _value <= accounts[_from].balance\n', '            && whitelist.isWhitelisted(_from)\n', '            && whitelist.isWhitelisted(_to);\n', '    }\n', '\n', '    /// @dev  Check if a token transfer by third party is possible\n', '    /// @param _spender  Ethereum address of third party trustee\n', '    /// @param _from     Ethereum address of token holder\n', '    /// @param _to       Ethereum address of token recipient\n', '    /// @param _value    Token amount to transfer\n', '    /// @return          True iff a transfer with given pramaters would succeed\n', '    function canTransferFrom(address _spender, address _from, address _to, uint _value)\n', '        public view returns (bool)\n', '    {\n', '        return canTransfer(_from, _to, _value) && _value <= allowance_[_from][_spender];\n', '    }\n', '\n', '    /// @dev  Token transfer\n', '    ///       Note: additional requirements are enforces within internal function.\n', '    /// @param _to     Ethereum address of token recipient\n', '    /// @param _value  Token amount to transfer\n', '    /// @return        Always true\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        return _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /// @dev  Token transfer by a third party\n', '    ///       Note: additional requirements are enforces within internal function.\n', '    /// @param _from   Ethereum address of token holder\n', '    /// @param _to     Ethereum address of token recipient\n', '    /// @param _value  Token amount to transfer\n', '    /// @return        Always true\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        require(_value <= allowance_[_from][msg.sender], "Amount exceeds allowance");\n', '\n', '        return _approve(_from, msg.sender, allowance_[_from][msg.sender].sub(_value))\n', '            && _transfer(_from, _to, _value);\n', '    }\n', '\n', '    /// @dev  Approve a third party trustee to transfer tokens (internal implementation)\n', '    /// @param _from     Ethereum address of token holder\n', '    /// @param _spender  Ethereum address of third party\n', '    /// @param _value    Maximum token amount the trustee is allowed to transfer\n', '    /// @return          Always true\n', '    function _approve(address _from, address _spender, uint _value)\n', '        internal\n', '        onlyWhitelisted(_from)\n', '        onlyWhenTotalSupplyIsFixed\n', '        returns (bool)\n', '    {\n', '        allowance_[_from][_spender] = _value;\n', '\n', '        emit Approval(_from, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev  Token transfer (internal implementation)\n', '    /// @param _from   Ethereum address of token sender\n', '    /// @param _to     Ethereum address of token recipient\n', '    /// @param _value  Token amount to transfer\n', '    /// @return        Always true\n', '    function _transfer(address _from, address _to, uint _value)\n', '        internal\n', '        onlyWhitelisted(_from)\n', '        onlyWhitelisted(_to)\n', '        onlyWhenTotalSupplyIsFixed\n', '        returns (bool)\n', '    {\n', '        require(_to != address(0x0), "Recipient is zero");\n', '        require(_value <= accounts[_from].balance, "Amount exceeds balance");\n', '\n', '        updateProfitShare(_from);\n', '        updateProfitShare(_to);\n', '\n', '        accounts[_from].balance = accounts[_from].balance.sub(_value);\n', '        accounts[_to].balance = accounts[_to].balance.add(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/crowdsale/RateSourceInterface.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '/// @title RateSource\n', '/// @author STOKR\n', 'interface RateSource {\n', '\n', '    /// @dev The current price of an Ether in EUR cents\n', '    /// @return Current ether rate\n', '    function etherRate() external view returns (uint);\n', '\n', '}\n', '\n', '// File: contracts/crowdsale/MintingCrowdsale.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title MintingCrowdsale\n', '/// @author STOKR\n', 'contract MintingCrowdsale is Ownable {\n', '    using SafeMath for uint;\n', '\n', '    // Maximum Time of offering period after extension\n', '    uint constant MAXOFFERINGPERIOD = 183 days;\n', '\n', '    // Ether rate oracle contract providing the price of an Ether in EUR cents\n', '    RateSource public rateSource;\n', '\n', '    // The token to be sold\n', '    // In the following, the term "token unit" always refers to the smallest\n', '    // and non-divisible quantum. Thus, token unit amounts are always integers.\n', '    // One token is expected to consist of 10^18 token units.\n', '    MintableToken public token;\n', '\n', '    // Token amounts in token units\n', '    // The public and the private sale are both capped (i.e. two distinct token pools)\n', '    // The tokenRemaining variables keep track of how many token units are available\n', '    // for the respective type of sale\n', '    uint public tokenCapOfPublicSale;\n', '    uint public tokenCapOfPrivateSale;\n', '    uint public tokenRemainingForPublicSale;\n', '    uint public tokenRemainingForPrivateSale;\n', '\n', '    // Prices are in Euro cents (i.e. 1/100 EUR)\n', '    uint public tokenPrice;\n', '\n', '    // The minimum amount of tokens a purchaser has to buy via one transaction\n', '    uint public tokenPurchaseMinimum;\n', '\n', '    // The maximum total amount of tokens a purchaser may buy during start phase\n', '    uint public tokenPurchaseLimit;\n', '\n', '    // Total token purchased by investor (while purchase amount is limited)\n', '    mapping(address => uint) public tokenPurchased;\n', '\n', '    // Public sale period\n', '    uint public openingTime;\n', '    uint public closingTime;\n', '    uint public limitEndTime;\n', '\n', '    // Ethereum address where invested funds will be transferred to\n', '    address payable public companyWallet;\n', '\n', '    // Amount and receiver of reserved tokens\n', '    uint public tokenReservePerMill;\n', '    address public reserveAccount;\n', '\n', '    // Wether this crowdsale was finalized or not\n', '    bool public isFinalized = false;\n', '\n', '\n', '    /// @dev Log entry upon token distribution event\n', '    /// @param beneficiary Ethereum address of token recipient\n', '    /// @param amount Number of token units\n', '    /// @param isPublicSale Whether the distribution was via public sale\n', '    event TokenDistribution(address indexed beneficiary, uint amount, bool isPublicSale);\n', '\n', '    /// @dev Log entry upon token purchase event\n', '    /// @param buyer Ethereum address of token purchaser\n', '    /// @param value Worth in wei of purchased token amount\n', '    /// @param amount Number of token units\n', '    event TokenPurchase(address indexed buyer, uint value, uint amount);\n', '\n', '    /// @dev Log entry upon opening time change event\n', '    /// @param previous Previous opening time of sale\n', '    /// @param current Current opening time of sale\n', '    event OpeningTimeChange(uint previous, uint current);\n', '\n', '    /// @dev Log entry upon closing time change event\n', '    /// @param previous Previous closing time of sale\n', '    /// @param current Current closing time of sale\n', '    event ClosingTimeChange(uint previous, uint current);\n', '\n', '    /// @dev Log entry upon finalization event\n', '    event Finalization();\n', '\n', '\n', '    /// @dev Constructor\n', '    /// @param _rateSource Ether rate oracle contract\n', '    /// @param _token The token to be sold\n', '    /// @param _tokenCapOfPublicSale Maximum number of token units to mint in public sale\n', '    /// @param _tokenCapOfPrivateSale Maximum number of token units to mint in private sale\n', '    /// @param _tokenPurchaseMinimum Minimum amount of tokens an investor has to buy at once\n', '    /// @param _tokenPurchaseLimit Maximum total token amounts individually buyable in limit phase\n', '    /// @param _tokenPrice Price of a token in EUR cent\n', '    /// @param _openingTime Block (Unix) timestamp of sale opening time\n', '    /// @param _closingTime Block (Unix) timestamp of sale closing time\n', '    /// @param _limitEndTime Block (Unix) timestamp until token purchases are limited\n', '    /// @param _companyWallet Ethereum account who will receive sent ether\n', '    /// @param _tokenReservePerMill Per mill amount of sold tokens to mint for reserve account\n', '    /// @param _reserveAccount Ethereum address of reserve tokens recipient\n', '    constructor(\n', '        RateSource _rateSource,\n', '        MintableToken _token,\n', '        uint _tokenCapOfPublicSale,\n', '        uint _tokenCapOfPrivateSale,\n', '        uint _tokenPurchaseMinimum,\n', '        uint _tokenPurchaseLimit,\n', '        uint _tokenReservePerMill,\n', '        uint _tokenPrice,\n', '        uint _openingTime,\n', '        uint _closingTime,\n', '        uint _limitEndTime,\n', '        address payable _companyWallet,\n', '        address _reserveAccount\n', '    )\n', '        public\n', '    {\n', '        require(address(_rateSource) != address(0x0), "Rate source is zero");\n', '        require(address(_token) != address(0x0), "Token address is zero");\n', '        require(_token.minter() == address(0x0), "Token has another minter");\n', '        require(_tokenCapOfPublicSale > 0, "Cap of public sale is zero");\n', '        require(_tokenCapOfPrivateSale > 0, "Cap of private sale is zero");\n', '        require(_tokenPurchaseMinimum <= _tokenCapOfPublicSale\n', '                && _tokenPurchaseMinimum <= _tokenCapOfPrivateSale,\n', '                "Purchase minimum exceeds cap");\n', '        require(_tokenPrice > 0, "Token price is zero");\n', '        require(_openingTime >= now, "Opening lies in the past");\n', '        require(_closingTime >= _openingTime, "Closing lies before opening");\n', '        require(_companyWallet != address(0x0), "Company wallet is zero");\n', '        require(_reserveAccount != address(0x0), "Reserve account is zero");\n', '\n', '\n', '        // Note: There are no time related requirements regarding limitEndTime.\n', "        //       If it's below openingTime, token purchases will never be limited.\n", "        //       If it's above closingTime, token purchases will always be limited.\n", '        if (_limitEndTime > _openingTime) {\n', "            // But, if there's a purchase limitation phase, the limit must be at\n", '            // least the purchase minimum or above to make purchases possible.\n', '            require(_tokenPurchaseLimit >= _tokenPurchaseMinimum,\n', '                    "Purchase limit is below minimum");\n', '        }\n', '\n', "        // Utilize safe math to ensure the sum of three token pools does't overflow\n", '        _tokenCapOfPublicSale.add(_tokenCapOfPrivateSale).mul(_tokenReservePerMill);\n', '\n', '        rateSource = _rateSource;\n', '        token = _token;\n', '        tokenCapOfPublicSale = _tokenCapOfPublicSale;\n', '        tokenCapOfPrivateSale = _tokenCapOfPrivateSale;\n', '        tokenPurchaseMinimum = _tokenPurchaseMinimum;\n', '        tokenPurchaseLimit= _tokenPurchaseLimit;\n', '        tokenReservePerMill = _tokenReservePerMill;\n', '        tokenPrice = _tokenPrice;\n', '        openingTime = _openingTime;\n', '        closingTime = _closingTime;\n', '        limitEndTime = _limitEndTime;\n', '        companyWallet = _companyWallet;\n', '        reserveAccount = _reserveAccount;\n', '\n', '        tokenRemainingForPublicSale = _tokenCapOfPublicSale;\n', '        tokenRemainingForPrivateSale = _tokenCapOfPrivateSale;\n', '    }\n', '\n', '\n', '\n', '    /// @dev Fallback function: buys tokens\n', '    function () external payable {\n', '        require(msg.data.length == 0, "Fallback call with data");\n', '\n', '        buyTokens();\n', '    }\n', '\n', '    /// @dev Distribute tokens purchased off-chain via public sale\n', '    ///      Note: additional requirements are enforced in internal function.\n', "    /// @param beneficiaries List of recipients' Ethereum addresses\n", '    /// @param amounts List of token units each recipient will receive\n', '    function distributeTokensViaPublicSale(\n', '        address[] memory beneficiaries,\n', '        uint[] memory amounts\n', '    )\n', '        public\n', '    {\n', '        tokenRemainingForPublicSale =\n', '            distributeTokens(tokenRemainingForPublicSale, beneficiaries, amounts, true);\n', '    }\n', '\n', '    /// @dev Distribute tokens purchased off-chain via private sale\n', '    ///      Note: additional requirements are enforced in internal function.\n', "    /// @param beneficiaries List of recipients' Ethereum addresses\n", '    /// @param amounts List of token units each recipient will receive\n', '    function distributeTokensViaPrivateSale(\n', '        address[] memory beneficiaries,\n', '        uint[] memory amounts\n', '    )\n', '        public\n', '    {\n', '        tokenRemainingForPrivateSale =\n', '            distributeTokens(tokenRemainingForPrivateSale, beneficiaries, amounts, false);\n', '    }\n', '\n', '    /// @dev Check whether the sale has closed\n', '    /// @return True iff sale closing time has passed\n', '    function hasClosed() public view returns (bool) {\n', '        return now >= closingTime || tokenRemainingForPublicSale == 0;\n', '    }\n', '\n', '    /// @dev Check wether the sale is open\n', '    /// @return True iff sale opening time has passed and sale is not closed yet\n', '    function isOpen() public view returns (bool) {\n', '        return now >= openingTime && !hasClosed();\n', '    }\n', '\n', '    /// @dev Determine the remaining open time of sale\n', '    /// @return Time in seconds until sale gets closed, or 0 if sale was closed\n', '    function timeRemaining() public view returns (uint) {\n', '        if (hasClosed()) {\n', '            return 0;\n', '        }\n', '\n', '        return closingTime - now;\n', '    }\n', '\n', '    /// @dev Determine the amount of sold tokens (off-chain and on-chain)\n', '    /// @return Token units amount\n', '    function tokenSold() public view returns (uint) {\n', '        return (tokenCapOfPublicSale - tokenRemainingForPublicSale)\n', '             + (tokenCapOfPrivateSale - tokenRemainingForPrivateSale);\n', '    }\n', '\n', '    /// @dev Purchase tokens\n', '    function buyTokens() public payable {\n', '        require(isOpen(), "Sale is not open");\n', '\n', '        uint etherRate = rateSource.etherRate();\n', '\n', '        require(etherRate > 0, "Ether rate is zero");\n', '\n', '        // Units:  [1e-18*ether] * [cent/ether] / [cent/token] => [1e-18*token]\n', '        uint amount = msg.value.mul(etherRate).div(tokenPrice);\n', '\n', '        require(amount <= tokenRemainingForPublicSale, "Not enough tokens available");\n', '        require(amount >= tokenPurchaseMinimum, "Investment is too low");\n', '\n', '        // Is the total amount an investor can purchase with Ether limited?\n', '        if (now < limitEndTime) {\n', '            uint purchased = tokenPurchased[msg.sender].add(amount);\n', '\n', '            require(purchased <= tokenPurchaseLimit, "Purchase limit reached");\n', '\n', '            tokenPurchased[msg.sender] = purchased;\n', '        }\n', '\n', '        tokenRemainingForPublicSale = tokenRemainingForPublicSale.sub(amount);\n', '\n', '        token.mint(msg.sender, amount);\n', '        forwardFunds();\n', '\n', '        emit TokenPurchase(msg.sender, msg.value, amount);\n', '    }\n', '\n', '    /// @dev Change the start time of offering period without changing its duration.\n', '    /// @param _newOpeningTime new openingTime of the crowdsale\n', '    function changeOpeningTime(uint _newOpeningTime) public onlyOwner {\n', '        require(now < openingTime, "Sale has started already");\n', '        require(now < _newOpeningTime, "OpeningTime not in the future");\n', '\n', '        uint _newClosingTime = _newOpeningTime + (closingTime - openingTime);\n', '\n', '        emit OpeningTimeChange(openingTime, _newOpeningTime);\n', '        emit ClosingTimeChange(closingTime, _newClosingTime);\n', '\n', '        openingTime = _newOpeningTime;\n', '        closingTime = _newClosingTime;\n', '    }\n', '\n', '    /// @dev Extend the offering period of the crowd sale.\n', '    /// @param _newClosingTime new closingTime of the crowdsale\n', '    function changeClosingTime(uint _newClosingTime) public onlyOwner {\n', '        require(!hasClosed(), "Sale has already ended");\n', '        require(_newClosingTime > now, "ClosingTime not in the future");\n', '        require(_newClosingTime > openingTime, "New offering is zero");\n', '        require(_newClosingTime - openingTime <= MAXOFFERINGPERIOD, "New offering too long");\n', '\n', '        emit ClosingTimeChange(closingTime, _newClosingTime);\n', '\n', '        closingTime = _newClosingTime;\n', '    }\n', '\n', '    /// @dev Finalize, i.e. end token minting phase and enable token transfers\n', '    function finalize() public onlyOwner {\n', '        require(!isFinalized, "Sale has already been finalized");\n', '        require(hasClosed(), "Sale has not closed");\n', '\n', '        if (tokenReservePerMill > 0) {\n', '            token.mint(reserveAccount, tokenSold().mul(tokenReservePerMill).div(1000));\n', '        }\n', '        token.finishMinting();\n', '        isFinalized = true;\n', '\n', '        emit Finalization();\n', '    }\n', '\n', '    /// @dev Distribute tokens purchased off-chain (in Euro) to investors\n', '    /// @param tokenRemaining Token units available for sale\n', '    /// @param beneficiaries Ethereum addresses of purchasers\n', '    /// @param amounts Token unit amounts to deliver to each investor\n', '    /// @return Token units available for sale after distribution\n', '    function distributeTokens(\n', '        uint tokenRemaining,\n', '        address[] memory beneficiaries,\n', '        uint[] memory amounts,\n', '        bool isPublicSale\n', '    )\n', '        internal\n', '        onlyOwner\n', '        returns (uint)\n', '    {\n', '        require(!isFinalized, "Sale has been finalized");\n', '        require(beneficiaries.length == amounts.length, "Lengths are different");\n', '\n', '        for (uint i = 0; i < beneficiaries.length; ++i) {\n', '            address beneficiary = beneficiaries[i];\n', '            uint amount = amounts[i];\n', '\n', '            require(amount <= tokenRemaining, "Not enough tokens available");\n', '\n', '            tokenRemaining = tokenRemaining.sub(amount);\n', '            token.mint(beneficiary, amount);\n', '\n', '            emit TokenDistribution(beneficiary, amount, isPublicSale);\n', '        }\n', '\n', '        return tokenRemaining;\n', '    }\n', '\n', '    /// @dev Forward invested ether to company wallet\n', '    function forwardFunds() internal {\n', '        companyWallet.transfer(address(this).balance);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/crowdsale/StokrCrowdsale.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '/// @title StokrCrowdsale\n', '/// @author STOKR\n', 'contract StokrCrowdsale is MintingCrowdsale {\n', '\n', '    // Soft cap in token units\n', '    uint public tokenGoal;\n', '\n', '    // As long as the goal is not reached funds of purchases are held back\n', '    // and investments are assigned to investors here to enable a refunding\n', '    // if the goal is missed upon finalization\n', '    mapping(address => uint) public investments;\n', '\n', '\n', '    // Log entry upon investor refund event\n', '    event InvestorRefund(address indexed investor, uint value);\n', '\n', '\n', '    /// @dev Constructor\n', '    /// @param _token The token\n', '    /// @param _tokenCapOfPublicSale Available token units for public sale\n', '    /// @param _tokenCapOfPrivateSale Available token units for private sale\n', '    /// @param _tokenGoal Minimum number of sold token units to be successful\n', '    /// @param _tokenPurchaseMinimum Minimum amount of tokens an investor has to buy at once\n', '    /// @param _tokenPurchaseLimit Maximum total token amounts individually buyable in limit phase\n', '    /// @param _tokenReservePerMill Additional reserve tokens in per mill of sold tokens\n', '    /// @param _tokenPrice Price of a token in EUR cent\n', '    /// @param _rateSource Ethereum address of ether rate setting authority\n', '    /// @param _openingTime Block (Unix) timestamp of sale opening time\n', '    /// @param _closingTime Block (Unix) timestamp of sale closing time\n', '    /// @param _limitEndTime Block (Unix) timestamp until token purchases are limited\n', '    /// @param _companyWallet Ethereum account who will receive sent ether\n', '    /// @param _reserveAccount An address\n', '    constructor(\n', '        RateSource _rateSource,\n', '        StokrToken _token,\n', '        uint _tokenCapOfPublicSale,\n', '        uint _tokenCapOfPrivateSale,\n', '        uint _tokenGoal,\n', '        uint _tokenPurchaseMinimum,\n', '        uint _tokenPurchaseLimit,\n', '        uint _tokenReservePerMill,\n', '        uint _tokenPrice,\n', '        uint _openingTime,\n', '        uint _closingTime,\n', '        uint _limitEndTime,\n', '        address payable _companyWallet,\n', '        address _reserveAccount\n', '    )\n', '        public\n', '        MintingCrowdsale(\n', '            _rateSource,\n', '            _token,\n', '            _tokenCapOfPublicSale,\n', '            _tokenCapOfPrivateSale,\n', '            _tokenPurchaseMinimum,\n', '            _tokenPurchaseLimit,\n', '            _tokenReservePerMill,\n', '            _tokenPrice,\n', '            _openingTime,\n', '            _closingTime,\n', '            _limitEndTime,\n', '            _companyWallet,\n', '            _reserveAccount\n', '        )\n', '    {\n', '        require(\n', '            _tokenGoal <= _tokenCapOfPublicSale + _tokenCapOfPrivateSale,\n', '            "Goal is not attainable"\n', '        );\n', '\n', '        tokenGoal = _tokenGoal;\n', '    }\n', '\n', '    /// @dev Wether the goal of sold tokens was reached or not\n', '    /// @return True if the sale can be considered successful\n', '    function goalReached() public view returns (bool) {\n', '        return tokenSold() >= tokenGoal;\n', '    }\n', '\n', '    /// @dev Investors can claim refunds here if crowdsale was unsuccessful\n', '    function distributeRefunds(address payable[] calldata _investors) external {\n', '        for (uint i = 0; i < _investors.length; ++i) {\n', '            refundInvestor(_investors[i]);\n', '        }\n', '    }\n', '\n', '    /// @dev Investors can claim refunds here if crowdsale was unsuccessful\n', '    function claimRefund() public {\n', '        refundInvestor(msg.sender);\n', '    }\n', '\n', '    /// @dev Overwritten. Kill the token if goal was missed\n', '    function finalize() public onlyOwner {\n', '        super.finalize();\n', '\n', '        if (!goalReached()) {\n', '            StokrToken(address(token)).destruct();\n', '        }\n', '    }\n', '\n', '    function distributeTokensViaPublicSale(\n', '        address[] memory beneficiaries,\n', '        uint[] memory amounts\n', '    )\n', '        public\n', '    {\n', '        super.distributeTokensViaPublicSale(beneficiaries, amounts);\n', '        // The goal may get reached due to token distribution,\n', '        // so forward any accumulated funds to the company wallet.\n', '        forwardFunds();\n', '    }\n', '\n', '    function distributeTokensViaPrivateSale(\n', '        address[] memory beneficiaries,\n', '        uint[] memory amounts\n', '    )\n', '        public\n', '    {\n', '        super.distributeTokensViaPrivateSale(beneficiaries, amounts);\n', '        // The goal may get reached due to token distribution,\n', '        // so forward any accumulated funds to the company wallet.\n', '        forwardFunds();\n', '    }\n', '\n', '    /// @dev Overwritten. Funds are held back until goal was reached\n', '    function forwardFunds() internal {\n', '        if (goalReached()) {\n', '            super.forwardFunds();\n', '        }\n', '        else {\n', '            investments[msg.sender] = investments[msg.sender].add(msg.value);\n', '        }\n', '    }\n', '\n', '    /// @dev Refund an investor if the sale was not successful\n', '    /// @param _investor Ethereum address of investor\n', '    function refundInvestor(address payable _investor) internal {\n', '        require(isFinalized, "Sale has not been finalized");\n', '        require(!goalReached(), "Goal was reached");\n', '\n', '        uint investment = investments[_investor];\n', '\n', '        if (investment > 0) {\n', '            investments[_investor] = 0;\n', '            _investor.transfer(investment);\n', '\n', '            emit InvestorRefund(_investor, investment);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/crowdsale/StokrCrowdsaleFactory.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '// Helper contract to deploy a new StokrCrowdsale contract\n', '\n', 'contract StokrCrowdsaleFactory {\n', '\n', '    function createNewCrowdsale(\n', '        StokrToken token,\n', '        uint tokenPrice,\n', '        uint[6] calldata amounts,    // [tokenCapOfPublicSale, tokenCapOfPrivateSale, tokenGoal,\n', '                                     //  tokenPurchaseMinimum, tokenPurchaseLimit,\n', '                                     //  tokenReservePerMill]\n', '        uint[3] calldata period,     // [openingTime, closingTime, limitEndTime]\n', '        address[2] calldata wallets  // [companyWallet, reserveAccount]\n', '    )\n', '        external\n', '        returns (StokrCrowdsale)\n', '    {\n', '        StokrCrowdsale crowdsale = new StokrCrowdsale(\n', '            RateSource(msg.sender),         // rateSource\n', '            token,\n', '            amounts[0],                     // tokenCapOfPublicSale\n', '            amounts[1],                     // tokenCapOfPrivateSale\n', '            amounts[2],                     // tokenGoal\n', '            amounts[3],                     // tokenPurchaseMinimum\n', '            amounts[4],                     // tokenPurchaseLimit\n', '            amounts[5],                     // tokenReservePerMill\n', '            tokenPrice,                     // tokenPrice\n', '            period[0],                      // openingTime\n', '            period[1],                      // closingTime\n', '            period[2],                      // limitEndTime\n', '            address(uint160(wallets[0])),   // companyWallet\n', '            wallets[1]);                    // reserveAccount\n', '\n', '        crowdsale.transferOwnershipUnsafe(msg.sender);\n', '\n', '        return crowdsale;\n', '    }\n', '\n', '}']