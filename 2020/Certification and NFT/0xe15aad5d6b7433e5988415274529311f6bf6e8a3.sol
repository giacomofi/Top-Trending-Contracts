['pragma solidity 0.5.16;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'interface MassetStructs {\n', '\n', '    /** @dev Stores high level basket info */\n', '    struct Basket {\n', '\n', '        /** @dev Array of Bassets currently active */\n', '        Basset[] bassets;\n', '\n', '        /** @dev Max number of bAssets that can be present in any Basket */\n', '        uint8 maxBassets;\n', '\n', '        /** @dev Some bAsset is undergoing re-collateralisation */\n', '        bool undergoingRecol;\n', '\n', '        /**\n', '         * @dev In the event that we do not raise enough funds from the auctioning of a failed Basset,\n', '         * The Basket is deemed as failed, and is undercollateralised to a certain degree.\n', '         * The collateralisation ratio is used to calc Masset burn rate.\n', '         */\n', '        bool failed;\n', '        uint256 collateralisationRatio;\n', '\n', '    }\n', '\n', '    /** @dev Stores bAsset info. The struct takes 5 storage slots per Basset */\n', '    struct Basset {\n', '\n', '        /** @dev Address of the bAsset */\n', '        address addr;\n', '\n', '        /** @dev Status of the basset,  */\n', '        BassetStatus status; // takes uint8 datatype (1 byte) in storage\n', '\n', '        /** @dev An ERC20 can charge transfer fee, for example USDT, DGX tokens. */\n', '        bool isTransferFeeCharged; // takes a byte in storage\n', '\n', '        /**\n', '         * @dev 1 Basset * ratio / ratioScale == x Masset (relative value)\n', '         *      If ratio == 10e8 then 1 bAsset = 10 mAssets\n', '         *      A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\n', '         */\n', '        uint256 ratio;\n', '\n', '        /** @dev Target weights of the Basset (100% == 1e18) */\n', '        uint256 maxWeight;\n', '\n', '        /** @dev Amount of the Basset that is held in Collateral */\n', '        uint256 vaultBalance;\n', '\n', '    }\n', '\n', '    /** @dev Status of the Basset - has it broken its peg? */\n', '    enum BassetStatus {\n', '        Default,\n', '        Normal,\n', '        BrokenBelowPeg,\n', '        BrokenAbovePeg,\n', '        Blacklisted,\n', '        Liquidating,\n', '        Liquidated,\n', '        Failed\n', '    }\n', '\n', '    /** @dev Internal details on Basset */\n', '    struct BassetDetails {\n', '        Basset bAsset;\n', '        address integrator;\n', '        uint8 index;\n', '    }\n', '\n', '    /** @dev All details needed to Forge with multiple bAssets */\n', '    struct ForgePropsMulti {\n', '        bool isValid; // Flag to signify that forge bAssets have passed validity check\n', '        Basset[] bAssets;\n', '        address[] integrators;\n', '        uint8[] indexes;\n', '    }\n', '\n', '    /** @dev All details needed for proportionate Redemption */\n', '    struct RedeemPropsMulti {\n', '        uint256 colRatio;\n', '        Basset[] bAssets;\n', '        address[] integrators;\n', '        uint8[] indexes;\n', '    }\n', '}\n', '\n', 'contract IMasset is MassetStructs {\n', '\n', '    /** @dev Calc interest */\n', '    function collectInterest() external returns (uint256 massetMinted, uint256 newTotalSupply);\n', '\n', '    /** @dev Minting */\n', '    function mint(address _basset, uint256 _bassetQuantity)\n', '        external returns (uint256 massetMinted);\n', '    function mintTo(address _basset, uint256 _bassetQuantity, address _recipient)\n', '        external returns (uint256 massetMinted);\n', '    function mintMulti(address[] calldata _bAssets, uint256[] calldata _bassetQuantity, address _recipient)\n', '        external returns (uint256 massetMinted);\n', '\n', '    /** @dev Swapping */\n', '    function swap( address _input, address _output, uint256 _quantity, address _recipient)\n', '        external returns (uint256 output);\n', '    function getSwapOutput( address _input, address _output, uint256 _quantity)\n', '        external view returns (bool, string memory, uint256 output);\n', '\n', '    /** @dev Redeeming */\n', '    function redeem(address _basset, uint256 _bassetQuantity)\n', '        external returns (uint256 massetRedeemed);\n', '    function redeemTo(address _basset, uint256 _bassetQuantity, address _recipient)\n', '        external returns (uint256 massetRedeemed);\n', '    function redeemMulti(address[] calldata _bAssets, uint256[] calldata _bassetQuantities, address _recipient)\n', '        external returns (uint256 massetRedeemed);\n', '    function redeemMasset(uint256 _mAssetQuantity, address _recipient) external;\n', '\n', '    /** @dev Setters for the Manager or Gov to update module info */\n', '    function upgradeForgeValidator(address _newForgeValidator) external;\n', '\n', '    /** @dev Setters for Gov to set system params */\n', '    function setSwapFee(uint256 _swapFee) external;\n', '\n', '    /** @dev Getters */\n', '    function getBasketManager() external view returns(address);\n', '    function forgeValidator() external view returns (address);\n', '    function totalSupply() external view returns (uint256);\n', '    function swapFee() external view returns (uint256);\n', '}\n', '\n', 'contract IBasketManager is MassetStructs {\n', '\n', '    /** @dev Setters for mAsset to update balances */\n', '    function increaseVaultBalance(\n', '        uint8 _bAsset,\n', '        address _integrator,\n', '        uint256 _increaseAmount) external;\n', '    function increaseVaultBalances(\n', '        uint8[] calldata _bAsset,\n', '        address[] calldata _integrator,\n', '        uint256[] calldata _increaseAmount) external;\n', '    function decreaseVaultBalance(\n', '        uint8 _bAsset,\n', '        address _integrator,\n', '        uint256 _decreaseAmount) external;\n', '    function decreaseVaultBalances(\n', '        uint8[] calldata _bAsset,\n', '        address[] calldata _integrator,\n', '        uint256[] calldata _decreaseAmount) external;\n', '    function collectInterest() external\n', '        returns (uint256 interestCollected, uint256[] memory gains);\n', '\n', '    /** @dev Setters for Gov to update Basket composition */\n', '    function addBasset(\n', '        address _basset,\n', '        address _integration,\n', '        bool _isTransferFeeCharged) external returns (uint8 index);\n', '    function setBasketWeights(address[] calldata _bassets, uint256[] calldata _weights) external;\n', '    function setTransferFeesFlag(address _bAsset, bool _flag) external;\n', '\n', '    /** @dev Getters to retrieve Basket information */\n', '    function getBasket() external view returns (Basket memory b);\n', '    function prepareForgeBasset(address _token, uint256 _amt, bool _mint) external\n', '        returns (bool isValid, BassetDetails memory bInfo);\n', '    function prepareSwapBassets(address _input, address _output, bool _isMint) external view\n', '        returns (bool, string memory, BassetDetails memory, BassetDetails memory);\n', '    function prepareForgeBassets(address[] calldata _bAssets, uint256[] calldata _amts, bool _mint) external\n', '        returns (ForgePropsMulti memory props);\n', '    function prepareRedeemMulti() external view\n', '        returns (RedeemPropsMulti memory props);\n', '    function getBasset(address _token) external view\n', '        returns (Basset memory bAsset);\n', '    function getBassets() external view\n', '        returns (Basset[] memory bAssets, uint256 len);\n', '    function paused() external view returns (bool);\n', '\n', '    /** @dev Recollateralisation */\n', '    function handlePegLoss(address _basset, bool _belowPeg) external returns (bool actioned);\n', '    function negateIsolation(address _basset) external;\n', '}\n', '\n', 'interface ISavingsContract {\n', '\n', '    /** @dev Manager privs */\n', '    function depositInterest(uint256 _amount) external;\n', '\n', '    /** @dev Saver privs */\n', '    function depositSavings(uint256 _amount) external returns (uint256 creditsIssued);\n', '    function redeem(uint256 _amount) external returns (uint256 massetReturned);\n', '\n', '    /** @dev Getters */\n', '    function exchangeRate() external view returns (uint256);\n', '    function creditBalances(address) external view returns (uint256);\n', '}\n', '\n', 'interface IMStableHelper {\n', '\n', '    /**\n', '     * @dev Returns a valid bAsset with which to mint\n', '     * @param _mAsset Masset addr\n', '     * @return valid bool\n', '     * @return string message\n', '     * @return address of bAsset to mint\n', '     */\n', '    function suggestMintAsset(\n', '        address _mAsset\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            bool,\n', '            string memory,\n', '            address\n', '        );\n', '\n', '    /**\n', '     * @dev Gets the maximum input for a valid swap pair\n', '     * @param _mAsset mAsset address (e.g. mUSD)\n', '     * @param _input Asset to input only bAssets accepted\n', '     * @param _output Either a bAsset or the mAsset\n', '     * @return valid\n', '     * @return validity reason\n', '     * @return max input units (in native decimals)\n', '     * @return how much output this input would produce (in native decimals, after any fee)\n', '     */\n', '    function getMaxSwap(\n', '        address _mAsset,\n', '        address _input,\n', '        address _output\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            bool,\n', '            string memory,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '\n', '    /**\n', '     * @dev Returns a valid bAsset to redeem\n', '     * @param _mAsset Masset addr\n', '     * @return valid bool\n', '     * @return string message\n', '     * @return address of bAsset to redeem\n', '     */\n', '    function suggestRedeemAsset(\n', '        address _mAsset\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            bool,\n', '            string memory,\n', '            address\n', '        );\n', '\n', '    /**\n', '     * @dev Determines if a given Redemption is valid\n', '     * @param _mAsset Address of the given mAsset (e.g. mUSD)\n', '     * @param _mAssetQuantity Amount of mAsset to redeem (in mUSD units)\n', '     * @param _outputBasset Desired output bAsset\n', '     * @return valid\n', '     * @return validity reason\n', '     * @return output in bAsset units\n', "     * @return bAssetQuantityArg - required input argument to the 'redeem' call\n", '     */\n', '    function getRedeemValidity(\n', '        address _mAsset,\n', '        uint256 _mAssetQuantity,\n', '        address _outputBasset\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            bool,\n', '            string memory,\n', '            uint256 output,\n', '            uint256 bassetQuantityArg\n', '        );\n', '\n', '    /**\n', '     * @dev Gets the users savings balance in Masset terms\n', '     * @param _save SAVE contract address\n', '     * @param _user Address of the user\n', '     * @return balance in Masset units\n', '     */\n', '    function getSaveBalance(\n', '        ISavingsContract _save,\n', '        address _user\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            uint256\n', '        );\n', '\n', '    /**\n', "     * @dev Returns the 'credit' units required to withdraw a certain\n", '     * amount of Masset from the SAVE contract\n', '     * @param _save SAVE contract address\n', '     * @param _amount Amount of mAsset to redeem from SAVE\n', '     * @return input for the redeem function (ie. credit units to redeem)\n', '     */\n', '    function getSaveRedeemInput(\n', '        ISavingsContract _save,\n', '        uint256 _amount\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            uint256\n', '        );\n', '}\n', '\n', 'contract IForgeValidator is MassetStructs {\n', '    function validateMint(uint256 _totalVault, Basset calldata _basset, uint256 _bAssetQuantity)\n', '        external pure returns (bool, string memory);\n', '    function validateMintMulti(uint256 _totalVault, Basset[] calldata _bassets, uint256[] calldata _bAssetQuantities)\n', '        external pure returns (bool, string memory);\n', '    function validateSwap(uint256 _totalVault, Basset calldata _inputBasset, Basset calldata _outputBasset, uint256 _quantity)\n', '        external pure returns (bool, string memory, uint256, bool);\n', '    function validateRedemption(\n', '        bool basketIsFailed,\n', '        uint256 _totalVault,\n', '        Basset[] calldata _allBassets,\n', '        uint8[] calldata _indices,\n', '        uint256[] calldata _bassetQuantities) external pure returns (bool, string memory, bool);\n', '    function calculateRedemptionMulti(\n', '        uint256 _mAssetQuantity,\n', '        Basset[] calldata _allBassets) external pure returns (bool, string memory, uint256[] memory);\n', '}\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library StableMath {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * @dev Scaling unit for use in specific calculations,\n', "     * where 1 * 10**18, or 1e18 represents a unit '1'\n", '     */\n', '    uint256 private constant FULL_SCALE = 1e18;\n', '\n', '    /**\n', '     * @notice Token Ratios are used when converting between units of bAsset, mAsset and MTA\n', '     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\n', '     * @dev bAsset ratio unit for use in exact calculations,\n', '     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\n', '     */\n', '    uint256 private constant RATIO_SCALE = 1e8;\n', '\n', '    /**\n', '     * @dev Provides an interface to the scaling unit\n', '     * @return Scaling unit (1e18 or 1 * 10**18)\n', '     */\n', '    function getFullScale() internal pure returns (uint256) {\n', '        return FULL_SCALE;\n', '    }\n', '\n', '    /**\n', '     * @dev Provides an interface to the ratio unit\n', '     * @return Ratio scale unit (1e8 or 1 * 10**8)\n', '     */\n', '    function getRatioScale() internal pure returns (uint256) {\n', '        return RATIO_SCALE;\n', '    }\n', '\n', '    /**\n', '     * @dev Scales a given integer to the power of the full scale.\n', '     * @param x   Simple uint256 to scale\n', '     * @return    Scaled value a to an exact number\n', '     */\n', '    function scaleInteger(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return x.mul(FULL_SCALE);\n', '    }\n', '\n', '    /***************************************\n', '              PRECISE ARITHMETIC\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Multiplies two precise units, and then truncates by the full scale\n', '     * @param x     Left hand input to multiplication\n', '     * @param y     Right hand input to multiplication\n', '     * @return      Result after multiplying the two inputs and then dividing by the shared\n', '     *              scale unit\n', '     */\n', '    function mulTruncate(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return mulTruncateScale(x, y, FULL_SCALE);\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\n', '     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\n', '     * @param x     Left hand input to multiplication\n', '     * @param y     Right hand input to multiplication\n', '     * @param scale Scale unit\n', '     * @return      Result after multiplying the two inputs and then dividing by the shared\n', '     *              scale unit\n', '     */\n', '    function mulTruncateScale(uint256 x, uint256 y, uint256 scale)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // e.g. assume scale = fullScale\n', '        // z = 10e18 * 9e17 = 9e36\n', '        uint256 z = x.mul(y);\n', '        // return 9e38 / 1e18 = 9e18\n', '        return z.div(scale);\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\n', '     * @param x     Left hand input to multiplication\n', '     * @param y     Right hand input to multiplication\n', '     * @return      Result after multiplying the two inputs and then dividing by the shared\n', '     *              scale unit, rounded up to the closest base unit.\n', '     */\n', '    function mulTruncateCeil(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // e.g. 8e17 * 17268172638 = 138145381104e17\n', '        uint256 scaled = x.mul(y);\n', '        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\n', '        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\n', '        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\n', '        return ceil.div(FULL_SCALE);\n', '    }\n', '\n', '    /**\n', '     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\n', '     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\n', '     * @param x     Left hand input to division\n', '     * @param y     Right hand input to division\n', '     * @return      Result after multiplying the left operand by the scale, and\n', '     *              executing the division on the right hand input.\n', '     */\n', '    function divPrecisely(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // e.g. 8e18 * 1e18 = 8e36\n', '        uint256 z = x.mul(FULL_SCALE);\n', '        // e.g. 8e36 / 10e18 = 8e17\n', '        return z.div(y);\n', '    }\n', '\n', '\n', '    /***************************************\n', '                  RATIO FUNCS\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Multiplies and truncates a token ratio, essentially flooring the result\n', '     *      i.e. How much mAsset is this bAsset worth?\n', '     * @param x     Left hand operand to multiplication (i.e Exact quantity)\n', '     * @param ratio bAsset ratio\n', '     * @return      Result after multiplying the two inputs and then dividing by the ratio scale\n', '     */\n', '    function mulRatioTruncate(uint256 x, uint256 ratio)\n', '        internal\n', '        pure\n', '        returns (uint256 c)\n', '    {\n', '        return mulTruncateScale(x, ratio, RATIO_SCALE);\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies and truncates a token ratio, rounding up the result\n', '     *      i.e. How much mAsset is this bAsset worth?\n', '     * @param x     Left hand input to multiplication (i.e Exact quantity)\n', '     * @param ratio bAsset ratio\n', '     * @return      Result after multiplying the two inputs and then dividing by the shared\n', '     *              ratio scale, rounded up to the closest base unit.\n', '     */\n', '    function mulRatioTruncateCeil(uint256 x, uint256 ratio)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // e.g. How much mAsset should I burn for this bAsset (x)?\n', '        // 1e18 * 1e8 = 1e26\n', '        uint256 scaled = x.mul(ratio);\n', '        // 1e26 + 9.99e7 = 100..00.999e8\n', '        uint256 ceil = scaled.add(RATIO_SCALE.sub(1));\n', '        // return 100..00.999e8 / 1e8 = 1e18\n', '        return ceil.div(RATIO_SCALE);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\n', '     *      i.e. How much bAsset is this mAsset worth?\n', '     * @param x     Left hand operand in division\n', '     * @param ratio bAsset ratio\n', '     * @return      Result after multiplying the left operand by the scale, and\n', '     *              executing the division on the right hand input.\n', '     */\n', '    function divRatioPrecisely(uint256 x, uint256 ratio)\n', '        internal\n', '        pure\n', '        returns (uint256 c)\n', '    {\n', '        // e.g. 1e14 * 1e8 = 1e22\n', '        uint256 y = x.mul(RATIO_SCALE);\n', '        // return 1e22 / 1e12 = 1e10\n', '        return y.div(ratio);\n', '    }\n', '\n', '    /***************************************\n', '                    HELPERS\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Calculates minimum of two numbers\n', '     * @param x     Left hand input\n', '     * @param y     Right hand input\n', '     * @return      Minimum of the two inputs\n', '     */\n', '    function min(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return x > y ? y : x;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculated maximum of two numbers\n', '     * @param x     Left hand input\n', '     * @param y     Right hand input\n', '     * @return      Maximum of the two inputs\n', '     */\n', '    function max(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return x > y ? x : y;\n', '    }\n', '\n', '    /**\n', '     * @dev Clamps a value to an upper bound\n', '     * @param x           Left hand input\n', '     * @param upperBound  Maximum possible value to return\n', '     * @return            Input x clamped to a maximum value, upperBound\n', '     */\n', '    function clamp(uint256 x, uint256 upperBound)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return x > upperBound ? upperBound : x;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title   MStableHelper\n', ' * @author  Stability Labs Pty. Ltd.\n', ' * @notice  Returns the validity and output of a given redemption\n', ' * @dev     VERSION: 1.0\n', ' *          DATE:    2020-06-18\n', ' */\n', 'contract MStableHelper is IMStableHelper, MassetStructs {\n', '\n', '    using StableMath for uint256;\n', '    using SafeMath for uint256;\n', '\n', '\n', '    /***************************************\n', '                MINT/SWAP/REDEEM\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Returns a valid bAsset with which to mint\n', '     * @param _mAsset Masset addr\n', '     * @return valid bool\n', '     * @return string message\n', '     * @return address of bAsset to mint\n', '     */\n', '    function suggestMintAsset(\n', '        address _mAsset\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            bool,\n', '            string memory,\n', '            address\n', '        )\n', '    {\n', '        require(_mAsset != address(0), "Invalid mAsset");\n', '        // Get the data\n', '        IBasketManager basketManager = IBasketManager(\n', '            IMasset(_mAsset).getBasketManager()\n', '        );\n', '        Basket memory basket = basketManager.getBasket();\n', '        uint256 totalSupply = IMasset(_mAsset).totalSupply();\n', '\n', '        // Calc the max weight delta (i.e is X% away from Max weight)\n', '        uint256 len = basket.bassets.length;\n', '        uint256[] memory maxWeightDelta = new uint256[](len);\n', '        for(uint256 i = 0; i < len; i++){\n', '            Basset memory bAsset = basket.bassets[i];\n', '            uint256 scaledBasset = bAsset.vaultBalance.mulRatioTruncate(bAsset.ratio);\n', '            // e.g. (1e21 * 1e18) / 1e23 = 1e16 or 1%\n', '            uint256 weight = scaledBasset.divPrecisely(totalSupply);\n', '            maxWeightDelta[i] = weight > bAsset.maxWeight ? 0 : bAsset.maxWeight.sub(weight);\n', '            if(bAsset.status != BassetStatus.Normal){\n', '                return (false, "No assets available", address(0));\n', '            }\n', '        }\n', '        // Ideal delta is the bAsset > 10 but closest\n', '        uint256 idealMaxWeight = 0;\n', '        address selected = address(0);\n', '        for(uint256 j = 0; j < len; j++){\n', '            uint256 bAssetDelta = maxWeightDelta[j];\n', '            if(bAssetDelta >= 1e17){\n', '                if(selected == address(0) || bAssetDelta < idealMaxWeight){\n', '                    idealMaxWeight = bAssetDelta;\n', '                    selected = basket.bassets[j].addr;\n', '                }\n', '            }\n', '        }\n', '        if(selected == address(0)){\n', '            return (false, "No assets available", address(0));\n', '        }\n', '        return (true, "", selected);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Gets the maximum input for a valid swap pair\n', '     * @param _mAsset mAsset address (e.g. mUSD)\n', '     * @param _input Asset to input only bAssets accepted\n', '     * @param _output Either a bAsset or the mAsset\n', '     * @return valid\n', '     * @return validity reason\n', '     * @return max input units (in native decimals)\n', '     * @return how much output this input would produce (in native decimals, after any fee)\n', '     */\n', '    function getMaxSwap(\n', '        address _mAsset,\n', '        address _input,\n', '        address _output\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            bool,\n', '            string memory,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        Data memory data = _getData(_mAsset, _input, _output);\n', '        if(!data.isValid) {\n', '          return (false, data.reason, 0, 0);\n', '        }\n', '        uint256 inputMaxWeightUnits = data.totalSupply.mulTruncate(data.input.maxWeight);\n', '        uint256 inputVaultBalanceScaled = data.input.vaultBalance.mulRatioTruncate(\n', '            data.input.ratio\n', '        );\n', '        if (data.isMint) {\n', '            // M = ((t * maxW) - c)/(1-maxW)\n', '            // M = max mint (scaled)\n', '            // t = totalSupply before\n', '            // maxW = max weight %\n', '            // c = vault balance (scaled)\n', '            // num = (t * maxW) - c\n', '            // e.g. 1e22 - 1e21 = 9e21\n', '            uint256 num = inputMaxWeightUnits.sub(inputVaultBalanceScaled);\n', '            // den = 1e18 - maxW\n', '            // e.g. 1e18 - 75e16 = 25e16\n', '            uint256 den = StableMath.getFullScale().sub(data.input.maxWeight);\n', '            uint256 maxMintScaled = den > 0 ? num.divPrecisely(den) : num;\n', '            uint256 maxMint = maxMintScaled.divRatioPrecisely(data.input.ratio);\n', '            maxMintScaled = maxMint.mulRatioTruncate(data.input.ratio);\n', '            return (true, "", maxMint, maxMintScaled);\n', '        } else {\n', '            // get max input\n', '            uint256 maxInputScaled = inputMaxWeightUnits.sub(inputVaultBalanceScaled);\n', '            // get max output\n', '            uint256 outputMaxWeight = data.totalSupply.mulTruncate(data.output.maxWeight);\n', '            uint256 outputVaultBalanceScaled = data.output.vaultBalance.mulRatioTruncate(data.output.ratio);\n', '            // If maxInput = 2, outputVaultBalance = 1, then clamp to 1\n', '            uint256 clampedMax = maxInputScaled > outputVaultBalanceScaled ? outputVaultBalanceScaled : maxInputScaled;\n', '            // if output is overweight, no fee, else fee\n', '            bool applyFee = outputVaultBalanceScaled < outputMaxWeight;\n', '            uint256 maxInputUnits = clampedMax.divRatioPrecisely(data.input.ratio);\n', '            uint256 outputUnitsIncFee = maxInputUnits.mulRatioTruncate(data.input.ratio).divRatioPrecisely(data.output.ratio);\n', '\n', '            uint256 fee = applyFee ? data.mAsset.swapFee() : 0;\n', '            uint256 outputFee = outputUnitsIncFee.mulTruncate(fee);\n', '            return (true, "", maxInputUnits, outputUnitsIncFee.sub(outputFee));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns a valid bAsset to redeem\n', '     * @param _mAsset Masset addr\n', '     * @return valid bool\n', '     * @return string message\n', '     * @return address of bAsset to redeem\n', '     */\n', '    function suggestRedeemAsset(\n', '        address _mAsset\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            bool,\n', '            string memory,\n', '            address\n', '        )\n', '    {\n', '        require(_mAsset != address(0), "Invalid mAsset");\n', '        // Get the data\n', '        IBasketManager basketManager = IBasketManager(\n', '            IMasset(_mAsset).getBasketManager()\n', '        );\n', '        Basket memory basket = basketManager.getBasket();\n', '        uint256 totalSupply = IMasset(_mAsset).totalSupply();\n', '\n', '        // Calc the max weight delta (i.e is X% away from Max weight)\n', '        uint256 len = basket.bassets.length;\n', '        uint256 overweightCount = 0;\n', '        uint256[] memory maxWeightDelta = new uint256[](len);\n', '        \n', '        for(uint256 i = 0; i < len; i++){\n', '            Basset memory bAsset = basket.bassets[i];\n', '            uint256 scaledBasset = bAsset.vaultBalance.mulRatioTruncate(bAsset.ratio);\n', '            // e.g. (1e21 * 1e18) / 1e23 = 1e16 or 1%\n', '            uint256 weight = scaledBasset.divPrecisely(totalSupply);\n', '            if(weight > bAsset.maxWeight) {\n', '                overweightCount++;\n', '            }\n', '            maxWeightDelta[i] = weight > bAsset.maxWeight ? uint256(-1) : bAsset.maxWeight.sub(weight);\n', '            if(bAsset.status != BassetStatus.Normal){\n', '                return (false, "No assets available", address(0));\n', '            }\n', '        }\n', '\n', '        // if > 1 overweight, fail\n', '        if(overweightCount > 1) {\n', '            return (false, "No assets available", address(0));\n', '        } else if(overweightCount == 1){\n', '            // if 1 overweight, choose asset\n', '            for(uint256 j = 0; j < len; j++){\n', '                if(maxWeightDelta[j] == uint256(-1)){\n', '                    return (true, "", basket.bassets[j].addr);\n', '                }\n', '            }\n', '        }\n', '        // else choose highest %\n', '        uint256 lowestDelta = uint256(-1);\n', '        address selected = address(0);\n', '        for(uint256 k = 0; k < len; k++){\n', '            if(maxWeightDelta[k] < lowestDelta) {\n', '                selected = basket.bassets[k].addr;\n', '                lowestDelta = maxWeightDelta[k];\n', '            }\n', '        }\n', '        return (true, "", selected);\n', '    }\n', '\n', '    /**\n', '     * @dev Determines if a given Redemption is valid\n', '     * @param _mAsset Address of the given mAsset (e.g. mUSD)\n', '     * @param _mAssetQuantity Amount of mAsset to redeem (in mUSD units)\n', '     * @param _outputBasset Desired output bAsset\n', '     * @return valid\n', '     * @return validity reason\n', '     * @return output in bAsset units\n', "     * @return bAssetQuantityArg - required input argument to the 'redeem' call\n", '     */\n', '    function getRedeemValidity(\n', '        address _mAsset,\n', '        uint256 _mAssetQuantity,\n', '        address _outputBasset\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            bool,\n', '            string memory,\n', '            uint256 output,\n', '            uint256 bassetQuantityArg\n', '        )\n', '    {\n', '        // Convert the `mAssetQuantity` (input) into bAsset units\n', '        IBasketManager basketManager = IBasketManager(\n', '            IMasset(_mAsset).getBasketManager()\n', '        );\n', '        Basset memory bAsset = basketManager.getBasset(_outputBasset);\n', '        uint256 bAssetQuantity = _mAssetQuantity.divRatioPrecisely(\n', '            bAsset.ratio\n', '        );\n', '\n', '        // Prepare params for internal validity\n', '        address[] memory bAssets = new address[](1);\n', '        uint256[] memory quantities = new uint256[](1);\n', '        bAssets[0] = _outputBasset;\n', '        quantities[0] = bAssetQuantity;\n', '        (\n', '            bool valid,\n', '            string memory reason,\n', '            uint256 bAssetOutput\n', '        ) = _getRedeemValidity(_mAsset, bAssets, quantities);\n', '        return (valid, reason, bAssetOutput, bAssetQuantity);\n', '    }\n', '\n', '\n', '    /***************************************\n', '                    SAVE\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Gets the users savings balance in Masset terms\n', '     * @param _save SAVE contract address\n', '     * @param _user Address of the user\n', '     * @return balance in Masset units\n', '     */\n', '    function getSaveBalance(\n', '        ISavingsContract _save,\n', '        address _user\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            uint256\n', '        )\n', '    {\n', '        require(address(_save) != address(0), "Invalid contract");\n', '        require(_user != address(0), "Invalid user");\n', '\n', '        uint256 credits = _save.creditBalances(_user);\n', '        uint256 rate = _save.exchangeRate();\n', '        require(rate > 0, "Invalid rate");\n', '\n', '        return credits.mulTruncate(rate);\n', '    }\n', '\n', '    /**\n', "     * @dev Returns the 'credit' units required to withdraw a certain\n", '     * amount of Masset from the SAVE contract\n', '     * @param _save SAVE contract address\n', '     * @param _mAssetUnits Amount of mAsset to redeem from SAVE\n', '     * @return input for the redeem function (ie. credit units to redeem)\n', '     */\n', '    function getSaveRedeemInput(\n', '        ISavingsContract _save,\n', '        uint256 _mAssetUnits\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            uint256\n', '        )\n', '    {\n', '        require(address(_save) != address(0), "Invalid contract");\n', '\n', '        uint256 rate = _save.exchangeRate();\n', '        require(rate > 0, "Invalid rate");\n', '\n', '        uint256 credits = _mAssetUnits.divPrecisely(rate);\n', '\n', '        // Add 1 because the amounts always round down\n', '        // e.g. i have 51 credits, e4 10 = 20.4\n', '        // to withdraw 20 i need 20*10/4 = 50 + 1\n', '        return credits + 1;\n', '    }\n', '\n', '\n', '    /***************************************\n', '                    INTERNAL\n', '    ****************************************/\n', '\n', '    struct Data {\n', '        bool isValid;\n', '        string reason;\n', '        IMasset mAsset;\n', '        IBasketManager basketManager;\n', '        bool isMint;\n', '        uint256 totalSupply;\n', '        Basset input;\n', '        Basset output;\n', '    }\n', '\n', '    function _getData(address _mAsset, address _input, address _output) internal view returns (Data memory) {\n', '        bool isMint = _output == _mAsset;\n', '        IMasset mAsset = IMasset(_mAsset);\n', '        IBasketManager basketManager = IBasketManager(\n', '            mAsset.getBasketManager()\n', '        );\n', '        (bool isValid, string memory reason, ) = mAsset\n', '            .getSwapOutput(_input, _output, 1);\n', '        uint256 totalSupply = mAsset.totalSupply();\n', '        Basset memory input = basketManager.getBasset(_input);\n', '        Basset memory output = !isMint ? basketManager.getBasset(_output) : Basset({\n', '            addr: _output,\n', '            ratio: StableMath.getRatioScale(),\n', '            maxWeight: 0,\n', '            vaultBalance: 0,\n', '            status: BassetStatus.Normal,\n', '            isTransferFeeCharged: false\n', '        });\n', '        return Data({\n', '            isValid: isValid,\n', '            reason: reason,\n', '            mAsset: mAsset,\n', '            basketManager: basketManager,\n', '            isMint: isMint,\n', '            totalSupply: totalSupply,\n', '            input: input,\n', '            output: output\n', '        });\n', '    }\n', '\n', '\n', '    function _getRedeemValidity(\n', '        address _mAsset,\n', '        address[] memory _bAssets,\n', '        uint256[] memory _bAssetQuantities\n', '    )\n', '        internal\n', '        view\n', '        returns (\n', '            bool,\n', '            string memory,\n', '            uint256 output\n', '        )\n', '    {\n', '        uint256 bAssetCount = _bAssetQuantities.length;\n', '        require(\n', '            bAssetCount == 1 && bAssetCount == _bAssets.length,\n', '            "Input array mismatch"\n', '        );\n', '\n', '        IMasset mAsset = IMasset(_mAsset);\n', '        IBasketManager basketManager = IBasketManager(\n', '            mAsset.getBasketManager()\n', '        );\n', '\n', '        Basket memory basket = basketManager.getBasket();\n', '\n', '        if (basket.undergoingRecol || basketManager.paused()) {\n', '            return (false, "Invalid basket state", 0);\n', '        }\n', '\n', '        (\n', '            bool redemptionValid,\n', '            string memory reason,\n', '            bool applyFee\n', '        ) = _validateRedeem(\n', '            mAsset,\n', '            _bAssetQuantities,\n', '            _bAssets[0],\n', '            basket.failed,\n', '            mAsset.totalSupply(),\n', '            basket.bassets\n', '        );\n', '        if (!redemptionValid) {\n', '            return (false, reason, 0);\n', '        }\n', '        uint256 fee = applyFee ? mAsset.swapFee() : 0;\n', '        uint256 feeAmount = _bAssetQuantities[0].mulTruncate(fee);\n', '        uint256 outputMinusFee = _bAssetQuantities[0].sub(feeAmount);\n', '        return (true, "", outputMinusFee);\n', '    }\n', '\n', '\n', '    function _validateRedeem(\n', '        IMasset mAsset,\n', '        uint256[] memory quantities,\n', '        address bAsset,\n', '        bool failed,\n', '        uint256 supply,\n', '        Basset[] memory allBassets\n', '    )\n', '        internal\n', '        view\n', '        returns (\n', '            bool,\n', '            string memory,\n', '            bool\n', '        )\n', '    {\n', '        IForgeValidator forgeValidator = IForgeValidator(\n', '            mAsset.forgeValidator()\n', '        );\n', '        uint8[] memory bAssetIndexes = new uint8[](1);\n', '        for (uint8 i = 0; i < uint8(allBassets.length); i++) {\n', '            if (allBassets[i].addr == bAsset) {\n', '                bAssetIndexes[0] = i;\n', '                break;\n', '            }\n', '        }\n', '        return\n', '            forgeValidator.validateRedemption(\n', '                failed,\n', '                supply,\n', '                allBassets,\n', '                bAssetIndexes,\n', '                quantities\n', '            );\n', '    }\n', '\n', '}']