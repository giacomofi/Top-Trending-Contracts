['// File: contracts/libraries/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '//Slightly modified SafeMath library - includes a min and max function, removes useless div function\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function add(int256 a, int256 b) internal pure returns (int256 c) {\n', '        if (b > 0) {\n', '            c = a + b;\n', '            assert(c >= a);\n', '        } else {\n', '            c = a + b;\n', '            assert(c <= a);\n', '        }\n', '    }\n', '\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a > b ? a : b;\n', '    }\n', '\n', '    function max(int256 a, int256 b) internal pure returns (uint256) {\n', '        return a > b ? uint256(a) : uint256(b);\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function sub(int256 a, int256 b) internal pure returns (int256 c) {\n', '        if (b > 0) {\n', '            c = a - b;\n', '            assert(c <= a);\n', '        } else {\n', '            c = a - b;\n', '            assert(c >= a);\n', '        }\n', '\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/TellorStorage.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Tellor Oracle Storage Library\n', ' * @dev Contains all the variables/structs used by Tellor\n', ' */\n', '\n', 'library TellorStorage {\n', '    //Internal struct for use in proof-of-work submission\n', '    struct Details {\n', '        uint256 value;\n', '        address miner;\n', '    }\n', '\n', '    struct Dispute {\n', '        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\n', '        int256 tally; //current tally of votes for - against measure\n', '        bool executed; //is the dispute settled\n', '        bool disputeVotePassed; //did the vote pass?\n', '        bool isPropFork; //true for fork proposal NEW\n', "        address reportedMiner; //miner who alledgedly submitted the 'bad value' will get disputeFee if dispute vote fails\n", "        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\n", '        address proposedForkAddress; //new fork address (if fork proposal)\n', '        mapping(bytes32 => uint256) disputeUintVars;\n', '        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\n', '        //e.g. TellorStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256("requestId")]\n', '        //These are the variables saved in this mapping:\n', '        // uint keccak256("requestId");//apiID of disputed value\n', '        // uint keccak256("timestamp");//timestamp of distputed value\n', '        // uint keccak256("value"); //the value being disputed\n', '        // uint keccak256("minExecutionDate");//7 days from when dispute initialized\n', '        // uint keccak256("numberOfVotes");//the number of parties who have voted on the measure\n', '        // uint keccak256("blockNumber");// the blocknumber for which votes will be calculated from\n', '        // uint keccak256("minerSlot"); //index in dispute array\n', '        // uint keccak256("fee"); //fee paid corresponding to dispute\n', '        mapping(address => bool) voted; //mapping of address to whether or not they voted\n', '    }\n', '\n', '    struct StakeInfo {\n', '        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute 4=ReadyForUnlocking 5=Unlocked\n', '        uint256 startDate; //stake start date\n', '    }\n', '\n', '    //Internal struct to allow balances to be queried by blocknumber for voting purposes\n', '    struct Checkpoint {\n', '        uint128 fromBlock; // fromBlock is the block number that the value was generated from\n', '        uint128 value; // value is the amount of tokens at a specific block number\n', '    }\n', '\n', '    struct Request {\n', '        string queryString; //id to string api\n', '        string dataSymbol; //short name for api request\n', '        bytes32 queryHash; //hash of api string and granularity e.g. keccak256(abi.encodePacked(_sapi,_granularity))\n', '        uint256[] requestTimestamps; //array of all newValueTimestamps requested\n', '        mapping(bytes32 => uint256) apiUintVars;\n', '        //Each of the variables below is saved in the mapping apiUintVars for each api request\n', '        //e.g. requestDetails[_requestId].apiUintVars[keccak256("totalTip")]\n', '        //These are the variables saved in this mapping:\n', '        // uint keccak256("granularity"); //multiplier for miners\n', '        // uint keccak256("requestQPosition"); //index in requestQ\n', '        // uint keccak256("totalTip");//bonus portion of payout\n', '        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\n', '        //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\n', '        mapping(uint256 => uint256) finalValues;\n', '        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\n', '        mapping(uint256 => address[5]) minersByValue;\n', '        mapping(uint256 => uint256[5]) valuesByTimestamp;\n', '    }\n', '\n', '    struct TellorStorageStruct {\n', '        bytes32 currentChallenge; //current challenge to be solved\n', '        uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\n', '        uint256[] newValueTimestamps; //array of all timestamps requested\n', '        Details[5] currentMiners; //This struct is for organizing the five mined values to find the median\n', '        mapping(bytes32 => address) addressVars;\n', '        //Address fields in the Tellor contract are saved the addressVars mapping\n', '        //e.g. addressVars[keccak256("tellorContract")] = address\n', '        //These are the variables saved in this mapping:\n', '        // address keccak256("tellorContract");//Tellor address\n', '        // address  keccak256("_owner");//Tellor Owner address\n', '        // address  keccak256("_deity");//Tellor Owner that can do things at will\n', '        // address  keccak256("pending_owner"); // The proposed new owner\n', '        mapping(bytes32 => uint256) uintVars;\n', '        //uint fields in the Tellor contract are saved the uintVars mapping\n', '        //e.g. uintVars[keccak256("decimals")] = uint\n', '        //These are the variables saved in this mapping:\n', '        // keccak256("decimals");    //18 decimal standard ERC20\n', '        // keccak256("disputeFee");//cost to dispute a mined value\n', '        // keccak256("disputeCount");//totalHistoricalDisputes\n', '        // keccak256("total_supply"); //total_supply of the token in circulation\n', '        // keccak256("stakeAmount");//stakeAmount for miners (we can cut gas if we just hardcode it in...or should it be variable?)\n', '        // keccak256("stakerCount"); //number of parties currently staked\n', '        // keccak256("timeOfLastNewValue"); // time of last challenge solved\n', '        // keccak256("difficulty"); // Difficulty of current block\n', '        // keccak256("currentTotalTips"); //value of highest api/timestamp PayoutPool\n', '        // keccak256("currentRequestId"); //API being mined--updates with the ApiOnQ Id\n', '        // keccak256("requestCount"); // total number of requests through the system\n', '        // keccak256("slotProgress");//Number of miners who have mined this value so far\n', '        // keccak256("miningReward");//Mining Reward in PoWo tokens given to all miners per value\n', '        // keccak256("timeTarget"); //The time between blocks (mined Oracle values)\n', '        // keccak256("_tblock"); //\n', '        // keccak256("runningTips"); // VAriable to track running tips\n', '        // keccak256("currentReward"); // The current reward\n', '        // keccak256("devShare"); // The amount directed towards th devShare\n', '        // keccak256("currentTotalTips"); //\n', '        //This is a boolean that tells you if a given challenge has been completed by a given miner\n', '        mapping(bytes32 => mapping(address => bool)) minersByChallenge;\n', '        mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\n', '        mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\n', '        mapping(uint256 => Dispute) disputesById; //disputeId=> Dispute details\n', '        mapping(address => Checkpoint[]) balances; //balances of a party given blocks\n', '        mapping(address => mapping(address => uint256)) allowed; //allowance for a given party and approver\n', '        mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\n', '        mapping(uint256 => Request) requestDetails; //mapping of apiID to details\n', '        mapping(bytes32 => uint256) requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\n', '        mapping(bytes32 => uint256) disputeIdByDisputeHash; //maps a hash to an ID for each dispute\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/TellorTransfer.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '/**\n', '* @title Tellor Transfer\n', '* @dev Contains the methods related to transfers and ERC20. Tellor.sol and TellorGetters.sol\n', "* reference this library for function's logic.\n", '*/\n', 'library TellorTransfer {\n', '    using SafeMath for uint256;\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value); //ERC20 Approval event\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value); //ERC20 Transfer Event\n', '\n', '    bytes32 public constant stakeAmount = 0x7be108969d31a3f0b261465c71f2b0ba9301cd914d55d9091c3b36a49d4d41b2; //keccak256("stakeAmount")\n', '\n', '    /*Functions*/\n', '\n', '    /**\n', '    * @dev Allows for a transfer of tokens to _to\n', '    * @param _to The address to send tokens to\n', '    * @param _amount The amount of tokens to send\n', '    * @return true if transfer is successful\n', '    */\n', '    function transfer(TellorStorage.TellorStorageStruct storage self, address _to, uint256 _amount) public returns (bool success) {\n', '        doTransfer(self, msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @notice Send _amount tokens to _to from _from on the condition it\n', '    * is approved by _from\n', '    * @param _from The address holding the tokens being transferred\n', '    * @param _to The address of the recipient\n', '    * @param _amount The amount of tokens to be transferred\n', '    * @return True if the transfer was successful\n', '    */\n', '    function transferFrom(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(self.allowed[_from][msg.sender] >= _amount, "Allowance is wrong");\n', '        self.allowed[_from][msg.sender] -= _amount;\n', '        doTransfer(self, _from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev This function approves a _spender an _amount of tokens to use\n', '    * @param _spender address\n', '    * @param _amount amount the spender is being approved for\n', '    * @return true if spender appproved successfully\n', '    */\n', '    function approve(TellorStorage.TellorStorageStruct storage self, address _spender, uint256 _amount) public returns (bool) {\n', '        require(_spender != address(0), "Spender is 0-address");\n', '        require(self.allowed[msg.sender][_spender] == 0 || _amount == 0, "Spender is already approved");\n', '        self.allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @param _user address of party with the balance\n', '    * @param _spender address of spender of parties said balance\n', '    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\n', '    */\n', '    function allowance(TellorStorage.TellorStorageStruct storage self, address _user, address _spender) public view returns (uint256) {\n', '        return self.allowed[_user][_spender];\n', '    }\n', '\n', '    /**\n', '    * @dev Completes POWO transfers by updating the balances on the current block number\n', '    * @param _from address to transfer from\n', '    * @param _to addres to transfer to\n', '    * @param _amount to transfer\n', '    */\n', '    function doTransfer(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount) public {\n', '        require(_amount != 0, "Tried to send non-positive amount");\n', '        require(_to != address(0), "Receiver is 0 address");\n', '        require(allowedToTrade(self, _from, _amount), "Should have sufficient balance to trade");\n', '        uint256 previousBalance = balanceOf(self, _from);\n', '        updateBalanceAtNow(self.balances[_from], previousBalance - _amount);\n', '        previousBalance = balanceOf(self,_to);\n', '        require(previousBalance + _amount >= previousBalance, "Overflow happened"); // Check for overflow\n', '        updateBalanceAtNow(self.balances[_to], previousBalance + _amount);\n', '        emit Transfer(_from, _to, _amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Gets balance of owner specified\n', '    * @param _user is the owner address used to look up the balance\n', '    * @return Returns the balance associated with the passed in _user\n', '    */\n', '    function balanceOf(TellorStorage.TellorStorageStruct storage self, address _user) public view returns (uint256) {\n', '        return balanceOfAt(self, _user, block.number);\n', '    }\n', '\n', '    /**\n', '    * @dev Queries the balance of _user at a specific _blockNumber\n', '    * @param _user The address from which the balance will be retrieved\n', '    * @param _blockNumber The block number when the balance is queried\n', '    * @return The balance at _blockNumber specified\n', '    */\n', '    function balanceOfAt(TellorStorage.TellorStorageStruct storage self, address _user, uint256 _blockNumber) public view returns (uint256) {\n', '        TellorStorage.Checkpoint[] storage checkpoints = self.balances[_user];\n', '        if (checkpoints.length == 0|| checkpoints[0].fromBlock > _blockNumber) {\n', '            return 0;\n', '        } else {\n', '            if (_blockNumber >= checkpoints[checkpoints.length - 1].fromBlock) return checkpoints[checkpoints.length - 1].value;\n', '            // Binary search of the value in the array\n', '            uint256 min = 0;\n', '            uint256 max = checkpoints.length - 2;\n', '            while (max > min) {\n', '                uint256 mid = (max + min + 1) / 2;\n', '                if  (checkpoints[mid].fromBlock ==_blockNumber){\n', '                    return checkpoints[mid].value;\n', '                }else if(checkpoints[mid].fromBlock < _blockNumber) {\n', '                    min = mid;\n', '                } else {\n', '                    max = mid - 1;\n', '                }\n', '            }\n', '            return checkpoints[min].value;\n', '        }\n', '    }\n', '    /**\n', '    * @dev This function returns whether or not a given user is allowed to trade a given amount\n', '    * and removing the staked amount from their balance if they are staked\n', '    * @param _user address of user\n', '    * @param _amount to check if the user can spend\n', '    * @return true if they are allowed to spend the amount being checked\n', '    */\n', '    function allowedToTrade(TellorStorage.TellorStorageStruct storage self, address _user, uint256 _amount) public view returns (bool) { \n', '        if (self.stakerDetails[_user].currentStatus != 0 && self.stakerDetails[_user].currentStatus < 5) {\n', '            //Subtracts the stakeAmount from balance if the _user is staked\n', '            if (balanceOf(self, _user)- self.uintVars[stakeAmount] >= _amount) {\n', '                return true;\n', '            }\n', '            return false;\n', '        } \n', '        return (balanceOf(self, _user) >= _amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Updates balance for from and to on the current block number via doTransfer\n', '    * @param checkpoints gets the mapping for the balances[owner]\n', '    * @param _value is the new balance\n', '    */\n', '    function updateBalanceAtNow(TellorStorage.Checkpoint[] storage checkpoints, uint256 _value) public {\n', '        if (checkpoints.length == 0 || checkpoints[checkpoints.length - 1].fromBlock != block.number) {\n', '           checkpoints.push(TellorStorage.Checkpoint({\n', '                fromBlock : uint128(block.number),\n', '                value : uint128(_value)\n', '            }));\n', '        } else {\n', '            TellorStorage.Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n', '            oldCheckPoint.value = uint128(_value);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/TellorDispute.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '/**\n', '* @title Tellor Dispute\n', "* @dev Contains the methods related to disputes. Tellor.sol references this library for function's logic.\n", '*/\n', '\n', 'library TellorDispute {\n', '    using SafeMath for uint256;\n', '    using SafeMath for int256;\n', '\n', '    //emitted when a new dispute is initialized\n', '    event NewDispute(uint256 indexed _disputeId, uint256 indexed _requestId, uint256 _timestamp, address _miner);\n', '    //emitted when a new vote happens\n', '    event Voted(uint256 indexed _disputeID, bool _position, address indexed _voter, uint256 indexed _voteWeight);\n', '    //emitted upon dispute tally\n', '    event DisputeVoteTallied(uint256 indexed _disputeID, int256 _result, address indexed _reportedMiner, address _reportingParty, bool _active);\n', '    event NewTellorAddress(address _newTellor); //emmited when a proposed fork is voted true\n', '\n', '    /*Functions*/\n', '\n', '    /**\n', '    * @dev Helps initialize a dispute by assigning it a disputeId\n', '    * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\n', '    * invalidated value information to POS voting\n', '    * @param _requestId being disputed\n', '    * @param _timestamp being disputed\n', '    * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\n', '    * requires 5 miners to submit a value.\n', '    */\n', '    function beginDispute(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp, uint256 _minerIndex) public {\n', '        TellorStorage.Request storage _request = self.requestDetails[_requestId];\n', '        require(_request.minedBlockNum[_timestamp] != 0, "Mined block is 0");\n', '        require(_minerIndex < 5, "Miner index is wrong");\n', '\n', '        //_miner is the miner being disputed. For every mined value 5 miners are saved in an array and the _minerIndex\n', '        //provided by the party initiating the dispute\n', '        address _miner = _request.minersByValue[_timestamp][_minerIndex];\n', '        bytes32 _hash = keccak256(abi.encodePacked(_miner, _requestId, _timestamp));\n', '\n', '\n', '\n', '        //Increase the dispute count by 1\n', '        uint256 disputeId = self.uintVars[keccak256("disputeCount")] + 1;\n', '        self.uintVars[keccak256("disputeCount")] = disputeId;\n', '\n', '        //Sets the new disputeCount as the disputeId\n', '\n', '                //Ensures that a dispute is not already open for the that miner, requestId and timestamp\n', '        uint256 hashId = self.disputeIdByDisputeHash[_hash];\n', '        if(hashId != 0){\n', '            self.disputesById[disputeId].disputeUintVars[keccak256("origID")] = hashId;\n', '\n', '        }\n', '        else{\n', '            self.disputeIdByDisputeHash[_hash] = disputeId;\n', '            hashId = disputeId;\n', '        }\n', '        uint256 origID = hashId;\n', '        uint256 dispRounds = self.disputesById[origID].disputeUintVars[keccak256("disputeRounds")] + 1;\n', '        self.disputesById[origID].disputeUintVars[keccak256("disputeRounds")] = dispRounds;\n', '        self.disputesById[origID].disputeUintVars[keccak256(abi.encode(dispRounds))] = disputeId;\n', '        if(disputeId != origID){\n', '            uint256 lastID =  self.disputesById[origID].disputeUintVars[keccak256(abi.encode(dispRounds-1))];\n', '            require(self.disputesById[lastID].disputeUintVars[keccak256("minExecutionDate")] <= now, "Dispute is already open");\n', '            if(self.disputesById[lastID].executed){\n', '                require(now - self.disputesById[lastID].disputeUintVars[keccak256("tallyDate")] <= 1 days, "Time for voting haven\'t elapsed");\n', '            }\n', '        }\n', '        uint256 _fee;\n', '        if (_minerIndex == 2) {\n', '            self.requestDetails[_requestId].apiUintVars[keccak256("disputeCount")] = self.requestDetails[_requestId].apiUintVars[keccak256("disputeCount")] +1;\n', '            //update dispute fee for this case\n', '            _fee = self.uintVars[keccak256("stakeAmount")]*self.requestDetails[_requestId].apiUintVars[keccak256("disputeCount")];\n', '        } else {\n', '\n', '            _fee = self.uintVars[keccak256("disputeFee")] * dispRounds;\n', '        }\n', '\n', '        //maps the dispute to the Dispute struct\n', '        self.disputesById[disputeId] = TellorStorage.Dispute({\n', '            hash: _hash,\n', '            isPropFork: false,\n', '            reportedMiner: _miner,\n', '            reportingParty: msg.sender,\n', '            proposedForkAddress: address(0),\n', '            executed: false,\n', '            disputeVotePassed: false,\n', '            tally: 0\n', '        });\n', '\n', '        //Saves all the dispute variables for the disputeId\n', '        self.disputesById[disputeId].disputeUintVars[keccak256("requestId")] = _requestId;\n', '        self.disputesById[disputeId].disputeUintVars[keccak256("timestamp")] = _timestamp;\n', '        self.disputesById[disputeId].disputeUintVars[keccak256("value")] = _request.valuesByTimestamp[_timestamp][_minerIndex];\n', '        self.disputesById[disputeId].disputeUintVars[keccak256("minExecutionDate")] = now + 2 days * dispRounds;\n', '        self.disputesById[disputeId].disputeUintVars[keccak256("blockNumber")] = block.number;\n', '        self.disputesById[disputeId].disputeUintVars[keccak256("minerSlot")] = _minerIndex;\n', '        self.disputesById[disputeId].disputeUintVars[keccak256("fee")] = _fee;\n', '        TellorTransfer.doTransfer(self, msg.sender, address(this),_fee);\n', '\n', '   \n', '\n', '        //Values are sorted as they come in and the official value is the median of the first five\n', '        //So the "official value" miner is always minerIndex==2. If the official value is being\n', '        //disputed, it sets its status to inDispute(currentStatus = 3) so that users are made aware it is under dispute\n', '        if (_minerIndex == 2) {\n', '            _request.inDispute[_timestamp] = true;\n', '            _request.finalValues[_timestamp] = 0;\n', '        }\n', '        if (self.stakerDetails[_miner].currentStatus != 4){\n', '            self.stakerDetails[_miner].currentStatus = 3;\n', '        }\n', '        emit NewDispute(disputeId, _requestId, _timestamp, _miner);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows token holders to vote\n', '    * @param _disputeId is the dispute id\n', '    * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\n', '    */\n', '    function vote(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId, bool _supportsDispute) public {\n', '        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\n', '\n', '        //Get the voteWeight or the balance of the user at the time/blockNumber the disupte began\n', '        uint256 voteWeight = TellorTransfer.balanceOfAt(self, msg.sender, disp.disputeUintVars[keccak256("blockNumber")]);\n', '\n', '        //Require that the msg.sender has not voted\n', '        require(disp.voted[msg.sender] != true, "Sender has already voted");\n', '\n', '        //Requre that the user had a balance >0 at time/blockNumber the disupte began\n', '        require(voteWeight != 0, "User balance is 0");\n', '\n', '        //ensures miners that are under dispute cannot vote\n', '        require(self.stakerDetails[msg.sender].currentStatus != 3, "Miner is under dispute");\n', '\n', '        //Update user voting status to true\n', '        disp.voted[msg.sender] = true;\n', '\n', '        //Update the number of votes for the dispute\n', '        disp.disputeUintVars[keccak256("numberOfVotes")] += 1;\n', '\n', '        //If the user supports the dispute increase the tally for the dispute by the voteWeight\n', '        //otherwise decrease it\n', '        if (_supportsDispute) {\n', '            disp.tally = disp.tally.add(int256(voteWeight));\n', '        } else {\n', '            disp.tally = disp.tally.sub(int256(voteWeight));\n', '        }\n', '\n', '        //Let the network know the user has voted on the dispute and their casted vote\n', '        emit Voted(_disputeId, _supportsDispute, msg.sender, voteWeight);\n', '    }\n', '\n', '    /**\n', '    * @dev tallies the votes and locks the stake disbursement(currentStatus = 4) if the vote passes\n', '    * @param _disputeId is the dispute id\n', '    */\n', '    function tallyVotes(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId) public {\n', '        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\n', '\n', '        //Ensure this has not already been executed/tallied\n', '        require(disp.executed == false, "Dispute has been already executed");\n', '        require(now >= disp.disputeUintVars[keccak256("minExecutionDate")], "Time for voting haven\'t elapsed");\n', '        require(disp.reportingParty != address(0), "reporting Party is address 0");\n', '        int256  _tally = disp.tally;\n', '        if (_tally > 0) {\n', '            //Set the dispute state to passed/true\n', '            disp.disputeVotePassed = true;\n', '        }\n', '        //If the vote is not a proposed fork\n', '        if (disp.isPropFork == false) {\n', '                //Ensure the time for voting has elapsed\n', '                    TellorStorage.StakeInfo storage stakes = self.stakerDetails[disp.reportedMiner];\n', '                    //If the vote for disputing a value is succesful(disp.tally >0) then unstake the reported\n', '                    // miner and transfer the stakeAmount and dispute fee to the reporting party\n', '                    if(stakes.currentStatus == 3){\n', '                        stakes.currentStatus = 4;\n', '                    }\n', '        } else if (uint(_tally) >= ((self.uintVars[keccak256("total_supply")] * 10) / 100)) {\n', '            emit NewTellorAddress(disp.proposedForkAddress);\n', '        }\n', '        disp.disputeUintVars[keccak256("tallyDate")] = now;\n', '        disp.executed = true;\n', '        emit DisputeVoteTallied(_disputeId, _tally, disp.reportedMiner, disp.reportingParty, disp.disputeVotePassed);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows for a fork to be proposed\n', '    * @param _propNewTellorAddress address for new proposed Tellor\n', '    */\n', '    function proposeFork(TellorStorage.TellorStorageStruct storage self, address _propNewTellorAddress) public {\n', '        bytes32 _hash = keccak256(abi.encode(_propNewTellorAddress));\n', '        TellorTransfer.doTransfer(self, msg.sender, address(this), 100e18); //This is the fork fee (just 100 tokens flat, no refunds)\n', '        self.uintVars[keccak256("disputeCount")]++;\n', '        uint256 disputeId = self.uintVars[keccak256("disputeCount")];\n', '        if(self.disputeIdByDisputeHash[_hash] != 0){\n', '            self.disputesById[disputeId].disputeUintVars[keccak256("origID")] = self.disputeIdByDisputeHash[_hash];\n', '        }\n', '        else{\n', '            self.disputeIdByDisputeHash[_hash] = disputeId;\n', '        }\n', '        uint256 origID = self.disputeIdByDisputeHash[_hash];\n', '\n', '        self.disputesById[origID].disputeUintVars[keccak256("disputeRounds")]++;\n', '        uint256 dispRounds = self.disputesById[origID].disputeUintVars[keccak256("disputeRounds")];\n', '        self.disputesById[origID].disputeUintVars[keccak256(abi.encode(dispRounds))] = disputeId;\n', '        if(disputeId != origID){\n', '            uint256 lastID =  self.disputesById[origID].disputeUintVars[keccak256(abi.encode(dispRounds-1))];\n', '            require(self.disputesById[lastID].disputeUintVars[keccak256("minExecutionDate")] <= now, "Dispute is already open");\n', '            if(self.disputesById[lastID].executed){\n', '                require(now - self.disputesById[lastID].disputeUintVars[keccak256("tallyDate")] <= 1 days, "Time for voting haven\'t elapsed");\n', '            }\n', '        }\n', '        self.disputesById[disputeId] = TellorStorage.Dispute({\n', '            hash: _hash,\n', '            isPropFork: true,\n', '            reportedMiner: msg.sender,\n', '            reportingParty: msg.sender,\n', '            proposedForkAddress: _propNewTellorAddress,\n', '            executed: false,\n', '            disputeVotePassed: false,\n', '            tally: 0\n', '        });\n', '        self.disputesById[disputeId].disputeUintVars[keccak256("blockNumber")] = block.number;\n', '        self.disputesById[disputeId].disputeUintVars[keccak256("minExecutionDate")] = now + 7 days;\n', '    }\n', '\n', '    /**\n', '    * @dev Updates the Tellor address after a proposed fork has \n', '    * passed the vote and day has gone by without a dispute\n', '    * @param _disputeId the disputeId for the proposed fork\n', '    */\n', '    function updateTellor(TellorStorage.TellorStorageStruct storage self, uint _disputeId) public {\n', '        bytes32 _hash = self.disputesById[_disputeId].hash;\n', '        uint256 origID = self.disputeIdByDisputeHash[_hash];\n', '        uint256 lastID =  self.disputesById[origID].disputeUintVars[keccak256(abi.encode(self.disputesById[origID].disputeUintVars[keccak256("disputeRounds")]))];\n', '        TellorStorage.Dispute storage disp = self.disputesById[lastID];\n', '        require(disp.disputeVotePassed == true, "vote needs to pass");\n', '        require(now - disp.disputeUintVars[keccak256("tallyDate")] > 1 days, "Time for voting for further disputes has not passed");\n', '        self.addressVars[keccak256("tellorContract")] = disp.proposedForkAddress;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows disputer to unlock the dispute fee\n', '    * @param _disputeId to unlock fee from\n', '    */\n', '    function unlockDisputeFee (TellorStorage.TellorStorageStruct storage self, uint _disputeId) public {\n', '        uint256 origID = self.disputeIdByDisputeHash[self.disputesById[_disputeId].hash];\n', '        uint256 lastID =  self.disputesById[origID].disputeUintVars[keccak256(abi.encode(self.disputesById[origID].disputeUintVars[keccak256("disputeRounds")]))];\n', '        if(lastID == 0){\n', '            lastID = origID;\n', '        }\n', '        TellorStorage.Dispute storage disp = self.disputesById[origID];\n', '        TellorStorage.Dispute storage last = self.disputesById[lastID];\n', '                //disputeRounds is increased by 1 so that the _id is not a negative number when it is the first time a dispute is initiated\n', '        uint256 dispRounds = disp.disputeUintVars[keccak256("disputeRounds")];\n', '        if(dispRounds == 0){\n', '          dispRounds = 1;  \n', '        }\n', '        uint256 _id;\n', '        require(disp.disputeUintVars[keccak256("paid")] == 0,"already paid out");\n', '        require(now - last.disputeUintVars[keccak256("tallyDate")] > 1 days, "Time for voting haven\'t elapsed");\n', '        TellorStorage.StakeInfo storage stakes = self.stakerDetails[disp.reportedMiner];\n', '        disp.disputeUintVars[keccak256("paid")] = 1;\n', '        if (last.disputeVotePassed == true){\n', '                //Changing the currentStatus and startDate unstakes the reported miner and transfers the stakeAmount\n', '                stakes.startDate = now - (now % 86400);\n', '\n', '                //Reduce the staker count\n', '                self.uintVars[keccak256("stakerCount")] -= 1;\n', '\n', '                //Update the minimum dispute fee that is based on the number of stakers \n', '                updateMinDisputeFee(self);\n', "                //Decreases the stakerCount since the miner's stake is being slashed\n", '                if(stakes.currentStatus == 4){\n', '                    stakes.currentStatus = 5;\n', '                    TellorTransfer.doTransfer(self,disp.reportedMiner,disp.reportingParty,self.uintVars[keccak256("stakeAmount")]);\n', '                    stakes.currentStatus =0 ;\n', '                }\n', '                for(uint i = 0; i < dispRounds;i++){\n', '                    _id = disp.disputeUintVars[keccak256(abi.encode(dispRounds-i))];\n', '                    if(_id == 0){\n', '                        _id = origID;\n', '                    }\n', '                    TellorStorage.Dispute storage disp2 = self.disputesById[_id];\n', '                        //transfer fee adjusted based on number of miners if the minerIndex is not 2(official value)\n', '                    TellorTransfer.doTransfer(self,address(this), disp2.reportingParty, disp2.disputeUintVars[keccak256("fee")]);\n', '                }\n', '            }\n', '            else {\n', '                stakes.currentStatus = 1;\n', '                TellorStorage.Request storage _request = self.requestDetails[disp.disputeUintVars[keccak256("requestId")]];\n', '                if(disp.disputeUintVars[keccak256("minerSlot")] == 2) {\n', "                    //note we still don't put timestamp back into array (is this an issue? (shouldn't be))\n", '                  _request.finalValues[disp.disputeUintVars[keccak256("timestamp")]] = disp.disputeUintVars[keccak256("value")];\n', '                }\n', '                if (_request.inDispute[disp.disputeUintVars[keccak256("timestamp")]] == true) {\n', '                    _request.inDispute[disp.disputeUintVars[keccak256("timestamp")]] = false;\n', '                }\n', '                for(uint i = 0; i < dispRounds;i++){\n', '                    _id = disp.disputeUintVars[keccak256(abi.encode(dispRounds-i))];\n', '                    if(_id != 0){\n', '                        last = self.disputesById[_id];//handling if happens during an upgrade\n', '                    }\n', '                    TellorTransfer.doTransfer(self,address(this),last.reportedMiner,self.disputesById[_id].disputeUintVars[keccak256("fee")]);\n', '                }\n', '            }\n', '\n', '            if (disp.disputeUintVars[keccak256("minerSlot")] == 2) {\n', '                self.requestDetails[disp.disputeUintVars[keccak256("requestId")]].apiUintVars[keccak256("disputeCount")]--;\n', '            } \n', '    }\n', '\n', '    /**\n', '    * @dev This function upates the minimun dispute fee as a function of the amount\n', '    * of staked miners\n', '    */\n', '    function updateMinDisputeFee(TellorStorage.TellorStorageStruct storage self) public {\n', '        uint256 stakeAmount = self.uintVars[keccak256("stakeAmount")];\n', '        uint256 targetMiners = self.uintVars[keccak256("targetMiners")];\n', '        self.uintVars[keccak256("disputeFee")] = SafeMath.max(15e18,\n', '                (stakeAmount-(stakeAmount*(SafeMath.min(targetMiners,self.uintVars[keccak256("stakerCount")])*1000)/\n', '                targetMiners)/1000));\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/Utilities.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '//Functions for retrieving min and Max in 51 length array (requestQ)\n', '//Taken partly from: https://github.com/modular-network/ethereum-libraries-array-utils/blob/master/contracts/Array256Lib.sol\n', '\n', 'library Utilities {\n', '    /**\n', '    * @dev Returns the max value in an array.\n', "    * The zero position here is ignored. It's because \n", "    * there's no null in solidity and we map each address \n", '    * to an index in this array. So when we get 51 parties, \n', '    * and one person is kicked out of the top 50, we \n', '    * assign them a 0, and when you get mined and pulled \n', "    * out of the top 50, also a 0. So then lot's of parties \n", '    * will have zero as the index so we made the array run \n', '    * from 1-51 with zero as nothing.\n', '    * @param data is the array to calculate max from\n', '    * @return max amount and its index within the array\n', '    */\n', '    function getMax(uint256[51] memory data) internal pure returns (uint256 max, uint256 maxIndex) {\n', '        maxIndex = 1;\n', '        max = data[maxIndex];\n', '        for (uint256 i = 2; i < data.length; i++) {\n', '            if (data[i] > max) {\n', '                max = data[i];\n', '                maxIndex = i;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the minimum value in an array.\n', '    * @param data is the array to calculate min from\n', '    * @return min amount and its index within the array\n', '    */\n', '    function getMin(uint256[51] memory data) internal pure returns (uint256 min, uint256 minIndex) {\n', '        minIndex = data.length - 1;\n', '        min = data[minIndex];\n', '        for (uint256 i = data.length - 2; i > 0; i--) {\n', '            if (data[i] < min) {\n', '                min = data[i];\n', '                minIndex = i;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', "    * @dev Returns the 5 requestsId's with the top payouts in an array.\n", '    * @param data is the array to get the top 5 from\n', '    * @return to 5 max amounts and their respective index within the array\n', '    */\n', '    function getMax5(uint256[51] memory data) internal pure returns (uint256[5] memory max, uint256[5] memory maxIndex) {\n', '        uint256 min5 = data[1];\n', '        uint256 minI = 0;\n', '        for(uint256 j=0;j<5;j++){\n', '            max[j]= data[j+1];//max[0]=data[1]\n', '            maxIndex[j] = j+1;//maxIndex[0]= 1\n', '            if(max[j] < min5){\n', '                min5 = max[j];\n', '                minI = j;\n', '            }\n', '        }\n', '        for(uint256 i = 6; i < data.length; i++) {\n', '            if (data[i] > min5) {\n', '                max[minI] = data[i];\n', '                maxIndex[minI] = i;\n', '                min5 = data[i];\n', '                for(uint256 j=0;j<5;j++){\n', '                    if(max[j] < min5){\n', '                        min5 = max[j];\n', '                        minI = j;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/TellorStake.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '/**\n', '* itle Tellor Stake\n', '* @dev Contains the methods related to miners staking and unstaking. Tellor.sol\n', "* references this library for function's logic.\n", '*/\n', '\n', 'library TellorStake {\n', '    event NewStake(address indexed _sender); //Emits upon new staker\n', '    event StakeWithdrawn(address indexed _sender); //Emits when a staker is now no longer staked\n', '    event StakeWithdrawRequested(address indexed _sender); //Emits when a staker begins the 7 day withdraw period\n', '\n', '    /*Functions*/\n', '\n', '    /**\n', '    * @dev This function stakes the five initial miners, sets the supply and all the constant variables.\n', '    * This function is called by the constructor function on TellorMaster.sol\n', '    */\n', '    function init(TellorStorage.TellorStorageStruct storage self) public {\n', '        require(self.uintVars[keccak256("decimals")] == 0, "Too many decimals");\n', '        //Give this contract 6000 Tellor Tributes so that it can stake the initial 6 miners\n', '        TellorTransfer.updateBalanceAtNow(self.balances[address(this)], 2**256 - 1 - 6000e18);\n', '\n', '        // //the initial 5 miner addresses are specfied below\n', '        // //changed payable[5] to 6\n', '        address payable[6] memory _initalMiners = [\n', '            address(0xE037EC8EC9ec423826750853899394dE7F024fee),\n', '            address(0xcdd8FA31AF8475574B8909F135d510579a8087d3),\n', '            address(0xb9dD5AfD86547Df817DA2d0Fb89334A6F8eDd891),\n', '            address(0x230570cD052f40E14C14a81038c6f3aa685d712B),\n', '            address(0x3233afA02644CCd048587F8ba6e99b3C00A34DcC),\n', '            address(0xe010aC6e0248790e08F42d5F697160DEDf97E024)\n', '        ];\n', '        //Stake each of the 5 miners specified above\n', '        for (uint256 i = 0; i < 6; i++) {\n', '            //6th miner to allow for dispute\n', '            //Miner balance is set at 1000e18 at the block that this function is ran\n', '            TellorTransfer.updateBalanceAtNow(self.balances[_initalMiners[i]], 1000e18);\n', '\n', '            newStake(self, _initalMiners[i]);\n', '        }\n', '\n', '        //update the total suppply\n', '        self.uintVars[keccak256("total_supply")] += 6000e18; //6th miner to allow for dispute\n', '        //set Constants\n', '        self.uintVars[keccak256("decimals")] = 18;\n', '        self.uintVars[keccak256("targetMiners")] = 200;\n', '        self.uintVars[keccak256("stakeAmount")] = 1000e18;\n', '        self.uintVars[keccak256("disputeFee")] = 970e18;\n', '        self.uintVars[keccak256("timeTarget")] = 600;\n', '        self.uintVars[keccak256("timeOfLastNewValue")] = now - (now % self.uintVars[keccak256("timeTarget")]);\n', '        self.uintVars[keccak256("difficulty")] = 1;\n', '    }\n', '\n', '    /**\n', '    * @dev This function allows stakers to request to withdraw their stake (no longer stake)\n', '    * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\n', '    * can withdraw the deposit\n', '    */\n', '    function requestStakingWithdraw(TellorStorage.TellorStorageStruct storage self) public {\n', '        TellorStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\n', '        //Require that the miner is staked\n', '        require(stakes.currentStatus == 1, "Miner is not staked");\n', '\n', '        //Change the miner staked to locked to be withdrawStake\n', '        stakes.currentStatus = 2;\n', '\n', '        //Change the startDate to now since the lock up period begins now\n', '        //and the miner can only withdraw 7 days later from now(check the withdraw function)\n', '        stakes.startDate = now - (now % 86400);\n', '\n', '        //Reduce the staker count\n', '        self.uintVars[keccak256("stakerCount")] -= 1;\n', '\n', '        //Update the minimum dispute fee that is based on the number of stakers \n', '        TellorDispute.updateMinDisputeFee(self);\n', '        emit StakeWithdrawRequested(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\n', '    */\n', '    function withdrawStake(TellorStorage.TellorStorageStruct storage self) public {\n', '        TellorStorage.StakeInfo storage stakes = self.stakerDetails[msg.sender];\n', '        //Require the staker has locked for withdraw(currentStatus ==2) and that 7 days have\n', '        //passed by since they locked for withdraw\n', '        require(now - (now % 86400) - stakes.startDate >= 7 days, "7 days didn\'t pass");\n', '        require(stakes.currentStatus == 2, "Miner was not locked for withdrawal");\n', '        stakes.currentStatus = 0;\n', '        emit StakeWithdrawn(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev This function allows miners to deposit their stake.\n', '    */\n', '    function depositStake(TellorStorage.TellorStorageStruct storage self) public {\n', '        newStake(self, msg.sender);\n', '        //self adjusting disputeFee\n', '        TellorDispute.updateMinDisputeFee(self);\n', '    }\n', '\n', '    /**\n', '    * @dev This function is used by the init function to succesfully stake the initial 5 miners.\n', "    * The function updates their status/state and status start date so they are locked it so they can't withdraw\n", '    * and updates the number of stakers in the system.\n', '    */\n', '    function newStake(TellorStorage.TellorStorageStruct storage self, address staker) internal {\n', '        require(TellorTransfer.balanceOf(self, staker) >= self.uintVars[keccak256("stakeAmount")], "Balance is lower than stake amount");\n', '        //Ensure they can only stake if they are not currrently staked or if their stake time frame has ended\n', '        //and they are currently locked for witdhraw\n', '        require(self.stakerDetails[staker].currentStatus == 0 || self.stakerDetails[staker].currentStatus == 2, "Miner is in the wrong state");\n', '        self.uintVars[keccak256("stakerCount")] += 1;\n', '        self.stakerDetails[staker] = TellorStorage.StakeInfo({\n', '            currentStatus: 1, //this resets their stake start date to today\n', '            startDate: now - (now % 86400)\n', '        });\n', '        emit NewStake(staker);\n', '    }\n', '\n', '    /**\n', '    * @dev Getter function for the requestId being mined \n', '    * @return variables for the current minin event: Challenge, 5 RequestId, difficulty and Totaltips\n', '    */\n', '    function getNewCurrentVariables(TellorStorage.TellorStorageStruct storage self) internal view returns(bytes32 _challenge,uint[5] memory _requestIds,uint256 _difficulty, uint256 _tip){\n', '        for(uint i=0;i<5;i++){\n', '            _requestIds[i] =  self.currentMiners[i].value;\n', '        }\n', '        return (self.currentChallenge,_requestIds,self.uintVars[keccak256("difficulty")],self.uintVars[keccak256("currentTotalTips")]);\n', '    }\n', '\n', '    /**\n', '    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\n', '    * @return onDeck/info on top 5 requests(highest payout)-- RequestId, Totaltips\n', '    */\n', '    function getNewVariablesOnDeck(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck) {\n', '        idsOnDeck = getTopRequestIDs(self);\n', '        for(uint i = 0;i<5;i++){\n', '            tipsOnDeck[i] = self.requestDetails[idsOnDeck[i]].apiUintVars[keccak256("totalTip")];\n', '        }\n', '    }\n', '    \n', '    /**\n', '    * @dev Getter function for the top 5 requests with highest payouts. This function is used within the getNewVariablesOnDeck function\n', '    * @return uint256[5] is an array with the top 5(highest payout) _requestIds at the time the function is called\n', '    */\n', '    function getTopRequestIDs(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256[5] memory _requestIds) {\n', '        uint256[5] memory _max;\n', '        uint256[5] memory _index;\n', '        (_max, _index) = Utilities.getMax5(self.requestQ);\n', '        for(uint i=0;i<5;i++){\n', '            if(_max[i] != 0){\n', '                _requestIds[i] = self.requestIdByRequestQIndex[_index[i]];\n', '            }\n', '            else{\n', '                _requestIds[i] = self.currentMiners[4-i].value;\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '   \n', '}\n', '\n', '// File: contracts/libraries/TellorGettersLibrary.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', '* @title Tellor Getters Library\n', '* @dev This is the getter library for all variables in the Tellor Tributes system. TellorGetters references this\n', '* libary for the getters logic\n', '*/\n', 'library TellorGettersLibrary {\n', '    using SafeMath for uint256;\n', '\n', '    event NewTellorAddress(address _newTellor); //emmited when a proposed fork is voted true\n', '\n', '    /*Functions*/\n', '\n', '    //The next two functions are onlyOwner functions.  For Tellor to be truly decentralized, we will need to transfer the Deity to the 0 address.\n', '    //Only needs to be in library\n', '    /**\n', '    * @dev This function allows us to set a new Deity (or remove it)\n', '    * @param _newDeity address of the new Deity of the tellor system\n', '    */\n', '    function changeDeity(TellorStorage.TellorStorageStruct storage self, address _newDeity) internal {\n', '        require(self.addressVars[keccak256("_deity")] == msg.sender, "Sender is not deity");\n', '        self.addressVars[keccak256("_deity")] = _newDeity;\n', '    }\n', '\n', '    //Only needs to be in library\n', '    /**\n', '    * @dev This function allows the deity to upgrade the Tellor System\n', '    * @param _tellorContract address of new updated TellorCore contract\n', '    */\n', '    function changeTellorContract(TellorStorage.TellorStorageStruct storage self, address _tellorContract) internal {\n', '        require(self.addressVars[keccak256("_deity")] == msg.sender, "Sender is not deity");\n', '        self.addressVars[keccak256("tellorContract")] = _tellorContract;\n', '        emit NewTellorAddress(_tellorContract);\n', '    }\n', '\n', '    /*Tellor Getters*/\n', '\n', '    /**\n', '    * @dev This function tells you if a given challenge has been completed by a given miner\n', '    * @param _challenge the challenge to search for\n', '    * @param _miner address that you want to know if they solved the challenge\n', '    * @return true if the _miner address provided solved the\n', '    */\n', '    function didMine(TellorStorage.TellorStorageStruct storage self, bytes32 _challenge, address _miner) public view returns (bool) {\n', '        return self.minersByChallenge[_challenge][_miner];\n', '    }\n', '\n', '    /**\n', '    * @dev Checks if an address voted in a dispute\n', '    * @param _disputeId to look up\n', '    * @param _address of voting party to look up\n', '    * @return bool of whether or not party voted\n', '    */\n', '    function didVote(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId, address _address) internal view returns (bool) {\n', '        return self.disputesById[_disputeId].voted[_address];\n', '    }\n', '\n', '    /**\n', '    * @dev allows Tellor to read data from the addressVars mapping\n', '    * @param _data is the keccak256("variable_name") of the variable that is being accessed.\n', '    * These are examples of how the variables are saved within other functions:\n', '    * addressVars[keccak256("_owner")]\n', '    * addressVars[keccak256("tellorContract")]\n', '    * @return address requested\n', '    */\n', '    function getAddressVars(TellorStorage.TellorStorageStruct storage self, bytes32 _data) internal view returns (address) {\n', '        return self.addressVars[_data];\n', '    }\n', '\n', '    /**\n', '    * @dev Gets all dispute variables\n', '    * @param _disputeId to look up\n', '    * @return bytes32 hash of dispute\n', '    * @return bool executed where true if it has been voted on\n', '    * @return bool disputeVotePassed\n', '    * @return bool isPropFork true if the dispute is a proposed fork\n', '    * @return address of reportedMiner\n', '    * @return address of reportingParty\n', '    * @return address of proposedForkAddress\n', '    * @return uint of requestId\n', '    * @return uint of timestamp\n', '    * @return uint of value\n', '    * @return uint of minExecutionDate\n', '    * @return uint of numberOfVotes\n', '    * @return uint of blocknumber\n', '    * @return uint of minerSlot\n', '    * @return uint of quorum\n', '    * @return uint of fee\n', '    * @return int count of the current tally\n', '    */\n', '    function getAllDisputeVars(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId)\n', '        internal\n', '        view\n', '        returns (bytes32, bool, bool, bool, address, address, address, uint256[9] memory, int256)\n', '    {\n', '        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\n', '        return (\n', '            disp.hash,\n', '            disp.executed,\n', '            disp.disputeVotePassed,\n', '            disp.isPropFork,\n', '            disp.reportedMiner,\n', '            disp.reportingParty,\n', '            disp.proposedForkAddress,\n', '            [\n', '                disp.disputeUintVars[keccak256("requestId")],\n', '                disp.disputeUintVars[keccak256("timestamp")],\n', '                disp.disputeUintVars[keccak256("value")],\n', '                disp.disputeUintVars[keccak256("minExecutionDate")],\n', '                disp.disputeUintVars[keccak256("numberOfVotes")],\n', '                disp.disputeUintVars[keccak256("blockNumber")],\n', '                disp.disputeUintVars[keccak256("minerSlot")],\n', '                disp.disputeUintVars[keccak256("quorum")],\n', '                disp.disputeUintVars[keccak256("fee")]\n', '            ],\n', '            disp.tally\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\n', '    * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\n', '    */\n', '    function getCurrentVariables(TellorStorage.TellorStorageStruct storage self)\n', '        internal\n', '        view\n', '        returns (bytes32, uint256, uint256, string memory, uint256, uint256)\n', '    {\n', '        return (\n', '            self.currentChallenge,\n', '            self.uintVars[keccak256("currentRequestId")],\n', '            self.uintVars[keccak256("difficulty")],\n', '            self.requestDetails[self.uintVars[keccak256("currentRequestId")]].queryString,\n', '            self.requestDetails[self.uintVars[keccak256("currentRequestId")]].apiUintVars[keccak256("granularity")],\n', '            self.requestDetails[self.uintVars[keccak256("currentRequestId")]].apiUintVars[keccak256("totalTip")]\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Checks if a given hash of miner,requestId has been disputed\n', '    * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\n', '    * @return uint disputeId\n', '    */\n', '    function getDisputeIdByDisputeHash(TellorStorage.TellorStorageStruct storage self, bytes32 _hash) internal view returns (uint256) {\n', '        return self.disputeIdByDisputeHash[_hash];\n', '    }\n', '\n', '    /**\n', '    * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\n', '    * @param _disputeId is the dispute id;\n', '    * @param _data the variable to pull from the mapping. _data = keccak256("variable_name") where variable_name is\n', '    * the variables/strings used to save the data in the mapping. The variables names are\n', '    * commented out under the disputeUintVars under the Dispute struct\n', '    * @return uint value for the bytes32 data submitted\n', '    */\n', '    function getDisputeUintVars(TellorStorage.TellorStorageStruct storage self, uint256 _disputeId, bytes32 _data)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return self.disputesById[_disputeId].disputeUintVars[_data];\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the a value for the latest timestamp available\n', '    * @return value for timestamp of last proof of work submited\n', '    * @return true if the is a timestamp for the lastNewValue\n', '    */\n', '    function getLastNewValue(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256, bool) {\n', '        return (\n', '            retrieveData(\n', '                self,\n', '                self.requestIdByTimestamp[self.uintVars[keccak256("timeOfLastNewValue")]],\n', '                self.uintVars[keccak256("timeOfLastNewValue")]\n', '            ),\n', '            true\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the a value for the latest timestamp available\n', '    * @param _requestId being requested\n', "    * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\n", '    */\n', '    function getLastNewValueById(TellorStorage.TellorStorageStruct storage self, uint256 _requestId) internal view returns (uint256, bool) {\n', '        TellorStorage.Request storage _request = self.requestDetails[_requestId];\n', '        if (_request.requestTimestamps.length != 0) {\n', '            return (retrieveData(self, _requestId, _request.requestTimestamps[_request.requestTimestamps.length - 1]), true);\n', '        } else {\n', '            return (0, false);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Gets blocknumber for mined timestamp\n', '    * @param _requestId to look up\n', '    * @param _timestamp is the timestamp to look up blocknumber\n', '    * @return uint of the blocknumber which the dispute was mined\n', '    */\n', '    function getMinedBlockNum(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return self.requestDetails[_requestId].minedBlockNum[_timestamp];\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n', '    * @param _requestId to look up\n', '    * @param _timestamp is the timestamp to look up miners for\n', "    * @return the 5 miners' addresses\n", '    */\n', '    function getMinersByRequestIdAndTimestamp(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\n', '        internal\n', '        view\n', '        returns (address[5] memory)\n', '    {\n', '        return self.requestDetails[_requestId].minersByValue[_timestamp];\n', '    }\n', '\n', '    /**\n', '    * @dev Counts the number of values that have been submited for the request\n', '    * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\n', '    * request so far\n', '    * @param _requestId the requestId to look up\n', '    * @return uint count of the number of values received for the requestId\n', '    */\n', '    function getNewValueCountbyRequestId(TellorStorage.TellorStorageStruct storage self, uint256 _requestId) internal view returns (uint256) {\n', '        return self.requestDetails[_requestId].requestTimestamps.length;\n', '    }\n', '\n', '    /**\n', '    * @dev Getter function for the specified requestQ index\n', '    * @param _index to look up in the requestQ array\n', '    * @return uint of reqeuestId\n', '    */\n', '    function getRequestIdByRequestQIndex(TellorStorage.TellorStorageStruct storage self, uint256 _index) internal view returns (uint256) {\n', '        require(_index <= 50, "RequestQ index is above 50");\n', '        return self.requestIdByRequestQIndex[_index];\n', '    }\n', '\n', '    /**\n', '    * @dev Getter function for requestId based on timestamp\n', '    * @param _timestamp to check requestId\n', '    * @return uint of reqeuestId\n', '    */\n', '    function getRequestIdByTimestamp(TellorStorage.TellorStorageStruct storage self, uint256 _timestamp) internal view returns (uint256) {\n', '        return self.requestIdByTimestamp[_timestamp];\n', '    }\n', '\n', '    /**\n', '    * @dev Getter function for requestId based on the qeuaryHash\n', '    * @param _queryHash hash(of string api and granularity) to check if a request already exists\n', '    * @return uint requestId\n', '    */\n', '    function getRequestIdByQueryHash(TellorStorage.TellorStorageStruct storage self, bytes32 _queryHash) internal view returns (uint256) {\n', '        return self.requestIdByQueryHash[_queryHash];\n', '    }\n', '\n', '    /**\n', '    * @dev Getter function for the requestQ array\n', '    * @return the requestQ arrray\n', '    */\n', '    function getRequestQ(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256[51] memory) {\n', '        return self.requestQ;\n', '    }\n', '\n', '    /**\n', '    * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\n', '    * for the requestId specified\n', '    * @param _requestId to look up\n', '    * @param _data the variable to pull from the mapping. _data = keccak256("variable_name") where variable_name is\n', '    * the variables/strings used to save the data in the mapping. The variables names are\n', '    * commented out under the apiUintVars under the requestDetails struct\n', '    * @return uint value of the apiUintVars specified in _data for the requestId specified\n', '    */\n', '    function getRequestUintVars(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, bytes32 _data)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return self.requestDetails[_requestId].apiUintVars[_data];\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the API struct variables that are not mappings\n', '    * @param _requestId to look up\n', '    * @return string of api to query\n', '    * @return string of symbol of api to query\n', '    * @return bytes32 hash of string\n', '    * @return bytes32 of the granularity(decimal places) requested\n', '    * @return uint of index in requestQ array\n', '    * @return uint of current payout/tip for this requestId\n', '    */\n', '    function getRequestVars(TellorStorage.TellorStorageStruct storage self, uint256 _requestId)\n', '        internal\n', '        view\n', '        returns (string memory, string memory, bytes32, uint256, uint256, uint256)\n', '    {\n', '        TellorStorage.Request storage _request = self.requestDetails[_requestId];\n', '        return (\n', '            _request.queryString,\n', '            _request.dataSymbol,\n', '            _request.queryHash,\n', '            _request.apiUintVars[keccak256("granularity")],\n', '            _request.apiUintVars[keccak256("requestQPosition")],\n', '            _request.apiUintVars[keccak256("totalTip")]\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev This function allows users to retireve all information about a staker\n', '    * @param _staker address of staker inquiring about\n', '    * @return uint current state of staker\n', '    * @return uint startDate of staking\n', '    */\n', '    function getStakerInfo(TellorStorage.TellorStorageStruct storage self, address _staker) internal view returns (uint256, uint256) {\n', '        return (self.stakerDetails[_staker].currentStatus, self.stakerDetails[_staker].startDate);\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n', '    * @param _requestId to look up\n', '    * @param _timestamp is the timestampt to look up miners for\n', '    * @return address[5] array of 5 addresses ofminers that mined the requestId\n', '    */\n', '    function getSubmissionsByTimestamp(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\n', '        internal\n', '        view\n', '        returns (uint256[5] memory)\n', '    {\n', '        return self.requestDetails[_requestId].valuesByTimestamp[_timestamp];\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the timestamp for the value based on their index\n', '    * @param _requestID is the requestId to look up\n', '    * @param _index is the value index to look up\n', '    * @return uint timestamp\n', '    */\n', '    function getTimestampbyRequestIDandIndex(TellorStorage.TellorStorageStruct storage self, uint256 _requestID, uint256 _index)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return self.requestDetails[_requestID].requestTimestamps[_index];\n', '    }\n', '\n', '    /**\n', '    * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\n', '    * @param _data the variable to pull from the mapping. _data = keccak256("variable_name") where variable_name is\n', '    * the variables/strings used to save the data in the mapping. The variables names are\n', '    * commented out under the uintVars under the TellorStorageStruct struct\n', '    * This is an example of how data is saved into the mapping within other functions:\n', '    * self.uintVars[keccak256("stakerCount")]\n', '    * @return uint of specified variable\n', '    */\n', '    function getUintVar(TellorStorage.TellorStorageStruct storage self, bytes32 _data) internal view returns (uint256) {\n', '        return self.uintVars[_data];\n', '    }\n', '\n', '    /**\n', '    * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\n', '    * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\n', '    */\n', '    function getVariablesOnDeck(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256, uint256, string memory) {\n', '        uint256 newRequestId = getTopRequestID(self);\n', '        return (\n', '            newRequestId,\n', '            self.requestDetails[newRequestId].apiUintVars[keccak256("totalTip")],\n', '            self.requestDetails[newRequestId].queryString\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Getter function for the request with highest payout. This function is used within the getVariablesOnDeck function\n', '    * @return uint _requestId of request with highest payout at the time the function is called\n', '    */\n', '    function getTopRequestID(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256 _requestId) {\n', '        uint256 _max;\n', '        uint256 _index;\n', '        (_max, _index) = Utilities.getMax(self.requestQ);\n', '        _requestId = self.requestIdByRequestQIndex[_index];\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n', '    * @param _requestId to looku p\n', '    * @param _timestamp is the timestamp to look up miners for\n', '    * @return bool true if requestId/timestamp is under dispute\n', '    */\n', '    function isInDispute(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp) internal view returns (bool) {\n', '        return self.requestDetails[_requestId].inDispute[_timestamp];\n', '    }\n', '\n', '    /**\n', '    * @dev Retreive value from oracle based on requestId/timestamp\n', '    * @param _requestId being requested\n', '    * @param _timestamp to retreive data/value from\n', '    * @return uint value for requestId/timestamp submitted\n', '    */\n', '    function retrieveData(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _timestamp)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return self.requestDetails[_requestId].finalValues[_timestamp];\n', '    }\n', '\n', '    /**\n', '    * @dev Getter for the total_supply of oracle tokens\n', '    * @return uint total supply\n', '    */\n', '    function totalSupply(TellorStorage.TellorStorageStruct storage self) internal view returns (uint256) {\n', '        return self.uintVars[keccak256("total_supply")];\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/libraries/TellorLibrary.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Tellor Oracle System Library\n', " * @dev Contains the functions' logic for the Tellor contract where miners can submit the proof of work\n", ' * along with the value and smart contracts can requestData and tip miners.\n', ' */\n', 'library TellorLibrary {\n', '    using SafeMath for uint256;\n', '\n', '    bytes32 public constant requestCount = 0x05de9147d05477c0a5dc675aeea733157f5092f82add148cf39d579cafe3dc98; //keccak256("requestCount")\n', '    bytes32 public constant totalTip = 0x2a9e355a92978430eca9c1aa3a9ba590094bac282594bccf82de16b83046e2c3; //keccak256("totalTip")\n', '    bytes32 public constant _tBlock = 0x969ea04b74d02bb4d9e6e8e57236e1b9ca31627139ae9f0e465249932e824502; //keccak256("_tBlock")\n', '    bytes32 public constant timeOfLastNewValue = 0x97e6eb29f6a85471f7cc9b57f9e4c3deaf398cfc9798673160d7798baf0b13a4; //keccak256("timeOfLastNewValue")\n', '    bytes32 public constant difficulty = 0xb12aff7664b16cb99339be399b863feecd64d14817be7e1f042f97e3f358e64e; //keccak256("difficulty")\n', '    bytes32 public constant timeTarget = 0xad16221efc80aaf1b7e69bd3ecb61ba5ffa539adf129c3b4ffff769c9b5bbc33; //keccak256("timeTarget")\n', '    bytes32 public constant runningTips = 0xdb21f0c4accc4f2f5f1045353763a9ffe7091ceaf0fcceb5831858d96cf84631; //keccak256("runningTips")\n', '    bytes32 public constant currentReward = 0x9b6853911475b07474368644a0d922ee13bc76a15cd3e97d3e334326424a47d4; //keccak256("currentReward")\n', '    bytes32 public constant total_supply = 0xb1557182e4359a1f0c6301278e8f5b35a776ab58d39892581e357578fb287836; //keccak256("total_supply")\n', '    bytes32 public constant devShare = 0x8fe9ded8d7c08f720cf0340699024f83522ea66b2bbfb8f557851cb9ee63b54c; //keccak256("devShare")\n', '    bytes32 public constant _owner =  0x9dbc393ddc18fd27b1d9b1b129059925688d2f2d5818a5ec3ebb750b7c286ea6; //keccak256("_owner")\n', '    bytes32 public constant requestQPosition = 0x1e344bd070f05f1c5b3f0b1266f4f20d837a0a8190a3a2da8b0375eac2ba86ea; //keccak256("requestQPosition")\n', '    bytes32 public constant currentTotalTips = 0xd26d9834adf5a73309c4974bf654850bb699df8505e70d4cfde365c417b19dfc; //keccak256("currentTotalTips")\n', '    bytes32 public constant slotProgress =0x6c505cb2db6644f57b42d87bd9407b0f66788b07d0617a2bc1356a0e69e66f9a; //keccak256("slotProgress")\n', '    bytes32 public constant pending_owner = 0x44b2657a0f8a90ed8e62f4c4cceca06eacaa9b4b25751ae1ebca9280a70abd68; //keccak256("pending_owner")\n', '    bytes32 public constant currentRequestId = 0x7584d7d8701714da9c117f5bf30af73b0b88aca5338a84a21eb28de2fe0d93b8; //keccak256("currentRequestId")\n', '\n', '\n', '    event TipAdded(address indexed _sender, uint256 indexed _requestId, uint256 _tip, uint256 _totalTips);\n', '    //emits when a new challenge is created (either on mined block or when a new request is pushed forward on waiting system)\n', '    event NewChallenge(\n', '        bytes32 indexed _currentChallenge,\n', '        uint256[5] _currentRequestId,\n', '        uint256 _difficulty,\n', '        uint256 _totalTips\n', '    );\n', '    //Emits upon a successful Mine, indicates the blocktime at point of the mine and the value mined\n', '    event NewValue(uint256[5] _requestId, uint256 _time, uint256[5] _value, uint256 _totalTips, bytes32 indexed _currentChallenge);\n', '    //Emits upon each mine (5 total) and shows the miner, nonce, and value submitted\n', '    event NonceSubmitted(address indexed _miner, string _nonce, uint256[5] _requestId, uint256[5] _value, bytes32 indexed _currentChallenge);\n', '    event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\n', '    event OwnershipProposed(address indexed _previousOwner, address indexed _newOwner);\n', '\n', '    /*Functions*/\n', '    /**\n', '    * @dev Add tip to Request value from oracle\n', '    * @param _requestId being requested to be mined\n', '    * @param _tip amount the requester is willing to pay to be get on queue. Miners\n', '    * mine the onDeckQueryHash, or the api with the highest payout pool\n', '    */\n', '    function addTip(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _tip) public {\n', '        require(_requestId != 0, "RequestId is 0");\n', '        require(_tip != 0, "Tip should be greater than 0");\n', '        uint256 _count =self.uintVars[requestCount] + 1;\n', '        if(_requestId == _count){\n', '            self.uintVars[requestCount] = _count;\n', '        }\n', '        else{\n', '            require(_requestId < _count, "RequestId is not less than count");\n', '        }\n', '        TellorTransfer.doTransfer(self, msg.sender, address(this), _tip);\n', '        //Update the information for the request that should be mined next based on the tip submitted\n', '        updateOnDeck(self, _requestId, _tip);\n', '        emit TipAdded(msg.sender, _requestId, _tip, self.requestDetails[_requestId].apiUintVars[totalTip]);\n', '    }\n', '\n', '   /**\n', '    * @dev This function is called by submitMiningSolution and adjusts the difficulty, sorts and stores the first\n', '    * 5 values received, pays the miners, the dev share and assigns a new challenge\n', '    * @param _nonce or solution for the PoW  for the requestId\n', '    * @param _requestId for the current request being mined\n', '    */\n', '    function newBlock(TellorStorage.TellorStorageStruct storage self, string memory _nonce, uint256[5] memory _requestId) public {\n', '        TellorStorage.Request storage _tblock = self.requestDetails[self.uintVars[_tBlock]];\n', '        // If the difference between the timeTarget and how long it takes to solve the challenge this updates the challenge\n', '        //difficulty up or donw by the difference between the target time and how long it took to solve the previous challenge\n', '        //otherwise it sets it to 1\n', '        int256 _change = int256(SafeMath.min(1200, (now - self.uintVars[timeOfLastNewValue])));\n', '        int256 _diff = int256(self.uintVars[difficulty]);\n', '        _change = (_diff * (int256(self.uintVars[timeTarget]) - _change)) / 4000;\n', '        if (_change == 0) {\n', '                _change = 1;\n', '            }\n', '        self.uintVars[difficulty]  = uint256(SafeMath.max(_diff + _change,1));\n', '        //Sets time of value submission rounded to 1 minute\n', '        bytes32 _currChallenge = self.currentChallenge;\n', '        uint256 _timeOfLastNewValue = now - (now % 1 minutes);\n', '        self.uintVars[timeOfLastNewValue] = _timeOfLastNewValue;\n', '        uint[5] memory a; \n', '        for (uint k = 0; k < 5; k++) {\n', '            for (uint i = 1; i < 5; i++) {\n', '                uint256 temp = _tblock.valuesByTimestamp[k][i];\n', '                address temp2 = _tblock.minersByValue[k][i];\n', '                uint256 j = i;\n', '                while (j > 0 && temp < _tblock.valuesByTimestamp[k][j - 1]) {\n', '                    _tblock.valuesByTimestamp[k][j] = _tblock.valuesByTimestamp[k][j - 1];\n', '                    _tblock.minersByValue[k][j] = _tblock.minersByValue[k][j - 1];\n', '                    j--;\n', '                }\n', '                if (j < i) {\n', '                    _tblock.valuesByTimestamp[k][j] = temp;\n', '                    _tblock.minersByValue[k][j] = temp2;\n', '                }\n', '            }\n', '            TellorStorage.Request storage _request = self.requestDetails[_requestId[k]];\n', '            //Save the official(finalValue), timestamp of it, 5 miners and their submitted values for it, and its block number\n', '            a = _tblock.valuesByTimestamp[k];\n', '            _request.finalValues[_timeOfLastNewValue] = a[2];\n', '            _request.minersByValue[_timeOfLastNewValue] = _tblock.minersByValue[k];\n', '            _request.valuesByTimestamp[_timeOfLastNewValue] = _tblock.valuesByTimestamp[k];\n', '            delete _tblock.minersByValue[k];\n', '            delete _tblock.valuesByTimestamp[k];\n', '            _request.requestTimestamps.push(_timeOfLastNewValue);\n', '            _request.minedBlockNum[_timeOfLastNewValue] = block.number;\n', '            _request.apiUintVars[totalTip] = 0;\n', '        }\n', '            emit NewValue(\n', '                _requestId,\n', '                _timeOfLastNewValue,\n', '                a,\n', '                self.uintVars[runningTips],\n', '                _currChallenge\n', '            );\n', '        //map the timeOfLastValue to the requestId that was just mined\n', '        self.requestIdByTimestamp[_timeOfLastNewValue] = _requestId[0];\n', '        //add timeOfLastValue to the newValueTimestamps array\n', '        self.newValueTimestamps.push(_timeOfLastNewValue);\n', '\n', '        uint _currReward = self.uintVars[currentReward];\n', '        //WARNING Reusing _timeOfLastNewValue to avoid stack too deep\n', '        _timeOfLastNewValue = _currReward; \n', '        if (_currReward > 1e18) {\n', '            //These number represent the inflation adjustement that started in 03/2019\n', '            _currReward = _currReward - _currReward *  15306316590563/1e18; \n', '            self.uintVars[devShare] = _currReward * 50/100;\n', '            _timeOfLastNewValue = _currReward;\n', '        } else {\n', '            _timeOfLastNewValue = 1e18;\n', '        }\n', '        self.uintVars[currentReward] = _timeOfLastNewValue;\n', '        _currReward = _timeOfLastNewValue;\n', '        uint _devShare = self.uintVars[devShare]; \n', '        //update the total supply\n', '        self.uintVars[total_supply] +=  _devShare + _currReward*5 - (self.uintVars[currentTotalTips]);\n', '        TellorTransfer.doTransfer(self, address(this), self.addressVars[_owner],  _devShare);\n', '        self.uintVars[_tBlock] ++;\n', '\n', '        self.uintVars[currentTotalTips] = 0;\n', '        uint256[5] memory _topId = TellorStake.getTopRequestIDs(self);\n', '        for(uint i = 0; i< 5;i++){\n', '            self.currentMiners[i].value = _topId[i];\n', '            self.requestQ[self.requestDetails[_topId[i]].apiUintVars[requestQPosition]] = 0;\n', '            self.uintVars[currentTotalTips] += self.requestDetails[_topId[i]].apiUintVars[totalTip];\n', '        }\n', '        //Issue the the next challenge\n', '       \n', '        _currChallenge = keccak256(abi.encode(_nonce, _currChallenge, blockhash(block.number - 1)));\n', '        self.currentChallenge = _currChallenge; // Save hash for next proof\n', '        emit NewChallenge(\n', '            _currChallenge,\n', '            _topId,\n', '            self.uintVars[difficulty],\n', '            self.uintVars[currentTotalTips]\n', '        );\n', '    }\n', '\n', '/**\n', '    * @dev This function is called by submitMiningSolution and adjusts the difficulty, sorts and stores the first\n', '    * 5 values received, pays the miners, the dev share and assigns a new challenge\n', '    * @param _nonce or solution for the PoW  for the requestId\n', '    * @param _requestId for the current request being mined\n', '    */\n', '    function newBlock(TellorStorage.TellorStorageStruct storage self, string memory _nonce, uint256 _requestId) public {\n', '        TellorStorage.Request storage _request = self.requestDetails[_requestId];\n', '\n', '        // If the difference between the timeTarget and how long it takes to solve the challenge this updates the challenge\n', '        //difficulty up or donw by the difference between the target time and how long it took to solve the prevous challenge\n', '        //otherwise it sets it to 1\n', '        int256 _change = int256(SafeMath.min(1200, (now - self.uintVars[timeOfLastNewValue])));\n', '       int256 _diff = int256(self.uintVars[difficulty]);\n', '        _change = (_diff * (int256(self.uintVars[timeTarget]) - _change)) / 4000;\n', '        \n', '        if (_change == 0) {\n', '                _change = 1;\n', '            }\n', '        self.uintVars[difficulty]  = uint256(SafeMath.max(_diff+ _change,1));\n', '        //Sets time of value submission rounded to 1 minute\n', '        uint256 _timeOfLastNewValue = now - (now % 1 minutes);\n', '        self.uintVars[timeOfLastNewValue] = _timeOfLastNewValue;\n', '\n', '        //The sorting algorithm that sorts the values of the first five values that come in\n', '        TellorStorage.Details[5] memory a = self.currentMiners;\n', '        uint256 i;\n', '        for (i = 1; i < 5; i++) {\n', '            uint256 temp = a[i].value;\n', '            address temp2 = a[i].miner;\n', '            uint256 j = i;\n', '            while (j > 0 && temp < a[j - 1].value) {\n', '                a[j].value = a[j - 1].value;\n', '                a[j].miner = a[j - 1].miner;\n', '                j--;\n', '            }\n', '            if (j < i) {\n', '                a[j].value = temp;\n', '                a[j].miner = temp2;\n', '            }\n', '        }\n', '\n', '        //Pay the miners \n', '        //adjust by payout = payout * ratio 0.000030612633181126/1e18  \n', '        if(self.uintVars[currentReward] == 0){\n', '            self.uintVars[currentReward] = 5e18;\n', '        }\n', '        if (self.uintVars[currentReward] > 1e18) {\n', '        self.uintVars[currentReward] = self.uintVars[currentReward] - self.uintVars[currentReward] * 30612633181126/1e18; \n', '        self.uintVars[devShare] = self.uintVars[currentReward] * 50/100;\n', '        } else {\n', '            self.uintVars[currentReward] = 1e18;\n', '        }\n', '        for (i = 0; i < 5; i++) {\n', '            TellorTransfer.doTransfer(self, address(this), a[i].miner, self.uintVars[currentReward]  + self.uintVars[currentTotalTips] / 5);\n', '        }\n', '        //update the total supply\n', '        self.uintVars[total_supply] +=  self.uintVars[devShare] + self.uintVars[currentReward]*5 ;\n', '        //pay the dev-share\n', '        TellorTransfer.doTransfer(self, address(this), self.addressVars[_owner],  self.uintVars[devShare]);\n', '        //Save the official(finalValue), timestamp of it, 5 miners and their submitted values for it, and its block number\n', '        _request.finalValues[_timeOfLastNewValue] = a[2].value;\n', '        _request.requestTimestamps.push(_timeOfLastNewValue);\n', '        //these are miners by timestamp\n', '        _request.minersByValue[_timeOfLastNewValue] = [a[0].miner, a[1].miner, a[2].miner, a[3].miner, a[4].miner];\n', '        _request.valuesByTimestamp[_timeOfLastNewValue] = [a[0].value, a[1].value, a[2].value, a[3].value, a[4].value];\n', '        _request.minedBlockNum[_timeOfLastNewValue] = block.number;\n', '        //map the timeOfLastValue to the requestId that was just mined\n', '        self.requestIdByTimestamp[_timeOfLastNewValue] = _requestId;\n', '        //add timeOfLastValue to the newValueTimestamps array\n', '        self.newValueTimestamps.push(_timeOfLastNewValue);\n', '        //re-start the count for the slot progress to zero before the new request mining starts\n', '        self.uintVars[slotProgress] = 0;\n', '\n', '\n', '        \n', '        if(self.uintVars[timeTarget] == 600){\n', '            self.uintVars[timeTarget] = 300;\n', '            self.uintVars[currentReward] = self.uintVars[currentReward]/2;\n', '            self.uintVars[_tBlock] = 1e18;\n', '            self.uintVars[difficulty] = SafeMath.max(1,self.uintVars[difficulty]/3);\n', '        }\n', '        for(i = 0; i< 5;i++){\n', '            self.currentMiners[i].value = i+1;\n', '            self.requestQ[self.requestDetails[i+1].apiUintVars[requestQPosition]] = 0;\n', '            self.uintVars[currentTotalTips] += self.requestDetails[i+1].apiUintVars[totalTip];\n', '        }\n', '        self.currentChallenge = keccak256(abi.encode(_nonce, self.currentChallenge, blockhash(block.number - 1))); // Save hash for next proof\n', '        emit NewChallenge(\n', '            self.currentChallenge,\n', '            [uint256(1),uint256(2),uint256(3),uint256(4),uint256(5)],\n', '            self.uintVars[difficulty],\n', '            self.uintVars[currentTotalTips]\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Proof of work is called by the miner when they submit the solution (proof of work and value)\n', '    * @param _nonce uint submitted by miner\n', '    * @param _requestId the apiId being mined\n', '    * @param _value of api query\n', '    */\n', '    function submitMiningSolution(TellorStorage.TellorStorageStruct storage self, string memory _nonce, uint256 _requestId, uint256 _value)\n', '        public\n', '    {\n', '\n', '        require (self.uintVars[timeTarget] == 600, "Contract has upgraded, call new function");\n', '        //require miner is staked\n', '        require(self.stakerDetails[msg.sender].currentStatus == 1, "Miner status is not staker");\n', '\n', '        //Check the miner is submitting the pow for the current request Id\n', '        require(_requestId == self.uintVars[currentRequestId], "RequestId is wrong");\n', '\n', '        //Saving the challenge information as unique by using the msg.sender\n', '        require(\n', '            uint256(\n', '                sha256(abi.encodePacked(ripemd160(abi.encodePacked(keccak256(abi.encodePacked(self.currentChallenge, msg.sender, _nonce))))))\n', '            ) %\n', '                self.uintVars[difficulty] ==\n', '                0,\n', '            "Incorrect nonce for current challenge"\n', '        );\n', '\n', '        //Make sure the miner does not submit a value more than once\n', '        require(self.minersByChallenge[self.currentChallenge][msg.sender] == false, "Miner already submitted the value");\n', '\n', '        //Save the miner and value received\n', '        self.currentMiners[self.uintVars[slotProgress]].value = _value;\n', '        self.currentMiners[self.uintVars[slotProgress]].miner = msg.sender;\n', '\n', '        //Add to the count how many values have been submitted, since only 5 are taken per request\n', '        self.uintVars[slotProgress]++;\n', '\n', "        //Update the miner status to true once they submit a value so they don't submit more than once\n", '        self.minersByChallenge[self.currentChallenge][msg.sender] = true;\n', '        if (self.uintVars[slotProgress] == 5) {\n', '            newBlock(self, _nonce, _requestId);\n', '        }\n', '    }\n', '\n', '\n', '\n', '\n', '    /**\n', '    * @dev Proof of work is called by the miner when they submit the solution (proof of work and value)\n', '    * @param _nonce uint submitted by miner\n', "    * @param _requestId is the array of the 5 PSR's being mined\n", '    * @param _value is an array of 5 values\n', '    */\n', '    function submitMiningSolution(TellorStorage.TellorStorageStruct storage self, string calldata _nonce,uint256[5] calldata _requestId, uint256[5] calldata _value)\n', '        external\n', '    {\n', '        //Verifying Miner Eligibility\n', '        bytes32 _hashMsgSender = keccak256(abi.encode(msg.sender));\n', '        require(self.stakerDetails[msg.sender].currentStatus == 1, "Miner status is not staker");\n', '        require(now - self.uintVars[_hashMsgSender] > 15 minutes, "Miner can only win rewards once per 15 min");\n', '        require(_requestId[0] ==  self.currentMiners[0].value,"Request ID is wrong");\n', '        require(_requestId[1] ==  self.currentMiners[1].value,"Request ID is wrong");\n', '        require(_requestId[2] ==  self.currentMiners[2].value,"Request ID is wrong");\n', '        require(_requestId[3] ==  self.currentMiners[3].value,"Request ID is wrong");\n', '        require(_requestId[4] ==  self.currentMiners[4].value,"Request ID is wrong");\n', '        self.uintVars[_hashMsgSender] = now;\n', '\n', '        \n', '        bytes32 _currChallenge = self.currentChallenge;\n', '        uint256 _slotProgress = self.uintVars[slotProgress]; \n', '        //Saving the challenge information as unique by using the msg.sender\n', '        require(uint256(\n', '                sha256(abi.encodePacked(ripemd160(abi.encodePacked(keccak256(abi.encodePacked(_currChallenge, msg.sender, _nonce))))))\n', '            ) %\n', '                self.uintVars[difficulty] == 0\n', '                || (now - (now % 1 minutes)) - self.uintVars[timeOfLastNewValue] >= 15 minutes,\n', '            "Incorrect nonce for current challenge"\n', '        );\n', '\n', '        //Checking and updating Miner Status\n', '        require(self.minersByChallenge[_currChallenge][msg.sender] == false, "Miner already submitted the value");\n', "        //Update the miner status to true once they submit a value so they don't submit more than once\n", '        self.minersByChallenge[_currChallenge][msg.sender] = true;\n', '\n', '        //Updating Request\n', '        TellorStorage.Request storage _tblock = self.requestDetails[self.uintVars[_tBlock]];\n', '        _tblock.minersByValue[1][_slotProgress]= msg.sender; \n', '        //Assigng directly is cheaper than using a for loop\n', '        _tblock.valuesByTimestamp[0][_slotProgress] = _value[0];\n', '        _tblock.valuesByTimestamp[1][_slotProgress] = _value[1];\n', '        _tblock.valuesByTimestamp[2][_slotProgress] = _value[2];\n', '        _tblock.valuesByTimestamp[3][_slotProgress] = _value[3];\n', '        _tblock.valuesByTimestamp[4][_slotProgress] = _value[4];\n', '        _tblock.minersByValue[0][self.uintVars[slotProgress]]= msg.sender;\n', '        _tblock.minersByValue[1][self.uintVars[slotProgress]]= msg.sender;\n', '        _tblock.minersByValue[2][self.uintVars[slotProgress]]= msg.sender;\n', '        _tblock.minersByValue[3][self.uintVars[slotProgress]]= msg.sender;\n', '        _tblock.minersByValue[4][self.uintVars[slotProgress]]= msg.sender;\n', '\n', '        //Internal Function Added to allow for more stack variables\n', '        _payReward(self, _slotProgress);\n', '        self.uintVars[slotProgress]++;\n', '\n', '        //If 5 values have been received, adjust the difficulty otherwise sort the values until 5 are received         \n', "        if (_slotProgress + 1 == 5) { //slotProgress has been incremented, but we're using the variable on stack to save gas\n", '            newBlock(self, _nonce, _requestId);\n', '            self.uintVars[slotProgress] = 0;\n', '        }\n', '        emit NonceSubmitted(msg.sender, _nonce, _requestId, _value, _currChallenge);\n', '    }\n', '     /**\n', '    * @dev Internal function to calculate and pay rewards to miners\n', '    * @param _slotProgress A value indicating which position is this miner is withing the first 5.\n', '    */\n', '    function _payReward(TellorStorage.TellorStorageStruct storage self, uint _slotProgress) internal {\n', '        uint _runningTips = self.uintVars[runningTips]; \n', '        uint _currentTotalTips = self.uintVars[currentTotalTips];\n', '        if(_slotProgress == 0){\n', '            _runningTips = _currentTotalTips;\n', '            self.uintVars[runningTips] = _currentTotalTips;\n', '        }\n', '        uint _extraTip = (_currentTotalTips-_runningTips)/(5-_slotProgress);\n', '        TellorTransfer.doTransfer(self, address(this), msg.sender, self.uintVars[currentReward]  + _runningTips / 2 / 5 + _extraTip);\n', '        self.uintVars[currentTotalTips] -= _extraTip;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Allows the current owner to propose transfer control of the contract to a\n', '    * newOwner and the ownership is pending until the new owner calls the claimOwnership\n', '    * function\n', '    * @param _pendingOwner The address to transfer ownership to.\n', '    */\n', '    function proposeOwnership(TellorStorage.TellorStorageStruct storage self, address payable _pendingOwner) public {\n', '        require(msg.sender == self.addressVars[_owner], "Sender is not owner");\n', '        emit OwnershipProposed(self.addressVars[_owner], _pendingOwner);\n', '        self.addressVars[pending_owner] = _pendingOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the new owner to claim control of the contract\n', '    */\n', '    function claimOwnership(TellorStorage.TellorStorageStruct storage self) public {\n', '        require(msg.sender == self.addressVars[pending_owner], "Sender is not pending owner");\n', '        emit OwnershipTransferred(self.addressVars[_owner], self.addressVars[pending_owner]);\n', '        self.addressVars[_owner] = self.addressVars[pending_owner];\n', '    }\n', '\n', '    /**\n', '    * @dev This function updates APIonQ and the requestQ when requestData or addTip are ran\n', '    * @param _requestId being requested\n', '    * @param _tip is the tip to add\n', '    */\n', '    function updateOnDeck(TellorStorage.TellorStorageStruct storage self, uint256 _requestId, uint256 _tip) public {\n', '        TellorStorage.Request storage _request = self.requestDetails[_requestId];\n', '        _request.apiUintVars[totalTip] = _request.apiUintVars[totalTip].add(_tip);\n', '        if(self.currentMiners[0].value == _requestId || self.currentMiners[1].value== _requestId ||self.currentMiners[2].value == _requestId||self.currentMiners[3].value== _requestId || self.currentMiners[4].value== _requestId ){\n', '            self.uintVars[currentTotalTips] += _tip;\n', '        }\n', '        else {\n', '            //if the request is not part of the requestQ[51] array\n', '            //then add to the requestQ[51] only if the _payout/tip is greater than the minimum(tip) in the requestQ[51] array\n', '            if (_request.apiUintVars[requestQPosition] == 0) {\n', '                uint256 _min;\n', '                uint256 _index;\n', '                (_min, _index) = Utilities.getMin(self.requestQ);\n', '                //we have to zero out the oldOne\n', '                //if the _payout is greater than the current minimum payout in the requestQ[51] or if the minimum is zero\n', '                //then add it to the requestQ array aand map its index information to the requestId and the apiUintvars\n', '                if (_request.apiUintVars[totalTip] > _min || _min == 0) {\n', '                    self.requestQ[_index] = _request.apiUintVars[totalTip];\n', '                    self.requestDetails[self.requestIdByRequestQIndex[_index]].apiUintVars[requestQPosition] = 0;\n', '                    self.requestIdByRequestQIndex[_index] = _requestId;\n', '                    _request.apiUintVars[requestQPosition] = _index;\n', '                }\n', '                // else if the requestid is part of the requestQ[51] then update the tip for it\n', '            } else{\n', '                self.requestQ[_request.apiUintVars[requestQPosition]] += _tip;\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '/**********************CHEAT Functions for Testing******************************/\n', '/**********************CHEAT Functions for Testing******************************/\n', '/**********************CHEAT Functions for Testing--No Nonce******************************/\n', '\n', '\n', '    // /*This is a cheat for demo purposes, will delete upon actual launch*/\n', '    // function theLazyCoon(TellorStorage.TellorStorageStruct storage self,address _address, uint _amount) public {\n', '    //     self.uintVars[total_supply] += _amount;\n', '    //     TellorTransfer.updateBalanceAtNow(self.balances[_address],_amount);\n', '    // } \n', '\n', '    // /**\n', '    // * @dev Proof of work is called by the miner when they submit the solution (proof of work and value)\n', '    // * @param _nonce uint submitted by miner\n', '    // * @param _requestId the apiId being mined\n', '    // * @param _value of api query\n', '    // ** OLD!!!!!!!!\n', '    // */\n', '    // function testSubmitMiningSolution(TellorStorage.TellorStorageStruct storage self, string memory _nonce, uint256 _requestId, uint256 _value)\n', '    //     public\n', '    // {\n', '    //     require (self.uintVars[timeTarget] == 600, "Contract has upgraded, call new function");\n', '    //     //require miner is staked\n', '    //     require(self.stakerDetails[msg.sender].currentStatus == 1, "Miner status is not staker");\n', '    //     //Check the miner is submitting the pow for the current request Id\n', '    //     require(_requestId == self.uintVars[currentRequestId], "RequestId is wrong");\n', '    //     //Saving the challenge information as unique by using the msg.sender\n', '    //     // require(\n', '    //     //     uint256(\n', '    //     //         sha256(abi.encodePacked(ripemd160(abi.encodePacked(keccak256(abi.encodePacked(self.currentChallenge, msg.sender, _nonce))))))\n', '    //     //     ) %\n', '    //     //         self.uintVars[difficulty] ==\n', '    //     //         0,\n', '    //     //     "Incorrect nonce for current challenge"\n', '    //     // );\n', '    //     //Make sure the miner does not submit a value more than once\n', '    //     require(self.minersByChallenge[self.currentChallenge][msg.sender] == false, "Miner already submitted the value");\n', '    //     //Save the miner and value received\n', '    //     uint256 _slotProgress = self.uintVars[slotProgress]; \n', '    //     self.currentMiners[_slotProgress].value = _value;\n', '    //     self.currentMiners[_slotProgress].miner = msg.sender;\n', '    //     //Add to the count how many values have been submitted, since only 5 are taken per request\n', '    //     self.uintVars[slotProgress]++;\n', "    //     //Update the miner status to true once they submit a value so they don't submit more than once\n", '    //     self.minersByChallenge[self.currentChallenge][msg.sender] = true;\n', '    //     //If 5 values have been received, adjust the difficulty otherwise sort the values until 5 are received\n', '    //     if (_slotProgress + 1 == 5) {\n', '    //         newBlock(self, _nonce, _requestId);\n', '    //     }\n', '    // }\n', '\n', '    // /**\n', '    // * @dev Proof of work is called by the miner when they submit the solution (proof of work and value)\n', '    // * @param _nonce uint submitted by miner\n', "    // * @param _requestId is the array of the 5 PSR's being mined\n", '    // * @param _value is an array of 5 values\n', '    // */\n', '    // function testSubmitMiningSolution(TellorStorage.TellorStorageStruct storage self, string memory _nonce,uint256[5] memory _requestId, uint256[5] memory _value)\n', '    //     public\n', '    // {\n', '    //     bytes32 _hashMsgSender = keccak256(abi.encode(msg.sender));\n', '    //     require(self.stakerDetails[msg.sender].currentStatus == 1, "Miner status is not staker");\n', '    //     //require(now - self.uintVars[_hashMsgSender] > 15 minutes, "Miner can only win rewards once per 15 min");\n', '    //     require(_requestId[0] ==  self.currentMiners[0].value,"Request ID is wrong");\n', '    //     require(_requestId[1] ==  self.currentMiners[1].value,"Request ID is wrong");\n', '    //     require(_requestId[2] ==  self.currentMiners[2].value,"Request ID is wrong");\n', '    //     require(_requestId[3] ==  self.currentMiners[3].value,"Request ID is wrong");\n', '    //     require(_requestId[4] ==  self.currentMiners[4].value,"Request ID is wrong");\n', '    //     self.uintVars[_hashMsgSender] = now;\n', '\n', '    //     bytes32 _currChallenge = self.currentChallenge;\n', '    //     uint256 _slotProgress = self.uintVars[slotProgress];\n', '\n', '    //     //Saving the challenge information as unique by using the msg.sender\n', '    //     // require(uint256(\n', '    //     //         sha256(abi.encodePacked(ripemd160(abi.encodePacked(keccak256(abi.encodePacked(self.currentChallenge, msg.sender, _nonce))))))\n', '    //     //     ) %\n', '    //     //         self.uintVars[difficulty] == 0\n', '    //     //         || (now - (now % 1 minutes)) - self.uintVars[timeOfLastNewValue] >= 15 minutes,\n', '    //     //     "Incorrect nonce for current challenge"\n', '    //     // );\n', '\n', '    //     //Checking and updating Miner Status\n', '    //     require(self.minersByChallenge[_currChallenge][msg.sender] == false, "Miner already submitted the value");\n', "    //     //Update the miner status to true once they submit a value so they don't submit more than once\n", '    //     self.minersByChallenge[_currChallenge][msg.sender] = true;\n', '\n', '    //     //Updating Request\n', '    //     TellorStorage.Request storage _tblock = self.requestDetails[self.uintVars[_tBlock]];\n', '    //     _tblock.minersByValue[1][_slotProgress]= msg.sender; \n', '    //     //this will fill the currentMiners array\n', '    //     _tblock.valuesByTimestamp[0][_slotProgress] = _value[0];\n', '    //     _tblock.valuesByTimestamp[1][_slotProgress] = _value[1];\n', '    //     _tblock.valuesByTimestamp[2][_slotProgress] = _value[2];\n', '    //     _tblock.valuesByTimestamp[3][_slotProgress] = _value[3];\n', '    //     _tblock.valuesByTimestamp[4][_slotProgress] = _value[4];\n', '    //     //Save the miner and value received\n', '    //     _tblock.minersByValue[0][self.uintVars[slotProgress]]= msg.sender;\n', '    //     _tblock.minersByValue[1][self.uintVars[slotProgress]]= msg.sender;\n', '    //     _tblock.minersByValue[2][self.uintVars[slotProgress]]= msg.sender;\n', '    //     _tblock.minersByValue[3][self.uintVars[slotProgress]]= msg.sender;\n', '    //     _tblock.minersByValue[4][self.uintVars[slotProgress]]= msg.sender;\n', '      \n', '\n', '    //     //Internal Function Added to allow for more stack variables\n', '    //     _payReward(self, _slotProgress);\n', '    //     self.uintVars[slotProgress]++;\n', '\n', '    //     //If 5 values have been received, adjust the difficulty otherwise sort the values until 5 are received \n', "    //     if (_slotProgress + 1 == 5) { //slotProgress has been incremented, but we're using the variable on stack to save gas\n", '    //         newBlock(self, _nonce, _requestId);\n', '    //         self.uintVars[slotProgress] = 0;\n', '    //     }\n', '\n', '    //     emit NonceSubmitted(msg.sender, _nonce, _requestId, _value, _currChallenge);\n', '       \n', '    // }\n', '}\n', '\n', '// File: contracts/Tellor.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Tellor Oracle System\n', ' * @dev Oracle contract where miners can submit the proof of work along with the value.\n', ' * The logic for this contract is in TellorLibrary.sol, TellorDispute.sol, TellorStake.sol,\n', ' * and TellorTransfer.sol\n', ' */\n', 'contract Tellor {\n', '    using SafeMath for uint256;\n', '\n', '    using TellorDispute for TellorStorage.TellorStorageStruct;\n', '    using TellorLibrary for TellorStorage.TellorStorageStruct;\n', '    using TellorStake for TellorStorage.TellorStorageStruct;\n', '    using TellorTransfer for TellorStorage.TellorStorageStruct;\n', '\n', '    TellorStorage.TellorStorageStruct tellor;\n', '\n', '    /*Functions*/\n', '\n', '    /**\n', '    * @dev Helps initialize a dispute by assigning it a disputeId\n', '    * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\n', '    * invalidated value information to POS voting\n', '    * @param _requestId being disputed\n', '    * @param _timestamp being disputed\n', '    * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\n', '    * requires 5 miners to submit a value.\n', '    */\n', '    function beginDispute(uint256 _requestId, uint256 _timestamp, uint256 _minerIndex) external {\n', '        tellor.beginDispute(_requestId, _timestamp, _minerIndex);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows token holders to vote\n', '    * @param _disputeId is the dispute id\n', '    * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\n', '    */\n', '    function vote(uint256 _disputeId, bool _supportsDispute) external {\n', '        tellor.vote(_disputeId, _supportsDispute);\n', '    }\n', '\n', '    /**\n', '    * @dev tallies the votes.\n', '    * @param _disputeId is the dispute id\n', '    */\n', '    function tallyVotes(uint256 _disputeId) external {\n', '        tellor.tallyVotes(_disputeId);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows for a fork to be proposed\n', '    * @param _propNewTellorAddress address for new proposed Tellor\n', '    */\n', '    function proposeFork(address _propNewTellorAddress) external {\n', '        tellor.proposeFork(_propNewTellorAddress);\n', '    }\n', '\n', '    /**\n', '    * @dev Add tip to Request value from oracle\n', '    * @param _requestId being requested to be mined\n', '    * @param _tip amount the requester is willing to pay to be get on queue. Miners\n', '    * mine the onDeckQueryHash, or the api with the highest payout pool\n', '    */\n', '    function addTip(uint256 _requestId, uint256 _tip) external {\n', '        tellor.addTip(_requestId, _tip);\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\n', '    * @param _nonce uint submitted by miner\n', '    * @param _requestId the apiId being mined\n', '    * @param _value of api query\n', '    * \n', '    */\n', '    function submitMiningSolution(string calldata _nonce, uint256 _requestId, uint256 _value) external {\n', '        tellor.submitMiningSolution(_nonce, _requestId, _value);\n', '    }\n', '\n', '    /**\n', '    * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\n', '    * @param _nonce uint submitted by miner\n', "    * @param _requestId is the array of the 5 PSR's being mined\n", '    * @param _value is an array of 5 values\n', '    */\n', '    function submitMiningSolution(string calldata _nonce,uint256[5] calldata _requestId, uint256[5] calldata _value) external {\n', '        tellor.submitMiningSolution(_nonce,_requestId, _value);\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Allows the current owner to propose transfer control of the contract to a\n', '    * newOwner and the ownership is pending until the new owner calls the claimOwnership\n', '    * function\n', '    * @param _pendingOwner The address to transfer ownership to.\n', '    */\n', '    function proposeOwnership(address payable _pendingOwner) external {\n', '        tellor.proposeOwnership(_pendingOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the new owner to claim control of the contract\n', '    */\n', '    function claimOwnership() external {\n', '        tellor.claimOwnership();\n', '    }\n', '\n', '    /**\n', '    * @dev This function allows miners to deposit their stake.\n', '    */\n', '    function depositStake() external {\n', '        tellor.depositStake();\n', '    }\n', '\n', '    /**\n', '    * @dev This function allows stakers to request to withdraw their stake (no longer stake)\n', '    * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\n', '    * can withdraw the stake\n', '    */\n', '    function requestStakingWithdraw() external {\n', '        tellor.requestStakingWithdraw();\n', '    }\n', '\n', '    /**\n', '    * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\n', '    */\n', '    function withdrawStake() external {\n', '        tellor.withdrawStake();\n', '    }\n', '\n', '    /**\n', '    * @dev This function approves a _spender an _amount of tokens to use\n', '    * @param _spender address\n', '    * @param _amount amount the spender is being approved for\n', '    * @return true if spender appproved successfully\n', '    */\n', '    function approve(address _spender, uint256 _amount) external returns (bool) {\n', '        return tellor.approve(_spender, _amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows for a transfer of tokens to _to\n', '    * @param _to The address to send tokens to\n', '    * @param _amount The amount of tokens to send\n', '    * @return true if transfer is successful\n', '    */\n', '    function transfer(address _to, uint256 _amount) external returns (bool) {\n', '        return tellor.transfer(_to, _amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Sends _amount tokens to _to from _from on the condition it\n', '    * is approved by _from\n', '    * @param _from The address holding the tokens being transferred\n', '    * @param _to The address of the recipient\n', '    * @param _amount The amount of tokens to be transferred\n', '    * @return True if the transfer was successful\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool) {\n', '        return tellor.transferFrom(_from, _to, _amount);\n', '    }\n', '\n', '    /**\n', "    * @dev Allows users to access the token's name\n", '    */\n', '    function name() external pure returns (string memory) {\n', '        return "Tellor Tributes";\n', '    }\n', '\n', '    /**\n', "    * @dev Allows users to access the token's symbol\n", '    */\n', '    function symbol() external pure returns (string memory) {\n', '        return "TRB";\n', '    }\n', '\n', '    /**\n', '    * @dev Allows users to access the number of decimals\n', '    */\n', '    function decimals() external pure returns (uint8) {\n', '        return 18;\n', '    }\n', '\n', '    /**\n', "    * @dev Getter for the current variables that include the 5 requests Id's\n", '    * @return the challenge, 5 requestsId, difficulty and tip\n', '    */\n', '    function getNewCurrentVariables() external view returns(bytes32 _challenge,uint[5] memory _requestIds,uint256 _difficutly, uint256 _tip){\n', '        return tellor.getNewCurrentVariables();\n', '    }\n', '\n', '    /**\n', "    * @dev Getter for the top tipped 5 requests Id's\n", '    * @return the 5 requestsId\n', '    */\n', '    function getTopRequestIDs() external view returns(uint256[5] memory _requestIds){\n', '        return tellor.getTopRequestIDs();\n', '    }\n', '\n', '    /**\n', "    * @dev Getter for the 5 requests Id's next in line to get mined\n", '    * @return the 5 requestsId\n', '    */\n', '    function getNewVariablesOnDeck() external view returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck) {\n', '        return tellor.getNewVariablesOnDeck();\n', '    }\n', '\n', '    /**\n', '    * @dev Updates the Tellor address after a proposed fork has \n', '    * passed the vote and day has gone by without a dispute\n', '    * @param _disputeId the disputeId for the proposed fork\n', '    */\n', '     function updateTellor(uint _disputeId) external{\n', '        return tellor.updateTellor(_disputeId);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows disputer to unlock the dispute fee\n', '    * @param _disputeId to unlock fee from\n', '    */\n', '     function unlockDisputeFee (uint _disputeId) external{\n', '        return tellor.unlockDisputeFee(_disputeId);\n', '    }\n', '\n', '    /*******************TEST Functions NOT INCLUDED ON PRODUCTION/MAINNET/RINKEBY******/\n', '    // /*This is a cheat for demo purposes, will delete upon actual launch*/\n', '    // function theLazyCoon(address _address, uint _amount) external {\n', '    //     tellor.theLazyCoon(_address,_amount);\n', '    // }\n', '\n', '    // function testSubmitMiningSolution(string calldata _nonce, uint256 _requestId, uint256 _value) external {\n', '    //     tellor.testSubmitMiningSolution(_nonce, _requestId, _value);\n', '    // }\n', '\n', '    // function testSubmitMiningSolution(string calldata _nonce,uint256[5] calldata _requestId, uint256[5] calldata _value) external {\n', '    //     tellor.testSubmitMiningSolution(_nonce,_requestId, _value);\n', '    // }\n', '    /***************END TEST Functions NOT INCLUDED ON PRODUCTION/MAINNET/RINKEBY******/\n', ' }']