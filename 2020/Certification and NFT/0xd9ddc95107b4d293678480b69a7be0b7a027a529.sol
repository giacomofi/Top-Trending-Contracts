['// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.8;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/library/WadRayMath.sol\n', '\n', '\n', '/******************\n', '@title WadRayMath library\n', '@notice borrowed from Aave V1 open source code https://raw.githubusercontent.com/aave/aave-protocol/master/contracts/libraries/WadRayMath.sol\n', '@author Aave\n', '@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n', ' */\n', '\n', 'library WadRayMath {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 internal constant WAD = 1e18;\n', '    uint256 internal constant halfWAD = WAD / 2;\n', '\n', '    uint256 internal constant RAY = 1e27;\n', '    uint256 internal constant halfRAY = RAY / 2;\n', '\n', '    uint256 internal constant WAD_RAY_RATIO = 1e9;\n', '\n', '    function ray() internal pure returns (uint256) {\n', '        return RAY;\n', '    }\n', '    function wad() internal pure returns (uint256) {\n', '        return WAD;\n', '    }\n', '\n', '    function halfRay() internal pure returns (uint256) {\n', '        return halfRAY;\n', '    }\n', '\n', '    function halfWad() internal pure returns (uint256) {\n', '        return halfWAD;\n', '    }\n', '\n', '    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return halfWAD.add(a.mul(b)).div(WAD);\n', '    }\n', '\n', '    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 halfB = b / 2;\n', '\n', '        return halfB.add(a.mul(WAD)).div(b);\n', '    }\n', '\n', '    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return halfRAY.add(a.mul(b)).div(RAY);\n', '    }\n', '\n', '    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 halfB = b / 2;\n', '\n', '        return halfB.add(a.mul(RAY)).div(b);\n', '    }\n', '\n', '    function rayToWad(uint256 a) internal pure returns (uint256) {\n', '        uint256 halfRatio = WAD_RAY_RATIO / 2;\n', '\n', '        return halfRatio.add(a).div(WAD_RAY_RATIO);\n', '    }\n', '\n', '    function wadToRay(uint256 a) internal pure returns (uint256) {\n', '        return a.mul(WAD_RAY_RATIO);\n', '    }\n', '\n', '    /**\n', '    * @dev calculates base^exp. The code uses the ModExp precompile\n', '    * @return z base^exp, in ray\n', '    */\n', '    //solium-disable-next-line\n', '    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n', '\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rayMul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rayMul(z, x);\n', '            }\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/GSN/Context.sol\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: contracts/access/Roles.sol\n', '\n', '\n', '/**\n', ' * @title Roles\n', ' * @notice copied from openzeppelin-solidity\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev Give an account access to this role.\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(!has(role, account), "Roles: account already has role");\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev Remove an account's access to this role.\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(has(role, account), "Roles: account does not have role");\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if an account has this role.\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0), "Roles: account is the zero address");\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '// File: contracts/access/WhitelistAdminRole.sol\n', '\n', '\n', '/**\n', ' * @title WhitelistAdminRole\n', ' * @notice copied from openzeppelin-solidity\n', ' * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\n', ' */\n', 'contract WhitelistAdminRole is Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistAdminAdded(address indexed account);\n', '    event WhitelistAdminRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelistAdmins;\n', '\n', '    constructor () internal {\n', '        _addWhitelistAdmin(_msgSender());\n', '    }\n', '\n', '    modifier onlyWhitelistAdmin() {\n', '        require(isWhitelistAdmin(_msgSender()), "WhitelistAdminRole: caller does not have the WhitelistAdmin role");\n', '        _;\n', '    }\n', '\n', '    function isWhitelistAdmin(address account) public view returns (bool) {\n', '        return _whitelistAdmins.has(account);\n', '    }\n', '\n', '    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\n', '        _addWhitelistAdmin(account);\n', '    }\n', '\n', '    function renounceWhitelistAdmin() public {\n', '        _removeWhitelistAdmin(_msgSender());\n', '    }\n', '\n', '    function _addWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.add(account);\n', '        emit WhitelistAdminAdded(account);\n', '    }\n', '\n', '    function _removeWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.remove(account);\n', '        emit WhitelistAdminRemoved(account);\n', '    }\n', '}\n', '\n', '// File: contracts/access/WhitelistedRole.sol\n', '\n', '\n', '/**\n', ' * @title WhitelistedRole\n', ' * @notice copied from openzeppelin-solidity\n', ' * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\n', ' * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\n', ' * it), and not Whitelisteds themselves.\n', ' */\n', 'contract WhitelistedRole is Context, WhitelistAdminRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistedAdded(address indexed account);\n', '    event WhitelistedRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelisteds;\n', '\n', '    modifier onlyWhitelisted() {\n', '        require(isWhitelisted(_msgSender()), "WhitelistedRole: caller does not have the Whitelisted role");\n', '        _;\n', '    }\n', '\n', '    function isWhitelisted(address account) public view returns (bool) {\n', '        return _whitelisteds.has(account);\n', '    }\n', '\n', '    function addWhitelisted(address account) public onlyWhitelistAdmin {\n', '        _addWhitelisted(account);\n', '    }\n', '\n', '    function removeWhitelisted(address account) public onlyWhitelistAdmin {\n', '        _removeWhitelisted(account);\n', '    }\n', '\n', '    function renounceWhitelisted() public {\n', '        _removeWhitelisted(_msgSender());\n', '    }\n', '\n', '    function _addWhitelisted(address account) internal {\n', '        _whitelisteds.add(account);\n', '        emit WhitelistedAdded(account);\n', '    }\n', '\n', '    function _removeWhitelisted(address account) internal {\n', '        _whitelisteds.remove(account);\n', '        emit WhitelistedRemoved(account);\n', '    }\n', '}\n', '\n', '// File: contracts/oracle/ILinearDividendOracle.sol\n', '\n', '\n', '/**\n', ' * @title ILinearDividendOracle\n', ' * @notice provides dividend information and calculation strategies for linear dividends.\n', '*/\n', 'interface ILinearDividendOracle {\n', '\n', '    /**\n', '     * @notice calculate the total dividend accrued since last dividend checkpoint to now\n', '     * @param tokenAmount           amount of token being held\n', '     * @param timestamp             timestamp to start calculating dividend accrued\n', '     * @param fromIndex             index in the dividend history that the timestamp falls into\n', '     * @return amount of dividend accrued in 1e18, and the latest dividend index\n', '     */\n', '    function calculateAccruedDividends(\n', '        uint256 tokenAmount,\n', '        uint256 timestamp,\n', '        uint256 fromIndex\n', '    ) external view returns (uint256, uint256);\n', '\n', '    /**\n', '     * @notice calculate the total dividend accrued since last dividend checkpoint to (inclusive) a given dividend index\n', '     * @param tokenAmount           amount of token being held\n', '     * @param timestamp             timestamp to start calculating dividend accrued\n', '     * @param fromIndex             index in the dividend history that the timestamp falls into\n', '     * @param toIndex               index in the dividend history to stop the calculation at, inclusive\n', '     * @return amount of dividend accrued in 1e18, dividend index and timestamp to use for remaining dividends\n', '     */\n', '    function calculateAccruedDividendsBounded(\n', '        uint256 tokenAmount,\n', '        uint256 timestamp,\n', '        uint256 fromIndex,\n', '        uint256 toIndex\n', '    ) external view returns (uint256, uint256, uint256);\n', '\n', '    /**\n', '     * @notice get the current dividend index\n', '     * @return the latest dividend index\n', '     */\n', '    function getCurrentIndex() external view returns (uint256);\n', '\n', '    /**\n', '     * @notice return the current dividend accrual rate, in USD per second\n', '     * @return dividend in USD per second\n', '     */\n', '    function getCurrentValue() external view returns (uint256);\n', '\n', '    /**\n', '     * @notice return the dividend accrual rate, in USD per second, of a given dividend index\n', '     * @return dividend in USD per second of the corresponding dividend phase.\n', '     */\n', '    function getHistoricalValue(uint256 dividendIndex) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/oracle/ManagedLinearDividendOracle.sol\n', '\n', '\n', '/**\n', ' * @title ManagedLinearDividendOracle\n', ' * @notice Provides managed linear dividend rate queries, and calculations\n', '*/\n', 'contract ManagedLinearDividendOracle is ILinearDividendOracle, WhitelistedRole {\n', '    using SafeMath for uint256;\n', '    using WadRayMath for uint256;\n', '\n', '    event DividendUpdated(uint256 value, uint256 timestamp);\n', '\n', '    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n', '\n', '    struct CalcReturnInfo {\n', '        uint256 dividendInWad;\n', '        uint256 index;\n', '        uint256 timestamp;\n', '    }\n', '\n', '    /**\n', '    * @dev records one phase of a given dividend rate\n', '    **/\n', '    struct DividendPhase {\n', '        // amount of usd accrued per second per token in 1e27\n', '        uint256 USDPerSecondInRay;\n', '\n', '        // timestamp for start of this dividend phase\n', '        uint256 start;\n', '\n', '        // timestamp for end of this dividend phase\n', '        uint256 end;\n', '    }\n', '\n', '    DividendPhase[] internal _dividendPhases;\n', '\n', '\n', '    constructor(uint256 USDPerAnnumInWad) public {\n', '        _addWhitelisted(msg.sender);\n', '\n', '        newDividendPhase(USDPerAnnumInWad);\n', '    }\n', '\n', '    /**\n', '     * @notice calculate the total dividend accrued since last dividend checkpoint to now\n', '     * @dev this contains a unbounded loop, use calculateAccruedDividendBounded for determimistic gas cost\n', '     * @param tokenAmount           amount of token being held\n', '     * @param timestamp             timestamp to start calculating dividend accrued\n', '     * @param fromIndex             index in the dividend history that the timestamp falls into\n', '     * @return amount of dividend accrued in 1e18, and the latest dividend index\n', '     */\n', '    function calculateAccruedDividends(\n', '        uint256 tokenAmount,\n', '        uint256 timestamp,\n', '        uint256 fromIndex\n', '    ) external view virtual override returns (uint256, uint256) {\n', '        (uint256 totalDividendInWad, uint256 resultIndex,) = calculateAccruedDividendsBounded(\n', '            tokenAmount,\n', '            timestamp,\n', '            fromIndex,\n', '            _dividendPhases.length.sub(1)\n', '        );\n', '\n', '        return (totalDividendInWad, resultIndex);\n', '    }\n', '\n', '    /**\n', '     * @notice calculate the total dividend accrued since last dividend checkpoint to a given dividend index\n', '     * @param tokenAmount           amount of token being held\n', '     * @param timestamp             timestamp to start calculating dividend accrued\n', '     * @param fromIndex             index in the dividend history that the timestamp falls into\n', '     * @param toIndex               index in the dividend history to stop the calculation at\n', '     * @return amount of dividend accrued in 1e18, dividend index and timestamp to use for remaining dividends\n', '     */\n', '    function calculateAccruedDividendsBounded(\n', '        uint256 tokenAmount,\n', '        uint256 timestamp,\n', '        uint256 fromIndex,\n', '        uint256 toIndex\n', '    ) public view virtual override returns (uint256, uint256, uint256){\n', '        require(toIndex < _dividendPhases.length, "toIndex out of bounds");\n', '        require(fromIndex <= toIndex, "fromIndex must be smaller than or equal to toIndex");\n', '\n', '        // culumative dividend per token, in ray\n', '        uint256 dividendPerToken = 0;\n', '\n', '        uint256 lastIndex = _dividendPhases.length.sub(1);\n', '\n', '        // sanity check, timestamp must match fromIndex\n', '        DividendPhase storage firstPhase = _dividendPhases[fromIndex];\n', '        require(timestamp >= firstPhase.start, "Timestamp must be within the specified starting phase");\n', '\n', '\n', '        if (fromIndex == toIndex && toIndex == lastIndex) {\n', '            // only calculating the last dividend phase\n', '            dividendPerToken = calculatePhaseDividend(timestamp, block.timestamp, firstPhase.USDPerSecondInRay);\n', '        } else {\n', '            // start the 1st phase calculation from the timestamp to phase end\n', '            dividendPerToken = calculatePhaseDividend(timestamp, firstPhase.end, firstPhase.USDPerSecondInRay);\n', '\n', '            for (uint256 i = fromIndex.add(1); i <= toIndex && i < lastIndex; i = i.add(1)) {\n', '                DividendPhase storage phase = _dividendPhases[i];\n', '\n', '                uint256 phaseDividend = calculatePhaseDividend(phase.start, phase.end, phase.USDPerSecondInRay);\n', '\n', '                dividendPerToken = dividendPerToken.add(phaseDividend);\n', '            }\n', '\n', '            if (toIndex == lastIndex) {\n', '                DividendPhase storage lastPhase = _dividendPhases[lastIndex];\n', '\n', '                uint256 phaseDividend = calculatePhaseDividend(lastPhase.start, block.timestamp, lastPhase.USDPerSecondInRay);\n', '\n', '                dividendPerToken = dividendPerToken.add(phaseDividend);\n', '            }\n', '        }\n', '\n', '        // reduce number of local variables to avoid stack too deep\n', '        CalcReturnInfo memory result = CalcReturnInfo(0, 0, 0);\n', '\n', '        if (toIndex == lastIndex) {\n', '            result.index = lastIndex;\n', '            result.timestamp = block.timestamp;\n', '        } else {\n', '            result.index = toIndex.add(1);\n', '            result.timestamp = _dividendPhases[result.index].start;\n', '        }\n', '\n', '        result.dividendInWad = tokenAmount\n', '            .wadToRay()\n', '            .rayMul(dividendPerToken)\n', '            .rayToWad();\n', '\n', '        return (result.dividendInWad, result.index, result.timestamp);\n', '    }\n', '\n', '    /**\n', '     * @notice get the current dividend index\n', '     * @return the latest dividend index\n', '     */\n', '    function getCurrentIndex() external view virtual override returns (uint256) {\n', '        return _dividendPhases.length.sub(1);\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice return the current dividend accrual rate, in USD per second\n', '     * @dev the returned value in 1e18 may not be precise enough\n', '     * @return dividend in USD per second\n', '     */\n', '    function getCurrentValue() external view virtual override returns (uint256) {\n', '        return getHistoricalValue(_dividendPhases.length.sub(1));\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice return the dividend accrual rate, in USD per second, of a given dividend index\n', '     * @dev the returned value in 1e18 may not be precise enough\n', '     * @return dividend in USD per second of the corresponding dividend phase.\n', '     */\n', '    function getHistoricalValue(uint256 dividendIndex) public view virtual override returns (uint256) {\n', '        (uint256 USDPerSecondInRay,,) = getPreciseDividendData(dividendIndex);\n', '\n', '        return USDPerSecondInRay.rayToWad();\n', '    }\n', '\n', '    /**\n', '     * @notice return the precise dividend accural rate in 1e27 for a given dividend index\n', '     * @return dividend in USD per second, and timestamp, of the corresponding dividend index\n', '     */\n', '    function getPreciseDividendData(uint256 dividendIndex) public view virtual returns (uint256, uint256, uint256) {\n', '        require(dividendIndex < _dividendPhases.length, "Dividend index out of bounds");\n', '\n', '        // storage type here points to existing storage, thus consuming less gas than memory\n', '        DividendPhase storage dividendPhase = _dividendPhases[dividendIndex];\n', '\n', '        return (dividendPhase.USDPerSecondInRay, dividendPhase.start, dividendPhase.end);\n', '    }\n', '\n', '    /**\n', '     * @notice admin can update the dividend accrual rate by creating a new dividend phase\n', '     * @param USDPerAnnumInWad     the new USD per annum accrued in 1e18\n', '     * @return  true if success\n', '     */\n', '    function newDividendPhase(uint256 USDPerAnnumInWad) public onlyWhitelisted returns (bool) {\n', '        uint256 rateInRay = USDPerAnnumInWadToPerSecondInRay(USDPerAnnumInWad);\n', '\n', '        if (_dividendPhases.length > 0) {\n', '            DividendPhase storage previousDividendPhase = _dividendPhases[_dividendPhases.length.sub(1)];\n', '\n', '            // phase.end is exclusive in sub calc, thus end of the previous phase should equal start of next phase\n', '            previousDividendPhase.end = block.timestamp;\n', '        }\n', '\n', '        DividendPhase memory newPhase = DividendPhase({ USDPerSecondInRay: rateInRay, start: block.timestamp, end: 0});\n', '        _dividendPhases.push(newPhase);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice convenience method for converting annual dividends to per second dividends with higher precision\n', '     * @param USDPerAnnumInWad       amount of USD accrued over a year in 1e18\n', '     * @return amount of USD accrued per second in 1e27\n', '     */\n', '    function USDPerAnnumInWadToPerSecondInRay(uint256 USDPerAnnumInWad) public pure returns (uint256) {\n', '        return USDPerAnnumInWad\n', '            .wadToRay()\n', '            .div(SECONDS_PER_YEAR);\n', '    }\n', '\n', '    /**\n', '     * @notice calculate the dividend between a time range\n', '     * @param start         start of dividend phase\n', '     * @param end           end of dividend phase\n', '     * @param USDPerSecondInRay     dividend accrual rate\n', '     * @return amount of USD accrued per second in 1e27\n', '     */\n', '    function calculatePhaseDividend(uint256 start, uint256 end, uint256 USDPerSecondInRay) public pure returns (uint256) {\n', '        return end\n', '            .sub(start, "Phase start end mismatch")\n', '            .mul(USDPerSecondInRay);\n', '    }\n', '}']