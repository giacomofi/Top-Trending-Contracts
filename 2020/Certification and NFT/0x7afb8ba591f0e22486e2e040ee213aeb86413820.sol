['// SPDX-License-Identifier: UNLICENSED\n', '/*\n', ' * @title String & slice utility library for Solidity contracts.\n', ' * @author Nick Johnson <arachnid@notdot.net>\n', ' *\n', ' * @dev Functionality in this library is largely implemented using an\n', " *      abstraction called a 'slice'. A slice represents a part of a string -\n", ' *      anything from the entire string to a single character, or even no\n', ' *      characters at all (a 0-length slice). Since a slice only has to specify\n', ' *      an offset and a length, copying and manipulating slices is a lot less\n', ' *      expensive than copying and manipulating the strings they reference.\n', ' *\n', ' *      To further reduce gas costs, most functions on slice that need to return\n', ' *      a slice modify the original one instead of allocating a new one; for\n', ' *      instance, `s.split(".")` will return the text up to the first \'.\',\n', " *      modifying s to only contain the remainder of the string after the '.'.\n", ' *      In situations where you do not want to modify the original slice, you\n', ' *      can make a copy first with `.copy()`, for example:\n', ' *      `s.copy().split(".")`. Try and avoid using this idiom in loops; since\n', ' *      Solidity has no memory management, it will result in allocating many\n', ' *      short-lived slices that are later discarded.\n', ' *\n', ' *      Functions that return two slices come in two versions: a non-allocating\n', ' *      version that takes the second slice as an argument, modifying it in\n', ' *      place, and an allocating version that allocates and returns the second\n', ' *      slice; see `nextRune` for example.\n', ' *\n', ' *      Functions that have to copy string data will return strings rather than\n', ' *      slices; these can be cast back to slices for further processing if\n', ' *      required.\n', ' *\n', ' *      For convenience, some functions are provided with non-modifying\n', ' *      variants that create a new slice and return both; for instance,\n', " *      `s.splitNew('.')` leaves s unmodified, and returns two values\n", ' *      corresponding to the left and right parts of the string.\n', ' */\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/* solium-disable */\n', 'library strings {\n', '    struct slice {\n', '        uint _len;\n', '        uint _ptr;\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure {\n', '        // Copy word-length chunks while possible\n', '        for(; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire string.\n', '     * @param self The string to make a slice from.\n', '     * @return A newly allocated slice containing the entire string.\n', '     */\n', '    function toSlice(string memory self) internal pure returns (slice memory) {\n', '        uint ptr;\n', '        assembly {\n', '            ptr := add(self, 0x20)\n', '        }\n', '        return slice(bytes(self).length, ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the length of a null-terminated bytes32 string.\n', '     * @param self The value to find the length of.\n', '     * @return The length of the string, from 0 to 32.\n', '     */\n', '    function len(bytes32 self) internal pure returns (uint) {\n', '        uint ret;\n', '        if (self == 0)\n', '            return 0;\n', '        if (uint256(self) & 0xffffffffffffffffffffffffffffffff == 0) {\n', '            ret += 16;\n', '            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n', '        }\n', '        if (uint256(self) & 0xffffffffffffffff == 0) {\n', '            ret += 8;\n', '            self = bytes32(uint(self) / 0x10000000000000000);\n', '        }\n', '        if (uint256(self) & 0xffffffff == 0) {\n', '            ret += 4;\n', '            self = bytes32(uint(self) / 0x100000000);\n', '        }\n', '        if (uint256(self) & 0xffff == 0) {\n', '            ret += 2;\n', '            self = bytes32(uint(self) / 0x10000);\n', '        }\n', '        if (uint256(self) & 0xff == 0) {\n', '            ret += 1;\n', '        }\n', '        return 32 - ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire bytes32, interpreted as a\n', '     *      null-terminated utf-8 string.\n', '     * @param self The bytes32 value to convert to a slice.\n', '     * @return A new slice containing the value of the input argument up to the\n', '     *         first null.\n', '     */\n', '    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n', '        // Allocate space for `self` in memory, copy it there, and point ret at it\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(0x40, add(ptr, 0x20))\n', '            mstore(ptr, self)\n', '            mstore(add(ret, 0x20), ptr)\n', '        }\n', '        ret._len = len(self);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a new slice containing the same data as the current slice.\n', '     * @param self The slice to copy.\n', '     * @return A new slice containing the same data as `self`.\n', '     */\n', '    function copy(slice memory self) internal pure returns (slice memory) {\n', '        return slice(self._len, self._ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Copies a slice to a new string.\n', '     * @param self The slice to copy.\n', "     * @return A newly allocated string containing the slice's text.\n", '     */\n', '    function toString(slice memory self) internal pure returns (string memory) {\n', '        string memory ret = new string(self._len);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '\n', '        memcpy(retptr, self._ptr, self._len);\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the length in runes of the slice. Note that this operation\n', '     *      takes time proportional to the length of the slice; avoid using it\n', '     *      in loops, and call `slice.empty()` if you only need to kblock.timestamp whether\n', '     *      the slice is empty or not.\n', '     * @param self The slice to operate on.\n', '     * @return The length of the slice in runes.\n', '     */\n', '    function len(slice memory self) internal pure returns (uint l) {\n', '        // Starting at ptr-31 means the LSB will be the byte we care about\n', '        uint ptr = self._ptr - 31;\n', '        uint end = ptr + self._len;\n', '        for (l = 0; ptr < end; l++) {\n', '            uint8 b;\n', '            assembly { b := and(mload(ptr), 0xFF) }\n', '            if (b < 0x80) {\n', '                ptr += 1;\n', '            } else if(b < 0xE0) {\n', '                ptr += 2;\n', '            } else if(b < 0xF0) {\n', '                ptr += 3;\n', '            } else if(b < 0xF8) {\n', '                ptr += 4;\n', '            } else if(b < 0xFC) {\n', '                ptr += 5;\n', '            } else {\n', '                ptr += 6;\n', '            }\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the slice is empty (has a length of 0).\n', '     * @param self The slice to operate on.\n', '     * @return True if the slice is empty, False otherwise.\n', '     */\n', '    function empty(slice memory self) internal pure returns (bool) {\n', '        return self._len == 0;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a positive number if `other` comes lexicographically after\n', '     *      `self`, a negative number if it comes before, or zero if the\n', '     *      contents of the two slices are equal. Comparison is done per-rune,\n', '     *      on unicode codepoints.\n', '     * @param self The first slice to compare.\n', '     * @param other The second slice to compare.\n', '     * @return The result of the comparison.\n', '     */\n', '    function compare(slice memory self, slice memory other) internal pure returns (int) {\n', '        uint shortest = self._len;\n', '        if (other._len < self._len)\n', '            shortest = other._len;\n', '\n', '        uint selfptr = self._ptr;\n', '        uint otherptr = other._ptr;\n', '        for (uint idx = 0; idx < shortest; idx += 32) {\n', '            uint a;\n', '            uint b;\n', '            assembly {\n', '                a := mload(selfptr)\n', '                b := mload(otherptr)\n', '            }\n', '            if (a != b) {\n', '                // Mask out irrelevant bytes and check again\n', '                uint256 mask = uint256(-1); // 0xffff...\n', '                if(shortest < 32) {\n', '                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n', '                }\n', '                uint256 diff = (a & mask) - (b & mask);\n', '                if (diff != 0)\n', '                    return int(diff);\n', '            }\n', '            selfptr += 32;\n', '            otherptr += 32;\n', '        }\n', '        return int(self._len) - int(other._len);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the two slices contain the same text.\n', '     * @param self The first slice to compare.\n', '     * @param self The second slice to compare.\n', '     * @return True if the slices are equal, false otherwise.\n', '     */\n', '    function equals(slice memory self, slice memory other) internal pure returns (bool) {\n', '        return compare(self, other) == 0;\n', '    }\n', '\n', '    /*\n', '     * @dev Extracts the first rune in the slice into `rune`, advancing the\n', '     *      slice to point to the next rune and returning `self`.\n', '     * @param self The slice to operate on.\n', '     * @param rune The slice that will contain the first rune.\n', '     * @return `rune`.\n', '     */\n', '    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n', '        rune._ptr = self._ptr;\n', '\n', '        if (self._len == 0) {\n', '            rune._len = 0;\n', '            return rune;\n', '        }\n', '\n', '        uint l;\n', '        uint b;\n', '        // Load the first byte of the rune into the LSBs of b\n', '        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n', '        if (b < 0x80) {\n', '            l = 1;\n', '        } else if(b < 0xE0) {\n', '            l = 2;\n', '        } else if(b < 0xF0) {\n', '            l = 3;\n', '        } else {\n', '            l = 4;\n', '        }\n', '\n', '        // Check for truncated codepoints\n', '        if (l > self._len) {\n', '            rune._len = self._len;\n', '            self._ptr += self._len;\n', '            self._len = 0;\n', '            return rune;\n', '        }\n', '\n', '        self._ptr += l;\n', '        self._len -= l;\n', '        rune._len = l;\n', '        return rune;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the first rune in the slice, advancing the slice to point\n', '     *      to the next rune.\n', '     * @param self The slice to operate on.\n', '     * @return A slice containing only the first rune from `self`.\n', '     */\n', '    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n', '        nextRune(self, ret);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the number of the first codepoint in the slice.\n', '     * @param self The slice to operate on.\n', '     * @return The number of the first codepoint in the slice.\n', '     */\n', '    function ord(slice memory self) internal pure returns (uint ret) {\n', '        if (self._len == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint word;\n', '        uint length;\n', '        uint divisor = 2 ** 248;\n', '\n', '        // Load the rune into the MSBs of b\n', '        assembly { word:= mload(mload(add(self, 32))) }\n', '        uint b = word / divisor;\n', '        if (b < 0x80) {\n', '            ret = b;\n', '            length = 1;\n', '        } else if(b < 0xE0) {\n', '            ret = b & 0x1F;\n', '            length = 2;\n', '        } else if(b < 0xF0) {\n', '            ret = b & 0x0F;\n', '            length = 3;\n', '        } else {\n', '            ret = b & 0x07;\n', '            length = 4;\n', '        }\n', '\n', '        // Check for truncated codepoints\n', '        if (length > self._len) {\n', '            return 0;\n', '        }\n', '\n', '        for (uint i = 1; i < length; i++) {\n', '            divisor = divisor / 256;\n', '            b = (word / divisor) & 0xFF;\n', '            if (b & 0xC0 != 0x80) {\n', '                // Invalid UTF-8 sequence\n', '                return 0;\n', '            }\n', '            ret = (ret * 64) | (b & 0x3F);\n', '        }\n', '\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the keccak-256 hash of the slice.\n', '     * @param self The slice to hash.\n', '     * @return The hash of the slice.\n', '     */\n', '    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n', '        assembly {\n', '            ret := keccak256(mload(add(self, 32)), mload(self))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if `self` starts with `needle`.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return True if the slice starts with the provided text, false otherwise.\n', '     */\n', '    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n', '        if (self._len < needle._len) {\n', '            return false;\n', '        }\n', '\n', '        if (self._ptr == needle._ptr) {\n', '            return true;\n', '        }\n', '\n', '        bool equal;\n', '        assembly {\n', '            let length := mload(needle)\n', '            let selfptr := mload(add(self, 0x20))\n', '            let needleptr := mload(add(needle, 0x20))\n', '            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '        }\n', '        return equal;\n', '    }\n', '\n', '    /*\n', '     * @dev If `self` starts with `needle`, `needle` is removed from the\n', '     *      beginning of `self`. Otherwise, `self` is unmodified.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return `self`\n', '     */\n', '    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n', '        if (self._len < needle._len) {\n', '            return self;\n', '        }\n', '\n', '        bool equal = true;\n', '        if (self._ptr != needle._ptr) {\n', '            assembly {\n', '                let length := mload(needle)\n', '                let selfptr := mload(add(self, 0x20))\n', '                let needleptr := mload(add(needle, 0x20))\n', '                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '            }\n', '        }\n', '\n', '        if (equal) {\n', '            self._len -= needle._len;\n', '            self._ptr += needle._len;\n', '        }\n', '\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the slice ends with `needle`.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return True if the slice starts with the provided text, false otherwise.\n', '     */\n', '    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n', '        if (self._len < needle._len) {\n', '            return false;\n', '        }\n', '\n', '        uint selfptr = self._ptr + self._len - needle._len;\n', '\n', '        if (selfptr == needle._ptr) {\n', '            return true;\n', '        }\n', '\n', '        bool equal;\n', '        assembly {\n', '            let length := mload(needle)\n', '            let needleptr := mload(add(needle, 0x20))\n', '            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '        }\n', '\n', '        return equal;\n', '    }\n', '\n', '    /*\n', '     * @dev If `self` ends with `needle`, `needle` is removed from the\n', '     *      end of `self`. Otherwise, `self` is unmodified.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return `self`\n', '     */\n', '    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n', '        if (self._len < needle._len) {\n', '            return self;\n', '        }\n', '\n', '        uint selfptr = self._ptr + self._len - needle._len;\n', '        bool equal = true;\n', '        if (selfptr != needle._ptr) {\n', '            assembly {\n', '                let length := mload(needle)\n', '                let needleptr := mload(add(needle, 0x20))\n', '                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '            }\n', '        }\n', '\n', '        if (equal) {\n', '            self._len -= needle._len;\n', '        }\n', '\n', '        return self;\n', '    }\n', '\n', '    // Returns the memory address of the first byte of the first occurrence of\n', '    // `needle` in `self`, or the first byte after `self` if not found.\n', '    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n', '        uint ptr = selfptr;\n', '        uint idx;\n', '\n', '        if (needlelen <= selflen) {\n', '            if (needlelen <= 32) {\n', '                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n', '\n', '                bytes32 needledata;\n', '                assembly { needledata := and(mload(needleptr), mask) }\n', '\n', '                uint end = selfptr + selflen - needlelen;\n', '                bytes32 ptrdata;\n', '                assembly { ptrdata := and(mload(ptr), mask) }\n', '\n', '                while (ptrdata != needledata) {\n', '                    if (ptr >= end)\n', '                        return selfptr + selflen;\n', '                    ptr++;\n', '                    assembly { ptrdata := and(mload(ptr), mask) }\n', '                }\n', '                return ptr;\n', '            } else {\n', '                // For long needles, use hashing\n', '                bytes32 hash;\n', '                assembly { hash := keccak256(needleptr, needlelen) }\n', '\n', '                for (idx = 0; idx <= selflen - needlelen; idx++) {\n', '                    bytes32 testHash;\n', '                    assembly { testHash := keccak256(ptr, needlelen) }\n', '                    if (hash == testHash)\n', '                        return ptr;\n', '                    ptr += 1;\n', '                }\n', '            }\n', '        }\n', '        return selfptr + selflen;\n', '    }\n', '\n', '    // Returns the memory address of the first byte after the last occurrence of\n', '    // `needle` in `self`, or the address of `self` if not found.\n', '    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n', '        uint ptr;\n', '\n', '        if (needlelen <= selflen) {\n', '            if (needlelen <= 32) {\n', '                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n', '\n', '                bytes32 needledata;\n', '                assembly { needledata := and(mload(needleptr), mask) }\n', '\n', '                ptr = selfptr + selflen - needlelen;\n', '                bytes32 ptrdata;\n', '                assembly { ptrdata := and(mload(ptr), mask) }\n', '\n', '                while (ptrdata != needledata) {\n', '                    if (ptr <= selfptr)\n', '                        return selfptr;\n', '                    ptr--;\n', '                    assembly { ptrdata := and(mload(ptr), mask) }\n', '                }\n', '                return ptr + needlelen;\n', '            } else {\n', '                // For long needles, use hashing\n', '                bytes32 hash;\n', '                assembly { hash := keccak256(needleptr, needlelen) }\n', '                ptr = selfptr + (selflen - needlelen);\n', '                while (ptr >= selfptr) {\n', '                    bytes32 testHash;\n', '                    assembly { testHash := keccak256(ptr, needlelen) }\n', '                    if (hash == testHash)\n', '                        return ptr + needlelen;\n', '                    ptr -= 1;\n', '                }\n', '            }\n', '        }\n', '        return selfptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Modifies `self` to contain everything from the first occurrence of\n', '     *      `needle` to the end of the slice. `self` is set to the empty slice\n', '     *      if `needle` is not found.\n', '     * @param self The slice to search and modify.\n', '     * @param needle The text to search for.\n', '     * @return `self`.\n', '     */\n', '    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        self._len -= ptr - self._ptr;\n', '        self._ptr = ptr;\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Modifies `self` to contain the part of the string from the start of\n', '     *      `self` to the end of the first occurrence of `needle`. If `needle`\n', '     *      is not found, `self` is set to the empty slice.\n', '     * @param self The slice to search and modify.\n', '     * @param needle The text to search for.\n', '     * @return `self`.\n', '     */\n', '    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\n', '        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        self._len = ptr - self._ptr;\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything after the first\n', '     *      occurrence of `needle`, and `token` to everything before it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and `token` is set to the entirety of `self`.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @param token An output parameter to which the first token is written.\n', '     * @return `token`.\n', '     */\n', '    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        token._ptr = self._ptr;\n', '        token._len = ptr - self._ptr;\n', '        if (ptr == self._ptr + self._len) {\n', '            // Not found\n', '            self._len = 0;\n', '        } else {\n', '            self._len -= token._len + needle._len;\n', '            self._ptr = ptr + needle._len;\n', '        }\n', '        return token;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything after the first\n', '     *      occurrence of `needle`, and returning everything before it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and the entirety of `self` is returned.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The part of `self` up to the first occurrence of `delim`.\n', '     */\n', '    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n', '        split(self, needle, token);\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything before the last\n', '     *      occurrence of `needle`, and `token` to everything after it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and `token` is set to the entirety of `self`.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @param token An output parameter to which the first token is written.\n', '     * @return `token`.\n', '     */\n', '    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n', '        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        token._ptr = ptr;\n', '        token._len = self._len - (ptr - self._ptr);\n', '        if (ptr == self._ptr) {\n', '            // Not found\n', '            self._len = 0;\n', '        } else {\n', '            self._len -= token._len + needle._len;\n', '        }\n', '        return token;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything before the last\n', '     *      occurrence of `needle`, and returning everything after it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and the entirety of `self` is returned.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The part of `self` after the last occurrence of `delim`.\n', '     */\n', '    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n', '        rsplit(self, needle, token);\n', '    }\n', '\n', '    /*\n', '     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n', '     * @param self The slice to search.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The number of occurrences of `needle` found in `self`.\n', '     */\n', '    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n', '        while (ptr <= self._ptr + self._len) {\n', '            cnt++;\n', '            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns True if `self` contains `needle`.\n', '     * @param self The slice to search.\n', '     * @param needle The text to search for in `self`.\n', '     * @return True if `needle` is found in `self`, false otherwise.\n', '     */\n', '    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\n', '        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a newly allocated string containing the concatenation of\n', '     *      `self` and `other`.\n', '     * @param self The first slice to concatenate.\n', '     * @param other The second slice to concatenate.\n', '     * @return The concatenation of the two strings.\n', '     */\n', '    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n', '        string memory ret = new string(self._len + other._len);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '        memcpy(retptr, self._ptr, self._len);\n', '        memcpy(retptr + self._len, other._ptr, other._len);\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n', '     *      newly allocated string.\n', '     * @param self The delimiter to use.\n', '     * @param parts A list of slices to join.\n', '     * @return A newly allocated string containing all the slices in `parts`,\n', '     *         joined with `self`.\n', '     */\n', '    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n', '        if (parts.length == 0)\n', '            return "";\n', '\n', '        uint length = self._len * (parts.length - 1);\n', '        for(uint i = 0; i < parts.length; i++)\n', '            length += parts[i]._len;\n', '\n', '        string memory ret = new string(length);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '\n', '        for(uint i = 0; i < parts.length; i++) {\n', '            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n', '            retptr += parts[i]._len;\n', '            if (i < parts.length - 1) {\n', '                memcpy(retptr, self._ptr, self._len);\n', '                retptr += self._len;\n', '            }\n', '        }\n', '\n', '        return ret;\n', '    }\n', '}\n', '\n', "// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ENS.sol\n", '// with few modifications.\n', '\n', '\n', '\n', '/**\n', ' * ENS Registry interface.\n', ' */\n', 'interface ENSRegistry {\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n', '    function setResolver(bytes32 node, address resolver) external;\n', '    function setOwner(bytes32 node, address owner) external;\n', '    function setTTL(bytes32 node, uint64 ttl) external;\n', '    function owner(bytes32 node) external view returns (address);\n', '    function resolver(bytes32 node) external view returns (address);\n', '    function ttl(bytes32 node) external view returns (uint64);\n', '}\n', '\n', '\n', '/**\n', ' * ENS Resolver interface.\n', ' */\n', 'abstract contract ENSResolver {\n', '    function addr(bytes32 _node) public view virtual returns (address);\n', '    function setAddr(bytes32 _node, address _addr) public virtual;\n', '    function name(bytes32 _node) public view virtual returns (string memory);\n', '    function setName(bytes32 _node, string memory _name) public virtual;\n', '}\n', '\n', '/**\n', ' * ENS Reverse Registrar interface.\n', ' */\n', 'abstract contract ENSReverseRegistrar {\n', '    function claim(address _owner) public virtual returns (bytes32 _node);\n', '    function claimWithResolver(address _owner, address _resolver) public virtual returns (bytes32);\n', '    function setName(string memory _name) public virtual returns (bytes32);\n', '    function node(address _addr) public view virtual returns (bytes32);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library MathUint\n', '{\n', '    function mul(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b, "MUL_OVERFLOW");\n', '    }\n', '\n', '    function sub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        require(b <= a, "SUB_UNDERFLOW");\n', '        return a - b;\n', '    }\n', '\n', '    function add(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', 'abstract contract ERC1271 {\n', '    // bytes4(keccak256("isValidSignature(bytes32,bytes)")\n', '    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\n', '\n', '    function isValidSignature(\n', '        bytes32      _hash,\n', '        bytes memory _signature)\n', '        public\n', '        view\n', '        virtual\n', '        returns (bytes4 magicValueB32);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Utility Functions for addresses\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library AddressUtil\n', '{\n', '    using AddressUtil for *;\n', '\n', '    function isContract(\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(addr) }\n', '        return (codehash != 0x0 &&\n', '                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n', '    }\n', '\n', '    function toPayable(\n', '        address addr\n', '        )\n', '        internal\n', '        pure\n', '        returns (address payable)\n', '    {\n', '        return payable(addr);\n', '    }\n', '\n', '    // Works like address.send but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETH(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        if (amount == 0) {\n', '            return true;\n', '        }\n', '        address payable recipient = to.toPayable();\n', '        /* solium-disable-next-line */\n', '        (success,) = recipient.call{value: amount, gas: gasLimit}("");\n', '    }\n', '\n', '    // Works like address.transfer but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETHAndVerify(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        success = to.sendETH(amount, gasLimit);\n', '        require(success, "TRANSFER_FAILURE");\n', '    }\n', '\n', '    // Works like call but is slightly more efficient when data\n', '    // needs to be copied from memory to do the call.\n', '    function fastCall(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bool success, bytes memory returnData)\n', '    {\n', '        if (to != address(0)) {\n', '            assembly {\n', '                // Do the call\n', '                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\n', '                // Copy the return data\n', '                let size := returndatasize()\n', '                returnData := mload(0x40)\n', '                mstore(returnData, size)\n', '                returndatacopy(add(returnData, 32), 0, size)\n', '                // Update free memory pointer\n', '                mstore(0x40, add(returnData, add(32, size)))\n', '            }\n', '        }\n', '    }\n', '\n', '    // Like fastCall, but throws when the call is unsuccessful.\n', '    function fastCallAndVerify(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bytes memory returnData)\n', '    {\n', '        bool success;\n', '        (success, returnData) = fastCall(to, gasLimit, value, data);\n', '        if (!success) {\n', '            assembly {\n', '                revert(add(returnData, 32), mload(returnData))\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '//Mainly taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n', '\n', '\n', 'library BytesUtil {\n', '    function slice(\n', '        bytes memory _bytes,\n', '        uint _start,\n', '        uint _length\n', '    )\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        require(_bytes.length >= (_start + _length));\n', '\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            switch iszero(_length)\n', '            case 0 {\n', '                // Get a location of some free memory and store it in tempBytes as\n', '                // Solidity does for memory variables.\n', '                tempBytes := mload(0x40)\n', '\n', '                // The first word of the slice result is potentially a partial\n', '                // word read from the original array. To read it, we calculate\n', '                // the length of that partial word and start copying that many\n', '                // bytes into the array. The first word we copy will start with\n', "                // data we don't care about, but the last `lengthmod` bytes will\n", '                // land at the beginning of the contents of the new array. When\n', "                // we're done copying, we overwrite the full first word with\n", '                // the actual length of the slice.\n', '                let lengthmod := and(_length, 31)\n', '\n', '                // The multiplication in the next line is necessary\n', '                // because when slicing multiples of 32 bytes (lengthmod == 0)\n', "                // the following copy loop was copying the origin's length\n", '                // and then ending prematurely not copying everything it should.\n', '                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                let end := add(mc, _length)\n', '\n', '                for {\n', '                    // The multiplication in the next line has the same exact purpose\n', '                    // as the one above.\n', '                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                } lt(mc, end) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    mstore(mc, mload(cc))\n', '                }\n', '\n', '                mstore(tempBytes, _length)\n', '\n', '                //update free-memory pointer\n', '                //allocating the array padded to 32 bytes like the compiler does now\n', '                mstore(0x40, and(add(mc, 31), not(31)))\n', '            }\n', "            //if we want a zero-length slice let's just return a zero-length array\n", '            default {\n', '                tempBytes := mload(0x40)\n', '\n', '                mstore(0x40, add(tempBytes, 0x20))\n', '            }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n', '        require(_bytes.length >= (_start + 20));\n', '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n', '        require(_bytes.length >= (_start + 1));\n', '        uint8 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x1), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\n', '        require(_bytes.length >= (_start + 2));\n', '        uint16 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x2), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\n', '        require(_bytes.length >= (_start + 3));\n', '        uint24 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x3), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\n', '        require(_bytes.length >= (_start + 4));\n', '        uint32 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x4), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\n', '        require(_bytes.length >= (_start + 8));\n', '        uint64 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x8), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\n', '        require(_bytes.length >= (_start + 12));\n', '        uint96 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0xc), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\n', '        require(_bytes.length >= (_start + 16));\n', '        uint128 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x10), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n', '        require(_bytes.length >= (_start + 32));\n', '        uint256 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\n', '        require(_bytes.length >= (_start + 4));\n', '        bytes4 tempBytes4;\n', '\n', '        assembly {\n', '            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes4;\n', '    }\n', '\n', '    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\n', '        require(_bytes.length >= (_start + 32));\n', '        bytes32 tempBytes32;\n', '\n', '        assembly {\n', '            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes32;\n', '    }\n', '\n', '    function fastSHA256(\n', '        bytes memory data\n', '        )\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        bytes32[] memory result = new bytes32[](1);\n', '        bool success;\n', '        assembly {\n', '             let ptr := add(data, 32)\n', '             success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)\n', '        }\n', '        require(success, "SHA256_FAILED");\n', '        return result[0];\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title SignatureUtil\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', "/// @dev This method supports multihash standard. Each signature's last byte indicates\n", "///      the signature's type.\n", 'library SignatureUtil\n', '{\n', '    using BytesUtil     for bytes;\n', '    using MathUint      for uint;\n', '    using AddressUtil   for address;\n', '\n', '    enum SignatureType {\n', '        ILLEGAL,\n', '        INVALID,\n', '        EIP_712,\n', '        ETH_SIGN,\n', '        WALLET   // deprecated\n', '    }\n', '\n', '    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\n', '\n', '    function verifySignatures(\n', '        bytes32          signHash,\n', '        address[] memory signers,\n', '        bytes[]   memory signatures\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        require(signers.length == signatures.length, "BAD_SIGNATURE_DATA");\n', '        address lastSigner;\n', '        for (uint i = 0; i < signers.length; i++) {\n', '            require(signers[i] > lastSigner, "INVALID_SIGNERS_ORDER");\n', '            lastSigner = signers[i];\n', '            if (!verifySignature(signHash, signers[i], signatures[i])) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function verifySignature(\n', '        bytes32        signHash,\n', '        address        signer,\n', '        bytes   memory signature\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (signer == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        return signer.isContract()?\n', '            verifyERC1271Signature(signHash, signer, signature):\n', '            verifyEOASignature(signHash, signer, signature);\n', '    }\n', '\n', '    function recoverECDSASigner(\n', '        bytes32      signHash,\n', '        bytes memory signature\n', '        )\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        if (signature.length != 65) {\n', '            return address(0);\n', '        }\n', '\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8   v;\n', '        // we jump 32 (0x20) as the first slot of bytes contains the length\n', '        // we jump 65 (0x41) per signature\n', '        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := and(mload(add(signature, 0x41)), 0xff)\n', '        }\n', '        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\n', '        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n', '            return address(0);\n', '        }\n', '        if (v == 27 || v == 28) {\n', '            return ecrecover(signHash, v, r, s);\n', '        } else {\n', '            return address(0);\n', '        }\n', '    }\n', '\n', '    function verifyEOASignature(\n', '        bytes32        signHash,\n', '        address        signer,\n', '        bytes   memory signature\n', '        )\n', '        private\n', '        pure\n', '        returns (bool success)\n', '    {\n', '        if (signer == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        uint signatureTypeOffset = signature.length.sub(1);\n', '        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\n', '\n', '        // Strip off the last byte of the signature by updating the length\n', '        assembly {\n', '            mstore(signature, signatureTypeOffset)\n', '        }\n', '\n', '        if (signatureType == SignatureType.EIP_712) {\n', '            success = (signer == recoverECDSASigner(signHash, signature));\n', '        } else if (signatureType == SignatureType.ETH_SIGN) {\n', '            bytes32 hash = keccak256(\n', '                abi.encodePacked("\\x19Ethereum Signed Message:\\n32", signHash)\n', '            );\n', '            success = (signer == recoverECDSASigner(hash, signature));\n', '        } else {\n', '            success = false;\n', '        }\n', '\n', '        // Restore the signature length\n', '        assembly {\n', '            mstore(signature, add(signatureTypeOffset, 1))\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '    function verifyERC1271Signature(\n', '        bytes32 signHash,\n', '        address signer,\n', '        bytes   memory signature\n', '        )\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            ERC1271.isValidSignature.selector,\n', '            signHash,\n', '            signature\n', '        );\n', '        (bool success, bytes memory result) = signer.staticcall(callData);\n', '        return (\n', '            success &&\n', '            result.length == 32 &&\n', '            result.toBytes4(0) == ERC1271_MAGICVALUE\n', '        );\n', '    }\n', '}\n', '\n', "// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ENSConsumer.sol\n", '// with few modifications.\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ENSConsumer\n', ' * @dev Helper contract to resolve ENS names.\n', ' * @author Julien Niset - <julien@argent.im>\n', ' */\n', 'contract ENSConsumer {\n', '\n', '    using strings for *;\n', '\n', "    // namehash('addr.reverse')\n", '    bytes32 constant public ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n', '\n', '    // the address of the ENS registry\n', '    address ensRegistry;\n', '\n', '    /**\n', '    * @dev No address should be provided when deploying on Mainnet to avoid storage cost. The\n', '    * contract will use the hardcoded value.\n', '    */\n', '    constructor(address _ensRegistry) {\n', '        ensRegistry = _ensRegistry;\n', '    }\n', '\n', '    /**\n', '    * @dev Resolves an ENS name to an address.\n', '    * @param _node The namehash of the ENS name.\n', '    */\n', '    function resolveEns(bytes32 _node) public view returns (address) {\n', '        address resolver = getENSRegistry().resolver(_node);\n', '        return ENSResolver(resolver).addr(_node);\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the official ENS registry.\n', '    */\n', '    function getENSRegistry() public view returns (ENSRegistry) {\n', '        return ENSRegistry(ensRegistry);\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the official ENS reverse registrar.\n', '    */\n', '    function getENSReverseRegistrar() public view returns (ENSReverseRegistrar) {\n', '        return ENSReverseRegistrar(getENSRegistry().owner(ADDR_REVERSE_NODE));\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title AddressSet\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract AddressSet\n', '{\n', '    struct Set\n', '    {\n', '        address[] addresses;\n', '        mapping (address => uint) positions;\n', '        uint count;\n', '    }\n', '    mapping (bytes32 => Set) private sets;\n', '\n', '    function addAddressToSet(\n', '        bytes32 key,\n', '        address addr,\n', '        bool    maintainList\n', '        ) internal\n', '    {\n', '        Set storage set = sets[key];\n', '        require(set.positions[addr] == 0, "ALREADY_IN_SET");\n', '\n', '        if (maintainList) {\n', '            require(set.addresses.length == set.count, "PREVIOUSLY_NOT_MAINTAILED");\n', '            set.addresses.push(addr);\n', '        } else {\n', '            require(set.addresses.length == 0, "MUST_MAINTAIN");\n', '        }\n', '\n', '        set.count += 1;\n', '        set.positions[addr] = set.count;\n', '    }\n', '\n', '    function removeAddressFromSet(\n', '        bytes32 key,\n', '        address addr\n', '        )\n', '        internal\n', '    {\n', '        Set storage set = sets[key];\n', '        uint pos = set.positions[addr];\n', '        require(pos != 0, "NOT_IN_SET");\n', '\n', '        delete set.positions[addr];\n', '        set.count -= 1;\n', '\n', '        if (set.addresses.length > 0) {\n', '            address lastAddr = set.addresses[set.count];\n', '            if (lastAddr != addr) {\n', '                set.addresses[pos - 1] = lastAddr;\n', '                set.positions[lastAddr] = pos;\n', '            }\n', '            set.addresses.pop();\n', '        }\n', '    }\n', '\n', '    function removeSet(bytes32 key)\n', '        internal\n', '    {\n', '        delete sets[key];\n', '    }\n', '\n', '    function isAddressInSet(\n', '        bytes32 key,\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return sets[key].positions[addr] != 0;\n', '    }\n', '\n', '    function numAddressesInSet(bytes32 key)\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        Set storage set = sets[key];\n', '        return set.count;\n', '    }\n', '\n', '    function addressesInSet(bytes32 key)\n', '        internal\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        Set storage set = sets[key];\n', '        require(set.count == set.addresses.length, "NOT_MAINTAINED");\n', '        return sets[key].addresses;\n', '    }\n', '}\n', '// Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeCast.sol\n', '\n', '\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n", ' * checks.\n', ' *\n', ' * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n', ' * easily result in undesired exploitation or bugs, since developers usually\n', ' * assume that overflows raise errors. `SafeCast` restores this intuition by\n', ' * reverting the transaction when such an operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' *\n', ' * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n', ' * all math on `uint256` and `int256` and then downcasting.\n', ' */\n', 'library SafeCast {\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint128 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint128).\n', '     *\n', "     * Counterpart to Solidity's `uint128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     */\n', '    function toUint128(uint256 value) internal pure returns (uint128) {\n', '        require(value < 2**128, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return uint128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint64 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint64).\n', '     *\n', "     * Counterpart to Solidity's `uint64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     */\n', '    function toUint64(uint256 value) internal pure returns (uint64) {\n', '        require(value < 2**64, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return uint64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint32 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint32).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     */\n', '    function toUint32(uint256 value) internal pure returns (uint32) {\n', '        require(value < 2**32, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return uint32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint40 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint40).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 40 bits\n', '     */\n', '    function toUint40(uint256 value) internal pure returns (uint40) {\n', '        require(value < 2**40, "SafeCast: value doesn\\\'t fit in 40 bits");\n', '        return uint40(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint16 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint16).\n', '     *\n', "     * Counterpart to Solidity's `uint16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     */\n', '    function toUint16(uint256 value) internal pure returns (uint16) {\n', '        require(value < 2**16, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return uint16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint8 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint8).\n', '     *\n', "     * Counterpart to Solidity's `uint8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     */\n', '    function toUint8(uint256 value) internal pure returns (uint8) {\n', '        require(value < 2**8, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return uint8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a signed int256 into an unsigned uint256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be greater than or equal to 0.\n', '     */\n', '    function toUint256(int256 value) internal pure returns (uint256) {\n', '        require(value >= 0, "SafeCast: value must be positive");\n', '        return uint256(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int128 from int256, reverting on\n', '     * overflow (when the input is less than smallest int128 or\n', '     * greater than largest int128).\n', '     *\n', "     * Counterpart to Solidity's `int128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt128(int256 value) internal pure returns (int128) {\n', '        require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return int128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int64 from int256, reverting on\n', '     * overflow (when the input is less than smallest int64 or\n', '     * greater than largest int64).\n', '     *\n', "     * Counterpart to Solidity's `int64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt64(int256 value) internal pure returns (int64) {\n', '        require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return int64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int32 from int256, reverting on\n', '     * overflow (when the input is less than smallest int32 or\n', '     * greater than largest int32).\n', '     *\n', "     * Counterpart to Solidity's `int32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt32(int256 value) internal pure returns (int32) {\n', '        require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return int32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int16 from int256, reverting on\n', '     * overflow (when the input is less than smallest int16 or\n', '     * greater than largest int16).\n', '     *\n', "     * Counterpart to Solidity's `int16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt16(int256 value) internal pure returns (int16) {\n', '        require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return int16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int8 from int256, reverting on\n', '     * overflow (when the input is less than smallest int8 or\n', '     * greater than largest int8).\n', '     *\n', "     * Counterpart to Solidity's `int8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt8(int256 value) internal pure returns (int8) {\n', '        require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return int8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an unsigned uint256 into a signed int256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be less than or equal to maxInt256.\n', '     */\n', '    function toInt256(uint256 value) internal pure returns (int256) {\n', '        require(value < 2**255, "SafeCast: value doesn\'t fit in an int256");\n', '        return int256(value);\n', '    }\n', '}\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Ownable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable\n', '{\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      new owner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership()\n', '        public\n', '        onlyOwner\n', '    {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title PriceOracle\n', 'interface PriceOracle\n', '{\n', "    // @dev Return's the token's value in ETH\n", '    function tokenValue(address token, uint amount)\n', '        external\n', '        view\n', '        returns (uint value);\n', '}\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Wallet\n', '/// @dev Base contract for smart wallets.\n', '///      Sub-contracts must NOT use non-default constructor to initialize\n', '///      wallet states, instead, `init` shall be used. This is to enable\n', '///      proxies to be deployed in front of the real wallet contract for\n', '///      saving gas.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'interface Wallet\n', '{\n', '    function version() external pure returns (string memory);\n', '\n', '    function owner() external view returns (address);\n', '\n', '    /// @dev Set a new owner.\n', '    function setOwner(address newOwner) external;\n', '\n', '    /// @dev Adds a new module. The `init` method of the module\n', '    ///      will be called with `address(this)` as the parameter.\n', '    ///      This method must throw if the module has already been added.\n', "    /// @param _module The module's address.\n", '    function addModule(address _module) external;\n', '\n', '    /// @dev Removes an existing module. This method must throw if the module\n', "    ///      has NOT been added or the module is the wallet's only module.\n", "    /// @param _module The module's address.\n", '    function removeModule(address _module) external;\n', '\n', '    /// @dev Checks if a module has been added to this wallet.\n', '    /// @param _module The module to check.\n', '    /// @return True if the module exists; False otherwise.\n', '    function hasModule(address _module) external view returns (bool);\n', '\n', '    /// @dev Binds a method from the given module to this\n', "    ///      wallet so the method can be invoked using this wallet's default\n", '    ///      function.\n', '    ///      Note that this method must throw when the given module has\n', '    ///      not been added to this wallet.\n', "    /// @param _method The method's 4-byte selector.\n", "    /// @param _module The module's address. Use address(0) to unbind the method.\n", '    function bindMethod(bytes4 _method, address _module) external;\n', '\n', '    /// @dev Returns the module the given method has been bound to.\n', "    /// @param _method The method's 4-byte selector.\n", '    /// @return _module The address of the bound module. If no binding exists,\n', '    ///                 returns address(0) instead.\n', '    function boundMethodModule(bytes4 _method) external view returns (address _module);\n', '\n', '    /// @dev Performs generic transactions. Any module that has been added to this\n', '    ///      wallet can use this method to transact on any third-party contract with\n', '    ///      msg.sender as this wallet itself.\n', '    ///\n', "    ///      This method will emit `Transacted` event if it doesn't throw.\n", '    ///\n', '    ///      Note: this method must ONLY allow invocations from a module that has\n', '    ///      been added to this wallet. The wallet owner shall NOT be permitted\n', '    ///      to call this method directly.\n', '    ///\n', '    /// @param mode The transaction mode, 1 for CALL, 2 for DELEGATECALL.\n', '    /// @param to The desitination address.\n', '    /// @param value The amount of Ether to transfer.\n', '    /// @param data The data to send over using `to.call{value: value}(data)`\n', "    /// @return returnData The transaction's return value.\n", '    function transact(\n', '        uint8    mode,\n', '        address  to,\n', '        uint     value,\n', '        bytes    calldata data\n', '        )\n', '        external\n', '        returns (bytes memory returnData);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title WalletRegistry\n', '/// @dev A registry for wallets.\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'interface WalletRegistry\n', '{\n', '    function registerWallet(address wallet) external;\n', '    function isWalletRegistered(address addr) external view returns (bool);\n', '    function numOfWallets() external view returns (uint);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ReentrancyGuard\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Exposes a modifier that guards a function against reentrancy\n', '///      Changing the value of the same storage value multiple times in a transaction\n', '///      is cheap (starting from Istanbul) so there is no need to minimize\n', '///      the number of times the value is changed\n', 'contract ReentrancyGuard\n', '{\n', '    //The default value must be 0 in order to work behind a proxy.\n', '    uint private _guardValue;\n', '\n', '    modifier nonReentrant()\n', '    {\n', '        require(_guardValue == 0, "REENTRANCY");\n', '        _guardValue = 1;\n', '        _;\n', '        _guardValue = 0;\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'abstract contract ERC20\n', '{\n', '    function totalSupply()\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint);\n', '\n', '    function balanceOf(\n', '        address who\n', '        )\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '        )\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function approve(\n', '        address spender,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', 'library Data\n', '{\n', '    // Optimized to fit into 32 bytes (1 slot)\n', '    struct Guardian\n', '    {\n', '        address addr;\n', '        uint16  group;\n', '        uint40  validSince;\n', '        uint40  validUntil;\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ModuleRegistry\n', '/// @dev A registry for modules.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'interface ModuleRegistry\n', '{\n', '\t/// @dev Registers and enables a new module.\n', '    function registerModule(address module) external;\n', '\n', '    /// @dev Disables a module\n', '    function disableModule(address module) external;\n', '\n', '    /// @dev Returns true if the module is registered and enabled.\n', '    function isModuleEnabled(address module) external view returns (bool);\n', '\n', '    /// @dev Returns the list of enabled modules.\n', '    function enabledModules() external view returns (address[] memory _modules);\n', '\n', '    /// @dev Returns the number of enbaled modules.\n', '    function numOfEnabledModules() external view returns (uint);\n', '\n', '    /// @dev Returns true if the module is ever registered.\n', '    function isModuleRegistered(address module) external view returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', '/// @title Controller\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'abstract contract Controller\n', '{\n', '    ModuleRegistry public moduleRegistry;\n', '    WalletRegistry public walletRegistry;\n', '    address        public walletFactory;\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Module\n', '/// @dev Base contract for all smart wallet modules.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'interface Module\n', '{\n', '    /// @dev Activates the module for the given wallet (msg.sender) after the module is added.\n', '    ///      Warning: this method shall ONLY be callable by a wallet.\n', '    function activate() external;\n', '\n', '    /// @dev Deactivates the module for the given wallet (msg.sender) before the module is removed.\n', '    ///      Warning: this method shall ONLY be callable by a wallet.\n', '    function deactivate() external;\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title BaseWallet\n', '/// @dev This contract provides basic implementation for a Wallet.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'abstract contract BaseWallet is ReentrancyGuard, Wallet\n', '{\n', '    // WARNING: do not delete wallet state data to make this implementation\n', '    // compatible with early versions.\n', '    //\n', '    //  ----- DATA LAYOUT BEGINS -----\n', '    address internal _owner;\n', '\n', '    mapping (address => bool) private modules;\n', '\n', '    Controller public controller;\n', '\n', '    mapping (bytes4  => address) internal methodToModule;\n', '    //  ----- DATA LAYOUT ENDS -----\n', '\n', '    event OwnerChanged          (address newOwner);\n', '    event ControllerChanged     (address newController);\n', '    event ModuleAdded           (address module);\n', '    event ModuleRemoved         (address module);\n', '    event MethodBound           (bytes4  method, address module);\n', '    event WalletSetup           (address owner);\n', '\n', '    event Transacted(\n', '        address module,\n', '        address to,\n', '        uint    value,\n', '        bytes   data\n', '    );\n', '\n', '    modifier onlyFromModule\n', '    {\n', '        require(modules[msg.sender], "MODULE_UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    modifier onlyFromFactory\n', '    {\n', '        require(\n', '            msg.sender == controller.walletFactory(),\n', '            "UNAUTHORIZED"\n', '        );\n', '        _;\n', '    }\n', '\n', "    /// @dev We need to make sure the Factory address cannot be changed without wallet owner's\n", '    ///      explicit authorization.\n', '    modifier onlyFromFactoryOrModule\n', '    {\n', '        require(\n', '            modules[msg.sender] || msg.sender == controller.walletFactory(),\n', '            "UNAUTHORIZED"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev Set up this wallet by assigning an original owner\n', '    ///\n', '    ///      Note that calling this method more than once will throw.\n', '    ///\n', '    /// @param _initialOwner The owner of this wallet, must not be address(0).\n', '    function initOwner(\n', '        address _initialOwner\n', '        )\n', '        external\n', '        onlyFromFactory\n', '        nonReentrant\n', '    {\n', '        require(controller != Controller(0), "NO_CONTROLLER");\n', '        require(_owner == address(0), "INITIALIZED_ALREADY");\n', '        require(_initialOwner != address(0), "ZERO_ADDRESS");\n', '\n', '        _owner = _initialOwner;\n', '        emit WalletSetup(_initialOwner);\n', '    }\n', '\n', '    /// @dev Set up this wallet by assigning an controller.\n', '    ///\n', '    ///      Note that calling this method more than once will throw.\n', '    ///      And this method must be invoked before owner is initialized\n', '    ///\n', '    /// @param _controller The Controller instance.\n', '    function initController(\n', '        Controller _controller\n', '        )\n', '        external\n', '        nonReentrant\n', '    {\n', '        require(\n', '            _owner == address(0) &&\n', '            controller == Controller(0) &&\n', '            _controller != Controller(0),\n', '            "CONTROLLER_INIT_FAILED"\n', '        );\n', '\n', '        controller = _controller;\n', '    }\n', '\n', '    function owner()\n', '        override\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return _owner;\n', '    }\n', '\n', '    function setOwner(address newOwner)\n', '        external\n', '        override\n', '        nonReentrant\n', '        onlyFromModule\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        require(newOwner != address(this), "PROHIBITED");\n', '        require(newOwner != _owner, "SAME_ADDRESS");\n', '        _owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '\n', '    function setController(Controller newController)\n', '        external\n', '        nonReentrant\n', '        onlyFromModule\n', '    {\n', '        require(newController != controller, "SAME_CONTROLLER");\n', '        require(newController != Controller(0), "INVALID_CONTROLLER");\n', '        controller = newController;\n', '        emit ControllerChanged(address(newController));\n', '    }\n', '\n', '    function addModule(address _module)\n', '        external\n', '        override\n', '        onlyFromFactoryOrModule\n', '    {\n', '        addModuleInternal(_module);\n', '    }\n', '\n', '    function removeModule(address _module)\n', '        external\n', '        override\n', '        onlyFromModule\n', '    {\n', '        // Allow deactivate to fail to make sure the module can be removed\n', '        require(modules[_module], "MODULE_NOT_EXISTS");\n', '        try Module(_module).deactivate() {} catch {}\n', '        delete modules[_module];\n', '        emit ModuleRemoved(_module);\n', '    }\n', '\n', '    function hasModule(address _module)\n', '        external\n', '        view\n', '        override\n', '        returns (bool)\n', '    {\n', '        return modules[_module];\n', '    }\n', '\n', '    function bindMethod(bytes4 _method, address _module)\n', '        external\n', '        override\n', '        onlyFromModule\n', '    {\n', '        require(_method != bytes4(0), "BAD_METHOD");\n', '        if (_module != address(0)) {\n', '            require(modules[_module], "MODULE_UNAUTHORIZED");\n', '        }\n', '\n', '        methodToModule[_method] = _module;\n', '        emit MethodBound(_method, _module);\n', '    }\n', '\n', '    function boundMethodModule(bytes4 _method)\n', '        external\n', '        view\n', '        override\n', '        returns (address)\n', '    {\n', '        return methodToModule[_method];\n', '    }\n', '\n', '    function transact(\n', '        uint8    mode,\n', '        address  to,\n', '        uint     value,\n', '        bytes    calldata data\n', '        )\n', '        external\n', '        override\n', '        onlyFromFactoryOrModule\n', '        returns (bytes memory returnData)\n', '    {\n', '        require(\n', '            !controller.moduleRegistry().isModuleRegistered(to),\n', '            "TRANSACT_ON_MODULE_DISALLOWED"\n', '        );\n', '\n', '        bool success;\n', '        (success, returnData) = nonReentrantCall(mode, to, value, data);\n', '\n', '        if (!success) {\n', '            assembly {\n', '                returndatacopy(0, 0, returndatasize())\n', '                revert(0, returndatasize())\n', '            }\n', '        }\n', '        emit Transacted(msg.sender, to, value, data);\n', '    }\n', '\n', '    function addModuleInternal(address _module)\n', '        internal\n', '    {\n', '        require(_module != address(0), "NULL_MODULE");\n', '        require(modules[_module] == false, "MODULE_EXISTS");\n', '        require(\n', '            controller.moduleRegistry().isModuleEnabled(_module),\n', '            "INVALID_MODULE"\n', '        );\n', '        modules[_module] = true;\n', '        emit ModuleAdded(_module);\n', '        Module(_module).activate();\n', '    }\n', '\n', '    receive()\n', '        external\n', '        payable\n', '    {\n', '    }\n', '\n', '    /// @dev This default function can receive Ether or perform queries to modules\n', '    ///      using bound methods.\n', '    fallback()\n', '        external\n', '        payable\n', '    {\n', '        address module = methodToModule[msg.sig];\n', '        require(modules[module], "MODULE_UNAUTHORIZED");\n', '\n', '        (bool success, bytes memory returnData) = module.call{value: msg.value}(msg.data);\n', '        assembly {\n', '            switch success\n', '            case 0 { revert(add(returnData, 32), mload(returnData)) }\n', '            default { return(add(returnData, 32), mload(returnData)) }\n', '        }\n', '    }\n', '\n', '    // This call is introduced to support reentrany check.\n', '    // The caller shall NOT have the nonReentrant modifier.\n', '    function nonReentrantCall(\n', '        uint8          mode,\n', '        address        target,\n', '        uint           value,\n', '        bytes calldata data\n', '        )\n', '        private\n', '        nonReentrant\n', '        returns (\n', '            bool success,\n', '            bytes memory returnData\n', '        )\n', '    {\n', '        if (mode == 1) {\n', '            // solium-disable-next-line security/no-call-value\n', '            (success, returnData) = target.call{value: value}(data);\n', '        } else if (mode == 2) {\n', '            // solium-disable-next-line security/no-call-value\n', '            (success, returnData) = target.delegatecall(data);\n', '        } else if (mode == 3) {\n', '            require(value == 0, "INVALID_VALUE");\n', '            // solium-disable-next-line security/no-call-value\n', '            (success, returnData) = target.staticcall(data);\n', '        } else {\n', '            revert("UNSUPPORTED_MODE");\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title DataStore\n', '/// @dev Modules share states by accessing the same storage instance.\n', '///      Using ModuleStorage will achieve better module decoupling.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'abstract contract DataStore\n', '{\n', '    modifier onlyWalletModule(address wallet)\n', '    {\n', '        require(Wallet(wallet).hasModule(msg.sender), "UNAUTHORIZED");\n', '        _;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/// @title SecurityStore\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'contract SecurityStore is DataStore\n', '{\n', '    using MathUint for uint;\n', '    using SafeCast for uint;\n', '\n', '    struct Wallet\n', '    {\n', '        address    inheritor;\n', '        uint64     lastActive; // the latest timestamp the owner is considered to be active\n', '        address    lockedBy;   // the module that locked the wallet.\n', '        uint64     lock;\n', '\n', '        Data.Guardian[]            guardians;\n', '        mapping (address => uint)  guardianIdx;\n', '    }\n', '\n', '    mapping (address => Wallet) public wallets;\n', '\n', '    constructor() DataStore() {}\n', '\n', '    function isGuardian(\n', '        address wallet,\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        Data.Guardian memory guardian = getGuardian(wallet, addr);\n', '        return guardian.addr != address(0) && isGuardianActive(guardian);\n', '    }\n', '\n', '    function isGuardianOrPendingAddition(\n', '        address wallet,\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        Data.Guardian memory guardian = getGuardian(wallet, addr);\n', '        return guardian.addr != address(0) &&\n', '            (isGuardianActive(guardian) || isGuardianPendingAddition(guardian));\n', '    }\n', '\n', '    function getGuardian(\n', '        address wallet,\n', '        address guardianAddr\n', '        )\n', '        public\n', '        view\n', '        returns (Data.Guardian memory)\n', '    {\n', '        uint index = wallets[wallet].guardianIdx[guardianAddr];\n', '        if (index > 0) {\n', '            return wallets[wallet].guardians[index-1];\n', '        }\n', '    }\n', '\n', '    // @dev Returns active guardians.\n', '    function guardians(address wallet)\n', '        public\n', '        view\n', '        returns (Data.Guardian[] memory _guardians)\n', '    {\n', '        Wallet storage w = wallets[wallet];\n', '        _guardians = new Data.Guardian[](w.guardians.length);\n', '        uint index = 0;\n', '        for (uint i = 0; i < w.guardians.length; i++) {\n', '            Data.Guardian memory g = w.guardians[i];\n', '            if (isGuardianActive(g)) {\n', '                _guardians[index] = g;\n', '                index ++;\n', '            }\n', '        }\n', '        assembly { mstore(_guardians, index) }\n', '    }\n', '\n', '    // @dev Returns the number of active guardians.\n', '    function numGuardians(address wallet)\n', '        public\n', '        view\n', '        returns (uint count)\n', '    {\n', '        Wallet storage w = wallets[wallet];\n', '        for (uint i = 0; i < w.guardians.length; i++) {\n', '            if (isGuardianActive(w.guardians[i])) {\n', '                count ++;\n', '            }\n', '        }\n', '    }\n', '\n', '    // @dev Returns guardians who are either active or pending addition.\n', '    function guardiansWithPending(address wallet)\n', '        public\n', '        view\n', '        returns (Data.Guardian[] memory _guardians)\n', '    {\n', '        Wallet storage w = wallets[wallet];\n', '        _guardians = new Data.Guardian[](w.guardians.length);\n', '        uint index = 0;\n', '        for (uint i = 0; i < w.guardians.length; i++) {\n', '            Data.Guardian memory g = w.guardians[i];\n', '            if (isGuardianActive(g) || isGuardianPendingAddition(g)) {\n', '                _guardians[index] = g;\n', '                index ++;\n', '            }\n', '        }\n', '        assembly { mstore(_guardians, index) }\n', '    }\n', '\n', '    // @dev Returns the number of guardians who are active or pending addition.\n', '    function numGuardiansWithPending(address wallet)\n', '        public\n', '        view\n', '        returns (uint count)\n', '    {\n', '        Wallet storage w = wallets[wallet];\n', '        for (uint i = 0; i < w.guardians.length; i++) {\n', '            Data.Guardian memory g = w.guardians[i];\n', '            if (isGuardianActive(g) || isGuardianPendingAddition(g)) {\n', '                count ++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function addGuardian(\n', '        address wallet,\n', '        address guardianAddr,\n', '        uint    group,\n', '        uint    validSince\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        cleanRemovedGuardians(wallet);\n', '\n', '        require(guardianAddr != address(0), "ZERO_ADDRESS");\n', '        Wallet storage w = wallets[wallet];\n', '\n', '        uint pos = w.guardianIdx[guardianAddr];\n', '        require(pos == 0, "GUARDIAN_EXISTS");\n', '\n', '        // Add the new guardian\n', '        Data.Guardian memory g = Data.Guardian(\n', '            guardianAddr,\n', '            group.toUint16(),\n', '            validSince.toUint40(),\n', '            uint40(0)\n', '        );\n', '        w.guardians.push(g);\n', '        w.guardianIdx[guardianAddr] = w.guardians.length;\n', '    }\n', '\n', '    function cancelGuardianAddition(\n', '        address wallet,\n', '        address guardianAddr\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        cleanRemovedGuardians(wallet);\n', '\n', '        Wallet storage w = wallets[wallet];\n', '        uint idx = w.guardianIdx[guardianAddr];\n', '        require(idx > 0, "GUARDIAN_NOT_EXISTS");\n', '        require(\n', '            isGuardianPendingAddition(w.guardians[idx - 1]),\n', '            "NOT_PENDING_ADDITION"\n', '        );\n', '\n', '        Data.Guardian memory lastGuardian = w.guardians[w.guardians.length - 1];\n', '        if (guardianAddr != lastGuardian.addr) {\n', '            w.guardians[idx - 1] = lastGuardian;\n', '            w.guardianIdx[lastGuardian.addr] = idx;\n', '        }\n', '        w.guardians.pop();\n', '        delete w.guardianIdx[guardianAddr];\n', '    }\n', '\n', '    function removeGuardian(\n', '        address wallet,\n', '        address guardianAddr,\n', '        uint    validUntil\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        cleanRemovedGuardians(wallet);\n', '\n', '        Wallet storage w = wallets[wallet];\n', '        uint idx = w.guardianIdx[guardianAddr];\n', '        require(idx > 0, "GUARDIAN_NOT_EXISTS");\n', '\n', '        w.guardians[idx - 1].validUntil = validUntil.toUint40();\n', '    }\n', '\n', '    function removeAllGuardians(address wallet)\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        Wallet storage w = wallets[wallet];\n', '        for (uint i = 0; i < w.guardians.length; i++) {\n', '            delete w.guardianIdx[w.guardians[i].addr];\n', '        }\n', '        delete w.guardians;\n', '    }\n', '\n', '    function cancelGuardianRemoval(\n', '        address wallet,\n', '        address guardianAddr\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        cleanRemovedGuardians(wallet);\n', '\n', '        Wallet storage w = wallets[wallet];\n', '        uint idx = w.guardianIdx[guardianAddr];\n', '        require(idx > 0, "GUARDIAN_NOT_EXISTS");\n', '\n', '        require(\n', '            isGuardianPendingRemoval(w.guardians[idx - 1]),\n', '            "NOT_PENDING_REMOVAL"\n', '        );\n', '\n', '        w.guardians[idx - 1].validUntil = 0;\n', '    }\n', '\n', '    function getLock(address wallet)\n', '        public\n', '        view\n', '        returns (uint _lock, address _lockedBy)\n', '    {\n', '        _lock = wallets[wallet].lock;\n', '        _lockedBy = wallets[wallet].lockedBy;\n', '    }\n', '\n', '    function setLock(\n', '        address wallet,\n', '        uint    lock\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        require(lock == 0 || lock > block.timestamp, "INVALID_LOCK_TIME");\n', '\n', '        wallets[wallet].lock = lock.toUint64();\n', '        wallets[wallet].lockedBy = msg.sender;\n', '    }\n', '\n', '    function lastActive(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return wallets[wallet].lastActive;\n', '    }\n', '\n', '    function touchLastActive(address wallet)\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        wallets[wallet].lastActive = uint64(block.timestamp);\n', '    }\n', '\n', '    function inheritor(address wallet)\n', '        public\n', '        view\n', '        returns (\n', '            address _who,\n', '            uint    _lastActive\n', '        )\n', '    {\n', '        _who = wallets[wallet].inheritor;\n', '        _lastActive = wallets[wallet].lastActive;\n', '    }\n', '\n', '    function setInheritor(address wallet, address who)\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        wallets[wallet].inheritor = who;\n', '        wallets[wallet].lastActive = uint64(block.timestamp);\n', '    }\n', '\n', '    function cleanRemovedGuardians(address wallet)\n', '        private\n', '    {\n', '        Wallet storage w = wallets[wallet];\n', '\n', '        for (int i = int(w.guardians.length) - 1; i >= 0; i--) {\n', '            Data.Guardian memory g = w.guardians[uint(i)];\n', '            if (isGuardianExpired(g)) {\n', '                Data.Guardian memory lastGuardian = w.guardians[w.guardians.length - 1];\n', '\n', '                if (g.addr != lastGuardian.addr) {\n', '                    w.guardians[uint(i)] = lastGuardian;\n', '                    w.guardianIdx[lastGuardian.addr] = uint(i) + 1;\n', '                }\n', '                w.guardians.pop();\n', '                delete w.guardianIdx[g.addr];\n', '            }\n', '        }\n', '    }\n', '\n', '    function isGuardianActive(Data.Guardian memory guardian)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        return guardian.validSince > 0 && guardian.validSince <= block.timestamp &&\n', '            !isGuardianExpired(guardian);\n', '    }\n', '\n', '    function isGuardianPendingAddition(Data.Guardian memory guardian)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        return guardian.validSince > block.timestamp;\n', '    }\n', '\n', '    function isGuardianPendingRemoval(Data.Guardian memory guardian)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        return guardian.validUntil > block.timestamp;\n', '    }\n', '\n', '    function isGuardianExpired(Data.Guardian memory guardian)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        return guardian.validUntil > 0 &&\n', '            guardian.validUntil <= block.timestamp;\n', '    }\n', '}\n', '\n', '// This code is taken from https://github.com/OpenZeppelin/openzeppelin-labs\n', '// with minor modifications.\n', '\n', '\n', '\n', '// This code is taken from https://github.com/OpenZeppelin/openzeppelin-labs\n', '// with minor modifications.\n', '\n', '\n', '\n', '// This code is taken from https://github.com/OpenZeppelin/openzeppelin-labs\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Gives the possibility to delegate any call to a foreign implementation.\n', ' */\n', 'abstract contract Proxy {\n', '  /**\n', '  * @dev Tells the address of the implementation where every call will be delegated.\n', '  * @return address of the implementation to which it will be delegated\n', '  */\n', '  function implementation() public view virtual returns (address);\n', '\n', '  /**\n', '  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n', '  * This function will return whatever the implementation call returns\n', '  */\n', '  fallback() payable external {\n', '    address _impl = implementation();\n', '    require(_impl != address(0));\n', '\n', '    assembly {\n', '      let ptr := mload(0x40)\n', '      calldatacopy(ptr, 0, calldatasize())\n', '      let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n', '      let size := returndatasize()\n', '      returndatacopy(ptr, 0, size)\n', '\n', '      switch result\n', '      case 0 { revert(ptr, size) }\n', '      default { return(ptr, size) }\n', '    }\n', '  }\n', '\n', '  receive() payable external {}\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n', ' */\n', 'contract UpgradeabilityProxy is Proxy {\n', '    /**\n', '     * @dev This event will be emitted every time the implementation gets upgraded\n', '     * @param implementation representing the address of the upgraded implementation\n', '     */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    // Storage position of the address of the current implementation\n', '    bytes32 private constant implementationPosition = keccak256("org.zeppelinos.proxy.implementation");\n', '\n', '    /**\n', '     * @dev Constructor function\n', '     */\n', '    constructor() {}\n', '\n', '    /**\n', '     * @dev Tells the address of the current implementation\n', '     * @return impl address of the current implementation\n', '     */\n', '    function implementation() public view override returns (address impl) {\n', '        bytes32 position = implementationPosition;\n', '        assembly {\n', '            impl := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the current implementation\n', '     * @param newImplementation address representing the new implementation to be set\n', '     */\n', '    function setImplementation(address newImplementation) internal {\n', '        bytes32 position = implementationPosition;\n', '        assembly {\n', '            sstore(position, newImplementation)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrades the implementation address\n', '     * @param newImplementation representing the address of the new implementation to be set\n', '     */\n', '    function _upgradeTo(address newImplementation) internal {\n', '        address currentImplementation = implementation();\n', '        require(currentImplementation != newImplementation);\n', '        setImplementation(newImplementation);\n', '        emit Upgraded(newImplementation);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title OwnedUpgradeabilityProxy\n', ' * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n', ' */\n', 'contract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n', '  /**\n', '  * @dev Event to show ownership has been transferred\n', '  * @param previousOwner representing the address of the previous owner\n', '  * @param newOwner representing the address of the new owner\n', '  */\n', '  event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n', '\n', '  // Storage position of the owner of the contract\n', '  bytes32 private constant proxyOwnerPosition = keccak256("org.zeppelinos.proxy.owner");\n', '\n', '  /**\n', '  * @dev the constructor sets the original owner of the contract to the sender account.\n', '  */\n', '  constructor() {\n', '    setUpgradeabilityOwner(msg.sender);\n', '  }\n', '\n', '  /**\n', '  * @dev Throws if called by any account other than the owner.\n', '  */\n', '  modifier onlyProxyOwner() {\n', '    require(msg.sender == proxyOwner());\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Tells the address of the owner\n', '   * @return owner the address of the owner\n', '   */\n', '  function proxyOwner() public view returns (address owner) {\n', '    bytes32 position = proxyOwnerPosition;\n', '    assembly {\n', '      owner := sload(position)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the address of the owner\n', '   */\n', '  function setUpgradeabilityOwner(address newProxyOwner) internal {\n', '    bytes32 position = proxyOwnerPosition;\n', '    assembly {\n', '      sstore(position, newProxyOwner)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferProxyOwnership(address newOwner) public onlyProxyOwner {\n', '    require(newOwner != address(0));\n', '    emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\n', '    setUpgradeabilityOwner(newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the proxy owner to upgrade the current version of the proxy.\n', '   * @param implementation representing the address of the new implementation to be set.\n', '   */\n', '  function upgradeTo(address implementation) public onlyProxyOwner {\n', '    _upgradeTo(implementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the proxy owner to upgrade the current version of the proxy and call the new implementation\n', '   * to initialize whatever is needed through a low level call.\n', '   * @param implementation representing the address of the new implementation to be set.\n', '   * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function\n', '   * signature of the implementation to be called with the needed payload\n', '   */\n', '  function upgradeToAndCall(address implementation, bytes memory data) payable public onlyProxyOwner {\n', '    upgradeTo(implementation);\n', '    (bool success, ) = address(this).call{value: msg.value}(data);\n', '    require(success);\n', '  }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title Claimable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable\n', '{\n', '    address public pendingOwner;\n', '\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0) && newOwner != owner, "INVALID_ADDRESS");\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        public\n', '        onlyPendingOwner\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract OwnerManagable is Claimable, AddressSet\n', '{\n', '    bytes32 internal constant MANAGER = keccak256("__MANAGED__");\n', '\n', '    event ManagerAdded  (address manager);\n', '    event ManagerRemoved(address manager);\n', '\n', '    modifier onlyManager\n', '    {\n', '        require(isManager(msg.sender), "NOT_MANAGER");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrManager\n', '    {\n', '        require(msg.sender == owner || isManager(msg.sender), "NOT_OWNER_OR_MANAGER");\n', '        _;\n', '    }\n', '\n', '    constructor() Claimable() {}\n', '\n', '    /// @dev Gets the managers.\n', '    /// @return The list of managers.\n', '    function managers()\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        return addressesInSet(MANAGER);\n', '    }\n', '\n', '    /// @dev Gets the number of managers.\n', '    /// @return The numer of managers.\n', '    function numManagers()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return numAddressesInSet(MANAGER);\n', '    }\n', '\n', '    /// @dev Checks if an address is a manger.\n', '    /// @param addr The address to check.\n', '    /// @return True if the address is a manager, False otherwise.\n', '    function isManager(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return isAddressInSet(MANAGER, addr);\n', '    }\n', '\n', '    /// @dev Adds a new manager.\n', '    /// @param manager The new address to add.\n', '    function addManager(address manager)\n', '        public\n', '        onlyOwner\n', '    {\n', '        addManagerInternal(manager);\n', '    }\n', '\n', '    /// @dev Removes a manager.\n', '    /// @param manager The manager to remove.\n', '    function removeManager(address manager)\n', '        public\n', '        onlyOwner\n', '    {\n', '        removeAddressFromSet(MANAGER, manager);\n', '        emit ManagerRemoved(manager);\n', '    }\n', '\n', '    function addManagerInternal(address manager)\n', '        internal\n', '    {\n', '        addAddressToSet(MANAGER, manager, true);\n', '        emit ManagerAdded(manager);\n', '    }\n', '}\n', '\n', '\n', '/// @title DappAddressStore\n', '/// @dev This store maintains global whitelist dapps.\n', 'contract DappAddressStore is DataStore, OwnerManagable\n', '{\n', '    bytes32 internal constant DAPPS = keccak256("__DAPPS__");\n', '\n', '    event Whitelisted(\n', '        address addr,\n', '        bool    whitelisted\n', '    );\n', '\n', '    constructor() DataStore() {}\n', '\n', '    function addDapp(address addr)\n', '        public\n', '        onlyManager\n', '    {\n', '        addAddressToSet(DAPPS, addr, true);\n', '        emit Whitelisted(addr, true);\n', '    }\n', '\n', '    function removeDapp(address addr)\n', '        public\n', '        onlyManager\n', '    {\n', '        removeAddressFromSet(DAPPS, addr);\n', '        emit Whitelisted(addr, false);\n', '    }\n', '\n', '    function dapps()\n', '        public\n', '        view\n', '        returns (\n', '            address[] memory addresses\n', '        )\n', '    {\n', '        return addressesInSet(DAPPS);\n', '    }\n', '\n', '    function isDapp(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return isAddressInSet(DAPPS, addr);\n', '    }\n', '\n', '    function numDapps()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return numAddressesInSet(DAPPS);\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title HashStore\n', '/// @dev This store maintains all hashes for SignedRequest.\n', 'contract HashStore is DataStore\n', '{\n', '    // wallet => hash => consumed\n', '    mapping(address => mapping(bytes32 => bool)) public hashes;\n', '\n', '    constructor() {}\n', '\n', '    function verifyAndUpdate(address wallet, bytes32 hash)\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        require(!hashes[wallet][hash], "HASH_EXIST");\n', '        hashes[wallet][hash] = true;\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title NonceStore\n', '/// @dev This store maintains all nonces for metaTx\n', 'contract NonceStore is DataStore\n', '{\n', '    mapping(address => uint) public nonces;\n', '\n', '    constructor() DataStore() {}\n', '\n', '    function lastNonce(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return nonces[wallet];\n', '    }\n', '\n', '    function isNonceValid(address wallet, uint nonce)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return nonce > nonces[wallet] && (nonce >> 128) <= block.number;\n', '    }\n', '\n', '    function verifyAndUpdate(address wallet, uint nonce)\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        require(isNonceValid(wallet, nonce), "INVALID_NONCE");\n', '        nonces[wallet] = nonce;\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title QuotaStore\n', '/// @dev This store maintains daily spending quota for each wallet.\n', '///      A rolling daily limit is used.\n', 'contract QuotaStore is DataStore, Claimable\n', '{\n', '    using MathUint for uint;\n', '    using SafeCast for uint;\n', '\n', '    uint128 public defaultQuota;\n', '\n', '    // Optimized to fit into 64 bytes (2 slots)\n', '    struct Quota\n', '    {\n', '        uint128 currentQuota; // 0 indicates default\n', '        uint128 pendingQuota;\n', '        uint128 spentAmount;\n', '        uint64  spentTimestamp;\n', '        uint64  pendingUntil;\n', '    }\n', '\n', '    mapping (address => Quota) public quotas;\n', '\n', '    event DefaultQuotaChanged(\n', '        uint prevValue,\n', '        uint currentValue\n', '    );\n', '\n', '    event QuotaScheduled(\n', '        address wallet,\n', '        uint    pendingQuota,\n', '        uint64  pendingUntil\n', '    );\n', '\n', '    constructor(uint128 _defaultQuota)\n', '        DataStore()\n', '    {\n', '        defaultQuota = _defaultQuota;\n', '    }\n', '\n', '    function changeDefaultQuota(uint128 _defaultQuota)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            _defaultQuota != defaultQuota &&\n', '            _defaultQuota >= 1 ether &&\n', '            _defaultQuota <= 100 ether,\n', '            "INVALID_DEFAULT_QUOTA"\n', '        );\n', '        emit DefaultQuotaChanged(defaultQuota, _defaultQuota);\n', '        defaultQuota = _defaultQuota;\n', '    }\n', '\n', '    function changeQuota(\n', '        address wallet,\n', '        uint    newQuota,\n', '        uint    effectiveTime\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        quotas[wallet].currentQuota = currentQuota(wallet).toUint128();\n', '        quotas[wallet].pendingQuota = newQuota.toUint128();\n', '        quotas[wallet].pendingUntil = effectiveTime.toUint64();\n', '\n', '        emit QuotaScheduled(\n', '            wallet,\n', '            newQuota,\n', '            quotas[wallet].pendingUntil\n', '        );\n', '    }\n', '\n', '    function checkAndAddToSpent(\n', '        address wallet,\n', '        uint    amount\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        require(hasEnoughQuota(wallet, amount), "QUOTA_EXCEEDED");\n', '        addToSpent(wallet, amount);\n', '    }\n', '\n', '    function addToSpent(\n', '        address wallet,\n', '        uint    amount\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        Quota storage q = quotas[wallet];\n', '        q.spentAmount = spentQuota(wallet).add(amount).toUint128();\n', '        q.spentTimestamp = uint64(block.timestamp);\n', '    }\n', '\n', '    function currentQuota(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        Quota storage q = quotas[wallet];\n', '        uint value = q.pendingUntil <= block.timestamp ?\n', '            q.pendingQuota : q.currentQuota;\n', '\n', '        return value == 0 ? defaultQuota : value;\n', '    }\n', '\n', '    function pendingQuota(address wallet)\n', '        public\n', '        view\n', '        returns (\n', '            uint _pendingQuota,\n', '            uint _pendingUntil\n', '        )\n', '    {\n', '        Quota storage q = quotas[wallet];\n', '        if (q.pendingUntil > 0 && q.pendingUntil > block.timestamp) {\n', '            _pendingQuota = q.pendingQuota > 0 ? q.pendingQuota : defaultQuota;\n', '            _pendingUntil = q.pendingUntil;\n', '        }\n', '    }\n', '\n', '    function spentQuota(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        Quota storage q = quotas[wallet];\n', '        uint timeSinceLastSpent = block.timestamp.sub(q.spentTimestamp);\n', '        if (timeSinceLastSpent < 1 days) {\n', '            return uint(q.spentAmount).sub(timeSinceLastSpent.mul(q.spentAmount) / 1 days);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function availableQuota(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint quota = currentQuota(wallet);\n', '        uint spent = spentQuota(wallet);\n', '        return quota > spent ? quota - spent : 0;\n', '    }\n', '\n', '    function hasEnoughQuota(\n', '        address wallet,\n', '        uint    requiredAmount\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return availableQuota(wallet) >= requiredAmount;\n', '    }\n', '}\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title WhitelistStore\n', "/// @dev This store maintains a wallet's whitelisted addresses.\n", 'contract WhitelistStore is DataStore, AddressSet\n', '{\n', '    // wallet => whitelisted_addr => effective_since\n', '    mapping(address => mapping(address => uint)) public effectiveTimeMap;\n', '\n', '    event Whitelisted(\n', '        address wallet,\n', '        address addr,\n', '        bool    whitelisted,\n', '        uint    effectiveTime\n', '    );\n', '\n', '    constructor() DataStore() {}\n', '\n', '    function addToWhitelist(\n', '        address wallet,\n', '        address addr,\n', '        uint    effectiveTime\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        addAddressToSet(walletKey(wallet), addr, true);\n', '        uint effective = effectiveTime >= block.timestamp ? effectiveTime : block.timestamp;\n', '        effectiveTimeMap[wallet][addr] = effective;\n', '        emit Whitelisted(wallet, addr, true, effective);\n', '    }\n', '\n', '    function removeFromWhitelist(\n', '        address wallet,\n', '        address addr\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        removeAddressFromSet(walletKey(wallet), addr);\n', '        delete effectiveTimeMap[wallet][addr];\n', '        emit Whitelisted(wallet, addr, false, 0);\n', '    }\n', '\n', '    function whitelist(address wallet)\n', '        public\n', '        view\n', '        returns (\n', '            address[] memory addresses,\n', '            uint[]    memory effectiveTimes\n', '        )\n', '    {\n', '        addresses = addressesInSet(walletKey(wallet));\n', '        effectiveTimes = new uint[](addresses.length);\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            effectiveTimes[i] = effectiveTimeMap[wallet][addresses[i]];\n', '        }\n', '    }\n', '\n', '    function isWhitelisted(\n', '        address wallet,\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (\n', '            bool isWhitelistedAndEffective,\n', '            uint effectiveTime\n', '        )\n', '    {\n', '        effectiveTime = effectiveTimeMap[wallet][addr];\n', '        isWhitelistedAndEffective = effectiveTime > 0 && effectiveTime <= block.timestamp;\n', '    }\n', '\n', '    function whitelistSize(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return numAddressesInSet(walletKey(wallet));\n', '    }\n', '\n', '    function walletKey(address addr)\n', '        public\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(abi.encodePacked("__WHITELIST__", addr));\n', '    }\n', '}\n', '\n', '\n', "// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ArgentENSManager.sol\n", '// with few modifications.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface for an ENS Mananger.\n', ' */\n', 'interface IENSManager {\n', '    function changeRootnodeOwner(address _newOwner) external;\n', '\n', '    function isAvailable(bytes32 _subnode) external view returns (bool);\n', '\n', '    function resolveName(address _wallet) external view returns (string memory);\n', '\n', '    function register(\n', '        address _wallet,\n', '        address _owner,\n', '        string  calldata _label,\n', '        bytes   calldata _approval\n', '    ) external;\n', '}\n', '\n', '/**\n', ' * @title BaseENSManager\n', ' * @dev Implementation of an ENS manager that orchestrates the complete\n', ' * registration of subdomains for a single root (e.g. argent.eth).\n', ' * The contract defines a manager role who is the only role that can trigger the registration of\n', ' * a new subdomain.\n', ' * @author Julien Niset - <julien@argent.im>\n', ' */\n', 'contract BaseENSManager is IENSManager, OwnerManagable, ENSConsumer {\n', '\n', '    using strings for *;\n', '    using BytesUtil     for bytes;\n', '    using MathUint      for uint;\n', '\n', '    // The managed root name\n', '    string public rootName;\n', '    // The managed root node\n', '    bytes32 public rootNode;\n', '    // The address of the ENS resolver\n', '    address public ensResolver;\n', '\n', '    // *************** Events *************************** //\n', '\n', '    event RootnodeOwnerChange(bytes32 indexed _rootnode, address indexed _newOwner);\n', '    event ENSResolverChanged(address addr);\n', '    event Registered(address indexed _wallet, address _owner, string _ens);\n', '    event Unregistered(string _ens);\n', '\n', '    // *************** Constructor ********************** //\n', '\n', '    /**\n', '     * @dev Constructor that sets the ENS root name and root node to manage.\n', '     * @param _rootName The root name (e.g. argentx.eth).\n', '     * @param _rootNode The node of the root name (e.g. namehash(argentx.eth)).\n', '     */\n', '    constructor(string memory _rootName, bytes32 _rootNode, address _ensRegistry, address _ensResolver)\n', '        ENSConsumer(_ensRegistry)\n', '    {\n', '        rootName = _rootName;\n', '        rootNode = _rootNode;\n', '        ensResolver = _ensResolver;\n', '    }\n', '\n', '    // *************** External Functions ********************* //\n', '\n', '    /**\n', '     * @dev This function must be called when the ENS Manager contract is replaced\n', '     * and the address of the new Manager should be provided.\n', '     * @param _newOwner The address of the new ENS manager that will manage the root node.\n', '     */\n', '    function changeRootnodeOwner(address _newOwner) external override onlyOwner {\n', '        getENSRegistry().setOwner(rootNode, _newOwner);\n', '        emit RootnodeOwnerChange(rootNode, _newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Lets the owner change the address of the ENS resolver contract.\n', '     * @param _ensResolver The address of the ENS resolver contract.\n', '     */\n', '    function changeENSResolver(address _ensResolver) external onlyOwner {\n', '        require(_ensResolver != address(0), "WF: address cannot be null");\n', '        ensResolver = _ensResolver;\n', '        emit ENSResolverChanged(_ensResolver);\n', '    }\n', '\n', '    /**\n', '    * @dev Lets the manager assign an ENS subdomain of the root node to a target address.\n', '    * Registers both the forward and reverse ENS.\n', '    * @param _wallet The wallet which owns the subdomain.\n', "    * @param _owner The wallet's owner.\n", '    * @param _label The subdomain label.\n', '    * @param _approval The signature of _wallet, _owner and _label by a manager.\n', '    */\n', '    function register(\n', '        address _wallet,\n', '        address _owner,\n', '        string  calldata _label,\n', '        bytes   calldata _approval\n', '        )\n', '        external\n', '        override\n', '        onlyManager\n', '    {\n', '        verifyApproval(_wallet, _owner, _label, _approval);\n', '\n', '        bytes32 labelNode = keccak256(abi.encodePacked(_label));\n', '        bytes32 node = keccak256(abi.encodePacked(rootNode, labelNode));\n', '        address currentOwner = getENSRegistry().owner(node);\n', '        require(currentOwner == address(0), "AEM: _label is alrealdy owned");\n', '\n', '        // Forward ENS\n', '        getENSRegistry().setSubnodeOwner(rootNode, labelNode, address(this));\n', '        getENSRegistry().setResolver(node, ensResolver);\n', '        getENSRegistry().setOwner(node, _wallet);\n', '        ENSResolver(ensResolver).setAddr(node, _wallet);\n', '\n', '        // Reverse ENS\n', '        strings.slice[] memory parts = new strings.slice[](2);\n', '        parts[0] = _label.toSlice();\n', '        parts[1] = rootName.toSlice();\n', '        string memory name = ".".toSlice().join(parts);\n', '        bytes32 reverseNode = getENSReverseRegistrar().node(_wallet);\n', '        ENSResolver(ensResolver).setName(reverseNode, name);\n', '\n', '        emit Registered(_wallet, _owner, name);\n', '    }\n', '\n', '    // *************** Public Functions ********************* //\n', '\n', '    /**\n', '    * @dev Resolves an address to an ENS name\n', '    * @param _wallet The ENS owner address\n', '    */\n', '    function resolveName(address _wallet) public view override returns (string memory) {\n', '        bytes32 reverseNode = getENSReverseRegistrar().node(_wallet);\n', '        return ENSResolver(ensResolver).name(reverseNode);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true is a given subnode is available.\n', '     * @param _subnode The target subnode.\n', '     * @return true if the subnode is available.\n', '     */\n', '    function isAvailable(bytes32 _subnode) public view override returns (bool) {\n', '        bytes32 node = keccak256(abi.encodePacked(rootNode, _subnode));\n', '        address currentOwner = getENSRegistry().owner(node);\n', '        if(currentOwner == address(0)) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function verifyApproval(\n', '        address _wallet,\n', '        address _owner,\n', '        string  calldata _label,\n', '        bytes   calldata _approval\n', '        )\n', '        internal\n', '        view\n', '    {\n', '        bytes32 messageHash = keccak256(\n', '            abi.encodePacked(\n', '                _wallet,\n', '                _owner,\n', '                _label\n', '            )\n', '        );\n', '\n', '        bytes32 hash = keccak256(\n', '            abi.encodePacked(\n', '                "\\x19Ethereum Signed Message:\\n32",\n', '                messageHash\n', '            )\n', '        );\n', '\n', '        address signer = SignatureUtil.recoverECDSASigner(hash, _approval);\n', '        require(isManager(signer), "UNAUTHORIZED");\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '/// @title ControllerImpl\n', '/// @dev Basic implementation of a Controller.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract ControllerImpl is Claimable, Controller\n', '{\n', '    address             public collectTo;\n', '    uint                public defaultLockPeriod;\n', '    BaseENSManager      public ensManager;\n', '    PriceOracle         public priceOracle;\n', '    DappAddressStore    public dappAddressStore;\n', '    HashStore           public hashStore;\n', '    NonceStore          public nonceStore;\n', '    QuotaStore          public quotaStore;\n', '    SecurityStore       public securityStore;\n', '    WhitelistStore      public whitelistStore;\n', '\n', '    // Make sure this value if false in production env.\n', '    // Ideally we can use chainid(), but there is a bug in truffle so testing is buggy:\n', '    // https://github.com/trufflesuite/ganache/issues/1643\n', '    bool                public allowChangingWalletFactory;\n', '\n', '    event AddressChanged(\n', '        string   name,\n', '        address  addr\n', '    );\n', '\n', '    constructor(\n', '        ModuleRegistry    _moduleRegistry,\n', '        WalletRegistry    _walletRegistry,\n', '        uint              _defaultLockPeriod,\n', '        address           _collectTo,\n', '        BaseENSManager    _ensManager,\n', '        PriceOracle       _priceOracle,\n', '        bool              _allowChangingWalletFactory\n', '        )\n', '    {\n', '        moduleRegistry = _moduleRegistry;\n', '        walletRegistry = _walletRegistry;\n', '\n', '        defaultLockPeriod = _defaultLockPeriod;\n', '\n', '        require(_collectTo != address(0), "ZERO_ADDRESS");\n', '        collectTo = _collectTo;\n', '\n', '        ensManager = _ensManager;\n', '        priceOracle = _priceOracle;\n', '        allowChangingWalletFactory = _allowChangingWalletFactory;\n', '    }\n', '\n', '    function initStores(\n', '        DappAddressStore  _dappAddressStore,\n', '        HashStore         _hashStore,\n', '        NonceStore        _nonceStore,\n', '        QuotaStore        _quotaStore,\n', '        SecurityStore     _securityStore,\n', '        WhitelistStore    _whitelistStore\n', '        )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            address(_dappAddressStore) != address(0),\n', '            "ZERO_ADDRESS"\n', '        );\n', '\n', '        // Make sure this function can only invoked once.\n', '        require(\n', '            address(dappAddressStore) == address(0),\n', '            "INITIALIZED_ALREADY"\n', '        );\n', '\n', '        dappAddressStore = _dappAddressStore;\n', '        hashStore = _hashStore;\n', '        nonceStore = _nonceStore;\n', '        quotaStore = _quotaStore;\n', '        securityStore = _securityStore;\n', '        whitelistStore = _whitelistStore;\n', '    }\n', '\n', '    function initWalletFactory(address _walletFactory)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            allowChangingWalletFactory || walletFactory == address(0),\n', '            "INITIALIZED_ALREADY"\n', '        );\n', '        require(_walletFactory != address(0), "ZERO_ADDRESS");\n', '        walletFactory = _walletFactory;\n', '        emit AddressChanged("WalletFactory", walletFactory);\n', '    }\n', '\n', '    function setCollectTo(address _collectTo)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(_collectTo != address(0), "ZERO_ADDRESS");\n', '        collectTo = _collectTo;\n', '        emit AddressChanged("CollectTo", collectTo);\n', '    }\n', '\n', '    function setPriceOracle(PriceOracle _priceOracle)\n', '        external\n', '        onlyOwner\n', '    {\n', '        priceOracle = _priceOracle;\n', '        emit AddressChanged("PriceOracle", address(priceOracle));\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '/// @title BaseModule\n', '/// @dev This contract implements some common functions that are likely\n', '///      be useful for all modules.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'abstract contract BaseModule is ReentrancyGuard, Module\n', '{\n', '    using MathUint      for uint;\n', '    using AddressUtil   for address;\n', '\n', '    event Activated   (address wallet);\n', '    event Deactivated (address wallet);\n', '\n', '    function logicalSender()\n', '        internal\n', '        view\n', '        virtual\n', '        returns (address payable)\n', '    {\n', '        return msg.sender;\n', '    }\n', '\n', '    modifier onlyWalletOwner(address wallet, address addr)\n', '        virtual\n', '    {\n', '        require(Wallet(wallet).owner() == addr, "NOT_WALLET_OWNER");\n', '        _;\n', '    }\n', '\n', '    modifier notWalletOwner(address wallet, address addr)\n', '        virtual\n', '    {\n', '        require(Wallet(wallet).owner() != addr, "IS_WALLET_OWNER");\n', '        _;\n', '    }\n', '\n', '    modifier eligibleWalletOwner(address addr)\n', '    {\n', '        require(addr != address(0) && !addr.isContract(), "INVALID_OWNER");\n', '        _;\n', '    }\n', '\n', '    function controller()\n', '        internal\n', '        view\n', '        virtual\n', '        returns(ControllerImpl);\n', '\n', '    /// @dev This method will cause an re-entry to the same module contract.\n', '    function activate()\n', '        external\n', '        override\n', '        virtual\n', '    {\n', '        address wallet = logicalSender();\n', '        bindMethods(wallet);\n', '        emit Activated(wallet);\n', '    }\n', '\n', '    /// @dev This method will cause an re-entry to the same module contract.\n', '    function deactivate()\n', '        external\n', '        override\n', '        virtual\n', '    {\n', '        address wallet = logicalSender();\n', '        unbindMethods(wallet);\n', '        emit Deactivated(wallet);\n', '    }\n', '\n', '    ///.@dev Gets the list of methods for binding to wallets.\n', '    ///      Sub-contracts should override this method to provide methods for\n', '    ///      wallet binding.\n', '    /// @return methods A list of method selectors for binding to the wallet\n', '    ///         when this module is activated for the wallet.\n', '    function bindableMethods()\n', '        public\n', '        pure\n', '        virtual\n', '        returns (bytes4[] memory methods);\n', '\n', '    // ===== internal & private methods =====\n', '\n', '    /// @dev Binds all methods to the given wallet.\n', '    function bindMethods(address wallet)\n', '        internal\n', '    {\n', '        Wallet w = Wallet(wallet);\n', '        bytes4[] memory methods = bindableMethods();\n', '        for (uint i = 0; i < methods.length; i++) {\n', '            w.bindMethod(methods[i], address(this));\n', '        }\n', '    }\n', '\n', '    /// @dev Unbinds all methods from the given wallet.\n', '    function unbindMethods(address wallet)\n', '        internal\n', '    {\n', '        Wallet w = Wallet(wallet);\n', '        bytes4[] memory methods = bindableMethods();\n', '        for (uint i = 0; i < methods.length; i++) {\n', '            w.bindMethod(methods[i], address(0));\n', '        }\n', '    }\n', '\n', '    function transactCall(\n', '        address wallet,\n', '        address to,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bytes memory)\n', '    {\n', '        return Wallet(wallet).transact(uint8(1), to, value, data);\n', '    }\n', '\n', '    // Special case for transactCall to support transfers on "bad" ERC20 tokens\n', '    function transactTokenTransfer(\n', '        address wallet,\n', '        address token,\n', '        address to,\n', '        uint    amount\n', '        )\n', '        internal\n', '    {\n', '        if (token == address(0)) {\n', '            transactCall(wallet, to, amount, "");\n', '            return;\n', '        }\n', '\n', '        bytes memory txData = abi.encodeWithSelector(\n', '            ERC20.transfer.selector,\n', '            to,\n', '            amount\n', '        );\n', '        bytes memory returnData = transactCall(wallet, token, 0, txData);\n', '        // `transactCall` will revert if the call was unsuccessful.\n', '        // The only extra check we have to do is verify if the return value (if there is any) is correct.\n', '        bool success = returnData.length == 0 ? true :  abi.decode(returnData, (bool));\n', '        require(success, "ERC20_TRANSFER_FAILED");\n', '    }\n', '\n', '    // Special case for transactCall to support approvals on "bad" ERC20 tokens\n', '    function transactTokenApprove(\n', '        address wallet,\n', '        address token,\n', '        address spender,\n', '        uint    amount\n', '        )\n', '        internal\n', '    {\n', '        require(token != address(0), "INVALID_TOKEN");\n', '        bytes memory txData = abi.encodeWithSelector(\n', '            ERC20.approve.selector,\n', '            spender,\n', '            amount\n', '        );\n', '        bytes memory returnData = transactCall(wallet, token, 0, txData);\n', '        // `transactCall` will revert if the call was unsuccessful.\n', '        // The only extra check we have to do is verify if the return value (if there is any) is correct.\n', '        bool success = returnData.length == 0 ? true :  abi.decode(returnData, (bool));\n', '        require(success, "ERC20_APPROVE_FAILED");\n', '    }\n', '\n', '    function transactDelegateCall(\n', '        address wallet,\n', '        address to,\n', '        uint    value,\n', '        bytes   calldata data\n', '        )\n', '        internal\n', '        returns (bytes memory)\n', '    {\n', '        return Wallet(wallet).transact(uint8(2), to, value, data);\n', '    }\n', '\n', '    function transactStaticCall(\n', '        address wallet,\n', '        address to,\n', '        bytes   calldata data\n', '        )\n', '        internal\n', '        returns (bytes memory)\n', '    {\n', '        return Wallet(wallet).transact(uint8(3), to, 0, data);\n', '    }\n', '\n', '    function reimburseGasFee(\n', '        address     wallet,\n', '        address     recipient,\n', '        address     gasToken,\n', '        uint        gasPrice,\n', '        uint        gasAmount,\n', '        bool        skipQuota\n', '        )\n', '        internal\n', '    {\n', '        uint gasCost = gasAmount.mul(gasPrice);\n', '\n', '        if (!skipQuota) {\n', '            uint value = controller().priceOracle().tokenValue(gasToken, gasCost);\n', '            if (value > 0) {\n', '              controller().quotaStore().checkAndAddToSpent(wallet, value);\n', '            }\n', '        }\n', '\n', '        transactTokenTransfer(wallet, gasToken, recipient, gasCost);\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '// This contract is created to generate the ABI for\n', '// interacting with the SecurityStore in the 1.0.2 release.\n', 'abstract contract SecurityStore_1_0_2\n', '{\n', '    struct Guardian\n', '    {\n', '        address  addr;\n', '        uint     group;\n', '        uint     validSince;\n', '        uint     validUntil;\n', '    }\n', '\n', '    // @dev Returns guardians who are either active or pending addition.\n', '    function guardians(address wallet)\n', '        public\n', '        virtual\n', '        view\n', '        returns (Guardian[] memory _guardians);\n', '\n', '    function inheritor(address wallet)\n', '        public\n', '        virtual\n', '        view\n', '        returns (address who, uint lastActive);\n', '}\n', '\n', '\n', '\n', '/// @title UpgraderModule\n', '/// @dev This module removes obsoleted modules and add new modules, then\n', '///      removes itself.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'contract UpgraderModule is BaseModule {\n', '    ControllerImpl private controller_;\n', '\n', '    address    public walletImplementation;\n', '    address[]  public modulesToRemove;\n', '    address[]  public modulesToAdd;\n', '\n', '    SecurityStore_1_0_2 oldSecurityStore;\n', '    SecurityStore       newSecurityStore;\n', '\n', '    constructor(\n', '        ControllerImpl   _controller,\n', '        address          _walletImplementation,\n', '        address[] memory _modulesToAdd,\n', '        address[] memory _modulesToRemove,\n', '        address          _oldSecurityStore,\n', '        address          _newSecurityStore\n', '        )\n', '    {\n', '        controller_ = _controller;\n', '        walletImplementation = _walletImplementation;\n', '        modulesToAdd = _modulesToAdd;\n', '        modulesToRemove = _modulesToRemove;\n', '\n', '        oldSecurityStore = SecurityStore_1_0_2(_oldSecurityStore);\n', '        newSecurityStore = SecurityStore(_newSecurityStore);\n', '    }\n', '\n', '    function controller()\n', '        internal\n', '        view\n', '        override\n', '        returns(ControllerImpl)\n', '    {\n', '        return ControllerImpl(controller_);\n', '    }\n', '\n', '    function bindableMethods()\n', '        public\n', '        pure\n', '        override\n', '        returns (bytes4[] memory methods)\n', '    {\n', '    }\n', '\n', '    function upgradeWalletImplementation(address payable wallet)\n', '        external\n', '    {\n', '        require(msg.sender == address(this), "NOT_ALLOWED");\n', '\n', '        if (walletImplementation != OwnedUpgradeabilityProxy(wallet).implementation()) {\n', '            bytes memory txData = abi.encodeWithSelector(\n', '                OwnedUpgradeabilityProxy.upgradeTo.selector,\n', '                walletImplementation\n', '            );\n', '            transactCall(wallet, wallet, 0, txData);\n', '        }\n', '    }\n', '\n', '    function migrateSecurityStore(address wallet)\n', '        internal\n', '    {\n', '        if (oldSecurityStore == SecurityStore_1_0_2(0) ||\n', '            newSecurityStore == SecurityStore(0)) {\n', '            return;\n', '        }\n', '\n', '        SecurityStore_1_0_2.Guardian[] memory guardians =\n', '            oldSecurityStore.guardians(wallet);\n', '\n', '        for (uint i = 0; i < guardians.length; i++) {\n', '            newSecurityStore.addGuardian(\n', '                wallet,\n', '                guardians[i].addr,\n', '                guardians[i].group,\n', '                guardians[i].validSince\n', '            );\n', '        }\n', '\n', '        (address inheritor,) = oldSecurityStore.inheritor(wallet);\n', '        if (inheritor != address(0)) {\n', '            newSecurityStore.setInheritor(wallet, inheritor);\n', '        }\n', '    }\n', '\n', '    function activate()\n', '        external\n', '        override\n', '    {\n', '        address payable wallet = msg.sender;\n', '\n', '        if (walletImplementation != address(0)) {\n', '            try UpgraderModule(address(this)).upgradeWalletImplementation(wallet) {} catch {}\n', '        }\n', '\n', '        BaseWallet w = BaseWallet(wallet);\n', '\n', '        // Upgrade the controller if different\n', '        if (w.controller() != controller_) {\n', '            w.setController(controller_);\n', '        }\n', '\n', '        for(uint i = 0; i < modulesToRemove.length; i++) {\n', '            if (w.hasModule(modulesToRemove[i])) {\n', '                w.removeModule(modulesToRemove[i]);\n', '            }\n', '        }\n', '\n', '        for(uint i = 0; i < modulesToAdd.length; i++) {\n', '            if (!w.hasModule(modulesToAdd[i])) {\n', '                w.addModule(modulesToAdd[i]);\n', '            }\n', '        }\n', '\n', '        migrateSecurityStore(wallet);\n', '\n', '        emit Activated(wallet);\n', '        w.removeModule(address(this));\n', '    }\n', '}']