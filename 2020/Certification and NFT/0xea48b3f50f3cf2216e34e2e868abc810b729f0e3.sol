['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', 'contract ValueMultiVaultMaster {\n', '    address public governance;\n', '\n', '    address public valueToken = address(0x49E833337ECe7aFE375e44F4E3e8481029218E5c);\n', '\n', '    address public govVault = address(0xceC03a960Ea678A2B6EA350fe0DbD1807B22D875); // 14.0% profit from Value Vaults\n', '    address public insuranceFund = 0xb7b2Ea8A1198368f950834875047aA7294A2bDAa; // set to Governance Multisig at start\n', '    address public performanceReward = 0x7Be4D5A99c903C437EC77A20CB6d0688cBB73c7f; // set to deploy wallet at start\n', '\n', '    uint256 public govVaultProfitShareFee = 1400; // 14.0% | VIP-7 (https://yfv.finance/vip-vote/vip_7)\n', '    uint256 public gasFee = 100; // 1.0% at start and can be set by governance decision\n', '    uint256 public insuranceFee = 0; // % of deposits go into an insurance fund (or auto-compounding if called by controller) in-case of negative profits to protect withdrawals\n', '    uint256 public withdrawalProtectionFee = 10; // % of withdrawal go back to vault (for auto-compounding) to protect withdrawals\n', '\n', '    mapping(address => address) public bank;\n', '    mapping(address => bool) public isVault;\n', '    mapping(address => bool) public isController;\n', '    mapping(address => bool) public isStrategy;\n', '\n', '    mapping(address => uint) public slippage; // over 10000\n', '\n', '    constructor(address _valueToken) public {\n', '        valueToken = _valueToken;\n', '        governance = msg.sender;\n', '    }\n', '\n', '    function setGovernance(address _governance) external {\n', '        require(msg.sender == governance, "!governance");\n', '        governance = _governance;\n', '    }\n', '\n', '    function setBank(address _vault, address _bank) external {\n', '        require(msg.sender == governance, "!governance");\n', '        bank[_vault] = _bank;\n', '    }\n', '\n', '    function addVault(address _vault) external {\n', '        require(msg.sender == governance, "!governance");\n', '        isVault[_vault] = true;\n', '    }\n', '\n', '    function removeVault(address _vault) external {\n', '        require(msg.sender == governance, "!governance");\n', '        isVault[_vault] = false;\n', '    }\n', '\n', '    function addController(address _controller) external {\n', '        require(msg.sender == governance, "!governance");\n', '        isController[_controller] = true;\n', '    }\n', '\n', '    function removeController(address _controller) external {\n', '        require(msg.sender == governance, "!governance");\n', '        isController[_controller] = true;\n', '    }\n', '\n', '    function addStrategy(address _strategy) external {\n', '        require(msg.sender == governance, "!governance");\n', '        isStrategy[_strategy] = true;\n', '    }\n', '\n', '    function removeStrategy(address _strategy) external {\n', '        require(msg.sender == governance, "!governance");\n', '        isStrategy[_strategy] = false;\n', '    }\n', '\n', '    function setGovVault(address _govVault) public {\n', '        require(msg.sender == governance, "!governance");\n', '        govVault = _govVault;\n', '    }\n', '\n', '    function setInsuranceFund(address _insuranceFund) public {\n', '        require(msg.sender == governance, "!governance");\n', '        insuranceFund = _insuranceFund;\n', '    }\n', '\n', '    function setPerformanceReward(address _performanceReward) public{\n', '        require(msg.sender == governance, "!governance");\n', '        performanceReward = _performanceReward;\n', '    }\n', '\n', '    function setGovVaultProfitShareFee(uint256 _govVaultProfitShareFee) public {\n', '        require(msg.sender == governance, "!governance");\n', '        govVaultProfitShareFee = _govVaultProfitShareFee;\n', '    }\n', '\n', '    function setGasFee(uint256 _gasFee) public {\n', '        require(msg.sender == governance, "!governance");\n', '        gasFee = _gasFee;\n', '    }\n', '\n', '    function setInsuranceFee(uint256 _insuranceFee) public {\n', '        require(msg.sender == governance, "!governance");\n', '        require(_insuranceFee <= 100, "_insuranceFee over 1%");\n', '        insuranceFee = _insuranceFee;\n', '    }\n', '\n', '    function setWithdrawalProtectionFee(uint256 _withdrawalProtectionFee) public {\n', '        require(msg.sender == governance, "!governance");\n', '        require(_withdrawalProtectionFee <= 100, "_withdrawalProtectionFee over 1%");\n', '        withdrawalProtectionFee = _withdrawalProtectionFee;\n', '    }\n', '\n', '    function setSlippage(address _token, uint _slippage) external {\n', '        require(msg.sender == governance, "!governance");\n', '        require(_slippage <= 1000, ">10%");\n', '        slippage[_token] = _slippage;\n', '    }\n', '\n', '    function convertSlippage(address _input, address _output) view external returns (uint) {\n', '        uint _is = slippage[_input];\n', '        uint _os = slippage[_output];\n', '        return (_is > _os) ? _is : _os;\n', '    }\n', '\n', '    /**\n', '     * This function allows governance to take unsupported tokens out of the contract.\n', '     * This is in an effort to make someone whole, should they seriously mess up.\n', '     * There is no guarantee governance will vote to return these.\n', '     * It also allows for removal of airdropped tokens.\n', '     */\n', '    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to) external {\n', '        require(msg.sender == governance, "!governance");\n', '        _token.transfer(to, amount);\n', '    }\n', '}']