['// SPDX-License-Identifier: MIT\n', '// ----------------------------------------------------------------------------\n', '// yBXTB Service contract\n', '// ----------------------------------------------------------------------------\n', 'pragma solidity ^0.7.4;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function addSafe(uint _a, uint _b) internal pure returns (uint c) {\n', '        c = _a + _b;\n', '        require(c >= _a);\n', '    }\n', '    function subSafe(uint _a, uint _b) internal pure returns (uint c) {\n', '        require(_b <= _a, "Insufficient balance");\n', '        c = _a - _b;\n', '    }\n', '    function mulSafe(uint _a, uint _b) internal pure returns (uint c) {\n', '        c = _a * _b;\n', '        require(_a == 0 || c / _a == _b);\n', '    }\n', '    function divSafe(uint _a, uint _b) internal pure returns (uint c) {\n', '        require(_b > 0);\n', '        c = _a / _b;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', '// ----------------------------------------------------------------------------\n', '// For BXTB Interface\n', 'interface ERC20Interface {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address _tokenOwner) external view returns (uint);\n', '    function allowance(address _tokenOwner, address _spender) external view returns (uint);\n', '    function transfer(address _to, uint _amount) external returns (bool);\n', '    function approve(address _spender, uint _amount) external returns (bool);\n', '    function transferFrom(address _from, address _to, uint _amount) external returns (bool);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '// ----------------------------------------------------------------------------\n', 'interface ApproveAndCallFallBack {\n', '    function receiveApproval(address _tokenOwner, uint256 _amount, address _tokenContract, bytes memory _data) external;\n', '}\n', '\n', 'interface SettlementInterface {\n', '    function disburseCommissions(bool _disburseBackstop) external;\n', '}\n', '\n', '\n', '// For USDT Interface\n', "// Changed 'constant' to 'view' for compiler 0.5.4\n", 'interface ERC20_USDT {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address who) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function transfer(address to, uint value) external;\n', '    function approve(address spender, uint value) external;\n', '    function transferFrom(address from, address to, uint value) external;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '    }\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// yBXTB Service Contract\n', '// ----------------------------------------------------------------------------\n', 'contract YieldTokenService is ApproveAndCallFallBack, SettlementInterface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    address public constant USDTContract = 0xdAC17F958D2ee523a2206206994597C13D831ec7;      // USDT contract\n', '    address public constant BXTBContract = 0x7bA9caa5D19002618F1D93e691490377361D5E60;      // BXTB contract\n', '    address public constant yieldTokenContract = 0x39dCCA7984B22cCB0347DeEAeEaaEE6e6Ce9ba9F;     // yBXTB contract\n', '    address public constant CHIPContract = 0x73F737dE96cF8987CA2C4C1FDC5134688BB2e10f;      // CHIP contract\n', '\n', '    address public bxtbFoundation = 0x616143B2e9ADC2F48c9Ad4C30162e0782297f06f;\n', '    address public recoveryAdmin;\n', '    address public settlementAdmin;\n', '    address public backstopAdmin;\n', '\n', '    uint public totalPoolUSDTCollateral;\n', '    uint public totalPoolBXTB;\n', '\n', '    uint public totalPoolCHIPBackStop;\n', '    uint public totalPoolCHIPBackStopAvailable;\n', '\n', '    uint public totalPoolCHIPCommissions;\n', '    uint public totalPoolCHIPCommissionsAvailable;\n', '\n', '    uint public totalSupplyYieldToken;\n', '    uint public outstandingYieldToken;\n', '\n', '    uint public totalSupplyCHIP;\n', '    uint public outstandingCHIP;\n', '\n', '    uint public constant decimals = 6;\n', '    uint public collateralizationRatio;\n', '\n', '    uint public bxtbTokenRatio;\n', '\n', '    bool public allowStaking;\n', '    bool public allowCommissions;\n', '\n', '    constructor() {\n', '        bxtbTokenRatio = 100;           // 100%\n', '        collateralizationRatio = 100;   // 100%\n', '\n', '        allowStaking = true;\n', '        allowCommissions = false;\n', '    }\n', '\n', '    event TotalSupplyYieldTokenChanged(uint _amount);                   // Load YieldToken supply\n', '    event TotalSupplyCHIPChanged(uint _amount);                         // Load CHIP supply\n', '    event OutstandingSupplyChanged();                                   // Change in YieldToken & CHIP in circulation\n', '    event ChangeBxtbTokenRatio(uint _amount);                           // Token ratio changed\n', '    event CommissionReceived(address indexed _sender, uint _amount);    // Commissions received\n', '    event CommissionsDisbursed(uint _amount);\n', '    event BackstopDisbursed(uint _amount);\n', '    event BackstopAdjusted(bool _refunded, uint _amount);\n', '\n', '\n', '    function receiveApproval(address _tokenOwner, uint256 _amount, address _tokenContract, bytes memory _data) public override {\n', '        // Prevent ERC20 short address attack\n', '        // _data length is not fixed\n', '        require((msg.data.length == (6 * 32) + 4) && (_data.length == 1), "Input length error");\n', '\n', '        require(msg.sender == yieldTokenContract ||\n', '        msg.sender == CHIPContract ||\n', '        msg.sender == BXTBContract, "Unknown caller");\n', '\n', '        // Mode 0x10: Normal deposit\n', '        // Mode 0xF0: Load reserve tokens\n', '        uint8 mode = uint8(_data[0]);\n', '        require(mode == 0x10 || mode == 0xE0 || mode == 0xF0, "Mode not accepted");\n', '\n', '        if(mode == 0x10) {\n', '            // Normal deposits for Stake and Redeem\n', '            // Sanity check\n', '            require(totalSupplyYieldToken == totalSupplyCHIP, "Supply imbalance");\n', '            uint wildChip;\n', '\n', '            // Credit to caller\n', '            if(msg.sender == BXTBContract) {\n', '                // Stake\n', '                // Staking paused by admin\n', '                require(allowStaking == true, "Staking is paused");\n', '\n', '                // Get allowance\n', '                uint allowanceUsdt = ERC20_USDT(USDTContract).allowance(_tokenOwner, address(this));\n', '                uint allowanceBxtb = _amount;\n', '\n', '                // Enforce token staking ratio\n', '                if(bxtbTokenRatio == 100) {  // 100 percent\n', '                    // Get minimum common size. Size must be the same\n', '                    if(allowanceUsdt <= allowanceBxtb) allowanceBxtb = allowanceUsdt;\n', '                    else allowanceUsdt = allowanceBxtb;\n', '                }\n', '                else {\n', '                    if(bxtbTokenRatio > 0) {\n', '                        uint allowanceBxtbExpected = allowanceUsdt.mulSafe(bxtbTokenRatio).divSafe(100);\n', '                        if(allowanceBxtb >= allowanceBxtbExpected) allowanceBxtb = allowanceBxtbExpected;  // Sufficient BXTB\n', '                        else allowanceUsdt = allowanceBxtb.mulSafe(100).divSafe(bxtbTokenRatio);  // Reduce USDT due to insufficient BXTB\n', '                    }\n', '                    else allowanceBxtb = 0;  // Prevent divide-by-zero errors\n', '                }\n', '\n', "                // Issue YieldToken 'n' CHIP\n", '                require(allowanceUsdt > 0, "Zero stake");\n', '\n', '                // How many YieldToken are in reserve?\n', '                uint remainderYieldToken = totalSupplyYieldToken.subSafe(outstandingYieldToken);\n', '                // If not enough YieldToken. Reject transaction\n', '                require((allowanceUsdt <= remainderYieldToken) && (remainderYieldToken > 0), "Staking size exceeded");\n', '\n', '                // Accept USDT\n', '                ERC20_USDT(USDTContract).transferFrom(_tokenOwner, address(this), allowanceUsdt);\n', '\n', '                // For every USDT stake, issue 1 CHIP and 1 YieldToken\n', '                // Update pool counter\n', '                totalPoolUSDTCollateral = totalPoolUSDTCollateral.addSafe(allowanceUsdt);\n', '\n', '                // Send out event for change in outstanding supply\n', '                emit OutstandingSupplyChanged();\n', '\n', '                // Accept BXTB\n', '                if(allowanceBxtb > 0) {\n', '                    ERC20Interface(BXTBContract).transferFrom(_tokenOwner, address(this), allowanceBxtb);\n', '                    totalPoolBXTB = totalPoolBXTB.addSafe(allowanceBxtb);\n', '                }\n', '\n', '                // Issue YieldToken and CHIP, and update outstanding tokens\n', '                // outstandingYieldToken and outstandingCHIP must be synchronized at all cost!\n', '                outstandingYieldToken = outstandingYieldToken.addSafe(allowanceUsdt);\n', '                outstandingCHIP = outstandingCHIP.addSafe(allowanceUsdt);\n', '\n', '                ERC20Interface(yieldTokenContract).transfer(_tokenOwner, allowanceUsdt);\n', '                ERC20Interface(CHIPContract).transfer(_tokenOwner, allowanceUsdt);\n', '\n', '                // Calculate collat ratio\n', '                wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);\n', '                if(wildChip > 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent\n', '                else collateralizationRatio = 100;\n', '            }\n', '            else if(msg.sender == CHIPContract) {\n', '                // Redeem\n', '                // Get allowance\n', '                uint allowanceYieldToken = ERC20Interface(yieldTokenContract).allowance(_tokenOwner, address(this));\n', '                uint allowanceCHIP = _amount;\n', '\n', '                uint allowanceSize;\n', '                // Get minimum common size. Size must be the same\n', '                if(allowanceYieldToken <= allowanceCHIP) allowanceSize = allowanceYieldToken;\n', '                else allowanceSize = allowanceCHIP;\n', '\n', '                // Redeem YieldToken and CHIP tokens\n', '                require(allowanceSize > 0, "Zero redeem");\n', '\n', "                // Can't redeem more than outstanding CHIP\n", '                require((allowanceSize <= outstandingCHIP) && (outstandingCHIP > 0), "Redemption size exceeded");\n', '\n', '                // Accept YieldToken and CHIP\n', '                ERC20Interface(yieldTokenContract).transferFrom(_tokenOwner, address(this), allowanceSize);\n', '                ERC20Interface(CHIPContract).transferFrom(_tokenOwner, address(this), allowanceSize);\n', '\n', '                // Take YieldToken and CHIP out of circulation\n', '                // outstandingYieldToken and outstandingCHIP must be synchronized at all cost\n', '                outstandingYieldToken = outstandingYieldToken.subSafe(allowanceSize);\n', '                outstandingCHIP = outstandingCHIP.subSafe(allowanceSize);\n', '\n', '                // Emit event for change in outstanding supply\n', '                emit OutstandingSupplyChanged();\n', '\n', '                // Pay out equivalent amount of USDT, and send BXTB to Foundation\n', '                uint shareOfBxtb;\n', '\n', '                if(outstandingCHIP > 0) {\n', '                    // Update pool counters\n', '                    totalPoolUSDTCollateral = totalPoolUSDTCollateral.subSafe(allowanceSize);\n', '                    // Send back collateral\n', '                    ERC20_USDT(USDTContract).transfer(_tokenOwner, allowanceSize);\n', '\n', '                    // Enforce token redemption ratio\n', '                    if(bxtbTokenRatio == 100) shareOfBxtb = allowanceSize;  // 100 percent\n', '                    else shareOfBxtb = allowanceSize.mulSafe(bxtbTokenRatio).divSafe(100);\n', '\n', "                    // Can't take out more BXTB than exists\n", '                    if(shareOfBxtb > totalPoolBXTB) shareOfBxtb = totalPoolBXTB;\n', '\n', '                    // Update counters\n', '                    totalPoolBXTB = totalPoolBXTB.subSafe(shareOfBxtb);\n', '                    // Send BXTB to foundation\n', '                    ERC20Interface(BXTBContract).transfer(bxtbFoundation, shareOfBxtb);\n', '\n', '                    // Calculate collat ratio\n', '                    wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);\n', '                    if(wildChip > 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent\n', '                    else collateralizationRatio = 100;\n', '                }\n', '                else {\n', '                    // Last redeemer: Disburse everything\n', '                    // In case contract accumulates more than expected, this clears out the account\n', '                    // Hard resets USDT counter. No more outstanding CHIP and YieldTokens\n', '                    outstandingCHIP = 0;\n', '                    outstandingYieldToken = 0;\n', '\n', '                    // Pay out USDT\n', '                    totalPoolUSDTCollateral = 0;\n', '                    uint residualValue = ERC20_USDT(USDTContract).balanceOf(address(this));\n', '                    ERC20_USDT(USDTContract).transfer(_tokenOwner, residualValue);\n', '\n', '                    // Hard reset BXTB counters\n', '                    totalPoolBXTB = 0;\n', '                    // Send BXTB to foundation\n', '                    shareOfBxtb = ERC20Interface(BXTBContract).balanceOf(address(this));\n', '                    ERC20Interface(BXTBContract).transfer(bxtbFoundation, shareOfBxtb);\n', '\n', '                    // Calculate collat ratio\n', '                    collateralizationRatio = 100;\n', '                }\n', '            }\n', '            else revert("Unknown stake/redeem token");\n', '        }\n', '        else if(mode == 0xE0) {\n', '            // Pay commissions\n', '            require(msg.sender == CHIPContract, "Only CHIP accepted");\n', '            payCommission(_tokenOwner);\n', '        }\n', '        else if(mode == 0xF0) {\n', '            // Load reserve tokens\n', '            // Only contract owner can load it\n', '            require((_tokenOwner == owner) && (owner != address(0)), "Caller must be owner");\n', '            // Check allowance\n', '            require(_amount > 0, "Zero deposit");\n', '\n', '            // YieldToken and CHIP reserve must be equal prior to staking commencement\n', '            if(msg.sender == yieldTokenContract) {\n', '                // Retrieve tokens\n', '                ERC20Interface(yieldTokenContract).transferFrom(_tokenOwner, address(this), _amount);\n', '                // Update total supply\n', '                totalSupplyYieldToken = totalSupplyYieldToken.addSafe(_amount);\n', '                // Emit event\n', '                emit TotalSupplyYieldTokenChanged(totalSupplyYieldToken);\n', '            }\n', '            else if(msg.sender == CHIPContract) {\n', '                // Retrieve tokens\n', '                ERC20Interface(CHIPContract).transferFrom(_tokenOwner, address(this), _amount);\n', '                // Update total supply\n', '                totalSupplyCHIP = totalSupplyCHIP.addSafe(_amount);\n', '                // Emit event\n', '                emit TotalSupplyCHIPChanged(totalSupplyCHIP);\n', '            }\n', '            else revert("Unknown reserve token");\n', '        }\n', '    }\n', '\n', '    // Pay commission\n', '    function payCommission(address _sender) internal {\n', '        require(allowCommissions == true, "Commissions paused");\n', '\n', '        uint allowanceCHIP = ERC20Interface(CHIPContract).allowance(_sender, address(this));\n', '        require(allowanceCHIP > 0, "Zero commission");\n', '\n', '        if(outstandingYieldToken > 0) {\n', '            // Distribute commission to unit holders\n', '            // Accept the deposit\n', '            ERC20Interface(CHIPContract).transferFrom(_sender, address(this), allowanceCHIP);\n', '            // Send to comission pools\n', '            distributeToPools(allowanceCHIP);\n', '            // Log event\n', '            emit CommissionReceived(_sender, allowanceCHIP);\n', '        }\n', '        else {\n', '            // This code should be unreachable\n', '            // No more unit holders\n', '            address recipient;\n', '            if(owner != address(0)) recipient = owner;  // Send to contract owner\n', '            else if(settlementAdmin != address(0)) recipient = settlementAdmin;  // If no contract owner, send to Settlement Admin\n', '            else if(bxtbFoundation != address(0)) recipient = bxtbFoundation;  // If no contract owner, send to BXTB Foundation\n', '            else revert("No recipients");  // No foundation, decline commission\n', '\n', '            // Accept the deposit\n', '            ERC20Interface(CHIPContract).transferFrom(_sender, recipient, allowanceCHIP);\n', '            // Log event\n', '            emit CommissionReceived(_sender, allowanceCHIP);\n', '        }\n', '    }\n', '\n', '    function distributeToPools(uint _amount) internal {\n', '        require(outstandingYieldToken > 0, "No more unit holders");\n', '\n', '        uint backstopShortfall;\n', '        uint backstopTarget = totalPoolUSDTCollateral.divSafe(10);  // Target backstop to be 10% of collateral\n', '\n', '        // Over collateralize coin up to 10% (100% collateral + 10% backstop)\n', '        if(totalPoolCHIPBackStop < backstopTarget) backstopShortfall = backstopTarget.subSafe(totalPoolCHIPBackStop);\n', '\n', '        // Share commission between internal totalPools\n', '        if(backstopShortfall > 0) {\n', '            // Send portion to backstop pool\n', '            uint allocateBackstop = _amount.divSafe(6);  // 1/6th goes to backstop pool\n', '\n', '            if(allocateBackstop > backstopShortfall) allocateBackstop = backstopShortfall;  // Limit reached\n', '\n', '            uint allocateCommission = _amount.subSafe(allocateBackstop);\n', '\n', '            // Send to pools\n', '            totalPoolCHIPBackStop = totalPoolCHIPBackStop.addSafe(allocateBackstop);                    // Cumulative amount deposited\n', '            totalPoolCHIPBackStopAvailable = totalPoolCHIPBackStopAvailable.addSafe(allocateBackstop);  // Current balance in contract\n', '\n', '            totalPoolCHIPCommissions = totalPoolCHIPCommissions.addSafe(allocateCommission);                    // Cumulative amount deposited\n', '            totalPoolCHIPCommissionsAvailable = totalPoolCHIPCommissionsAvailable.addSafe(allocateCommission);  // Current balance in contract\n', '        }\n', '        else {\n', '            // Send all to commissions pool\n', '            totalPoolCHIPCommissions = totalPoolCHIPCommissions.addSafe(_amount);                       // Cumulative amount deposited\n', '            totalPoolCHIPCommissionsAvailable = totalPoolCHIPCommissionsAvailable.addSafe(_amount);     // Current balance in contract\n', '        }\n', '\n', '        // Calculate collat ratio\n', '        uint wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);\n', '        if(wildChip > 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent\n', '        else collateralizationRatio = 100;\n', '    }\n', '\n', '    // Perform settlement\n', '    function disburseCommissions(bool _disburseBackstop) external override {\n', '        require((msg.sender == yieldTokenContract) ||\n', '        (msg.sender == settlementAdmin) ||\n', '            (msg.sender == owner) , "Caller not authorized");\n', '\n', '        require(settlementAdmin != address(0), "Settlement Admin address error");\n', '\n', '        // How much funds to disburse?\n', '        uint withdrawAmount = totalPoolCHIPCommissionsAvailable;\n', '        totalPoolCHIPCommissionsAvailable = 0;\n', '        // Pay out to settlementAdmin account\n', '        ERC20Interface(CHIPContract).transfer(settlementAdmin, withdrawAmount);\n', '        emit CommissionsDisbursed(withdrawAmount);\n', '\n', '        // Send out the backstop balance too\n', '        if(_disburseBackstop == true) {\n', '            require(backstopAdmin != address(0), "Backstop Admin address error");\n', '\n', '            // How much to pay out?\n', '            withdrawAmount = totalPoolCHIPBackStopAvailable;\n', '            totalPoolCHIPBackStopAvailable = 0;\n', '            // Disburse backstop CHIPs to backstop Admin\n', '            ERC20Interface(CHIPContract).transfer(backstopAdmin, withdrawAmount);\n', '            emit BackstopDisbursed(withdrawAmount);\n', '        }\n', '    }\n', '\n', '    // Send out backstop balance\n', '    function disburseBackstop() external {\n', '        require((msg.sender == backstopAdmin) || (msg.sender == owner), "Caller not authorized");\n', '        require(backstopAdmin != address(0), "Backstop Admin address error");\n', '\n', '        // How much to pay out?\n', '        uint withdrawAmount = totalPoolCHIPBackStopAvailable;\n', '        totalPoolCHIPBackStopAvailable = 0;\n', '        // Disburse backstop CHIPs to backstop Admin\n', '        ERC20Interface(CHIPContract).transfer(backstopAdmin, withdrawAmount);\n', '        emit BackstopDisbursed(withdrawAmount);\n', '    }\n', '\n', '    // Update collat ratio after refunding backstop to CHIP or yBXTB holders\n', '    function adjustBackstop(bool _refunded, uint _amount) external {\n', '        require((msg.sender == backstopAdmin) || (msg.sender == owner), "Caller not authorized");\n', '\n', '        if(_refunded == true) totalPoolCHIPBackStop = totalPoolCHIPBackStop.subSafe(_amount);  // Back out refunded amount\n', '        else totalPoolCHIPBackStop = totalPoolCHIPBackStop.addSafe(_amount);  // Add more. This is used to fix user errors\n', '\n', '        // Recalculate collateralization ratio\n', '        uint wildChip = outstandingCHIP.subSafe(totalPoolCHIPBackStop);\n', '        if(wildChip > 0) collateralizationRatio = totalPoolUSDTCollateral.mulSafe(100).divSafe(wildChip);  // In percent\n', '        else collateralizationRatio = 100;\n', '\n', '        emit BackstopAdjusted(_refunded, _amount);\n', '    }\n', '\n', '    // Change Recovery Admin for lost coins\n', '    function changeRecoveryAdmin(address _newAddress) external {\n', '        require(msg.data.length == 32 + 4, "Address error");  // Prevent input error\n', '        require((msg.sender == recoveryAdmin) || (msg.sender == owner), "Caller not authorized");\n', '        recoveryAdmin = _newAddress;\n', '    }\n', '\n', '    // Change Settlement Admin for daily settlements\n', '    function changeSettlementAdmin(address _newAddress) external {\n', '        require(msg.data.length == 32 + 4, "Address error");  // Prevent input error\n', '        require((msg.sender == settlementAdmin) || (msg.sender == owner), "Caller not authorized");\n', '        settlementAdmin = _newAddress;\n', '    }\n', '\n', '    // Change Backstop Admin for managing backstop balance\n', '    function changeBackstopAdmin(address _newAddress) external {\n', '        require(msg.data.length == 32 + 4, "Address error");  // Prevent input error\n', '        require((msg.sender == backstopAdmin) || (msg.sender == owner), "Caller not authorized");\n', '        backstopAdmin = _newAddress;\n', '    }\n', '\n', '    // Change BXBT Foundation Address\n', '    function changeBxtbFoundation(address _newAddress) external {\n', '        require(msg.data.length == 32 + 4, "Address error");  // Prevent input error\n', '        require(msg.sender == bxtbFoundation, "Caller not authorized");\n', '        bxtbFoundation = _newAddress;\n', '    }\n', '\n', '    // Change BXTB-to-USDT ratio for staking, and BXTB-to-YieldToken ratio redemption\n', '    function changebxtbTokenRatio(uint _newRatio) external {\n', '        require(msg.sender == bxtbFoundation, "Caller not authorized");\n', '        bxtbTokenRatio = _newRatio;\n', '        emit ChangeBxtbTokenRatio(_newRatio);\n', '    }\n', '\n', '    function setAllowStaking(bool _allow) external onlyOwner {\n', '        allowStaking = _allow;\n', '    }\n', '\n', '    function setAllowCommissions(bool _allow) external onlyOwner {\n', '        allowCommissions = _allow;\n', '    }\n', '\n', '    // Retrieve lost coins (USDT, BXTB, YieldToken, CHIP)\n', '    // If coins are accidentally sent to the contract, calling this function will recover them\n', '    function recoverLostCoins(uint _amount, address _fromTokenContract, address _recoveryAddress) external {\n', '        require(msg.data.length == (3 * 32) + 4, "Input length error");\n', '\n', '        bool hasAdmin;\n', '        if(recoveryAdmin != address(0)) {\n', '            if(msg.sender == recoveryAdmin) {\n', '                hasAdmin = true;\n', '            }\n', '            else if(_fromTokenContract == BXTBContract) {\n', '                // But also let foundation call for BXTB\n', '                if(bxtbFoundation != address(0)) {\n', '                    if(msg.sender != bxtbFoundation) revert("Caller must be admin");\n', '                }\n', '                else revert("Caller must be admin");\n', '            }\n', '            else revert("Caller must be admin");\n', '        }\n', '\n', '        if(_fromTokenContract == USDTContract) recoverLostUSDT(_amount, _fromTokenContract, _recoveryAddress, msg.sender, hasAdmin);\n', '        else if(_fromTokenContract == BXTBContract) recoverLostBXTB(_amount, _fromTokenContract, _recoveryAddress, msg.sender, hasAdmin);\n', '        else recoverLostERC20(_amount, _fromTokenContract, _recoveryAddress, msg.sender, hasAdmin);\n', '    }\n', '\n', '    function recoverLostUSDT(uint _amount, address _fromTokenContract, address _recoveryAddress, address _sender, bool _hasAdmin) internal {\n', '        uint amountAdmin;\n', '        uint amountOwner;\n', '        uint amountRecoveryAddress;\n', '        uint amountSender;\n', '\n', '        uint sweepAmount;\n', '        uint recoverAmount;\n', '\n', '        // How much is lost in this contract?\n', '        sweepAmount = ERC20_USDT(_fromTokenContract).balanceOf(address(this));\n', '        if(sweepAmount > totalPoolUSDTCollateral) {\n', '            sweepAmount = sweepAmount.subSafe(totalPoolUSDTCollateral);\n', '\n', '            // Retrieve amount\n', '            if(_amount <= sweepAmount) {\n', '                recoverAmount = _amount.mulSafe(3).divSafe(4);\n', '                sweepAmount = sweepAmount.subSafe(recoverAmount);\n', '            }\n', '\n', '            if(_hasAdmin) {\n', '                // Send 1/4 + swept up amounts to admin\n', '                amountAdmin = sweepAmount;\n', '\n', '                // Send 3/4 to recovery address or admin\n', '                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\n', '                else amountAdmin = amountAdmin.addSafe(recoverAmount);\n', '            }\n', '            else {\n', '                // Send 1/4 fees + swept up amounts to: Owner\n', '                amountOwner = sweepAmount;\n', '\n', '                // Send 3/4 balance to: Recovery address, Sender\n', '                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\n', '                else amountSender = recoverAmount;\n', '            }\n', '\n', '            if(amountAdmin > 0) ERC20_USDT(_fromTokenContract).transfer(recoveryAdmin, amountAdmin);\n', '            if(amountOwner > 0) ERC20_USDT(_fromTokenContract).transfer(owner, amountOwner);\n', '            if(amountRecoveryAddress > 0) ERC20_USDT(_fromTokenContract).transfer(_recoveryAddress, amountRecoveryAddress);\n', '            if(amountSender > 0) ERC20_USDT(_fromTokenContract).transfer(_sender, amountSender);\n', '        }\n', '    }\n', '\n', '    function recoverLostBXTB(uint _amount, address _fromTokenContract, address _recoveryAddress, address _sender, bool _hasAdmin) internal {\n', '        uint amountAdmin;\n', '        uint amountFoundation;\n', '        uint amountRecoveryAddress;\n', '        uint amountSender;\n', '\n', '        uint sweepAmount;\n', '        uint recoverAmount;\n', '\n', '        // How much is lost in this contract?\n', '        sweepAmount = ERC20Interface(_fromTokenContract).balanceOf(address(this));\n', '        if(sweepAmount > totalPoolBXTB) {\n', '            sweepAmount = sweepAmount.subSafe(totalPoolBXTB);\n', '\n', '            // Retrieve amount\n', '            if(_amount <= sweepAmount) {\n', '                recoverAmount = _amount.mulSafe(3).divSafe(4);\n', '                sweepAmount = sweepAmount.subSafe(recoverAmount);\n', '            }\n', '\n', '            if(_hasAdmin) {\n', '                // Send 1/4 fees + swept up amounts to: BXTB foundation, Admin\n', '                if(bxtbFoundation != address(0)) amountFoundation = sweepAmount;\n', '                else amountAdmin = sweepAmount;\n', '                // Send 3/4 balance to: Recovery address, Admin\n', '                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\n', '                else amountAdmin = amountAdmin.addSafe(recoverAmount);\n', '            }\n', '            else {\n', '                // Send 1/4 fees + swept up amounts to: BXTB foundation, Recovery address, Sender\n', '                if(bxtbFoundation != address(0)) amountFoundation = sweepAmount;\n', '                else if(_recoveryAddress != address(0)) amountRecoveryAddress = sweepAmount;\n', '                else amountSender = sweepAmount;\n', '\n', '                // Send 3/4 balance to: Recovery address, Sender\n', '                if(_recoveryAddress != address(0)) amountRecoveryAddress = amountRecoveryAddress.addSafe(recoverAmount);\n', '                else amountSender = amountSender.addSafe(recoverAmount);\n', '            }\n', '\n', '            if(amountAdmin > 0) ERC20Interface(_fromTokenContract).transfer(recoveryAdmin, amountAdmin);\n', '            if(amountFoundation > 0) ERC20Interface(_fromTokenContract).transfer(bxtbFoundation, amountFoundation);\n', '            if(amountRecoveryAddress > 0) ERC20Interface(_fromTokenContract).transfer(_recoveryAddress, amountRecoveryAddress);\n', '            if(amountSender > 0) ERC20Interface(_fromTokenContract).transfer(_sender, amountSender);\n', '        }\n', '    }\n', '\n', '    function recoverLostERC20(uint _amount, address _fromTokenContract, address _recoveryAddress, address _sender, bool _hasAdmin) internal {\n', '        uint amountAdmin;\n', '        uint amountOwner;\n', '        uint amountRecoveryAddress;\n', '        uint amountSender;\n', '\n', '        uint sweepAmount;\n', '        uint recoverAmount;\n', '        uint poolSize;\n', '\n', '        // How much is lost in this contract?\n', '        sweepAmount = ERC20Interface(_fromTokenContract).balanceOf(address(this));\n', '\n', '        if(_fromTokenContract == yieldTokenContract) poolSize = outstandingYieldToken;\n', '        else if(_fromTokenContract == CHIPContract) poolSize = outstandingCHIP;\n', '        else poolSize = 0;\n', '\n', '        if(sweepAmount > poolSize) {\n', '            sweepAmount = sweepAmount.subSafe(poolSize);\n', '\n', '            // Retrieve amount\n', '            if(_amount <= sweepAmount) {\n', '                recoverAmount = _amount.mulSafe(3).divSafe(4);\n', '                sweepAmount = sweepAmount.subSafe(recoverAmount);\n', '            }\n', '\n', '            if(_hasAdmin) {\n', '                // Send 1/4 fees + swept up amounts to: Admin\n', '                amountAdmin = sweepAmount;\n', '\n', '                // Send 3/4 balance to: Recovery address, Admin\n', '                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\n', '                else amountAdmin = amountAdmin.addSafe(recoverAmount);\n', '            }\n', '            else {\n', '                // Send 1/4 fees + swept up amounts to: Owner\n', '                amountOwner = sweepAmount;\n', '\n', '                // Send 3/4 balance to: Recovery address, Sender\n', '                if(_recoveryAddress != address(0)) amountRecoveryAddress = recoverAmount;\n', '                else amountSender = recoverAmount;\n', '            }\n', '\n', '            if(amountAdmin > 0) ERC20Interface(_fromTokenContract).transfer(recoveryAdmin, amountAdmin);\n', '            if(amountOwner > 0) ERC20Interface(_fromTokenContract).transfer(owner, amountOwner);\n', '            if(amountRecoveryAddress > 0) ERC20Interface(_fromTokenContract).transfer(_recoveryAddress, amountRecoveryAddress);\n', '            if(amountSender > 0) ERC20Interface(_fromTokenContract).transfer(_sender, amountSender);\n', '        }\n', '    }\n', '\n', '}']