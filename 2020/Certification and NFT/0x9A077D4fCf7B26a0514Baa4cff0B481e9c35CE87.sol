['// File: contracts/oracle/interfaces/FinderInterface.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title Provides addresses of the live contracts implementing certain interfaces.\n', ' * @dev Examples are the Oracle or Store interfaces.\n', ' */\n', 'interface FinderInterface {\n', '    /**\n', '     * @notice Updates the address of the contract that implements `interfaceName`.\n', '     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\n', '     * @param implementationAddress address of the deployed contract that implements the interface.\n', '     */\n', '    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\n', '\n', '    /**\n', '     * @notice Gets the address of the contract that implements the given `interfaceName`.\n', '     * @param interfaceName queried interface.\n', '     * @return implementationAddress address of the deployed contract that implements the interface.\n', '     */\n', '    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\n', '}\n', '\n', '// File: @openzeppelin/contracts/GSN/Context.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/access/Ownable.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/common/implementation/Lockable.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\n', ' * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n', ' * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\n', ' */\n', 'contract Lockable {\n', '    bool private _notEntered;\n', '\n', '    constructor() internal {\n', '        // Storing an initial non-zero value makes deployment a bit more\n', '        // expensive, but in exchange the refund on every call to nonReentrant\n', '        // will be lower in amount. Since refunds are capped to a percetange of\n', "        // the total transaction's gas, it is best to keep them low in cases\n", '        // like this one, to increase the likelihood of the full refund coming\n', '        // into effect.\n', '        _notEntered = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _preEntranceCheck();\n', '        _preEntranceSet();\n', '        _;\n', '        _postEntranceReset();\n', '    }\n', '\n', '    /**\n', '     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\n', '     */\n', '    modifier nonReentrantView() {\n', '        _preEntranceCheck();\n', '        _;\n', '    }\n', '\n', "    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\n", '    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being re-entered.\n', '    // Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and then call `_postEntranceReset()`.\n', '    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\n', '    function _preEntranceCheck() internal view {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '    }\n', '\n', '    function _preEntranceSet() internal {\n', '        // Any calls to nonReentrant after this point will fail\n', '        _notEntered = false;\n', '    }\n', '\n', '    function _postEntranceReset() internal {\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '}\n', '\n', '// File: contracts/common/implementation/AddressWhitelist.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title A contract to track a whitelist of addresses.\n', ' */\n', 'contract AddressWhitelist is Ownable, Lockable {\n', '    enum Status { None, In, Out }\n', '    mapping(address => Status) public whitelist;\n', '\n', '    address[] public whitelistIndices;\n', '\n', '    event AddedToWhitelist(address indexed addedAddress);\n', '    event RemovedFromWhitelist(address indexed removedAddress);\n', '\n', '    /**\n', '     * @notice Adds an address to the whitelist.\n', '     * @param newElement the new address to add.\n', '     */\n', '    function addToWhitelist(address newElement) external nonReentrant() onlyOwner {\n', '        // Ignore if address is already included\n', '        if (whitelist[newElement] == Status.In) {\n', '            return;\n', '        }\n', '\n', '        // Only append new addresses to the array, never a duplicate\n', '        if (whitelist[newElement] == Status.None) {\n', '            whitelistIndices.push(newElement);\n', '        }\n', '\n', '        whitelist[newElement] = Status.In;\n', '\n', '        emit AddedToWhitelist(newElement);\n', '    }\n', '\n', '    /**\n', '     * @notice Removes an address from the whitelist.\n', '     * @param elementToRemove the existing address to remove.\n', '     */\n', '    function removeFromWhitelist(address elementToRemove) external nonReentrant() onlyOwner {\n', '        if (whitelist[elementToRemove] != Status.Out) {\n', '            whitelist[elementToRemove] = Status.Out;\n', '            emit RemovedFromWhitelist(elementToRemove);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks whether an address is on the whitelist.\n', '     * @param elementToCheck the address to check.\n', '     * @return True if `elementToCheck` is on the whitelist, or False.\n', '     */\n', '    function isOnWhitelist(address elementToCheck) external view nonReentrantView() returns (bool) {\n', '        return whitelist[elementToCheck] == Status.In;\n', '    }\n', '\n', '    /**\n', '     * @notice Gets all addresses that are currently included in the whitelist.\n', '     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out\n', '     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we\n', '     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to\n', '     * the empty index.\n', '     * @return activeWhitelist the list of addresses on the whitelist.\n', '     */\n', '    function getWhitelist() external view nonReentrantView() returns (address[] memory activeWhitelist) {\n', '        // Determine size of whitelist first\n', '        uint256 activeCount = 0;\n', '        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n', '            if (whitelist[whitelistIndices[i]] == Status.In) {\n', '                activeCount++;\n', '            }\n', '        }\n', '\n', '        // Populate whitelist\n', '        activeWhitelist = new address[](activeCount);\n', '        activeCount = 0;\n', '        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n', '            address addr = whitelistIndices[i];\n', '            if (whitelist[addr] == Status.In) {\n', '                activeWhitelist[activeCount] = addr;\n', '                activeCount++;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/common/implementation/MultiRole.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', 'library Exclusive {\n', '    struct RoleMembership {\n', '        address member;\n', '    }\n', '\n', '    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n', '        return roleMembership.member == memberToCheck;\n', '    }\n', '\n', '    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\n', '        require(newMember != address(0x0), "Cannot set an exclusive role to 0x0");\n', '        roleMembership.member = newMember;\n', '    }\n', '\n', '    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\n', '        return roleMembership.member;\n', '    }\n', '\n', '    function init(RoleMembership storage roleMembership, address initialMember) internal {\n', '        resetMember(roleMembership, initialMember);\n', '    }\n', '}\n', '\n', '\n', 'library Shared {\n', '    struct RoleMembership {\n', '        mapping(address => bool) members;\n', '    }\n', '\n', '    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n', '        return roleMembership.members[memberToCheck];\n', '    }\n', '\n', '    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\n', '        require(memberToAdd != address(0x0), "Cannot add 0x0 to a shared role");\n', '        roleMembership.members[memberToAdd] = true;\n', '    }\n', '\n', '    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\n', '        roleMembership.members[memberToRemove] = false;\n', '    }\n', '\n', '    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\n', '        for (uint256 i = 0; i < initialMembers.length; i++) {\n', '            addMember(roleMembership, initialMembers[i]);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Base class to manage permissions for the derived class.\n', ' */\n', 'abstract contract MultiRole {\n', '    using Exclusive for Exclusive.RoleMembership;\n', '    using Shared for Shared.RoleMembership;\n', '\n', '    enum RoleType { Invalid, Exclusive, Shared }\n', '\n', '    struct Role {\n', '        uint256 managingRole;\n', '        RoleType roleType;\n', '        Exclusive.RoleMembership exclusiveRoleMembership;\n', '        Shared.RoleMembership sharedRoleMembership;\n', '    }\n', '\n', '    mapping(uint256 => Role) private roles;\n', '\n', '    event ResetExclusiveMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n', '    event AddedSharedMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n', '    event RemovedSharedMember(uint256 indexed roleId, address indexed oldMember, address indexed manager);\n', '\n', '    /**\n', '     * @notice Reverts unless the caller is a member of the specified roleId.\n', '     */\n', '    modifier onlyRoleHolder(uint256 roleId) {\n', '        require(holdsRole(roleId, msg.sender), "Sender does not hold required role");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\n', '     */\n', '    modifier onlyRoleManager(uint256 roleId) {\n', '        require(holdsRole(roles[roleId].managingRole, msg.sender), "Can only be called by a role manager");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\n', '     */\n', '    modifier onlyExclusive(uint256 roleId) {\n', '        require(roles[roleId].roleType == RoleType.Exclusive, "Must be called on an initialized Exclusive role");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts unless the roleId represents an initialized, shared roleId.\n', '     */\n', '    modifier onlyShared(uint256 roleId) {\n', '        require(roles[roleId].roleType == RoleType.Shared, "Must be called on an initialized Shared role");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `memberToCheck` is a member of roleId.\n', '     * @dev Reverts if roleId does not correspond to an initialized role.\n', '     * @param roleId the Role to check.\n', '     * @param memberToCheck the address to check.\n', '     * @return True if `memberToCheck` is a member of `roleId`.\n', '     */\n', '    function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\n', '        Role storage role = roles[roleId];\n', '        if (role.roleType == RoleType.Exclusive) {\n', '            return role.exclusiveRoleMembership.isMember(memberToCheck);\n', '        } else if (role.roleType == RoleType.Shared) {\n', '            return role.sharedRoleMembership.isMember(memberToCheck);\n', '        }\n', '        revert("Invalid roleId");\n', '    }\n', '\n', '    /**\n', '     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\n', '     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\n', '     * initialized, ExclusiveRole.\n', '     * @param roleId the ExclusiveRole membership to modify.\n', '     * @param newMember the new ExclusiveRole member.\n', '     */\n', '    function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\n', '        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\n', '        emit ResetExclusiveMember(roleId, newMember, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the current holder of the exclusive role, `roleId`.\n', '     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\n', '     * @param roleId the ExclusiveRole membership to check.\n', '     * @return the address of the current ExclusiveRole member.\n', '     */\n', '    function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {\n', '        return roles[roleId].exclusiveRoleMembership.getMember();\n', '    }\n', '\n', '    /**\n', '     * @notice Adds `newMember` to the shared role, `roleId`.\n', '     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n', '     * managing role for `roleId`.\n', '     * @param roleId the SharedRole membership to modify.\n', '     * @param newMember the new SharedRole member.\n', '     */\n', '    function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\n', '        roles[roleId].sharedRoleMembership.addMember(newMember);\n', '        emit AddedSharedMember(roleId, newMember, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Removes `memberToRemove` from the shared role, `roleId`.\n', '     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n', '     * managing role for `roleId`.\n', '     * @param roleId the SharedRole membership to modify.\n', '     * @param memberToRemove the current SharedRole member to remove.\n', '     */\n', '    function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\n', '        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\n', '        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Removes caller from the role, `roleId`.\n', '     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an\n', '     * initialized, SharedRole.\n', '     * @param roleId the SharedRole membership to modify.\n', '     */\n', '    function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {\n', '        roles[roleId].sharedRoleMembership.removeMember(msg.sender);\n', '        emit RemovedSharedMember(roleId, msg.sender, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts if `roleId` is not initialized.\n', '     */\n', '    modifier onlyValidRole(uint256 roleId) {\n', '        require(roles[roleId].roleType != RoleType.Invalid, "Attempted to use an invalid roleId");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts if `roleId` is initialized.\n', '     */\n', '    modifier onlyInvalidRole(uint256 roleId) {\n', '        require(roles[roleId].roleType == RoleType.Invalid, "Cannot use a pre-existing role");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\n', '     * `initialMembers` will be immediately added to the role.\n', '     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n', '     * initialized.\n', '     */\n', '    function _createSharedRole(\n', '        uint256 roleId,\n', '        uint256 managingRoleId,\n', '        address[] memory initialMembers\n', '    ) internal onlyInvalidRole(roleId) {\n', '        Role storage role = roles[roleId];\n', '        role.roleType = RoleType.Shared;\n', '        role.managingRole = managingRoleId;\n', '        role.sharedRoleMembership.init(initialMembers);\n', '        require(\n', '            roles[managingRoleId].roleType != RoleType.Invalid,\n', '            "Attempted to use an invalid role to manage a shared role"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Internal method to initialize an exclusive role, `roleId`, which will be managed by `managingRoleId`.\n', '     * `initialMember` will be immediately added to the role.\n', '     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n', '     * initialized.\n', '     */\n', '    function _createExclusiveRole(\n', '        uint256 roleId,\n', '        uint256 managingRoleId,\n', '        address initialMember\n', '    ) internal onlyInvalidRole(roleId) {\n', '        Role storage role = roles[roleId];\n', '        role.roleType = RoleType.Exclusive;\n', '        role.managingRole = managingRoleId;\n', '        role.exclusiveRoleMembership.init(initialMember);\n', '        require(\n', '            roles[managingRoleId].roleType != RoleType.Invalid,\n', '            "Attempted to use an invalid role to manage an exclusive role"\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/oracle/interfaces/RegistryInterface.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '/**\n', ' * @title Interface for a registry of contracts and contract creators.\n', ' */\n', 'interface RegistryInterface {\n', '    /**\n', '     * @notice Registers a new contract.\n', '     * @dev Only authorized contract creators can call this method.\n', '     * @param parties an array of addresses who become parties in the contract.\n', '     * @param contractAddress defines the address of the deployed contract.\n', '     */\n', '    function registerContract(address[] calldata parties, address contractAddress) external;\n', '\n', '    /**\n', '     * @notice Returns whether the contract has been registered with the registry.\n', '     * @dev If it is registered, it is an authorized participant in the UMA system.\n', '     * @param contractAddress address of the contract.\n', '     * @return bool indicates whether the contract is registered.\n', '     */\n', '    function isContractRegistered(address contractAddress) external view returns (bool);\n', '\n', '    /**\n', '     * @notice Returns a list of all contracts that are associated with a particular party.\n', '     * @param party address of the party.\n', '     * @return an array of the contracts the party is registered to.\n', '     */\n', '    function getRegisteredContracts(address party) external view returns (address[] memory);\n', '\n', '    /**\n', '     * @notice Returns all registered contracts.\n', '     * @return all registered contract addresses within the system.\n', '     */\n', '    function getAllRegisteredContracts() external view returns (address[] memory);\n', '\n', '    /**\n', '     * @notice Adds a party to the calling contract.\n', '     * @dev msg.sender must be the contract to which the party member is added.\n', '     * @param party address to be added to the contract.\n', '     */\n', '    function addPartyToContract(address party) external;\n', '\n', '    /**\n', '     * @notice Removes a party member to the calling contract.\n', '     * @dev msg.sender must be the contract to which the party member is added.\n', '     * @param party address to be removed from the contract.\n', '     */\n', '    function removePartyFromContract(address party) external;\n', '\n', '    /**\n', '     * @notice checks if an address is a party in a contract.\n', '     * @param party party to check.\n', '     * @param contractAddress address to check against the party.\n', '     * @return bool indicating if the address is a party of the contract.\n', '     */\n', '    function isPartyMemberOfContract(address party, address contractAddress) external view returns (bool);\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/oracle/implementation/Registry.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Registry for financial contracts and approved financial contract creators.\n', ' * @dev Maintains a whitelist of financial contract creators that are allowed\n', ' * to register new financial contracts and stores party members of a financial contract.\n', ' */\n', 'contract Registry is RegistryInterface, MultiRole {\n', '    using SafeMath for uint256;\n', '\n', '    /****************************************\n', '     *    INTERNAL VARIABLES AND STORAGE    *\n', '     ****************************************/\n', '\n', '    enum Roles {\n', '        Owner, // The owner manages the set of ContractCreators.\n', '        ContractCreator // Can register financial contracts.\n', '    }\n', '\n', '    // This enum is required because a `WasValid` state is required\n', '    // to ensure that financial contracts cannot be re-registered.\n', '    enum Validity { Invalid, Valid }\n', '\n', '    // Local information about a contract.\n', '    struct FinancialContract {\n', '        Validity valid;\n', '        uint128 index;\n', '    }\n', '\n', '    struct Party {\n', '        address[] contracts; // Each financial contract address is stored in this array.\n', '        // The address of each financial contract is mapped to its index for constant time look up and deletion.\n', '        mapping(address => uint256) contractIndex;\n', '    }\n', '\n', '    // Array of all contracts that are approved to use the UMA Oracle.\n', '    address[] public registeredContracts;\n', '\n', '    // Map of financial contract contracts to the associated FinancialContract struct.\n', '    mapping(address => FinancialContract) public contractMap;\n', '\n', '    // Map each party member to their their associated Party struct.\n', '    mapping(address => Party) private partyMap;\n', '\n', '    /****************************************\n', '     *                EVENTS                *\n', '     ****************************************/\n', '\n', '    event NewContractRegistered(address indexed contractAddress, address indexed creator, address[] parties);\n', '    event PartyAdded(address indexed contractAddress, address indexed party);\n', '    event PartyRemoved(address indexed contractAddress, address indexed party);\n', '\n', '    /**\n', '     * @notice Construct the Registry contract.\n', '     */\n', '    constructor() public {\n', '        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\n', '        // Start with no contract creators registered.\n', '        _createSharedRole(uint256(Roles.ContractCreator), uint256(Roles.Owner), new address[](0));\n', '    }\n', '\n', '    /****************************************\n', '     *        REGISTRATION FUNCTIONS        *\n', '     ****************************************/\n', '\n', '    /**\n', '     * @notice Registers a new financial contract.\n', '     * @dev Only authorized contract creators can call this method.\n', '     * @param parties array of addresses who become parties in the contract.\n', '     * @param contractAddress address of the contract against which the parties are registered.\n', '     */\n', '    function registerContract(address[] calldata parties, address contractAddress)\n', '        external\n', '        override\n', '        onlyRoleHolder(uint256(Roles.ContractCreator))\n', '    {\n', '        FinancialContract storage financialContract = contractMap[contractAddress];\n', '        require(contractMap[contractAddress].valid == Validity.Invalid, "Can only register once");\n', '\n', '        // Store contract address as a registered contract.\n', '        registeredContracts.push(contractAddress);\n', '\n', '        // No length check necessary because we should never hit (2^127 - 1) contracts.\n', '        financialContract.index = uint128(registeredContracts.length.sub(1));\n', '\n', "        // For all parties in the array add them to the contract's parties.\n", '        financialContract.valid = Validity.Valid;\n', '        for (uint256 i = 0; i < parties.length; i = i.add(1)) {\n', '            _addPartyToContract(parties[i], contractAddress);\n', '        }\n', '\n', '        emit NewContractRegistered(contractAddress, msg.sender, parties);\n', '    }\n', '\n', '    /**\n', '     * @notice Adds a party member to the calling contract.\n', '     * @dev msg.sender will be used to determine the contract that this party is added to.\n', '     * @param party new party for the calling contract.\n', '     */\n', '    function addPartyToContract(address party) external override {\n', '        address contractAddress = msg.sender;\n', '        require(contractMap[contractAddress].valid == Validity.Valid, "Can only add to valid contract");\n', '\n', '        _addPartyToContract(party, contractAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice Removes a party member from the calling contract.\n', '     * @dev msg.sender will be used to determine the contract that this party is removed from.\n', '     * @param partyAddress address to be removed from the calling contract.\n', '     */\n', '    function removePartyFromContract(address partyAddress) external override {\n', '        address contractAddress = msg.sender;\n', '        Party storage party = partyMap[partyAddress];\n', '        uint256 numberOfContracts = party.contracts.length;\n', '\n', '        require(numberOfContracts != 0, "Party has no contracts");\n', '        require(contractMap[contractAddress].valid == Validity.Valid, "Remove only from valid contract");\n', '        require(isPartyMemberOfContract(partyAddress, contractAddress), "Can only remove existing party");\n', '\n', '        // Index of the current location of the contract to remove.\n', '        uint256 deleteIndex = party.contractIndex[contractAddress];\n', '\n', "        // Store the last contract's address to update the lookup map.\n", '        address lastContractAddress = party.contracts[numberOfContracts - 1];\n', '\n', '        // Swap the contract to be removed with the last contract.\n', '        party.contracts[deleteIndex] = lastContractAddress;\n', '\n', '        // Update the lookup index with the new location.\n', '        party.contractIndex[lastContractAddress] = deleteIndex;\n', '\n', '        // Pop the last contract from the array and update the lookup map.\n', '        party.contracts.pop();\n', '        delete party.contractIndex[contractAddress];\n', '\n', '        emit PartyRemoved(contractAddress, partyAddress);\n', '    }\n', '\n', '    /****************************************\n', '     *         REGISTRY STATE GETTERS       *\n', '     ****************************************/\n', '\n', '    /**\n', '     * @notice Returns whether the contract has been registered with the registry.\n', '     * @dev If it is registered, it is an authorized participant in the UMA system.\n', '     * @param contractAddress address of the financial contract.\n', '     * @return bool indicates whether the contract is registered.\n', '     */\n', '    function isContractRegistered(address contractAddress) external override view returns (bool) {\n', '        return contractMap[contractAddress].valid == Validity.Valid;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns a list of all contracts that are associated with a particular party.\n', '     * @param party address of the party.\n', '     * @return an array of the contracts the party is registered to.\n', '     */\n', '    function getRegisteredContracts(address party) external override view returns (address[] memory) {\n', '        return partyMap[party].contracts;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns all registered contracts.\n', '     * @return all registered contract addresses within the system.\n', '     */\n', '    function getAllRegisteredContracts() external override view returns (address[] memory) {\n', '        return registeredContracts;\n', '    }\n', '\n', '    /**\n', '     * @notice checks if an address is a party of a contract.\n', '     * @param party party to check.\n', '     * @param contractAddress address to check against the party.\n', '     * @return bool indicating if the address is a party of the contract.\n', '     */\n', '    function isPartyMemberOfContract(address party, address contractAddress) public override view returns (bool) {\n', '        uint256 index = partyMap[party].contractIndex[contractAddress];\n', '        return partyMap[party].contracts.length > index && partyMap[party].contracts[index] == contractAddress;\n', '    }\n', '\n', '    /****************************************\n', '     *           INTERNAL FUNCTIONS         *\n', '     ****************************************/\n', '\n', '    function _addPartyToContract(address party, address contractAddress) internal {\n', '        require(!isPartyMemberOfContract(party, contractAddress), "Can only register a party once");\n', '        uint256 contractIndex = partyMap[party].contracts.length;\n', '        partyMap[party].contracts.push(contractAddress);\n', '        partyMap[party].contractIndex[contractAddress] = contractIndex;\n', '\n', '        emit PartyAdded(contractAddress, party);\n', '    }\n', '}\n', '\n', '// File: contracts/oracle/implementation/Constants.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title Stores common interface names used throughout the DVM by registration in the Finder.\n', ' */\n', 'library OracleInterfaces {\n', '    bytes32 public constant Oracle = "Oracle";\n', '    bytes32 public constant IdentifierWhitelist = "IdentifierWhitelist";\n', '    bytes32 public constant Store = "Store";\n', '    bytes32 public constant FinancialContractsAdmin = "FinancialContractsAdmin";\n', '    bytes32 public constant Registry = "Registry";\n', '    bytes32 public constant CollateralWhitelist = "CollateralWhitelist";\n', '}\n', '\n', '// File: contracts/oracle/implementation/ContractCreator.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Base contract for all financial contract creators\n', ' */\n', 'abstract contract ContractCreator {\n', '    address internal finderAddress;\n', '\n', '    constructor(address _finderAddress) public {\n', '        finderAddress = _finderAddress;\n', '    }\n', '\n', '    function _requireWhitelistedCollateral(address collateralAddress) internal view {\n', '        FinderInterface finder = FinderInterface(finderAddress);\n', '        AddressWhitelist collateralWhitelist = AddressWhitelist(\n', '            finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist)\n', '        );\n', '        require(collateralWhitelist.isOnWhitelist(collateralAddress), "Collateral not whitelisted");\n', '    }\n', '\n', '    function _registerContract(address[] memory parties, address contractToRegister) internal {\n', '        FinderInterface finder = FinderInterface(finderAddress);\n', '        Registry registry = Registry(finder.getImplementationAddress(OracleInterfaces.Registry));\n', '        registry.registerContract(parties, contractToRegister);\n', '    }\n', '}\n', '\n', '// File: contracts/common/implementation/Timer.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title Universal store of current contract time for testing environments.\n', ' */\n', 'contract Timer {\n', '    uint256 private currentTime;\n', '\n', '    constructor() public {\n', '        currentTime = now; // solhint-disable-line not-rely-on-time\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the current time.\n', '     * @dev Will revert if not running in test mode.\n', '     * @param time timestamp to set `currentTime` to.\n', '     */\n', '    function setCurrentTime(uint256 time) external {\n', '        currentTime = time;\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n', '     * Otherwise, it will return the block timestamp.\n', '     * @return uint256 for the current Testable timestamp.\n', '     */\n', '    function getCurrentTime() public view returns (uint256) {\n', '        return currentTime;\n', '    }\n', '}\n', '\n', '// File: contracts/common/implementation/Testable.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title Base class that provides time overrides, but only if being run in test mode.\n', ' */\n', 'abstract contract Testable {\n', '    // If the contract is being run on the test network, then `timerAddress` will be the 0x0 address.\n', '    // Note: this variable should be set on construction and never modified.\n', '    address public timerAddress;\n', '\n', '    /**\n', '     * @notice Constructs the Testable contract. Called by child contracts.\n', '     * @param _timerAddress Contract that stores the current time in a testing environment.\n', '     * Must be set to 0x0 for production environments that use live time.\n', '     */\n', '    constructor(address _timerAddress) internal {\n', '        timerAddress = _timerAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts if not running in test mode.\n', '     */\n', '    modifier onlyIfTest {\n', '        require(timerAddress != address(0x0));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the current time.\n', '     * @dev Will revert if not running in test mode.\n', '     * @param time timestamp to set current Testable time to.\n', '     */\n', '    function setCurrentTime(uint256 time) external onlyIfTest {\n', '        Timer(timerAddress).setCurrentTime(time);\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n', '     * Otherwise, it will return the block timestamp.\n', '     * @return uint for the current Testable timestamp.\n', '     */\n', '    function getCurrentTime() public view returns (uint256) {\n', '        if (timerAddress != address(0x0)) {\n', '            return Timer(timerAddress).getCurrentTime();\n', '        } else {\n', '            return now; // solhint-disable-line not-rely-on-time\n', '        }\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.6.2;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/common/implementation/FixedPoint.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title Library for fixed point arithmetic on uints\n', ' */\n', 'library FixedPoint {\n', '    using SafeMath for uint256;\n', '\n', '    // Supports 18 decimals. E.g., 1e18 represents "1", 5e17 represents "0.5".\n', '    // Can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n', '    uint256 private constant FP_SCALING_FACTOR = 10**18;\n', '\n', '    struct Unsigned {\n', '        uint256 rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5**18`.\n', '     * @param a uint to convert into a FixedPoint.\n', '     * @return the converted FixedPoint.\n', '     */\n', '    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n', '        return Unsigned(a.mul(FP_SCALING_FACTOR));\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is equal to `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return True if equal, or False.\n', '     */\n', '    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n', '        return a.rawValue == fromUnscaledUint(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is equal to `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return True if equal, or False.\n', '     */\n', '    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n', '        return a.rawValue == b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a > b`, or False.\n', '     */\n', '    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n', '        return a.rawValue > b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return True if `a > b`, or False.\n', '     */\n', '    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n', '        return a.rawValue > fromUnscaledUint(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than `b`.\n', '     * @param a a uint256.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a > b`, or False.\n', '     */\n', '    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n', '        return fromUnscaledUint(a).rawValue > b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than or equal to `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a >= b`, or False.\n', '     */\n', '    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n', '        return a.rawValue >= b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than or equal to `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return True if `a >= b`, or False.\n', '     */\n', '    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n', '        return a.rawValue >= fromUnscaledUint(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than or equal to `b`.\n', '     * @param a a uint256.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a >= b`, or False.\n', '     */\n', '    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n', '        return fromUnscaledUint(a).rawValue >= b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a < b`, or False.\n', '     */\n', '    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n', '        return a.rawValue < b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return True if `a < b`, or False.\n', '     */\n', '    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n', '        return a.rawValue < fromUnscaledUint(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than `b`.\n', '     * @param a a uint256.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a < b`, or False.\n', '     */\n', '    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n', '        return fromUnscaledUint(a).rawValue < b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than or equal to `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a <= b`, or False.\n', '     */\n', '    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n', '        return a.rawValue <= b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than or equal to `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return True if `a <= b`, or False.\n', '     */\n', '    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n', '        return a.rawValue <= fromUnscaledUint(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than or equal to `b`.\n', '     * @param a a uint256.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a <= b`, or False.\n', '     */\n', '    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n', '        return fromUnscaledUint(a).rawValue <= b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice The minimum of `a` and `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the minimum of `a` and `b`.\n', '     */\n', '    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        return a.rawValue < b.rawValue ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @notice The maximum of `a` and `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the maximum of `a` and `b`.\n', '     */\n', '    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        return a.rawValue > b.rawValue ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @notice Adds two `Unsigned`s, reverting on overflow.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the sum of `a` and `b`.\n', '     */\n', '    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        return Unsigned(a.rawValue.add(b.rawValue));\n', '    }\n', '\n', '    /**\n', '     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return the sum of `a` and `b`.\n', '     */\n', '    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n', '        return add(a, fromUnscaledUint(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Subtracts two `Unsigned`s, reverting on overflow.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the difference of `a` and `b`.\n', '     */\n', '    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        return Unsigned(a.rawValue.sub(b.rawValue));\n', '    }\n', '\n', '    /**\n', '     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return the difference of `a` and `b`.\n', '     */\n', '    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n', '        return sub(a, fromUnscaledUint(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n', '     * @param a a uint256.\n', '     * @param b a FixedPoint.\n', '     * @return the difference of `a` and `b`.\n', '     */\n', '    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        return sub(fromUnscaledUint(a), b);\n', '    }\n', '\n', '    /**\n', '     * @notice Multiplies two `Unsigned`s, reverting on overflow.\n', '     * @dev This will "floor" the product.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the product of `a` and `b`.\n', '     */\n', '    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        // There are two caveats with this computation:\n', '        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n', '        // stored internally as a uint256 ~10^59.\n', "        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n", '        // would round to 3, but this computation produces the result 2.\n', '        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n', '        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n', '    }\n', '\n', '    /**\n', '     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n', '     * @dev This will "floor" the product.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return the product of `a` and `b`.\n', '     */\n', '    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n', '        return Unsigned(a.rawValue.mul(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Multiplies two `Unsigned`s and "ceil\'s" the product, reverting on overflow.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the product of `a` and `b`.\n', '     */\n', '    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        uint256 mulRaw = a.rawValue.mul(b.rawValue);\n', '        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n', '        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n', '        if (mod != 0) {\n', '            return Unsigned(mulFloor.add(1));\n', '        } else {\n', '            return Unsigned(mulFloor);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Multiplies an `Unsigned` and an unscaled uint256 and "ceil\'s" the product, reverting on overflow.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the product of `a` and `b`.\n', '     */\n', '    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n', '        // Since b is an int, there is no risk of truncation and we can just mul it normally\n', '        return Unsigned(a.rawValue.mul(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n', '     * @dev This will "floor" the quotient.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b a FixedPoint denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        // There are two caveats with this computation:\n', '        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n', '        // 10^41 is stored internally as a uint256 10^59.\n', "        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n", '        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n', '        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n', '     * @dev This will "floor" the quotient.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b a uint256 denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n', '        return Unsigned(a.rawValue.div(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n', '     * @dev This will "floor" the quotient.\n', '     * @param a a uint256 numerator.\n', '     * @param b a FixedPoint denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        return div(fromUnscaledUint(a), b);\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one `Unsigned` by an `Unsigned` and "ceil\'s" the quotient, reverting on overflow or division by 0.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b a FixedPoint denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n', '        uint256 divFloor = aScaled.div(b.rawValue);\n', '        uint256 mod = aScaled.mod(b.rawValue);\n', '        if (mod != 0) {\n', '            return Unsigned(divFloor.add(1));\n', '        } else {\n', '            return Unsigned(divFloor);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one `Unsigned` by an unscaled uint256 and "ceil\'s" the quotient, reverting on overflow or division by 0.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b a uint256 denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n', '        // Because it is possible that a quotient gets truncated, we can\'t just call "Unsigned(a.rawValue.div(b))"\n', '        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n', '        // This creates the possibility of overflow if b is very large.\n', '        return divCeil(a, fromUnscaledUint(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n', '     * @dev This will "floor" the result.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b a uint256 denominator.\n', '     * @return output is `a` to the power of `b`.\n', '     */\n', '    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n', '        output = fromUnscaledUint(1);\n', '        for (uint256 i = 0; i < b; i = i.add(1)) {\n', '            output = mul(output, a);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/common/interfaces/ExpandedIERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface that includes burn and mint methods.\n', ' */\n', 'abstract contract ExpandedIERC20 is IERC20 {\n', '    /**\n', "     * @notice Burns a specific amount of the caller's tokens.\n", "     * @dev Only burns the caller's tokens, so it is safe to leave this method permissionless.\n", '     */\n', '    function burn(uint256 value) external virtual;\n', '\n', '    /**\n', '     * @notice Mints tokens and adds them to the balance of the `to` address.\n', '     * @dev This method should be permissioned to only allow designated parties to mint tokens.\n', '     */\n', '    function mint(address to, uint256 value) external virtual returns (bool);\n', '}\n', '\n', '// File: contracts/oracle/interfaces/OracleInterface.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title Financial contract facing Oracle interface.\n', ' * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n', ' */\n', 'interface OracleInterface {\n', '    /**\n', "     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\n", '     * @dev Time must be in the past and the identifier must be supported.\n', '     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n', '     * @param time unix timestamp for the price request.\n', '     */\n', '    function requestPrice(bytes32 identifier, uint256 time) external;\n', '\n', '    /**\n', '     * @notice Whether the price for `identifier` and `time` is available.\n', '     * @dev Time must be in the past and the identifier must be supported.\n', '     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n', '     * @param time unix timestamp for the price request.\n', '     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\n', '     */\n', '    function hasPrice(bytes32 identifier, uint256 time) external view returns (bool);\n', '\n', '    /**\n', '     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\n', '     * @dev If the price is not available, the method reverts.\n', '     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n', '     * @param time unix timestamp for the price request.\n', '     * @return int256 representing the resolved price for the given identifier and timestamp.\n', '     */\n', '    function getPrice(bytes32 identifier, uint256 time) external view returns (int256);\n', '}\n', '\n', '// File: contracts/oracle/interfaces/IdentifierWhitelistInterface.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title Interface for whitelists of supported identifiers that the oracle can provide prices for.\n', ' */\n', 'interface IdentifierWhitelistInterface {\n', '    /**\n', '     * @notice Adds the provided identifier as a supported identifier.\n', '     * @dev Price requests using this identifier will succeed after this call.\n', '     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n', '     */\n', '    function addSupportedIdentifier(bytes32 identifier) external;\n', '\n', '    /**\n', '     * @notice Removes the identifier from the whitelist.\n', '     * @dev Price requests using this identifier will no longer succeed after this call.\n', '     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n', '     */\n', '    function removeSupportedIdentifier(bytes32 identifier) external;\n', '\n', '    /**\n', '     * @notice Checks whether an identifier is on the whitelist.\n', '     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n', '     * @return bool if the identifier is supported (or not).\n', '     */\n', '    function isIdentifierSupported(bytes32 identifier) external view returns (bool);\n', '}\n', '\n', '// File: contracts/oracle/interfaces/AdministrateeInterface.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title Interface that all financial contracts expose to the admin.\n', ' */\n', 'interface AdministrateeInterface {\n', '    /**\n', '     * @notice Initiates the shutdown process, in case of an emergency.\n', '     */\n', '    function emergencyShutdown() external;\n', '\n', '    /**\n', '     * @notice A core contract method called independently or as a part of other financial contract transactions.\n', '     * @dev It pays fees and moves money between margin accounts to make sure they reflect the NAV of the contract.\n', '     */\n', '    function remargin() external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20MinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n', '     * a default value of 18.\n', '     *\n', '     * To select a different value for {decimals}, use {_setupDecimals}.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    constructor (string memory name, string memory symbol) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = 18;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n', '     * called.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets {decimals} to a value other than the default one of 18.\n', '     *\n', '     * WARNING: This function should only be called from the constructor. Most\n', '     * applications that interact with token contracts will not expect\n', '     * {decimals} to ever change, and may work incorrectly if it does.\n', '     */\n', '    function _setupDecimals(uint8 decimals_) internal {\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '}\n', '\n', '// File: contracts/common/implementation/ExpandedERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title An ERC20 with permissioned burning and minting. The contract deployer will initially\n', ' * be the owner who is capable of adding new roles.\n', ' */\n', 'contract ExpandedERC20 is ExpandedIERC20, ERC20, MultiRole {\n', '    enum Roles {\n', '        // Can set the minter and burner.\n', '        Owner,\n', '        // Addresses that can mint new tokens.\n', '        Minter,\n', '        // Addresses that can burn tokens that address owns.\n', '        Burner\n', '    }\n', '\n', '    /**\n', '     * @notice Constructs the ExpandedERC20.\n', '     * @param _tokenName The name which describes the new token.\n', '     * @param _tokenSymbol The ticker abbreviation of the name. Ideally < 5 chars.\n', '     * @param _tokenDecimals The number of decimals to define token precision.\n', '     */\n', '    constructor(\n', '        string memory _tokenName,\n', '        string memory _tokenSymbol,\n', '        uint8 _tokenDecimals\n', '    ) public ERC20(_tokenName, _tokenSymbol) {\n', '        _setupDecimals(_tokenDecimals);\n', '        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\n', '        _createSharedRole(uint256(Roles.Minter), uint256(Roles.Owner), new address[](0));\n', '        _createSharedRole(uint256(Roles.Burner), uint256(Roles.Owner), new address[](0));\n', '    }\n', '\n', '    /**\n', '     * @dev Mints `value` tokens to `recipient`, returning true on success.\n', '     * @param recipient address to mint to.\n', '     * @param value amount of tokens to mint.\n', '     * @return True if the mint succeeded, or False.\n', '     */\n', '    function mint(address recipient, uint256 value)\n', '        external\n', '        override\n', '        onlyRoleHolder(uint256(Roles.Minter))\n', '        returns (bool)\n', '    {\n', '        _mint(recipient, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Burns `value` tokens owned by `msg.sender`.\n', '     * @param value amount of tokens to burn.\n', '     */\n', '    function burn(uint256 value) external override onlyRoleHolder(uint256(Roles.Burner)) {\n', '        _burn(msg.sender, value);\n', '    }\n', '}\n', '\n', '// File: contracts/financial-templates/common/SyntheticToken.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Burnable and mintable ERC20.\n', ' * @dev The contract deployer will initially be the only minter, burner and owner capable of adding new roles.\n', ' */\n', '\n', 'contract SyntheticToken is ExpandedERC20, Lockable {\n', '    /**\n', '     * @notice Constructs the SyntheticToken.\n', '     * @param tokenName The name which describes the new token.\n', '     * @param tokenSymbol The ticker abbreviation of the name. Ideally < 5 chars.\n', '     * @param tokenDecimals The number of decimals to define token precision.\n', '     */\n', '    constructor(\n', '        string memory tokenName,\n', '        string memory tokenSymbol,\n', '        uint8 tokenDecimals\n', '    ) public ExpandedERC20(tokenName, tokenSymbol, tokenDecimals) nonReentrant() {}\n', '\n', '    /**\n', '     * @notice Add Minter role to account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The address to which the Minter role is added.\n', '     */\n', '    function addMinter(address account) external nonReentrant() {\n', '        addMember(uint256(Roles.Minter), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Remove Minter role from account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The address from which the Minter role is removed.\n', '     */\n', '    function removeMinter(address account) external nonReentrant() {\n', '        removeMember(uint256(Roles.Minter), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Add Burner role to account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The address to which the Burner role is added.\n', '     */\n', '    function addBurner(address account) external nonReentrant() {\n', '        addMember(uint256(Roles.Burner), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Removes Burner role from account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The address from which the Burner role is removed.\n', '     */\n', '    function removeBurner(address account) external nonReentrant() {\n', '        removeMember(uint256(Roles.Burner), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Reset Owner role to account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The new holder of the Owner role.\n', '     */\n', '    function resetOwner(address account) external nonReentrant() {\n', '        resetMember(uint256(Roles.Owner), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if a given account holds the Minter role.\n', '     * @param account The address which is checked for the Minter role.\n', '     * @return bool True if the provided account is a Minter.\n', '     */\n', '    function isMinter(address account) public view nonReentrantView() returns (bool) {\n', '        return holdsRole(uint256(Roles.Minter), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if a given account holds the Burner role.\n', '     * @param account The address which is checked for the Burner role.\n', '     * @return bool True if the provided account is a Burner.\n', '     */\n', '    function isBurner(address account) public view nonReentrantView() returns (bool) {\n', '        return holdsRole(uint256(Roles.Burner), account);\n', '    }\n', '}\n', '\n', '// File: contracts/financial-templates/common/TokenFactory.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Factory for creating new mintable and burnable tokens.\n', ' */\n', '\n', 'contract TokenFactory is Lockable {\n', '    /**\n', '     * @notice Create a new token and return it to the caller.\n', '     * @dev The caller will become the only minter and burner and the new owner capable of assigning the roles.\n', '     * @param tokenName used to describe the new token.\n', '     * @param tokenSymbol short ticker abbreviation of the name. Ideally < 5 chars.\n', "     * @param tokenDecimals used to define the precision used in the token's numerical representation.\n", '     * @return newToken an instance of the newly created token interface.\n', '     */\n', '    function createToken(\n', '        string calldata tokenName,\n', '        string calldata tokenSymbol,\n', '        uint8 tokenDecimals\n', '    ) external nonReentrant() returns (ExpandedIERC20 newToken) {\n', '        SyntheticToken mintableToken = new SyntheticToken(tokenName, tokenSymbol, tokenDecimals);\n', '        mintableToken.addMinter(msg.sender);\n', '        mintableToken.addBurner(msg.sender);\n', '        mintableToken.resetOwner(msg.sender);\n', '        newToken = ExpandedIERC20(address(mintableToken));\n', '    }\n', '}\n', '\n', '// File: contracts/oracle/interfaces/StoreInterface.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Interface that allows financial contracts to pay oracle fees for their use of the system.\n', ' */\n', 'interface StoreInterface {\n', '    /**\n', '     * @notice Pays Oracle fees in ETH to the store.\n', '     * @dev To be used by contracts whose margin currency is ETH.\n', '     */\n', '    function payOracleFees() external payable;\n', '\n', '    /**\n', '     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\n', '     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\n', '     * @param erc20Address address of the ERC20 token used to pay the fee.\n', '     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\n', '     */\n', '    function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external;\n', '\n', '    /**\n', '     * @notice Computes the regular oracle fees that a contract should pay for a period.\n', '     * @param startTime defines the beginning time from which the fee is paid.\n', '     * @param endTime end time until which the fee is paid.\n', '     * @param pfc "profit from corruption", or the maximum amount of margin currency that a\n', '     * token sponsor could extract from the contract through corrupting the price feed in their favor.\n', '     * @return regularFee amount owed for the duration from start to end time for the given pfc.\n', '     * @return latePenalty for paying the fee after the deadline.\n', '     */\n', '    function computeRegularFee(\n', '        uint256 startTime,\n', '        uint256 endTime,\n', '        FixedPoint.Unsigned calldata pfc\n', '    ) external view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty);\n', '\n', '    /**\n', '     * @notice Computes the final oracle fees that a contract should pay at settlement.\n', '     * @param currency token used to pay the final fee.\n', '     * @return finalFee amount due.\n', '     */\n', '    function computeFinalFee(address currency) external view returns (FixedPoint.Unsigned memory);\n', '}\n', '\n', '// File: contracts/financial-templates/common/FeePayer.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title FeePayer contract.\n', ' * @notice Provides fee payment functionality for the ExpiringMultiParty contract.\n', ' * contract is abstract as each derived contract that inherits `FeePayer` must implement `pfc()`.\n', ' */\n', '\n', 'abstract contract FeePayer is Testable, Lockable {\n', '    using SafeMath for uint256;\n', '    using FixedPoint for FixedPoint.Unsigned;\n', '    using SafeERC20 for IERC20;\n', '\n', '    /****************************************\n', '     *      FEE PAYER DATA STRUCTURES       *\n', '     ****************************************/\n', '\n', '    // The collateral currency used to back the positions in this contract.\n', '    IERC20 public collateralCurrency;\n', '\n', '    // Finder contract used to look up addresses for UMA system contracts.\n', '    FinderInterface public finder;\n', '\n', '    // Tracks the last block time when the fees were paid.\n', '    uint256 private lastPaymentTime;\n', '\n', '    // Tracks the cumulative fees that have been paid by the contract for use by derived contracts.\n', '    // The multiplier starts at 1, and is updated by computing cumulativeFeeMultiplier * (1 - effectiveFee).\n', '    // Put another way, the cumulativeFeeMultiplier is (1 - effectiveFee1) * (1 - effectiveFee2) ...\n', '    // For example:\n', '    // The cumulativeFeeMultiplier should start at 1.\n', '    // If a 1% fee is charged, the multiplier should update to .99.\n', '    // If another 1% fee is charged, the multiplier should be 0.99^2 (0.9801).\n', '    FixedPoint.Unsigned public cumulativeFeeMultiplier;\n', '\n', '    /****************************************\n', '     *                EVENTS                *\n', '     ****************************************/\n', '\n', '    event RegularFeesPaid(uint256 indexed regularFee, uint256 indexed lateFee);\n', '    event FinalFeesPaid(uint256 indexed amount);\n', '\n', '    /****************************************\n', '     *              MODIFIERS               *\n', '     ****************************************/\n', '\n', '    // modifier that calls payRegularFees().\n', '    modifier fees {\n', '        payRegularFees();\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Constructs the FeePayer contract. Called by child contracts.\n', '     * @param _collateralAddress ERC20 token that is used as the underlying collateral for the synthetic.\n', '     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\n', '     * @param _timerAddress Contract that stores the current time in a testing environment.\n', '     * Must be set to 0x0 for production environments that use live time.\n', '     */\n', '    constructor(\n', '        address _collateralAddress,\n', '        address _finderAddress,\n', '        address _timerAddress\n', '    ) public Testable(_timerAddress) nonReentrant() {\n', '        collateralCurrency = IERC20(_collateralAddress);\n', '        finder = FinderInterface(_finderAddress);\n', '        lastPaymentTime = getCurrentTime();\n', '        cumulativeFeeMultiplier = FixedPoint.fromUnscaledUint(1);\n', '    }\n', '\n', '    /****************************************\n', '     *        FEE PAYMENT FUNCTIONS         *\n', '     ****************************************/\n', '\n', '    /**\n', '     * @notice Pays UMA DVM regular fees (as a % of the collateral pool) to the Store contract.\n', '     * @dev These must be paid periodically for the life of the contract. If the contract has not paid its regular fee\n', '     * in a week or more then a late penalty is applied which is sent to the caller. If the amount of\n', '     * fees owed are greater than the pfc, then this will pay as much as possible from the available collateral.\n', '     * An event is only fired if the fees charged are greater than 0.\n', '     * @return totalPaid Amount of collateral that the contract paid (sum of the amount paid to the Store and caller).\n', '     * This returns 0 and exit early if there is no pfc, fees were already paid during the current block, or the fee rate is 0.\n', '     */\n', '    function payRegularFees() public nonReentrant() returns (FixedPoint.Unsigned memory totalPaid) {\n', '        StoreInterface store = _getStore();\n', '        uint256 time = getCurrentTime();\n', '        FixedPoint.Unsigned memory collateralPool = _pfc();\n', '\n', '        // Exit early if there is no collateral from which to pay fees.\n', '        if (collateralPool.isEqual(0)) {\n', '            return totalPaid;\n', '        }\n', '\n', '        // Exit early if fees were already paid during this block.\n', '        if (lastPaymentTime == time) {\n', '            return totalPaid;\n', '        }\n', '\n', '        (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty) = store.computeRegularFee(\n', '            lastPaymentTime,\n', '            time,\n', '            collateralPool\n', '        );\n', '        lastPaymentTime = time;\n', '\n', '        totalPaid = regularFee.add(latePenalty);\n', '        if (totalPaid.isEqual(0)) {\n', '            return totalPaid;\n', '        }\n', '        // If the effective fees paid as a % of the pfc is > 100%, then we need to reduce it and make the contract pay\n', "        // as much of the fee that it can (up to 100% of its pfc). We'll reduce the late penalty first and then the\n", '        // regular fee, which has the effect of paying the store first, followed by the caller if there is any fee remaining.\n', '        if (totalPaid.isGreaterThan(collateralPool)) {\n', '            FixedPoint.Unsigned memory deficit = totalPaid.sub(collateralPool);\n', '            FixedPoint.Unsigned memory latePenaltyReduction = FixedPoint.min(latePenalty, deficit);\n', '            latePenalty = latePenalty.sub(latePenaltyReduction);\n', '            deficit = deficit.sub(latePenaltyReduction);\n', '            regularFee = regularFee.sub(FixedPoint.min(regularFee, deficit));\n', '            totalPaid = collateralPool;\n', '        }\n', '\n', '        emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\n', '\n', '        _adjustCumulativeFeeMultiplier(totalPaid, collateralPool);\n', '\n', '        if (regularFee.isGreaterThan(0)) {\n', '            collateralCurrency.safeIncreaseAllowance(address(store), regularFee.rawValue);\n', '            store.payOracleFeesErc20(address(collateralCurrency), regularFee);\n', '        }\n', '\n', '        if (latePenalty.isGreaterThan(0)) {\n', '            collateralCurrency.safeTransfer(msg.sender, latePenalty.rawValue);\n', '        }\n', '        return totalPaid;\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the current profit from corruption for this contract in terms of the collateral currency.\n', '     * @dev This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are\n', '     * expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.\n', '     * @return pfc value for equal to the current profit from corruption denominated in collateral currency.\n', '     */\n', '    function pfc() public view nonReentrantView() returns (FixedPoint.Unsigned memory) {\n', '        return _pfc();\n', '    }\n', '\n', '    /****************************************\n', '     *         INTERNAL FUNCTIONS           *\n', '     ****************************************/\n', '\n', '    // Pays UMA Oracle final fees of `amount` in `collateralCurrency` to the Store contract. Final fee is a flat fee\n', '    // charged for each price request. If payer is the contract, adjusts internal bookkeeping variables. If payer is not\n', '    // the contract, pulls in `amount` of collateral currency.\n', '    function _payFinalFees(address payer, FixedPoint.Unsigned memory amount) internal {\n', '        if (amount.isEqual(0)) {\n', '            return;\n', '        }\n', '\n', '        if (payer != address(this)) {\n', '            // If the payer is not the contract pull the collateral from the payer.\n', '            collateralCurrency.safeTransferFrom(payer, address(this), amount.rawValue);\n', '        } else {\n', '            // If the payer is the contract, adjust the cumulativeFeeMultiplier to compensate.\n', '            FixedPoint.Unsigned memory collateralPool = _pfc();\n', '\n', '            // The final fee must be < available collateral or the fee will be larger than 100%.\n', '            require(collateralPool.isGreaterThan(amount), "Final fee is more than PfC");\n', '\n', '            _adjustCumulativeFeeMultiplier(amount, collateralPool);\n', '        }\n', '\n', '        emit FinalFeesPaid(amount.rawValue);\n', '\n', '        StoreInterface store = _getStore();\n', '        collateralCurrency.safeIncreaseAllowance(address(store), amount.rawValue);\n', '        store.payOracleFeesErc20(address(collateralCurrency), amount);\n', '    }\n', '\n', '    function _pfc() internal virtual view returns (FixedPoint.Unsigned memory);\n', '\n', '    function _getStore() internal view returns (StoreInterface) {\n', '        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\n', '    }\n', '\n', '    function _computeFinalFees() internal view returns (FixedPoint.Unsigned memory finalFees) {\n', '        StoreInterface store = _getStore();\n', '        return store.computeFinalFee(address(collateralCurrency));\n', '    }\n', '\n', "    // Returns the user's collateral minus any fees that have been subtracted since it was originally\n", '    // deposited into the contract. Note: if the contract has paid fees since it was deployed, the raw\n', '    // value should be larger than the returned value.\n', '    function _getFeeAdjustedCollateral(FixedPoint.Unsigned memory rawCollateral)\n', '        internal\n', '        view\n', '        returns (FixedPoint.Unsigned memory collateral)\n', '    {\n', '        return rawCollateral.mul(cumulativeFeeMultiplier);\n', '    }\n', '\n', '    // Converts a user-readable collateral value into a raw value that accounts for already-assessed fees. If any fees\n', '    // have been taken from this contract in the past, then the raw value will be larger than the user-readable value.\n', '    function _convertToRawCollateral(FixedPoint.Unsigned memory collateral)\n', '        internal\n', '        view\n', '        returns (FixedPoint.Unsigned memory rawCollateral)\n', '    {\n', '        return collateral.div(cumulativeFeeMultiplier);\n', '    }\n', '\n', '    // Decrease rawCollateral by a fee-adjusted collateralToRemove amount. Fee adjustment scales up collateralToRemove\n', '    // by dividing it by cumulativeFeeMultiplier. There is potential for this quotient to be floored, therefore\n', '    // rawCollateral is decreased by less than expected. Because this method is usually called in conjunction with an\n', '    // actual removal of collateral from this contract, return the fee-adjusted amount that the rawCollateral is\n', '    // decreased by so that the caller can minimize error between collateral removed and rawCollateral debited.\n', '    function _removeCollateral(FixedPoint.Unsigned storage rawCollateral, FixedPoint.Unsigned memory collateralToRemove)\n', '        internal\n', '        returns (FixedPoint.Unsigned memory removedCollateral)\n', '    {\n', '        FixedPoint.Unsigned memory initialBalance = _getFeeAdjustedCollateral(rawCollateral);\n', '        FixedPoint.Unsigned memory adjustedCollateral = _convertToRawCollateral(collateralToRemove);\n', '        rawCollateral.rawValue = rawCollateral.sub(adjustedCollateral).rawValue;\n', '        removedCollateral = initialBalance.sub(_getFeeAdjustedCollateral(rawCollateral));\n', '    }\n', '\n', '    // Increase rawCollateral by a fee-adjusted collateralToAdd amount. Fee adjustment scales up collateralToAdd\n', '    // by dividing it by cumulativeFeeMultiplier. There is potential for this quotient to be floored, therefore\n', '    // rawCollateral is increased by less than expected. Because this method is usually called in conjunction with an\n', '    // actual addition of collateral to this contract, return the fee-adjusted amount that the rawCollateral is\n', '    // increased by so that the caller can minimize error between collateral added and rawCollateral credited.\n', "    // NOTE: This return value exists only for the sake of symmetry with _removeCollateral. We don't actually use it\n", '    // because we are OK if more collateral is stored in the contract than is represented by rawTotalPositionCollateral.\n', '    function _addCollateral(FixedPoint.Unsigned storage rawCollateral, FixedPoint.Unsigned memory collateralToAdd)\n', '        internal\n', '        returns (FixedPoint.Unsigned memory addedCollateral)\n', '    {\n', '        FixedPoint.Unsigned memory initialBalance = _getFeeAdjustedCollateral(rawCollateral);\n', '        FixedPoint.Unsigned memory adjustedCollateral = _convertToRawCollateral(collateralToAdd);\n', '        rawCollateral.rawValue = rawCollateral.add(adjustedCollateral).rawValue;\n', '        addedCollateral = _getFeeAdjustedCollateral(rawCollateral).sub(initialBalance);\n', '    }\n', '\n', '    // Scale the cumulativeFeeMultiplier by the ratio of fees paid to the current available collateral.\n', '    function _adjustCumulativeFeeMultiplier(FixedPoint.Unsigned memory amount, FixedPoint.Unsigned memory currentPfc)\n', '        internal\n', '    {\n', '        FixedPoint.Unsigned memory effectiveFee = amount.divCeil(currentPfc);\n', '        cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee));\n', '    }\n', '}\n', '\n', '// File: contracts/financial-templates/expiring-multiparty/PricelessPositionManager.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Financial contract with priceless position management.\n', ' * @notice Handles positions for multiple sponsors in an optimistic (i.e., priceless) way without relying\n', ' * on a price feed. On construction, deploys a new ERC20, managed by this contract, that is the synthetic token.\n', ' */\n', '\n', 'contract PricelessPositionManager is FeePayer, AdministrateeInterface {\n', '    using SafeMath for uint256;\n', '    using FixedPoint for FixedPoint.Unsigned;\n', '    using SafeERC20 for IERC20;\n', '    using SafeERC20 for ExpandedIERC20;\n', '\n', '    /****************************************\n', '     *  PRICELESS POSITION DATA STRUCTURES  *\n', '     ****************************************/\n', '\n', '    // Stores the state of the PricelessPositionManager. Set on expiration, emergency shutdown, or settlement.\n', '    enum ContractState { Open, ExpiredPriceRequested, ExpiredPriceReceived }\n', '    ContractState public contractState;\n', '\n', "    // Represents a single sponsor's position. All collateral is held by this contract.\n", '    // This struct acts as bookkeeping for how much of that collateral is allocated to each sponsor.\n', '    struct PositionData {\n', '        FixedPoint.Unsigned tokensOutstanding;\n', '        // Tracks pending withdrawal requests. A withdrawal request is pending if `withdrawalRequestPassTimestamp != 0`.\n', '        uint256 withdrawalRequestPassTimestamp;\n', '        FixedPoint.Unsigned withdrawalRequestAmount;\n', '        // Raw collateral value. This value should never be accessed directly -- always use _getFeeAdjustedCollateral().\n', '        // To add or remove collateral, use _addCollateral() and _removeCollateral().\n', '        FixedPoint.Unsigned rawCollateral;\n', '        // Tracks pending transfer position requests. A transfer position request is pending if `transferPositionRequestPassTimestamp != 0`.\n', '        uint256 transferPositionRequestPassTimestamp;\n', '    }\n', '\n', '    // Maps sponsor addresses to their positions. Each sponsor can have only one position.\n', '    mapping(address => PositionData) public positions;\n', '\n', '    // Keep track of the total collateral and tokens across all positions to enable calculating the\n', '    // global collateralization ratio without iterating over all positions.\n', '    FixedPoint.Unsigned public totalTokensOutstanding;\n', '\n', '    // Similar to the rawCollateral in PositionData, this value should not be used directly.\n', '    // _getFeeAdjustedCollateral(), _addCollateral() and _removeCollateral() must be used to access and adjust.\n', '    FixedPoint.Unsigned public rawTotalPositionCollateral;\n', '\n', '    // Synthetic token created by this contract.\n', '    ExpandedIERC20 public tokenCurrency;\n', '\n', '    // Unique identifier for DVM price feed ticker.\n', '    bytes32 public priceIdentifier;\n', '    // Time that this contract expires. Should not change post-construction unless an emergency shutdown occurs.\n', '    uint256 public expirationTimestamp;\n', '    // Time that has to elapse for a withdrawal request to be considered passed, if no liquidations occur.\n', '    // !!Note: The lower the withdrawal liveness value, the more risk incurred by the contract.\n', '    //       Extremely low liveness values increase the chance that opportunistic invalid withdrawal requests\n', '    //       expire without liquidation, thereby increasing the insolvency risk for the contract as a whole. An insolvent\n', '    //       contract is extremely risky for any sponsor or synthetic token holder for the contract.\n', '    uint256 public withdrawalLiveness;\n', '\n', "    // Minimum number of tokens in a sponsor's position.\n", '    FixedPoint.Unsigned public minSponsorTokens;\n', '\n', '    // The expiry price pulled from the DVM.\n', '    FixedPoint.Unsigned public expiryPrice;\n', '\n', '    // The excessTokenBeneficiary of any excess tokens added to the contract.\n', '    address public excessTokenBeneficiary;\n', '\n', '    /****************************************\n', '     *                EVENTS                *\n', '     ****************************************/\n', '\n', '    event RequestTransferPosition(address indexed oldSponsor);\n', '    event RequestTransferPositionExecuted(address indexed oldSponsor, address indexed newSponsor);\n', '    event RequestTransferPositionCanceled(address indexed oldSponsor);\n', '    event Deposit(address indexed sponsor, uint256 indexed collateralAmount);\n', '    event Withdrawal(address indexed sponsor, uint256 indexed collateralAmount);\n', '    event RequestWithdrawal(address indexed sponsor, uint256 indexed collateralAmount);\n', '    event RequestWithdrawalExecuted(address indexed sponsor, uint256 indexed collateralAmount);\n', '    event RequestWithdrawalCanceled(address indexed sponsor, uint256 indexed collateralAmount);\n', '    event PositionCreated(address indexed sponsor, uint256 indexed collateralAmount, uint256 indexed tokenAmount);\n', '    event NewSponsor(address indexed sponsor);\n', '    event EndedSponsorPosition(address indexed sponsor);\n', '    event Redeem(address indexed sponsor, uint256 indexed collateralAmount, uint256 indexed tokenAmount);\n', '    event ContractExpired(address indexed caller);\n', '    event SettleExpiredPosition(\n', '        address indexed caller,\n', '        uint256 indexed collateralReturned,\n', '        uint256 indexed tokensBurned\n', '    );\n', '    event EmergencyShutdown(address indexed caller, uint256 originalExpirationTimestamp, uint256 shutdownTimestamp);\n', '\n', '    /****************************************\n', '     *               MODIFIERS              *\n', '     ****************************************/\n', '\n', '    modifier onlyPreExpiration() {\n', '        _onlyPreExpiration();\n', '        _;\n', '    }\n', '\n', '    modifier onlyPostExpiration() {\n', '        _onlyPostExpiration();\n', '        _;\n', '    }\n', '\n', '    modifier onlyCollateralizedPosition(address sponsor) {\n', '        _onlyCollateralizedPosition(sponsor);\n', '        _;\n', '    }\n', '\n', '    // Check that the current state of the pricelessPositionManager is Open.\n', '    // This prevents multiple calls to `expire` and `EmergencyShutdown` post expiration.\n', '    modifier onlyOpenState() {\n', '        _onlyOpenState();\n', '        _;\n', '    }\n', '\n', '    modifier noPendingWithdrawal(address sponsor) {\n', '        _positionHasNoPendingWithdrawal(sponsor);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Construct the PricelessPositionManager\n', '     * @param _expirationTimestamp unix timestamp of when the contract will expire.\n', '     * @param _withdrawalLiveness liveness delay, in seconds, for pending withdrawals.\n', '     * @param _collateralAddress ERC20 token used as collateral for all positions.\n', '     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\n', '     * @param _priceIdentifier registered in the DVM for the synthetic.\n', '     * @param _syntheticName name for the token contract that will be deployed.\n', '     * @param _syntheticSymbol symbol for the token contract that will be deployed.\n', '     * @param _tokenFactoryAddress deployed UMA token factory to create the synthetic token.\n', '     * @param _minSponsorTokens minimum amount of collateral that must exist at any time in a position.\n', '     * @param _timerAddress Contract that stores the current time in a testing environment.\n', '     * @param _excessTokenBeneficiary Beneficiary to which all excess token balances that accrue in the contract can be\n', '     * sent.\n', '     * Must be set to 0x0 for production environments that use live time.\n', '     */\n', '    constructor(\n', '        uint256 _expirationTimestamp,\n', '        uint256 _withdrawalLiveness,\n', '        address _collateralAddress,\n', '        address _finderAddress,\n', '        bytes32 _priceIdentifier,\n', '        string memory _syntheticName,\n', '        string memory _syntheticSymbol,\n', '        address _tokenFactoryAddress,\n', '        FixedPoint.Unsigned memory _minSponsorTokens,\n', '        address _timerAddress,\n', '        address _excessTokenBeneficiary\n', '    ) public FeePayer(_collateralAddress, _finderAddress, _timerAddress) nonReentrant() {\n', '        require(_expirationTimestamp > getCurrentTime(), "Invalid expiration in future");\n', '        require(_getIdentifierWhitelist().isIdentifierSupported(_priceIdentifier), "Unsupported price identifier");\n', '\n', '        expirationTimestamp = _expirationTimestamp;\n', '        withdrawalLiveness = _withdrawalLiveness;\n', '        TokenFactory tf = TokenFactory(_tokenFactoryAddress);\n', '        tokenCurrency = tf.createToken(_syntheticName, _syntheticSymbol, 18);\n', '        minSponsorTokens = _minSponsorTokens;\n', '        priceIdentifier = _priceIdentifier;\n', '        excessTokenBeneficiary = _excessTokenBeneficiary;\n', '    }\n', '\n', '    /****************************************\n', '     *          POSITION FUNCTIONS          *\n', '     ****************************************/\n', '\n', '    /**\n', "     * @notice Requests to transfer ownership of the caller's current position to a new sponsor address.\n", '     * Once the request liveness is passed, the sponsor can execute the transfer and specify the new sponsor.\n', '     * @dev The liveness length is the same as the withdrawal liveness.\n', '     */\n', '    function requestTransferPosition() public onlyPreExpiration() nonReentrant() {\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        require(positionData.transferPositionRequestPassTimestamp == 0, "Pending transfer");\n', '\n', '        // Make sure the proposed expiration of this request is not post-expiry.\n', '        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\n', '        require(requestPassTime < expirationTimestamp, "Request expires post-expiry");\n', '\n', '        // Update the position object for the user.\n', '        positionData.transferPositionRequestPassTimestamp = requestPassTime;\n', '\n', '        emit RequestTransferPosition(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice After a passed transfer position request (i.e., by a call to `requestTransferPosition` and waiting\n', "     * `withdrawalLiveness`), transfers ownership of the caller's current position to `newSponsorAddress`.\n", '     * @dev Transferring positions can only occur if the recipient does not already have a position.\n', '     * @param newSponsorAddress is the address to which the position will be transferred.\n', '     */\n', '    function transferPositionPassedRequest(address newSponsorAddress)\n', '        public\n', '        onlyPreExpiration()\n', '        noPendingWithdrawal(msg.sender)\n', '        nonReentrant()\n', '    {\n', '        require(\n', '            _getFeeAdjustedCollateral(positions[newSponsorAddress].rawCollateral).isEqual(\n', '                FixedPoint.fromUnscaledUint(0)\n', '            ),\n', '            "Sponsor already has position"\n', '        );\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        require(\n', '            positionData.transferPositionRequestPassTimestamp != 0 &&\n', '                positionData.transferPositionRequestPassTimestamp <= getCurrentTime(),\n', '            "Invalid transfer request"\n', '        );\n', '\n', '        // Reset transfer request.\n', '        positionData.transferPositionRequestPassTimestamp = 0;\n', '\n', '        positions[newSponsorAddress] = positionData;\n', '        delete positions[msg.sender];\n', '\n', '        emit RequestTransferPositionExecuted(msg.sender, newSponsorAddress);\n', '        emit NewSponsor(newSponsorAddress);\n', '        emit EndedSponsorPosition(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Cancels a pending transfer position request.\n', '     */\n', '    function cancelTransferPosition() external onlyPreExpiration() nonReentrant() {\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        require(positionData.transferPositionRequestPassTimestamp != 0, "No pending transfer");\n', '\n', '        emit RequestTransferPositionCanceled(msg.sender);\n', '\n', '        // Reset withdrawal request.\n', '        positionData.transferPositionRequestPassTimestamp = 0;\n', '    }\n', '\n', '    /**\n', "     * @notice Transfers `collateralAmount` of `collateralCurrency` into the specified sponsor's position.\n", '     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend\n', '     * at least `collateralAmount` of `collateralCurrency`.\n', '     * @param sponsor the sponsor to credit the deposit to.\n', "     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\n", '     */\n', '    function depositTo(address sponsor, FixedPoint.Unsigned memory collateralAmount)\n', '        public\n', '        onlyPreExpiration()\n', '        noPendingWithdrawal(sponsor)\n', '        fees()\n', '        nonReentrant()\n', '    {\n', '        require(collateralAmount.isGreaterThan(0), "Invalid collateral amount");\n', '        PositionData storage positionData = _getPositionData(sponsor);\n', '\n', '        // Increase the position and global collateral balance by collateral amount.\n', '        _incrementCollateralBalances(positionData, collateralAmount);\n', '\n', '        emit Deposit(sponsor, collateralAmount.rawValue);\n', '\n', '        // Move collateral currency from sender to contract.\n', '        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n', '    }\n', '\n', '    /**\n', "     * @notice Transfers `collateralAmount` of `collateralCurrency` into the caller's position.\n", '     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend\n', '     * at least `collateralAmount` of `collateralCurrency`.\n', "     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\n", '     */\n', '    function deposit(FixedPoint.Unsigned memory collateralAmount) public {\n', '        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\n', '        depositTo(msg.sender, collateralAmount);\n', '    }\n', '\n', '    /**\n', "     * @notice Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.\n", "     * @dev Reverts if the withdrawal puts this position's collateralization ratio below the global collateralization\n", '     * ratio. In that case, use `requestWithdrawal`. Might not withdraw the full requested amount to account for precision loss.\n', '     * @param collateralAmount is the amount of collateral to withdraw.\n', '     * @return amountWithdrawn The actual amount of collateral withdrawn.\n', '     */\n', '    function withdraw(FixedPoint.Unsigned memory collateralAmount)\n', '        public\n', '        onlyPreExpiration()\n', '        noPendingWithdrawal(msg.sender)\n', '        fees()\n', '        nonReentrant()\n', '        returns (FixedPoint.Unsigned memory amountWithdrawn)\n', '    {\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        require(collateralAmount.isGreaterThan(0), "Invalid collateral amount");\n', '\n', "        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\n", '        // position remains above the GCR within the witdrawl. If this is not the case the caller must submit a request.\n', '        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\n', '\n', '        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n', '\n', '        // Move collateral currency from contract to sender.\n', '        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n', '        // instead of the user requested amount. This eliminates precision loss that could occur\n', '        // where the user withdraws more collateral than rawCollateral is decremented by.\n', '        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice Starts a withdrawal request that, if passed, allows the sponsor to withdraw` from their position.\n', '     * @dev The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.\n', '     * @param collateralAmount the amount of collateral requested to withdraw\n', '     */\n', '    function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\n', '        public\n', '        onlyPreExpiration()\n', '        noPendingWithdrawal(msg.sender)\n', '        nonReentrant()\n', '    {\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        require(\n', '            collateralAmount.isGreaterThan(0) &&\n', '                collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral)),\n', '            "Invalid collateral amount"\n', '        );\n', '\n', '        // Make sure the proposed expiration of this request is not post-expiry.\n', '        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\n', '        require(requestPassTime < expirationTimestamp, "Request expires post-expiry");\n', '\n', '        // Update the position object for the user.\n', '        positionData.withdrawalRequestPassTimestamp = requestPassTime;\n', '        positionData.withdrawalRequestAmount = collateralAmount;\n', '\n', '        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting\n', '     * `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.\n', '     * @dev Might not withdraw the full requested amount in order to account for precision loss or if the full requested\n', '     * amount exceeds the collateral in the position (due to paying fees).\n', '     * @return amountWithdrawn The actual amount of collateral withdrawn.\n', '     */\n', '    function withdrawPassedRequest()\n', '        external\n', '        onlyPreExpiration()\n', '        fees()\n', '        nonReentrant()\n', '        returns (FixedPoint.Unsigned memory amountWithdrawn)\n', '    {\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        require(\n', '            positionData.withdrawalRequestPassTimestamp != 0 &&\n', '                positionData.withdrawalRequestPassTimestamp <= getCurrentTime(),\n', '            "Invalid withdraw request"\n', '        );\n', '\n', '        // If withdrawal request amount is > position collateral, then withdraw the full collateral amount.\n', '        // This situation is possible due to fees charged since the withdrawal was originally requested.\n', '        FixedPoint.Unsigned memory amountToWithdraw = positionData.withdrawalRequestAmount;\n', '        if (positionData.withdrawalRequestAmount.isGreaterThan(_getFeeAdjustedCollateral(positionData.rawCollateral))) {\n', '            amountToWithdraw = _getFeeAdjustedCollateral(positionData.rawCollateral);\n', '        }\n', '\n', "        // Decrement the sponsor's collateral and global collateral amounts.\n", '        amountWithdrawn = _decrementCollateralBalances(positionData, amountToWithdraw);\n', '\n', '        // Reset withdrawal request by setting withdrawal amount and withdrawal timestamp to 0.\n', '        _resetWithdrawalRequest(positionData);\n', '\n', '        // Transfer approved withdrawal amount from the contract to the caller.\n', '        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n', '\n', '        emit RequestWithdrawalExecuted(msg.sender, amountWithdrawn.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice Cancels a pending withdrawal request.\n', '     */\n', '    function cancelWithdrawal() external nonReentrant() {\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        require(positionData.withdrawalRequestPassTimestamp != 0, "No pending withdrawal");\n', '\n', '        emit RequestWithdrawalCanceled(msg.sender, positionData.withdrawalRequestAmount.rawValue);\n', '\n', '        // Reset withdrawal request by setting withdrawal amount and withdrawal timestamp to 0.\n', '        _resetWithdrawalRequest(positionData);\n', '    }\n', '\n', '    /**\n', "     * @notice Creates tokens by creating a new position or by augmenting an existing position. Pulls `collateralAmount` into the sponsor's position and mints `numTokens` of `tokenCurrency`.\n", "     * @dev Reverts if minting these tokens would put the position's collateralization ratio below the\n", '     * global collateralization ratio. This contract must be approved to spend at least `collateralAmount` of\n', '     * `collateralCurrency`.\n', '     * @param collateralAmount is the number of collateral tokens to collateralize the position with\n', '     * @param numTokens is the number of tokens to mint from the position.\n', '     */\n', '    function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\n', '        public\n', '        onlyPreExpiration()\n', '        fees()\n', '        nonReentrant()\n', '    {\n', '        PositionData storage positionData = positions[msg.sender];\n', '\n', '        // Either the new create ratio or the resultant position CR must be above the current GCR.\n', '        require(\n', '            (_checkCollateralization(\n', '                _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\n', '                positionData.tokensOutstanding.add(numTokens)\n', '            ) || _checkCollateralization(collateralAmount, numTokens)),\n', '            "Insufficient collateral"\n', '        );\n', '\n', '        require(positionData.withdrawalRequestPassTimestamp == 0, "Pending withdrawal");\n', '        if (positionData.tokensOutstanding.isEqual(0)) {\n', '            require(numTokens.isGreaterThanOrEqual(minSponsorTokens), "Below minimum sponsor position");\n', '            emit NewSponsor(msg.sender);\n', '        }\n', '\n', '        // Increase the position and global collateral balance by collateral amount.\n', '        _incrementCollateralBalances(positionData, collateralAmount);\n', '\n', "        // Add the number of tokens created to the position's outstanding tokens.\n", '        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n', '\n', '        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n', '\n', '        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n', '\n', "        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\n", '        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n', '        require(tokenCurrency.mint(msg.sender, numTokens.rawValue), "Minting synthetic tokens failed");\n', '    }\n', '\n', '    /**\n', '     * @notice Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.\n', '     * @dev Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral\n', '     * in order to account for precision loss. This contract must be approved to spend at least `numTokens` of\n', '     * `tokenCurrency`.\n', '     * @param numTokens is the number of tokens to be burnt for a commensurate amount of collateral.\n', '     * @return amountWithdrawn The actual amount of collateral withdrawn.\n', '     */\n', '    function redeem(FixedPoint.Unsigned memory numTokens)\n', '        public\n', '        noPendingWithdrawal(msg.sender)\n', '        fees()\n', '        nonReentrant()\n', '        returns (FixedPoint.Unsigned memory amountWithdrawn)\n', '    {\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        require(!numTokens.isGreaterThan(positionData.tokensOutstanding), "Invalid token amount");\n', '\n', '        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n', '        FixedPoint.Unsigned memory collateralRedeemed = fractionRedeemed.mul(\n', '            _getFeeAdjustedCollateral(positionData.rawCollateral)\n', '        );\n', '\n', '        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n', '        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n', '            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n', '        } else {\n', "            // Decrement the sponsor's collateral and global collateral amounts.\n", '            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\n', '\n', '            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n', '            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n', '            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens), "Below minimum sponsor position");\n', '            positionData.tokensOutstanding = newTokenCount;\n', '\n', '            // Update the totalTokensOutstanding after redemption.\n', '            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n', '        }\n', '\n', '        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n', '\n', '        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n', '        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n', '        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n', '        tokenCurrency.burn(numTokens.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice After a contract has passed expiry all token holders can redeem their tokens for underlying at the\n', '     * prevailing price defined by the DVM from the `expire` function.\n', '     * @dev This burns all tokens from the caller of `tokenCurrency` and sends back the proportional amount of\n', '     * `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for\n', "     * precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.\n", '     * @return amountWithdrawn The actual amount of collateral withdrawn.\n', '     */\n', '    function settleExpired()\n', '        external\n', '        onlyPostExpiration()\n', '        fees()\n', '        nonReentrant()\n', '        returns (FixedPoint.Unsigned memory amountWithdrawn)\n', '    {\n', '        // If the contract state is open and onlyPostExpiration passed then `expire()` has not yet been called.\n', '        require(contractState != ContractState.Open, "Unexpired position");\n', '\n', '        // Get the current settlement price and store it. If it is not resolved will revert.\n', '        if (contractState != ContractState.ExpiredPriceReceived) {\n', '            expiryPrice = _getOraclePrice(expirationTimestamp);\n', '            contractState = ContractState.ExpiredPriceReceived;\n', '        }\n', '\n', "        // Get caller's tokens balance and calculate amount of underlying entitled to them.\n", '        FixedPoint.Unsigned memory tokensToRedeem = FixedPoint.Unsigned(tokenCurrency.balanceOf(msg.sender));\n', '        FixedPoint.Unsigned memory totalRedeemableCollateral = tokensToRedeem.mul(expiryPrice);\n', '\n', '        // If the caller is a sponsor with outstanding collateral they are also entitled to their excess collateral after their debt.\n', '        PositionData storage positionData = positions[msg.sender];\n', '        if (_getFeeAdjustedCollateral(positionData.rawCollateral).isGreaterThan(0)) {\n', '            // Calculate the underlying entitled to a token sponsor. This is collateral - debt in underlying.\n', '            FixedPoint.Unsigned memory tokenDebtValueInCollateral = positionData.tokensOutstanding.mul(expiryPrice);\n', '            FixedPoint.Unsigned memory positionCollateral = _getFeeAdjustedCollateral(positionData.rawCollateral);\n', '\n', '            // If the debt is greater than the remaining collateral, they cannot redeem anything.\n', '            FixedPoint.Unsigned memory positionRedeemableCollateral = tokenDebtValueInCollateral.isLessThan(\n', '                positionCollateral\n', '            )\n', '                ? positionCollateral.sub(tokenDebtValueInCollateral)\n', '                : FixedPoint.Unsigned(0);\n', '\n', '            // Add the number of redeemable tokens for the sponsor to their total redeemable collateral.\n', '            totalRedeemableCollateral = totalRedeemableCollateral.add(positionRedeemableCollateral);\n', '\n', '            // Reset the position state as all the value has been removed after settlement.\n', '            delete positions[msg.sender];\n', '            emit EndedSponsorPosition(msg.sender);\n', '        }\n', '\n', '        // Take the min of the remaining collateral and the collateral "owed". If the contract is undercapitalized,\n', '        // the caller will get as much collateral as the contract can pay out.\n', '        FixedPoint.Unsigned memory payout = FixedPoint.min(\n', '            _getFeeAdjustedCollateral(rawTotalPositionCollateral),\n', '            totalRedeemableCollateral\n', '        );\n', '\n', '        // Decrement total contract collateral and outstanding debt.\n', '        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, payout);\n', '        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRedeem);\n', '\n', '        emit SettleExpiredPosition(msg.sender, amountWithdrawn.rawValue, tokensToRedeem.rawValue);\n', '\n', '        // Transfer tokens & collateral and burn the redeemed tokens.\n', '        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n', '        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensToRedeem.rawValue);\n', '        tokenCurrency.burn(tokensToRedeem.rawValue);\n', '    }\n', '\n', '    /****************************************\n', '     *        GLOBAL STATE FUNCTIONS        *\n', '     ****************************************/\n', '\n', '    /**\n', '     * @notice Locks contract state in expired and requests oracle price.\n', "     * @dev this function can only be called once the contract is expired and can't be re-called.\n", '     */\n', '    function expire() external onlyPostExpiration() onlyOpenState() fees() nonReentrant() {\n', '        contractState = ContractState.ExpiredPriceRequested;\n', '\n', '        // The final fee for this request is paid out of the contract rather than by the caller.\n', '        _payFinalFees(address(this), _computeFinalFees());\n', '        _requestOraclePrice(expirationTimestamp);\n', '\n', '        emit ContractExpired(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Premature contract settlement under emergency circumstances.\n', '     * @dev Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`.\n', '     * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal\n', '     * to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested`\n', '     * which prevents re-entry into this function or the `expire` function. No fees are paid when calling\n', '     * `emergencyShutdown` as the governor who would call the function would also receive the fees.\n', '     */\n', '    function emergencyShutdown() external override onlyPreExpiration() onlyOpenState() nonReentrant() {\n', '        require(msg.sender == _getFinancialContractsAdminAddress(), "Caller not Governor");\n', '\n', '        contractState = ContractState.ExpiredPriceRequested;\n', '        // Expiratory time now becomes the current time (emergency shutdown time).\n', '        // Price requested at this time stamp. `settleExpired` can now withdraw at this timestamp.\n', '        uint256 oldExpirationTimestamp = expirationTimestamp;\n', '        expirationTimestamp = getCurrentTime();\n', '        _requestOraclePrice(expirationTimestamp);\n', '\n', '        emit EmergencyShutdown(msg.sender, oldExpirationTimestamp, expirationTimestamp);\n', '    }\n', '\n', '    /**\n', '     * @notice Theoretically supposed to pay fees and move money between margin accounts to make sure they\n', "     * reflect the NAV of the contract. However, this functionality doesn't apply to this contract.\n", '     * @dev This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable\n', '     * only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.\n', '     */\n', '    function remargin() external override onlyPreExpiration() nonReentrant() {\n', '        return;\n', '    }\n', '\n', '    /**\n', '     * @notice Drains any excess balance of the provided ERC20 token to a pre-selected beneficiary.\n', '     * @dev This will drain down to the amount of tracked collateral and drain the full balance of any other token.\n', '     * @param token address of the ERC20 token whose excess balance should be drained.\n', '     */\n', '    function trimExcess(IERC20 token) external fees() nonReentrant() returns (FixedPoint.Unsigned memory amount) {\n', '        FixedPoint.Unsigned memory balance = FixedPoint.Unsigned(token.balanceOf(address(this)));\n', '\n', '        if (address(token) == address(collateralCurrency)) {\n', '            // If it is the collateral currency, send only the amount that the contract is not tracking.\n', '            // Note: this could be due to rounding error or balance-changing tokens, like aTokens.\n', '            amount = balance.sub(_pfc());\n', '        } else {\n', "            // If it's not the collateral currency, send the entire balance.\n", '            amount = balance;\n', '        }\n', '        token.safeTransfer(excessTokenBeneficiary, amount.rawValue);\n', '    }\n', '\n', '    /**\n', "     * @notice Accessor method for a sponsor's collateral.\n", '     * @dev This is necessary because the struct returned by the positions() method shows\n', "     * rawCollateral, which isn't a user-readable value.\n", '     * @param sponsor address whose collateral amount is retrieved.\n', '     * @return collateralAmount amount of collateral within a sponsors position.\n', '     */\n', '    function getCollateral(address sponsor)\n', '        external\n', '        view\n', '        nonReentrantView()\n', '        returns (FixedPoint.Unsigned memory collateralAmount)\n', '    {\n', '        // Note: do a direct access to avoid the validity check.\n', '        return _getFeeAdjustedCollateral(positions[sponsor].rawCollateral);\n', '    }\n', '\n', '    /**\n', '     * @notice Accessor method for the total collateral stored within the PricelessPositionManager.\n', '     * @return totalCollateral amount of all collateral within the Expiring Multi Party Contract.\n', '     */\n', '    function totalPositionCollateral()\n', '        external\n', '        view\n', '        nonReentrantView()\n', '        returns (FixedPoint.Unsigned memory totalCollateral)\n', '    {\n', '        return _getFeeAdjustedCollateral(rawTotalPositionCollateral);\n', '    }\n', '\n', '    /****************************************\n', '     *          INTERNAL FUNCTIONS          *\n', '     ****************************************/\n', '\n', "    // Reduces a sponsor's position and global counters by the specified parameters. Handles deleting the entire\n", '    // position if the entire position is being removed. Does not make any external transfers.\n', '    function _reduceSponsorPosition(\n', '        address sponsor,\n', '        FixedPoint.Unsigned memory tokensToRemove,\n', '        FixedPoint.Unsigned memory collateralToRemove,\n', '        FixedPoint.Unsigned memory withdrawalAmountToRemove\n', '    ) internal {\n', '        PositionData storage positionData = _getPositionData(sponsor);\n', '\n', '        // If the entire position is being removed, delete it instead.\n', '        if (\n', '            tokensToRemove.isEqual(positionData.tokensOutstanding) &&\n', '            _getFeeAdjustedCollateral(positionData.rawCollateral).isEqual(collateralToRemove)\n', '        ) {\n', '            _deleteSponsorPosition(sponsor);\n', '            return;\n', '        }\n', '\n', "        // Decrement the sponsor's collateral and global collateral amounts.\n", '        _decrementCollateralBalances(positionData, collateralToRemove);\n', '\n', '        // Ensure that the sponsor will meet the min position size after the reduction.\n', '        FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(tokensToRemove);\n', '        require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens), "Below minimum sponsor position");\n', '        positionData.tokensOutstanding = newTokenCount;\n', '\n', "        // Decrement the position's withdrawal amount.\n", '        positionData.withdrawalRequestAmount = positionData.withdrawalRequestAmount.sub(withdrawalAmountToRemove);\n', '\n', '        // Decrement the total outstanding tokens in the overall contract.\n', '        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRemove);\n', '    }\n', '\n', "    // Deletes a sponsor's position and updates global counters. Does not make any external transfers.\n", '    function _deleteSponsorPosition(address sponsor) internal returns (FixedPoint.Unsigned memory) {\n', '        PositionData storage positionToLiquidate = _getPositionData(sponsor);\n', '\n', '        FixedPoint.Unsigned memory startingGlobalCollateral = _getFeeAdjustedCollateral(rawTotalPositionCollateral);\n', '\n', '        // Remove the collateral and outstanding from the overall total position.\n', '        FixedPoint.Unsigned memory remainingRawCollateral = positionToLiquidate.rawCollateral;\n', '        rawTotalPositionCollateral = rawTotalPositionCollateral.sub(remainingRawCollateral);\n', '        totalTokensOutstanding = totalTokensOutstanding.sub(positionToLiquidate.tokensOutstanding);\n', '\n', '        // Reset the sponsors position to have zero outstanding and collateral.\n', '        delete positions[sponsor];\n', '\n', '        emit EndedSponsorPosition(sponsor);\n', '\n', '        // Return fee-adjusted amount of collateral deleted from position.\n', '        return startingGlobalCollateral.sub(_getFeeAdjustedCollateral(rawTotalPositionCollateral));\n', '    }\n', '\n', '    function _pfc() internal virtual override view returns (FixedPoint.Unsigned memory) {\n', '        return _getFeeAdjustedCollateral(rawTotalPositionCollateral);\n', '    }\n', '\n', '    function _getPositionData(address sponsor)\n', '        internal\n', '        view\n', '        onlyCollateralizedPosition(sponsor)\n', '        returns (PositionData storage)\n', '    {\n', '        return positions[sponsor];\n', '    }\n', '\n', '    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\n', '        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n', '    }\n', '\n', '    function _getOracle() internal view returns (OracleInterface) {\n', '        return OracleInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\n', '    }\n', '\n', '    function _getFinancialContractsAdminAddress() internal view returns (address) {\n', '        return finder.getImplementationAddress(OracleInterfaces.FinancialContractsAdmin);\n', '    }\n', '\n', '    // Requests a price for `priceIdentifier` at `requestedTime` from the Oracle.\n', '    function _requestOraclePrice(uint256 requestedTime) internal {\n', '        OracleInterface oracle = _getOracle();\n', '        oracle.requestPrice(priceIdentifier, requestedTime);\n', '    }\n', '\n', "    // Fetches a resolved Oracle price from the Oracle. Reverts if the Oracle hasn't resolved for this request.\n", '    function _getOraclePrice(uint256 requestedTime) internal view returns (FixedPoint.Unsigned memory) {\n', '        // Create an instance of the oracle and get the price. If the price is not resolved revert.\n', '        OracleInterface oracle = _getOracle();\n', '        require(oracle.hasPrice(priceIdentifier, requestedTime), "Unresolved oracle price");\n', '        int256 oraclePrice = oracle.getPrice(priceIdentifier, requestedTime);\n', '\n', "        // For now we don't want to deal with negative prices in positions.\n", '        if (oraclePrice < 0) {\n', '            oraclePrice = 0;\n', '        }\n', '        return FixedPoint.Unsigned(uint256(oraclePrice));\n', '    }\n', '\n', '    // Reset withdrawal request by setting the withdrawal request and withdrawal timestamp to 0.\n', '    function _resetWithdrawalRequest(PositionData storage positionData) internal {\n', '        positionData.withdrawalRequestAmount = FixedPoint.fromUnscaledUint(0);\n', '        positionData.withdrawalRequestPassTimestamp = 0;\n', '    }\n', '\n', '    // Ensure individual and global consistency when increasing collateral balances. Returns the change to the position.\n', '    function _incrementCollateralBalances(\n', '        PositionData storage positionData,\n', '        FixedPoint.Unsigned memory collateralAmount\n', '    ) internal returns (FixedPoint.Unsigned memory) {\n', '        _addCollateral(positionData.rawCollateral, collateralAmount);\n', '        return _addCollateral(rawTotalPositionCollateral, collateralAmount);\n', '    }\n', '\n', '    // Ensure individual and global consistency when decrementing collateral balances. Returns the change to the\n', '    // position. We elect to return the amount that the global collateral is decreased by, rather than the individual\n', "    // position's collateral, because we need to maintain the invariant that the global collateral is always\n", '    // <= the collateral owned by the contract to avoid reverts on withdrawals. The amount returned = amount withdrawn.\n', '    function _decrementCollateralBalances(\n', '        PositionData storage positionData,\n', '        FixedPoint.Unsigned memory collateralAmount\n', '    ) internal returns (FixedPoint.Unsigned memory) {\n', '        _removeCollateral(positionData.rawCollateral, collateralAmount);\n', '        return _removeCollateral(rawTotalPositionCollateral, collateralAmount);\n', '    }\n', '\n', '    // Ensure individual and global consistency when decrementing collateral balances. Returns the change to the position.\n', '    // This function is similar to the _decrementCollateralBalances function except this function checks position GCR\n', '    // between the decrements. This ensures that collateral removal will not leave the position undercollateralized.\n', '    function _decrementCollateralBalancesCheckGCR(\n', '        PositionData storage positionData,\n', '        FixedPoint.Unsigned memory collateralAmount\n', '    ) internal returns (FixedPoint.Unsigned memory) {\n', '        _removeCollateral(positionData.rawCollateral, collateralAmount);\n', '        require(_checkPositionCollateralization(positionData), "CR below GCR");\n', '        return _removeCollateral(rawTotalPositionCollateral, collateralAmount);\n', '    }\n', '\n', '    // These internal functions are supposed to act identically to modifiers, but re-used modifiers\n', '    // unnecessarily increase contract bytecode size.\n', '    // source: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6\n', '    function _onlyOpenState() internal view {\n', '        require(contractState == ContractState.Open, "Contract state is not OPEN");\n', '    }\n', '\n', '    function _onlyPreExpiration() internal view {\n', '        require(getCurrentTime() < expirationTimestamp, "Only callable pre-expiry");\n', '    }\n', '\n', '    function _onlyPostExpiration() internal view {\n', '        require(getCurrentTime() >= expirationTimestamp, "Only callable post-expiry");\n', '    }\n', '\n', '    function _onlyCollateralizedPosition(address sponsor) internal view {\n', '        require(\n', '            _getFeeAdjustedCollateral(positions[sponsor].rawCollateral).isGreaterThan(0),\n', '            "Position has no collateral"\n', '        );\n', '    }\n', '\n', '    // Note: This checks whether an already existing position has a pending withdrawal. This cannot be used on the\n', '    // `create` method because it is possible that `create` is called on a new position (i.e. one without any collateral\n', '    // or tokens outstanding) which would fail the `onlyCollateralizedPosition` modifier on `_getPositionData`.\n', '    function _positionHasNoPendingWithdrawal(address sponsor) internal view {\n', '        require(_getPositionData(sponsor).withdrawalRequestPassTimestamp == 0, "Pending withdrawal");\n', '    }\n', '\n', '    /****************************************\n', '     *          PRIVATE FUNCTIONS          *\n', '     ****************************************/\n', '\n', '    function _checkPositionCollateralization(PositionData storage positionData) private view returns (bool) {\n', '        return\n', '            _checkCollateralization(\n', '                _getFeeAdjustedCollateral(positionData.rawCollateral),\n', '                positionData.tokensOutstanding\n', '            );\n', '    }\n', '\n', '    // Checks whether the provided `collateral` and `numTokens` have a collateralization ratio above the global\n', '    // collateralization ratio.\n', '    function _checkCollateralization(FixedPoint.Unsigned memory collateral, FixedPoint.Unsigned memory numTokens)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        FixedPoint.Unsigned memory global = _getCollateralizationRatio(\n', '            _getFeeAdjustedCollateral(rawTotalPositionCollateral),\n', '            totalTokensOutstanding\n', '        );\n', '        FixedPoint.Unsigned memory thisChange = _getCollateralizationRatio(collateral, numTokens);\n', '        return !global.isGreaterThan(thisChange);\n', '    }\n', '\n', '    function _getCollateralizationRatio(FixedPoint.Unsigned memory collateral, FixedPoint.Unsigned memory numTokens)\n', '        private\n', '        pure\n', '        returns (FixedPoint.Unsigned memory ratio)\n', '    {\n', '        if (!numTokens.isGreaterThan(0)) {\n', '            return FixedPoint.fromUnscaledUint(0);\n', '        } else {\n', '            return collateral.div(numTokens);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/financial-templates/expiring-multiparty/Liquidatable.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Liquidatable\n', ' * @notice Adds logic to a position-managing contract that enables callers to liquidate an undercollateralized position.\n', ' * @dev The liquidation has a liveness period before expiring successfully, during which someone can "dispute" the\n', ' * liquidation, which sends a price request to the relevant Oracle to settle the final collateralization ratio based on\n', ' * a DVM price. The contract enforces dispute rewards in order to incentivize disputers to correctly dispute false\n', ' * liquidations and compensate position sponsors who had their position incorrectly liquidated. Importantly, a\n', ' * prospective disputer must deposit a dispute bond that they can lose in the case of an unsuccessful dispute.\n', ' */\n', 'contract Liquidatable is PricelessPositionManager {\n', '    using FixedPoint for FixedPoint.Unsigned;\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    /****************************************\n', '     *     LIQUIDATION DATA STRUCTURES      *\n', '     ****************************************/\n', '\n', '    // Because of the check in withdrawable(), the order of these enum values should not change.\n', '    enum Status { Uninitialized, PreDispute, PendingDispute, DisputeSucceeded, DisputeFailed }\n', '\n', '    struct LiquidationData {\n', '        // Following variables set upon creation of liquidation:\n', "        address sponsor; // Address of the liquidated position's sponsor\n", '        address liquidator; // Address who created this liquidation\n', '        Status state; // Liquidated (and expired or not), Pending a Dispute, or Dispute has resolved\n', '        uint256 liquidationTime; // Time when liquidation is initiated, needed to get price from Oracle\n', '        // Following variables determined by the position that is being liquidated:\n', '        FixedPoint.Unsigned tokensOutstanding; // Synthetic tokens required to be burned by liquidator to initiate dispute\n', '        FixedPoint.Unsigned lockedCollateral; // Collateral locked by contract and released upon expiry or post-dispute\n', '        // Amount of collateral being liquidated, which could be different from\n', '        // lockedCollateral if there were pending withdrawals at the time of liquidation\n', '        FixedPoint.Unsigned liquidatedCollateral;\n', '        // Unit value (starts at 1) that is used to track the fees per unit of collateral over the course of the liquidation.\n', '        FixedPoint.Unsigned rawUnitCollateral;\n', '        // Following variable set upon initiation of a dispute:\n', '        address disputer; // Person who is disputing a liquidation\n', '        // Following variable set upon a resolution of a dispute:\n', '        FixedPoint.Unsigned settlementPrice; // Final price as determined by an Oracle following a dispute\n', '        FixedPoint.Unsigned finalFee;\n', '    }\n', '\n', "    // Define the contract's constructor parameters as a struct to enable more variables to be specified.\n", "    // This is required to enable more params, over and above Solidity's limits.\n", '    struct ConstructorParams {\n', '        // Params for PricelessPositionManager only.\n', '        uint256 expirationTimestamp;\n', '        uint256 withdrawalLiveness;\n', '        address collateralAddress;\n', '        address finderAddress;\n', '        address tokenFactoryAddress;\n', '        address timerAddress;\n', '        address excessTokenBeneficiary;\n', '        bytes32 priceFeedIdentifier;\n', '        string syntheticName;\n', '        string syntheticSymbol;\n', '        FixedPoint.Unsigned minSponsorTokens;\n', '        // Params specifically for Liquidatable.\n', '        uint256 liquidationLiveness;\n', '        FixedPoint.Unsigned collateralRequirement;\n', '        FixedPoint.Unsigned disputeBondPct;\n', '        FixedPoint.Unsigned sponsorDisputeRewardPct;\n', '        FixedPoint.Unsigned disputerDisputeRewardPct;\n', '    }\n', '\n', '    // Liquidations are unique by ID per sponsor\n', '    mapping(address => LiquidationData[]) public liquidations;\n', '\n', '    // Total collateral in liquidation.\n', '    FixedPoint.Unsigned public rawLiquidationCollateral;\n', '\n', '    // Immutable contract parameters:\n', '    // Amount of time for pending liquidation before expiry.\n', '    // !!Note: The lower the liquidation liveness value, the more risk incurred by sponsors.\n', '    //       Extremely low liveness values increase the chance that opportunistic invalid liquidations\n', '    //       expire without dispute, thereby decreasing the usability for sponsors and increasing the risk\n', '    //       for the contract as a whole. An insolvent contract is extremely risky for any sponsor or synthetic\n', '    //       token holder for the contract.\n', '    uint256 public liquidationLiveness;\n', '    // Required collateral:TRV ratio for a position to be considered sufficiently collateralized.\n', '    FixedPoint.Unsigned public collateralRequirement;\n', "    // Percent of a Liquidation/Position's lockedCollateral to be deposited by a potential disputer\n", '    // Represented as a multiplier, for example 1.5e18 = "150%" and 0.05e18 = "5%"\n', '    FixedPoint.Unsigned public disputeBondPct;\n', '    // Percent of oraclePrice paid to sponsor in the Disputed state (i.e. following a successful dispute)\n', '    // Represented as a multiplier, see above.\n', '    FixedPoint.Unsigned public sponsorDisputeRewardPct;\n', '    // Percent of oraclePrice paid to disputer in the Disputed state (i.e. following a successful dispute)\n', '    // Represented as a multiplier, see above.\n', '    FixedPoint.Unsigned public disputerDisputeRewardPct;\n', '\n', '    /****************************************\n', '     *                EVENTS                *\n', '     ****************************************/\n', '\n', '    event LiquidationCreated(\n', '        address indexed sponsor,\n', '        address indexed liquidator,\n', '        uint256 indexed liquidationId,\n', '        uint256 tokensOutstanding,\n', '        uint256 lockedCollateral,\n', '        uint256 liquidatedCollateral,\n', '        uint256 liquidationTime\n', '    );\n', '    event LiquidationDisputed(\n', '        address indexed sponsor,\n', '        address indexed liquidator,\n', '        address indexed disputer,\n', '        uint256 liquidationId,\n', '        uint256 disputeBondAmount\n', '    );\n', '    event DisputeSettled(\n', '        address indexed caller,\n', '        address indexed sponsor,\n', '        address indexed liquidator,\n', '        address disputer,\n', '        uint256 liquidationId,\n', '        bool disputeSucceeded\n', '    );\n', '    event LiquidationWithdrawn(\n', '        address indexed caller,\n', '        uint256 withdrawalAmount,\n', '        Status indexed liquidationStatus,\n', '        uint256 settlementPrice\n', '    );\n', '\n', '    /****************************************\n', '     *              MODIFIERS               *\n', '     ****************************************/\n', '\n', '    modifier disputable(uint256 liquidationId, address sponsor) {\n', '        _disputable(liquidationId, sponsor);\n', '        _;\n', '    }\n', '\n', '    modifier withdrawable(uint256 liquidationId, address sponsor) {\n', '        _withdrawable(liquidationId, sponsor);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Constructs the liquidatable contract.\n', '     * @param params struct to define input parameters for construction of Liquidatable. Some params\n', "     * are fed directly into the PricelessPositionManager's constructor within the inheritance tree.\n", '     */\n', '    constructor(ConstructorParams memory params)\n', '        public\n', '        PricelessPositionManager(\n', '            params.expirationTimestamp,\n', '            params.withdrawalLiveness,\n', '            params.collateralAddress,\n', '            params.finderAddress,\n', '            params.priceFeedIdentifier,\n', '            params.syntheticName,\n', '            params.syntheticSymbol,\n', '            params.tokenFactoryAddress,\n', '            params.minSponsorTokens,\n', '            params.timerAddress,\n', '            params.excessTokenBeneficiary\n', '        )\n', '        nonReentrant()\n', '    {\n', '        require(params.collateralRequirement.isGreaterThan(1), "CR is more than 100%");\n', '        require(\n', '            params.sponsorDisputeRewardPct.add(params.disputerDisputeRewardPct).isLessThan(1),\n', '            "Rewards are more than 100%"\n', '        );\n', '\n', '        // Set liquidatable specific variables.\n', '        liquidationLiveness = params.liquidationLiveness;\n', '        collateralRequirement = params.collateralRequirement;\n', '        disputeBondPct = params.disputeBondPct;\n', '        sponsorDisputeRewardPct = params.sponsorDisputeRewardPct;\n', '        disputerDisputeRewardPct = params.disputerDisputeRewardPct;\n', '    }\n', '\n', '    /****************************************\n', '     *        LIQUIDATION FUNCTIONS         *\n', '     ****************************************/\n', '\n', '    /**\n', "     * @notice Liquidates the sponsor's position if the caller has enough\n", "     * synthetic tokens to retire the position's outstanding tokens. Liquidations above\n", '     * a minimum size also reset an ongoing "slow withdrawal"\'s liveness.\n', '     * @dev This method generates an ID that will uniquely identify liquidation for the sponsor. This contract must be\n', '     * approved to spend at least `tokensLiquidated` of `tokenCurrency` and at least `finalFeeBond` of `collateralCurrency`.\n', '     * @param sponsor address of the sponsor to liquidate.\n', "     * @param minCollateralPerToken abort the liquidation if the position's collateral per token is below this value.\n", "     * @param maxCollateralPerToken abort the liquidation if the position's collateral per token exceeds this value.\n", '     * @param maxTokensToLiquidate max number of tokens to liquidate.\n', '     * @param deadline abort the liquidation if the transaction is mined after this timestamp.\n', '     * @return liquidationId ID of the newly created liquidation.\n', "     * @return tokensLiquidated amount of synthetic tokens removed and liquidated from the `sponsor`'s position.\n", '     * @return finalFeeBond amount of collateral to be posted by liquidator and returned if not disputed successfully.\n', '     */\n', '    function createLiquidation(\n', '        address sponsor,\n', '        FixedPoint.Unsigned calldata minCollateralPerToken,\n', '        FixedPoint.Unsigned calldata maxCollateralPerToken,\n', '        FixedPoint.Unsigned calldata maxTokensToLiquidate,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        fees()\n', '        onlyPreExpiration()\n', '        nonReentrant()\n', '        returns (\n', '            uint256 liquidationId,\n', '            FixedPoint.Unsigned memory tokensLiquidated,\n', '            FixedPoint.Unsigned memory finalFeeBond\n', '        )\n', '    {\n', '        // Check that this transaction was mined pre-deadline.\n', '        require(getCurrentTime() <= deadline, "Mined after deadline");\n', '\n', '        // Retrieve Position data for sponsor\n', '        PositionData storage positionToLiquidate = _getPositionData(sponsor);\n', '\n', '        tokensLiquidated = FixedPoint.min(maxTokensToLiquidate, positionToLiquidate.tokensOutstanding);\n', '\n', "        // Starting values for the Position being liquidated. If withdrawal request amount is > position's collateral,\n", '        // then set this to 0, otherwise set it to (startCollateral - withdrawal request amount).\n', '        FixedPoint.Unsigned memory startCollateral = _getFeeAdjustedCollateral(positionToLiquidate.rawCollateral);\n', '        FixedPoint.Unsigned memory startCollateralNetOfWithdrawal = FixedPoint.fromUnscaledUint(0);\n', '        if (positionToLiquidate.withdrawalRequestAmount.isLessThanOrEqual(startCollateral)) {\n', '            startCollateralNetOfWithdrawal = startCollateral.sub(positionToLiquidate.withdrawalRequestAmount);\n', '        }\n', '\n', '        // Scoping to get rid of a stack too deep error.\n', '        {\n', '            FixedPoint.Unsigned memory startTokens = positionToLiquidate.tokensOutstanding;\n', '\n', "            // The Position's collateralization ratio must be between [minCollateralPerToken, maxCollateralPerToken].\n", '            // maxCollateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\n', '            require(\n', '                maxCollateralPerToken.mul(startTokens).isGreaterThanOrEqual(startCollateralNetOfWithdrawal),\n', '                "CR is more than max liq. price"\n', '            );\n', '            // minCollateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\n', '            require(\n', '                minCollateralPerToken.mul(startTokens).isLessThanOrEqual(startCollateralNetOfWithdrawal),\n', '                "CR is less than min liq. price"\n', '            );\n', '        }\n', '\n', '        // Compute final fee at time of liquidation.\n', '        finalFeeBond = _computeFinalFees();\n', '\n', '        // These will be populated within the scope below.\n', '        FixedPoint.Unsigned memory lockedCollateral;\n', '        FixedPoint.Unsigned memory liquidatedCollateral;\n', '\n', '        // Scoping to get rid of a stack too deep error.\n', '        {\n', '            FixedPoint.Unsigned memory ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding);\n', '\n', '            // The actual amount of collateral that gets moved to the liquidation.\n', '            lockedCollateral = startCollateral.mul(ratio);\n', '\n', "            // For purposes of disputes, it's actually this liquidatedCollateral value that's used. This value is net of\n", '            // withdrawal requests.\n', '            liquidatedCollateral = startCollateralNetOfWithdrawal.mul(ratio);\n', '\n', '            // Part of the withdrawal request is also removed. Ideally:\n', '            // liquidatedCollateral + withdrawalAmountToRemove = lockedCollateral.\n', '            FixedPoint.Unsigned memory withdrawalAmountToRemove = positionToLiquidate.withdrawalRequestAmount.mul(\n', '                ratio\n', '            );\n', '            _reduceSponsorPosition(sponsor, tokensLiquidated, lockedCollateral, withdrawalAmountToRemove);\n', '        }\n', '\n', '        // Add to the global liquidation collateral count.\n', '        _addCollateral(rawLiquidationCollateral, lockedCollateral.add(finalFeeBond));\n', '\n', '        // Construct liquidation object.\n', '        // Note: All dispute-related values are zeroed out until a dispute occurs. liquidationId is the index of the new\n', '        // LiquidationData that is pushed into the array, which is equal to the current length of the array pre-push.\n', '        liquidationId = liquidations[sponsor].length;\n', '        liquidations[sponsor].push(\n', '            LiquidationData({\n', '                sponsor: sponsor,\n', '                liquidator: msg.sender,\n', '                state: Status.PreDispute,\n', '                liquidationTime: getCurrentTime(),\n', '                tokensOutstanding: tokensLiquidated,\n', '                lockedCollateral: lockedCollateral,\n', '                liquidatedCollateral: liquidatedCollateral,\n', '                rawUnitCollateral: _convertToRawCollateral(FixedPoint.fromUnscaledUint(1)),\n', '                disputer: address(0),\n', '                settlementPrice: FixedPoint.fromUnscaledUint(0),\n', '                finalFee: finalFeeBond\n', '            })\n', '        );\n', '\n', '        // If this liquidation is a subsequent liquidation on the position, and the liquidation size is larger than\n', '        // some "griefing threshold", then re-set the liveness. This enables a liquidation against a withdraw request to be\n', '        // "dragged out" if the position is very large and liquidators need time to gather funds. The griefing threshold\n', "        // is enforced so that liquidations for trivially small # of tokens cannot drag out an honest sponsor's slow withdrawal.\n", '\n', '        // We arbitrarily set the "griefing threshold" to `minSponsorTokens` because it is the only parameter\n', '        // denominated in token currency units and we can avoid adding another parameter.\n', '        FixedPoint.Unsigned memory griefingThreshold = minSponsorTokens;\n', '        if (\n', '            positionToLiquidate.withdrawalRequestPassTimestamp > 0 && // The position is undergoing a slow withdrawal.\n', '            positionToLiquidate.withdrawalRequestPassTimestamp <= getCurrentTime() && // The slow withdrawal has not yet expired.\n', '            tokensLiquidated.isGreaterThanOrEqual(griefingThreshold) // The liquidated token count is above a "griefing threshold".\n', '        ) {\n', '            positionToLiquidate.withdrawalRequestPassTimestamp = getCurrentTime().add(liquidationLiveness);\n', '        }\n', '\n', '        emit LiquidationCreated(\n', '            sponsor,\n', '            msg.sender,\n', '            liquidationId,\n', '            tokensLiquidated.rawValue,\n', '            lockedCollateral.rawValue,\n', '            liquidatedCollateral.rawValue,\n', '            getCurrentTime()\n', '        );\n', '\n', '        // Destroy tokens\n', '        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensLiquidated.rawValue);\n', '        tokenCurrency.burn(tokensLiquidated.rawValue);\n', '\n', '        // Pull final fee from liquidator.\n', '        collateralCurrency.safeTransferFrom(msg.sender, address(this), finalFeeBond.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice Disputes a liquidation, if the caller has enough collateral to post a dispute bond\n', '     * and pay a fixed final fee charged on each price request.\n', '     * @dev Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.\n', '     * This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute\n', '     * bond amount is calculated from `disputeBondPct` times the collateral in the liquidation.\n', '     * @param liquidationId of the disputed liquidation.\n', '     * @param sponsor the address of the sponsor whose liquidation is being disputed.\n', '     * @return totalPaid amount of collateral charged to disputer (i.e. final fee bond + dispute bond).\n', '     */\n', '    function dispute(uint256 liquidationId, address sponsor)\n', '        external\n', '        disputable(liquidationId, sponsor)\n', '        fees()\n', '        nonReentrant()\n', '        returns (FixedPoint.Unsigned memory totalPaid)\n', '    {\n', '        LiquidationData storage disputedLiquidation = _getLiquidationData(sponsor, liquidationId);\n', '\n', '        // Multiply by the unit collateral so the dispute bond is a percentage of the locked collateral after fees.\n', '        FixedPoint.Unsigned memory disputeBondAmount = disputedLiquidation.lockedCollateral.mul(disputeBondPct).mul(\n', '            _getFeeAdjustedCollateral(disputedLiquidation.rawUnitCollateral)\n', '        );\n', '        _addCollateral(rawLiquidationCollateral, disputeBondAmount);\n', '\n', '        // Request a price from DVM. Liquidation is pending dispute until DVM returns a price.\n', '        disputedLiquidation.state = Status.PendingDispute;\n', '        disputedLiquidation.disputer = msg.sender;\n', '\n', '        // Enqueue a request with the DVM.\n', '        _requestOraclePrice(disputedLiquidation.liquidationTime);\n', '\n', '        emit LiquidationDisputed(\n', '            sponsor,\n', '            disputedLiquidation.liquidator,\n', '            msg.sender,\n', '            liquidationId,\n', '            disputeBondAmount.rawValue\n', '        );\n', '        totalPaid = disputeBondAmount.add(disputedLiquidation.finalFee);\n', '\n', '        // Pay the final fee for requesting price from the DVM.\n', '        _payFinalFees(msg.sender, disputedLiquidation.finalFee);\n', '\n', '        // Transfer the dispute bond amount from the caller to this contract.\n', '        collateralCurrency.safeTransferFrom(msg.sender, address(this), disputeBondAmount.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice After a dispute has settled or after a non-disputed liquidation has expired,\n', '     * the sponsor, liquidator, and/or disputer can call this method to receive payments.\n', '     * @dev If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment.\n', '     * If the dispute FAILED: only the liquidator can receive payment.\n', '     * Once all collateral is withdrawn, delete the liquidation data.\n', "     * @param liquidationId uniquely identifies the sponsor's liquidation.\n", '     * @param sponsor address of the sponsor associated with the liquidation.\n', '     * @return amountWithdrawn the total amount of underlying returned from the liquidation.\n', '     */\n', '    function withdrawLiquidation(uint256 liquidationId, address sponsor)\n', '        public\n', '        withdrawable(liquidationId, sponsor)\n', '        fees()\n', '        nonReentrant()\n', '        returns (FixedPoint.Unsigned memory amountWithdrawn)\n', '    {\n', '        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n', '        require(\n', '            (msg.sender == liquidation.disputer) ||\n', '                (msg.sender == liquidation.liquidator) ||\n', '                (msg.sender == liquidation.sponsor),\n', '            "Caller cannot withdraw rewards"\n', '        );\n', '\n', '        // Settles the liquidation if necessary. This call will revert if the price has not resolved yet.\n', '        _settle(liquidationId, sponsor);\n', '\n', '        // Calculate rewards as a function of the TRV.\n', '        // Note: all payouts are scaled by the unit collateral value so all payouts are charged the fees pro rata.\n', '        FixedPoint.Unsigned memory feeAttenuation = _getFeeAdjustedCollateral(liquidation.rawUnitCollateral);\n', '        FixedPoint.Unsigned memory settlementPrice = liquidation.settlementPrice;\n', '        FixedPoint.Unsigned memory tokenRedemptionValue = liquidation.tokensOutstanding.mul(settlementPrice).mul(\n', '            feeAttenuation\n', '        );\n', '        FixedPoint.Unsigned memory collateral = liquidation.lockedCollateral.mul(feeAttenuation);\n', '        FixedPoint.Unsigned memory disputerDisputeReward = disputerDisputeRewardPct.mul(tokenRedemptionValue);\n', '        FixedPoint.Unsigned memory sponsorDisputeReward = sponsorDisputeRewardPct.mul(tokenRedemptionValue);\n', '        FixedPoint.Unsigned memory disputeBondAmount = collateral.mul(disputeBondPct);\n', '        FixedPoint.Unsigned memory finalFee = liquidation.finalFee.mul(feeAttenuation);\n', '\n', '        // There are three main outcome states: either the dispute succeeded, failed or was not updated.\n', '        // Based on the state, different parties of a liquidation can withdraw different amounts.\n', '        // Once a caller has been paid their address deleted from the struct.\n', '        // This prevents them from being paid multiple from times the same liquidation.\n', '        FixedPoint.Unsigned memory withdrawalAmount = FixedPoint.fromUnscaledUint(0);\n', '        if (liquidation.state == Status.DisputeSucceeded) {\n', '            // If the dispute is successful then all three users can withdraw from the contract.\n', '            if (msg.sender == liquidation.disputer) {\n', '                // Pay DISPUTER: disputer reward + dispute bond + returned final fee\n', '                FixedPoint.Unsigned memory payToDisputer = disputerDisputeReward.add(disputeBondAmount).add(finalFee);\n', '                withdrawalAmount = withdrawalAmount.add(payToDisputer);\n', '                delete liquidation.disputer;\n', '            }\n', '\n', '            if (msg.sender == liquidation.sponsor) {\n', '                // Pay SPONSOR: remaining collateral (collateral - TRV) + sponsor reward\n', '                FixedPoint.Unsigned memory remainingCollateral = collateral.sub(tokenRedemptionValue);\n', '                FixedPoint.Unsigned memory payToSponsor = sponsorDisputeReward.add(remainingCollateral);\n', '                withdrawalAmount = withdrawalAmount.add(payToSponsor);\n', '                delete liquidation.sponsor;\n', '            }\n', '\n', '            if (msg.sender == liquidation.liquidator) {\n', '                // Pay LIQUIDATOR: TRV - dispute reward - sponsor reward\n', '                // If TRV > Collateral, then subtract rewards from collateral\n', '                // NOTE: This should never be below zero since we prevent (sponsorDisputePct+disputerDisputePct) >= 0 in\n', '                // the constructor when these params are set.\n', '                FixedPoint.Unsigned memory payToLiquidator = tokenRedemptionValue.sub(sponsorDisputeReward).sub(\n', '                    disputerDisputeReward\n', '                );\n', '                withdrawalAmount = withdrawalAmount.add(payToLiquidator);\n', '                delete liquidation.liquidator;\n', '            }\n', '\n', '            // Free up space once all collateral is withdrawn by removing the liquidation object from the array.\n', '            if (\n', '                liquidation.disputer == address(0) &&\n', '                liquidation.sponsor == address(0) &&\n', '                liquidation.liquidator == address(0)\n', '            ) {\n', '                delete liquidations[sponsor][liquidationId];\n', '            }\n', '            // In the case of a failed dispute only the liquidator can withdraw.\n', '        } else if (liquidation.state == Status.DisputeFailed && msg.sender == liquidation.liquidator) {\n', '            // Pay LIQUIDATOR: collateral + dispute bond + returned final fee\n', '            withdrawalAmount = collateral.add(disputeBondAmount).add(finalFee);\n', '            delete liquidations[sponsor][liquidationId];\n', '            // If the state is pre-dispute but time has passed liveness then there was no dispute. We represent this\n', '            // state as a dispute failed and the liquidator can withdraw.\n', '        } else if (liquidation.state == Status.PreDispute && msg.sender == liquidation.liquidator) {\n', '            // Pay LIQUIDATOR: collateral + returned final fee\n', '            withdrawalAmount = collateral.add(finalFee);\n', '            delete liquidations[sponsor][liquidationId];\n', '        }\n', '        require(withdrawalAmount.isGreaterThan(0), "Invalid withdrawal amount");\n', '\n', '        // Decrease the total collateral held in liquidatable by the amount withdrawn.\n', '        amountWithdrawn = _removeCollateral(rawLiquidationCollateral, withdrawalAmount);\n', '\n', '        emit LiquidationWithdrawn(msg.sender, amountWithdrawn.rawValue, liquidation.state, settlementPrice.rawValue);\n', '\n', '        // Transfer amount withdrawn from this contract to the caller.\n', '        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n', '\n', '        return amountWithdrawn;\n', '    }\n', '\n', '    /**\n', '     * @notice Gets all liquidation information for a given sponsor address.\n', '     * @param sponsor address of the position sponsor.\n', '     * @return liquidationData array of all liquidation information for the given sponsor address.\n', '     */\n', '    function getLiquidations(address sponsor)\n', '        external\n', '        view\n', '        nonReentrantView()\n', '        returns (LiquidationData[] memory liquidationData)\n', '    {\n', '        return liquidations[sponsor];\n', '    }\n', '\n', '    /****************************************\n', '     *          INTERNAL FUNCTIONS          *\n', '     ****************************************/\n', '\n', '    // This settles a liquidation if it is in the PendingDispute state. If not, it will immediately return.\n', '    // If the liquidation is in the PendingDispute state, but a price is not available, this will revert.\n', '    function _settle(uint256 liquidationId, address sponsor) internal {\n', '        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n', '\n', '        // Settlement only happens when state == PendingDispute and will only happen once per liquidation.\n', '        // If this liquidation is not ready to be settled, this method should return immediately.\n', '        if (liquidation.state != Status.PendingDispute) {\n', '            return;\n', '        }\n', '\n', '        // Get the returned price from the oracle. If this has not yet resolved will revert.\n', '        liquidation.settlementPrice = _getOraclePrice(liquidation.liquidationTime);\n', '\n', '        // Find the value of the tokens in the underlying collateral.\n', '        FixedPoint.Unsigned memory tokenRedemptionValue = liquidation.tokensOutstanding.mul(\n', '            liquidation.settlementPrice\n', '        );\n', '\n', '        // The required collateral is the value of the tokens in underlying * required collateral ratio.\n', '        FixedPoint.Unsigned memory requiredCollateral = tokenRedemptionValue.mul(collateralRequirement);\n', '\n', '        // If the position has more than the required collateral it is solvent and the dispute is valid(liquidation is invalid)\n', '        // Note that this check uses the liquidatedCollateral not the lockedCollateral as this considers withdrawals.\n', '        bool disputeSucceeded = liquidation.liquidatedCollateral.isGreaterThanOrEqual(requiredCollateral);\n', '        liquidation.state = disputeSucceeded ? Status.DisputeSucceeded : Status.DisputeFailed;\n', '\n', '        emit DisputeSettled(\n', '            msg.sender,\n', '            sponsor,\n', '            liquidation.liquidator,\n', '            liquidation.disputer,\n', '            liquidationId,\n', '            disputeSucceeded\n', '        );\n', '    }\n', '\n', '    function _pfc() internal override view returns (FixedPoint.Unsigned memory) {\n', '        return super._pfc().add(_getFeeAdjustedCollateral(rawLiquidationCollateral));\n', '    }\n', '\n', '    function _getLiquidationData(address sponsor, uint256 liquidationId)\n', '        internal\n', '        view\n', '        returns (LiquidationData storage liquidation)\n', '    {\n', '        LiquidationData[] storage liquidationArray = liquidations[sponsor];\n', '\n', '        // Revert if the caller is attempting to access an invalid liquidation\n', '        // (one that has never been created or one has never been initialized).\n', '        require(\n', '            liquidationId < liquidationArray.length && liquidationArray[liquidationId].state != Status.Uninitialized,\n', '            "Invalid liquidation ID"\n', '        );\n', '        return liquidationArray[liquidationId];\n', '    }\n', '\n', '    function _getLiquidationExpiry(LiquidationData storage liquidation) internal view returns (uint256) {\n', '        return liquidation.liquidationTime.add(liquidationLiveness);\n', '    }\n', '\n', '    // These internal functions are supposed to act identically to modifiers, but re-used modifiers\n', '    // unnecessarily increase contract bytecode size.\n', '    // source: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6\n', '    function _disputable(uint256 liquidationId, address sponsor) internal view {\n', '        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n', '        require(\n', '            (getCurrentTime() < _getLiquidationExpiry(liquidation)) && (liquidation.state == Status.PreDispute),\n', '            "Liquidation not disputable"\n', '        );\n', '    }\n', '\n', '    function _withdrawable(uint256 liquidationId, address sponsor) internal view {\n', '        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n', '        Status state = liquidation.state;\n', '\n', '        // Must be disputed or the liquidation has passed expiry.\n', '        require(\n', '            (state > Status.PreDispute) ||\n', '                ((_getLiquidationExpiry(liquidation) <= getCurrentTime()) && (state == Status.PreDispute)),\n', '            "Liquidation not withdrawable"\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/financial-templates/expiring-multiparty/ExpiringMultiParty.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title Expiring Multi Party.\n', ' * @notice Convenient wrapper for Liquidatable.\n', ' */\n', 'contract ExpiringMultiParty is Liquidatable {\n', '    /**\n', '     * @notice Constructs the ExpiringMultiParty contract.\n', '     * @param params struct to define input parameters for construction of Liquidatable. Some params\n', "     * are fed directly into the PricelessPositionManager's constructor within the inheritance tree.\n", '     */\n', '    constructor(ConstructorParams memory params)\n', '        public\n', '        Liquidatable(params)\n', '    // Note: since there is no logic here, there is no need to add a re-entrancy guard.\n', '    {\n', '\n', '    }\n', '}\n', '\n', '// File: contracts/financial-templates/expiring-multiparty/ExpiringMultiPartyLib.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title Provides convenient Expiring Multi Party contract utilities.\n', " * @dev Using this library to deploy EMP's allows calling contracts to avoid importing the full EMP bytecode.\n", ' */\n', 'library ExpiringMultiPartyLib {\n', '    /**\n', '     * @notice Returns address of new EMP deployed with given `params` configuration.\n', '     * @dev Caller will need to register new EMP with the Registry to begin requesting prices. Caller is also\n', '     * responsible for enforcing constraints on `params`.\n', '     * @param params is a `ConstructorParams` object from ExpiringMultiParty.\n', '     * @return address of the deployed ExpiringMultiParty contract\n', '     */\n', '    function deploy(ExpiringMultiParty.ConstructorParams memory params) public returns (address) {\n', '        ExpiringMultiParty derivative = new ExpiringMultiParty(params);\n', '        return address(derivative);\n', '    }\n', '}\n', '\n', '// File: contracts/financial-templates/expiring-multiparty/ExpiringMultiPartyCreator.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Expiring Multi Party Contract creator.\n', ' * @notice Factory contract to create and register new instances of expiring multiparty contracts.\n', ' * Responsible for constraining the parameters used to construct a new EMP. This creator contains a number of constraints\n', ' * that are applied to newly created expiring multi party contract. These constraints can evolve over time and are\n', ' * initially constrained to conservative values in this first iteration. Technically there is nothing in the\n', ' * ExpiringMultiParty contract requiring these constraints. However, because `createExpiringMultiParty()` is intended\n', ' * to be the only way to create valid financial contracts that are registered with the DVM (via _registerContract),\n', '  we can enforce deployment configurations here.\n', ' */\n', 'contract ExpiringMultiPartyCreator is ContractCreator, Testable, Lockable {\n', '    using FixedPoint for FixedPoint.Unsigned;\n', '\n', '    /****************************************\n', '     *     EMP CREATOR DATA STRUCTURES      *\n', '     ****************************************/\n', '\n', '    struct Params {\n', '        uint256 expirationTimestamp;\n', '        address collateralAddress;\n', '        bytes32 priceFeedIdentifier;\n', '        string syntheticName;\n', '        string syntheticSymbol;\n', '        FixedPoint.Unsigned collateralRequirement;\n', '        FixedPoint.Unsigned disputeBondPct;\n', '        FixedPoint.Unsigned sponsorDisputeRewardPct;\n', '        FixedPoint.Unsigned disputerDisputeRewardPct;\n', '        FixedPoint.Unsigned minSponsorTokens;\n', '        uint256 withdrawalLiveness;\n', '        uint256 liquidationLiveness;\n', '        address excessTokenBeneficiary;\n', '    }\n', '    // - Address of TokenFactory to pass into newly constructed ExpiringMultiParty contracts\n', '    address public tokenFactoryAddress;\n', '\n', '    event CreatedExpiringMultiParty(address indexed expiringMultiPartyAddress, address indexed deployerAddress);\n', '\n', '    /**\n', '     * @notice Constructs the ExpiringMultiPartyCreator contract.\n', '     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\n', '     * @param _tokenFactoryAddress ERC20 token factory used to deploy synthetic token instances.\n', '     * @param _timerAddress Contract that stores the current time in a testing environment.\n', '     */\n', '    constructor(\n', '        address _finderAddress,\n', '        address _tokenFactoryAddress,\n', '        address _timerAddress\n', '    ) public ContractCreator(_finderAddress) Testable(_timerAddress) nonReentrant() {\n', '        tokenFactoryAddress = _tokenFactoryAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Creates an instance of expiring multi party and registers it within the registry.\n', '     * @param params is a `ConstructorParams` object from ExpiringMultiParty.\n', '     * @return address of the deployed ExpiringMultiParty contract.\n', '     */\n', '    function createExpiringMultiParty(Params memory params) public nonReentrant() returns (address) {\n', '        address derivative = ExpiringMultiPartyLib.deploy(_convertParams(params));\n', '\n', '        _registerContract(new address[](0), address(derivative));\n', '\n', '        emit CreatedExpiringMultiParty(address(derivative), msg.sender);\n', '\n', '        return address(derivative);\n', '    }\n', '\n', '    /****************************************\n', '     *          PRIVATE FUNCTIONS           *\n', '     ****************************************/\n', '\n', '    // Converts createExpiringMultiParty params to ExpiringMultiParty constructor params.\n', '    function _convertParams(Params memory params)\n', '        private\n', '        view\n', '        returns (ExpiringMultiParty.ConstructorParams memory constructorParams)\n', '    {\n', '        // Known from creator deployment.\n', '        constructorParams.finderAddress = finderAddress;\n', '        constructorParams.tokenFactoryAddress = tokenFactoryAddress;\n', '        constructorParams.timerAddress = timerAddress;\n', '\n', '        // Enforce configuration constraints.\n', '        require(bytes(params.syntheticName).length != 0, "Missing synthetic name");\n', '        require(bytes(params.syntheticSymbol).length != 0, "Missing synthetic symbol");\n', '        require(params.withdrawalLiveness != 0, "Withdrawal liveness cannot be 0");\n', '        require(params.liquidationLiveness != 0, "Liquidation liveness cannot be 0");\n', '        require(params.excessTokenBeneficiary != address(0), "Token Beneficiary cannot be 0x0");\n', '        require(params.expirationTimestamp > now, "Invalid expiration time");\n', '        _requireWhitelistedCollateral(params.collateralAddress);\n', '\n', "        // We don't want EMP deployers to be able to intentionally or unintentionally set\n", "        // liveness periods that could induce arithmetic overflow, but we also don't want\n", '        // to be opinionated about what livenesses are "correct", so we will somewhat\n', '        // arbitrarily set the liveness upper bound to 100 years (5200 weeks). In practice, liveness\n', '        // periods even greater than a few days would make the EMP unusable for most users.\n', '        require(params.withdrawalLiveness < 5200 weeks, "Withdrawal liveness too large");\n', '        require(params.liquidationLiveness < 5200 weeks, "Liquidation liveness too large");\n', '\n', '        // Input from function call.\n', '        constructorParams.expirationTimestamp = params.expirationTimestamp;\n', '        constructorParams.collateralAddress = params.collateralAddress;\n', '        constructorParams.priceFeedIdentifier = params.priceFeedIdentifier;\n', '        constructorParams.syntheticName = params.syntheticName;\n', '        constructorParams.syntheticSymbol = params.syntheticSymbol;\n', '        constructorParams.collateralRequirement = params.collateralRequirement;\n', '        constructorParams.disputeBondPct = params.disputeBondPct;\n', '        constructorParams.sponsorDisputeRewardPct = params.sponsorDisputeRewardPct;\n', '        constructorParams.disputerDisputeRewardPct = params.disputerDisputeRewardPct;\n', '        constructorParams.minSponsorTokens = params.minSponsorTokens;\n', '        constructorParams.withdrawalLiveness = params.withdrawalLiveness;\n', '        constructorParams.liquidationLiveness = params.liquidationLiveness;\n', '        constructorParams.excessTokenBeneficiary = params.excessTokenBeneficiary;\n', '    }\n', '}']