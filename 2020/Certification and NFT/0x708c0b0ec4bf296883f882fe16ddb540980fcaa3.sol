['pragma solidity 0.5.17; // optimization runs: 200, evm version: istanbul\n', '// WARNING - `executeActionWithAtomicBatchCalls` has a `bytes[]` argument that\n', '// requires ABIEncoderV2. Exercise caution when calling that specific function.\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'interface DharmaSmartWalletImplementationV1Interface {\n', '  event CallSuccess(\n', '    bytes32 actionID,\n', '    bool rolledBack,\n', '    uint256 nonce,\n', '    address to,\n', '    bytes data,\n', '    bytes returnData\n', '  );\n', '\n', '  event CallFailure(\n', '    bytes32 actionID,\n', '    uint256 nonce,\n', '    address to,\n', '    bytes data,\n', '    string revertReason\n', '  );\n', '\n', '  // ABIEncoderV2 uses an array of Calls for executing generic batch calls.\n', '  struct Call {\n', '    address to;\n', '    bytes data;\n', '  }\n', '\n', '  // ABIEncoderV2 uses an array of CallReturns for handling generic batch calls.\n', '  struct CallReturn {\n', '    bool ok;\n', '    bytes returnData;\n', '  }\n', '\n', '  function withdrawEther(\n', '    uint256 amount,\n', '    address payable recipient,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external returns (bool ok);\n', '\n', '  function executeAction(\n', '    address to,\n', '    bytes calldata data,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external returns (bool ok, bytes memory returnData);\n', '\n', '  function recover(address newUserSigningKey) external;\n', '\n', '  function executeActionWithAtomicBatchCalls(\n', '    Call[] calldata calls,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external returns (bool[] memory ok, bytes[] memory returnData);\n', '\n', '  function getNextGenericActionID(\n', '    address to,\n', '    bytes calldata data,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID);\n', '\n', '  function getGenericActionID(\n', '    address to,\n', '    bytes calldata data,\n', '    uint256 nonce,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID);\n', '\n', '  function getNextGenericAtomicBatchActionID(\n', '    Call[] calldata calls,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID);\n', '\n', '  function getGenericAtomicBatchActionID(\n', '    Call[] calldata calls,\n', '    uint256 nonce,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID);\n', '}\n', '\n', '\n', 'interface DharmaSmartWalletImplementationV3Interface {\n', '  event Cancel(uint256 cancelledNonce);\n', '  event EthWithdrawal(uint256 amount, address recipient);\n', '}\n', '\n', '\n', 'interface DharmaSmartWalletImplementationV4Interface {\n', '  event Escaped();\n', '\n', '  function setEscapeHatch(\n', '    address account,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external;\n', '\n', '  function removeEscapeHatch(\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external;\n', '\n', '  function permanentlyDisableEscapeHatch(\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external;\n', '\n', '  function escape() external;\n', '}\n', '\n', '\n', 'interface DharmaSmartWalletImplementationV7Interface {\n', '  // Fires when a new user signing key is set on the smart wallet.\n', '  event NewUserSigningKey(address userSigningKey);\n', '\n', '  // Fires when an error occurs as part of an attempted action.\n', '  event ExternalError(address indexed source, string revertReason);\n', '\n', '  // The smart wallet recognizes DAI, USDC, ETH, and SAI as supported assets.\n', '  enum AssetType {\n', '    DAI,\n', '    USDC,\n', '    ETH,\n', '    SAI\n', '  }\n', '\n', '  // Actions, or protected methods (i.e. not deposits) each have an action type.\n', '  enum ActionType {\n', '    Cancel,\n', '    SetUserSigningKey,\n', '    Generic,\n', '    GenericAtomicBatch,\n', '    SAIWithdrawal,\n', '    USDCWithdrawal,\n', '    ETHWithdrawal,\n', '    SetEscapeHatch,\n', '    RemoveEscapeHatch,\n', '    DisableEscapeHatch,\n', '    DAIWithdrawal,\n', '    SignatureVerification,\n', '    TradeEthForDai,\n', '    DAIBorrow,\n', '    USDCBorrow\n', '  }\n', '\n', '  function initialize(address userSigningKey) external;\n', '\n', '  function repayAndDeposit() external;\n', '\n', '  function withdrawDai(\n', '    uint256 amount,\n', '    address recipient,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external returns (bool ok);\n', '\n', '  function withdrawUSDC(\n', '    uint256 amount,\n', '    address recipient,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external returns (bool ok);\n', '\n', '  function cancel(\n', '    uint256 minimumActionGas,\n', '    bytes calldata signature\n', '  ) external;\n', '\n', '  function setUserSigningKey(\n', '    address userSigningKey,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external;\n', '\n', '  function migrateSaiToDai() external;\n', '\n', '  function migrateCSaiToDDai() external;\n', '\n', '  function migrateCDaiToDDai() external;\n', '\n', '  function migrateCUSDCToDUSDC() external;\n', '\n', '  function getBalances() external view returns (\n', '    uint256 daiBalance,\n', '    uint256 usdcBalance,\n', '    uint256 etherBalance,\n', '    uint256 dDaiUnderlyingDaiBalance,\n', '    uint256 dUsdcUnderlyingUsdcBalance,\n', '    uint256 dEtherUnderlyingEtherBalance // always returns zero\n', '  );\n', '\n', '  function getUserSigningKey() external view returns (address userSigningKey);\n', '\n', '  function getNonce() external view returns (uint256 nonce);\n', '\n', '  function getNextCustomActionID(\n', '    ActionType action,\n', '    uint256 amount,\n', '    address recipient,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID);\n', '\n', '  function getCustomActionID(\n', '    ActionType action,\n', '    uint256 amount,\n', '    address recipient,\n', '    uint256 nonce,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID);\n', '\n', '  function getVersion() external pure returns (uint256 version);\n', '}\n', '\n', '\n', 'interface DharmaSmartWalletImplementationV8Interface {\n', '  function tradeEthForDaiAndMintDDai(\n', '    uint256 ethToSupply,\n', '    uint256 minimumDaiReceived,\n', '    address target,\n', '    bytes calldata data,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external returns (bool ok, bytes memory returnData);\n', '\n', '  function getNextEthForDaiActionID(\n', '    uint256 ethToSupply,\n', '    uint256 minimumDaiReceived,\n', '    address target,\n', '    bytes calldata data,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID);\n', '\n', '  function getEthForDaiActionID(\n', '    uint256 ethToSupply,\n', '    uint256 minimumDaiReceived,\n', '    address target,\n', '    bytes calldata data,\n', '    uint256 nonce,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID);\n', '}\n', '\n', '\n', 'interface DharmaSmartWalletImplementationV12Interface {\n', '  function setApproval(address token, uint256 amount) external;\n', '}\n', '\n', '\n', 'interface ERC20Interface {\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '  function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '  function balanceOf(address account) external view returns (uint256);\n', '  function allowance(\n', '    address owner, address spender\n', '  ) external view returns (uint256);\n', '}\n', '\n', '\n', 'interface ERC1271Interface {\n', '  function isValidSignature(\n', '    bytes calldata data, bytes calldata signature\n', '  ) external view returns (bytes4 magicValue);\n', '}\n', '\n', '\n', 'interface CTokenInterface {\n', '  function redeem(uint256 redeemAmount) external returns (uint256 err);\n', '  function transfer(address recipient, uint256 value) external returns (bool);\n', '  function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '  function balanceOf(address account) external view returns (uint256 balance);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '}\n', '\n', '\n', 'interface DTokenInterface {\n', '  // These external functions trigger accrual on the dToken and backing cToken.\n', '  function mint(uint256 underlyingToSupply) external returns (uint256 dTokensMinted);\n', '  function redeem(uint256 dTokensToBurn) external returns (uint256 underlyingReceived);\n', '  function redeemUnderlying(uint256 underlyingToReceive) external returns (uint256 dTokensBurned);\n', '\n', '  // These external functions only trigger accrual on the dToken.\n', '  function mintViaCToken(uint256 cTokensToSupply) external returns (uint256 dTokensMinted);\n', '\n', '  // View and pure functions do not trigger accrual on the dToken or the cToken.\n', '  function balanceOfUnderlying(address account) external view returns (uint256 underlyingBalance);\n', '}\n', '\n', '\n', 'interface USDCV1Interface {\n', '  function isBlacklisted(address _account) external view returns (bool);\n', '  function paused() external view returns (bool);\n', '}\n', '\n', '\n', 'interface DharmaKeyRegistryInterface {\n', '  function getKey() external view returns (address key);\n', '}\n', '\n', '\n', 'interface DharmaEscapeHatchRegistryInterface {\n', '  function setEscapeHatch(address newEscapeHatch) external;\n', '\n', '  function removeEscapeHatch() external;\n', '\n', '  function permanentlyDisableEscapeHatch() external;\n', '\n', '  function getEscapeHatch() external view returns (\n', '    bool exists, address escapeHatch\n', '  );\n', '}\n', '\n', '\n', 'interface TradeHelperInterface {\n', '  function tradeEthForDai(\n', '    uint256 daiExpected, address target, bytes calldata data\n', '  ) external payable returns (uint256 daiReceived);\n', '}\n', '\n', '\n', 'interface RevertReasonHelperInterface {\n', '  function reason(uint256 code) external pure returns (string memory);\n', '}\n', '\n', '\n', 'interface EtherizedInterface {\n', '  function triggerEtherTransfer(\n', '    address payable target, uint256 value\n', '  ) external returns (bool success);\n', '}\n', '\n', '\n', 'interface DharmaDaiExchangerInterface {\n', '  function mintTo(\n', '    address account, uint256 daiToSupply\n', '  ) external returns (uint256 dDaiMinted);\n', '  function redeemUnderlyingTo(\n', '    address account, uint256 daiToReceive\n', '  ) external returns (uint256 dDaiBurned);\n', '}\n', '\n', '\n', 'interface ConfigurationRegistryInterface {\n', '  function get(bytes32 key) external view returns (bytes32 value);\n', '}\n', '\n', '\n', 'library Address {\n', '  function isContract(address account) internal view returns (bool) {\n', '    uint256 size;\n', '    assembly { size := extcodesize(account) }\n', '    return size > 0;\n', '  }\n', '}\n', '\n', '\n', 'library ECDSA {\n', '  function recover(\n', '    bytes32 hash, bytes memory signature\n', '  ) internal pure returns (address) {\n', '    if (signature.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    assembly {\n', '      r := mload(add(signature, 0x20))\n', '      s := mload(add(signature, 0x40))\n', '      v := byte(0, mload(add(signature, 0x60)))\n', '    }\n', '\n', '    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n', '      return address(0);\n', '    }\n', '\n', '    if (v != 27 && v != 28) {\n', '      return address(0);\n', '    }\n', '\n', '    return ecrecover(hash, v, r, s);\n', '  }\n', '\n', '  function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n', '    return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '  }\n', '}\n', '\n', '\n', 'contract Etherized is EtherizedInterface {\n', '  address private constant _ETHERIZER = address(\n', '    0x723B51b72Ae89A3d0c2a2760f0458307a1Baa191 \n', '  );\n', '  \n', '  function triggerEtherTransfer(\n', '    address payable target, uint256 amount\n', '  ) external returns (bool success) {\n', '    require(msg.sender == _ETHERIZER, "Etherized: only callable by Etherizer");\n', '    (success, ) = target.call.value(amount)("");\n', '    if (!success) {\n', '      assembly {\n', '        returndatacopy(0, 0, returndatasize())\n', '        revert(0, returndatasize())\n', '      }\n', '    }\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title DharmaSmartWalletImplementationV12 (staging version)\n', ' * @author 0age\n', ' * @notice The V12 implementation for the Dharma smart wallet is a non-custodial,\n', ' * meta-transaction-enabled wallet with helper functions to facilitate lending\n', ' * funds through Dharma Dai and Dharma USD Coin (which in turn use CompoundV2),\n', ' * and with an added security backstop provided by Dharma Labs prior to making\n', ' * withdrawals. It adds support for Dharma Dai and Dharma USD Coin - they employ\n', ' * the respective cTokens as backing tokens and mint and redeem them internally\n', ' * as interest-bearing collateral. This implementation also contains methods to\n', ' * support account recovery, escape hatch functionality, and generic actions,\n', ' * including in an atomic batch. The smart wallet instances utilizing this\n', ' * implementation are deployed through the Dharma Smart Wallet Factory via\n', ' * `CREATE2`, which allows for their address to be known ahead of time, and any\n', ' * Dai or USDC that has already been sent into that address will automatically\n', ' * be deposited into the respective Dharma Token upon deployment of the new\n', ' * smart wallet instance. V12 uses the dai <> dDai exchanger to save gas when\n', ' * minting and redeeming dDai, and adds support for limit orders using the new\n', ' * BotCommanderV2 contract.\n', ' */\n', 'contract DharmaSmartWalletImplementationV12Staging is\n', '  DharmaSmartWalletImplementationV1Interface,\n', '  DharmaSmartWalletImplementationV3Interface,\n', '  DharmaSmartWalletImplementationV4Interface,\n', '  DharmaSmartWalletImplementationV7Interface,\n', '  DharmaSmartWalletImplementationV8Interface,\n', '  DharmaSmartWalletImplementationV12Interface,\n', '  ERC1271Interface,\n', '  Etherized {\n', '  using Address for address;\n', '  using ECDSA for bytes32;\n', '  // WARNING: DO NOT REMOVE OR REORDER STORAGE WHEN WRITING NEW IMPLEMENTATIONS!\n', '\n', '  // The user signing key associated with this account is in storage slot 0.\n', '  // It is the core differentiator when it comes to the account in question.\n', '  address private _userSigningKey;\n', '\n', '  // The nonce associated with this account is in storage slot 1. Every time a\n', '  // signature is submitted, it must have the appropriate nonce, and once it has\n', '  // been accepted the nonce will be incremented.\n', '  uint256 private _nonce;\n', '\n', '  // The self-call context flag is in storage slot 2. Some protected functions\n', '  // may only be called externally from calls originating from other methods on\n', '  // this contract, which enables appropriate exception handling on reverts.\n', '  // Any storage should only be set immediately preceding a self-call and should\n', '  // be cleared upon entering the protected function being called.\n', '  bytes4 internal _selfCallContext;\n', '\n', '  // END STORAGE DECLARATIONS - DO NOT REMOVE OR REORDER STORAGE ABOVE HERE!\n', '\n', '  // The smart wallet version will be used when constructing valid signatures.\n', '  uint256 internal constant _DHARMA_SMART_WALLET_VERSION = 1012;\n', '\n', '  // DharmaKeyRegistryV2Staging holds a public key to verify meta-transactions.\n', '  DharmaKeyRegistryInterface internal constant _DHARMA_KEY_REGISTRY = (\n', '    DharmaKeyRegistryInterface(0x00000000006c7f32F0cD1eA4C1383558eb68802D)\n', '  );\n', '  // Account recovery uses a hard-coded staging version of the recovery manager.\n', '  address internal constant _ACCOUNT_RECOVERY_MANAGER = address(\n', '    0x2a7E7718b755F9868E6B64DD18C6886707DD9c10\n', '  );\n', '\n', '  // Users can designate an "escape hatch" account with the ability to sweep all\n', '  // funds from their smart wallet by using the Dharma Escape Hatch Registry.\n', '  DharmaEscapeHatchRegistryInterface internal constant _ESCAPE_HATCH_REGISTRY = (\n', '    DharmaEscapeHatchRegistryInterface(0x00000000005280B515004B998a944630B6C663f8)\n', '  );\n', '\n', '  // Interface with dDai, dUSDC, Dai, USDC, Sai, cSai, cDai, cUSDC, & migrator.\n', '  DTokenInterface internal constant _DDAI = DTokenInterface(\n', '    0x00000000001876eB1444c986fD502e618c587430 // mainnet\n', '  );\n', '\n', '  DTokenInterface internal constant _DUSDC = DTokenInterface(\n', '    0x00000000008943c65cAf789FFFCF953bE156f6f8 // mainnet\n', '  );\n', '\n', '  ERC20Interface internal constant _DAI = ERC20Interface(\n', '    0x6B175474E89094C44Da98b954EedeAC495271d0F // mainnet\n', '  );\n', '\n', '  ERC20Interface internal constant _USDC = ERC20Interface(\n', '    0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 // mainnet\n', '  );\n', '\n', '  CTokenInterface internal constant _CDAI = CTokenInterface(\n', '    0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643 // mainnet\n', '  );\n', '\n', '  CTokenInterface internal constant _CUSDC = CTokenInterface(\n', '    0x39AA39c021dfbaE8faC545936693aC917d5E7563 // mainnet\n', '  );\n', '  \n', '  // The "trade helper" facilitates Eth-to-Dai trades in an isolated context.\n', '  TradeHelperInterface internal constant _TRADE_HELPER = TradeHelperInterface(\n', '    0x421816CDFe2073945173c0c35799ec21261fB399\n', '  );\n', '\n', '  // The "exchanger" facilitates cheaper minting and redeeming for Dharma Dai.\n', '  DharmaDaiExchangerInterface internal constant _DDAI_EXCHANGER = (\n', '    DharmaDaiExchangerInterface(\n', '      0x83E02F0b169be417C38d1216fc2a5134C48Af44a\n', '    )\n', '  );\n', '\n', '  // The "revert reason helper" contains a collection of revert reason strings.\n', '  RevertReasonHelperInterface internal constant _REVERT_REASON_HELPER = (\n', '    RevertReasonHelperInterface(0x9C0ccB765D3f5035f8b5Dd30fE375d5F4997D8E4)\n', '  );\n', '  \n', '  ConfigurationRegistryInterface internal constant _CONFIG_REGISTRY = (\n', '    ConfigurationRegistryInterface(0xC5C0ead7Df3CeFC45c8F4592E3a0f1500949E75D)\n', '  );\n', '  \n', '  // The "Bot Commander" enables limit orders using unordered meta-transactions.\n', '  address internal constant _BOT_COMMANDER = address(\n', '    0x0f36f2DA9F935a7802a4f1Af43A3740A73219A9e\n', '  );\n', '  \n', '  bytes32 internal constant _ENABLE_USDC_MINTING_KEY = bytes32(\n', '    0x596746115f08448433597980d42b4541c0197187d07ffad9c7f66a471c49dbba\n', '  ); // keccak256("allowAvailableUSDCToBeUsedToMintCUSDC")\n', '\n', '  // Compound returns a value of 0 to indicate success, or lack of an error.\n', '  uint256 internal constant _COMPOUND_SUCCESS = 0;\n', '\n', '  // ERC-1271 must return this magic value when `isValidSignature` is called.\n', '  bytes4 internal constant _ERC_1271_MAGIC_VALUE = bytes4(0x20c13b0b);\n', '\n', '  // Minimum supported deposit & non-maximum withdrawal size is .001 underlying.\n', '  uint256 private constant _JUST_UNDER_ONE_1000th_DAI = 999999999999999;\n', '  uint256 private constant _JUST_UNDER_ONE_1000th_USDC = 999;\n', '\n', '  // Specify the amount of gas to supply when making Ether transfers.\n', '  uint256 private constant _ETH_TRANSFER_GAS = 4999;\n', '  \n', '  constructor() public {\n', '    assert(\n', '      _ENABLE_USDC_MINTING_KEY == keccak256(\n', '        bytes("allowAvailableUSDCToBeUsedToMintCUSDC")\n', '      )\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Accept Ether in the fallback.\n', '   */\n', '  function () external payable {}\n', '\n', '  /**\n', '   * @notice In the initializer, set up the initial user signing key, set\n', '   * approval on the Dharma Dai and Dharma USD Coin contracts, and deposit any\n', '   * Dai or USDC already at this address to receive dDai or dUSDC. Note that\n', '   * this initializer is only callable while the smart wallet instance is still\n', '   * in the contract creation phase.\n', '   * @param userSigningKey address The initial user signing key for the smart\n', '   * wallet.\n', '   */\n', '  function initialize(address userSigningKey) external {\n', '    // Ensure that this function is only callable during contract construction.\n', '    assembly { if extcodesize(address) { revert(0, 0) } }\n', '\n', "    // Set up the user's signing key and emit a corresponding event.\n", '    _setUserSigningKey(userSigningKey);\n', '\n', '    // Approve the dDai contract to transfer Dai on behalf of this contract.\n', '    if (_setFullApproval(AssetType.DAI)) {\n', '      // Get the current Dai balance on this contract.\n', '      uint256 daiBalance = _DAI.balanceOf(address(this));\n', '\n', '      // Try to deposit the full Dai balance to Dharma Dai.\n', '      _depositDharmaToken(AssetType.DAI, daiBalance);\n', '    }\n', '\n', '    // Approve the dUSDC contract to transfer USDC on behalf of this contract.\n', '    if (_setFullApproval(AssetType.USDC)) {\n', '      // Get the current USDC balance on this contract.\n', '      uint256 usdcBalance = _USDC.balanceOf(address(this));\n', '\n', '      // Try to deposit the full Dai balance to Dharma USDC.\n', '      _depositDharmaToken(AssetType.USDC, usdcBalance);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Deposit all Dai and USDC currently residing at this address and\n', '   * receive Dharma Dai or Dharma USD Coin in return. Note that "repay" is not\n', '   * currently implemented, though it may be in a future implementation. If some\n', '   * step of this function fails, the function itself will still succeed, but an\n', '   * `ExternalError` with information on what went wrong will be emitted.\n', '   */\n', '  function repayAndDeposit() external {\n', '    // Get the current Dai balance on this contract.\n', '    uint256 daiBalance = _DAI.balanceOf(address(this));\n', '\n', '    // If there is any Dai balance, check for adequate approval for dDai.\n', '    if (daiBalance > 0) {\n', '      uint256 daiAllowance = _DAI.allowance(address(this), address(_DDAI_EXCHANGER));\n', '      // If allowance is insufficient, try to set it before depositing.\n', '      if (daiAllowance < daiBalance) {\n', '        if (_setFullApproval(AssetType.DAI)) {\n', '          // Deposit the full available Dai balance to Dharma Dai.\n', '          _depositDharmaToken(AssetType.DAI, daiBalance);\n', '        }\n', '      // Otherwise, just go ahead and try the Dai deposit.\n', '      } else {\n', '        // Deposit the full available Dai balance to Dharma Dai.\n', '        _depositDharmaToken(AssetType.DAI, daiBalance);\n', '      }\n', '    }\n', '\n', '    // Get the current USDC balance on this contract.\n', '    uint256 usdcBalance = _USDC.balanceOf(address(this));\n', '\n', '    // If there is any USDC balance, check for adequate approval for dUSDC.\n', '    if (usdcBalance > 0) {\n', '      uint256 usdcAllowance = _USDC.allowance(address(this), address(_DUSDC));\n', '      // If allowance is insufficient, try to set it before depositing.\n', '      if (usdcAllowance < usdcBalance) {\n', '        if (_setFullApproval(AssetType.USDC)) {\n', '          // Deposit the full available USDC balance to Dharma USDC.\n', '          _depositDharmaToken(AssetType.USDC, usdcBalance);\n', '        }\n', '      // Otherwise, just go ahead and try the USDC deposit.\n', '      } else {\n', '        // Deposit the full available USDC balance to Dharma USDC.\n', '        _depositDharmaToken(AssetType.USDC, usdcBalance);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Withdraw Dai to a provided recipient address by redeeming the\n', '   * underlying Dai from the dDai contract and transferring it to the recipient.\n', '   * All Dai in Dharma Dai and in the smart wallet itself can be withdrawn by\n', '   * providing an amount of uint256(-1) or 0xfff...fff. This function can be\n', '   * called directly by the account set as the global key on the Dharma Key\n', '   * Registry, or by any relayer that provides a signed message from the same\n', '   * keyholder. The nonce used for the signature must match the current nonce on\n', '   * the smart wallet, and gas supplied to the call must exceed the specified\n', '   * minimum action gas, plus the gas that will be spent before the gas check is\n', '   * reached - usually somewhere around 25,000 gas. If the withdrawal fails, an\n', '   * `ExternalError` with additional details on what went wrong will be emitted.\n', '   * Note that some dust may still be left over, even in the event of a max\n', '   * withdrawal, due to the fact that Dai has a higher precision than dDai. Also\n', '   * note that the withdrawal will fail in the event that Compound does not have\n', '   * sufficient Dai available to withdraw.\n', '   * @param amount uint256 The amount of Dai to withdraw.\n', '   * @param recipient address The account to transfer the withdrawn Dai to.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param userSignature bytes A signature that resolves to the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`. If the user\n', '   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\n', '   * will be used. A unique hash returned from `getCustomActionID` is prefixed\n', '   * and hashed to create the message hash for the signature.\n', '   * @param dharmaSignature bytes A signature that resolves to the public key\n', '   * returned for this account from the Dharma Key Registry. A unique hash\n', '   * returned from `getCustomActionID` is prefixed and hashed to create the\n', '   * signed message.\n', '   * @return True if the withdrawal succeeded, otherwise false.\n', '   */\n', '  function withdrawDai(\n', '    uint256 amount,\n', '    address recipient,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external returns (bool ok) {\n', '    // Ensure caller and/or supplied signatures are valid and increment nonce.\n', '    _validateActionAndIncrementNonce(\n', '      ActionType.DAIWithdrawal,\n', '      abi.encode(amount, recipient),\n', '      minimumActionGas,\n', '      userSignature,\n', '      dharmaSignature\n', '    );\n', '\n', '    // Ensure that an amount of at least 0.001 Dai has been supplied.\n', '    if (amount <= _JUST_UNDER_ONE_1000th_DAI) {\n', '      revert(_revertReason(0));\n', '    }\n', '\n', '    // Ensure that a non-zero recipient has been supplied.\n', '    if (recipient == address(0)) {\n', '      revert(_revertReason(1));\n', '    }\n', '\n', '    // Set the self-call context in order to call _withdrawDaiAtomic.\n', '    _selfCallContext = this.withdrawDai.selector;\n', '\n', '    // Make the atomic self-call - if redeemUnderlying fails on dDai, it will\n', '    // succeed but nothing will happen except firing an ExternalError event. If\n', '    // the second part of the self-call (the Dai transfer) fails, it will revert\n', '    // and roll back the first part of the call as well as fire an ExternalError\n', '    // event after returning from the failed call.\n', '    bytes memory returnData;\n', '    (ok, returnData) = address(this).call(abi.encodeWithSelector(\n', '      this._withdrawDaiAtomic.selector, amount, recipient\n', '    ));\n', '\n', '    // If the atomic call failed, emit an event signifying a transfer failure.\n', '    if (!ok) {\n', '      emit ExternalError(address(_DAI), _revertReason(2));\n', '    } else {\n', '      // Set ok to false if the call succeeded but the withdrawal failed.\n', '      ok = abi.decode(returnData, (bool));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Protected function that can only be called from `withdrawDai` on\n', '   * this contract. It will attempt to withdraw the supplied amount of Dai, or\n', '   * the maximum amount if specified using `uint256(-1)`, to the supplied\n', '   * recipient address by redeeming the underlying Dai from the dDai contract\n', '   * and transferring it to the recipient. An ExternalError will be emitted and\n', '   * the transfer will be skipped if the call to `redeem` or `redeemUnderlying`\n', '   * fails, and any revert will be caught by `withdrawDai` and diagnosed in\n', '   * order to emit an appropriate `ExternalError` as well.\n', '   * @param amount uint256 The amount of Dai to withdraw.\n', '   * @param recipient address The account to transfer the withdrawn Dai to.\n', '   * @return True if the withdrawal succeeded, otherwise false.\n', '   */\n', '  function _withdrawDaiAtomic(\n', '    uint256 amount,\n', '    address recipient\n', '  ) external returns (bool success) {\n', '    // Ensure caller is this contract and self-call context is correctly set.\n', '    _enforceSelfCallFrom(this.withdrawDai.selector);\n', '\n', '    // If amount = 0xfff...fff, withdraw the maximum amount possible.\n', '    bool maxWithdraw = (amount == uint256(-1));\n', '    if (maxWithdraw) {\n', '      // First attempt to redeem all dDai if there is a balance.\n', '      _withdrawMaxFromDharmaToken(AssetType.DAI);\n', '\n', '      // Then transfer all Dai to recipient if there is a balance.\n', '      require(_transferMax(_DAI, recipient, false));\n', '      success = true;\n', '    } else {\n', '      // Attempt to withdraw specified Dai from Dharma Dai before proceeding.\n', '      if (_withdrawFromDharmaToken(AssetType.DAI, amount)) {\n', '        // At this point Dai transfer should never fail - wrap it just in case.\n', '        require(_DAI.transfer(recipient, amount));\n', '        success = true;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Withdraw USDC to a provided recipient address by redeeming the\n', '   * underlying USDC from the dUSDC contract and transferring it to recipient.\n', '   * All USDC in Dharma USD Coin and in the smart wallet itself can be withdrawn\n', '   * by providing an amount of uint256(-1) or 0xfff...fff. This function can be\n', '   * called directly by the account set as the global key on the Dharma Key\n', '   * Registry, or by any relayer that provides a signed message from the same\n', '   * keyholder. The nonce used for the signature must match the current nonce on\n', '   * the smart wallet, and gas supplied to the call must exceed the specified\n', '   * minimum action gas, plus the gas that will be spent before the gas check is\n', '   * reached - usually somewhere around 25,000 gas. If the withdrawal fails, an\n', '   * `ExternalError` with additional details on what went wrong will be emitted.\n', '   * Note that the USDC contract can be paused and also allows for blacklisting\n', '   * accounts - either of these possibilities may cause a withdrawal to fail. In\n', '   * addition, Compound may not have sufficient USDC available at the time to\n', '   * withdraw.\n', '   * @param amount uint256 The amount of USDC to withdraw.\n', '   * @param recipient address The account to transfer the withdrawn USDC to.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param userSignature bytes A signature that resolves to the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`. If the user\n', '   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\n', '   * will be used. A unique hash returned from `getCustomActionID` is prefixed\n', '   * and hashed to create the message hash for the signature.\n', '   * @param dharmaSignature bytes A signature that resolves to the public key\n', '   * returned for this account from the Dharma Key Registry. A unique hash\n', '   * returned from `getCustomActionID` is prefixed and hashed to create the\n', '   * signed message.\n', '   * @return True if the withdrawal succeeded, otherwise false.\n', '   */\n', '  function withdrawUSDC(\n', '    uint256 amount,\n', '    address recipient,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external returns (bool ok) {\n', '    // Ensure caller and/or supplied signatures are valid and increment nonce.\n', '    _validateActionAndIncrementNonce(\n', '      ActionType.USDCWithdrawal,\n', '      abi.encode(amount, recipient),\n', '      minimumActionGas,\n', '      userSignature,\n', '      dharmaSignature\n', '    );\n', '\n', '    // Ensure that an amount of at least 0.001 USDC has been supplied.\n', '    if (amount <= _JUST_UNDER_ONE_1000th_USDC) {\n', '      revert(_revertReason(3));\n', '    }\n', '\n', '    // Ensure that a non-zero recipient has been supplied.\n', '    if (recipient == address(0)) {\n', '      revert(_revertReason(1));\n', '    }\n', '\n', '    // Set the self-call context in order to call _withdrawUSDCAtomic.\n', '    _selfCallContext = this.withdrawUSDC.selector;\n', '\n', '    // Make the atomic self-call - if redeemUnderlying fails on dUSDC, it will\n', '    // succeed but nothing will happen except firing an ExternalError event. If\n', '    // the second part of the self-call (USDC transfer) fails, it will revert\n', '    // and roll back the first part of the call as well as fire an ExternalError\n', '    // event after returning from the failed call.\n', '    bytes memory returnData;\n', '    (ok, returnData) = address(this).call(abi.encodeWithSelector(\n', '      this._withdrawUSDCAtomic.selector, amount, recipient\n', '    ));\n', '    if (!ok) {\n', "      // Find out why USDC transfer reverted (doesn't give revert reasons).\n", '      _diagnoseAndEmitUSDCSpecificError(_USDC.transfer.selector);\n', '    } else {\n', '      // Set ok to false if the call succeeded but the withdrawal failed.\n', '      ok = abi.decode(returnData, (bool));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Protected function that can only be called from `withdrawUSDC` on\n', '   * this contract. It will attempt to withdraw the supplied amount of USDC, or\n', '   * the maximum amount if specified using `uint256(-1)`, to the supplied\n', '   * recipient address by redeeming the underlying USDC from the dUSDC contract\n', '   * and transferring it to the recipient. An ExternalError will be emitted and\n', '   * the transfer will be skipped if the call to `redeemUnderlying` fails, and\n', '   * any revert will be caught by `withdrawUSDC` and diagnosed in order to emit\n', '   * an appropriate ExternalError as well.\n', '   * @param amount uint256 The amount of USDC to withdraw.\n', '   * @param recipient address The account to transfer the withdrawn USDC to.\n', '   * @return True if the withdrawal succeeded, otherwise false.\n', '   */\n', '  function _withdrawUSDCAtomic(\n', '    uint256 amount,\n', '    address recipient\n', '  ) external returns (bool success) {\n', '    // Ensure caller is this contract and self-call context is correctly set.\n', '    _enforceSelfCallFrom(this.withdrawUSDC.selector);\n', '\n', '    // If amount = 0xfff...fff, withdraw the maximum amount possible.\n', '    bool maxWithdraw = (amount == uint256(-1));\n', '    if (maxWithdraw) {\n', '      // Attempt to redeem all dUSDC from Dharma USDC if there is a balance.\n', '      _withdrawMaxFromDharmaToken(AssetType.USDC);\n', '\n', '      // Then transfer all USDC to recipient if there is a balance.\n', '      require(_transferMax(_USDC, recipient, false));\n', '      success = true;\n', '    } else {\n', '      // Attempt to withdraw specified USDC from Dharma USDC before proceeding.\n', '      if (_withdrawFromDharmaToken(AssetType.USDC, amount)) {\n', '        // Ensure that the USDC transfer does not fail.\n', '        require(_USDC.transfer(recipient, amount));\n', '        success = true;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Withdraw Ether to a provided recipient address by transferring it\n', '   * to a recipient.\n', '   * @param amount uint256 The amount of Ether to withdraw.\n', '   * @param recipient address The account to transfer the Ether to.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param userSignature bytes A signature that resolves to the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`. If the user\n', '   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\n', '   * will be used. A unique hash returned from `getCustomActionID` is prefixed\n', '   * and hashed to create the message hash for the signature.\n', '   * @param dharmaSignature bytes A signature that resolves to the public key\n', '   * returned for this account from the Dharma Key Registry. A unique hash\n', '   * returned from `getCustomActionID` is prefixed and hashed to create the\n', '   * signed message.\n', '   * @return True if the transfer succeeded, otherwise false.\n', '   */\n', '  function withdrawEther(\n', '    uint256 amount,\n', '    address payable recipient,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external returns (bool ok) {\n', '    // Ensure caller and/or supplied signatures are valid and increment nonce.\n', '    _validateActionAndIncrementNonce(\n', '      ActionType.ETHWithdrawal,\n', '      abi.encode(amount, recipient),\n', '      minimumActionGas,\n', '      userSignature,\n', '      dharmaSignature\n', '    );\n', '\n', '    // Ensure that a non-zero amount of Ether has been supplied.\n', '    if (amount == 0) {\n', '      revert(_revertReason(4));\n', '    }\n', '\n', '    // Ensure that a non-zero recipient has been supplied.\n', '    if (recipient == address(0)) {\n', '      revert(_revertReason(1));\n', '    }\n', '\n', '    // Attempt to transfer Ether to the recipient and emit an appropriate event.\n', '    ok = _transferETH(recipient, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Allow a signatory to increment the nonce at any point. The current\n', '   * nonce needs to be provided as an argument to the signature so as not to\n', '   * enable griefing attacks. All arguments can be omitted if called directly.\n', '   * No value is returned from this function - it will either succeed or revert.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param signature bytes A signature that resolves to either the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`, or the public\n', '   * key returned for this account from the Dharma Key Registry. A unique hash\n', '   * returned from `getCustomActionID` is prefixed and hashed to create the\n', '   * signed message.\n', '   */\n', '  function cancel(\n', '    uint256 minimumActionGas,\n', '    bytes calldata signature\n', '  ) external {\n', '    // Get the current nonce.\n', '    uint256 nonceToCancel = _nonce;\n', '\n', '    // Ensure the caller or the supplied signature is valid and increment nonce.\n', '    _validateActionAndIncrementNonce(\n', '      ActionType.Cancel,\n', '      abi.encode(),\n', '      minimumActionGas,\n', '      signature,\n', '      signature\n', '    );\n', '\n', '    // Emit an event to validate that the nonce is no longer valid.\n', '    emit Cancel(nonceToCancel);\n', '  }\n', '\n', '  /**\n', '   * @notice Perform a generic call to another contract. Note that accounts with\n', '   * no code may not be specified, nor may the smart wallet itself or the escape\n', '   * hatch registry. In order to increment the nonce and invalidate the\n', '   * signatures, a call to this function with a valid target, signatutes, and\n', '   * gas will always succeed. To determine whether the call made as part of the\n', '   * action was successful or not, either the return values or the `CallSuccess`\n', '   * or `CallFailure` event can be used.\n', '   * @param to address The contract to call.\n', '   * @param data bytes The calldata to provide when making the call.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param userSignature bytes A signature that resolves to the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`. If the user\n', '   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\n', '   * will be used. A unique hash returned from `getCustomActionID` is prefixed\n', '   * and hashed to create the message hash for the signature.\n', '   * @param dharmaSignature bytes A signature that resolves to the public key\n', '   * returned for this account from the Dharma Key Registry. A unique hash\n', '   * returned from `getCustomActionID` is prefixed and hashed to create the\n', '   * signed message.\n', '   * @return A boolean signifying the status of the call, as well as any data\n', '   * returned from the call.\n', '   */\n', '  function executeAction(\n', '    address to,\n', '    bytes calldata data,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external returns (bool ok, bytes memory returnData) {\n', '    // Ensure that the `to` address is a contract and is not this contract.\n', '    _ensureValidGenericCallTarget(to);\n', '\n', '    // Ensure caller and/or supplied signatures are valid and increment nonce.\n', '    (bytes32 actionID, uint256 nonce) = _validateActionAndIncrementNonce(\n', '      ActionType.Generic,\n', '      abi.encode(to, data),\n', '      minimumActionGas,\n', '      userSignature,\n', '      dharmaSignature\n', '    );\n', '\n', '    // Note: from this point on, there are no reverts (apart from out-of-gas or\n', '    // call-depth-exceeded) originating from this action. However, the call\n', '    // itself may revert, in which case the function will return `false`, along\n', '    // with the revert reason encoded as bytes, and fire an CallFailure event.\n', '\n', '    // Perform the action via low-level call and set return values using result.\n', '    (ok, returnData) = to.call(data);\n', '\n', '    // Emit a CallSuccess or CallFailure event based on the outcome of the call.\n', '    if (ok) {\n', '      // Note: while the call succeeded, the action may still have "failed"\n', '      // (for example, successful calls to Compound can still return an error).\n', '      emit CallSuccess(actionID, false, nonce, to, data, returnData);\n', '    } else {\n', '      // Note: while the call failed, the nonce will still be incremented, which\n', '      // will invalidate all supplied signatures.\n', '      emit CallFailure(actionID, nonce, to, data, _decodeRevertReason(returnData));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Allow signatory to set a new user signing key. The current nonce\n', '   * needs to be provided as an argument to the signature so as not to enable\n', '   * griefing attacks. No value is returned from this function - it will either\n', '   * succeed or revert.\n', '   * @param userSigningKey address The new user signing key to set on this smart\n', '   * wallet.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param userSignature bytes A signature that resolves to the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`. If the user\n', '   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\n', '   * will be used. A unique hash returned from `getCustomActionID` is prefixed\n', '   * and hashed to create the message hash for the signature.\n', '   * @param dharmaSignature bytes A signature that resolves to the public key\n', '   * returned for this account from the Dharma Key Registry. A unique hash\n', '   * returned from `getCustomActionID` is prefixed and hashed to create the\n', '   * signed message.\n', '   */\n', '  function setUserSigningKey(\n', '    address userSigningKey,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external {\n', '    // Ensure caller and/or supplied signatures are valid and increment nonce.\n', '    _validateActionAndIncrementNonce(\n', '      ActionType.SetUserSigningKey,\n', '      abi.encode(userSigningKey),\n', '      minimumActionGas,\n', '      userSignature,\n', '      dharmaSignature\n', '    );\n', '\n', '    // Set new user signing key on smart wallet and emit a corresponding event.\n', '    _setUserSigningKey(userSigningKey);\n', '  }\n', '\n', '  /**\n', '   * @notice Set a dedicated address as the "escape hatch" account. This account\n', '   * can then call `escape()` at any point to "sweep" the entire Dai, USDC,\n', '   * residual cDai, cUSDC, dDai, dUSDC, and Ether balance from the smart wallet.\n', '   * This function call will revert if the smart wallet has previously called\n', '   * `permanentlyDisableEscapeHatch` at any point and disabled the escape hatch.\n', '   * No value is returned from this function - it will either succeed or revert.\n', '   * @param account address The account to set as the escape hatch account.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param userSignature bytes A signature that resolves to the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`. If the user\n', '   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\n', '   * will be used. A unique hash returned from `getCustomActionID` is prefixed\n', '   * and hashed to create the message hash for the signature.\n', '   * @param dharmaSignature bytes A signature that resolves to the public key\n', '   * returned for this account from the Dharma Key Registry. A unique hash\n', '   * returned from `getCustomActionID` is prefixed and hashed to create the\n', '   * signed message.\n', '   */\n', '  function setEscapeHatch(\n', '    address account,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external {\n', '    // Ensure caller and/or supplied signatures are valid and increment nonce.\n', '    _validateActionAndIncrementNonce(\n', '      ActionType.SetEscapeHatch,\n', '      abi.encode(account),\n', '      minimumActionGas,\n', '      userSignature,\n', '      dharmaSignature\n', '    );\n', '\n', '    // Ensure that an escape hatch account has been provided.\n', '    if (account == address(0)) {\n', '      revert(_revertReason(5));\n', '    }\n', '\n', '    // Set a new escape hatch for the smart wallet unless it has been disabled.\n', '    _ESCAPE_HATCH_REGISTRY.setEscapeHatch(account);\n', '  }\n', '\n', '  /**\n', '   * @notice Remove the "escape hatch" account if one is currently set. This\n', '   * function call will revert if the smart wallet has previously called\n', '   * `permanentlyDisableEscapeHatch` at any point and disabled the escape hatch.\n', '   * No value is returned from this function - it will either succeed or revert.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param userSignature bytes A signature that resolves to the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`. If the user\n', '   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\n', '   * will be used. A unique hash returned from `getCustomActionID` is prefixed\n', '   * and hashed to create the message hash for the signature.\n', '   * @param dharmaSignature bytes A signature that resolves to the public key\n', '   * returned for this account from the Dharma Key Registry. A unique hash\n', '   * returned from `getCustomActionID` is prefixed and hashed to create the\n', '   * signed message.\n', '   */\n', '  function removeEscapeHatch(\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external {\n', '    // Ensure caller and/or supplied signatures are valid and increment nonce.\n', '    _validateActionAndIncrementNonce(\n', '      ActionType.RemoveEscapeHatch,\n', '      abi.encode(),\n', '      minimumActionGas,\n', '      userSignature,\n', '      dharmaSignature\n', '    );\n', '\n', '    // Remove the escape hatch for the smart wallet if one is currently set.\n', '    _ESCAPE_HATCH_REGISTRY.removeEscapeHatch();\n', '  }\n', '\n', '  /**\n', '   * @notice Permanently disable the "escape hatch" mechanism for this smart\n', '   * wallet. This function call will revert if the smart wallet has already\n', '   * called `permanentlyDisableEscapeHatch` at any point in the past. No value\n', '   * is returned from this function - it will either succeed or revert.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param userSignature bytes A signature that resolves to the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`. If the user\n', '   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\n', '   * will be used. A unique hash returned from `getCustomActionID` is prefixed\n', '   * and hashed to create the message hash for the signature.\n', '   * @param dharmaSignature bytes A signature that resolves to the public key\n', '   * returned for this account from the Dharma Key Registry. A unique hash\n', '   * returned from `getCustomActionID` is prefixed and hashed to create the\n', '   * signed message.\n', '   */\n', '  function permanentlyDisableEscapeHatch(\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external {\n', '    // Ensure caller and/or supplied signatures are valid and increment nonce.\n', '    _validateActionAndIncrementNonce(\n', '      ActionType.DisableEscapeHatch,\n', '      abi.encode(),\n', '      minimumActionGas,\n', '      userSignature,\n', '      dharmaSignature\n', '    );\n', '\n', '    // Permanently disable the escape hatch mechanism for this smart wallet.\n', '    _ESCAPE_HATCH_REGISTRY.permanentlyDisableEscapeHatch();\n', '  }\n', '\n', '  /**\n', '   * @notice Swap Ether for Dai and use it to mint Dharma Dai. The trade is\n', '   * facilitated by a "trade helper" contract in order to protect against\n', '   * malicious calls related to processing swaps via potentially unsafe call\n', '   * targets or other parameters. In the event that a swap does not result in\n', '   * sufficient Dai being received, the swap will be rolled back. In either\n', '   * case the nonce will still be incremented as long as signatures are valid.\n', '   * @param ethToSupply uint256 The Ether to supply as part of the swap.\n', '   * @param minimumDaiReceived uint256 The minimum amount of Dai that must be\n', '   * received in exchange for the supplied Ether.\n', '   * @param target address The contract that the trade helper should call in\n', '   * order to facilitate the swap.\n', '   * @param data bytes The payload that will be passed to the target, along with\n', '   * the supplied Ether, by the trade helper in order to facilitate the swap.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param userSignature bytes A signature that resolves to the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`. If the user\n', '   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\n', '   * will be used. A unique hash returned from `getEthForDaiActionID` is prefixed\n', '   * and hashed to create the message hash for the signature.\n', '   * @param dharmaSignature bytes A signature that resolves to the public key\n', '   * returned for this account from the Dharma Key Registry. A unique hash\n', '   * returned from `getEthForDaiActionIDActionID` is prefixed and hashed to\n', '   * create the signed message.\n', '   */\n', '  function tradeEthForDaiAndMintDDai(\n', '    uint256 ethToSupply,\n', '    uint256 minimumDaiReceived,\n', '    address target,\n', '    bytes calldata data,\n', '    uint256 minimumActionGas,\n', '    bytes calldata userSignature,\n', '    bytes calldata dharmaSignature\n', '  ) external returns (bool ok, bytes memory returnData) {\n', '    // Ensure caller and/or supplied signatures are valid and increment nonce.\n', '    _validateActionAndIncrementNonce(\n', '      ActionType.TradeEthForDai,\n', '      abi.encode(ethToSupply, minimumDaiReceived, target, data),\n', '      minimumActionGas,\n', '      userSignature,\n', '      dharmaSignature\n', '    );\n', '\n', '    // Ensure that an amount of at least 0.001 Dai will be received.\n', '    if (minimumDaiReceived <= _JUST_UNDER_ONE_1000th_DAI) {\n', '      revert(_revertReason(31));\n', '    }\n', '\n', '    // Set the self-call context in order to call _tradeEthForDaiAndMintDDaiAtomic.\n', '    _selfCallContext = this.tradeEthForDaiAndMintDDai.selector;\n', '\n', '    // Make the atomic self-call - if the swap fails or the received dai is not\n', '    // greater than or equal to the requirement, it will revert and roll back the\n', '    // atomic call as well as fire an ExternalError. If dDai is not successfully\n', '    // minted, the swap will succeed but an ExternalError for dDai will be fired.\n', '    (ok, returnData) = address(this).call(abi.encodeWithSelector(\n', '      this._tradeEthForDaiAndMintDDaiAtomic.selector,\n', '      ethToSupply, minimumDaiReceived, target, data\n', '    ));\n', '\n', '    // If the atomic call failed, emit an event signifying a trade failure.\n', '    if (!ok) {\n', '      emit ExternalError(\n', '        address(_TRADE_HELPER), _decodeRevertReason(returnData)\n', '      );\n', '    }\n', '  }\n', '  \n', '  function _tradeEthForDaiAndMintDDaiAtomic(\n', '    uint256 ethToSupply,\n', '    uint256 minimumDaiReceived,\n', '    address target,\n', '    bytes calldata data\n', '  ) external {\n', '    // Ensure caller is this contract and self-call context is correctly set.\n', '    _enforceSelfCallFrom(this.tradeEthForDaiAndMintDDai.selector);\n', '    \n', '    // Do swap using supplied Ether amount, minimum Dai, target, and data.\n', '    uint256 daiReceived = _TRADE_HELPER.tradeEthForDai.value(ethToSupply)(\n', '      minimumDaiReceived, target, data\n', '    );\n', '    \n', '    // Ensure that sufficient Dai was returned as a result of the swap. \n', '    if (daiReceived < minimumDaiReceived) {\n', '      revert(_revertReason(32));\n', '    }\n', '    \n', '    // Attempt to deposit the dai received and mint Dharma Dai.\n', '    _depositDharmaToken(AssetType.DAI, daiReceived);\n', '  }\n', '\n', '  /**\n', '   * @notice Allow the designated escape hatch account to redeem and "sweep"\n', '   * the entire Dai, USDC, residual dDai, dUSDC, cDai, cUSDC, & Ether balance\n', '   * from the smart wallet. The call will revert for any other caller, or if\n', '   * there is no escape hatch account on this smart wallet. First, an attempt\n', '   * will be made to redeem any dDai or dUSDC that is currently deposited in a\n', '   * dToken. Then, attempts will be made to transfer any balance in Dai, USDC,\n', '   * residual cDai & cUSDC, and Ether to the escape hatch account. If any\n', '   * portion of this operation does not succeed, it will simply be skipped,\n', '   * allowing the rest of the operation to proceed. Finally, an `Escaped` event\n', '   * will be emitted. No value is returned from this function - it will either\n', '   * succeed or revert.\n', '   */\n', '  function escape() external {\n', '    // Get the escape hatch account, if one exists, for this account.\n', '    (bool exists, address escapeHatch) = _ESCAPE_HATCH_REGISTRY.getEscapeHatch();\n', '\n', '    // Ensure that an escape hatch is currently set for this smart wallet.\n', '    if (!exists) {\n', '      revert(_revertReason(6));\n', '    }\n', '\n', '    // Ensure that the escape hatch account is the caller.\n', '    if (msg.sender != escapeHatch) {\n', '      revert(_revertReason(7));\n', '    }\n', '\n', '    // Attempt to redeem all dDai for Dai on Dharma Dai.\n', '    _withdrawMaxFromDharmaToken(AssetType.DAI);\n', '\n', '    // Attempt to redeem all dUSDC for USDC on Dharma USDC.\n', '    _withdrawMaxFromDharmaToken(AssetType.USDC);\n', '\n', '    // Attempt to transfer the total Dai balance to the caller.\n', '    _transferMax(_DAI, msg.sender, true);\n', '\n', '    // Attempt to transfer the total USDC balance to the caller.\n', '    _transferMax(_USDC, msg.sender, true);\n', '\n', '    // Attempt to transfer any residual cDai to the caller.\n', '    _transferMax(ERC20Interface(address(_CDAI)), msg.sender, true);\n', '\n', '    // Attempt to transfer any residual cUSDC to the caller.\n', '    _transferMax(ERC20Interface(address(_CUSDC)), msg.sender, true);\n', '\n', '    // Attempt to transfer any residual dDai to the caller.\n', '    _transferMax(ERC20Interface(address(_DDAI)), msg.sender, true);\n', '\n', '    // Attempt to transfer any residual dUSDC to the caller.\n', '    _transferMax(ERC20Interface(address(_DUSDC)), msg.sender, true);\n', '\n', '    // Determine if there is Ether at this address that should be transferred.\n', '    uint256 balance = address(this).balance;\n', '    if (balance > 0) {\n', '      // Attempt to transfer any Ether to caller and emit an appropriate event.\n', '      _transferETH(msg.sender, balance);\n', '    }\n', '\n', '    // Emit an `Escaped` event.\n', '    emit Escaped();\n', '  }\n', '\n', '  /**\n', '   * @notice Allow the account recovery manager to set a new user signing key on\n', '   * the smart wallet. The call will revert for any other caller. The account\n', '   * recovery manager implements a set of controls around the process, including\n', '   * a timelock and an option to permanently opt out of account recover. No\n', '   * value is returned from this function - it will either succeed or revert.\n', '   * @param newUserSigningKey address The new user signing key to set on this\n', '   * smart wallet.\n', '   */\n', '  function recover(address newUserSigningKey) external {\n', '    // Only the Account Recovery Manager contract may call this function.\n', '    if (msg.sender != _ACCOUNT_RECOVERY_MANAGER) {\n', '      revert(_revertReason(8));\n', '    }\n', '\n', '    // Increment nonce to prevent signature reuse should original key be reset.\n', '    _nonce++;\n', '\n', "    // Set up the user's new dharma key and emit a corresponding event.\n", '    _setUserSigningKey(newUserSigningKey);\n', '  }\n', '  \n', '  function setApproval(address token, uint256 amount) external {\n', '    // Only the Bot Commander contract may call this function.\n', '    if (msg.sender != _BOT_COMMANDER) {\n', '      revert("Only the Bot Commander may call this function.");\n', '    }\n', '    \n', '    ERC20Interface(token).approve(_BOT_COMMANDER, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice This call is no longer supported.\n', '   */\n', '  function migrateSaiToDai() external {\n', '    revert();\n', '  }\n', '\n', '  /**\n', '   * @notice This call is no longer supported.\n', '   */\n', '  function migrateCSaiToDDai() external {\n', '    revert();\n', '  }\n', '\n', '  /**\n', '   * @notice Redeem all available cDAI for Dai and use that Dai to mint dDai. If\n', '   * any step in the process fails, the call will revert and prior steps will be\n', '   * rolled back. Also note that existing Sai and Dai are not included as part\n', '   * of this operation.\n', '   */\n', '  function migrateCDaiToDDai() external {\n', '     _migrateCTokenToDToken(AssetType.DAI);\n', '  }\n', '\n', '  /**\n', '   * @notice Redeem all available cUSDC for USDC and use that USDC to mint\n', '   * dUSDC. If any step in the process fails, the call will revert and prior\n', '   * steps will be rolled back. Also note that existing USDC is not included as\n', '   * part of this operation.\n', '   */\n', '  function migrateCUSDCToDUSDC() external {\n', '     _migrateCTokenToDToken(AssetType.USDC);\n', '  }\n', '\n', '  /**\n', '   * @notice View function to retrieve the Dai and USDC balances held by the\n', '   * smart wallet, both directly and held in Dharma Dai and Dharma USD Coin, as\n', '   * well as the Ether balance (the underlying dEther balance will always return\n', '   * zero in this implementation, as there is no dEther yet).\n', '   * @return The Dai balance, the USDC balance, the Ether balance, the\n', '   * underlying Dai balance of the dDai balance, and the underlying USDC balance\n', '   * of the dUSDC balance (zero will always be returned as the underlying Ether\n', '   * balance of the dEther balance in this implementation).\n', '   */\n', '  function getBalances() external view returns (\n', '    uint256 daiBalance,\n', '    uint256 usdcBalance,\n', '    uint256 etherBalance,\n', '    uint256 dDaiUnderlyingDaiBalance,\n', '    uint256 dUsdcUnderlyingUsdcBalance,\n', '    uint256 dEtherUnderlyingEtherBalance // always returns 0\n', '  ) {\n', '    daiBalance = _DAI.balanceOf(address(this));\n', '    usdcBalance = _USDC.balanceOf(address(this));\n', '    etherBalance = address(this).balance;\n', '    dDaiUnderlyingDaiBalance = _DDAI.balanceOfUnderlying(address(this));\n', '    dUsdcUnderlyingUsdcBalance = _DUSDC.balanceOfUnderlying(address(this));\n', '    dEtherUnderlyingEtherBalance = 0;\n', '  }\n', '\n', '  /**\n', '   * @notice View function for getting the current user signing key for the\n', '   * smart wallet.\n', '   * @return The current user signing key.\n', '   */\n', '  function getUserSigningKey() external view returns (address userSigningKey) {\n', '    userSigningKey = _userSigningKey;\n', '  }\n', '\n', '  /**\n', '   * @notice View function for getting the current nonce of the smart wallet.\n', '   * This nonce is incremented whenever an action is taken that requires a\n', '   * signature and/or a specific caller.\n', '   * @return The current nonce.\n', '   */\n', '  function getNonce() external view returns (uint256 nonce) {\n', '    nonce = _nonce;\n', '  }\n', '\n', '  /**\n', '   * @notice View function that, given an action type and arguments, will return\n', '   * the action ID or message hash that will need to be prefixed (according to\n', '   * EIP-191 0x45), hashed, and signed by both the user signing key and by the\n', '   * key returned for this smart wallet by the Dharma Key Registry in order to\n', '   * construct a valid signature for the corresponding action. Any nonce value\n', '   * may be supplied, which enables constructing valid message hashes for\n', '   * multiple future actions ahead of time.\n', "   * @param action uint8 The type of action, designated by it's index. Valid\n", '   * custom actions in V8 include Cancel (0), SetUserSigningKey (1),\n', '   * DAIWithdrawal (10), USDCWithdrawal (5), ETHWithdrawal (6),\n', '   * SetEscapeHatch (7), RemoveEscapeHatch (8), and DisableEscapeHatch (9).\n', '   * @param amount uint256 The amount to withdraw for Withdrawal actions. This\n', '   * value is ignored for non-withdrawal action types.\n', '   * @param recipient address The account to transfer withdrawn funds to or the\n', '   * new user signing key. This value is ignored for Cancel, RemoveEscapeHatch,\n', '   * and DisableEscapeHatch action types.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @return The action ID, which will need to be prefixed, hashed and signed in\n', '   * order to construct a valid signature.\n', '   */\n', '  function getNextCustomActionID(\n', '    ActionType action,\n', '    uint256 amount,\n', '    address recipient,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID) {\n', '    // Determine the actionID - this serves as a signature hash for an action.\n', '    actionID = _getActionID(\n', '      action,\n', '      _validateCustomActionTypeAndGetArguments(action, amount, recipient),\n', '      _nonce,\n', '      minimumActionGas,\n', '      _userSigningKey,\n', '      _getDharmaSigningKey()\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice View function that, given an action type and arguments, will return\n', '   * the action ID or message hash that will need to be prefixed (according to\n', '   * EIP-191 0x45), hashed, and signed by both the user signing key and by the\n', '   * key returned for this smart wallet by the Dharma Key Registry in order to\n', '   * construct a valid signature for the corresponding action. The current nonce\n', '   * will be used, which means that it will only be valid for the next action\n', '   * taken.\n', "   * @param action uint8 The type of action, designated by it's index. Valid\n", '   * custom actions in V8 include Cancel (0), SetUserSigningKey (1),\n', '   * DAIWithdrawal (10), USDCWithdrawal (5), ETHWithdrawal (6),\n', '   * SetEscapeHatch (7), RemoveEscapeHatch (8), and DisableEscapeHatch (9).\n', '   * @param amount uint256 The amount to withdraw for Withdrawal actions. This\n', '   * value is ignored for non-withdrawal action types.\n', '   * @param recipient address The account to transfer withdrawn funds to or the\n', '   * new user signing key. This value is ignored for Cancel, RemoveEscapeHatch,\n', '   * and DisableEscapeHatch action types.\n', '   * @param nonce uint256 The nonce to use.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @return The action ID, which will need to be prefixed, hashed and signed in\n', '   * order to construct a valid signature.\n', '   */\n', '  function getCustomActionID(\n', '    ActionType action,\n', '    uint256 amount,\n', '    address recipient,\n', '    uint256 nonce,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID) {\n', '    // Determine the actionID - this serves as a signature hash for an action.\n', '    actionID = _getActionID(\n', '      action,\n', '      _validateCustomActionTypeAndGetArguments(action, amount, recipient),\n', '      nonce,\n', '      minimumActionGas,\n', '      _userSigningKey,\n', '      _getDharmaSigningKey()\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice View function that will return the action ID or message hash that\n', '   * will need to be prefixed (according to EIP-191 0x45), hashed, and signed by\n', '   * both the user signing key and by the key returned for this smart wallet by\n', '   * the Dharma Key Registry in order to construct a valid signature for a given\n', '   * generic action. The current nonce will be used, which means that it will\n', '   * only be valid for the next action taken.\n', '   * @param to address The target to call into as part of the generic action.\n', '   * @param data bytes The data to supply when calling into the target.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @return The action ID, which will need to be prefixed, hashed and signed in\n', '   * order to construct a valid signature.\n', '   */\n', '  function getNextGenericActionID(\n', '    address to,\n', '    bytes calldata data,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID) {\n', '    // Determine the actionID - this serves as a signature hash for an action.\n', '    actionID = _getActionID(\n', '      ActionType.Generic,\n', '      abi.encode(to, data),\n', '      _nonce,\n', '      minimumActionGas,\n', '      _userSigningKey,\n', '      _getDharmaSigningKey()\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice View function that will return the action ID or message hash that\n', '   * will need to be prefixed (according to EIP-191 0x45), hashed, and signed by\n', '   * both the user signing key and by the key returned for this smart wallet by\n', '   * the Dharma Key Registry in order to construct a valid signature for a given\n', '   * generic action. Any nonce value may be supplied, which enables constructing\n', '   * valid message hashes for multiple future actions ahead of time.\n', '   * @param to address The target to call into as part of the generic action.\n', '   * @param data bytes The data to supply when calling into the target.\n', '   * @param nonce uint256 The nonce to use.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @return The action ID, which will need to be prefixed, hashed and signed in\n', '   * order to construct a valid signature.\n', '   */\n', '  function getGenericActionID(\n', '    address to,\n', '    bytes calldata data,\n', '    uint256 nonce,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID) {\n', '    // Determine the actionID - this serves as a signature hash for an action.\n', '    actionID = _getActionID(\n', '      ActionType.Generic,\n', '      abi.encode(to, data),\n', '      nonce,\n', '      minimumActionGas,\n', '      _userSigningKey,\n', '      _getDharmaSigningKey()\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice View function that will return the action ID or message hash that\n', '   * will need to be prefixed (according to EIP-191 0x45), hashed, and signed by\n', '   * both the user signing key and by the key returned for this smart wallet by\n', '   * the Dharma Key Registry in order to construct a valid signature for an\n', '   * Eth-to-Dai swap. The current nonce will be used, which means that it will\n', '   * only be valid for the next action taken.\n', '   * @param ethToSupply uint256 The Ether to supply as part of the swap.\n', '   * @param minimumDaiReceived uint256 The minimum amount of Dai that must be\n', '   * received in exchange for the supplied Ether.\n', '   * @param target address The contract that the trade helper should call in\n', '   * order to facilitate the swap.\n', '   * @param data bytes The payload that will be passed to the target, along with\n', '   * the supplied Ether, by the trade helper in order to facilitate the swap.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @return The action ID, which will need to be prefixed, hashed and signed in\n', '   * order to construct a valid signature.\n', '   */\n', '  function getNextEthForDaiActionID(\n', '    uint256 ethToSupply,\n', '    uint256 minimumDaiReceived,\n', '    address target,\n', '    bytes calldata data,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID) {\n', '    // Determine the actionID - this serves as a signature hash for an action.\n', '    actionID = _getActionID(\n', '      ActionType.TradeEthForDai,\n', '      abi.encode(ethToSupply, minimumDaiReceived, target, data),\n', '      _nonce,\n', '      minimumActionGas,\n', '      _userSigningKey,\n', '      _getDharmaSigningKey()\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice View function that will return the action ID or message hash that\n', '   * will need to be prefixed (according to EIP-191 0x45), hashed, and signed by\n', '   * both the user signing key and by the key returned for this smart wallet by\n', '   * the Dharma Key Registry in order to construct a valid signature for an\n', '   * Eth-to-Dai swap. Any nonce value may be supplied, which enables\n', '   * constructing valid message hashes for multiple future actions ahead of\n', '   * time.\n', '   * @param ethToSupply uint256 The Ether to supply as part of the swap.\n', '   * @param minimumDaiReceived uint256 The minimum amount of Dai that must be\n', '   * received in exchange for the supplied Ether.\n', '   * @param target address The contract that the trade helper should call in\n', '   * order to facilitate the swap.\n', '   * @param data bytes The payload that will be passed to the target, along with\n', '   * the supplied Ether, by the trade helper in order to facilitate the swap.\n', '   * @param nonce uint256 The nonce to use.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @return The action ID, which will need to be prefixed, hashed and signed in\n', '   * order to construct a valid signature.\n', '   */ \n', '  function getEthForDaiActionID(\n', '    uint256 ethToSupply,\n', '    uint256 minimumDaiReceived,\n', '    address target,\n', '    bytes calldata data,\n', '    uint256 nonce,\n', '    uint256 minimumActionGas\n', '  ) external view returns (bytes32 actionID) {\n', '    // Determine the actionID - this serves as a signature hash for an action.\n', '    actionID = _getActionID(\n', '      ActionType.TradeEthForDai,\n', '      abi.encode(ethToSupply, minimumDaiReceived, target, data),\n', '      nonce,\n', '      minimumActionGas,\n', '      _userSigningKey,\n', '      _getDharmaSigningKey()\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice View function that implements ERC-1271 and validates a set of\n', '   * signatures, one from the owner (using ERC-1271 as well if the user signing\n', '   * key is a contract) and one from the Dharma Key Registry against the\n', '   * supplied data. The data must be ABI encoded as (bytes32, bytes), where the\n', '   * first bytes32 parameter represents the hash digest for validating the\n', '   * supplied signatures and the second bytes parameter contains context for the\n', '   * requested validation. The two signatures are packed together, with the one\n', '   * from Dharma coming first and that from the user coming second - this is so\n', '   * that, in future versions, multiple user signatures may be supplied if the\n', '   * associated key ring requires them.\n', '   * @param data bytes The data used to validate the signature.\n', '   * @param signatures bytes The two signatures, each 65 bytes - one from the\n', '   * owner (using ERC-1271 as well if the user signing key is a contract) and\n', '   * one from the Dharma Key Registry.\n', '   * @return The 4-byte magic value to signify a valid signature in ERC-1271, if\n', '   * the signatures are both valid.\n', '   */\n', '  function isValidSignature(\n', '    bytes calldata data, bytes calldata signatures\n', '  ) external view returns (bytes4 magicValue) {\n', '    // Get message hash digest and any additional context from data argument.\n', '    bytes32 digest;\n', '    bytes memory context;\n', '\n', '    if (data.length == 32) {\n', '      digest = abi.decode(data, (bytes32));\n', '    } else {\n', '      if (data.length < 64) {\n', '        revert(_revertReason(30));\n', '      }\n', '      (digest, context) = abi.decode(data, (bytes32, bytes));\n', '    }\n', '\n', '    // Get Dharma signature & user signature from combined signatures argument.\n', '    if (signatures.length != 130) {\n', '      revert(_revertReason(11));\n', '    }\n', '    bytes memory signaturesInMemory = signatures;\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '    assembly {\n', '      r := mload(add(signaturesInMemory, 0x20))\n', '      s := mload(add(signaturesInMemory, 0x40))\n', '      v := byte(0, mload(add(signaturesInMemory, 0x60)))\n', '    }\n', '    bytes memory dharmaSignature = abi.encodePacked(r, s, v);\n', '\n', '    assembly {\n', '      r := mload(add(signaturesInMemory, 0x61))\n', '      s := mload(add(signaturesInMemory, 0x81))\n', '      v := byte(0, mload(add(signaturesInMemory, 0xa1)))\n', '    }\n', '    bytes memory userSignature = abi.encodePacked(r, s, v);\n', '\n', '    // Validate user signature with `SignatureVerification` as the action type.\n', '    if (\n', '      !_validateUserSignature(\n', '        digest,\n', '        ActionType.SignatureVerification,\n', '        context,\n', '        _userSigningKey,\n', '        userSignature\n', '      )\n', '    ) {\n', '      revert(_revertReason(12));\n', '    }\n', '\n', '    // Recover Dharma signature against key returned from Dharma Key Registry.\n', '    if (_getDharmaSigningKey() != digest.recover(dharmaSignature)) {\n', '      revert(_revertReason(13));\n', '    }\n', '\n', '    // Return the ERC-1271 magic value to indicate success.\n', '    magicValue = _ERC_1271_MAGIC_VALUE;\n', '  }\n', '\n', '  /**\n', '   * @notice View function for getting the current Dharma Smart Wallet\n', '   * implementation contract address set on the upgrade beacon.\n', '   * @return The current Dharma Smart Wallet implementation contract.\n', '   */ \n', '  function getImplementation() external view returns (address implementation) {\n', '    (bool ok, bytes memory returnData) = address(\n', '      0x0000000000b45D6593312ac9fdE193F3D0633644\n', '    ).staticcall("");\n', '    require(ok && returnData.length == 32, "Invalid implementation.");\n', '    implementation = abi.decode(returnData, (address));\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function for getting the current Dharma Smart Wallet version.\n', '   * @return The current Dharma Smart Wallet version.\n', '   */\n', '  function getVersion() external pure returns (uint256 version) {\n', '    version = _DHARMA_SMART_WALLET_VERSION;\n', '  }\n', '\n', '  /**\n', '   * @notice Perform a series of generic calls to other contracts. If any call\n', '   * fails during execution, the preceding calls will be rolled back, but their\n', '   * original return data will still be accessible. Calls that would otherwise\n', '   * occur after the failed call will not be executed. Note that accounts with\n', '   * no code may not be specified, nor may the smart wallet itself or the escape\n', '   * hatch registry. In order to increment the nonce and invalidate the\n', '   * signatures, a call to this function with valid targets, signatutes, and gas\n', '   * will always succeed. To determine whether each call made as part of the\n', '   * action was successful or not, either the corresponding return value or the\n', '   * corresponding `CallSuccess` or `CallFailure` event can be used - note that\n', '   * even calls that return a success status will have been rolled back unless\n', '   * all of the calls returned a success status. Finally, note that this\n', '   * function must currently be implemented as a public function (instead of as\n', '   * an external one) due to an ABIEncoderV2 `UnimplementedFeatureError`.\n', '   * @param calls Call[] A struct containing the target and calldata to provide\n', '   * when making each call.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param userSignature bytes A signature that resolves to the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`. If the user\n', '   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\n', '   * will be used. A unique hash returned from `getCustomActionID` is prefixed\n', '   * and hashed to create the message hash for the signature.\n', '   * @param dharmaSignature bytes A signature that resolves to the public key\n', '   * returned for this account from the Dharma Key Registry. A unique hash\n', '   * returned from `getCustomActionID` is prefixed and hashed to create the\n', '   * signed message.\n', '   * @return An array of structs signifying the status of each call, as well as\n', '   * any data returned from that call. Calls that are not executed will return\n', '   * empty data.\n', '   */\n', '  function executeActionWithAtomicBatchCalls(\n', '    Call[] memory calls,\n', '    uint256 minimumActionGas,\n', '    bytes memory userSignature,\n', '    bytes memory dharmaSignature\n', '  ) public returns (bool[] memory ok, bytes[] memory returnData) {\n', '    // Ensure that each `to` address is a contract and is not this contract.\n', '    for (uint256 i = 0; i < calls.length; i++) {\n', '      _ensureValidGenericCallTarget(calls[i].to);\n', '    }\n', '\n', '    // Ensure caller and/or supplied signatures are valid and increment nonce.\n', '    (bytes32 actionID, uint256 nonce) = _validateActionAndIncrementNonce(\n', '      ActionType.GenericAtomicBatch,\n', '      abi.encode(calls),\n', '      minimumActionGas,\n', '      userSignature,\n', '      dharmaSignature\n', '    );\n', '\n', '    // Note: from this point on, there are no reverts (apart from out-of-gas or\n', '    // call-depth-exceeded) originating from this contract. However, one of the\n', '    // calls may revert, in which case the function will return `false`, along\n', '    // with the revert reason encoded as bytes, and fire an CallFailure event.\n', '\n', '    // Specify length of returned values in order to work with them in memory.\n', '    ok = new bool[](calls.length);\n', '    returnData = new bytes[](calls.length);\n', '\n', '    // Set self-call context to call _executeActionWithAtomicBatchCallsAtomic.\n', '    _selfCallContext = this.executeActionWithAtomicBatchCalls.selector;\n', '\n', '    // Make the atomic self-call - if any call fails, calls that preceded it\n', '    // will be rolled back and calls that follow it will not be made.\n', '    (bool externalOk, bytes memory rawCallResults) = address(this).call(\n', '      abi.encodeWithSelector(\n', '        this._executeActionWithAtomicBatchCallsAtomic.selector, calls\n', '      )\n', '    );\n', '\n', '    // Parse data returned from self-call into each call result and store / log.\n', '    CallReturn[] memory callResults = abi.decode(rawCallResults, (CallReturn[]));\n', '    for (uint256 i = 0; i < callResults.length; i++) {\n', '      Call memory currentCall = calls[i];\n', '\n', '      // Set the status and the return data / revert reason from the call.\n', '      ok[i] = callResults[i].ok;\n', '      returnData[i] = callResults[i].returnData;\n', '\n', '      // Emit CallSuccess or CallFailure event based on the outcome of the call.\n', '      if (callResults[i].ok) {\n', '        // Note: while the call succeeded, the action may still have "failed".\n', '        emit CallSuccess(\n', '          actionID,\n', '          !externalOk, // If another call failed this will have been rolled back\n', '          nonce,\n', '          currentCall.to,\n', '          currentCall.data,\n', '          callResults[i].returnData\n', '        );\n', '      } else {\n', '        // Note: while the call failed, the nonce will still be incremented,\n', '        // which will invalidate all supplied signatures.\n', '        emit CallFailure(\n', '          actionID,\n', '          nonce,\n', '          currentCall.to,\n', '          currentCall.data,\n', '          _decodeRevertReason(callResults[i].returnData)\n', '        );\n', '\n', '        // exit early - any calls after the first failed call will not execute.\n', '        break;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Protected function that can only be called from\n', '   * `executeActionWithAtomicBatchCalls` on this contract. It will attempt to\n', '   * perform each specified call, populating the array of results as it goes,\n', '   * unless a failure occurs, at which point it will revert and "return" the\n', '   * array of results as revert data. Otherwise, it will simply return the array\n', '   * upon successful completion of each call. Finally, note that this function\n', '   * must currently be implemented as a public function (instead of as an\n', '   * external one) due to an ABIEncoderV2 `UnimplementedFeatureError`.\n', '   * @param calls Call[] A struct containing the target and calldata to provide\n', '   * when making each call.\n', '   * @return An array of structs signifying the status of each call, as well as\n', '   * any data returned from that call. Calls that are not executed will return\n', '   * empty data. If any of the calls fail, the array will be returned as revert\n', '   * data.\n', '   */\n', '  function _executeActionWithAtomicBatchCallsAtomic(\n', '    Call[] memory calls\n', '  ) public returns (CallReturn[] memory callResults) {\n', '    // Ensure caller is this contract and self-call context is correctly set.\n', '    _enforceSelfCallFrom(this.executeActionWithAtomicBatchCalls.selector);\n', '\n', '    bool rollBack = false;\n', '    callResults = new CallReturn[](calls.length);\n', '\n', '    for (uint256 i = 0; i < calls.length; i++) {\n', '      // Perform low-level call and set return values using result.\n', '      (bool ok, bytes memory returnData) = calls[i].to.call(calls[i].data);\n', '      callResults[i] = CallReturn({ok: ok, returnData: returnData});\n', '      if (!ok) {\n', '        // Exit early - any calls after the first failed call will not execute.\n', '        rollBack = true;\n', '        break;\n', '      }\n', '    }\n', '\n', '    if (rollBack) {\n', '      // Wrap in length encoding and revert (provide data instead of a string).\n', '      bytes memory callResultsBytes = abi.encode(callResults);\n', '      assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice View function that, given an action type and arguments, will return\n', '   * the action ID or message hash that will need to be prefixed (according to\n', '   * EIP-191 0x45), hashed, and signed by both the user signing key and by the\n', '   * key returned for this smart wallet by the Dharma Key Registry in order to\n', '   * construct a valid signature for a given generic atomic batch action. The\n', '   * current nonce will be used, which means that it will only be valid for the\n', '   * next action taken. Finally, note that this function must currently be\n', '   * implemented as a public function (instead of as an external one) due to an\n', '   * ABIEncoderV2 `UnimplementedFeatureError`.\n', '   * @param calls Call[] A struct containing the target and calldata to provide\n', '   * when making each call.\n', '   * @param calls Call[] A struct containing the target and calldata to provide\n', '   * when making each call.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @return The action ID, which will need to be prefixed, hashed and signed in\n', '   * order to construct a valid signature.\n', '   */\n', '  function getNextGenericAtomicBatchActionID(\n', '    Call[] memory calls,\n', '    uint256 minimumActionGas\n', '  ) public view returns (bytes32 actionID) {\n', '    // Determine the actionID - this serves as a signature hash for an action.\n', '    actionID = _getActionID(\n', '      ActionType.GenericAtomicBatch,\n', '      abi.encode(calls),\n', '      _nonce,\n', '      minimumActionGas,\n', '      _userSigningKey,\n', '      _getDharmaSigningKey()\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice View function that, given an action type and arguments, will return\n', '   * the action ID or message hash that will need to be prefixed (according to\n', '   * EIP-191 0x45), hashed, and signed by both the user signing key and by the\n', '   * key returned for this smart wallet by the Dharma Key Registry in order to\n', '   * construct a valid signature for a given generic atomic batch action. Any\n', '   * nonce value may be supplied, which enables constructing valid message\n', '   * hashes for multiple future actions ahead of time. Finally, note that this\n', '   * function must currently be implemented as a public function (instead of as\n', '   * an external one) due to an ABIEncoderV2 `UnimplementedFeatureError`.\n', '   * @param calls Call[] A struct containing the target and calldata to provide\n', '   * when making each call.\n', '   * @param calls Call[] A struct containing the target and calldata to provide\n', '   * when making each call.\n', '   * @param nonce uint256 The nonce to use.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @return The action ID, which will need to be prefixed, hashed and signed in\n', '   * order to construct a valid signature.\n', '   */\n', '  function getGenericAtomicBatchActionID(\n', '    Call[] memory calls,\n', '    uint256 nonce,\n', '    uint256 minimumActionGas\n', '  ) public view returns (bytes32 actionID) {\n', '    // Determine the actionID - this serves as a signature hash for an action.\n', '    actionID = _getActionID(\n', '      ActionType.GenericAtomicBatch,\n', '      abi.encode(calls),\n', '      nonce,\n', '      minimumActionGas,\n', '      _userSigningKey,\n', '      _getDharmaSigningKey()\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for setting a new user signing key. Called by the\n', '   * initializer, by the `setUserSigningKey` function, and by the `recover`\n', '   * function. A `NewUserSigningKey` event will also be emitted.\n', '   * @param userSigningKey address The new user signing key to set on this smart\n', '   * wallet.\n', '   */\n', '  function _setUserSigningKey(address userSigningKey) internal {\n', '    // Ensure that a user signing key is set on this smart wallet.\n', '    if (userSigningKey == address(0)) {\n', '      revert(_revertReason(14));\n', '    }\n', '\n', '    _userSigningKey = userSigningKey;\n', '    emit NewUserSigningKey(userSigningKey);\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for setting the allowance of a given ERC20 asset\n', '   * to the maximum value. This enables the corresponding dToken for the asset\n', '   * to pull in tokens in order to make deposits.\n', '   * @param asset uint256 The ID of the asset, either Dai (0) or USDC (1).\n', '   * @return True if the approval succeeded, otherwise false.\n', '   */\n', '  function _setFullApproval(AssetType asset) internal returns (bool ok) {\n', "    // Get asset's underlying token address and corresponding dToken address.\n", '    address token;\n', '    address dToken;\n', '    if (asset == AssetType.DAI) {\n', '      token = address(_DAI);\n', '      dToken = address(_DDAI_EXCHANGER);\n', '    } else {\n', '      token = address(_USDC);\n', '      dToken = address(_DUSDC);\n', '    }\n', '\n', '    // Approve dToken contract to transfer underlying on behalf of this wallet.\n', '    (ok, ) = address(token).call(abi.encodeWithSelector(\n', "      // Note: since both Tokens have the same interface, just use DAI's.\n", '      _DAI.approve.selector, dToken, uint256(-1)\n', '    ));\n', '\n', '    // Emit a corresponding event if the approval failed.\n', '    if (!ok) {\n', '      if (asset == AssetType.DAI) {\n', '        emit ExternalError(address(_DAI), _revertReason(17));\n', '      } else {\n', "        // Find out why USDC transfer reverted (it doesn't give revert reasons).\n", '        _diagnoseAndEmitUSDCSpecificError(_USDC.approve.selector);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for depositing a given ERC20 asset and balance on\n', '   * the corresponding dToken. No value is returned, as no additional steps need\n', '   * to be conditionally performed after the deposit.\n', '   * @param asset uint256 The ID of the asset, either Dai (0) or USDC (1).\n', '   * @param balance uint256 The amount of the asset to deposit. Note that an\n', '   * attempt to deposit "dust" (i.e. very small amounts) may result in fewer\n', '   * dTokens being minted than is implied by the current exchange rate due to a\n', '   * lack of sufficient precision on the tokens in question. USDC deposits are\n', '   * also dependent on a flag being set on the Configuration Registry contract.\n', '   */\n', '  function _depositDharmaToken(AssetType asset, uint256 balance) internal {\n', '    // Only perform a deposit if the balance is at least .001 Dai or USDC.\n', '    if (\n', '      asset == AssetType.DAI && balance > _JUST_UNDER_ONE_1000th_DAI ||\n', '      asset == AssetType.USDC && (\n', '        balance > _JUST_UNDER_ONE_1000th_USDC &&\n', '        uint256(_CONFIG_REGISTRY.get(_ENABLE_USDC_MINTING_KEY)) != 0\n', '      )\n', '    ) {\n', '      bool ok;\n', '      bytes memory data;\n', '      if (asset == AssetType.DAI) {\n', '        // Attempt to mint the Dai balance on the dDai Exchanger contract.\n', '        (ok, data) = address(_DDAI_EXCHANGER).call(abi.encodeWithSelector(\n', '          _DDAI_EXCHANGER.mintTo.selector, address(this), balance\n', '        ));\n', '      } else {\n', '        // Attempt to mint the USDC balance on the dUDSC contract.\n', '        (ok, data) = address(_DUSDC).call(abi.encodeWithSelector(\n', '          _DUSDC.mint.selector, balance\n', '        ));\n', '      }\n', '\n', '      // Log an external error if something went wrong with the attempt.\n', '      _checkDharmaTokenInteractionAndLogAnyErrors(\n', '        asset, _DDAI.mint.selector, ok, data\n', '      );\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for withdrawing a given underlying asset balance\n', '   * from the corresponding dToken. Note that the requested balance may not be\n', '   * currently available on Compound, which will cause the withdrawal to fail.\n', "   * @param asset uint256 The asset's ID, either Dai (0) or USDC (1).\n", '   * @param balance uint256 The amount of the asset to withdraw, denominated in\n', '   * the underlying token. Note that an attempt to withdraw "dust" (i.e. very\n', '   * small amounts) may result in 0 underlying tokens being redeemed, or in\n', '   * fewer tokens being redeemed than is implied by the current exchange rate\n', '   * (due to lack of sufficient precision on the tokens).\n', '   * @return True if the withdrawal succeeded, otherwise false.\n', '   */\n', '  function _withdrawFromDharmaToken(\n', '    AssetType asset, uint256 balance\n', '  ) internal returns (bool success) {\n', '    // Get dToken address for the asset type. (No custom ETH withdrawal action.)\n', '    address dToken = asset == AssetType.DAI ? address(_DDAI) : address(_DUSDC);\n', '\n', '    // Attempt to redeem the underlying balance from the dToken contract.\n', '    (bool ok, bytes memory data) = dToken.call(abi.encodeWithSelector(\n', "      // Note: function selector is the same for each dToken so just use dDai's.\n", '      _DDAI.redeemUnderlying.selector, balance\n', '    ));\n', '\n', '    // Log an external error if something went wrong with the attempt.\n', '    success = _checkDharmaTokenInteractionAndLogAnyErrors(\n', '      asset, _DDAI.redeemUnderlying.selector, ok, data\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for withdrawing the total underlying asset\n', '   * balance from the corresponding dToken. Note that the requested balance may\n', '   * not be currently available on Compound, which will cause the withdrawal to\n', '   * fail.\n', "   * @param asset uint256 The asset's ID, either Dai (0) or USDC (1).\n", '   */\n', '  function _withdrawMaxFromDharmaToken(AssetType asset) internal {\n', '    // Get dToken address for the asset type. (No custom ETH withdrawal action.)\n', '    address dToken = asset == AssetType.DAI ? address(_DDAI) : address(_DUSDC);\n', '\n', '    // Try to retrieve the current dToken balance for this account.\n', '    ERC20Interface dTokenBalance;\n', '    (bool ok, bytes memory data) = dToken.call(abi.encodeWithSelector(\n', '      dTokenBalance.balanceOf.selector, address(this)\n', '    ));\n', '\n', '    uint256 redeemAmount = 0;\n', '    if (ok && data.length == 32) {\n', '      redeemAmount = abi.decode(data, (uint256));\n', '    } else {\n', '      // Something went wrong with the balance check - log an ExternalError.\n', '      _checkDharmaTokenInteractionAndLogAnyErrors(\n', '        asset, dTokenBalance.balanceOf.selector, ok, data\n', '      );\n', '    }\n', '\n', '    // Only perform the call to redeem if there is a non-zero balance.\n', '    if (redeemAmount > 0) {\n', '      // Attempt to redeem the underlying balance from the dToken contract.\n', '      (ok, data) = dToken.call(abi.encodeWithSelector(\n', "        // Function selector is the same for all dTokens, so just use dDai's.\n", '        _DDAI.redeem.selector, redeemAmount\n', '      ));\n', '\n', '      // Log an external error if something went wrong with the attempt.\n', '      _checkDharmaTokenInteractionAndLogAnyErrors(\n', '        asset, _DDAI.redeem.selector, ok, data\n', '      );\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for transferring the total underlying balance of\n', '   * the corresponding token to a designated recipient. It will return true if\n', '   * tokens were successfully transferred (or there is no balance), signified by\n', '   * the boolean returned by the transfer function, or the call status if the\n', '   * `suppressRevert` boolean is set to true.\n', '   * @param token IERC20 The interface of the token in question.\n', '   * @param recipient address The account that will receive the tokens.\n', '   * @param suppressRevert bool A boolean indicating whether reverts should be\n', '   * suppressed or not. Used by the escape hatch so that a problematic transfer\n', '   * will not block the rest of the call from executing.\n', '   * @return True if tokens were successfully transferred or if there is no\n', '   * balance, else false.\n', '   */\n', '  function _transferMax(\n', '    ERC20Interface token, address recipient, bool suppressRevert\n', '  ) internal returns (bool success) {\n', '    // Get the current balance on the smart wallet for the supplied ERC20 token.\n', '    uint256 balance = 0;\n', '    bool balanceCheckWorked = true;\n', '    if (!suppressRevert) {\n', '      balance = token.balanceOf(address(this));\n', '    } else {\n', '      // Try to retrieve current token balance for this account with 1/2 gas.\n', '      (bool ok, bytes memory data) = address(token).call.gas(gasleft() / 2)(\n', '        abi.encodeWithSelector(token.balanceOf.selector, address(this))\n', '      );\n', '\n', '      if (ok && data.length == 32) {\n', '        balance = abi.decode(data, (uint256));\n', '      } else {\n', '        // Something went wrong with the balance check.\n', '        balanceCheckWorked = false;\n', '      }\n', '    }\n', '\n', '    // Only perform the call to transfer if there is a non-zero balance.\n', '    if (balance > 0) {\n', '      if (!suppressRevert) {\n', '        // Perform the transfer and pass along the returned boolean (or revert).\n', '        success = token.transfer(recipient, balance);\n', '      } else {\n', '        // Attempt transfer with 1/2 gas, allow reverts, and return call status.\n', '        (success, ) = address(token).call.gas(gasleft() / 2)(\n', '          abi.encodeWithSelector(token.transfer.selector, recipient, balance)\n', '        );\n', '      }\n', '    } else {\n', '      // Skip the transfer and return true as long as the balance check worked.\n', '      success = balanceCheckWorked;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for transferring Ether to a designated recipient.\n', '   * It will return true and emit an `EthWithdrawal` event if Ether was\n', '   * successfully transferred - otherwise, it will return false and emit an\n', '   * `ExternalError` event.\n', '   * @param recipient address payable The account that will receive the Ether.\n', '   * @param amount uint256 The amount of Ether to transfer.\n', '   * @return True if Ether was successfully transferred, else false.\n', '   */\n', '  function _transferETH(\n', '    address payable recipient, uint256 amount\n', '  ) internal returns (bool success) {\n', '    // Attempt to transfer any Ether to caller and emit an event if it fails.\n', '    (success, ) = recipient.call.gas(_ETH_TRANSFER_GAS).value(amount)("");\n', '    if (!success) {\n', '      emit ExternalError(recipient, _revertReason(18));\n', '    } else {\n', '      emit EthWithdrawal(amount, recipient);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function for validating supplied gas (if specified),\n', "   * retrieving the signer's public key from the Dharma Key Registry, deriving\n", '   * the action ID, validating the provided caller and/or signatures using that\n', '   * action ID, and incrementing the nonce. This function serves as the\n', '   * entrypoint for all protected "actions" on the smart wallet, and is the only\n', '   * area where these functions should revert (other than due to out-of-gas\n', '   * errors, which can be guarded against by supplying a minimum action gas\n', '   * requirement).\n', "   * @param action uint8 The type of action, designated by it's index. Valid\n", '   * actions in V8 include Cancel (0), SetUserSigningKey (1), Generic (2),\n', '   * GenericAtomicBatch (3), DAIWithdrawal (10), USDCWithdrawal (5),\n', '   * ETHWithdrawal (6), SetEscapeHatch (7), RemoveEscapeHatch (8), and\n', '   * DisableEscapeHatch (9).\n', '   * @param arguments bytes ABI-encoded arguments for the action.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param userSignature bytes A signature that resolves to the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`. If the user\n', '   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\n', '   * will be used. A unique hash returned from `getCustomActionID` is prefixed\n', '   * and hashed to create the message hash for the signature.\n', '   * @param dharmaSignature bytes A signature that resolves to the public key\n', '   * returned for this account from the Dharma Key Registry. A unique hash\n', '   * returned from `getCustomActionID` is prefixed and hashed to create the\n', '   * signed message.\n', '   * @return The nonce of the current action (prior to incrementing it).\n', '   */\n', '  function _validateActionAndIncrementNonce(\n', '    ActionType action,\n', '    bytes memory arguments,\n', '    uint256 minimumActionGas,\n', '    bytes memory userSignature,\n', '    bytes memory dharmaSignature\n', '  ) internal returns (bytes32 actionID, uint256 actionNonce) {\n', '    // Ensure that the current gas exceeds the minimum required action gas.\n', '    // This prevents griefing attacks where an attacker can invalidate a\n', '    // signature without providing enough gas for the action to succeed. Also\n', '    // note that some gas will be spent before this check is reached - supplying\n', '    // ~30,000 additional gas should suffice when submitting transactions. To\n', '    // skip this requirement, supply zero for the minimumActionGas argument.\n', '    if (minimumActionGas != 0) {\n', '      if (gasleft() < minimumActionGas) {\n', '        revert(_revertReason(19));\n', '      }\n', '    }\n', '\n', '    // Get the current nonce for the action to be performed.\n', '    actionNonce = _nonce;\n', '\n', '    // Get the user signing key that will be used to verify their signature.\n', '    address userSigningKey = _userSigningKey;\n', '\n', '    // Get the Dharma signing key that will be used to verify their signature.\n', '    address dharmaSigningKey = _getDharmaSigningKey();\n', '\n', '    // Determine the actionID - this serves as the signature hash.\n', '    actionID = _getActionID(\n', '      action,\n', '      arguments,\n', '      actionNonce,\n', '      minimumActionGas,\n', '      userSigningKey,\n', '      dharmaSigningKey\n', '    );\n', '\n', '    // Compute the message hash - the hashed, EIP-191-0x45-prefixed action ID.\n', '    bytes32 messageHash = actionID.toEthSignedMessageHash();\n', '\n', '    // Actions other than Cancel require both signatures; Cancel only needs one.\n', '    if (action != ActionType.Cancel) {\n', '      // Validate user signing key signature unless it is `msg.sender`.\n', '      if (msg.sender != userSigningKey) {\n', '        if (\n', '          !_validateUserSignature(\n', '            messageHash, action, arguments, userSigningKey, userSignature\n', '          )\n', '        ) {\n', '          revert(_revertReason(20));\n', '        }\n', '      }\n', '\n', '      // Validate Dharma signing key signature unless it is `msg.sender`.\n', '      if (msg.sender != dharmaSigningKey) {\n', '        if (dharmaSigningKey != messageHash.recover(dharmaSignature)) {\n', '          revert(_revertReason(21));\n', '        }\n', '      }\n', '    } else {\n', '      // Validate signing key signature unless user or Dharma is `msg.sender`.\n', '      if (msg.sender != userSigningKey && msg.sender != dharmaSigningKey) {\n', '        if (\n', '          dharmaSigningKey != messageHash.recover(dharmaSignature) &&\n', '          !_validateUserSignature(\n', '            messageHash, action, arguments, userSigningKey, userSignature\n', '          )\n', '        ) {\n', '          revert(_revertReason(22));\n', '        }\n', '      }\n', '    }\n', '\n', '    // Increment nonce in order to prevent reuse of signatures after the call.\n', '    _nonce++;\n', '  }\n', '\n', '  /**\n', '   * @notice Use all available cTokens to mint the respective dTokens. If any\n', '   * step in the process fails, the call will revert and prior steps will be\n', '   * rolled back. Also note that existing underlying tokens are not included as\n', '   * part of this operation.\n', '   */\n', '  function _migrateCTokenToDToken(AssetType token) internal {\n', '    CTokenInterface cToken;\n', '    DTokenInterface dToken;\n', '\n', '    if (token == AssetType.DAI) {\n', '      cToken = _CDAI;\n', '      dToken = _DDAI;\n', '    } else {\n', '      cToken = _CUSDC;\n', '      dToken = _DUSDC;\n', '    }\n', '\n', '    // Get the current cToken balance for this account.\n', '    uint256 balance = cToken.balanceOf(address(this));\n', '\n', '    // Only perform the conversion if there is a non-zero balance.\n', '    if (balance > 0) {    \n', '      // If the allowance is insufficient, set it before depositing.\n', '      if (cToken.allowance(address(this), address(dToken)) < balance) {\n', '        if (!cToken.approve(address(dToken), uint256(-1))) {\n', '          revert(_revertReason(23));\n', '        }\n', '      }\n', '      \n', '      // Deposit the new balance on the Dharma Token.\n', '      if (dToken.mintViaCToken(balance) == 0) {\n', '        revert(_revertReason(24));\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function to determine whether a call to a given dToken\n', '   * succeeded, and to emit a relevant ExternalError event if it failed.\n', '   * @param asset uint256 The ID of the asset, either Dai (0) or USDC (1).\n', '   * @param functionSelector bytes4 The function selector that was called on the\n', '   * corresponding dToken of the asset type.\n', '   * @param ok bool A boolean representing whether the call returned or\n', '   * reverted.\n', '   * @param data bytes The data provided by the returned or reverted call.\n', '   * @return True if the interaction was successful, otherwise false. This will\n', '   * be used to determine if subsequent steps in the action should be attempted\n', '   * or not, specifically a transfer following a withdrawal.\n', '   */\n', '  function _checkDharmaTokenInteractionAndLogAnyErrors(\n', '    AssetType asset,\n', '    bytes4 functionSelector,\n', '    bool ok,\n', '    bytes memory data\n', '  ) internal returns (bool success) {\n', '    // Log an external error if something went wrong with the attempt.\n', '    if (ok) {\n', '      if (data.length == 32) {\n', '        uint256 amount = abi.decode(data, (uint256));\n', '        if (amount > 0) {\n', '          success = true;\n', '        } else {\n', '          // Get called contract address, name of contract, and function name.\n', '          (address account, string memory name, string memory functionName) = (\n', '            _getDharmaTokenDetails(asset, functionSelector)\n', '          );\n', '\n', '          emit ExternalError(\n', '            account,\n', '            string(\n', '              abi.encodePacked(\n', '                name,\n', '                " gave no tokens calling ",\n', '                functionName,\n', '                "."\n', '              )\n', '            )\n', '          );         \n', '        }\n', '      } else {\n', '        // Get called contract address, name of contract, and function name.\n', '        (address account, string memory name, string memory functionName) = (\n', '          _getDharmaTokenDetails(asset, functionSelector)\n', '        );\n', '\n', '        emit ExternalError(\n', '          account,\n', '          string(\n', '            abi.encodePacked(\n', '              name,\n', '              " gave bad data calling ",\n', '              functionName,\n', '              "."\n', '            )\n', '          )\n', '        );        \n', '      }\n', '      \n', '    } else {\n', '      // Get called contract address, name of contract, and function name.\n', '      (address account, string memory name, string memory functionName) = (\n', '        _getDharmaTokenDetails(asset, functionSelector)\n', '      );\n', '\n', '      // Decode the revert reason in the event one was returned.\n', '      string memory revertReason = _decodeRevertReason(data);\n', '\n', '      emit ExternalError(\n', '        account,\n', '        string(\n', '          abi.encodePacked(\n', '            name,\n', '            " reverted calling ",\n', '            functionName,\n', '            ": ",\n', '            revertReason\n', '          )\n', '        )\n', '      );\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function to diagnose the reason that a call to the USDC\n', '   * contract failed and to emit a corresponding ExternalError event. USDC can\n', '   * blacklist accounts and pause the contract, which can both cause a transfer\n', '   * or approval to fail.\n', '   * @param functionSelector bytes4 The function selector that was called on the\n', '   * USDC contract.\n', '   */\n', '  function _diagnoseAndEmitUSDCSpecificError(bytes4 functionSelector) internal {\n', '    // Determine the name of the function that was called on USDC.\n', '    string memory functionName;\n', '    if (functionSelector == _USDC.transfer.selector) {\n', '      functionName = "transfer";\n', '    } else {\n', '      functionName = "approve";\n', '    }\n', '    \n', '    USDCV1Interface usdcNaughty = USDCV1Interface(address(_USDC));\n', '\n', "    // Find out why USDC transfer reverted (it doesn't give revert reasons).\n", '    if (usdcNaughty.isBlacklisted(address(this))) {\n', '      emit ExternalError(\n', '        address(_USDC),\n', '        string(\n', '          abi.encodePacked(\n', '            functionName, " failed - USDC has blacklisted this user."\n', '          )\n', '        )\n', '      );\n', '    } else { // Note: `else if` breaks coverage.\n', '      if (usdcNaughty.paused()) {\n', '        emit ExternalError(\n', '          address(_USDC),\n', '          string(\n', '            abi.encodePacked(\n', '              functionName, " failed - USDC contract is currently paused."\n', '            )\n', '          )\n', '        );\n', '      } else {\n', '        emit ExternalError(\n', '          address(_USDC),\n', '          string(\n', '            abi.encodePacked(\n', '              "USDC contract reverted on ", functionName, "."\n', '            )\n', '          )\n', '        );\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function to ensure that protected functions can only be\n', '   * called from this contract and that they have the appropriate context set.\n', '   * The self-call context is then cleared. It is used as an additional guard\n', '   * against reentrancy, especially once generic actions are supported by the\n', '   * smart wallet in future versions.\n', '   * @param selfCallContext bytes4 The expected self-call context, equal to the\n', '   * function selector of the approved calling function.\n', '   */\n', '  function _enforceSelfCallFrom(bytes4 selfCallContext) internal {\n', '    // Ensure caller is this contract and self-call context is correctly set.\n', '    if (msg.sender != address(this) || _selfCallContext != selfCallContext) {\n', '      revert(_revertReason(25));\n', '    }\n', '\n', '    // Clear the self-call context.\n', '    delete _selfCallContext;\n', '  }\n', '\n', '  /**\n', "   * @notice Internal view function for validating a user's signature. If the\n", "   * user's signing key does not have contract code, it will be validated via\n", '   * ecrecover; otherwise, it will be validated using ERC-1271, passing the\n', '   * message hash that was signed, the action type, and the arguments as data.\n', '   * @param messageHash bytes32 The message hash that is signed by the user. It\n', '   * is derived by prefixing (according to EIP-191 0x45) and hashing an actionID\n', '   * returned from `getCustomActionID`.\n', "   * @param action uint8 The type of action, designated by it's index. Valid\n", '   * actions in V8 include Cancel (0), SetUserSigningKey (1), Generic (2),\n', '   * GenericAtomicBatch (3), DAIWithdrawal (10), USDCWithdrawal (5),\n', '   * ETHWithdrawal (6), SetEscapeHatch (7), RemoveEscapeHatch (8), and\n', '   * DisableEscapeHatch (9).\n', '   * @param arguments bytes ABI-encoded arguments for the action.\n', '   * @param userSignature bytes A signature that resolves to the public key\n', '   * set for this account in storage slot zero, `_userSigningKey`. If the user\n', '   * signing key is not a contract, ecrecover will be used; otherwise, ERC1271\n', '   * will be used.\n', '   * @return A boolean representing the validity of the supplied user signature.\n', '   */\n', '  function _validateUserSignature(\n', '    bytes32 messageHash,\n', '    ActionType action,\n', '    bytes memory arguments,\n', '    address userSigningKey,\n', '    bytes memory userSignature\n', '  ) internal view returns (bool valid) {\n', '    if (!userSigningKey.isContract()) {\n', '      valid = userSigningKey == messageHash.recover(userSignature);\n', '    } else {\n', '      bytes memory data = abi.encode(messageHash, action, arguments);\n', '      valid = (\n', '        ERC1271Interface(userSigningKey).isValidSignature(\n', '          data, userSignature\n', '        ) == _ERC_1271_MAGIC_VALUE\n', '      );\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal view function to get the Dharma signing key for the smart\n', '   * wallet from the Dharma Key Registry. This key can be set for each specific\n', '   * smart wallet - if none has been set, a global fallback key will be used.\n', '   * @return The address of the Dharma signing key, or public key corresponding\n', '   * to the secondary signer.\n', '   */\n', '  function _getDharmaSigningKey() internal view returns (\n', '    address dharmaSigningKey\n', '  ) {\n', '    dharmaSigningKey = _DHARMA_KEY_REGISTRY.getKey();\n', '  }\n', '\n', '  /**\n', '   * @notice Internal view function that, given an action type and arguments,\n', '   * will return the action ID or message hash that will need to be prefixed\n', '   * (according to EIP-191 0x45), hashed, and signed by the key designated by\n', '   * the Dharma Key Registry in order to construct a valid signature for the\n', '   * corresponding action. The current nonce will be supplied to this function\n', '   * when reconstructing an action ID during protected function execution based\n', '   * on the supplied parameters.\n', "   * @param action uint8 The type of action, designated by it's index. Valid\n", '   * actions in V8 include Cancel (0), SetUserSigningKey (1), Generic (2),\n', '   * GenericAtomicBatch (3), DAIWithdrawal (10), USDCWithdrawal (5),\n', '   * ETHWithdrawal (6), SetEscapeHatch (7), RemoveEscapeHatch (8), and\n', '   * DisableEscapeHatch (9).\n', '   * @param arguments bytes ABI-encoded arguments for the action.\n', '   * @param nonce uint256 The nonce to use.\n', '   * @param minimumActionGas uint256 The minimum amount of gas that must be\n', '   * provided to this call - be aware that additional gas must still be included\n', '   * to account for the cost of overhead incurred up until the start of this\n', '   * function call.\n', '   * @param dharmaSigningKey address The address of the secondary key, or public\n', '   * key corresponding to the secondary signer.\n', '   * @return The action ID, which will need to be prefixed, hashed and signed in\n', '   * order to construct a valid signature.\n', '   */\n', '  function _getActionID(\n', '    ActionType action,\n', '    bytes memory arguments,\n', '    uint256 nonce,\n', '    uint256 minimumActionGas,\n', '    address userSigningKey,\n', '    address dharmaSigningKey\n', '  ) internal view returns (bytes32 actionID) {\n', '    // actionID is constructed according to EIP-191-0x45 to prevent replays.\n', '    actionID = keccak256(\n', '      abi.encodePacked(\n', '        address(this),\n', '        _DHARMA_SMART_WALLET_VERSION,\n', '        userSigningKey,\n', '        dharmaSigningKey,\n', '        nonce,\n', '        minimumActionGas,\n', '        action,\n', '        arguments\n', '      )\n', '    );\n', '  }\n', '\n', '  /**\n', "   * @notice Internal pure function to get the dToken address, it's name, and\n", '   * the name of the called function, based on a supplied asset type and\n', '   * function selector. It is used to help construct ExternalError events.\n', '   * @param asset uint256 The ID of the asset, either Dai (0) or USDC (1).\n', '   * @param functionSelector bytes4 The function selector that was called on the\n', '   * corresponding dToken of the asset type.\n', "   * @return The dToken address, it's name, and the name of the called function.\n", '   */\n', '  function _getDharmaTokenDetails(\n', '    AssetType asset,\n', '    bytes4 functionSelector\n', '  ) internal pure returns (\n', '    address account,\n', '    string memory name,\n', '    string memory functionName\n', '  ) {\n', '    if (asset == AssetType.DAI) {\n', '      account = address(_DDAI);\n', '      name = "Dharma Dai";\n', '    } else {\n', '      account = address(_DUSDC);\n', '      name = "Dharma USD Coin";\n', '    }\n', '\n', "    // Note: since both dTokens have the same interface, just use dDai's.\n", '    if (functionSelector == _DDAI.mint.selector) {\n', '      functionName = "mint";\n', '    } else {\n', '      if (functionSelector == ERC20Interface(account).balanceOf.selector) {\n', '        functionName = "balanceOf";\n', '      } else {\n', '        functionName = string(abi.encodePacked(\n', '          "redeem",\n', '          functionSelector == _DDAI.redeem.selector ? "" : "Underlying"\n', '        ));\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal view function to ensure that a given `to` address provided\n', '   * as part of a generic action is valid. Calls cannot be performed to accounts\n', '   * without code or back into the smart wallet itself. Additionally, generic\n', '   * calls cannot supply the address of the Dharma Escape Hatch registry - the\n', '   * specific, designated functions must be used in order to make calls into it.\n', '   * @param to address The address that will be targeted by the generic call.\n', '   */\n', '  function _ensureValidGenericCallTarget(address to) internal view {\n', '    if (!to.isContract()) {\n', '      revert(_revertReason(26));\n', '    }\n', '    \n', '    if (to == address(this)) {\n', '      revert(_revertReason(27));\n', '    }\n', '\n', '    if (to == address(_ESCAPE_HATCH_REGISTRY)) {\n', '      revert(_revertReason(28));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to ensure that a given action type is a\n', '   * "custom" action type (i.e. is not a generic action type) and to construct\n', '   * the "arguments" input to an actionID based on that action type.\n', "   * @param action uint8 The type of action, designated by it's index. Valid\n", '   * custom actions in V8 include Cancel (0), SetUserSigningKey (1),\n', '   * DAIWithdrawal (10), USDCWithdrawal (5), ETHWithdrawal (6),\n', '   * SetEscapeHatch (7), RemoveEscapeHatch (8), and DisableEscapeHatch (9).\n', '   * @param amount uint256 The amount to withdraw for Withdrawal actions. This\n', '   * value is ignored for all non-withdrawal action types.\n', '   * @param recipient address The account to transfer withdrawn funds to or the\n', '   * new user signing key. This value is ignored for Cancel, RemoveEscapeHatch,\n', '   * and DisableEscapeHatch action types.\n', '   * @return A bytes array containing the arguments that will be provided as\n', '   * a component of the inputs when constructing a custom action ID.\n', '   */\n', '  function _validateCustomActionTypeAndGetArguments(\n', '    ActionType action, uint256 amount, address recipient\n', '  ) internal pure returns (bytes memory arguments) {\n', '    // Ensure that the action type is a valid custom action type.\n', '    bool validActionType = (\n', '      action == ActionType.Cancel ||\n', '      action == ActionType.SetUserSigningKey ||\n', '      action == ActionType.DAIWithdrawal ||\n', '      action == ActionType.USDCWithdrawal ||\n', '      action == ActionType.ETHWithdrawal ||\n', '      action == ActionType.SetEscapeHatch ||\n', '      action == ActionType.RemoveEscapeHatch ||\n', '      action == ActionType.DisableEscapeHatch\n', '    );\n', '    if (!validActionType) {\n', '      revert(_revertReason(29));\n', '    }\n', '\n', '    // Use action type to determine parameters to include in returned arguments.\n', '    if (\n', '      action == ActionType.Cancel ||\n', '      action == ActionType.RemoveEscapeHatch ||\n', '      action == ActionType.DisableEscapeHatch\n', '    ) {\n', '      // Ignore parameters for Cancel, RemoveEscapeHatch, or DisableEscapeHatch.\n', '      arguments = abi.encode();\n', '    } else if (\n', '      action == ActionType.SetUserSigningKey ||\n', '      action == ActionType.SetEscapeHatch\n', '    ) {\n', '      // Ignore `amount` parameter for other, non-withdrawal actions.\n', '      arguments = abi.encode(recipient);\n', '    } else {\n', '      // Use both `amount` and `recipient` parameters for withdrawals.\n', '      arguments = abi.encode(amount, recipient);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to decode revert reasons. The revert reason\n', '   * prefix is removed and the remaining string argument is decoded.\n', '   * @param revertData bytes The raw data supplied alongside the revert.\n', '   * @return The decoded revert reason string.\n', '   */\n', '  function _decodeRevertReason(\n', '    bytes memory revertData\n', '  ) internal pure returns (string memory revertReason) {\n', '    // Solidity prefixes revert reason with 0x08c379a0 -> Error(string) selector\n', '    if (\n', '      revertData.length > 68 && // prefix (4) + position (32) + length (32)\n', '      revertData[0] == byte(0x08) &&\n', '      revertData[1] == byte(0xc3) &&\n', '      revertData[2] == byte(0x79) &&\n', '      revertData[3] == byte(0xa0)\n', '    ) {\n', '      // Get the revert reason without the prefix from the revert data.\n', '      bytes memory revertReasonBytes = new bytes(revertData.length - 4);\n', '      for (uint256 i = 4; i < revertData.length; i++) {\n', '        revertReasonBytes[i - 4] = revertData[i];\n', '      }\n', '\n', '      // Decode the resultant revert reason as a string.\n', '      revertReason = abi.decode(revertReasonBytes, (string));\n', '    } else {\n', '      // Simply return the default, with no revert reason.\n', '      revertReason = _revertReason(uint256(-1));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function call the revert reason helper contract,\n', '   * supplying a revert "code" and receiving back a revert reason string.\n', '   * @param code uint256 The code for the revert reason.\n', '   * @return The revert reason string.\n', '   */\n', '  function _revertReason(\n', '    uint256 code\n', '  ) internal pure returns (string memory reason) {\n', '    reason = _REVERT_REASON_HELPER.reason(code);\n', '  }\n', '}']