['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.10;\n', '\n', 'abstract contract ERC1820Registry {\n', '    function setInterfaceImplementer(\n', '        address _addr,\n', '        bytes32 _interfaceHash,\n', '        address _implementer\n', '    ) external virtual;\n', '\n', '    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash)\n', '        external\n', '        virtual\n', '        view\n', '        returns (address);\n', '\n', '    function setManager(address _addr, address _newManager) external virtual;\n', '\n', '    function getManager(address _addr) public virtual view returns (address);\n', '}\n', '\n', '/// Base client to interact with the registry.\n', 'contract ERC1820Client {\n', '    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(\n', '        0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\n', '    );\n', '\n', '    function setInterfaceImplementation(\n', '        string memory _interfaceLabel,\n', '        address _implementation\n', '    ) internal {\n', '        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n', '        ERC1820REGISTRY.setInterfaceImplementer(\n', '            address(this),\n', '            interfaceHash,\n', '            _implementation\n', '        );\n', '    }\n', '\n', '    function interfaceAddr(address addr, string memory _interfaceLabel)\n', '        internal\n', '        view\n', '        returns (address)\n', '    {\n', '        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n', '        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\n', '    }\n', '\n', '    function delegateManagement(address _newManager) internal {\n', '        ERC1820REGISTRY.setManager(address(this), _newManager);\n', '    }\n', '}\n', '\n', 'contract ERC1820Implementer {\n', '    /**\n', '     * @dev ERC1820 well defined magic value indicating the contract has\n', '     * registered with the ERC1820Registry that it can implement an interface.\n', '     */\n', '    bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(\n', '        abi.encodePacked("ERC1820_ACCEPT_MAGIC")\n', '    );\n', '\n', '    /**\n', '     * @dev Mapping of interface name keccak256 hashes for which this contract\n', '     * implements the interface.\n', '     * @dev Only settable internally.\n', '     */\n', '    mapping(bytes32 => bool) internal _interfaceHashes;\n', '\n', '    /**\n', '     * @notice Indicates whether the contract implements the interface `_interfaceHash`\n', '     * for the address `_addr`.\n', '     * @param _interfaceHash keccak256 hash of the name of the interface.\n', '     * @return ERC1820_ACCEPT_MAGIC only if the contract implements `Ã¬nterfaceHash`\n', '     * for the address `_addr`.\n', '     * @dev In this implementation, the `_addr` (the address for which the\n', '     * contract will implement the interface) is always `address(this)`.\n', '     */\n', '    function canImplementInterfaceForAddress(\n', '        bytes32 _interfaceHash,\n', '        address // Comments to avoid compilation warnings for unused variables. /*addr*/\n', '    ) external view returns (bytes32) {\n', '        if (_interfaceHashes[_interfaceHash]) {\n', '            return ERC1820_ACCEPT_MAGIC;\n', '        } else {\n', '            return "";\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Internally set the fact this contract implements the interface\n', '     * identified by `_interfaceLabel`\n', '     * @param _interfaceLabel String representation of the interface.\n', '     */\n', '    function _setInterface(string memory _interfaceLabel) internal {\n', '        _interfaceHashes[keccak256(abi.encodePacked(_interfaceLabel))] = true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @notice Partition strategy validator hooks for Amp\n', ' */\n', 'interface IAmpPartitionStrategyValidator {\n', '    function tokensFromPartitionToValidate(\n', '        bytes4 _functionSig,\n', '        bytes32 _partition,\n', '        address _operator,\n', '        address _from,\n', '        address _to,\n', '        uint256 _value,\n', '        bytes calldata _data,\n', '        bytes calldata _operatorData\n', '    ) external;\n', '\n', '    function tokensToPartitionToValidate(\n', '        bytes4 _functionSig,\n', '        bytes32 _partition,\n', '        address _operator,\n', '        address _from,\n', '        address _to,\n', '        uint256 _value,\n', '        bytes calldata _data,\n', '        bytes calldata _operatorData\n', '    ) external;\n', '\n', '    function isOperatorForPartitionScope(\n', '        bytes32 _partition,\n', '        address _operator,\n', '        address _tokenHolder\n', '    ) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @title PartitionUtils\n', ' * @notice Partition related helper functions.\n', ' */\n', '\n', 'library PartitionUtils {\n', '    bytes32 public constant CHANGE_PARTITION_FLAG = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n', '\n', '    /**\n', "     * @notice Retrieve the destination partition from the 'data' field.\n", "     * A partition change is requested ONLY when 'data' starts with the flag:\n", '     *\n', '     *   0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n', '     *\n', '     * When the flag is detected, the destination partition is extracted from the\n', '     * 32 bytes following the flag.\n', '     * @param _data Information attached to the transfer. Will contain the\n', '     * destination partition if a change is requested.\n', '     * @param _fallbackPartition Partition value to return if a partition change\n', '     * is not requested in the `_data`.\n', '     * @return toPartition Destination partition. If the `_data` does not contain\n', '     * the prefix and bytes32 partition in the first 64 bytes, the method will\n', '     * return the provided `_fromPartition`.\n', '     */\n', '    function _getDestinationPartition(bytes memory _data, bytes32 _fallbackPartition)\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        if (_data.length < 64) {\n', '            return _fallbackPartition;\n', '        }\n', '\n', '        (bytes32 flag, bytes32 toPartition) = abi.decode(_data, (bytes32, bytes32));\n', '        if (flag == CHANGE_PARTITION_FLAG) {\n', '            return toPartition;\n', '        }\n', '\n', '        return _fallbackPartition;\n', '    }\n', '\n', '    /**\n', '     * @notice Helper to get the strategy identifying prefix from the `_partition`.\n', '     * @param _partition Partition to get the prefix for.\n', '     * @return 4 byte partition strategy prefix.\n', '     */\n', '    function _getPartitionPrefix(bytes32 _partition) internal pure returns (bytes4) {\n', '        return bytes4(_partition);\n', '    }\n', '\n', '    /**\n', '     * @notice Helper method to split the partition into the prefix, sub partition\n', '     * and partition owner components.\n', '     * @param _partition The partition to split into parts.\n', '     * @return The 4 byte partition prefix, 8 byte sub partition, and final 20\n', '     * bytes representing an address.\n', '     */\n', '    function _splitPartition(bytes32 _partition)\n', '        internal\n', '        pure\n', '        returns (\n', '            bytes4,\n', '            bytes8,\n', '            address\n', '        )\n', '    {\n', '        bytes4 prefix = bytes4(_partition);\n', '        bytes8 subPartition = bytes8(_partition << 32);\n', '        address addressPart = address(uint160(uint256(_partition)));\n', '        return (prefix, subPartition, addressPart);\n', '    }\n', '\n', '    /**\n', '     * @notice Helper method to get a partition strategy ERC1820 interface name\n', '     * based on partition prefix.\n', '     * @param _prefix 4 byte partition prefix.\n', '     * @dev Each 4 byte prefix has a unique interface name so that an individual\n', '     * hook implementation can be set for each prefix.\n', '     */\n', '    function _getPartitionStrategyValidatorIName(bytes4 _prefix)\n', '        internal\n', '        pure\n', '        returns (string memory)\n', '    {\n', '        return string(abi.encodePacked("AmpPartitionStrategyValidator", _prefix));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Base contract that satisfies the IAmpPartitionStrategyValidator\n', ' * interface\n', ' */\n', 'contract AmpPartitionStrategyValidatorBase is\n', '    IAmpPartitionStrategyValidator,\n', '    ERC1820Client,\n', '    ERC1820Implementer\n', '{\n', '    /**\n', '     * @notice Partition prefix the hooks are valid for.\n', '     * @dev Must to be set by the parent contract.\n', '     */\n', '    bytes4 public partitionPrefix;\n', '\n', '    /**\n', '     * @notice Amp contract address.\n', '     */\n', '    address public amp;\n', '\n', '    /**\n', '     * @notice Initialize the partition prefix and register the implementation\n', '     * with the ERC1820 registry for the dynamic interface name.\n', '     * @param _prefix Partition prefix the hooks are valid for.\n', '     * @param _amp The address of the Amp contract.\n', '     */\n', '    constructor(bytes4 _prefix, address _amp) public {\n', '        partitionPrefix = _prefix;\n', '\n', '        string memory iname = PartitionUtils._getPartitionStrategyValidatorIName(\n', '            partitionPrefix\n', '        );\n', '        ERC1820Implementer._setInterface(iname);\n', '\n', '        amp = _amp;\n', '    }\n', '\n', '    /**\n', '     * @dev Placeholder to satisfy IAmpPartitionSpaceValidator interface that\n', '     * can be overridden by parent.\n', '     */\n', '    function tokensFromPartitionToValidate(\n', '        bytes4, /* functionSig */\n', '        bytes32, /* fromPartition */\n', '        address, /* operator */\n', '        address, /* from */\n', '        address, /* to */\n', '        uint256, /* value */\n', '        bytes calldata, /* data */\n', '        bytes calldata /* operatorData */\n', '    ) external virtual override {}\n', '\n', '    /**\n', '     * @dev Placeholder to satisfy IAmpPartitionSpaceValidator interface that\n', '     * can be overridden by parent.\n', '     */\n', '    function tokensToPartitionToValidate(\n', '        bytes4, /* functionSig */\n', '        bytes32, /* fromPartition */\n', '        address, /* operator */\n', '        address, /* from */\n', '        address, /* to */\n', '        uint256, /* value */\n', '        bytes calldata, /* data */\n', '        bytes calldata /* operatorData */\n', '    ) external virtual override {}\n', '\n', '    /**\n', '     * @notice Report if address is an operator for a partition based on the\n', "     * partition's strategy.\n", '     * @dev Placeholder that can be overridden by parent.\n', '     */\n', '    function isOperatorForPartitionScope(\n', '        bytes32, /* partition */\n', '        address, /* operator */\n', '        address /* tokenHolder */\n', '    ) external virtual override view returns (bool) {\n', '        return false;\n', '    }\n', '}\n', '\n', '\n', 'interface IAmp {\n', '    function isCollateralManager(address) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @title CollateralPoolPartitionValidator\n', ' */\n', 'contract CollateralPoolPartitionValidator is AmpPartitionStrategyValidatorBase {\n', '    bytes4 constant PARTITION_PREFIX = 0xCCCCCCCC;\n', '\n', '    constructor(address _amp)\n', '        public\n', '        AmpPartitionStrategyValidatorBase(PARTITION_PREFIX, _amp)\n', '    {}\n', '\n', '    /**\n', '     * @notice Reports if the token holder is an operator for the partition.\n', '     * @dev The `_operator` address param is unused. For this strategy, this will\n', '     * be being called on behalf of suppliers, as they have sent their tokens\n', '     * to the collateral manager address, and are now trying to execute a\n', '     * transfer from the pool. This implies that the pool sender hook\n', '     * MUST be implemented in such a way as to restrict any unauthorized\n', '     * transfers, as the partitions affected by this strategy will allow\n', '     * all callers to make an attempt to transfer from the collateral\n', '     * managers partition.\n', '     * @param _partition The partition to check.\n', '     * @param _tokenHolder The collateral manager holding the pool of tokens.\n', '     * @return The operator check for this strategy returns true if the partition\n', '     * owner (identified by the final 20 bytes of the partition) is the\n', '     * same as the token holder address, as in this case the token holder\n', '     * is the collateral manager address.\n', '     */\n', '    function isOperatorForPartitionScope(\n', '        bytes32 _partition,\n', '        address, /* operator */\n', '        address _tokenHolder\n', '    ) external override view returns (bool) {\n', '        require(msg.sender == address(amp), "Hook must be called by amp");\n', '\n', '        (, , address partitionOwner) = PartitionUtils._splitPartition(_partition);\n', '        if (!IAmp(amp).isCollateralManager(partitionOwner)) {\n', '            return false;\n', '        }\n', '\n', '        return _tokenHolder == partitionOwner;\n', '    }\n', '\n', '    /**\n', '     * @notice Validate the rules of the strategy when tokens are being sent to\n', '     * a partition under the purview of the strategy.\n', '     * @dev The `_toPartition` must be formatted with the PARTITION_PREFIX as the\n', '     * first 4 bytes, the `_to` value as the final 20 bytes. The 8 bytes in the\n', '     * middle can be used by the manager to create sub partitions within their\n', '     * impelemntation.\n', '     * @param _toPartition The partition the tokens are transferred to.\n', '     * @param _to The address of the collateral manager.\n', '     */\n', '    function tokensToPartitionToValidate(\n', '        bytes4, /* functionSig */\n', '        bytes32 _toPartition,\n', '        address, /* operator */\n', '        address, /* from */\n', '        address _to,\n', '        uint256, /* value */\n', '        bytes calldata, /* _data */\n', '        bytes calldata /* operatorData */\n', '    ) external override {\n', '        require(msg.sender == address(amp), "Hook must be called by amp");\n', '\n', '        (, , address toPartitionOwner) = PartitionUtils._splitPartition(_toPartition);\n', '\n', '        require(\n', '            _to == toPartitionOwner,\n', '            "Transfers to this partition must be to the partitionOwner"\n', '        );\n', '        require(\n', '            IAmp(amp).isCollateralManager(toPartitionOwner),\n', '            "Partition owner is not a registered collateral manager"\n', '        );\n', '    }\n', '}']