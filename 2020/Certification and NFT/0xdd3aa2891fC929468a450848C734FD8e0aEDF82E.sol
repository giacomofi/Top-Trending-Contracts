['pragma solidity ^0.5.16;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '          return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract LockIdGen {\n', '\n', '    uint256 public requestCount;\n', '\n', '    constructor() public {\n', '        requestCount = 0;\n', '    }\n', '\n', '    function generateLockId() internal returns (bytes32 lockId) {\n', '        return keccak256(abi.encodePacked(blockhash(block.number-1), address(this), ++requestCount));\n', '    }\n', '}\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * This test is non-exhaustive, and there may be false-negatives: during the\n', "     * execution of a contract's constructor, its address will be reported as\n", '     * not containing a contract.\n', '     *\n', '     * IMPORTANT: It is unsafe to assume that an address for which this\n', '     * function returns false is an externally-owned account (EOA) and not a\n', '     * contract.\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(StandardToken token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(StandardToken token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(StandardToken token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(StandardToken token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(StandardToken token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(ERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'contract ManagerUpgradeable is LockIdGen {\n', '\n', '    struct ChangeRequest {\n', '        address proposedNew;\n', '        address proposedClear;\n', '    }\n', '\n', '    // address public custodian;\n', '    mapping (address => address) public managers;\n', '\n', '    mapping (bytes32 => ChangeRequest) public changeReqs;\n', '\n', '    uint256     public    mancount  ;\n', '\n', '    // CONSTRUCTOR\n', '    constructor(\n', '         address  [] memory _mans\n', '    )\n', '      LockIdGen()\n', '      public\n', '    {\n', '        uint256 numMans = _mans.length;\n', '        for (uint256 i = 0; i < numMans; i++) {\n', '          address pto = _mans[i];\n', '          require(pto != address(0));\n', '          managers[pto] = pto;\n', '        }\n', '        mancount = 0;\n', '    }\n', '\n', '\n', '\n', '    modifier onlyManager {\n', '        require(msg.sender == managers[msg.sender],"onlyManger must use");\n', '        _;\n', '    }\n', '\n', '    //replace managers\n', '    function replaceManager(address _new,address _clear) public onlyManager {\n', '        require( _clear != address(0) || _new != address(0) );\n', '\n', '        require( _clear == address(0) || managers[_clear] == _clear);\n', '        \n', '        if(_new != address(0))\n', '        {\n', '            managers[_new] = _new;\n', '            mancount = mancount + 1;\n', '        }\n', '\n', '        if(_clear != address(0))\n', '        {\n', '            delete managers[_clear];\n', '            mancount = mancount - 1;\n', '        }\n', '\n', '    }\n', '    \n', '    // for manager change\n', '    function requestChange(address _new,address _clear) public onlyManager returns (bytes32 lockId) {\n', '        require( _clear != address(0) || _new != address(0) );\n', '\n', '        require( _clear == address(0) || managers[_clear] == _clear);\n', '\n', '        lockId = generateLockId();\n', '\n', '        changeReqs[lockId] = ChangeRequest({\n', '            proposedNew: _new,\n', '            proposedClear: _clear\n', '        });\n', '\n', '        emit ChangeRequested(lockId, msg.sender, _new,_clear);\n', '    }\n', '\n', '    event ChangeRequested(\n', '        bytes32 _lockId,\n', '        address _msgSender,\n', '        address _new,\n', '        address _clear\n', '    );\n', '\n', '   function confirmChange(bytes32 _lockId) public onlyManager {\n', '        ChangeRequest storage changeRequest = changeReqs[_lockId];\n', '        require( changeRequest.proposedNew != address(0) || changeRequest.proposedClear != address(0));\n', '\n', '        if(changeRequest.proposedNew != address(0))\n', '        {\n', '            managers[changeRequest.proposedNew] = changeRequest.proposedNew;\n', '            mancount = mancount + 1;\n', '        }\n', '\n', '        if(changeRequest.proposedClear != address(0))\n', '        {\n', '            delete managers[changeRequest.proposedClear];\n', '            mancount = mancount - 1;\n', '        }\n', '\n', '        delete changeReqs[_lockId];\n', '\n', '        emit ChangeConfirmed(_lockId, changeRequest.proposedNew,changeRequest.proposedClear);\n', '    }\n', '    event ChangeConfirmed(bytes32 _lockId, address _newCustodian, address _clearCustodian);\n', '\n', '    function sweepChange(bytes32 _lockId) public onlyManager {\n', '        ChangeRequest storage changeRequest=changeReqs[_lockId];\n', '        require((changeRequest.proposedNew != address(0) || changeRequest.proposedClear != address(0) ));\n', '        delete changeReqs[_lockId];\n', '        emit ChangeSweep(_lockId, msg.sender);\n', '    }\n', '    event ChangeSweep(bytes32 _lockId, address _sender);\n', '    \n', '    function sweeptoken(address tokenaddr,uint256 amount) public onlyManager{\n', '        TransferHelper.safeTransfer(tokenaddr,msg.sender,amount);\n', '    }\n', '    function sweepeth(uint256 amount) public onlyManager{\n', '        msg.sender.transfer(amount);\n', '    }\n', '}\n', '\n', 'contract ERC20Basic {\n', '    // events\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // public functions\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address addr) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    // events\n', '    event Approval(address indexed owner, address indexed agent, uint256 value);\n', '\n', '    // public functions\n', '    function allowance(address owner, address agent) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address agent, uint256 value) public returns (bool);\n', '\n', '}\n', '\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  // public variables\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals = 18;\n', '\n', '  // internal variables\n', '  uint256 _totalSupply;\n', '  mapping(address => uint256) _balances;\n', '\n', '  // events\n', '\n', '  // public functions\n', '  function totalSupply() public view returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '\n', '  function balanceOf(address addr) public view returns (uint256 balance) {\n', '    return _balances[addr];\n', '  }\n', '\n', '  function transfer(address to, uint256 value) public returns (bool) {\n', '    require(to != address(0));\n', '    require(value <= _balances[msg.sender]);\n', '\n', '    _balances[msg.sender] = _balances[msg.sender].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '    emit Transfer(msg.sender, to, value);\n', '    return true;\n', '  }\n', '\n', '  // internal functions\n', '\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '  // public variables\n', '\n', '  // internal variables\n', '  mapping (address => mapping (address => uint256)) _allowances;\n', '\n', '  // events\n', '\n', '  // public functions\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '    require(to != address(0));\n', '    require(value <= _balances[from],"value lt from");\n', '    require(value <= _allowances[from][msg.sender],"value lt _allowances from ");\n', '\n', '    _balances[from] = _balances[from].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '    _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);\n', '    emit Transfer(from, to, value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address agent, uint256 value) public returns (bool) {\n', '    _allowances[msg.sender][agent] = value;\n', '    emit Approval(msg.sender, agent, value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address owner, address agent) public view returns (uint256) {\n', '    return _allowances[owner][agent];\n', '  }\n', '\n', '  function increaseApproval(address agent, uint value) public returns (bool) {\n', '    _allowances[msg.sender][agent] = _allowances[msg.sender][agent].add(value);\n', '    emit Approval(msg.sender, agent, _allowances[msg.sender][agent]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(address agent, uint value) public returns (bool) {\n', '    uint allowanceValue = _allowances[msg.sender][agent];\n', '    if (value > allowanceValue) {\n', '      _allowances[msg.sender][agent] = 0;\n', '    } else {\n', '      _allowances[msg.sender][agent] = allowanceValue.sub(value);\n', '    }\n', '    emit Approval(msg.sender, agent, _allowances[msg.sender][agent]);\n', '    return true;\n', '  }\n', '  // internal functions\n', '}\n', '\n', '\n', '\n', 'contract MinableToken is StandardToken,ManagerUpgradeable{\n', '    \n', '    \n', '    uint256 maxMined =0;\n', '    constructor(uint256 _maxMined,address [] memory _mans) public ManagerUpgradeable(_mans){\n', '        maxMined = _maxMined;\n', '    }\n', '    \n', '    function _mint(address to, uint256 value) public onlyManager  {\n', '        require(maxMined==0||_totalSupply.add(value)<=maxMined,"_mint value invalid");\n', '        _totalSupply = _totalSupply.add(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(address(0), to, value);\n', '    }\n', '\n', '    function _burn(address from, uint value) public {\n', '        _balances[from] = _balances[from].sub(value);\n', '        _totalSupply = _totalSupply.sub(value);\n', '        emit Transfer(from, address(0), value);\n', '    }\n', '\n', '\n', '}\n', '\n', 'contract DFKII is MinableToken {\n', '  // public variables\n', '  string public name = "Defiking.finance Version 2.0";\n', '  string public symbol = "DFKII";\n', '  uint8 public decimals = 18;\n', '\n', '  // internal variables\n', ' \n', '  // events\n', '\n', '  // public functions\n', '  constructor(address [] memory _mans,uint256 _maxMined) public MinableToken(_maxMined,_mans) {\n', '    //init _totalSupply\n', '    // _totalSupply = 1000*10000 * (10 ** uint256(decimals));\n', '    \n', '    // _balances[msg.sender] = _totalSupply;\n', '    // emit Transfer(address(0x0), msg.sender, _totalSupply);\n', '  }\n', '\n', '  // internal functions\n', '}\n', '\n', 'contract USDT is MinableToken {\n', '  // public variables\n', '  string public name = "Defiking.finance Version 2.0";\n', '  string public symbol = "USDT";\n', '  uint8 public decimals = 6;\n', '\n', '  // internal variables\n', ' \n', '  // events\n', '\n', '  // public functions\n', '  constructor(address [] memory _mans,uint256 _maxMined) public MinableToken(_maxMined,_mans) {\n', '    //init _totalSupply\n', '    // _totalSupply = 1000*10000 * (10 ** uint256(decimals));\n', '    \n', '    // _balances[msg.sender] = _totalSupply;\n', '    // emit Transfer(address(0x0), msg.sender, _totalSupply);\n', '  }\n', '\n', '  // internal functions\n', '}\n', '\n', '\n', 'contract DFK is ManagerUpgradeable {\n', '            \n', '    //liquidity +\n', '    function stakingDeposit(uint256 value) public payable returns (bool);\n', '\n', '    //profit +\n', '    function profit2Staking(uint256 value)public  returns (bool success);\n', '    \n', '    \n', '    function withdrawProfit(address to)public  returns (bool success);\n', '    \n', '    \n', '    function withdrawStaking(address to,uint256 value)public  returns (bool success);\n', '    \n', '    \n', '    function withdrawAll(address to)public  returns (bool success);\n', '\n', '    \n', '    \n', '    function totalMiners() public view returns (uint256);\n', '\n', '    function totalStaking() public view returns (uint256);\n', '\n', '    \n', '    function poolBalance() public view returns (uint256);\n', '\n', '    \n', '    function minedBalance() public view returns (uint256);\n', '\n', '    \n', '    function stakingBalance(address miner) public view returns (uint256);\n', '\n', '\n', '    function profitBalance(address miner) public view returns (uint256);\n', '\n', '    \n', '    \n', '    function pauseStaking()public  returns (bool success);\n', '    \n', '    \n', '    function resumeStaking()public  returns (bool success);\n', '\n', '}\n', '\n', 'contract DFKImplement is DFK {\n', '\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for StandardToken;\n', '\n', '    int public status; \n', '\n', '    struct StakingLog{\n', '        uint256   staking_time;\n', '        uint256   profit_time;\n', '        uint256   staking_value;\n', '        uint256   unstaking_value; \n', '    }\n', '    mapping(address => StakingLog) public stakings;\n', '\n', '    uint256  public cleanup_time;\n', '\n', '    uint256  public profit_period;\n', '\n', '    uint256  public period_bonus; \n', '\n', '    mapping(address => uint256) public balanceProfit;\n', '    mapping(address => uint256) public balanceStaking;\n', '\n', '    StandardToken    public     dfkToken;\n', '\n', '    uint256 public  _totalMiners;\n', '    uint256 public  _totalStaking; \n', '    uint256 public  totalProfit;\n', '\n', '    uint256 public  minePoolBalance; \n', '\n', '    modifier onStaking {\n', '        require(status == 1,"please start minner");\n', '        _;\n', '    }\n', '    event ProfitLog(\n', '        address indexed from,\n', '        uint256 profit_time, \n', '        uint256 staking_value,\n', '        uint256 unstaking_value,\n', '        uint256 profit_times, \n', '        uint256 profit\n', '    );\n', '\n', '    constructor(address _dfkToken,int decimals,address  [] memory _mans) public ManagerUpgradeable(_mans){\n', '        status = 0;\n', '        cleanup_time = now;\n', '        profit_period = 24*3600; \n', '        period_bonus = 100000*(10 ** uint256(decimals));\n', '        cleanup_time = now;\n', '        dfkToken = StandardToken(_dfkToken);\n', '    }\n', '\n', '     \n', '    function addMinePool(uint256 stakevalue) public onStaking payable returns (uint256){\n', '        require(stakevalue>0);\n', '\n', '        // user must call prove first.\n', '        dfkToken.safeTransferFrom(msg.sender,address(this),stakevalue);\n', '\n', '        minePoolBalance = minePoolBalance.add(stakevalue);\n', '\n', '        return minePoolBalance;\n', '    }\n', '\n', '\n', '      \n', '    function stakingDeposit(uint256 stakevalue) public onStaking payable returns (bool){\n', '        require(stakevalue>0,"stakevalue is gt zero");\n', '\n', '        // user must call prove first.\n', '        dfkToken.transferFrom(msg.sender,address(this),stakevalue);\n', '\n', '        _totalStaking = _totalStaking.add(stakevalue);\n', '         \n', '        return addMinerStaking(msg.sender,stakevalue);\n', '    }\n', '\n', '\n', '    function addMinerStaking(address miner,uint256 stakevalue) internal  returns (bool){\n', '        balanceStaking[miner] = balanceStaking[miner].add(stakevalue);\n', '        \n', '        StakingLog memory slog=stakings[miner];\n', '\n', '        if(slog.profit_time < cleanup_time){ \n', '            stakings[miner] = StakingLog({\n', '                staking_time:now,\n', '                profit_time:now,\n', '                staking_value:0,\n', '                unstaking_value:stakevalue\n', '            });\n', '            _totalMiners = _totalMiners.add(1);\n', '        }else if(now.sub(slog.profit_time) >= profit_period){ \n', '            uint256   profit_times = now.sub(slog.profit_time).div(profit_period); \n', '            \n', '            stakings[miner] = StakingLog({\n', '                staking_time:now,\n', '                profit_time:now,\n', '                staking_value:slog.staking_value.add(slog.unstaking_value),\n', '                unstaking_value:stakevalue\n', '            });\n', '            \n', '            \n', '            uint256   profit =  period_bonus.mul(stakings[miner].staking_value).mul(profit_times).div(_totalStaking);\n', '            emit ProfitLog(miner,stakings[miner].profit_time,stakings[miner].staking_value,stakings[miner].unstaking_value,profit_times,profit);\n', '            require(minePoolBalance>=profit,"minePoolBalance lt profit");\n', '            minePoolBalance = minePoolBalance.sub(profit);\n', '\n', '             \n', '            balanceProfit[miner]=balanceProfit[miner].add(profit);\n', '            totalProfit = totalProfit.add(profit);\n', '\n', '        }else { \n', '            stakings[miner] = StakingLog({\n', '                staking_time:now,\n', '                profit_time:slog.profit_time,\n', '                staking_value:slog.staking_value,\n', '                unstaking_value:slog.unstaking_value.add(stakevalue)\n', '            });\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '     \n', '    function profit2Staking(uint256 value)public onStaking returns (bool success){\n', '        \n', '        require(balanceProfit[msg.sender]>=value);\n', '        balanceProfit[msg.sender] = balanceProfit[msg.sender].sub(value);\n', '        return addMinerStaking(msg.sender,value);\n', '\n', '    }\n', '\n', '     \n', '    function withdrawProfit(address to)public  returns (bool success){\n', '        \n', '        require(to != address(0));\n', '\n', '        addMinerStaking(msg.sender,0);\n', '\n', '        uint256 profit = balanceProfit[msg.sender];\n', '        balanceProfit[msg.sender] = 0;\n', '\n', '        require(dfkToken.transfer(to,profit));\n', '\n', '        return true;\n', '\n', '    }\n', '\n', '     \n', '    function withdrawStaking(address to,uint256 value)public  returns (bool success){\n', '        require(value>0);\n', '        require(to != address(0));\n', '        require(balanceStaking[msg.sender]>=value);\n', '        require(_totalStaking>=value);\n', '        \n', '        _totalStaking=_totalStaking.sub(value);\n', '        \n', '        balanceStaking[msg.sender] = balanceStaking[msg.sender].sub(value);\n', '        StakingLog memory slog=stakings[msg.sender];\n', '        \n', '         \n', '        stakings[msg.sender] = StakingLog({\n', '            staking_time:now,\n', '            profit_time:slog.profit_time,\n', '            staking_value:0,\n', '            unstaking_value:balanceStaking[msg.sender]\n', '        });\n', '        \n', '        require(dfkToken.transfer(to,value));\n', '        \n', '        return true;\n', '    }\n', '\n', '      \n', '    function withdrawAll(address to)public  returns (bool success){\n', '        require(to != address(0));\n', '        \n', '        addMinerStaking(msg.sender,0);\n', '        \n', '        _totalStaking=_totalStaking.sub(balanceStaking[msg.sender]);\n', '        \n', '        uint256 total=balanceStaking[msg.sender].add(balanceProfit[msg.sender]);\n', '\n', '        balanceProfit[msg.sender]=0;\n', '        balanceStaking[msg.sender] = 0;\n', '         \n', '        stakings[msg.sender] = StakingLog({\n', '            staking_time:0,\n', '            profit_time:0,\n', '            staking_value:0,\n', '            unstaking_value:0\n', '        });\n', '        // _totalMiners=_totalMiners.sub(1);\n', '        require(dfkToken.transfer(to,total));\n', '        \n', '        return true;\n', '    }\n', '    \n', '    \n', '    function totalMiners() public view returns (uint256){\n', '        return _totalMiners;\n', '    }\n', '\n', '     \n', '    function totalStaking() public view returns (uint256){\n', '        return _totalStaking;\n', '\n', '    }\n', '     \n', '    function poolBalance() public view returns (uint256){\n', '        return minePoolBalance;\n', '    }\n', '\n', '     \n', '    function minedBalance() public view returns (uint256){\n', '        return totalProfit;\n', '    }\n', '\n', '     \n', '    function stakingBalance(address miner) public view returns (uint256){\n', '        return balanceStaking[miner];\n', '    }\n', '\n', '\n', '     \n', '    function profitBalance(address miner) public view returns (uint256){\n', '        return balanceProfit[miner];\n', '    }\n', '\n', '     \n', '    function pauseStaking()public onlyManager  returns (bool ){\n', '        status = 0;\n', '    }\n', '    \n', '     \n', '    function resumeStaking()public onlyManager returns (bool ){\n', '       status = 1;\n', '    }\n', '}\n', '\n', '\n', 'contract DFKImplHelper{\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    DFKImplement public dfkImpl;\n', '    \n', '    constructor(address _dfkImpl) public{\n', '        dfkImpl = DFKImplement(_dfkImpl);\n', '    }\n', '    \n', '    function calcProfit(address miner) public view returns (uint256)\n', '    {\n', '        (,uint256   profit_time,uint256   staking_value,) = dfkImpl.stakings(miner);\n', '        if(profit_time < dfkImpl.cleanup_time()){ \n', '            return 0;\n', '        }else if(now.sub(profit_time) >= dfkImpl.profit_period()){ \n', '            uint256   profit_times = now.sub(profit_time).div(dfkImpl.profit_period()); \n', '            uint256   profit =  dfkImpl.period_bonus().mul(staking_value).mul(profit_times).div(dfkImpl._totalStaking());\n', '            return profit;\n', '        }else { \n', '            return 0;\n', '        }\n', '        \n', '    }\n', '    \n', '    function calcProfitForFee(address miner,uint256 totalFee,uint256 lastFetchFee) public view returns (uint256)\n', '    {\n', '        (,uint256   profit_time,uint256   staking_value,) = dfkImpl.stakings(miner);\n', '        \n', '        if(staking_value == 0) {\n', '            return 0;\n', '        }\n', '        if(profit_time < dfkImpl.cleanup_time()){ \n', '            return 0;\n', '        }else { \n', '            // uint256   profit_times = now.sub(profit_time).div(dfkImpl.profit_period()); \n', '            uint256   profit =  totalFee.mul(staking_value).div(dfkImpl._totalStaking());\n', '            if(profit>lastFetchFee){\n', '                return profit.sub(lastFetchFee);\n', '            }else{\n', '                return 0;\n', '            }\n', '            \n', '        \n', '        }\n', '        \n', '    }\n', '    \n', '    \n', '}\n', '\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '\n', 'contract DTradeLiquids is StandardToken {\n', '  // public variables\n', '  string public name = "Defiking.finance swap";\n', '  string public symbol = "DTrade-V1 LP";\n', '  uint8 public decimals = 18;\n', '\n', '  // internal variables\n', ' \n', '  // events\n', '  address owner;\n', '  // public functions\n', '  constructor() public {\n', '    //init _totalSupply\n', '     owner = msg.sender;\n', '  }\n', '  \n', '  modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '   }\n', '    \n', '  function _mint(address to, uint value) public onlyOwner  {\n', '        _totalSupply = _totalSupply.add(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(address(0), to, value);\n', '    }\n', '\n', '    function _burn(address from, uint value) public onlyOwner{\n', '        _balances[from] = _balances[from].sub(value);\n', '        _totalSupply = _totalSupply.sub(value);\n', '        emit Transfer(from, address(0), value);\n', '    }\n', '  //function initialize(string _symbol) public{\n', '//    symbol = _symbol;\n', ' // }\n', '\n', '  // internal functions\n', '}\n', '\n', '\n', 'interface Refers {\n', '    \n', '    function rewards2Super(address user,uint256 totalReward) external returns (bool);\n', '    \n', '}\n', '\n', '\n', 'contract DFKExPair is ManagerUpgradeable{\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '    \n', '    \n', '    address public token0;//usdt,basic token\n', '    address public token1;//dfkii\n', '    \n', '    uint8   public price_decimal = 8;\n', '    uint256 public cur_price  = 0;\n', '    uint    public fee2Liquid = 22;\n', '    uint    public fee2Refs = 3;\n', '    uint    public fee2Burn = 5;\n', '    uint256 public feeTotal=30;\n', '    uint256 public PRICE_MOD=10000;//基数10000\n', '    uint256 public FEE_MOD=10000;//基数10000\n', '    uint256 public TOKEN_DECIMAL_DIF;//基数10000\n', '    uint256 public reserve0 =0;//liquid.token0\n', '    uint256 public reserve1 =0;//liquid.token1\n', '    uint256 public decimal0;//liquid.token0\n', '    uint256 public decimal1;//liquid.token1\n', '    uint256 public fee = 0;\n', '    uint256 public priceFlips = 1;//flips for each 10000 token1\n', '    uint256 public totalProfitForLiquids =0; //fee.for liquid\n', '    uint256 public totalProfitRefs =0; //fee.for dfk1 staking\n', '    uint256 public totalProfitBurn =0; //fee.for burn\n', '    uint256 public totalLiquids = 0;\n', '    // mapping(address => uint256) public profits4DFK1;\n', '    mapping(address => uint256[]) public liquidBonusLog;\n', '    \n', '    address public liquidToken;//\n', '    \n', '    Refers public  refers;\n', '    address public isDfkiiRefs;\n', '    \n', '    uint256 public unlocked = 0;\n', '    uint256 public miniLiquid = 100000*(10 **18);\n', '    modifier onLiquity {\n', '        require(unlocked == 1,"please wait liquity");\n', '        _;\n', '    }\n', '    \n', '    function pauseLiquity() public onlyManager  returns (bool ){\n', '        unlocked = 0;\n', '    }\n', '    \n', '     \n', '    function resumeLiquity() public onlyManager returns (bool ){\n', '       unlocked = 1;\n', '    }\n', '    \n', '    constructor(address _token0,address _token1,address refs,uint256 initprice,address []memory _mans,uint256 _miniLiquid) public ManagerUpgradeable(_mans){\n', '    //init _totalSupply\n', '        token0 = _token0;\n', '        token1 = _token1;\n', '        if(_token0 == address(0x0)){\n', '            decimal0 = 10 **18;\n', '        } else {\n', '            decimal0 = 10 **uint256(StandardToken(_token0).decimals());\n', '        }\n', '\n', '        if(_token1 == address(0x0)){\n', '            decimal1 = 10 **18;\n', '        } else {\n', '            decimal1 = 10 **uint256(StandardToken(_token1).decimals());\n', '        }        \n', '        \n', '        cur_price = initprice;\n', '        TOKEN_DECIMAL_DIF = decimal1.div(decimal0);\n', '\n', '        refers = Refers(refs);        \n', '        bytes memory bytecode = type(DTradeLiquids).creationCode;\n', '        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n', '        address _swapV2;\n', '        assembly {\n', '            _swapV2 := create2(0, add(bytecode, 32), mload(bytecode), salt)\n', '        }\n', '\n', '        liquidToken = _swapV2;\n', '\t\t\n', '\t\tminiLiquid=_miniLiquid;\n', '        \n', '    } \n', '    \n', '    function setPriceMod(uint256 price_mod) onlyManager public {\n', '        require(price_mod>0);\n', '        PRICE_MOD=price_mod;\n', '    }\n', '    \n', '\n', '    //修正价格，手续费分配比例\n', '    function fixPrice (uint256 price,uint _fee2Liquid,uint _fee2Refs,uint _fee2Burn,uint256 _priceFlips,uint256 _miniLiquid) onlyManager public {\n', '        cur_price = price;\n', '        fee2Liquid = _fee2Liquid;\n', '        fee2Refs = _fee2Refs;\n', '        fee2Burn = _fee2Burn;\n', '        feeTotal = fee2Liquid+fee2Refs+fee2Burn;\n', '        priceFlips = _priceFlips;\n', '        miniLiquid=_miniLiquid;\n', '    }\n', '    \n', '    \n', '    //增加池子流动性\n', '    function poolTokens(uint256 amount0,uint256 amount1) payable onlyManager public {\n', '        if(token0 == address(0x0)){\n', '            require(msg.value>=amount0);\n', '        } else{\n', '            TransferHelper.safeTransferFrom(token0,msg.sender,address(this),amount0);\n', '        }        \n', '\n', '        if(token1 == address(0x0)){\n', '            require(msg.value>=amount1,"eth not enough");\n', '        }else{\n', '            TransferHelper.safeTransferFrom(token1,msg.sender,address(this),amount1);\n', '        }   \n', '         \n', '        reserve0 = reserve0.add(amount0);\n', '        reserve1 = reserve1.add(amount1);\n', '    }\n', '    event TotalEvent(\n', '        uint256 totalProfitBurn,\n', '        uint256 totalProfitRefs,\n', '        uint256 totalProfitForLiquids,\n', '        uint256 cur_price,\n', '        uint256 liquidfee,\n', '        uint256 liquidRefs,\n', '        uint256 liquidburn\n', '        );\n', '    event TotalAmount(\n', '        uint256 amount0,\n', '        uint256 amount1,\n', '        uint256 avg_price,\n', '        uint256 fee\n', '        );\n', '\n', '    //swap token0 or token1\n', '    function swap(uint256 amount0,uint256 amount1 ,bool toLiquids) payable public returns(uint256,uint256){\n', '        \n', '        require(cur_price>0);\n', '        \n', '        if(amount1>0 && amount0 == 0){//sell token get basic token\n', '            //uint256 price_float = amount1.mul(priceFlips).div(decimal1).div(PRICE_MOD);\n', '            \n', '            // require (ERC20(token1).balanceOf(msg.sender) >= amount1 );\n', '\n', '            uint256 price_float = amount1.mul(priceFlips).div(decimal1);\n', '            require(price_float<cur_price,"too large amount");\n', '            uint256 next_price = cur_price.sub(price_float);\n', '            uint256 avg_price = cur_price.add(next_price).div(2);\n', '\n', '            if(token1 == address(0x0)){\n', '                require(msg.value>=amount1);\n', '            }else{\n', '                require (ERC20(token1).balanceOf(msg.sender) >= amount1 );\n', '                TransferHelper.safeTransferFrom(token1,msg.sender,address(this),amount1);\n', '            }  \n', '\n', '            uint256 liquidfee = amount1.mul(fee2Liquid).div(FEE_MOD);\n', '            uint256 liquidRefs = amount1.mul(fee2Refs).div(FEE_MOD);\n', '            uint256 liquidburn = amount1.mul(fee2Burn).div(FEE_MOD);\n', '\n', '            amount1 = amount1.sub(liquidfee).sub(liquidRefs).sub(liquidburn);\n', '            \n', '            if(address(refers)!=address(0x0)){\n', '                TransferHelper.safeTransfer(token1,address(refers),liquidRefs);\n', '                refers.rewards2Super(msg.sender,liquidRefs);\n', '            }\n', '\n', '            totalProfitBurn = totalProfitBurn.add(liquidburn);\n', '            totalProfitRefs = totalProfitRefs.add(liquidRefs);\n', '            totalProfitForLiquids = totalProfitForLiquids.add(liquidfee);\n', '            \n', '            amount0 = amount1.mul(avg_price).div(TOKEN_DECIMAL_DIF).div(PRICE_MOD);\n', '            cur_price = next_price;\n', '            if(toLiquids){\n', '                reserve0 = reserve0.add(amount0);\n', '                reserve1 = reserve1.add(amount1);\n', '            }else{\n', '                if(token0==address(0x0))\n', '                {//eth\n', '                   msg.sender.transfer(amount0);\n', '                }else{\n', '                    TransferHelper.safeTransfer(token0,msg.sender,amount0);\n', '                }\n', '                \n', '            }\n', '        }\n', '        else if(amount0 > 0  && amount1 == 0){//using eth/usdt to buy token1\n', '            if(token0 == address(0x0)) {\n', '                require(msg.value >= amount0 );\n', '            } else {\n', '                require (ERC20(token0).balanceOf(msg.sender) >= amount0  );\n', '                TransferHelper.safeTransferFrom(token0,msg.sender,address(this),amount0);\n', '            }\n', '                        \n', '            amount1 = amount0.mul(PRICE_MOD).div(cur_price);\n', '\n', '            uint256 price_float = amount1.mul(priceFlips).div(decimal0);\n', '            uint256 next_price = cur_price.add(price_float);\n', '\n', '            uint256 avg_price = cur_price.add(next_price).div(2);\n', '            amount1 = amount0.mul(TOKEN_DECIMAL_DIF).mul(PRICE_MOD).div(avg_price);\n', '\n', '            \n', '            uint256 liquidfee = amount1.mul(fee2Liquid).div(FEE_MOD);\n', '            uint256 liquidRefs = amount1.mul(fee2Refs).div(FEE_MOD);\n', '            uint256 liquidburn = amount1.mul(fee2Burn).div(FEE_MOD);\n', '            \n', '            amount1 = amount1.sub(liquidfee).sub(liquidRefs).sub(liquidburn);\n', '            \n', '            if(address(refers)!=address(0x0)){\n', '                TransferHelper.safeTransfer(token1,address(refers),liquidRefs);\n', '                refers.rewards2Super(msg.sender,liquidRefs);\n', '            }\n', '            \n', '            totalProfitBurn = totalProfitBurn.add(liquidburn);\n', '            totalProfitRefs = totalProfitRefs.add(liquidRefs);\n', '            totalProfitForLiquids = totalProfitForLiquids.add(liquidfee);\n', '            cur_price = next_price;\n', '            if(toLiquids){\n', '                reserve0 = reserve0.add(amount0);\n', '                reserve1 = reserve1.add(amount1);\n', '            }else{\n', '                if(token1 == address(0x0)){\n', '                    msg.sender.transfer(amount1);\n', '                }else{\n', '                    TransferHelper.safeTransfer(token1,msg.sender,amount1);\n', '                }       \n', '\n', '            }\n', '\n', '        }\n', '        \n', '        return (amount0,amount1);\n', '    }\n', '    \n', '    \n', '    function addLiquid(uint256 amount0) public onLiquity  payable  returns(uint256) {\n', '\n', '        if(token0 == address(0x0)){\n', '            require (msg.value >= amount0);\n', '        }else{\n', '            require (ERC20(token0).balanceOf(msg.sender) >= amount0  );\n', '            TransferHelper.safeTransferFrom(token0,msg.sender,address(this),amount0.div(2));\n', '        }\n', '\n', '        (,uint256 buyamount1) = swap(amount0.div(2),0,true);\n', '        \n', '        uint256 totalLiquid = reserve1.add(reserve1);\n', '        uint256 poolLiquid = ERC20(address(token1)).balanceOf(address(this));\n', '        if(poolLiquid<miniLiquid){\n', '            poolLiquid=miniLiquid;\n', '        }\n', '\n', '        uint256 mineCoin = buyamount1.add(buyamount1).mul(totalLiquid).div(poolLiquid);\n', '        DTradeLiquids(liquidToken)._mint(msg.sender,mineCoin);\n', '        uint256 leftCoin = amount0.sub(amount0.div(2).mul(2));\n', '        if(leftCoin>0&&token0!=address(0x0)){\n', '            TransferHelper.safeTransferFrom(token0,msg.sender,address(this),leftCoin);\n', '        }\n', '        return mineCoin;\n', '    }\n', '    \n', '    function removeLiquid(uint256 amountL) payable public returns(uint256,uint256) {\n', '        require(DTradeLiquids(liquidToken).balanceOf(msg.sender)>=amountL);\n', '        \n', '        uint256 totalLiquid = reserve1.add(reserve1);\n', '        uint256 amount1 = amountL.mul((ERC20(address(token1)).balanceOf(address(this)))).div(totalLiquid).div(2);\n', '        uint256 amount0 = amount1.mul(cur_price).div(TOKEN_DECIMAL_DIF).div(PRICE_MOD);\n', '        \n', '        require(ERC20(token1).balanceOf(address(this))>=amount1);\n', '        \n', '        reserve1 = reserve1.sub(amount1);\n', '        reserve0 = reserve0.sub(amount0);\n', '        \n', '        DTradeLiquids(liquidToken)._burn(msg.sender,amountL);\n', '        \n', '        if(token0==address(0x0))\n', '        {//eth\n', '            require(address(this).balance>=amount0);\n', '            msg.sender.transfer(amount0);\n', '        }else{\n', '            require(ERC20(token0).balanceOf(address(this))>=amount0);\n', '            TransferHelper.safeTransfer(token0,msg.sender,amount0);\n', '        }\n', '        \n', '        if(token1==address(0x0))\n', '        {//eth\n', '            require(address(this).balance>=amount1);\n', '            msg.sender.transfer(amount1);\n', '        }else{\n', '            require(ERC20(token1).balanceOf(address(this))>=amount1);\n', '            TransferHelper.safeTransfer(token1,msg.sender,amount1);\n', '        }\n', '        \n', '        return (amount0,amount1);\n', '    }  \n', '    \n', '   \n', '}\n', '\n', '\n', 'contract UserRefers is ManagerUpgradeable,Refers{\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '    \n', '    mapping(address => address) public relations;\n', '    mapping(address => address[]) public superiors;\n', '    mapping(address => address) public callers;\n', '    mapping(address => uint256) public rewards;\n', '    \n', '    address public topAddr;\n', '    address public token;\n', '    \n', '    constructor(address _token,address []memory _mans) public ManagerUpgradeable(_mans){\n', '        relations[address(0x0)] = address(0x0);\n', '        topAddr = msg.sender;\n', '        token = _token;\n', '    }\n', '    \n', '    function addCaller(address _newCaller) onlyManager public {\n', '        callers[_newCaller] = _newCaller;\n', '    }\n', '    \n', '    function removeCaller(address rmCaller) onlyManager public {\n', '        callers[rmCaller] = address(0x0);\n', '    }\n', '    \n', '\n', '    function buildSuperoir(address ref,uint256 maxLayer) public {\n', '        if(relations[msg.sender]==address(0x0)) {\n', '            relations[msg.sender] = ref;\n', '            superiors[msg.sender].push(ref);\n', '            address[] memory supers = superiors[ref];\n', '            if(supers.length>0){\n', '                superiors[msg.sender].push(supers[0]);\n', '            }\n', '            uint256 cc = 2;\n', '            for(uint256 i=1;i<supers.length && cc < maxLayer;i++){\n', '                superiors[msg.sender].push(supers[i]);\n', '                cc++;\n', '            }\n', '        }\n', '    }\n', '    function withdrawRewards() public{\n', '        require(rewards[msg.sender]>0);\n', '        TransferHelper.safeTransfer(token,msg.sender,rewards[msg.sender]);\n', '        rewards[msg.sender] = 0;\n', '    }\n', '    // 0.03%分配给邀请人（其中0.01%分配给直接推荐人30%，0.005%分配给间接推荐人,15%,0.015%均分给第3代至第12代）\n', '    function rewards2Super(address user,uint256 totalReward) external returns (bool)\n', '    {\n', '        require(callers[msg.sender]==msg.sender,"caller is empty") ;\n', '        // rewards[user] = rewards[user].add(totalReward);\n', '        address[] memory supers = superiors[user];\n', '        uint256 leftReward = totalReward;\n', '        uint256 bonus0;\n', '        uint256 bonus1;\n', '        uint256 bonus2;\n', '        if(supers.length>0){\n', '            uint256 bonus = totalReward.mul(30).div(100);\n', '            rewards[supers[0]] = bonus;\n', '            // TransferHelper.safeTransfer(token,supers[0],bonus);\n', '            leftReward = leftReward.sub(bonus);\n', '            bonus0=bonus;\n', '        }\n', '        if(supers.length>1){\n', '            uint256 bonus = totalReward.mul(15).div(100);\n', '            rewards[supers[1]] = bonus;\n', '            // TransferHelper.safeTransfer(token,supers[1],bonus);\n', '            leftReward = leftReward.sub(bonus);\n', '            bonus1=bonus;\n', '        }\n', '        if(supers.length>2){\n', '            uint256 preReward = leftReward.div(supers.length.sub(2));\n', '        \n', '            for(uint256 i=2;i<supers.length ;i++){\n', '                // TransferHelper.safeTransfer(token,supers[i],preReward);\n', '                rewards[supers[i]] = preReward;\n', '                leftReward = leftReward.sub(preReward);\n', '            }\n', '\n', '            bonus2=preReward;\n', '        }\n', '        if(leftReward>0){\n', '            // TransferHelper.safeTransfer(token,topAddr,leftReward);\n', '            rewards[topAddr] = leftReward;\n', '        }\n', '        return true;\n', '        \n', '    }\n', '    \n', '\n', '}\n', 'contract TestRefs {\n', '    \n', '    \n', '    Refers public refs;\n', '    constructor(address _ref) public {\n', '        refs =  Refers(_ref);\n', '    }\n', '    \n', '    function testReward(uint256 amount) public {\n', '        refs.rewards2Super(msg.sender,amount);\n', '    }\n', '    \n', '}\n', '\n', '\n', 'contract DTrade is ManagerUpgradeable{\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '    mapping(address => mapping(address =>uint256 )) public uniswapLiquids;//(liquid.addr=>(user.address=>amount)\n', '\n', '    mapping(address => address) public liquidsMap;\n', '    mapping(address => uint256)public  liquidPools;\n', '\n', '    mapping(address => uint256) public profits4DFK1;\n', '    mapping(address => uint256) public bonusWithdraw;\n', '    mapping(address => uint256) public checkpointHistory;\n', '    \n', '    mapping(address => uint256) public joinTime;\n', '    address [] public liquidPairs;\n', '\n', '    uint256  public  peroid_total_bonus = 90000*(10 **18);\n', '    uint256   public peroid_left_bonus = 0;\n', '    uint256  public bonus_per_block = 9*(10 **18);\n', '    uint256   public bonus_percent_LP = 10;\n', '    \n', '    uint256   public checkpoint_number = 0;    \n', '    // uint256   totalProfitDFK1 = 0;\n', '    \n', '    uint256   public totalLiquids;\n', '\n', '    uint256   public  totalMint;\n', '    DFKImplHelper public dfk1Helper;\n', '    \n', '    uint256   public peroid_mined_coin = 0;\n', '    \n', '    address public token1;\n', '\n', '    uint256 public totalFactor = 0;\n', '\n', '    address public liquidToken;\n', '    \n', '    DFKII   public dfkii;\n', '    \n', '    constructor(address _token1,address []memory _mans) public ManagerUpgradeable(_mans){\n', '        token1 = _token1;\n', '        checkpoint_number = block.number+5*60;\n', '        \n', '        bytes memory bytecode = type(DTradeLiquids).creationCode;\n', '        bytes32 salt = keccak256(abi.encodePacked(msg.sender, token1));\n', '        address _swapV2;\n', '        assembly {\n', '            _swapV2 := create2(0, add(bytecode, 32), mload(bytecode), salt)\n', '        }\n', '\n', '        liquidToken = _swapV2;\n', '        \n', '    }\n', '    \n', '    function setDFKII(address _dfkii) public onlyManager {\n', '        dfkii = DFKII(_dfkii);\n', '    }\n', '    \n', '    function setDfk1Helper(address _dfk1Helper) public onlyManager {\n', '        dfk1Helper = DFKImplHelper(_dfk1Helper);\n', '    }\n', '    \n', '    \n', '    function nextPeroid(uint256 total,uint256 perblock,uint256 percentLP) public onlyManager {\n', '               \n', '        totalMint = totalMint.add(peroid_total_bonus);\n', '        peroid_total_bonus = total;\n', '        bonus_per_block = perblock;\n', '        bonus_percent_LP = percentLP;\n', '        peroid_left_bonus = total;\n', '        peroid_mined_coin = 0;\n', '        checkpoint_number = block.number;\n', '        joinTime[address(0x0)] = block.number;\n', '        \n', '    }\n', '    \n', '    function addUniswapPair(address uniAddr,uint256 factor) public onlyManager  {\n', '        if(liquidsMap[uniAddr]==address(0x0)){\n', '            uniswapLiquids[uniAddr][address(0x0)]=factor;\n', '            totalFactor = totalFactor.add(factor);\n', '            // uniswapLiquids[address(0x0)][address(0x0)] = uniswapLiquids[address(0x0)][address(0x0)].add(factor);\n', '            liquidsMap[uniAddr] = uniAddr;\n', '            liquidPairs.push(uniAddr);\n', '\n', '        }\n', '    }\n', '    \n', '    function removeUniswapPair(address uniAddr) public onlyManager  {\n', '        totalFactor = totalFactor.sub(uniswapLiquids[uniAddr][address(0x0)]);\n', '        uniswapLiquids[uniAddr][address(0x0)]=0;\n', '    }\n', '\n', '    function addDfkPair(address uniAddr,uint256 factor) public onlyManager  {\n', '        if(liquidsMap[uniAddr]==address(0x0)){\n', '            uniswapLiquids[uniAddr][address(0x0)]=factor;\n', '            totalFactor = totalFactor.add(factor);\n', '            liquidsMap[uniAddr] = uniAddr;\n', '            liquidPairs.push(uniAddr);\n', '        }\n', '    }\n', '    \n', '    function removeDfkPair(address uniAddr) public onlyManager  {\n', '        totalFactor = totalFactor.sub(uniswapLiquids[uniAddr][address(0x0)]);\n', '        uniswapLiquids[uniAddr][address(0x0)]=0;\n', '    }\n', '\n', '    \n', '    function addLiquid(address uniAddr,uint256 amountUL) public  {\n', '        require(uniswapLiquids[uniAddr][address(0x0)]>0);//factor must large than zero\n', '        uint256  realBonus=calcBonus(msg.sender);\n', '        if(realBonus>0)\n', '        {\n', '            dfkii._mint(msg.sender,realBonus);\n', '        }\n', '        \n', '        TransferHelper.safeTransferFrom(uniAddr,msg.sender,address(this),amountUL);\n', '        liquidPools[uniAddr] = liquidPools[uniAddr].add(amountUL);\n', '        uniswapLiquids[uniAddr][msg.sender]=uniswapLiquids[uniAddr][msg.sender].add(amountUL);\n', '\n', '        uint256 mine_liquid=amountUL.mul(uniswapLiquids[uniAddr][address(0x0)]);\n', '        // totalLiquids = totalLiquids.add(mine_liquid);\n', '        DTradeLiquids(liquidToken)._mint(msg.sender,mine_liquid);\n', '        \n', '        joinTime[msg.sender] = block.number;\n', '        bonusWithdraw[msg.sender] = 0;\n', '    }\n', '    \n', '    function removeLiquid(address uniAddr,uint256 amountUL) public  {\n', "        require(uniswapLiquids[uniAddr][msg.sender]>=amountUL,'amountUL is not enough');  \n", '\n', '        uint256  realBonus=calcBonus(msg.sender);\n', '        if(realBonus>0)\n', '        {\n', '            dfkii._mint(msg.sender,realBonus);\n', '        }          \n', '              \n', '        TransferHelper.safeTransfer(address(uniAddr),msg.sender,amountUL); \n', '        uint256 mine_liquid=amountUL.mul(uniswapLiquids[uniAddr][address(0x0)]);\n', '        DTradeLiquids(liquidToken)._burn(msg.sender,mine_liquid);        \n', '        uniswapLiquids[uniAddr][msg.sender]=uniswapLiquids[uniAddr][msg.sender].sub(amountUL);\n', '        \n', '        if(DTradeLiquids(liquidToken).balanceOf(msg.sender)==0){\n', '            joinTime[msg.sender] = 0;\n', '        }\n', '        else\n', '        {\n', '            joinTime[msg.sender] = block.number;\n', '        }\n', '        bonusWithdraw[msg.sender] = 0;\n', '    }\n', '    \n', '    function mintCoin(address user) public view returns (uint256){\n', '        if(joinTime[user]==0){\n', '            return 0;\n', '        }\n', '        uint256 checkTime = checkpoint_number;\n', '        if(joinTime[user]>checkpoint_number){\n', '            checkTime = joinTime[user];\n', '        }\n', '        uint256 currentBonus = bonus_per_block.mul(block.number.sub(checkTime));\n', '        if(currentBonus>peroid_left_bonus){\n', '            currentBonus = peroid_left_bonus;\n', '        }\n', '        \n', '        //\n', '        return currentBonus;\n', '         \n', '        \n', '    }\n', '\n', '   \n', '    modifier onlyJoin {\n', '        require(joinTime[msg.sender] > 0,"onlyJoin time gt 0");\n', '        _;\n', '    }\n', '\n', '    function calcDFK1Bonus(address addr) public view returns(uint256){\n', '        if(joinTime[msg.sender] == 0){\n', '            return 0;\n', '        }\n', '        return dfk1Helper.calcProfitForFee(addr,mintCoin(address(0x0)).mul(bonus_percent_LP).div(100),profits4DFK1[addr]);\n', '    }\n', '    \n', '    function withdrawDFK1Bonus() public onlyJoin returns(uint256){\n', '        \n', '        uint256 bonus=calcDFK1Bonus(msg.sender);\n', '        if(bonus>0){\n', '            profits4DFK1[msg.sender] = profits4DFK1[msg.sender].add(bonus);\n', '            // totalProfitDFK1 = totalProfitDFK1.sub(bonus);\n', '            // TransferHelper.safeTransfer(token1,msg.sender,bonus);\n', '            dfkii._mint(msg.sender,bonus);\n', '            return bonus;\n', '        }else{\n', '            return 0;\n', '        }\n', '            \n', '    }\n', '    \n', '\n', '    function withdrawBonus() public onlyJoin returns(uint256){\n', '        uint256  realBonus=calcBonus(msg.sender);\n', '        if(realBonus>0)\n', '        {\n', '            bonusWithdraw[msg.sender] = bonusWithdraw[msg.sender].add(realBonus);\n', '            dfkii._mint(msg.sender,realBonus);\n', '            \n', '            joinTime[msg.sender] = block.number;\n', '            bonusWithdraw[msg.sender] = 0;\n', '        }\n', '        return realBonus;\n', '    }\n', '\n', '    function calcBonus(address addr) public view returns (uint256){\n', '        if(joinTime[addr] == 0){\n', '            return 0;\n', '        }\n', '        if(joinTime[addr]<block.number){\n', '            return (ERC20(liquidToken).balanceOf(addr)).div(ERC20(liquidToken).totalSupply()).mul(mintCoin(addr));\n', '        }else{\n', '            return 0;\n', '        }\n', '        \n', '    }\n', '}\n', '\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    // function safeTransferETH(address to, uint value) internal {\n', '    //     (bool success,bt) = to.call{value:value}(new bytes(0));\n', "    //     require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    // }\n', '}']