['pragma solidity 0.6.0;\n', '\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', ' \n', '\n', '\n', '/**\n', ' * @title ERC1132 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/1132\n', ' */\n', '\n', 'abstract contract ERC1132 {\n', '    /**\n', "     * @dev Reasons why a user's tokens have been locked\n", '     */\n', '    mapping(address => bytes32[]) public lockReason;\n', '\n', '    /**\n', '     * @dev locked token structure\n', '     */\n', '    struct lockToken {\n', '        uint256 amount;\n', '        uint256 validity;\n', '        bool claimed;\n', '    }\n', '\n', '    /**\n', '     * @dev Holds number & validity of tokens locked for a given reason for\n', '     *      a specified address\n', '     */\n', '    mapping(address => mapping(bytes32 => lockToken)) public locked;\n', '\n', '    /**\n', '     * @dev Records data of all the tokens Locked\n', '     */\n', '    event Locked(\n', '        address indexed _of,\n', '        bytes32 indexed _reason,\n', '        uint256 _amount,\n', '        uint256 _validity\n', '    );\n', '\n', '    /**\n', '     * @dev Records data of all the tokens unlocked\n', '     */\n', '    event Unlocked(\n', '        address indexed _of,\n', '        bytes32 indexed _reason,\n', '        uint256 _amount\n', '    );\n', '    \n', '    /**\n', '     * @dev Locks a specified amount of tokens against an address,\n', '     *      for a specified reason and time\n', '     * @param _reason The reason to lock tokens\n', '     * @param _amount Number of tokens to be locked\n', '     * @param _time Lock time in seconds\n', '     */\n', '    function lock(string memory _reason, uint256 _amount, uint256 _time)\n', '        public virtual returns (bool);\n', '  \n', '    /**\n', '     * @dev Returns tokens locked for a specified address for a\n', '     *      specified reason\n', '     *\n', '     * @param _of The address whose tokens are locked\n', '     * @param _reason The reason to query the lock tokens for\n', '     */\n', '    function tokensLocked(address _of, string memory _reason)\n', '        public virtual view returns (uint256 amount);\n', '    \n', '    /**\n', '     * @dev Returns tokens locked for a specified address for a\n', '     *      specified reason at a specific time\n', '     *\n', '     * @param _of The address whose tokens are locked\n', '     * @param _reason The reason to query the lock tokens for\n', '     * @param _time The timestamp to query the lock tokens for\n', '     */\n', '    function tokensLockedAtTime(address _of, string memory _reason, uint256 _time)\n', '        public virtual view returns (uint256 amount);\n', '    \n', '    /**\n', '     * @dev Returns total tokens held by an address (locked + transferable)\n', '     * @param _of The address to query the total balance of\n', '     */\n', '    function totalBalanceOf(address _of)\n', '        public virtual view returns (uint256 amount);\n', '    \n', '    /**\n', '     * @dev Extends lock for a specified reason and time\n', '     * @param _reason The reason to lock tokens\n', '     * @param _time Lock extension time in seconds\n', '     */\n', '    function extendLock(string memory _reason, uint256 _time)\n', '        public virtual returns (bool);\n', '    \n', '    /**\n', '     * @dev Increase number of tokens locked for a specified reason\n', '     * @param _reason The reason to lock tokens\n', '     * @param _amount Number of tokens to be increased\n', '     */\n', '    function increaseLockAmount(string memory _reason, uint256 _amount)\n', '        public virtual returns (bool);\n', '\n', '    /**\n', '     * @dev Returns unlockable tokens for a specified address for a specified reason\n', '     * @param _of The address to query the the unlockable token count of\n', '     * @param _reason The reason to query the unlockable tokens for\n', '     */\n', '    function tokensUnlockable(address _of, string memory _reason)\n', '        public virtual view returns (uint256 amount);\n', ' \n', '    /**\n', '     * @dev Unlocks the unlockable tokens of a specified address\n', '     * @param _of Address of user, claiming back unlockable tokens\n', '     */\n', '    function unlock(address _of)\n', '        public virtual returns (uint256 unlockableTokens);\n', '\n', '    /**\n', '     * @dev Gets the unlockable tokens of a specified address\n', '     * @param _of The address to query the the unlockable token count of\n', '     */\n', '    function getUnlockableTokens(address _of)\n', '        public virtual view returns (uint256 unlockableTokens);\n', '\n', '}\n', '\n', 'interface IDotTokenContract{\n', '  function balanceOf(address account) external view returns (uint256);\n', '  function totalSupply() external view returns (uint256);\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '  function approve(address spender, uint256 amount) external returns (bool);\n', '}\n', '\n', '\n', '\n', 'contract LockDotTokenContract is ERC1132, Ownable {\n', '    using SafeMath for uint;\n', '   /**\n', '    * @dev Error messages for require statements\n', '    */\n', "    string internal constant ALREADY_LOCKED = 'Tokens already locked';\n", "    string internal constant NOT_LOCKED = 'No tokens locked';\n", "    string internal constant AMOUNT_ZERO = 'Amount can not be 0';\n", '    IDotTokenContract private token;\n', '\n', '    /*string public name;\n', '    string public symbol;\n', '    uint8 public decimals;*/\n', '\n', '   /**\n', '    * @dev constructor to mint initial tokens\n', '    * Shall update to _mint once openzepplin updates their npm package.\n', '    */\n', '    constructor(address dotxTokenAddress) public {\n', '        token = IDotTokenContract(dotxTokenAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev Locks a specified amount of tokens against an address,\n', '     *      for a specified reason and time\n', '     * @param _reason The reason to lock tokens\n', '     * @param _amount Number of tokens to be locked\n', '     * @param _time Lock time in seconds\n', '     */\n', '    function lock(string memory _reason, uint256 _amount, uint256 _time)\n', '        public override onlyOwner\n', '        returns (bool)\n', '    {\n', '        bytes32 reason = stringToBytes32(_reason);\n', '        uint256 validUntil = now.add(_time); //solhint-disable-line\n', '\n', '        // If tokens are already locked, then functions extendLock or\n', '        // increaseLockAmount should be used to make any changes\n', '        require(tokensLocked(msg.sender, bytes32ToString(reason)) == 0, ALREADY_LOCKED);\n', '        require(_amount != 0, AMOUNT_ZERO);\n', '\n', '        if (locked[msg.sender][reason].amount == 0)\n', '            lockReason[msg.sender].push(reason);\n', '\n', '        token.transferFrom(msg.sender, address(this), _amount);\n', '\n', '        locked[msg.sender][reason] = lockToken(_amount, validUntil, false);\n', '\n', '        emit Locked(msg.sender, reason, _amount, validUntil);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Transfers and Locks a specified amount of tokens,\n', '     *      for a specified reason and time\n', '     * @param _to adress to which tokens are to be transfered\n', '     * @param _reason The reason to lock tokens\n', '     * @param _amount Number of tokens to be transfered and locked\n', '     * @param _time Lock time in seconds\n', '     */\n', '    function transferWithLock(address _to, string memory _reason, uint256 _amount, uint256 _time)\n', '        public onlyOwner\n', '        returns (bool)\n', '    {\n', '        bytes32 reason = stringToBytes32(_reason);\n', '        uint256 validUntil = now.add(_time); //solhint-disable-line\n', '\n', '        require(tokensLocked(_to, _reason) == 0, ALREADY_LOCKED);\n', '        require(_amount != 0, AMOUNT_ZERO);\n', '\n', '        if (locked[_to][reason].amount == 0)\n', '            lockReason[_to].push(reason);\n', '\n', '        token.transferFrom(msg.sender, address(this), _amount);\n', '\n', '        locked[_to][reason] = lockToken(_amount, validUntil, false);\n', '        \n', '        emit Locked(_to, reason, _amount, validUntil);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns tokens locked for a specified address for a\n', '     *      specified reason\n', '     *\n', '     * @param _of The address whose tokens are locked\n', '     * @param _reason The reason to query the lock tokens for\n', '     */\n', '    function tokensLocked(address _of, string memory _reason)\n', '        public override\n', '        view\n', '        returns (uint256 amount)\n', '    {\n', '        bytes32 reason = stringToBytes32(_reason);\n', '        if (!locked[_of][reason].claimed)\n', '            amount = locked[_of][reason].amount;\n', '    }\n', '    \n', '    /**\n', '     * @dev Returns tokens locked for a specified address for a\n', '     *      specified reason at a specific time\n', '     *\n', '     * @param _of The address whose tokens are locked\n', '     * @param _reason The reason to query the lock tokens for\n', '     * @param _time The timestamp to query the lock tokens for\n', '     */\n', '    function tokensLockedAtTime(address _of, string memory _reason, uint256 _time)\n', '        public override\n', '        view\n', '        returns (uint256 amount)\n', '    {\n', '        bytes32 reason = stringToBytes32(_reason);\n', '        if (locked[_of][reason].validity > _time)\n', '            amount = locked[_of][reason].amount;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns total tokens held by an address (locked + transferable)\n', '     * @param _of The address to query the total balance of\n', '     */\n', '    function totalBalanceOf(address _of)\n', '        public override\n', '        view\n', '        returns (uint256 amount)\n', '    {\n', '        amount = token.balanceOf(_of);\n', '\n', '        for (uint256 i = 0; i < lockReason[_of].length; i++) {\n', '            amount = amount.add(tokensLocked(_of, bytes32ToString(lockReason[_of][i])));\n', '        }   \n', '    }    \n', '    \n', '    /**\n', '     * @dev Extends lock for a specified reason and time\n', '     * @param _reason The reason to lock tokens\n', '     * @param _time Lock extension time in seconds\n', '     */\n', '    function extendLock(string memory _reason, uint256 _time)\n', '        public override onlyOwner\n', '        returns (bool)\n', '    {\n', '        bytes32 reason = stringToBytes32(_reason);\n', '        require(tokensLocked(msg.sender, _reason) > 0, NOT_LOCKED);\n', '\n', '        locked[msg.sender][reason].validity = locked[msg.sender][reason].validity.add(_time);\n', '\n', '        emit Locked(msg.sender, reason, locked[msg.sender][reason].amount, locked[msg.sender][reason].validity);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Increase number of tokens locked for a specified reason\n', '     * @param _reason The reason to lock tokens\n', '     * @param _amount Number of tokens to be increased\n', '     */\n', '    function increaseLockAmount(string memory _reason, uint256 _amount)\n', '        public override onlyOwner\n', '        returns (bool)\n', '    {\n', '        bytes32 reason = stringToBytes32(_reason);\n', '        require(tokensLocked(msg.sender, _reason) > 0, NOT_LOCKED);\n', '        token.transfer(address(this), _amount);\n', '\n', '        locked[msg.sender][reason].amount = locked[msg.sender][reason].amount.add(_amount);\n', '\n', '        emit Locked(msg.sender, reason, locked[msg.sender][reason].amount, locked[msg.sender][reason].validity);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns unlockable tokens for a specified address for a specified reason\n', '     * @param _of The address to query the the unlockable token count of\n', '     * @param _reason The reason to query the unlockable tokens for\n', '     */\n', '    function tokensUnlockable(address _of, string memory _reason)\n', '        public override\n', '        view\n', '        returns (uint256 amount)\n', '    {\n', '        bytes32 reason = stringToBytes32(_reason);\n', '        if (locked[_of][reason].validity <= now && !locked[_of][reason].claimed) //solhint-disable-line\n', '            amount = locked[_of][reason].amount;\n', '    }\n', '\n', '    /**\n', '     * @dev Unlocks the unlockable tokens of a specified address\n', '     * @param _of Address of user, claiming back unlockable tokens\n', '     */\n', '    function unlock(address _of)\n', '        public override onlyOwner\n', '        returns (uint256 unlockableTokens)\n', '    {\n', '        uint256 lockedTokens;\n', '\n', '        for (uint256 i = 0; i < lockReason[_of].length; i++) {\n', '            lockedTokens = tokensUnlockable(_of, bytes32ToString(lockReason[_of][i]));\n', '            if (lockedTokens > 0) {\n', '                unlockableTokens = unlockableTokens.add(lockedTokens);\n', '                locked[_of][lockReason[_of][i]].claimed = true;\n', '                emit Unlocked(_of, lockReason[_of][i], lockedTokens);\n', '            }\n', '        }  \n', '\n', '        if (unlockableTokens > 0)\n', '            token.transfer(_of, unlockableTokens);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the unlockable tokens of a specified address\n', '     * @param _of The address to query the the unlockable token count of\n', '     */\n', '    function getUnlockableTokens(address _of)\n', '        public override\n', '        view\n', '        returns (uint256 unlockableTokens)\n', '    {\n', '        for (uint256 i = 0; i < lockReason[_of].length; i++) {\n', '            unlockableTokens = unlockableTokens.add(tokensUnlockable(_of, bytes32ToString(lockReason[_of][i])));\n', '        }  \n', '    }\n', '    \n', '    function getremainingLockTime(address _of, string memory _reason) public view returns (uint256 remainingTime) {\n', '        bytes32 reason = stringToBytes32(_reason);\n', '        if (locked[_of][reason].validity > now && !locked[_of][reason].claimed) //solhint-disable-line\n', '            remainingTime = locked[_of][reason].validity.sub(now);\n', '    }\n', '    \n', '    function getremainingLockDays(address _of, string memory _reason) public view returns (uint256 remainingDays) {\n', '        bytes32 reason = stringToBytes32(_reason);\n', '        if (locked[_of][reason].validity > now && !locked[_of][reason].claimed) //solhint-disable-line\n', '            remainingDays = (locked[_of][reason].validity.sub(now)) / 86400;\n', '    }\n', '    \n', '    /*\n', '    UTILS\n', '    */\n', '    \n', '    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '    \n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '    \n', '    function bytes32ToString(bytes32 x) public pure returns (string memory) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (uint256 j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '}']