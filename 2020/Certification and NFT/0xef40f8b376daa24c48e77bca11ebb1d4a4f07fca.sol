['// File: contracts/external/openzeppelin-solidity/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library SafeMath64 {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        uint64 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint64 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\n', '        require(b <= a, errorMessage);\n', '        uint64 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint64 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint64 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/external/govblocks-protocol/interfaces/IMemberRoles.sol\n', '\n', '/* Copyright (C) 2017 GovBlocks.io\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'contract IMemberRoles {\n', '\n', '    event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\n', '    \n', '    enum Role {UnAssigned, AdvisoryBoard, TokenHolder, DisputeResolution}\n', '\n', '    function setInititorAddress(address _initiator) external;\n', '\n', '    /// @dev Adds new member role\n', '    /// @param _roleName New role name\n', '    /// @param _roleDescription New description hash\n', '    /// @param _authorized Authorized member against every role id\n', '    function addRole(bytes32 _roleName, string memory _roleDescription, address _authorized) public;\n', '\n', '    /// @dev Assign or Delete a member from specific role.\n', '    /// @param _memberAddress Address of Member\n', '    /// @param _roleId RoleId to update\n', '    /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\n', '    function updateRole(address _memberAddress, uint _roleId, bool _active) public;\n', '\n', '    /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\n', '    /// @param _roleId roleId to update its Authorized Address\n', '    /// @param _authorized New authorized address against role id\n', '    function changeAuthorized(uint _roleId, address _authorized) public;\n', '\n', '    /// @dev Return number of member roles\n', '    function totalRoles() public view returns(uint256);\n', '\n', '    /// @dev Gets the member addresses assigned by a specific role\n', '    /// @param _memberRoleId Member role id\n', '    /// @return roleId Role id\n', '    /// @return allMemberAddress Member addresses of specified role id\n', '    function members(uint _memberRoleId) public view returns(uint, address[] memory allMemberAddress);\n', '\n', "    /// @dev Gets all members' length\n", '    /// @param _memberRoleId Member role id\n', '    /// @return memberRoleData[_memberRoleId].memberAddress.length Member length\n', '    function numberOfMembers(uint _memberRoleId) public view returns(uint);\n', '    \n', '    /// @dev Return member address who holds the right to add/remove any member from specific role.\n', '    function authorized(uint _memberRoleId) public view returns(address);\n', '\n', '    /// @dev Get All role ids array that has been assigned to a member so far.\n', '    function roles(address _memberAddress) public view returns(uint[] memory assignedRoles);\n', '\n', '    /// @dev Returns true if the given role id is assigned to a member.\n', '    /// @param _memberAddress Address of member\n', "    /// @param _roleId Checks member's authenticity with the roleId.\n", '    /// i.e. Returns true if this roleId is assigned to member\n', '    function checkRole(address _memberAddress, uint _roleId) public view returns(bool);   \n', '}\n', '\n', '// File: contracts/external/govblocks-protocol/Governed.sol\n', '\n', '/* Copyright (C) 2017 GovBlocks.io\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'contract IMaster {\n', '    mapping(address => bool) public whitelistedSponsor;\n', '    function dAppToken() public view returns(address);\n', '    function isInternal(address _address) public view returns(bool);\n', '    function getLatestAddress(bytes2 _module) public view returns(address);\n', '    function isAuthorizedToGovern(address _toCheck) public view returns(bool);\n', '}\n', '\n', '\n', 'contract Governed {\n', '\n', '    address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\n', '\n', '    /// @dev modifier that allows only the authorized addresses to execute the function\n', '    modifier onlyAuthorizedToGovern() {\n', '        IMaster ms = IMaster(masterAddress);\n', '        require(ms.getLatestAddress("GV") == msg.sender, "Not authorized");\n', '        _;\n', '    }\n', '\n', '    /// @dev checks if an address is authorized to govern\n', '    function isAuthorizedToGovern(address _toCheck) public view returns(bool) {\n', '        IMaster ms = IMaster(masterAddress);\n', '        return (ms.getLatestAddress("GV") == _toCheck);\n', '    } \n', '\n', '}\n', '\n', '// File: contracts/external/proxy/Proxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Gives the possibility to delegate any call to a foreign implementation.\n', ' */\n', 'contract Proxy {\n', '    /**\n', '    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n', '    * This function will return whatever the implementation call returns\n', '    */\n', '    function () external payable {\n', '        address _impl = implementation();\n', '        require(_impl != address(0));\n', '\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            calldatacopy(ptr, 0, calldatasize)\n', '            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n', '            let size := returndatasize\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            switch result\n', '            case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '            }\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the implementation where every call will be delegated.\n', '    * @return address of the implementation to which it will be delegated\n', '    */\n', '    function implementation() public view returns (address);\n', '}\n', '\n', '// File: contracts/external/proxy/UpgradeabilityProxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n', ' */\n', 'contract UpgradeabilityProxy is Proxy {\n', '    /**\n', '    * @dev This event will be emitted every time the implementation gets upgraded\n', '    * @param implementation representing the address of the upgraded implementation\n', '    */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    // Storage position of the address of the current implementation\n', '    bytes32 private constant IMPLEMENTATION_POSITION = keccak256("org.govblocks.proxy.implementation");\n', '\n', '    /**\n', '    * @dev Constructor function\n', '    */\n', '    constructor() public {}\n', '\n', '    /**\n', '    * @dev Tells the address of the current implementation\n', '    * @return address of the current implementation\n', '    */\n', '    function implementation() public view returns (address impl) {\n', '        bytes32 position = IMPLEMENTATION_POSITION;\n', '        assembly {\n', '            impl := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Sets the address of the current implementation\n', '    * @param _newImplementation address representing the new implementation to be set\n', '    */\n', '    function _setImplementation(address _newImplementation) internal {\n', '        bytes32 position = IMPLEMENTATION_POSITION;\n', '        assembly {\n', '        sstore(position, _newImplementation)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Upgrades the implementation address\n', '    * @param _newImplementation representing the address of the new implementation to be set\n', '    */\n', '    function _upgradeTo(address _newImplementation) internal {\n', '        address currentImplementation = implementation();\n', '        require(currentImplementation != _newImplementation);\n', '        _setImplementation(_newImplementation);\n', '        emit Upgraded(_newImplementation);\n', '    }\n', '}\n', '\n', '// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title OwnedUpgradeabilityProxy\n', ' * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n', ' */\n', 'contract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n', '    /**\n', '    * @dev Event to show ownership has been transferred\n', '    * @param previousOwner representing the address of the previous owner\n', '    * @param newOwner representing the address of the new owner\n', '    */\n', '    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n', '\n', '    // Storage position of the owner of the contract\n', '    bytes32 private constant PROXY_OWNER_POSITION = keccak256("org.govblocks.proxy.owner");\n', '\n', '    /**\n', '    * @dev the constructor sets the original owner of the contract to the sender account.\n', '    */\n', '    constructor(address _implementation) public {\n', '        _setUpgradeabilityOwner(msg.sender);\n', '        _upgradeTo(_implementation);\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyProxyOwner() {\n', '        require(msg.sender == proxyOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the owner\n', '    * @return the address of the owner\n', '    */\n', '    function proxyOwner() public view returns (address owner) {\n', '        bytes32 position = PROXY_OWNER_POSITION;\n', '        assembly {\n', '            owner := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\n', '        require(_newOwner != address(0));\n', '        _setUpgradeabilityOwner(_newOwner);\n', '        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the proxy owner to upgrade the current version of the proxy.\n', '    * @param _implementation representing the address of the new implementation to be set.\n', '    */\n', '    function upgradeTo(address _implementation) public onlyProxyOwner {\n', '        _upgradeTo(_implementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the owner\n', '    */\n', '    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\n', '        bytes32 position = PROXY_OWNER_POSITION;\n', '        assembly {\n', '            sstore(position, _newProxyOwner)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/Iupgradable.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract Iupgradable {\n', '\n', '    /**\n', '     * @dev change master address\n', '     */\n', '    function setMasterAddress() public;\n', '}\n', '\n', '// File: contracts/interfaces/ITokenController.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract ITokenController {\n', '\taddress public token;\n', '    address public bLOTToken;\n', '\n', '    /**\n', '    * @dev Swap BLOT token.\n', '    * account.\n', '    * @param amount The amount that will be swapped.\n', '    */\n', '    function swapBLOT(address _of, address _to, uint256 amount) public;\n', '\n', '    function totalBalanceOf(address _of)\n', '        public\n', '        view\n', '        returns (uint256 amount);\n', '\n', '    function transferFrom(address _token, address _of, address _to, uint256 amount) public;\n', '\n', '    /**\n', '     * @dev Returns tokens locked for a specified address for a\n', '     *      specified reason at a specific time\n', '     * @param _of The address whose tokens are locked\n', '     * @param _reason The reason to query the lock tokens for\n', '     * @param _time The timestamp to query the lock tokens for\n', '     */\n', '    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\n', '        public\n', '        view\n', '        returns (uint256 amount);\n', '\n', '    /**\n', '    * @dev burns an amount of the tokens of the message sender\n', '    * account.\n', '    * @param amount The amount that will be burnt.\n', '    */\n', '    function burnCommissionTokens(uint256 amount) external returns(bool);\n', ' \n', '    function initiateVesting(address _vesting) external;\n', '\n', '    function lockForGovernanceVote(address _of, uint _days) public;\n', '\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    function mint(address _member, uint _amount) public;\n', '\n', '}\n', '\n', '// File: contracts/MemberRoles.sol\n', '\n', '/* Copyright (C) 2020 PlotX.io\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract MemberRoles is IMemberRoles, Governed, Iupgradable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    ITokenController internal tokenController;\n', '    struct MemberRoleDetails {\n', '        uint256 memberCounter;\n', '        mapping(address => uint256) memberIndex;\n', '        address[] memberAddress;\n', '        address authorized;\n', '    }\n', '\n', '    MemberRoleDetails[] internal memberRoleData;\n', '    bool internal constructorCheck;\n', '    address internal initiator;\n', '    uint256 internal minLockAmountForDR;\n', '    uint256 internal lockTimeForDR;\n', '\n', '    modifier checkRoleAuthority(uint256 _memberRoleId) {\n', '        if (memberRoleData[_memberRoleId].authorized != address(0))\n', '            require(\n', '                msg.sender == memberRoleData[_memberRoleId].authorized,\n', '                "Not authorized"\n', '            );\n', '        else require(isAuthorizedToGovern(msg.sender), "Not Authorized");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev to swap advisory board member\n', '     * @param _newABAddress is address of new AB member\n', '     * @param _removeAB is advisory board member to be removed\n', '     */\n', '    function swapABMember(address _newABAddress, address _removeAB)\n', '        external\n', '        checkRoleAuthority(uint256(Role.AdvisoryBoard))\n', '    {\n', '        _updateRole(_newABAddress, uint256(Role.AdvisoryBoard), true);\n', '        _updateRole(_removeAB, uint256(Role.AdvisoryBoard), false);\n', '    }\n', '\n', '    /**\n', '     * @dev to change the master address\n', '     */\n', '    function setMasterAddress() public {\n', '        OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(\n', '            address(uint160(address(this)))\n', '        );\n', '        require(msg.sender == proxy.proxyOwner(), "Sender is not proxy owner.");\n', '\n', '        require(masterAddress == address(0), "Master address already set");\n', '        masterAddress = msg.sender;\n', '        IMaster masterInstance = IMaster(masterAddress);\n', '        tokenController = ITokenController(\n', '            masterInstance.getLatestAddress("TC")\n', '        );\n', '        minLockAmountForDR = 500 ether;\n', '        lockTimeForDR = 15 days;\n', '    }\n', '\n', '    /**\n', '     * @dev Set the authorized address to add the initial roles and members\n', '     * @param _initiator is address of the initiator\n', '     */\n', '    function setInititorAddress(address _initiator) external {\n', '        OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(\n', '            address(uint160(address(this)))\n', '        );\n', '        require(msg.sender == proxy.proxyOwner(), "Sender is not proxy owner.");\n', '        require(initiator == address(0), "Already Set");\n', '        initiator = _initiator;\n', '    }\n', '\n', '    /**\n', '     * @dev to initiate the member roles and add initial AB, DR board members\n', '     * @param _abArray is array of addresses of the Initial AB members\n', '     */\n', '    function memberRolesInitiate(\n', '        address[] calldata _abArray\n', '    ) external {\n', '        require(msg.sender == initiator);\n', '        require(!constructorCheck, "Already constructed");\n', '        _addInitialMemberRoles();\n', '        for (uint256 i = 0; i < _abArray.length; i++) {\n', '            _updateRole(_abArray[i], uint256(Role.AdvisoryBoard), true);\n', '        }\n', '        constructorCheck = true;\n', '    }\n', '\n', '    /// @dev Adds new member role\n', '    /// @param _roleName New role name\n', '    /// @param _roleDescription New description hash\n', '    /// @param _authorized Authorized member against every role id\n', '    function addRole(\n', '        //solhint-disable-line\n', '        bytes32 _roleName,\n', '        string memory _roleDescription,\n', '        address _authorized\n', '    ) public onlyAuthorizedToGovern {\n', '        _addRole(_roleName, _roleDescription, _authorized);\n', '    }\n', '\n', '    /// @dev Assign or Delete a member from specific role.\n', '    /// @param _memberAddress Address of Member\n', '    /// @param _roleId RoleId to update\n', '    /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\n', '    function updateRole(\n', '        //solhint-disable-line\n', '        address _memberAddress,\n', '        uint256 _roleId,\n', '        bool _active\n', '    ) public checkRoleAuthority(_roleId) {\n', '        _updateRole(_memberAddress, _roleId, _active);\n', '    }\n', '\n', '    /// @dev Return number of member roles\n', '    function totalRoles() public view returns (uint256) {\n', '        //solhint-disable-line\n', '        return memberRoleData.length;\n', '    }\n', '\n', '    /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\n', '    /// @param _roleId roleId to update its Authorized Address\n', '    /// @param _newAuthorized New authorized address against role id\n', '    function changeAuthorized(uint256 _roleId, address _newAuthorized)\n', '        public\n', '        checkRoleAuthority(_roleId)\n', '    {\n', '        //solhint-disable-line\n', '        memberRoleData[_roleId].authorized = _newAuthorized;\n', '    }\n', '\n', '    /// @dev Gets the member addresses assigned by a specific role\n', '    /// @param _memberRoleId Member role id\n', '    /// @return roleId Role id\n', '    /// @return allMemberAddress Member addresses of specified role id\n', '    function members(uint256 _memberRoleId)\n', '        public\n', '        view\n', '        returns (uint256, address[] memory memberArray)\n', '    {\n', '        return (_memberRoleId, memberRoleData[_memberRoleId].memberAddress);\n', '    }\n', '\n', "    /// @dev Gets all members' length\n", '    /// @param _memberRoleId Member role id\n', '    /// @return memberRoleData[_memberRoleId].memberCounter Member length\n', '    function numberOfMembers(uint256 _memberRoleId)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        //solhint-disable-line\n', '        return memberRoleData[_memberRoleId].memberCounter;\n', '    }\n', '\n', '    /// @dev Return member address who holds the right to add/remove any member from specific role.\n', '    function authorized(uint256 _memberRoleId) public view returns (address) {\n', '        //solhint-disable-line\n', '        return memberRoleData[_memberRoleId].authorized;\n', '    }\n', '\n', '    /// @dev Get All role ids array that has been assigned to a member so far.\n', '    function roles(address _memberAddress)\n', '        public\n', '        view\n', '        returns (uint256[] memory)\n', '    {\n', '        //solhint-disable-line\n', '        uint256 length = memberRoleData.length;\n', '        uint256[] memory assignedRoles = new uint256[](length);\n', '        uint256 counter = 0;\n', '        for (uint256 i = 1; i < length; i++) {\n', '            if (memberRoleData[i].memberIndex[_memberAddress] > 0) {\n', '                assignedRoles[counter] = i;\n', '                counter++;\n', '            }\n', '        }\n', '        if (tokenController.totalBalanceOf(_memberAddress) > 0) {\n', '            assignedRoles[counter] = uint256(Role.TokenHolder);\n', '            counter++;\n', '        }\n', '        if (tokenController.tokensLockedAtTime(_memberAddress, "DR", (lockTimeForDR).add(now)) >= minLockAmountForDR) {\n', '            assignedRoles[counter] = uint256(Role.DisputeResolution);\n', '        }\n', '        return assignedRoles;\n', '    }\n', '\n', '    /**\n', '     * @dev Updates Uint Parameters of a code\n', '     * @param code whose details we want to update\n', '     * @param val value to set\n', '     */\n', '    function updateUintParameters(bytes8 code, uint val) public onlyAuthorizedToGovern {\n', '        if(code == "MNLOCKDR") { //Minimum lock amount to consider user as DR member\n', '            minLockAmountForDR = val;\n', '        } else if (code == "TLOCDR") { // Lock period required for DR\n', '            lockTimeForDR = val * (1 days);\n', '        } \n', '    }\n', '\n', '    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\n', '        codeVal = code;\n', '        if(code == "MNLOCKDR") {\n', '            val = minLockAmountForDR;\n', '        } else if (code == "TLOCDR") { // Lock period required for DR\n', '            val = lockTimeForDR / (1 days);\n', '        } \n', '    }\n', '\n', '\n', '    /// @dev Returns true if the given role id is assigned to a member.\n', '    /// @param _memberAddress Address of member\n', "    /// @param _roleId Checks member's authenticity with the roleId.\n", '    /// i.e. Returns true if this roleId is assigned to member\n', '    function checkRole(address _memberAddress, uint256 _roleId)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        //solhint-disable-line\n', '        if (_roleId == uint256(Role.UnAssigned)) {\n', '            return true;\n', '        } else if (_roleId == uint256(Role.TokenHolder)) {\n', '            if (tokenController.totalBalanceOf(_memberAddress) > 0) {\n', '                return true;\n', '            }\n', '        } else if (_roleId == uint256(Role.DisputeResolution)) {\n', '            if (tokenController.tokensLockedAtTime(_memberAddress, "DR", (lockTimeForDR).add(now)) >= minLockAmountForDR) {\n', '                return true;\n', '            }\n', '        } else if (memberRoleData[_roleId].memberIndex[_memberAddress] > 0) {\n', '            //solhint-disable-line\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @dev Return total number of members assigned against each role id.\n', '    /// @return totalMembers Total members in particular role id\n', '    function getMemberLengthForAllRoles()\n', '        public\n', '        view\n', '        returns (uint256[] memory totalMembers)\n', '    {\n', '        //solhint-disable-line\n', '        totalMembers = new uint256[](memberRoleData.length);\n', '        for (uint256 i = 0; i < memberRoleData.length; i++) {\n', '            totalMembers[i] = numberOfMembers(i);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev to update the member roles\n', '     * @param _memberAddress in concern\n', '     * @param _roleId the id of role\n', '     * @param _active if active is true, add the member, else remove it\n', '     */\n', '    function _updateRole(\n', '        address _memberAddress,\n', '        uint256 _roleId,\n', '        bool _active\n', '    ) internal {\n', '        require(\n', '            _roleId != uint256(Role.TokenHolder) && _roleId != uint256(Role.DisputeResolution),\n', '            "Membership to this role is detected automatically"\n', '        );\n', '        if (_active) {\n', '            require(\n', '                memberRoleData[_roleId].memberIndex[_memberAddress] == 0,\n', '                "already active"\n', '            );\n', '\n', '            memberRoleData[_roleId].memberCounter = SafeMath.add(\n', '                memberRoleData[_roleId].memberCounter,\n', '                1\n', '            );\n', '            memberRoleData[_roleId]\n', '                .memberIndex[_memberAddress] = memberRoleData[_roleId]\n', '                .memberAddress\n', '                .length;\n', '            memberRoleData[_roleId].memberAddress.push(_memberAddress);\n', '        } else {\n', '            //Remove the selected member and swap its index with the member at last index\n', '            require(\n', '                memberRoleData[_roleId].memberIndex[_memberAddress] > 0,\n', '                "not active"\n', '            );\n', '            uint256 _memberIndex = memberRoleData[_roleId]\n', '                .memberIndex[_memberAddress];\n', '            address _topElement = memberRoleData[_roleId]\n', '                .memberAddress[memberRoleData[_roleId].memberCounter];\n', '            memberRoleData[_roleId].memberIndex[_topElement] = _memberIndex;\n', '            memberRoleData[_roleId].memberCounter = SafeMath.sub(\n', '                memberRoleData[_roleId].memberCounter,\n', '                1\n', '            );\n', '            memberRoleData[_roleId].memberAddress[_memberIndex] = _topElement;\n', '            memberRoleData[_roleId].memberAddress.length--;\n', '            delete memberRoleData[_roleId].memberIndex[_memberAddress];\n', '        }\n', '    }\n', '\n', '    /// @dev Adds new member role\n', '    /// @param _roleName New role name\n', '    /// @param _roleDescription New description hash\n', '    /// @param _authorized Authorized member against every role id\n', '    function _addRole(\n', '        bytes32 _roleName,\n', '        string memory _roleDescription,\n', '        address _authorized\n', '    ) internal {\n', '        emit MemberRole(memberRoleData.length, _roleName, _roleDescription);\n', '        memberRoleData.push(\n', '            MemberRoleDetails(0, new address[](1), _authorized)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev to add initial member roles\n', '     */\n', '    function _addInitialMemberRoles() internal {\n', '        _addRole("Unassigned", "Unassigned", address(0));\n', '        _addRole(\n', '            "Advisory Board",\n', '            "Selected few members that are deeply entrusted by the dApp. An ideal advisory board should be a mix of skills of domain, governance, research, technology, consulting etc to improve the performance of the dApp.", //solhint-disable-line\n', '            address(0)\n', '        );\n', '        _addRole(\n', '            "Token Holder",\n', '            "Represents all users who hold dApp tokens. This is the most general category and anyone holding token balance is a part of this category by default.", //solhint-disable-line\n', '            address(0)\n', '        );\n', '        _addRole(\n', '            "DisputeResolution",\n', '            "Represents members who are assigned to vote on resolving disputes", //solhint-disable-line\n', '            address(0)\n', '        );\n', '    }\n', '}']