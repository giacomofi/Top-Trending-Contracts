['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function mint(address account, uint amount) external;\n', '\n', '    function burn(uint amount) external;\n', '\n', '    function governance() external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /** YFV, vUSD, vETH has minters **/\n', '    function minters(address account) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Context {\n', '    constructor () internal {}\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {codehash := extcodehash(account)}\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success,) = recipient.call{value: amount}("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) {// Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'interface IController {\n', '    function withdraw(address, uint256) external;\n', '    function balanceOf(address) external view returns (uint256);\n', '    function maxAcceptAmount(address) external view returns (uint256);\n', '    function doHardWork(address, uint256) external;\n', '    function yfvInsuranceFund() external view returns (address);\n', '    function performanceReward() external view returns (address);\n', '}\n', '\n', 'interface IYFVReferral {\n', '    function setReferrer(address farmer, address referrer) external;\n', '    function getReferrer(address farmer) external view returns (address);\n', '}\n', '\n', 'interface IFreeFromUpTo {\n', '    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n', '}\n', '\n', 'contract YFVGovernanceVault {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    IFreeFromUpTo public constant chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n', '\n', '    modifier discountCHI {\n', '        uint256 gasStart = gasleft();\n', '        _;\n', '        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n', '        chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41130);\n', '    }\n', '\n', '    IERC20 public yfv; // stake token\n', '    IERC20 public value; // reward token\n', '    IERC20 public vUSD; // reward token\n', '    IERC20 public vETH; // reward token\n', '\n', '    uint256 public fundCap = 9500; // use up to 95% of fund (to keep small withdrawals cheap)\n', '    uint256 public constant FUND_CAP_DENOMINATOR = 10000;\n', '\n', '    uint256 public earnLowerlimit;\n', '\n', '    address public governance;\n', '    address public controller;\n', '    address public rewardReferral;\n', '\n', '    struct Staker {\n', '        uint256 stake;\n', '        uint256 payout;\n', '        uint256 total_out;\n', '    }\n', '\n', "    mapping(address => Staker) public stakers; // stakerAddress -> staker's info\n", '\n', '    struct Global {\n', '        uint256 total_stake;\n', '        uint256 total_out;\n', '        uint256 earnings_per_share;\n', '    }\n', '\n', '    Global public global; // global data\n', '    uint256 constant internal magnitude = 10 ** 40;\n', '\n', '    string public getName;\n', '\n', '    uint256 public vETH_REWARD_FRACTION_RATE = 1000;\n', '\n', '    uint256 public constant DURATION = 7 days;\n', '    uint8 public constant NUMBER_EPOCHS = 36;\n', '\n', '    uint256 public constant REFERRAL_COMMISSION_PERCENT = 1;\n', '\n', '    uint256 public currentEpochReward = 0;\n', '    uint256 public totalAccumulatedReward = 0;\n', '    uint8 public currentEpoch = 0;\n', '    uint256 public starttime = 1598968800; // Tuesday, September 1, 2020 2:00:00 PM (GMT+0)\n', '    uint256 public periodFinish = 0;\n', '    uint256 public rewardRate = 0;\n', '    uint256 public valueRewardRateMultipler = 0;\n', '    bool public isOpened;\n', '    uint256 public lastUpdateTime;\n', '    uint256 public rewardPerTokenStored;\n', '\n', '    uint256 public constant DEFAULT_EPOCH_REWARD = 230000 * (10 ** 9); // 230,000 vUSD (and 230 vETH)\n', '    uint256 public constant TOTAL_REWARD = DEFAULT_EPOCH_REWARD * NUMBER_EPOCHS; // 8,740,000 vUSD (and 8,740 vETH)\n', '    uint256 public constant DEFAULT_VALUE_EPOCH_REWARD = 23000 * (10 ** 18); // 23,000 VALUE\n', '\n', '    uint256 public epochReward = DEFAULT_EPOCH_REWARD;\n', '    uint256 public valueEpochReward = DEFAULT_VALUE_EPOCH_REWARD;\n', '    uint256 public minStakingAmount = 0 ether;\n', '    uint256 public unstakingFrozenTime = 40 hours;\n', '    uint256 public minStakeTimeToClaimVaultReward = 24 hours;\n', '\n', '    // ** unlockWithdrawFee = 1.92%: stakers will need to pay 1.92% (sent to insurance fund)of amount they want to withdraw if the coin still frozen\n', '    uint256 public unlockWithdrawFee = 0; // per ten thousand (eg. 15 -> 0.15%)\n', '\n', '    address public yfvInsuranceFund = 0xb7b2Ea8A1198368f950834875047aA7294A2bDAa; // set to Governance Multisig at start\n', '\n', '    mapping(address => uint256) public userRewardPerTokenPaid;\n', '    mapping(address => uint256) public rewards;\n', '    mapping(address => uint256) public lastStakeTimes;\n', '\n', '    mapping(address => uint256) public accumulatedStakingPower; // will accumulate every time staker does getReward()\n', '\n', '    event RewardAdded(uint256 reward);\n', '    event YfvRewardAdded(uint256 reward);\n', '    event Burned(uint256 reward);\n', '    event Staked(address indexed user, uint256 amount, uint256 actualStakeAmount);\n', '    event Withdrawn(address indexed user, uint256 amount, uint256 actualWithdrawAmount);\n', '    event RewardPaid(address indexed user, uint256 reward);\n', '    event CommissionPaid(address indexed user, uint256 reward);\n', '\n', '    constructor (address _yfv, address _value, address _vUSD, address _vETH, uint256 _earnLowerlimit) public {\n', '        yfv = IERC20(_yfv);\n', '        value = IERC20(_value);\n', '        vUSD = IERC20(_vUSD);\n', '        vETH = IERC20(_vETH);\n', '        getName = string(abi.encodePacked("YFV:GovVault:v2"));\n', '        earnLowerlimit = _earnLowerlimit * 1e18;\n', '        governance = msg.sender;\n', '    }\n', '\n', '    function setGovernance(address _governance) public {\n', '        require(msg.sender == governance, "!governance");\n', '        governance = _governance;\n', '    }\n', '\n', '    function balance() public view returns (uint256) {\n', '        uint256 bal = yfv.balanceOf(address(this));\n', '        if (controller != address(0)) bal = bal.add(IController(controller).balanceOf(address(yfv)));\n', '        return bal;\n', '    }\n', '\n', '    function setFundCap(uint256 _fundCap) external {\n', '        require(msg.sender == governance, "!governance");\n', '        fundCap = _fundCap;\n', '    }\n', '\n', '    function setController(address _controller) public {\n', '        require(msg.sender == governance, "!governance");\n', '        controller = _controller;\n', '    }\n', '\n', '    function setRewardReferral(address _rewardReferral) external {\n', '        require(msg.sender == governance, "!governance");\n', '        rewardReferral = _rewardReferral;\n', '    }\n', '\n', '    function setIsOpened(bool _isOpened) external {\n', '        require(msg.sender == governance, "!governance");\n', '        isOpened = _isOpened;\n', '    }\n', '\n', '    function setEarnLowerlimit(uint256 _earnLowerlimit) public {\n', '        require(msg.sender == governance, "!governance");\n', '        earnLowerlimit = _earnLowerlimit;\n', '    }\n', '\n', '    function setYfvInsuranceFund(address _yfvInsuranceFund) public {\n', '        require(msg.sender == governance, "!governance");\n', '        yfvInsuranceFund = _yfvInsuranceFund;\n', '    }\n', '\n', '    function setEpochReward(uint256 _epochReward) public {\n', '        require(msg.sender == governance, "!governance");\n', '        require(_epochReward <= DEFAULT_EPOCH_REWARD * 10, "Insane big _epochReward!"); // At most 10x only\n', '        epochReward = _epochReward;\n', '    }\n', '\n', '    function setValueEpochReward(uint256 _valueEpochReward) public {\n', '        require(msg.sender == governance, "!governance");\n', '        valueEpochReward = _valueEpochReward;\n', '    }\n', '\n', '    function setMinStakingAmount(uint256 _minStakingAmount) public {\n', '        require(msg.sender == governance, "!governance");\n', '        minStakingAmount = _minStakingAmount;\n', '    }\n', '\n', '    function setUnstakingFrozenTime(uint256 _unstakingFrozenTime) public {\n', '        require(msg.sender == governance, "!governance");\n', '        unstakingFrozenTime = _unstakingFrozenTime;\n', '    }\n', '\n', '    function setUnlockWithdrawFee(uint256 _unlockWithdrawFee) public {\n', '        require(msg.sender == governance, "!governance");\n', '        require(_unlockWithdrawFee <= 1000, "Dont be too greedy"); // <= 10%\n', '        unlockWithdrawFee = _unlockWithdrawFee;\n', '    }\n', '\n', '    function setMinStakeTimeToClaimVaultReward(uint256 _minStakeTimeToClaimVaultReward) public {\n', '        require(msg.sender == governance, "!governance");\n', '        minStakeTimeToClaimVaultReward = _minStakeTimeToClaimVaultReward;\n', '    }\n', '\n', '    // To upgrade vUSD contract (v1 is still experimental, we may need vUSDv2 with rebase() function working soon - then governance will call this upgrade)\n', '    function upgradeVUSDContract(address _vUSDContract) public {\n', '        require(msg.sender == governance, "!governance");\n', '        vUSD = IERC20(_vUSDContract);\n', '    }\n', '\n', '    // To upgrade vETH contract (v1 is still experimental, we may need vETHv2 with rebase() function working soon - then governance will call this upgrade)\n', '    function upgradeVETHContract(address _vETHContract) public {\n', '        require(msg.sender == governance, "!governance");\n', '        vETH = IERC20(_vETHContract);\n', '    }\n', '\n', '    modifier updateReward(address account) {\n', '        rewardPerTokenStored = rewardPerToken();\n', '        lastUpdateTime = lastTimeRewardApplicable();\n', '        if (account != address(0)) {\n', '            rewards[account] = earned(account);\n', '            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n', '        }\n', '        _;\n', '    }\n', '\n', '    function lastTimeRewardApplicable() public view returns (uint256) {\n', '        if (block.timestamp < periodFinish) return block.timestamp;\n', '        else return periodFinish;\n', '    }\n', '\n', '    function rewardPerToken() public view returns (uint256) {\n', '        if (global.total_stake == 0) {\n', '            return rewardPerTokenStored;\n', '        }\n', '        return\n', '        rewardPerTokenStored.add(\n', '            lastTimeRewardApplicable()\n', '            .sub(lastUpdateTime)\n', '            .mul(rewardRate)\n', '            .mul(1e18)\n', '            .div(global.total_stake)\n', '        );\n', '    }\n', '\n', '    // vUSD balance\n', '    function earned(address account) public view returns (uint256) {\n', '        uint256 calculatedEarned = stakers[account].stake\n', '            .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n', '            .div(1e18)\n', '            .add(rewards[account]);\n', '        uint256 poolBalance = vUSD.balanceOf(address(this));\n', '        // some rare case the reward can be slightly bigger than real number, we need to check against how much we have left in pool\n', '        if (calculatedEarned > poolBalance) return poolBalance;\n', '        return calculatedEarned;\n', '    }\n', '\n', '    function stakingPower(address account) public view returns (uint256) {\n', '        return accumulatedStakingPower[account].add(earned(account));\n', '    }\n', '\n', '    function earnedVETH(address account) public view returns (uint256) {\n', '        return earned(account).div(vETH_REWARD_FRACTION_RATE);\n', '    }\n', '\n', '    function earnedValue(address account) public view returns (uint256) {\n', '        return earned(account).mul(valueRewardRateMultipler);\n', '    }\n', '\n', '    // Custom logic in here for how much the vault allows to be borrowed\n', '    // Sets minimum required on-hand to keep small withdrawals cheap\n', '    function available() public view returns (uint256) {\n', '        return yfv.balanceOf(address(this)).mul(fundCap).div(FUND_CAP_DENOMINATOR);\n', '    }\n', '\n', '    function doHardWork() public discountCHI {\n', '        if (controller != address(0)) {\n', '            uint256 _amount = available();\n', '            uint256 _accepted = IController(controller).maxAcceptAmount(address(yfv));\n', '            if (_amount > _accepted) _amount = _accepted;\n', '            if (_amount > 0) {\n', '                yfv.safeTransfer(controller, _amount);\n', '                IController(controller).doHardWork(address(yfv), _amount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function stake(uint256 amount, address referrer) public discountCHI updateReward(msg.sender) checkNextEpoch {\n', '        require(isOpened, "Pool is not opening to stake");\n', '        yfv.safeTransferFrom(msg.sender, address(this), amount);\n', '        stakers[msg.sender].stake = stakers[msg.sender].stake.add(amount);\n', '        require(stakers[msg.sender].stake > minStakingAmount, "Cannot stake below minStakingAmount");\n', '\n', '        if (global.earnings_per_share != 0) {\n', '            stakers[msg.sender].payout = stakers[msg.sender].payout.add(\n', '                global.earnings_per_share.mul(amount).sub(1).div(magnitude).add(1)\n', '            );\n', '        }\n', '        global.total_stake = global.total_stake.add(amount);\n', '\n', '        if (yfv.balanceOf(address(this)) > earnLowerlimit) {\n', '            doHardWork();\n', '        }\n', '\n', '        lastStakeTimes[msg.sender] = block.timestamp;\n', '        if (rewardReferral != address(0) && referrer != address(0)) {\n', '            IYFVReferral(rewardReferral).setReferrer(msg.sender, referrer);\n', '        }\n', '    }\n', '\n', '    function unfrozenStakeTime(address account) public view returns (uint256) {\n', '        return lastStakeTimes[account] + unstakingFrozenTime;\n', '    }\n', '\n', '    // No rebalance implementation for lower fees and faster swaps\n', '    function withdraw(uint256 amount) public discountCHI updateReward(msg.sender) checkNextEpoch {\n', '        require(amount > 0, "Cannot withdraw 0");\n', '        claim();\n', '        require(amount <= stakers[msg.sender].stake, "!balance");\n', '        uint256 actualWithdrawAmount = amount;\n', '\n', '        // Check balance\n', '        uint256 b = yfv.balanceOf(address(this));\n', '        if (b < actualWithdrawAmount) {\n', '            if (controller != address(0)) {\n', '                uint256 _withdraw = actualWithdrawAmount.sub(b);\n', '                IController(controller).withdraw(address(yfv), _withdraw);\n', '                uint256 _after = yfv.balanceOf(address(this));\n', '                uint256 _diff = _after.sub(b);\n', '                if (_diff < _withdraw) {\n', '                    actualWithdrawAmount = b.add(_diff);\n', '                }\n', '            } else {\n', '                actualWithdrawAmount = b;\n', '            }\n', '        }\n', '\n', '        stakers[msg.sender].payout = stakers[msg.sender].payout.sub(\n', '            global.earnings_per_share.mul(amount).div(magnitude)\n', '        );\n', '\n', '        stakers[msg.sender].stake = stakers[msg.sender].stake.sub(amount);\n', '        global.total_stake = global.total_stake.sub(amount);\n', '\n', '        if (block.timestamp < unfrozenStakeTime(msg.sender)) {\n', '            // if coin is still frozen and governance does not allow stakers to unstake before timer ends\n', '            if (unlockWithdrawFee == 0) revert("Coin is still frozen");\n', '\n', '            // otherwise withdrawFee will be calculated based on the rate\n', '            uint256 withdrawFee = amount.mul(unlockWithdrawFee).div(10000);\n', '            uint256 r = amount.sub(withdrawFee);\n', '            if (actualWithdrawAmount > r) {\n', '                withdrawFee = actualWithdrawAmount.sub(r);\n', '                actualWithdrawAmount = r;\n', '                if (yfvInsuranceFund != address(0)) { // send fee to insurance\n', '                    safeTokenTransfer(yfv, yfvInsuranceFund, withdrawFee);\n', '                    emit RewardPaid(yfvInsuranceFund, withdrawFee);\n', '                } else { // or burn\n', '                    yfv.burn(withdrawFee);\n', '                    emit Burned(withdrawFee);\n', '                }\n', '            }\n', '        }\n', '\n', '        safeTokenTransfer(yfv, msg.sender, actualWithdrawAmount);\n', '        emit Withdrawn(msg.sender, amount, actualWithdrawAmount);\n', '    }\n', '\n', '    function make_profit(uint256 amount) public discountCHI {\n', '        require(amount > 0, "not 0");\n', '        value.safeTransferFrom(msg.sender, address(this), amount);\n', '        global.earnings_per_share = global.earnings_per_share.add(\n', '            amount.mul(magnitude).div(global.total_stake)\n', '        );\n', '        global.total_out = global.total_out.add(amount);\n', '    }\n', '\n', '    function cal_out(address user) public view returns (uint256) {\n', '        uint256 _cal = global.earnings_per_share.mul(stakers[user].stake).div(magnitude);\n', '        if (_cal < stakers[user].payout) {\n', '            return 0;\n', '        } else {\n', '            return _cal.sub(stakers[user].payout);\n', '        }\n', '    }\n', '\n', '    function cal_out_pending(uint256 _pendingBalance, address user) public view returns (uint256) {\n', '        uint256 _earnings_per_share = global.earnings_per_share.add(\n', '            _pendingBalance.mul(magnitude).div(global.total_stake)\n', '        );\n', '        uint256 _cal = _earnings_per_share.mul(stakers[user].stake).div(magnitude);\n', '        _cal = _cal.sub(cal_out(user));\n', '        if (_cal < stakers[user].payout) {\n', '            return 0;\n', '        } else {\n', '            return _cal.sub(stakers[user].payout);\n', '        }\n', '    }\n', '\n', '    function claim() public discountCHI {\n', '        uint256 out = cal_out(msg.sender);\n', '        stakers[msg.sender].payout = global.earnings_per_share.mul(stakers[msg.sender].stake).div(magnitude);\n', '        stakers[msg.sender].total_out = stakers[msg.sender].total_out.add(out);\n', '\n', '        if (out > 0) {\n', '            uint256 _stakeTime = now - lastStakeTimes[msg.sender];\n', '            if (controller != address(0) && _stakeTime < minStakeTimeToClaimVaultReward) { // deposit in less than requirement\n', '                uint256 actually_out = _stakeTime.mul(out).mul(1e18).div(minStakeTimeToClaimVaultReward).div(1e18);\n', '                uint256 to_team = out.sub(actually_out);\n', '                safeTokenTransfer(value, IController(controller).performanceReward(), to_team);\n', '                out = actually_out;\n', '            }\n', '            safeTokenTransfer(value, msg.sender, out);\n', '        }\n', '    }\n', '\n', '    function exit() external discountCHI {\n', '        withdraw(stakers[msg.sender].stake);\n', '        getReward();\n', '    }\n', '\n', '    function getReward() public discountCHI updateReward(msg.sender) checkNextEpoch {\n', '        uint256 reward = rewards[msg.sender];\n', '        if (reward > 0) {\n', '            accumulatedStakingPower[msg.sender] = accumulatedStakingPower[msg.sender].add(rewards[msg.sender]);\n', '            rewards[msg.sender] = 0;\n', '\n', '            safeTokenTransfer(vUSD, msg.sender, reward);\n', '            safeTokenTransfer(vETH, msg.sender, reward.div(vETH_REWARD_FRACTION_RATE));\n', '            emit RewardPaid(msg.sender, reward);\n', '\n', '            uint256 valueReward = reward.mul(valueRewardRateMultipler);\n', '            uint256 actualValuePaid = valueReward.mul(100 - REFERRAL_COMMISSION_PERCENT).div(100); // 99%\n', '            uint256 valueCommission = valueReward - actualValuePaid; // 1%\n', '\n', '            safeTokenTransfer(value, msg.sender, actualValuePaid);\n', '\n', '            address referrer = address(0);\n', '            if (rewardReferral != address(0)) {\n', '                referrer = IYFVReferral(rewardReferral).getReferrer(msg.sender);\n', '            }\n', '            if (referrer != address(0)) { // send commission to referrer\n', '                safeTokenTransfer(value, referrer, valueCommission);\n', '            } else {// or burn\n', '                safeTokenBurn(value, valueCommission);\n', '                emit Burned(valueCommission);\n', '            }\n', '        }\n', '    }\n', '\n', '    modifier checkNextEpoch() {\n', '        if (block.timestamp >= periodFinish) {\n', '            currentEpochReward = epochReward;\n', '\n', '            if (totalAccumulatedReward.add(currentEpochReward) > TOTAL_REWARD) {\n', '                currentEpochReward = TOTAL_REWARD.sub(totalAccumulatedReward); // limit total reward\n', '            }\n', '\n', '            if (currentEpochReward > 0) {\n', '                if (!vUSD.minters(address(this)) || !vETH.minters(address(this))) {\n', '                    currentEpochReward = 0;\n', '                } else {\n', '                    vUSD.mint(address(this), currentEpochReward);\n', '                    vETH.mint(address(this), currentEpochReward.div(vETH_REWARD_FRACTION_RATE));\n', '                    totalAccumulatedReward = totalAccumulatedReward.add(currentEpochReward);\n', '                }\n', '                currentEpoch++;\n', '            }\n', '\n', '            rewardRate = currentEpochReward.div(DURATION);\n', '\n', '            if (currentEpochReward > 0) {\n', '                value.mint(address(this), valueEpochReward);\n', '                valueRewardRateMultipler = valueEpochReward.div(currentEpochReward);\n', '            } else {\n', '                valueRewardRateMultipler = 0;\n', '            }\n', '\n', '            lastUpdateTime = block.timestamp;\n', '            periodFinish = block.timestamp.add(DURATION);\n', '            emit RewardAdded(currentEpochReward);\n', '        }\n', '        _;\n', '    }\n', '\n', '    function addValueReward(uint256 _amount) external discountCHI {\n', '        require(periodFinish > 0, "Pool has not started yet");\n', '        uint256 remaining = periodFinish.sub(block.timestamp);\n', '        require(remaining > 1 days, "Too little time to distribute. Wait for next epoch");\n', '        value.safeTransferFrom(msg.sender, address(this), _amount);\n', '        uint256 leftover = remaining.mul(rewardRate);\n', '        uint256 valueLeftover = leftover.mul(valueRewardRateMultipler);\n', '        valueRewardRateMultipler = valueLeftover.add(_amount).div(leftover);\n', '    }\n', '\n', '    // Safe token transfer function, just in case if rounding error causes pool to not have enough token.\n', '    function safeTokenTransfer(IERC20 _token, address _to, uint256 _amount) internal {\n', '        uint256 bal = _token.balanceOf(address(this));\n', '        if (_amount > bal) {\n', '            _token.safeTransfer(_to, bal);\n', '        } else {\n', '            _token.safeTransfer(_to, _amount);\n', '        }\n', '    }\n', '\n', '    // Safe token burn function, just in case if rounding error causes pool to not have enough token.\n', '    function safeTokenBurn(IERC20 _token, uint256 _amount) internal {\n', '        uint256 bal = _token.balanceOf(address(this));\n', '        if (_amount > bal) {\n', '            _token.burn(bal);\n', '        } else {\n', '            _token.burn(_amount);\n', '        }\n', '    }\n', '\n', '    // Withdraw without caring about rewards. EMERGENCY ONLY.\n', '    function emergencyWithdraw() public discountCHI {\n', '        require(block.timestamp >= unfrozenStakeTime(msg.sender), "Wait until coin unfrozen");\n', '        uint256 amount = stakers[msg.sender].stake;\n', '        uint256 b = yfv.balanceOf(address(this));\n', '        if (b < amount) amount = b;\n', '        stakers[msg.sender].payout = stakers[msg.sender].payout.sub(\n', '            global.earnings_per_share.mul(amount).div(magnitude)\n', '        );\n', '        stakers[msg.sender].stake = stakers[msg.sender].stake.sub(amount);\n', '        global.total_stake = global.total_stake.sub(amount);\n', '        safeTokenTransfer(yfv, msg.sender, amount);\n', '        emit Withdrawn(msg.sender, amount, amount);\n', '    }\n', '\n', '    // This function allows governance to take unsupported tokens out of the contract, since this pool exists longer than the other pools.\n', '    // This is in an effort to make someone whole, should they seriously mess up.\n', '    // There is no guarantee governance will vote to return these.\n', '    // It also allows for removal of airdropped tokens.\n', '    function governanceRecoverUnsupported(IERC20 _token, uint256 amount, address to) external {\n', '        require(msg.sender == governance, "!governance");\n', '\n', '        // cant take staked asset\n', '        require(_token != yfv || global.total_stake.add(amount) <= yfv.balanceOf(address(this)), "cant withdraw more than stuck YFV");\n', '\n', '        // transfer to\n', '        _token.safeTransfer(to, amount);\n', '    }\n', '}']