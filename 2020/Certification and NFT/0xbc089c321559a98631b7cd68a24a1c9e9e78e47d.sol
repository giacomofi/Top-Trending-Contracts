['pragma solidity ^0.5.0;\n', '\n', 'contract Context {\n', '    constructor () internal {}\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () internal {\n', '        _owner = _msgSender();\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'interface IUniswapV2Factory {\n', '    function allPairs(uint) external view returns (address pair);\n', '\n', '    function allPairsLength() external view returns (uint);\n', '}\n', '\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    function totalSupply() external view returns (uint);\n', '\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '\n', '    function price0CumulativeLast() external view returns (uint);\n', '\n', '    function price1CumulativeLast() external view returns (uint);\n', '\n', '    function kLast() external view returns (uint);\n', '}\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'contract FSERandom is Ownable {\n', '    mapping(address => bool) private _modules;\n', '    IUniswapV2Factory private _uniswapV2Factory;\n', '    address[] private _uniswapPools;\n', '    bytes32 private _randNumber;\n', '\n', '    modifier onlyModule() {\n', '        require(_modules[_msgSender()], "Illegal caller!");\n', '        _;\n', '    }\n', '\n', '    constructor (address __uniswapV2Factory, address[] memory __uniswapPools)\n', '    public {\n', '        _genRandomNumber(gasleft());\n', '        setUniswapV2Factory(__uniswapV2Factory);\n', '        setUniswapPools(__uniswapPools);\n', '    }\n', '\n', '    function setUniswapV2Factory(address __uniswapV2Factory)\n', '    public onlyOwner {\n', '        _uniswapV2Factory = IUniswapV2Factory(__uniswapV2Factory);\n', '    }\n', '\n', '    function setUniswapPools(address[] memory __uniswapPools)\n', '    public onlyOwner {\n', '        _uniswapPools = __uniswapPools;\n', '    }\n', '\n', '    function setModule(address _moduleAddress, bool _running)\n', '    public onlyOwner {\n', '        _modules[_moduleAddress] = _running;\n', '    }\n', '\n', '    function _genRandomNumber(uint256 _seed)\n', '    internal\n', '    returns (bytes32 _rand){\n', '        _randNumber = keccak256(\n', '            abi.encodePacked(\n', '                _randNumber,\n', '                _seed,\n', '                gasleft(),\n', '                block.number,\n', '                blockhash(block.number - 1),\n', '                block.coinbase,\n', '                block.difficulty,\n', '                block.gaslimit,\n', '                block.timestamp));\n', '        return _randNumber;\n', '    }\n', '\n', '    function _genRandByUniswapV2Pair(address _uniswapV2Pair)\n', '    internal\n', '    returns (bytes32 _rand){\n', '        IUniswapV2Pair uniswapV2Pair = IUniswapV2Pair(_uniswapV2Pair);\n', '        (uint256 reserve0, uint256 reserve1, uint256 blockTimestampLast) = uniswapV2Pair.getReserves();\n', '        uint256 totalSupply = uniswapV2Pair.totalSupply();\n', '        uint256 price0CumulativeLast = uniswapV2Pair.price0CumulativeLast();\n', '        uint256 price1CumulativeLast = uniswapV2Pair.price1CumulativeLast();\n', '        uint256 kLast = uniswapV2Pair.kLast();\n', '        return _genRandomNumber(uint256(keccak256(abi.encodePacked(\n', '                _uniswapV2Pair,\n', '                reserve0,\n', '                reserve1,\n', '                blockTimestampLast,\n', '                totalSupply,\n', '                price0CumulativeLast,\n', '                price1CumulativeLast,\n', '                kLast))));\n', '    }\n', '\n', '    function genRandom(uint256 seed)\n', '    public onlyModule\n', '    returns (bytes32 _rand){\n', '        require(_uniswapPools.length > 3, "Not enought pool size!");\n', '        require(_uniswapV2Factory.allPairsLength() > 3, "Not enought pool size!");\n', '        uint256 randTimes = uint256(_genRandomNumber(gasleft())) % 3 + 1;\n', '        uint256 memPoolSize = _uniswapPools.length;\n', '        uint256 randPos;\n', '        for (uint i = 0; i < randTimes; i++) {\n', '            randPos = uint256(_genRandomNumber(gasleft() + i)) % memPoolSize;\n', '            _genRandByUniswapV2Pair(_uniswapPools[randPos]);\n', '        }\n', '        randTimes = uint256(_genRandomNumber(gasleft())) % 3 + 1;\n', '        memPoolSize = _uniswapV2Factory.allPairsLength();\n', '        for (uint i = 0; i < randTimes; i++) {\n', '            randPos = uint256(_genRandomNumber(gasleft() + i)) % memPoolSize;\n', '            _genRandByUniswapV2Pair(_uniswapV2Factory.allPairs(randPos));\n', '        }\n', '        return keccak256(abi.encodePacked(_randNumber, gasleft(), seed));\n', '    }\n', '}']