['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2017 Loopring Technology Limited.\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/// @title Ownable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable\n', '{\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      new owner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership()\n', '        public\n', '        onlyOwner\n', '    {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title Claimable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable\n', '{\n', '    address public pendingOwner;\n', '\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0) && newOwner != owner, "INVALID_ADDRESS");\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        public\n', '        onlyPendingOwner\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title IBlockVerifier\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'abstract contract IBlockVerifier is Claimable\n', '{\n', '    // -- Events --\n', '\n', '    event CircuitRegistered(\n', '        uint8  indexed blockType,\n', '        uint16         blockSize,\n', '        uint8          blockVersion\n', '    );\n', '\n', '    event CircuitDisabled(\n', '        uint8  indexed blockType,\n', '        uint16         blockSize,\n', '        uint8          blockVersion\n', '    );\n', '\n', '    // -- Public functions --\n', '\n', '    /// @dev Sets the verifying key for the specified circuit.\n', '    ///      Every block permutation needs its own circuit and thus its own set of\n', '    ///      verification keys. Only a limited number of block sizes per block\n', '    ///      type are supported.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @param vk The verification key\n', '    function registerCircuit(\n', '        uint8    blockType,\n', '        uint16   blockSize,\n', '        uint8    blockVersion,\n', '        uint[18] calldata vk\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Disables the use of the specified circuit.\n', '    ///      This will stop NEW blocks from using the given circuit, blocks that were already committed\n', '    ///      can still be verified.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    function disableCircuit(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Verifies blocks with the given public data and proofs.\n', '    ///      Verifying a block makes sure all requests handled in the block\n', '    ///      are correctly handled by the operator.\n', '    /// @param blockType The type of block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @param publicInputs The hash of all the public data of the blocks\n', '    /// @param proofs The ZK proofs proving that the blocks are correct\n', '    /// @return True if the block is valid, false otherwise\n', '    function verifyProofs(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion,\n', '        uint[] calldata publicInputs,\n', '        uint[] calldata proofs\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Checks if a circuit with the specified parameters is registered.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @return True if the circuit is registered, false otherwise\n', '    function isCircuitRegistered(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Checks if a circuit can still be used to commit new blocks.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @return True if the circuit is enabled, false otherwise\n', '    function isCircuitEnabled(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ReentrancyGuard\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Exposes a modifier that guards a function against reentrancy\n', '///      Changing the value of the same storage value multiple times in a transaction\n', '///      is cheap (starting from Istanbul) so there is no need to minimize\n', '///      the number of times the value is changed\n', 'contract ReentrancyGuard\n', '{\n', '    //The default value must be 0 in order to work behind a proxy.\n', '    uint private _guardValue;\n', '\n', '    // Use this modifier on a function to prevent reentrancy\n', '    modifier nonReentrant()\n', '    {\n', '        // Check if the guard value has its original value\n', '        require(_guardValue == 0, "REENTRANCY");\n', '\n', '        // Set the value to something else\n', '        _guardValue = 1;\n', '\n', '        // Function body\n', '        _;\n', '\n', '        // Set the value back\n', '        _guardValue = 0;\n', '    }\n', '}\n', '\n', '\n', '\n', '// This code is taken from https://github.com/matter-labs/Groth16BatchVerifier/blob/master/BatchedSnarkVerifier/contracts/BatchVerifier.sol\n', '// Thanks Harry from ETHSNARKS for base code\n', '\n', '\n', 'library BatchVerifier {\n', '    function GroupOrder ()\n', '        public pure returns (uint256)\n', '    {\n', '        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n', '    }\n', '\n', '    function NegateY( uint256 Y )\n', '        internal pure returns (uint256)\n', '    {\n', '        uint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n', '        return q - (Y % q);\n', '    }\n', '\n', '    function getProofEntropy(\n', '        uint256[] memory in_proof,\n', '        uint256[] memory proof_inputs,\n', '        uint proofNumber\n', '    )\n', '        internal pure returns (uint256)\n', '    {\n', '        // Truncate the least significant 3 bits from the 256bit entropy so it fits the scalar field\n', '        return uint(\n', '            keccak256(\n', '                abi.encodePacked(\n', '                    in_proof[proofNumber*8 + 0], in_proof[proofNumber*8 + 1], in_proof[proofNumber*8 + 2], in_proof[proofNumber*8 + 3],\n', '                    in_proof[proofNumber*8 + 4], in_proof[proofNumber*8 + 5], in_proof[proofNumber*8 + 6], in_proof[proofNumber*8 + 7],\n', '                    proof_inputs[proofNumber]\n', '                )\n', '            )\n', '        ) >> 3;\n', '    }\n', '\n', '    function accumulate(\n', '        uint256[] memory in_proof,\n', '        uint256[] memory proof_inputs, // public inputs, length is num_inputs * num_proofs\n', '        uint256 num_proofs\n', '    ) internal view returns (\n', '        bool success,\n', '        uint256[] memory proofsAandC,\n', '        uint256[] memory inputAccumulators\n', '    ) {\n', '        uint256 q = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n', '        uint256 numPublicInputs = proof_inputs.length / num_proofs;\n', '        uint256[] memory entropy = new uint256[](num_proofs);\n', '        inputAccumulators = new uint256[](numPublicInputs + 1);\n', '\n', '        for (uint256 proofNumber = 0; proofNumber < num_proofs; proofNumber++) {\n', '            if (proofNumber == 0) {\n', '                entropy[proofNumber] = 1;\n', '            } else {\n', '                // entropy[proofNumber] = uint(blockhash(block.number - proofNumber)) % q;\n', '                // Safer entropy:\n', '                entropy[proofNumber] = getProofEntropy(in_proof, proof_inputs, proofNumber);\n', '            }\n', '            require(entropy[proofNumber] != 0, "Entropy should not be zero");\n', '            // here multiplication by 1 is implied\n', '            inputAccumulators[0] = addmod(inputAccumulators[0], entropy[proofNumber], q);\n', '            for (uint256 i = 0; i < numPublicInputs; i++) {\n', '                require(proof_inputs[proofNumber * numPublicInputs + i] < q, "INVALID_INPUT");\n', '                // accumulate the exponent with extra entropy mod q\n', '                inputAccumulators[i+1] = addmod(inputAccumulators[i+1], mulmod(entropy[proofNumber], proof_inputs[proofNumber * numPublicInputs + i], q), q);\n', '            }\n', '            // coefficient for +vk.alpha (mind +) is the same as inputAccumulator[0]\n', '        }\n', '\n', '        // inputs for scalar multiplication\n', '        uint256[3] memory mul_input;\n', '\n', '        // use scalar multiplications to get proof.A[i] * entropy[i]\n', '\n', '        proofsAandC = new uint256[](num_proofs*2 + 2);\n', '\n', '        proofsAandC[0] = in_proof[0];\n', '        proofsAandC[1] = in_proof[1];\n', '\n', '        for (uint256 proofNumber = 1; proofNumber < num_proofs; proofNumber++) {\n', '            require(entropy[proofNumber] < q, "INVALID_INPUT");\n', '            mul_input[0] = in_proof[proofNumber*8];\n', '            mul_input[1] = in_proof[proofNumber*8 + 1];\n', '            mul_input[2] = entropy[proofNumber];\n', '            assembly {\n', '                // ECMUL, output proofsA[i]\n', '                // success := staticcall(sub(gas, 2000), 7, mul_input, 0x60, add(add(proofsAandC, 0x20), mul(proofNumber, 0x40)), 0x40)\n', '                success := staticcall(sub(gas(), 2000), 7, mul_input, 0x60, mul_input, 0x40)\n', '            }\n', '            if (!success) {\n', '                return (false, proofsAandC, inputAccumulators);\n', '            }\n', '            proofsAandC[proofNumber*2] = mul_input[0];\n', '            proofsAandC[proofNumber*2 + 1] = mul_input[1];\n', '        }\n', '\n', '        // use scalar multiplication and addition to get sum(proof.C[i] * entropy[i])\n', '\n', '        uint256[4] memory add_input;\n', '\n', '        add_input[0] = in_proof[6];\n', '        add_input[1] = in_proof[7];\n', '\n', '        for (uint256 proofNumber = 1; proofNumber < num_proofs; proofNumber++) {\n', '            mul_input[0] = in_proof[proofNumber*8 + 6];\n', '            mul_input[1] = in_proof[proofNumber*8 + 7];\n', '            mul_input[2] = entropy[proofNumber];\n', '            assembly {\n', '                // ECMUL, output proofsA\n', '                success := staticcall(sub(gas(), 2000), 7, mul_input, 0x60, add(add_input, 0x40), 0x40)\n', '            }\n', '            if (!success) {\n', '                return (false, proofsAandC, inputAccumulators);\n', '            }\n', '\n', '            assembly {\n', '                // ECADD from two elements that are in add_input and output into first two elements of add_input\n', '                success := staticcall(sub(gas(), 2000), 6, add_input, 0x80, add_input, 0x40)\n', '            }\n', '            if (!success) {\n', '                return (false, proofsAandC, inputAccumulators);\n', '            }\n', '        }\n', '\n', '        proofsAandC[num_proofs*2] = add_input[0];\n', '        proofsAandC[num_proofs*2 + 1] = add_input[1];\n', '    }\n', '\n', '    function prepareBatches(\n', '        uint256[14] memory in_vk,\n', '        uint256[4] memory vk_gammaABC,\n', '        uint256[] memory inputAccumulators\n', '    ) internal view returns (\n', '        bool success,\n', '        uint256[4] memory finalVksAlphaX\n', '    ) {\n', '        // Compute the linear combination vk_x using accumulator\n', '        // First two fields are used as the sum and are initially zero\n', '        uint256[4] memory add_input;\n', '        uint256[3] memory mul_input;\n', '\n', '        // Performs a sum(gammaABC[i] * inputAccumulator[i])\n', '        for (uint256 i = 0; i < inputAccumulators.length; i++) {\n', '            mul_input[0] = vk_gammaABC[2*i];\n', '            mul_input[1] = vk_gammaABC[2*i + 1];\n', '            mul_input[2] = inputAccumulators[i];\n', '\n', '            assembly {\n', '                // ECMUL, output to the last 2 elements of `add_input`\n', '                success := staticcall(sub(gas(), 2000), 7, mul_input, 0x60, add(add_input, 0x40), 0x40)\n', '            }\n', '            if (!success) {\n', '                return (false, finalVksAlphaX);\n', '            }\n', '\n', '            assembly {\n', '                // ECADD from four elements that are in add_input and output into first two elements of add_input\n', '                success := staticcall(sub(gas(), 2000), 6, add_input, 0x80, add_input, 0x40)\n', '            }\n', '            if (!success) {\n', '                return (false, finalVksAlphaX);\n', '            }\n', '        }\n', '\n', '        finalVksAlphaX[2] = add_input[0];\n', '        finalVksAlphaX[3] = add_input[1];\n', '\n', '        // add one extra memory slot for scalar for multiplication usage\n', '        uint256[3] memory finalVKalpha;\n', '        finalVKalpha[0] = in_vk[0];\n', '        finalVKalpha[1] = in_vk[1];\n', '        finalVKalpha[2] = inputAccumulators[0];\n', '\n', '        assembly {\n', '            // ECMUL, output to first 2 elements of finalVKalpha\n', '            success := staticcall(sub(gas(), 2000), 7, finalVKalpha, 0x60, finalVKalpha, 0x40)\n', '        }\n', '        if (!success) {\n', '            return (false, finalVksAlphaX);\n', '        }\n', '\n', '        finalVksAlphaX[0] = finalVKalpha[0];\n', '        finalVksAlphaX[1] = finalVKalpha[1];\n', '    }\n', '\n', '    // original equation\n', '    // e(proof.A, proof.B)*e(-vk.alpha, vk.beta)*e(-vk_x, vk.gamma)*e(-proof.C, vk.delta) == 1\n', '    // accumulation of inputs\n', '    // gammaABC[0] + sum[ gammaABC[i+1]^proof_inputs[i] ]\n', '\n', '    function BatchVerify (\n', '        uint256[14] memory in_vk, // verifying key is always constant number of elements\n', '        uint256[4] memory vk_gammaABC, // variable length, depends on number of inputs\n', '        uint256[] memory in_proof, // proof itself, length is 8 * num_proofs\n', '        uint256[] memory proof_inputs, // public inputs, length is num_inputs * num_proofs\n', '        uint256 num_proofs\n', '    )\n', '    internal\n', '    view\n', '    returns (bool success)\n', '    {\n', '        require(in_proof.length == num_proofs * 8, "Invalid proofs length for a batch");\n', '        require(proof_inputs.length % num_proofs == 0, "Invalid inputs length for a batch");\n', '        require(((vk_gammaABC.length / 2) - 1) == proof_inputs.length / num_proofs, "Invalid verification key");\n', '\n', '        // strategy is to accumulate entropy separately for some proof elements\n', "        // (accumulate only for G1, can't in G2) of the pairing equation, as well as input verification key,\n", '        // postpone scalar multiplication as much as possible and check only one equation\n', '        // by using 3 + num_proofs pairings only plus 2*num_proofs + (num_inputs+1) + 1 scalar multiplications compared to naive\n', '        // 4*num_proofs pairings and num_proofs*(num_inputs+1) scalar multiplications\n', '\n', '        bool valid;\n', '        uint256[] memory proofsAandC;\n', '        uint256[] memory inputAccumulators;\n', '        (valid, proofsAandC, inputAccumulators) = accumulate(in_proof, proof_inputs, num_proofs);\n', '        if (!valid) {\n', '            return false;\n', '        }\n', '\n', '        uint256[4] memory finalVksAlphaX;\n', '        (valid, finalVksAlphaX) = prepareBatches(in_vk, vk_gammaABC, inputAccumulators);\n', '        if (!valid) {\n', '            return false;\n', '        }\n', '\n', '        uint256[] memory inputs = new uint256[](6*num_proofs + 18);\n', '        // first num_proofs pairings e(ProofA, ProofB)\n', '        for (uint256 proofNumber = 0; proofNumber < num_proofs; proofNumber++) {\n', '            inputs[proofNumber*6] = proofsAandC[proofNumber*2];\n', '            inputs[proofNumber*6 + 1] = proofsAandC[proofNumber*2 + 1];\n', '            inputs[proofNumber*6 + 2] = in_proof[proofNumber*8 + 2];\n', '            inputs[proofNumber*6 + 3] = in_proof[proofNumber*8 + 3];\n', '            inputs[proofNumber*6 + 4] = in_proof[proofNumber*8 + 4];\n', '            inputs[proofNumber*6 + 5] = in_proof[proofNumber*8 + 5];\n', '        }\n', '\n', '        // second pairing e(-finalVKaplha, vk.beta)\n', '        inputs[num_proofs*6] = finalVksAlphaX[0];\n', '        inputs[num_proofs*6 + 1] = NegateY(finalVksAlphaX[1]);\n', '        inputs[num_proofs*6 + 2] = in_vk[2];\n', '        inputs[num_proofs*6 + 3] = in_vk[3];\n', '        inputs[num_proofs*6 + 4] = in_vk[4];\n', '        inputs[num_proofs*6 + 5] = in_vk[5];\n', '\n', '        // third pairing e(-finalVKx, vk.gamma)\n', '        inputs[num_proofs*6 + 6] = finalVksAlphaX[2];\n', '        inputs[num_proofs*6 + 7] = NegateY(finalVksAlphaX[3]);\n', '        inputs[num_proofs*6 + 8] = in_vk[6];\n', '        inputs[num_proofs*6 + 9] = in_vk[7];\n', '        inputs[num_proofs*6 + 10] = in_vk[8];\n', '        inputs[num_proofs*6 + 11] = in_vk[9];\n', '\n', '        // fourth pairing e(-proof.C, finalVKdelta)\n', '        inputs[num_proofs*6 + 12] = proofsAandC[num_proofs*2];\n', '        inputs[num_proofs*6 + 13] = NegateY(proofsAandC[num_proofs*2 + 1]);\n', '        inputs[num_proofs*6 + 14] = in_vk[10];\n', '        inputs[num_proofs*6 + 15] = in_vk[11];\n', '        inputs[num_proofs*6 + 16] = in_vk[12];\n', '        inputs[num_proofs*6 + 17] = in_vk[13];\n', '\n', '        uint256 inputsLength = inputs.length * 32;\n', '        uint[1] memory out;\n', '        require(inputsLength % 192 == 0, "Inputs length should be multiple of 192 bytes");\n', '\n', '        assembly {\n', '            success := staticcall(sub(gas(), 2000), 8, add(inputs, 0x20), inputsLength, out, 0x20)\n', '        }\n', '        return success && out[0] == 1;\n', '    }\n', '}\n', '\n', '\n', '// This code is taken from https://github.com/HarryR/ethsnarks/blob/master/contracts/Verifier.sol\n', '// this code is taken from https://github.com/JacobEberhardt/ZoKrates\n', '\n', '\n', 'library Verifier\n', '{\n', '    function ScalarField ()\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n', '    }\n', '\n', '    function NegateY( uint256 Y )\n', '        internal pure returns (uint256)\n', '    {\n', '        uint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n', '        return q - (Y % q);\n', '    }\n', '\n', '\n', '    /*\n', '    * This implements the Solidity equivalent of the following Python code:\n', '\n', '        from py_ecc.bn128 import *\n', '\n', '        data = # ... arguments to function [in_vk, vk_gammaABC, in_proof, proof_inputs]\n', '\n', '        vk = [int(_, 16) for _ in data[0]]\n', '        ic = [FQ(int(_, 16)) for _ in data[1]]\n', '        proof = [int(_, 16) for _ in data[2]]\n', '        inputs = [int(_, 16) for _ in data[3]]\n', '\n', '        it = iter(ic)\n', '        ic = [(_, next(it)) for _ in it]\n', '        vk_alpha = [FQ(_) for _ in vk[:2]]\n', '        vk_beta = (FQ2(vk[2:4][::-1]), FQ2(vk[4:6][::-1]))\n', '        vk_gamma = (FQ2(vk[6:8][::-1]), FQ2(vk[8:10][::-1]))\n', '        vk_delta = (FQ2(vk[10:12][::-1]), FQ2(vk[12:14][::-1]))\n', '\n', '        assert is_on_curve(vk_alpha, b)\n', '        assert is_on_curve(vk_beta, b2)\n', '        assert is_on_curve(vk_gamma, b2)\n', '        assert is_on_curve(vk_delta, b2)\n', '\n', '        proof_A = [FQ(_) for _ in proof[:2]]\n', '        proof_B = (FQ2(proof[2:4][::-1]), FQ2(proof[4:-2][::-1]))\n', '        proof_C = [FQ(_) for _ in proof[-2:]]\n', '\n', '        assert is_on_curve(proof_A, b)\n', '        assert is_on_curve(proof_B, b2)\n', '        assert is_on_curve(proof_C, b)\n', '\n', '        vk_x = ic[0]\n', '        for i, s in enumerate(inputs):\n', '            vk_x = add(vk_x, multiply(ic[i + 1], s))\n', '\n', '        check_1 = pairing(proof_B, proof_A)\n', '        check_2 = pairing(vk_beta, neg(vk_alpha))\n', '        check_3 = pairing(vk_gamma, neg(vk_x))\n', '        check_4 = pairing(vk_delta, neg(proof_C))\n', '\n', '        ok = check_1 * check_2 * check_3 * check_4\n', '        assert ok == FQ12.one()\n', '    */\n', '    function Verify(\n', '        uint256[14] memory in_vk,\n', '        uint256[4] memory vk_gammaABC,\n', '        uint256[] memory in_proof,\n', '        uint256[] memory proof_inputs\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        uint256 snark_scalar_field = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n', '        require(((vk_gammaABC.length / 2) - 1) == proof_inputs.length, "INVALID_VALUE");\n', '\n', '        // Compute the linear combination vk_x\n', '        uint256[3] memory mul_input;\n', '        uint256[4] memory add_input;\n', '        bool success;\n', '        uint m = 2;\n', '\n', '        // First two fields are used as the sum\n', '        add_input[0] = vk_gammaABC[0];\n', '        add_input[1] = vk_gammaABC[1];\n', '\n', '        // Performs a sum of gammaABC[0] + sum[ gammaABC[i+1]^proof_inputs[i] ]\n', '        for (uint i = 0; i < proof_inputs.length; i++) {\n', '            require(proof_inputs[i] < snark_scalar_field, "INVALID_INPUT");\n', '            mul_input[0] = vk_gammaABC[m++];\n', '            mul_input[1] = vk_gammaABC[m++];\n', '            mul_input[2] = proof_inputs[i];\n', '\n', '            assembly {\n', '                // ECMUL, output to last 2 elements of `add_input`\n', '                success := staticcall(sub(gas(), 2000), 7, mul_input, 0x80, add(add_input, 0x40), 0x60)\n', '            }\n', '            if (!success) {\n', '                return false;\n', '            }\n', '\n', '            assembly {\n', '                // ECADD\n', '                success := staticcall(sub(gas(), 2000), 6, add_input, 0xc0, add_input, 0x60)\n', '            }\n', '            if (!success) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        uint[24] memory input = [\n', '            // (proof.A, proof.B)\n', '            in_proof[0], in_proof[1],                           // proof.A   (G1)\n', '            in_proof[2], in_proof[3], in_proof[4], in_proof[5], // proof.B   (G2)\n', '\n', '            // (-vk.alpha, vk.beta)\n', '            in_vk[0], NegateY(in_vk[1]),                        // -vk.alpha (G1)\n', '            in_vk[2], in_vk[3], in_vk[4], in_vk[5],             // vk.beta   (G2)\n', '\n', '            // (-vk_x, vk.gamma)\n', '            add_input[0], NegateY(add_input[1]),                // -vk_x     (G1)\n', '            in_vk[6], in_vk[7], in_vk[8], in_vk[9],             // vk.gamma  (G2)\n', '\n', '            // (-proof.C, vk.delta)\n', '            in_proof[6], NegateY(in_proof[7]),                  // -proof.C  (G1)\n', '            in_vk[10], in_vk[11], in_vk[12], in_vk[13]          // vk.delta  (G2)\n', '        ];\n', '\n', '        uint[1] memory out;\n', '        assembly {\n', '            success := staticcall(sub(gas(), 2000), 8, input, 768, out, 0x20)\n', '        }\n', '        return success && out[0] != 0;\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', 'interface IAgent{}\n', '\n', 'interface IAgentRegistry\n', '{\n', '    /// @dev Returns whether an agent address is an agent of an account owner\n', '    /// @param owner The account owner.\n', '    /// @param agent The agent address\n', '    /// @return True if the agent address is an agent for the account owner, else false\n', '    function isAgent(\n', '        address owner,\n', '        address agent\n', '        )\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Returns whether an agent address is an agent of all account owners\n', '    /// @param owners The account owners.\n', '    /// @param agent The agent address\n', '    /// @return True if the agent address is an agent for the account owner, else false\n', '    function isAgent(\n', '        address[] calldata owners,\n', '        address            agent\n', '        )\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title IDepositContract.\n', '/// @dev   Contract storing and transferring funds for an exchange.\n', '///\n', '///        ERC1155 tokens can be supported by registering pseudo token addresses calculated\n', '///        as `address(keccak256(real_token_address, token_params))`. Then the custom\n', '///        deposit contract can look up the real token address and paramsters with the\n', '///        pseudo token address before doing the transfers.\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'interface IDepositContract\n', '{\n', '    /// @dev Returns if a token is suppoprted by this contract.\n', '    function isTokenSupported(address token)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Transfers tokens from a user to the exchange. This function will\n', '    ///      be called when a user deposits funds to the exchange.\n', '    ///      In a simple implementation the funds are simply stored inside the\n', '    ///      deposit contract directly. More advanced implementations may store the funds\n', '    ///      in some DeFi application to earn interest, so this function could directly\n', '    ///      call the necessary functions to store the funds there.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', '    /// @param token The address of the token to transfer (`0x0` for ETH).\n', '    /// @param amount The amount of tokens to transfer.\n', '    /// @param extraData Opaque data that can be used by the contract to handle the deposit\n', "    /// @return amountReceived The amount to deposit to the user's account in the Merkle tree\n", '    function deposit(\n', '        address from,\n', '        address token,\n', '        uint96  amount,\n', '        bytes   calldata extraData\n', '        )\n', '        external\n', '        payable\n', '        returns (uint96 amountReceived);\n', '\n', '    /// @dev Transfers tokens from the exchange to a user. This function will\n', '    ///      be called when a withdrawal is done for a user on the exchange.\n', '    ///      In the simplest implementation the funds are simply stored inside the\n', '    ///      deposit contract directly so this simply transfers the requested tokens back\n', '    ///      to the user. More advanced implementations may store the funds\n', '    ///      in some DeFi application to earn interest so the function would\n', '    ///      need to get those tokens back from the DeFi application first before they\n', '    ///      can be transferred to the user.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', "    /// @param from The address from which 'amount' tokens are transferred.\n", "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (`0x0` for ETH).\n', '    /// @param amount The amount of tokens transferred.\n', '    /// @param extraData Opaque data that can be used by the contract to handle the withdrawal\n', '    function withdraw(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount,\n', '        bytes   calldata extraData\n', '        )\n', '        external\n', '        payable;\n', '\n', '    /// @dev Transfers tokens (ETH not supported) for a user using the allowance set\n', '    ///      for the exchange. This way the approval can be used for all functionality (and\n', '    ///      extended functionality) of the exchange.\n', '    ///      Should NOT be used to deposit/withdraw user funds, `deposit`/`withdraw`\n', '    ///      should be used for that as they will contain specialised logic for those operations.\n', '    ///      This function can be called by the exchange to transfer onchain funds of users\n', '    ///      necessary for Agent functionality.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (ETH is and cannot be suppported).\n', '    /// @param amount The amount of tokens transferred.\n', '    function transfer(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '        )\n', '        external\n', '        payable;\n', '\n', '    /// @dev Checks if the given address is used for depositing ETH or not.\n', '    ///      Is used while depositing to send the correct ETH amount to the deposit contract.\n', '    ///\n', '    ///      Note that 0x0 is always registered for deposting ETH when the exchange is created!\n', '    ///      This function allows additional addresses to be used for depositing ETH, the deposit\n', '    ///      contract can implement different behaviour based on the address value.\n', '    ///\n', '    /// @param addr The address to check\n', '    /// @return True if the address is used for depositing ETH, else false.\n', '    function isETH(address addr)\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title ILoopringV3\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @author Daniel Wang  - <daniel@loopring.org>\n', 'abstract contract ILoopringV3 is Claimable\n', '{\n', '    // == Events ==\n', '    event ExchangeStakeDeposited(address exchangeAddr, uint amount);\n', '    event ExchangeStakeWithdrawn(address exchangeAddr, uint amount);\n', '    event ExchangeStakeBurned(address exchangeAddr, uint amount);\n', '    event SettingsUpdated(uint time);\n', '\n', '    // == Public Variables ==\n', '    mapping (address => uint) internal exchangeStake;\n', '\n', '    address public lrcAddress;\n', '    uint    public totalStake;\n', '    address public blockVerifierAddress;\n', '    uint    public forcedWithdrawalFee;\n', '    uint    public tokenRegistrationFeeLRCBase;\n', '    uint    public tokenRegistrationFeeLRCDelta;\n', '    uint8   public protocolTakerFeeBips;\n', '    uint8   public protocolMakerFeeBips;\n', '\n', '    address payable public protocolFeeVault;\n', '\n', '    // == Public Functions ==\n', '    /// @dev Updates the global exchange settings.\n', '    ///      This function can only be called by the owner of this contract.\n', '    ///\n', '    ///      Warning: these new values will be used by existing and\n', '    ///      new Loopring exchanges.\n', '    function updateSettings(\n', '        address payable _protocolFeeVault,   // address(0) not allowed\n', '        address _blockVerifierAddress,       // address(0) not allowed\n', '        uint    _forcedWithdrawalFee\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Updates the global protocol fee settings.\n', '    ///      This function can only be called by the owner of this contract.\n', '    ///\n', '    ///      Warning: these new values will be used by existing and\n', '    ///      new Loopring exchanges.\n', '    function updateProtocolFeeSettings(\n', '        uint8 _protocolTakerFeeBips,\n', '        uint8 _protocolMakerFeeBips\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the amount of staked LRC for an exchange.\n', '    /// @param exchangeAddr The address of the exchange\n', '    /// @return stakedLRC The amount of LRC\n', '    function getExchangeStake(\n', '        address exchangeAddr\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint stakedLRC);\n', '\n', '    /// @dev Burns a certain amount of staked LRC for a specific exchange.\n', '    ///      This function is meant to be called only from exchange contracts.\n', '    /// @return burnedLRC The amount of LRC burned. If the amount is greater than\n', '    ///         the staked amount, all staked LRC will be burned.\n', '    function burnExchangeStake(\n', '        uint amount\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint burnedLRC);\n', '\n', '    /// @dev Stakes more LRC for an exchange.\n', '    /// @param  exchangeAddr The address of the exchange\n', '    /// @param  amountLRC The amount of LRC to stake\n', '    /// @return stakedLRC The total amount of LRC staked for the exchange\n', '    function depositExchangeStake(\n', '        address exchangeAddr,\n', '        uint    amountLRC\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint stakedLRC);\n', '\n', '    /// @dev Withdraws a certain amount of staked LRC for an exchange to the given address.\n', '    ///      This function is meant to be called only from within exchange contracts.\n', '    /// @param  recipient The address to receive LRC\n', '    /// @param  requestedAmount The amount of LRC to withdraw\n', '    /// @return amountLRC The amount of LRC withdrawn\n', '    function withdrawExchangeStake(\n', '        address recipient,\n', '        uint    requestedAmount\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint amountLRC);\n', '\n', '    /// @dev Gets the protocol fee values for an exchange.\n', '    /// @return takerFeeBips The protocol taker fee\n', '    /// @return makerFeeBips The protocol maker fee\n', '    function getProtocolFeeValues(\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (\n', '            uint8 takerFeeBips,\n', '            uint8 makerFeeBips\n', '        );\n', '}\n', '\n', '\n', '\n', '/// @title ExchangeData\n', '/// @dev All methods in this lib are internal, therefore, there is no need\n', '///      to deploy this library independently.\n', '/// @author Daniel Wang  - <daniel@loopring.org>\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library ExchangeData\n', '{\n', '    // -- Enums --\n', '    enum TransactionType\n', '    {\n', '        NOOP,\n', '        DEPOSIT,\n', '        WITHDRAWAL,\n', '        TRANSFER,\n', '        SPOT_TRADE,\n', '        ACCOUNT_UPDATE,\n', '        AMM_UPDATE\n', '    }\n', '\n', '    // -- Structs --\n', '    struct Token\n', '    {\n', '        address token;\n', '    }\n', '\n', '    struct ProtocolFeeData\n', '    {\n', '        uint32 syncedAt; // only valid before 2105 (85 years to go)\n', '        uint8  takerFeeBips;\n', '        uint8  makerFeeBips;\n', '        uint8  previousTakerFeeBips;\n', '        uint8  previousMakerFeeBips;\n', '    }\n', '\n', '    // General auxiliary data for each conditional transaction\n', '    struct AuxiliaryData\n', '    {\n', '        uint  txIndex;\n', '        bytes data;\n', '    }\n', '\n', '    // This is the (virtual) block the owner  needs to submit onchain to maintain the\n', '    // per-exchange (virtual) blockchain.\n', '    struct Block\n', '    {\n', '        uint8      blockType;\n', '        uint16     blockSize;\n', '        uint8      blockVersion;\n', '        bytes      data;\n', '        uint256[8] proof;\n', '\n', '        // Whether we should store the @BlockInfo for this block on-chain.\n', '        bool storeBlockInfoOnchain;\n', '\n', '        // Block specific data that is only used to help process the block on-chain.\n', '        // It is not used as input for the circuits and it is not necessary for data-availability.\n', '        AuxiliaryData[] auxiliaryData;\n', '\n', '        // Arbitrary data, mainly for off-chain data-availability, i.e.,\n', '        // the multihash of the IPFS file that contains the block data.\n', '        bytes offchainData;\n', '    }\n', '\n', '    struct BlockInfo\n', '    {\n', '        // The time the block was submitted on-chain.\n', '        uint32  timestamp;\n', '        // The public data hash of the block (the 28 most significant bytes).\n', '        bytes28 blockDataHash;\n', '    }\n', '\n', '    // Represents an onchain deposit request.\n', '    struct Deposit\n', '    {\n', '        uint96 amount;\n', '        uint64 timestamp;\n', '    }\n', '\n', '    // A forced withdrawal request.\n', "    // If the actual owner of the account initiated the request (we don't know who the owner is\n", '    // at the time the request is being made) the full balance will be withdrawn.\n', '    struct ForcedWithdrawal\n', '    {\n', '        address owner;\n', '        uint64  timestamp;\n', '    }\n', '\n', '    struct Constants\n', '    {\n', '        uint SNARK_SCALAR_FIELD;\n', '        uint MAX_OPEN_FORCED_REQUESTS;\n', '        uint MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE;\n', '        uint TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS;\n', '        uint MAX_NUM_ACCOUNTS;\n', '        uint MAX_NUM_TOKENS;\n', '        uint MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED;\n', '        uint MIN_TIME_IN_SHUTDOWN;\n', '        uint TX_DATA_AVAILABILITY_SIZE;\n', '        uint MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND;\n', '    }\n', '\n', '    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\n', '        // This is the prime number that is used for the alt_bn128 elliptic curve, see EIP-196.\n', '        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n', '    }\n', '    function MAX_OPEN_FORCED_REQUESTS() internal pure returns (uint16) { return 4096; }\n', '    function MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 15 days; }\n', '    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 7 days; }\n', '    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 32; }\n', '    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 16; }\n', '    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 7 days; }\n', '    function MIN_TIME_IN_SHUTDOWN() internal pure returns (uint32) { return 30 days; }\n', '    // The amount of bytes each rollup transaction uses in the block data for data-availability.\n', '    // This is the maximum amount of bytes of all different transaction types.\n', '    function TX_DATA_AVAILABILITY_SIZE() internal pure returns (uint32) { return 68; }\n', '    function MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND() internal pure returns (uint32) { return 15 days; }\n', '    function ACCOUNTID_PROTOCOLFEE() internal pure returns (uint32) { return 0; }\n', '\n', '    function TX_DATA_AVAILABILITY_SIZE_PART_1() internal pure returns (uint32) { return 29; }\n', '    function TX_DATA_AVAILABILITY_SIZE_PART_2() internal pure returns (uint32) { return 39; }\n', '\n', '    struct AccountLeaf\n', '    {\n', '        uint32   accountID;\n', '        address  owner;\n', '        uint     pubKeyX;\n', '        uint     pubKeyY;\n', '        uint32   nonce;\n', '        uint     feeBipsAMM;\n', '    }\n', '\n', '    struct BalanceLeaf\n', '    {\n', '        uint16   tokenID;\n', '        uint96   balance;\n', '        uint96   weightAMM;\n', '        uint     storageRoot;\n', '    }\n', '\n', '    struct MerkleProof\n', '    {\n', '        ExchangeData.AccountLeaf accountLeaf;\n', '        ExchangeData.BalanceLeaf balanceLeaf;\n', '        uint[48]                 accountMerkleProof;\n', '        uint[24]                 balanceMerkleProof;\n', '    }\n', '\n', '    struct BlockContext\n', '    {\n', '        bytes32 DOMAIN_SEPARATOR;\n', '        uint32  timestamp;\n', '    }\n', '\n', '    // Represents the entire exchange state except the owner of the exchange.\n', '    struct State\n', '    {\n', '        uint32  maxAgeDepositUntilWithdrawable;\n', '        bytes32 DOMAIN_SEPARATOR;\n', '\n', '        ILoopringV3      loopring;\n', '        IBlockVerifier   blockVerifier;\n', '        IAgentRegistry   agentRegistry;\n', '        IDepositContract depositContract;\n', '\n', '\n', '        // The merkle root of the offchain data stored in a Merkle tree. The Merkle tree\n', '        // stores balances for users using an account model.\n', '        bytes32 merkleRoot;\n', '\n', '        // List of all blocks\n', '        mapping(uint => BlockInfo) blocks;\n', '        uint  numBlocks;\n', '\n', '        // List of all tokens\n', '        Token[] tokens;\n', '\n', '        // A map from a token to its tokenID + 1\n', '        mapping (address => uint16) tokenToTokenId;\n', '\n', '        // A map from an accountID to a tokenID to if the balance is withdrawn\n', '        mapping (uint32 => mapping (uint16 => bool)) withdrawnInWithdrawMode;\n', '\n', '        // A map from an account to a token to the amount withdrawable for that account.\n', '        // This is only used when the automatic distribution of the withdrawal failed.\n', '        mapping (address => mapping (uint16 => uint)) amountWithdrawable;\n', '\n', '        // A map from an account to a token to the forced withdrawal (always full balance)\n', '        mapping (uint32 => mapping (uint16 => ForcedWithdrawal)) pendingForcedWithdrawals;\n', '\n', '        // A map from an address to a token to a deposit\n', '        mapping (address => mapping (uint16 => Deposit)) pendingDeposits;\n', '\n', '        // A map from an account owner to an approved transaction hash to if the transaction is approved or not\n', '        mapping (address => mapping (bytes32 => bool)) approvedTx;\n', '\n', '        // A map from an account owner to a destination address to a tokenID to an amount to a storageID to a new recipient address\n', '        mapping (address => mapping (address => mapping (uint16 => mapping (uint => mapping (uint32 => address))))) withdrawalRecipient;\n', '\n', '\n', '        // Counter to keep track of how many of forced requests are open so we can limit the work that needs to be done by the owner\n', '        uint32 numPendingForcedTransactions;\n', '\n', '        // Cached data for the protocol fee\n', '        ProtocolFeeData protocolFeeData;\n', '\n', '        // Time when the exchange was shutdown\n', '        uint shutdownModeStartTime;\n', '\n', '        // Time when the exchange has entered withdrawal mode\n', '        uint withdrawalModeStartTime;\n', '\n', '        // Last time the protocol fee was withdrawn for a specific token\n', '        mapping (address => uint) protocolFeeLastWithdrawnTime;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/// @title An Implementation of IBlockVerifier.\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'contract BlockVerifier is ReentrancyGuard, IBlockVerifier\n', '{\n', '    struct Circuit\n', '    {\n', '        bool registered;\n', '        bool enabled;\n', '        uint[18] verificationKey;\n', '    }\n', '\n', '    mapping (uint8 => mapping (uint16 => mapping (uint8 => Circuit))) public circuits;\n', '\n', '    constructor() Claimable() {}\n', '\n', '    function registerCircuit(\n', '        uint8    blockType,\n', '        uint16   blockSize,\n', '        uint8    blockVersion,\n', '        uint[18] calldata vk\n', '        )\n', '        external\n', '        override\n', '        nonReentrant\n', '        onlyOwner\n', '    {\n', '        Circuit storage circuit = circuits[blockType][blockSize][blockVersion];\n', '        require(circuit.registered == false, "ALREADY_REGISTERED");\n', '\n', '        for (uint i = 0; i < 18; i++) {\n', '            circuit.verificationKey[i] = vk[i];\n', '        }\n', '        circuit.registered = true;\n', '        circuit.enabled = true;\n', '\n', '        emit CircuitRegistered(\n', '            blockType,\n', '            blockSize,\n', '            blockVersion\n', '        );\n', '    }\n', '\n', '    function disableCircuit(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        override\n', '        nonReentrant\n', '        onlyOwner\n', '    {\n', '        Circuit storage circuit = circuits[blockType][blockSize][blockVersion];\n', '        require(circuit.registered == true, "NOT_REGISTERED");\n', '        require(circuit.enabled == true, "ALREADY_DISABLED");\n', '\n', '        circuit.enabled = false;\n', '\n', '        emit CircuitDisabled(\n', '            blockType,\n', '            blockSize,\n', '            blockVersion\n', '        );\n', '    }\n', '\n', '    function verifyProofs(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion,\n', '        uint[] calldata publicInputs,\n', '        uint[] calldata proofs\n', '        )\n', '        external\n', '        override\n', '        view\n', '        returns (bool)\n', '    {\n', '        Circuit storage circuit = circuits[blockType][blockSize][blockVersion];\n', '        require(circuit.registered == true, "NOT_REGISTERED");\n', '\n', '        uint[18] storage vk = circuit.verificationKey;\n', '        uint[14] memory _vk = [\n', '            vk[0], vk[1], vk[2], vk[3], vk[4], vk[5], vk[6],\n', '            vk[7], vk[8], vk[9], vk[10], vk[11], vk[12], vk[13]\n', '        ];\n', '        uint[4] memory _vk_gammaABC = [vk[14], vk[15], vk[16], vk[17]];\n', '\n', '        if (publicInputs.length == 1) {\n', '            return Verifier.Verify(_vk, _vk_gammaABC, proofs, publicInputs);\n', '        } else {\n', '            return BatchVerifier.BatchVerify(\n', '                _vk,\n', '                _vk_gammaABC,\n', '                proofs,\n', '                publicInputs,\n', '                publicInputs.length\n', '            );\n', '        }\n', '    }\n', '\n', '    function isCircuitRegistered(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        override\n', '        view\n', '        returns (bool)\n', '    {\n', '        return circuits[blockType][blockSize][blockVersion].registered;\n', '    }\n', '\n', '    function isCircuitEnabled(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        override\n', '        view\n', '        returns (bool)\n', '    {\n', '        return circuits[blockType][blockSize][blockVersion].enabled;\n', '    }\n', '\n', '    function getVerificationKey(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        view\n', '        returns (uint[18] memory)\n', '    {\n', '        return circuits[blockType][blockSize][blockVersion].verificationKey;\n', '    }\n', '}']