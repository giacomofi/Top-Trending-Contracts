['// hevm: flattened sources of src/lp-farm.sol\n', 'pragma solidity >0.4.13 >=0.4.23 >=0.5.0 >=0.6.0 <0.7.0 >=0.6.2 <0.7.0 >=0.6.7 <0.7.0;\n', '\n', '////// lib/ds-auth/src/auth.sol\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity >=0.4.23; */\n', '\n', 'interface DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) external view returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(address(authority));\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig), "ds-auth-unauthorized");\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, address(this), sig);\n', '        }\n', '    }\n', '}\n', '\n', '////// lib/ds-math/src/math.sol\n', '/// math.sol -- mixin for inline numerical wizardry\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity >0.4.13; */\n', '\n', 'contract DSMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    //rounds to zero if x*y < WAD / 2\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    //rounds to zero if x*y < WAD / 2\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    //rounds to zero if x*y < WAD / 2\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    //rounds to zero if x*y < RAY / 2\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', "    // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '////// lib/ds-token/src/token.sol\n', '/// token.sol -- ERC20 implementation with minting and burning\n', '\n', '// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity >=0.4.23; */\n', '\n', '/* import "ds-math/math.sol"; */\n', '/* import "ds-auth/auth.sol"; */\n', '\n', '\n', 'contract DSToken is DSMath, DSAuth {\n', '    bool                                              public  stopped;\n', '    uint256                                           public  totalSupply;\n', '    mapping (address => uint256)                      public  balanceOf;\n', '    mapping (address => mapping (address => uint256)) public  allowance;\n', '    bytes32                                           public  symbol;\n', '    uint256                                           public  decimals = 18; // standard token precision. override to customize\n', '    bytes32                                           public  name = "";     // Optional token name\n', '\n', '    constructor(bytes32 symbol_) public {\n', '        symbol = symbol_;\n', '    }\n', '\n', '    event Approval(address indexed src, address indexed guy, uint wad);\n', '    event Transfer(address indexed src, address indexed dst, uint wad);\n', '    event Mint(address indexed guy, uint wad);\n', '    event Burn(address indexed guy, uint wad);\n', '    event Stop();\n', '    event Start();\n', '\n', '    modifier stoppable {\n', '        require(!stopped, "ds-stop-is-stopped");\n', '        _;\n', '    }\n', '\n', '    function approve(address guy) external returns (bool) {\n', '        return approve(guy, uint(-1));\n', '    }\n', '\n', '    function approve(address guy, uint wad) public stoppable returns (bool) {\n', '        allowance[msg.sender][guy] = wad;\n', '\n', '        emit Approval(msg.sender, guy, wad);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint wad) external returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        stoppable\n', '        returns (bool)\n', '    {\n', '        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n', '            require(allowance[src][msg.sender] >= wad, "ds-token-insufficient-approval");\n', '            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\n', '        }\n', '\n', '        require(balanceOf[src] >= wad, "ds-token-insufficient-balance");\n', '        balanceOf[src] = sub(balanceOf[src], wad);\n', '        balanceOf[dst] = add(balanceOf[dst], wad);\n', '\n', '        emit Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '\n', '    function push(address dst, uint wad) external {\n', '        transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function pull(address src, uint wad) external {\n', '        transferFrom(src, msg.sender, wad);\n', '    }\n', '\n', '    function move(address src, address dst, uint wad) external {\n', '        transferFrom(src, dst, wad);\n', '    }\n', '\n', '\n', '    function mint(uint wad) external {\n', '        mint(msg.sender, wad);\n', '    }\n', '\n', '    function burn(uint wad) external {\n', '        burn(msg.sender, wad);\n', '    }\n', '\n', '    function mint(address guy, uint wad) public auth stoppable {\n', '        balanceOf[guy] = add(balanceOf[guy], wad);\n', '        totalSupply = add(totalSupply, wad);\n', '        emit Mint(guy, wad);\n', '    }\n', '\n', '    function burn(address guy, uint wad) public auth stoppable {\n', '        if (guy != msg.sender && allowance[guy][msg.sender] != uint(-1)) {\n', '            require(allowance[guy][msg.sender] >= wad, "ds-token-insufficient-approval");\n', '            allowance[guy][msg.sender] = sub(allowance[guy][msg.sender], wad);\n', '        }\n', '\n', '        require(balanceOf[guy] >= wad, "ds-token-insufficient-balance");\n', '        balanceOf[guy] = sub(balanceOf[guy], wad);\n', '        totalSupply = sub(totalSupply, wad);\n', '        emit Burn(guy, wad);\n', '    }\n', '\n', '    function stop() public auth {\n', '        stopped = true;\n', '        emit Stop();\n', '    }\n', '\n', '    function start() public auth {\n', '        stopped = false;\n', '        emit Start();\n', '    }\n', '\n', '    function setName(bytes32 name_) external auth {\n', '        name = name_;\n', '    }\n', '}\n', '\n', '////// src/constants.sol\n', '/* pragma solidity ^0.6.7; */\n', '\n', '\n', 'library Constants {\n', '    // Tokens\n', '    address constant SNX = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n', '    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    address constant SUSHI = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\n', '    address constant UNIV2_SUSHI_ETH = 0xCE84867c3c02B05dc570d0135103d3fB9CC19433;\n', '    address constant UNIV2_SNX_ETH = 0x43AE24960e5534731Fc831386c07755A2dc33D47;\n', '\n', '    // Uniswap\n', '    address constant UNIV2_ROUTER2 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '\n', '    // Sushiswap\n', '    address constant MASTERCHEF = 0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd;\n', '}\n', '////// src/interfaces/masterchef.sol\n', '// SPDX-License-Identifier: MIT\n', '/* pragma solidity ^0.6.2; */\n', '\n', 'interface Masterchef {\n', '    function deposit(uint256 _pid, uint256 _amount) external;\n', '\n', '    function withdraw(uint256 _pid, uint256 _amount) external;\n', '\n', '    function pendingSushi(uint256 _pid, address _user)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function poolInfo(uint256)\n', '        external\n', '        view\n', '        returns (\n', '            address lpToken,\n', '            uint256 allocPoint,\n', '            uint256 lastRewardBlock,\n', '            uint256 accSushiPerShare\n', '        );\n', '\n', '    function userInfo(uint256, address)\n', '        external\n', '        view\n', '        returns (uint256 amount, uint256 rewardDebt);\n', '\n', '    function updatePool(uint256 _pid) external;\n', '}\n', '\n', '////// src/interfaces/uniswap.sol\n', '// SPDX-License-Identifier: MIT\n', '/* pragma solidity ^0.6.2; */\n', '\n', 'interface UniswapRouterV2 {\n', '    function swapExactTokensForTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function getAmountsOut(uint256 amountIn, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '\n', '    function getAmountsIn(uint256 amountOut, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '\n', '    function swapETHForExactTokens(\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (uint256[] memory amounts);\n', '}\n', '\n', 'interface UniswapPair {\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestamp\n', '        );\n', '}\n', '\n', '////// src/safe-math.sol\n', '// SPDX-License-Identifier: MIT\n', '// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n', '\n', '/* pragma solidity ^0.6.0; */\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '////// src/lp-farm.sol\n', '/* pragma solidity ^0.6.7; */\n', '\n', '/* import "ds-token/token.sol"; */\n', '\n', '/* import "./interfaces/masterchef.sol"; */\n', '/* import "./interfaces/uniswap.sol"; */\n', '\n', '/* import "./safe-math.sol"; */\n', '/* import "./constants.sol"; */\n', '\n', '// Liquidity Provider Farming for SushiSwap\n', '// Used to farm LP Tokens.\n', '\n', '// Based off https://github.com/iearn-finance/vaults/blob/master/contracts/yVault.sol\n', '\n', 'contract LPFarm {\n', '    using SafeMath for uint256;\n', '\n', '    // Tokens\n', '    DSToken public sushi = DSToken(Constants.SUSHI);\n', '    DSToken public snx = DSToken(Constants.SNX);\n', '    DSToken public weth = DSToken(Constants.WETH);\n', '    DSToken public lpToken = DSToken(Constants.UNIV2_SNX_ETH);\n', '    DSToken public degenLpToken;\n', '\n', '    // Uniswap Router and Pair\n', '    UniswapRouterV2 public univ2 = UniswapRouterV2(Constants.UNIV2_ROUTER2);\n', '    UniswapPair public univ2Pair = UniswapPair(address(lpToken));\n', '\n', '    // Masterchef Contract\n', '    Masterchef public masterchef = Masterchef(Constants.MASTERCHEF);\n', '    uint256 public poolId = 6;\n', '\n', '    // 5% harvester rewards\n', '    // 2.5% to dev\n', '    // 2.5% to harvester\n', '    uint256 public maxharvesterRewards = 5 ether;\n', '    address public dev = 0xAbcCB8f0a3c206Bb0468C52CCc20f3b81077417B;\n', '\n', '\n', '    constructor() public {\n', '        degenLpToken = new DSToken("dUNI-V2");\n', '        degenLpToken.setName("Degen UNI-V2");\n', '    }\n', '\n', '    // **** Harvest profits ****\n', '\n', '    function harvestAndWithdrawAll() external {\n', '        harvest();\n', '        withdrawAll();\n', '    }\n', '\n', '    function harvest() public {\n', '        // Get rewards\n', '        masterchef.withdraw(poolId, 0);\n', '\n', '        uint256 sushiBal = sushi.balanceOf(address(this));\n', '        require(sushiBal > 0, "no-sushi");\n', '\n', '        // Converts 1/2 to ETH, 1/2 to SNX\n', '        // Add to liquidity pool\n', '        uint256 _before = getLpTokenBalance();\n', '        _convertSushiToLp(sushiBal);\n', '        uint256 _after = getLpTokenBalance();\n', '\n', '        uint256 _amount = _after.sub(_before);\n', '\n', '        // Caller gets 2.5%, Dev gets 2.5%\n', '        uint256 _rewards = _amount.mul(maxharvesterRewards).div(100 ether);\n', '        lpToken.transfer(dev, _rewards.div(2));\n', '        lpToken.transfer(msg.sender, _rewards.div(2));\n', '\n', '        // Deposit to SNX/ETH pool\n', '        _amount = lpToken.balanceOf(address(this));\n', '        lpToken.approve(address(masterchef), _amount);\n', '        masterchef.deposit(poolId, _amount);\n', '    }\n', '\n', '    function _convertSushiToLp(uint256 _amount) internal {\n', '        // SUSHI -> WETH\n', '        address[] memory wethPath = new address[](2);\n', '        wethPath[0] = address(sushi);\n', '        wethPath[1] = address(weth);\n', '        sushi.approve(address(univ2), _amount);\n', '        univ2.swapExactTokensForTokens(\n', '            _amount,\n', '            0,\n', '            wethPath,\n', '            address(this),\n', '            now + 60\n', '        );\n', '\n', '        // 1/2 of WETH\n', '        // WETH -> SNX\n', '        uint256 wethHalf = weth.balanceOf(address(this)).div(2);\n', '        address[] memory snxPath = new address[](2);\n', '        snxPath[0] = address(weth);\n', '        snxPath[1] = address(snx);\n', '        weth.approve(address(univ2), wethHalf);\n', '        univ2.swapExactTokensForTokens(\n', '            wethHalf,\n', '            0,\n', '            snxPath,\n', '            address(this),\n', '            now + 60\n', '        );\n', '\n', '        // Add liquidity\n', '        uint256 snxBal = snx.balanceOf(address(this));\n', '        uint256 wethBal = weth.balanceOf(address(this));\n', '        snx.approve(address(univ2), snxBal);\n', '        weth.approve(address(univ2), wethBal);\n', '        univ2.addLiquidity(\n', '            address(snx),\n', '            address(weth),\n', '            snxBal,\n', '            wethBal,\n', '            0,\n', '            0,\n', '            address(this),\n', '            now + 60\n', '        );\n', '    }\n', '\n', '    // **** Withdraw / Deposit functions ****\n', '\n', '    function withdrawAll() public {\n', '        withdraw(degenLpToken.balanceOf(msg.sender));\n', '    }\n', '\n', '    function withdraw(uint256 _shares) public {\n', '        // Calculate amount to withdraw\n', '        uint256 _amount = getLpTokenBalance()\n', '            .div(degenLpToken.totalSupply())\n', '            .mul(_shares);\n', '\n', '        degenLpToken.burn(msg.sender, _shares);\n', '\n', '        // Withdraw tokens\n', '        masterchef.withdraw(poolId, _amount);\n', '\n', '        // Send back to user\n', '        lpToken.transfer(msg.sender, _amount);\n', '    }\n', '\n', '    function depositAll() public {\n', '        deposit(lpToken.balanceOf(msg.sender));\n', '    }\n', '\n', '    function deposit(uint256 _amount) public {\n', '        uint256 _lpBal = getLpTokenBalance();\n', '        uint256 _before = lpToken.balanceOf(address(this));\n', '        lpToken.transferFrom(msg.sender, address(this), _amount);\n', '        uint256 _after = lpToken.balanceOf(address(this));\n', '\n', '        uint256 _obtained = _after.sub(_before);\n', '        uint256 _shares = 0;\n', '        uint256 _degenSupply = degenLpToken.totalSupply();\n', '\n', '        if (_degenSupply == 0) {\n', '            _shares = _obtained;\n', '        } else {\n', '            _shares = _obtained.mul(_degenSupply).div(_lpBal);\n', '        }\n', '\n', '        // Stake coins\n', '        lpToken.approve(address(masterchef), _amount);\n', '        masterchef.deposit(poolId, _obtained);\n', '\n', '        degenLpToken.mint(msg.sender, _shares);\n', '    }\n', '\n', '    function getRatioPerShare() public view returns (uint256) {\n', '        if (degenLpToken.totalSupply() == 0) {\n', '            return 0;\n', '        }\n', '        \n', '        return getLpTokenBalance().mul(1e18).div(degenLpToken.totalSupply());\n', '    }\n', '\n', '    function getLpTokenBalance() public view returns (uint256) {\n', '        (uint256 stakedBal, ) = masterchef.userInfo(poolId, address(this));\n', '\n', '        uint256 holdingBal = lpToken.balanceOf(address(this));\n', '\n', '        return stakedBal.add(holdingBal);\n', '    }\n', '}']