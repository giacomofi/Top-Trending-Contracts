['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-24\n', '*/\n', '\n', 'pragma solidity ^0.5.12;\n', '\n', 'contract ReserveLike {\n', '    function depositToken(address, string memory, bytes memory, uint) public;\n', '}\n', '\n', 'contract WrappedDaiLike {\n', '    function setProxy(address) public;\n', '    function setReserve(address) public;\n', '\n', '    uint public totalSupply;\n', '    function approve(address, uint) public returns (bool);\n', '\n', '    function mint(address, uint) public;\n', '    function burn(address, uint) public;\n', '}\n', '\n', 'contract DaiLike {\n', '    function approve(address, uint) public returns (bool);\n', '    function transferFrom(address, address, uint) public returns (bool);\n', '}\n', '\n', 'contract JoinLike {\n', '    VatLike public vat;\n', '    DaiLike public dai;\n', '\n', '    function join(address, uint) public;\n', '    function exit(address, uint) public;\n', '}\n', '\n', 'contract PotLike {\n', '    mapping(address => uint) public pie;\n', '    uint public chi;\n', '\n', '    VatLike public vat;\n', '    uint public rho;\n', '\n', '    function drip() public returns (uint);\n', '\n', '    function join(uint) public;\n', '    function exit(uint) public;\n', '}\n', '\n', 'contract VatLike {\n', '    mapping(address => uint) public dai;\n', '\n', '    function hope(address) public;\n', '    function move(address, address, uint) public;\n', '}\n', '\n', 'contract DaiProxy {\n', '    string public constant version = "0511";\n', '\n', '    // --- Owner ---\n', '    address public owner;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    event SetOwner(address owner);\n', '\n', '    function setOwner(address _owner) public onlyOwner {\n', '        owner = _owner;\n', '        emit SetOwner(_owner);\n', '    }\n', '\n', '    // --- State ---\n', '    enum State { Ready, Running, Killed }\n', '\n', '    State public state = State.Ready;\n', '\n', '    modifier notStarted {\n', '        require(state == State.Ready);\n', '        _;\n', '    }\n', '\n', '    modifier notPaused {\n', '        require(state == State.Running);\n', '        _;\n', '    }\n', '\n', '    // --- Math ---\n', '    uint constant ONE = 10 ** 27;\n', '\n', '    function add(uint a, uint b) private pure returns (uint) {\n', '        require(a <= uint(-1) - b);\n', '        return a + b;\n', '    }\n', '\n', '    function sub(uint a, uint b) private pure returns (uint) {\n', '        require(a >= b);\n', '        return a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) private pure returns (uint) {\n', '        require(b == 0 || a <= uint(-1) / b);\n', '        return a * b;\n', '    }\n', '\n', '    function div(uint a, uint b) private pure returns (uint) {\n', '        require(b != 0);\n', '        return a / b;\n', '    }\n', '\n', '    function ceil(uint a, uint b) private pure returns (uint) {\n', '        require(b != 0);\n', '\n', '        uint r = a / b;\n', '        return a > r * b ? r + 1 : r;\n', '    }\n', '\n', '    function muldiv(uint a, uint b, uint c) private pure returns (uint) {\n', '        uint safe = 1 << (256 - 32);  // 2.696e67\n', '        uint mask = (1 << 32) - 1;\n', '\n', '        require(c != 0 && c < safe);\n', '\n', '        if (b == 0) return 0;\n', '        if (a < b) (a, b) = (b, a);\n', '        \n', '        uint p = a / c;\n', '        uint r = a % c;\n', '\n', '        uint res = 0;\n', '\n', '        while (true) {  // most 8 times\n', '            uint v = b & mask;\n', '            res = add(res, add(mul(p, v), r * v / c));\n', '\n', '            b >>= 32;\n', '            if (b == 0) break;\n', '\n', '            require(p < safe);\n', '\n', '            p <<= 32;\n', '            r <<= 32;\n', '\n', '            p = add(p, r / c);\n', '            r %= c;\n', '        }\n', '\n', '        return res;\n', '    }\n', '\n', '    // --- Contracts & Constructor ---\n', '    DaiLike public Dai;\n', '    JoinLike public Join;\n', '    PotLike public Pot;\n', '    VatLike public Vat;\n', '\n', '    ReserveLike public Reserve;\n', '\n', '    WrappedDaiLike public EDai;\n', '    WrappedDaiLike public ODai;\n', '\n', '    event SetReserve(address reserve);\n', '\n', '    constructor(address dai, address join, address pot, address vat, address eDai, address oDai) public {\n', '        owner = msg.sender;\n', '\n', '        Dai = DaiLike(dai);\n', '        Join = JoinLike(join);\n', '        Pot = PotLike(pot);\n', '        Vat = VatLike(vat);\n', '\n', '        EDai = WrappedDaiLike(eDai);\n', '        ODai = WrappedDaiLike(oDai);\n', '\n', '        require(address(Join.dai()) == dai);\n', '        require(address(Join.vat()) == vat);\n', '        require(address(Pot.vat()) == vat);\n', '\n', '        Vat.hope(pot);  // Pot.join\n', '        Vat.hope(join);  // Join.exit\n', '\n', '        require(Dai.approve(join, uint(-1)));  // Join.join -> dai.burn\n', '    }\n', '\n', '    function setReserve(address reserve) public onlyOwner {\n', '        require(EDai.approve(address(Reserve), 0));\n', '        require(ODai.approve(address(Reserve), 0));\n', '\n', '        Reserve = ReserveLike(reserve);\n', '\n', '        EDai.setReserve(reserve);\n', '        ODai.setReserve(reserve);\n', '\n', '        // approve for Reserve.depositToken\n', '        require(EDai.approve(reserve, uint(-1)));\n', '        require(ODai.approve(reserve, uint(-1)));\n', '\n', '        emit SetReserve(reserve);\n', '    }\n', '\n', '    modifier onlyEDai {\n', '        require(msg.sender == address(EDai));\n', '        _;\n', '    }\n', '\n', '    modifier onlyODai {\n', '        require(msg.sender == address(ODai));\n', '        _;\n', '    }\n', '\n', '    // --- Integration ---\n', '    function chi() private returns (uint) {\n', '        return now > Pot.rho() ? Pot.drip() : Pot.chi();\n', '    }\n', '\n', '    function joinDai(uint dai) private {\n', '        require(Dai.transferFrom(msg.sender, address(this), dai));\n', '        Join.join(address(this), dai);\n', '\n', '        uint vat = Vat.dai(address(this));\n', '        Pot.join(div(vat, chi()));\n', '    }\n', '\n', '    function exitDai(address to, uint dai) private {\n', '        uint vat = Vat.dai(address(this));\n', '        uint req = mul(dai, ONE);\n', '\n', '        if (req > vat) {\n', '            uint pot = ceil(req - vat, chi());\n', '            Pot.exit(pot);\n', '        }\n', '\n', '        Join.exit(to, dai);\n', '    }\n', '\n', '    function mintODai(address to, uint dai) private returns (uint) {\n', '        uint wad = dai;\n', '\n', '        if (ODai.totalSupply() != 0) {\n', '            uint pie = Pot.pie(address(this));\n', '            uint vat = Vat.dai(address(this));\n', '\n', '            // 기존 rad\n', '            uint rad = sub(add(mul(pie, chi()), vat), mul(EDai.totalSupply(), ONE));\n', '\n', '            // rad : supply = dai * ONE : wad\n', '            wad = muldiv(ODai.totalSupply(), mul(dai, ONE), rad);\n', '        }\n', '\n', '        joinDai(dai);\n', '        ODai.mint(to, wad);\n', '        return wad;\n', '    }\n', '\n', '    function depositEDai(string memory toChain, uint dai, bytes memory to) public notPaused {\n', '        require(dai > 0);\n', '\n', '        joinDai(dai);\n', '\n', '        EDai.mint(address(this), dai);\n', '        Reserve.depositToken(address(EDai), toChain, to, dai);\n', '    }\n', '\n', '    function depositODai(string memory toChain, uint dai, bytes memory to) public notPaused {\n', '        require(dai > 0);\n', '\n', '        uint wad = mintODai(address(this), dai);\n', '        Reserve.depositToken(address(ODai), toChain, to, wad);\n', '    }\n', '\n', '    function swapFromEDai(address from, address to, uint dai) private {\n', '        EDai.burn(from, dai);\n', '        exitDai(to, dai);\n', '    }\n', '\n', '    function swapFromODai(address from, address to, uint wad) private {\n', '        uint pie = Pot.pie(address(this));\n', '        uint vat = Vat.dai(address(this));\n', '\n', '        // 기존 rad\n', '        uint rad = sub(add(mul(pie, chi()), vat), mul(EDai.totalSupply(), ONE));\n', '\n', '        // rad : supply = dai * ONE : wad\n', '        uint dai = muldiv(rad, wad, mul(ODai.totalSupply(), ONE));\n', '\n', '        ODai.burn(from, wad);\n', '        exitDai(to, dai);\n', '    }\n', '\n', '    function withdrawEDai(address to, uint dai) public onlyEDai notPaused {\n', '        require(dai > 0);\n', '\n', '        swapFromEDai(address(Reserve), to, dai);\n', '    }\n', '\n', '    function withdrawODai(address to, uint wad) public onlyODai notPaused {\n', '        require(wad > 0);\n', '\n', '        swapFromODai(address(Reserve), to, wad);\n', '    }\n', '\n', '    function swapToEDai(uint dai) public notPaused {\n', '        require(dai > 0);\n', '\n', '        joinDai(dai);\n', '        EDai.mint(msg.sender, dai);\n', '    }\n', '\n', '    function swapToODai(uint dai) public notPaused {\n', '        require(dai > 0);\n', '\n', '        mintODai(msg.sender, dai);\n', '    }\n', '\n', '    function swapFromEDai(uint dai) public notPaused {\n', '        require(dai > 0);\n', '\n', '        swapFromEDai(msg.sender, msg.sender, dai);\n', '    }\n', '\n', '    function swapFromODai(uint wad) public notPaused {\n', '        require(wad > 0);\n', '\n', '        swapFromODai(msg.sender, msg.sender, wad);\n', '    }\n', '\n', '    // --- Migration ---\n', '    DaiProxy public NewProxy;\n', '\n', '    event SetNewProxy(address proxy);\n', '    event StartProxy(address prev);\n', '    event KillProxy(address next, bool mig);\n', '\n', '    modifier onlyNewProxy {\n', '        require(msg.sender == address(NewProxy));\n', '        _;\n', '    }\n', '\n', '\n', '    function setNewProxy(address proxy) public onlyOwner {\n', '        NewProxy = DaiProxy(proxy);\n', '        emit SetNewProxy(proxy);\n', '    }\n', '\n', '\n', '    function killProxy(address to) public notPaused onlyOwner {\n', '        state = State.Killed;\n', '\n', '        chi();\n', '\n', '        Pot.exit(Pot.pie(address(this)));\n', '        Join.exit(to, Vat.dai(address(this)) / ONE);\n', '\n', '        emit KillProxy(to, false);\n', '    }\n', '\n', '\n', '    function migrateProxy() public notPaused onlyNewProxy {\n', '        state = State.Killed;\n', '\n', '        EDai.setProxy(address(NewProxy));\n', '        ODai.setProxy(address(NewProxy));\n', '\n', '        chi();\n', '\n', '        Pot.exit(Pot.pie(address(this)));\n', '        Vat.move(address(this), address(NewProxy), Vat.dai(address(this)));\n', '\n', '        emit KillProxy(address(NewProxy), true);\n', '    }\n', '\n', '\n', '    function startProxy(address oldProxy) public notStarted onlyOwner {\n', '        state = State.Running;\n', '\n', '        if (oldProxy != address(0)) {\n', '            DaiProxy(oldProxy).migrateProxy();\n', '\n', '            uint vat = Vat.dai(address(this));\n', '            Pot.join(div(vat, chi()));\n', '        }\n', '\n', '        emit StartProxy(oldProxy);\n', '    }\n', '}']