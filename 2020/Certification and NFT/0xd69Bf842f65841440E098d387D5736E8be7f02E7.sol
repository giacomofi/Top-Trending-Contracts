['pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Tellor Oracle Storage Library\n', ' * @dev Contains all the variables/structs used by Tellor\n', ' */\n', '\n', 'library TellorStorage {\n', '    //Internal struct for use in proof-of-work submission\n', '    struct Details {\n', '        uint256 value;\n', '        address miner;\n', '    }\n', '\n', '    struct Dispute {\n', '        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\n', '        int256 tally; //current tally of votes for - against measure\n', '        bool executed; //is the dispute settled\n', '        bool disputeVotePassed; //did the vote pass?\n', '        bool isPropFork; //true for fork proposal NEW\n', "        address reportedMiner; //miner who alledgedly submitted the 'bad value' will get disputeFee if dispute vote fails\n", "        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\n", '        address proposedForkAddress; //new fork address (if fork proposal)\n', '        mapping(bytes32 => uint256) disputeUintVars;\n', '        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\n', '        //e.g. TellorStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256("requestId")]\n', '        //These are the variables saved in this mapping:\n', '        // uint keccak256("requestId");//apiID of disputed value\n', '        // uint keccak256("timestamp");//timestamp of distputed value\n', '        // uint keccak256("value"); //the value being disputed\n', '        // uint keccak256("minExecutionDate");//7 days from when dispute initialized\n', '        // uint keccak256("numberOfVotes");//the number of parties who have voted on the measure\n', '        // uint keccak256("blockNumber");// the blocknumber for which votes will be calculated from\n', '        // uint keccak256("minerSlot"); //index in dispute array\n', '        // uint keccak256("fee"); //fee paid corresponding to dispute\n', '        mapping(address => bool) voted; //mapping of address to whether or not they voted\n', '    }\n', '\n', '    struct StakeInfo {\n', '        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute 4=ReadyForUnlocking 5=Unlocked\n', '        uint256 startDate; //stake start date\n', '    }\n', '\n', '    //Internal struct to allow balances to be queried by blocknumber for voting purposes\n', '    struct Checkpoint {\n', '        uint128 fromBlock; // fromBlock is the block number that the value was generated from\n', '        uint128 value; // value is the amount of tokens at a specific block number\n', '    }\n', '\n', '    struct Request {\n', '        string queryString; //id to string api\n', '        string dataSymbol; //short name for api request\n', '        bytes32 queryHash; //hash of api string and granularity e.g. keccak256(abi.encodePacked(_sapi,_granularity))\n', '        uint256[] requestTimestamps; //array of all newValueTimestamps requested\n', '        mapping(bytes32 => uint256) apiUintVars;\n', '        //Each of the variables below is saved in the mapping apiUintVars for each api request\n', '        //e.g. requestDetails[_requestId].apiUintVars[keccak256("totalTip")]\n', '        //These are the variables saved in this mapping:\n', '        // uint keccak256("granularity"); //multiplier for miners\n', '        // uint keccak256("requestQPosition"); //index in requestQ\n', '        // uint keccak256("totalTip");//bonus portion of payout\n', '        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\n', '        //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\n', '        mapping(uint256 => uint256) finalValues;\n', '        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\n', '        mapping(uint256 => address[5]) minersByValue;\n', '        mapping(uint256 => uint256[5]) valuesByTimestamp;\n', '    }\n', '\n', '    struct TellorStorageStruct {\n', '        bytes32 currentChallenge; //current challenge to be solved\n', '        uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\n', '        uint256[] newValueTimestamps; //array of all timestamps requested\n', '        Details[5] currentMiners; //This struct is for organizing the five mined values to find the median\n', '        mapping(bytes32 => address) addressVars;\n', '        //Address fields in the Tellor contract are saved the addressVars mapping\n', '        //e.g. addressVars[keccak256("tellorContract")] = address\n', '        //These are the variables saved in this mapping:\n', '        // address keccak256("tellorContract");//Tellor address\n', '        // address  keccak256("_owner");//Tellor Owner address\n', '        // address  keccak256("_deity");//Tellor Owner that can do things at will\n', '        // address  keccak256("pending_owner"); // The proposed new owner\n', '        mapping(bytes32 => uint256) uintVars;\n', '        //uint fields in the Tellor contract are saved the uintVars mapping\n', '        //e.g. uintVars[keccak256("decimals")] = uint\n', '        //These are the variables saved in this mapping:\n', '        // keccak256("decimals");    //18 decimal standard ERC20\n', '        // keccak256("disputeFee");//cost to dispute a mined value\n', '        // keccak256("disputeCount");//totalHistoricalDisputes\n', '        // keccak256("total_supply"); //total_supply of the token in circulation\n', '        // keccak256("stakeAmount");//stakeAmount for miners (we can cut gas if we just hardcode it in...or should it be variable?)\n', '        // keccak256("stakerCount"); //number of parties currently staked\n', '        // keccak256("timeOfLastNewValue"); // time of last challenge solved\n', '        // keccak256("difficulty"); // Difficulty of current block\n', '        // keccak256("currentTotalTips"); //value of highest api/timestamp PayoutPool\n', '        // keccak256("currentRequestId"); //API being mined--updates with the ApiOnQ Id\n', '        // keccak256("requestCount"); // total number of requests through the system\n', '        // keccak256("slotProgress");//Number of miners who have mined this value so far\n', '        // keccak256("miningReward");//Mining Reward in PoWo tokens given to all miners per value\n', '        // keccak256("timeTarget"); //The time between blocks (mined Oracle values)\n', '        // keccak256("_tblock"); //\n', '        // keccak256("runningTips"); // VAriable to track running tips\n', '        // keccak256("currentReward"); // The current reward\n', '        // keccak256("devShare"); // The amount directed towards th devShare\n', '        // keccak256("currentTotalTips"); //\n', '        //This is a boolean that tells you if a given challenge has been completed by a given miner\n', '        mapping(bytes32 => mapping(address => bool)) minersByChallenge;\n', '        mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\n', '        mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\n', '        mapping(uint256 => Dispute) disputesById; //disputeId=> Dispute details\n', '        mapping(address => Checkpoint[]) balances; //balances of a party given blocks\n', '        mapping(address => mapping(address => uint256)) allowed; //allowance for a given party and approver\n', '        mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\n', '        mapping(uint256 => Request) requestDetails; //mapping of apiID to details\n', '        mapping(bytes32 => uint256) requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\n', '        mapping(bytes32 => uint256) disputeIdByDisputeHash; //maps a hash to an ID for each dispute\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '/**\n', '* @title Tellor Master\n', '* @dev This is a transaction contract designed to perform a temporary configuration on a Tellor Update.\n', '*/\n', 'contract TellorTransition {\n', '\n', '    TellorStorage.TellorStorageStruct tellor;\n', '\n', '    address public constant newTellor = 0xF7914ebf0f021Adaf95114B068502d0C7D107bc9;\n', '    address public constant currentTellor = 0x8041ebDae1358d79CC1c2813B61b7f8DA3323d38;\n', '\n', '    /**\n', '    * @dev Function to be executed before the first transaction to new version is called. After performing\n', '    * the necessary steps, it just sets the "tellorContract" to the actual new version. \n', '    */\n', '    function _transition() internal {\n', '        //Perfomr all necessary steps for the transition\n', '        tellor.uintVars[keccak256("currentReward")] = 1e18;\n', '        tellor.uintVars[keccak256("stakeAmount")] = 500e18;\n', '        tellor.uintVars[keccak256("disputeFee")] = 500e18;\n', '\n', '        //After, change the "tellorAddress" to the new version\n', '        tellor.addressVars[keccak256("tellorContract")] = newTellor;\n', '    } \n', '\n', '    /**\n', '    * @dev Function to be verify if the system is in the correct state for executing a transition.\n', "    *  Ex: we're not in the middle of a block;\n", '    */\n', '    function _isReady() internal view returns(bool){\n', '        if(tellor.uintVars[keccak256("slotProgress")] == 0){\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function() external payable{\n', '        \n', '        address addr = currentTellor;\n', '        //If contract is ready, perform the transition and set the definitive address as TellorContract;\n', '        if(_isReady()){\n', '            _transition();\n', '            addr = newTellor;\n', '        } \n', '        bytes memory _calldata = msg.data;\n', '        assembly {\n', '            let result := delegatecall(not(0), addr, add(_calldata, 0x20), mload(_calldata), 0, 0)\n', '            let size := returndatasize\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n', '            // if the call returned error data, forward it\n', '            switch result\n', '                case 0 {\n', '                    revert(ptr, size)\n', '                }\n', '                default {\n', '                    return(ptr, size)\n', '                }\n', '        }\n', '    }\n', '}']