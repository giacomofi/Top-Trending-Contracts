['// File: contracts/external/govblocks-protocol/interfaces/IGovernance.sol\n', '\n', '/* Copyright (C) 2017 GovBlocks.io\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'contract IGovernance { \n', '\n', '    event Proposal(\n', '        address indexed proposalOwner,\n', '        uint256 indexed proposalId,\n', '        uint256 dateAdd,\n', '        string proposalTitle,\n', '        string proposalSD,\n', '        string proposalDescHash\n', '    );\n', '\n', '    event Solution(\n', '        uint256 indexed proposalId,\n', '        address indexed solutionOwner,\n', '        uint256 indexed solutionId,\n', '        string solutionDescHash,\n', '        uint256 dateAdd\n', '    );\n', '\n', '    event Vote(\n', '        address indexed from,\n', '        uint256 indexed proposalId,\n', '        uint256 indexed voteId,\n', '        uint256 dateAdd,\n', '        uint256 solutionChosen\n', '    );\n', '\n', '    event RewardClaimed(\n', '        address indexed member,\n', '        uint gbtReward\n', '    );\n', '\n', '    /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal. \n', '    event VoteCast (uint256 proposalId);\n', '\n', '    /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can \n', '    ///      call any offchain actions\n', '    event ProposalAccepted (uint256 proposalId);\n', '\n', '    /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\n', '    event CloseProposalOnTime (\n', '        uint256 indexed proposalId,\n', '        uint256 time\n', '    );\n', '\n', '    /// @dev ActionSuccess event is called whenever an onchain action is executed.\n', '    event ActionSuccess (\n', '        uint256 proposalId\n', '    );\n', '\n', '    /// @dev Creates a new proposal\n', '    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\n', "    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\n", '    function createProposal(\n', '        string calldata _proposalTitle,\n', '        string calldata _proposalSD,\n', '        string calldata _proposalDescHash,\n', '        uint _categoryId\n', '    ) \n', '        external;\n', '\n', '    /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\n', '    function categorizeProposal(\n', '        uint _proposalId, \n', '        uint _categoryId,\n', '        uint _incentives\n', '    ) \n', '        external;\n', '\n', '    /// @dev Submit proposal with solution\n', '    /// @param _proposalId Proposal id\n', '    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\n', '    function submitProposalWithSolution(\n', '        uint _proposalId, \n', '        string calldata _solutionHash, \n', '        bytes calldata _action\n', '    ) \n', '        external;\n', '\n', '    /// @dev Creates a new proposal with solution and votes for the solution\n', '    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\n', "    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\n", '    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\n', '    function createProposalwithSolution(\n', '        string calldata _proposalTitle, \n', '        string calldata _proposalSD, \n', '        string calldata _proposalDescHash,\n', '        uint _categoryId, \n', '        string calldata _solutionHash, \n', '        bytes calldata _action\n', '    ) \n', '        external;\n', '\n', '    /// @dev Casts vote\n', '    /// @param _proposalId Proposal id\n', '    /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\n', '    function submitVote(uint _proposalId, uint _solutionChosen) external;\n', '\n', '    function closeProposal(uint _proposalId) external;\n', '\n', '    function claimReward(address _memberAddress, uint _maxRecords) external returns(uint pendingDAppReward); \n', '\n', '    function proposal(uint _proposalId)\n', '        external\n', '        view\n', '        returns(\n', '            uint proposalId,\n', '            uint category,\n', '            uint status,\n', '            uint finalVerdict,\n', '            uint totalReward\n', '        );\n', '\n', '    function canCloseProposal(uint _proposalId) public view returns(uint closeValue);\n', '\n', '    function allowedToCatgorize() public view returns(uint roleId);\n', '\n', '    /**\n', '     * @dev Gets length of propsal\n', '     * @return length of propsal\n', '     */\n', '    function getProposalLength() external view returns(uint);\n', '\n', '}\n', '\n', '// File: contracts/external/govblocks-protocol/interfaces/IProposalCategory.sol\n', '\n', '/* Copyright (C) 2017 GovBlocks.io\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'contract IProposalCategory {\n', '\n', '    event Category(\n', '        uint indexed categoryId,\n', '        string categoryName,\n', '        string actionHash\n', '    );\n', '\n', '    mapping(uint256 => bytes) public categoryActionHashes;\n', '\n', '    /**\n', '    * @dev Adds new category\n', '    * @param _name Category name\n', '    * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n', '    * @param _majorityVotePerc Majority Vote threshold for Each voting layer\n', '    * @param _quorumPerc minimum threshold percentage required in voting to calculate result\n', '    * @param _allowedToCreateProposal Member roles allowed to create the proposal\n', '    * @param _closingTime Vote closing time for Each voting layer\n', '    * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n', '    * @param _contractAddress address of contract to call after proposal is accepted\n', '    * @param _contractName name of contract to be called after proposal is accepted\n', '    * @param _incentives rewards to distributed after proposal is accepted\n', '    * @param _functionHash function signature to be executed\n', '    */\n', '    function newCategory(\n', '        string calldata _name, \n', '        uint _memberRoleToVote,\n', '        uint _majorityVotePerc, \n', '        uint _quorumPerc,\n', '        uint[] calldata _allowedToCreateProposal,\n', '        uint _closingTime,\n', '        string calldata _actionHash,\n', '        address _contractAddress,\n', '        bytes2 _contractName,\n', '        uint[] calldata _incentives,\n', '        string calldata _functionHash\n', '    )\n', '        external;\n', '\n', '    /** @dev gets category details\n', '    */\n', '    function category(uint _categoryId)\n', '        external\n', '        view\n', '        returns(\n', '            uint categoryId,\n', '            uint memberRoleToVote,\n', '            uint majorityVotePerc,\n', '            uint quorumPerc,\n', '            uint[] memory allowedToCreateProposal,\n', '            uint closingTime,\n', '            uint minStake\n', '        );\n', '    \n', '    /**@dev gets category action details\n', '    */\n', '    function categoryAction(uint _categoryId)\n', '        external\n', '        view\n', '        returns(\n', '            uint categoryId,\n', '            address contractAddress,\n', '            bytes2 contractName,\n', '            uint defaultIncentive\n', '        );\n', '    \n', '    /** @dev Gets Total number of categories added till now\n', '    */\n', '    function totalCategories() external view returns(uint numberOfCategories);\n', '\n', '    /**\n', '     * @dev Gets the category acion details of a category id\n', '     * @param _categoryId is the category id in concern\n', '     * @return the category id\n', '     * @return the contract address\n', '     * @return the contract name\n', '     * @return the default incentive\n', '     * @return action function hash\n', '     */\n', '    function categoryActionDetails(uint256 _categoryId)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            address,\n', '            bytes2,\n', '            uint256,\n', '            bytes memory\n', '        );\n', '\n', '    /**\n', '    * @dev Updates category details\n', '    * @param _categoryId Category id that needs to be updated\n', '    * @param _name Category name\n', '    * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\n', '    * @param _allowedToCreateProposal Member roles allowed to create the proposal\n', '    * @param _majorityVotePerc Majority Vote threshold for Each voting layer\n', '    * @param _quorumPerc minimum threshold percentage required in voting to calculate result\n', '    * @param _closingTime Vote closing time for Each voting layer\n', '    * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\n', '    * @param _contractAddress address of contract to call after proposal is accepted\n', '    * @param _contractName name of contract to be called after proposal is accepted\n', '    * @param _incentives rewards to distributed after proposal is accepted\n', '    * @param _functionHash function signature to be executed\n', '    */\n', '    function editCategory(\n', '        uint _categoryId, \n', '        string calldata _name, \n', '        uint _memberRoleToVote, \n', '        uint _majorityVotePerc, \n', '        uint _quorumPerc,\n', '        uint[] calldata _allowedToCreateProposal,\n', '        uint _closingTime,\n', '        string calldata _actionHash,\n', '        address _contractAddress,\n', '        bytes2 _contractName,\n', '        uint[] calldata _incentives,\n', '        string calldata _functionHash\n', '    )\n', '        external;\n', '\n', '}\n', '\n', '// File: contracts/external/govblocks-protocol/interfaces/IMemberRoles.sol\n', '\n', '/* Copyright (C) 2017 GovBlocks.io\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'contract IMemberRoles {\n', '\n', '    event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\n', '    \n', '    enum Role {UnAssigned, AdvisoryBoard, TokenHolder, DisputeResolution}\n', '\n', '    function setInititorAddress(address _initiator) external;\n', '\n', '    /// @dev Adds new member role\n', '    /// @param _roleName New role name\n', '    /// @param _roleDescription New description hash\n', '    /// @param _authorized Authorized member against every role id\n', '    function addRole(bytes32 _roleName, string memory _roleDescription, address _authorized) public;\n', '\n', '    /// @dev Assign or Delete a member from specific role.\n', '    /// @param _memberAddress Address of Member\n', '    /// @param _roleId RoleId to update\n', '    /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\n', '    function updateRole(address _memberAddress, uint _roleId, bool _active) public;\n', '\n', '    /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\n', '    /// @param _roleId roleId to update its Authorized Address\n', '    /// @param _authorized New authorized address against role id\n', '    function changeAuthorized(uint _roleId, address _authorized) public;\n', '\n', '    /// @dev Return number of member roles\n', '    function totalRoles() public view returns(uint256);\n', '\n', '    /// @dev Gets the member addresses assigned by a specific role\n', '    /// @param _memberRoleId Member role id\n', '    /// @return roleId Role id\n', '    /// @return allMemberAddress Member addresses of specified role id\n', '    function members(uint _memberRoleId) public view returns(uint, address[] memory allMemberAddress);\n', '\n', "    /// @dev Gets all members' length\n", '    /// @param _memberRoleId Member role id\n', '    /// @return memberRoleData[_memberRoleId].memberAddress.length Member length\n', '    function numberOfMembers(uint _memberRoleId) public view returns(uint);\n', '    \n', '    /// @dev Return member address who holds the right to add/remove any member from specific role.\n', '    function authorized(uint _memberRoleId) public view returns(address);\n', '\n', '    /// @dev Get All role ids array that has been assigned to a member so far.\n', '    function roles(address _memberAddress) public view returns(uint[] memory assignedRoles);\n', '\n', '    /// @dev Returns true if the given role id is assigned to a member.\n', '    /// @param _memberAddress Address of member\n', "    /// @param _roleId Checks member's authenticity with the roleId.\n", '    /// i.e. Returns true if this roleId is assigned to member\n', '    function checkRole(address _memberAddress, uint _roleId) public view returns(bool);   \n', '}\n', '\n', '// File: contracts/external/proxy/Proxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Gives the possibility to delegate any call to a foreign implementation.\n', ' */\n', 'contract Proxy {\n', '    /**\n', '    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n', '    * This function will return whatever the implementation call returns\n', '    */\n', '    function () external payable {\n', '        address _impl = implementation();\n', '        require(_impl != address(0));\n', '\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            calldatacopy(ptr, 0, calldatasize)\n', '            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n', '            let size := returndatasize\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            switch result\n', '            case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '            }\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the implementation where every call will be delegated.\n', '    * @return address of the implementation to which it will be delegated\n', '    */\n', '    function implementation() public view returns (address);\n', '}\n', '\n', '// File: contracts/external/proxy/UpgradeabilityProxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n', ' */\n', 'contract UpgradeabilityProxy is Proxy {\n', '    /**\n', '    * @dev This event will be emitted every time the implementation gets upgraded\n', '    * @param implementation representing the address of the upgraded implementation\n', '    */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    // Storage position of the address of the current implementation\n', '    bytes32 private constant IMPLEMENTATION_POSITION = keccak256("org.govblocks.proxy.implementation");\n', '\n', '    /**\n', '    * @dev Constructor function\n', '    */\n', '    constructor() public {}\n', '\n', '    /**\n', '    * @dev Tells the address of the current implementation\n', '    * @return address of the current implementation\n', '    */\n', '    function implementation() public view returns (address impl) {\n', '        bytes32 position = IMPLEMENTATION_POSITION;\n', '        assembly {\n', '            impl := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Sets the address of the current implementation\n', '    * @param _newImplementation address representing the new implementation to be set\n', '    */\n', '    function _setImplementation(address _newImplementation) internal {\n', '        bytes32 position = IMPLEMENTATION_POSITION;\n', '        assembly {\n', '        sstore(position, _newImplementation)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Upgrades the implementation address\n', '    * @param _newImplementation representing the address of the new implementation to be set\n', '    */\n', '    function _upgradeTo(address _newImplementation) internal {\n', '        address currentImplementation = implementation();\n', '        require(currentImplementation != _newImplementation);\n', '        _setImplementation(_newImplementation);\n', '        emit Upgraded(_newImplementation);\n', '    }\n', '}\n', '\n', '// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title OwnedUpgradeabilityProxy\n', ' * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n', ' */\n', 'contract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n', '    /**\n', '    * @dev Event to show ownership has been transferred\n', '    * @param previousOwner representing the address of the previous owner\n', '    * @param newOwner representing the address of the new owner\n', '    */\n', '    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n', '\n', '    // Storage position of the owner of the contract\n', '    bytes32 private constant PROXY_OWNER_POSITION = keccak256("org.govblocks.proxy.owner");\n', '\n', '    /**\n', '    * @dev the constructor sets the original owner of the contract to the sender account.\n', '    */\n', '    constructor(address _implementation) public {\n', '        _setUpgradeabilityOwner(msg.sender);\n', '        _upgradeTo(_implementation);\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyProxyOwner() {\n', '        require(msg.sender == proxyOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the owner\n', '    * @return the address of the owner\n', '    */\n', '    function proxyOwner() public view returns (address owner) {\n', '        bytes32 position = PROXY_OWNER_POSITION;\n', '        assembly {\n', '            owner := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\n', '        require(_newOwner != address(0));\n', '        _setUpgradeabilityOwner(_newOwner);\n', '        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the proxy owner to upgrade the current version of the proxy.\n', '    * @param _implementation representing the address of the new implementation to be set.\n', '    */\n', '    function upgradeTo(address _implementation) public onlyProxyOwner {\n', '        _upgradeTo(_implementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the owner\n', '    */\n', '    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\n', '        bytes32 position = PROXY_OWNER_POSITION;\n', '        assembly {\n', '            sstore(position, _newProxyOwner)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/external/openzeppelin-solidity/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library SafeMath64 {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        uint64 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint64 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\n', '        require(b <= a, errorMessage);\n', '        uint64 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint64 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint64 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/Iupgradable.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract Iupgradable {\n', '\n', '    /**\n', '     * @dev change master address\n', '     */\n', '    function setMasterAddress() public;\n', '}\n', '\n', '// File: contracts/interfaces/IMarketRegistry.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract IMarketRegistry {\n', '\n', '    enum MarketType {\n', '      HourlyMarket,\n', '      DailyMarket,\n', '      WeeklyMarket\n', '    }\n', '    address public owner;\n', '    address public tokenController;\n', '    address public marketUtility;\n', '    bool public marketCreationPaused;\n', '\n', '    mapping(address => bool) public isMarket;\n', '    function() external payable{}\n', '\n', '    function marketDisputeStatus(address _marketAddress) public view returns(uint _status);\n', '\n', '    function burnDisputedProposalTokens(uint _proposaId) external;\n', '\n', '    function isWhitelistedSponsor(address _address) public view returns(bool);\n', '\n', '    function transferAssets(address _asset, address _to, uint _amount) external;\n', '\n', '    /**\n', '    * @dev Initialize the PlotX.\n', '    * @param _marketConfig The address of market config.\n', '    * @param _plotToken The address of PLOT token.\n', '    */\n', '    function initiate(address _defaultAddress, address _marketConfig, address _plotToken, address payable[] memory _configParams) public;\n', '\n', '    /**\n', '    * @dev Create proposal if user wants to raise the dispute.\n', '    * @param proposalTitle The title of proposal created by user.\n', '    * @param description The description of dispute.\n', '    * @param solutionHash The ipfs solution hash.\n', '    * @param actionHash The action hash for solution.\n', '    * @param stakeForDispute The token staked to raise the diospute.\n', '    * @param user The address who raises the dispute.\n', '    */\n', '    function createGovernanceProposal(string memory proposalTitle, string memory description, string memory solutionHash, bytes memory actionHash, uint256 stakeForDispute, address user, uint256 ethSentToPool, uint256 tokenSentToPool, uint256 proposedValue) public {\n', '    }\n', '\n', '    /**\n', '    * @dev Emits the PlacePrediction event and sets user data.\n', '    * @param _user The address who placed prediction.\n', '    * @param _value The amount of ether user staked.\n', '    * @param _predictionPoints The positions user will get.\n', '    * @param _predictionAsset The prediction assets user will get.\n', '    * @param _prediction The option range on which user placed prediction.\n', '    * @param _leverage The leverage selected by user at the time of place prediction.\n', '    */\n', '    function setUserGlobalPredictionData(address _user,uint _value, uint _predictionPoints, address _predictionAsset, uint _prediction,uint _leverage) public{\n', '    }\n', '\n', '    /**\n', '    * @dev Emits the claimed event.\n', '    * @param _user The address who claim their reward.\n', '    * @param _reward The reward which is claimed by user.\n', '    * @param incentives The incentives of user.\n', '    * @param incentiveToken The incentive tokens of user.\n', '    */\n', '    function callClaimedEvent(address _user , uint[] memory _reward, address[] memory predictionAssets, uint incentives, address incentiveToken) public {\n', '    }\n', '\n', '        /**\n', '    * @dev Emits the MarketResult event.\n', '    * @param _totalReward The amount of reward to be distribute.\n', '    * @param _winningOption The winning option of the market.\n', '    * @param _closeValue The closing value of the market currency.\n', '    */\n', '    function callMarketResultEvent(uint[] memory _totalReward, uint _winningOption, uint _closeValue, uint roundId) public {\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/ITokenController.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract ITokenController {\n', '\taddress public token;\n', '    address public bLOTToken;\n', '\n', '    /**\n', '    * @dev Swap BLOT token.\n', '    * account.\n', '    * @param amount The amount that will be swapped.\n', '    */\n', '    function swapBLOT(address _of, address _to, uint256 amount) public;\n', '\n', '    function totalBalanceOf(address _of)\n', '        public\n', '        view\n', '        returns (uint256 amount);\n', '\n', '    function transferFrom(address _token, address _of, address _to, uint256 amount) public;\n', '\n', '    /**\n', '     * @dev Returns tokens locked for a specified address for a\n', '     *      specified reason at a specific time\n', '     * @param _of The address whose tokens are locked\n', '     * @param _reason The reason to query the lock tokens for\n', '     * @param _time The timestamp to query the lock tokens for\n', '     */\n', '    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\n', '        public\n', '        view\n', '        returns (uint256 amount);\n', '\n', '    /**\n', '    * @dev burns an amount of the tokens of the message sender\n', '    * account.\n', '    * @param amount The amount that will be burnt.\n', '    */\n', '    function burnCommissionTokens(uint256 amount) external returns(bool);\n', ' \n', '    function initiateVesting(address _vesting) external;\n', '\n', '    function lockForGovernanceVote(address _of, uint _days) public;\n', '\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    function mint(address _member, uint _amount) public;\n', '\n', '}\n', '\n', '// File: contracts/interfaces/IToken.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract IToken {\n', '\n', '    function decimals() external view returns(uint8);\n', '\n', '    /**\n', '    * @dev Total number of tokens in existence\n', '    */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param account The address to query the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', '    * @dev Transfer token for a specified address\n', '    * @param recipient The address to transfer to.\n', '    * @param amount The amount to be transferred.\n', '    */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '    * @dev function that mints an amount of the token and assigns it to\n', '    * an account.\n', '    * @param account The account that will receive the created tokens.\n', '    * @param amount The amount that will be created.\n', '    */\n', '    function mint(address account, uint256 amount) external returns (bool);\n', '    \n', '     /**\n', '    * @dev burns an amount of the tokens of the message sender\n', '    * account.\n', '    * @param amount The amount that will be burnt.\n', '    */\n', '    function burn(uint256 amount) external;\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     * Returns a boolean value indicating whether the operation succeeded.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '    * @dev Transfer tokens from one address to another\n', '    * @param sender address The address which you want to send tokens from\n', '    * @param recipient address The address which you want to transfer to\n', '    * @param amount uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '}\n', '\n', '// File: contracts/interfaces/IMaster.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract IMaster {\n', '    function dAppToken() public view returns(address);\n', '    function isInternal(address _address) public view returns(bool);\n', '    function getLatestAddress(bytes2 _module) public view returns(address);\n', '    function isAuthorizedToGovern(address _toCheck) public view returns(bool);\n', '}\n', '\n', '// File: contracts/interfaces/IMarket.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract IMarket {\n', '\n', '    enum PredictionStatus {\n', '      Live,\n', '      InSettlement,\n', '      Cooling,\n', '      InDispute,\n', '      Settled\n', '    }\n', '\n', '    struct MarketData {\n', '      uint64 startTime;\n', '      uint64 predictionTime;\n', '      uint64 neutralMinValue;\n', '      uint64 neutralMaxValue;\n', '    }\n', '\n', '    struct MarketSettleData {\n', '      uint64 WinningOption;\n', '      uint64 settleTime;\n', '    }\n', '\n', '    MarketSettleData public marketSettleData;\n', '\n', '    MarketData public marketData;\n', '\n', '    function WinningOption() public view returns(uint256);\n', '\n', '    function marketCurrency() public view returns(bytes32);\n', '\n', '    function getMarketFeedData() public view returns(uint8, bytes32, address);\n', '\n', '    function settleMarket() external;\n', '    \n', '    function getTotalStakedValueInPLOT() external view returns(uint256);\n', '\n', '    /**\n', '    * @dev Initialize the market.\n', '    * @param _startTime The time at which market will create.\n', '    * @param _predictionTime The time duration of market.\n', '    * @param _minValue The minimum value of middle option range.\n', '    * @param _maxValue The maximum value of middle option range.\n', '    */\n', '    function initiate(uint64 _startTime, uint64 _predictionTime, uint64 _minValue, uint64 _maxValue) public payable;\n', '\n', '    /**\n', '    * @dev Resolve the dispute if wrong value passed at the time of market result declaration.\n', '    * @param accepted The flag defining that the dispute raised is accepted or not \n', '    * @param finalResult The final correct value of market currency.\n', '    */\n', '    function resolveDispute(bool accepted, uint256 finalResult) external payable;\n', '\n', '    /**\n', '    * @dev Gets the market data.\n', '    * @return _marketCurrency bytes32 representing the currency or stock name of the market.\n', '    * @return minvalue uint[] memory representing the minimum range of all the options of the market.\n', '    * @return maxvalue uint[] memory representing the maximum range of all the options of the market.\n', '    * @return _optionPrice uint[] memory representing the option price of each option ranges of the market.\n', '    * @return _ethStaked uint[] memory representing the ether staked on each option ranges of the market.\n', '    * @return _plotStaked uint[] memory representing the plot staked on each option ranges of the market.\n', '    * @return _predictionType uint representing the type of market.\n', '    * @return _expireTime uint representing the expire time of the market.\n', '    * @return _predictionStatus uint representing the status of the market.\n', '    */\n', '    function getData() external view \n', '    \treturns (\n', '    \t\tbytes32 _marketCurrency,uint[] memory minvalue,uint[] memory maxvalue,\n', '        \tuint[] memory _optionPrice, uint[] memory _ethStaked, uint[] memory _plotStaked,uint _predictionType,\n', '        \tuint _expireTime, uint _predictionStatus\n', '        );\n', '\n', '    // /**\n', '    // * @dev Gets the pending return.\n', '    // * @param _user The address to specify the return of.\n', '    // * @return uint representing the pending return amount.\n', '    // */\n', '    // function getPendingReturn(address _user) external view returns(uint[] memory returnAmount, address[] memory _predictionAssets, uint[] memory incentive, address[] memory _incentiveTokens);\n', '\n', '    /**\n', '    * @dev Claim the return amount of the specified address.\n', '    * @param _user The address to query the claim return amount of.\n', '    * @return Flag, if 0:cannot claim, 1: Already Claimed, 2: Claimed\n', '    */\n', '    function claimReturn(address payable _user) public returns(uint256);\n', '\n', '}\n', '\n', '// File: contracts/Governance.sol\n', '\n', '/* Copyright (C) 2020 PlotX.io\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Governance is IGovernance, Iupgradable {\n', '    using SafeMath for uint256;\n', '\n', '    enum ProposalStatus {\n', '        Draft,\n', '        AwaitingSolution,\n', '        VotingStarted,\n', '        Accepted,\n', '        Rejected,\n', '        Denied\n', '    }\n', '\n', '    struct ProposalData {\n', '        uint256 propStatus;\n', '        uint256 finalVerdict;\n', '        uint256 category;\n', '        uint256 commonIncentive;\n', '        uint256 dateUpd;\n', '        uint256 totalVoteValue;\n', '        address owner;\n', '    }\n', '\n', '    struct ProposalVote {\n', '        address voter;\n', '        uint256 proposalId;\n', '        uint256 solutionChosen;\n', '        uint256 voteValue;\n', '        uint256 dateAdd;\n', '    }\n', '    struct VoteTally {\n', '        mapping(uint256 => uint256) voteValue;\n', '        mapping(uint=>uint) abVoteValue;\n', '        uint256 voters;\n', '    }\n', '\n', '    ProposalVote[] internal allVotes;\n', '\n', '    mapping(uint256 => ProposalData) internal allProposalData;\n', '    mapping(uint256 => bytes[]) internal allProposalSolutions;\n', '    mapping(address => uint256[]) internal allVotesByMember;\n', '    mapping(uint256 => mapping(address => bool)) public rewardClaimed;\n', '    mapping(address => mapping(uint256 => uint256)) public memberProposalVote;\n', '    mapping(uint256 => VoteTally) public proposalVoteTally;\n', '    mapping(address => uint256) public lastRewardClaimed;\n', '\n', '    bytes32 constant swapABMemberHash = keccak256(abi.encodeWithSignature("swapABMember(address,address)"));\n', '    bytes32 constant resolveDisputeHash = keccak256(abi.encodeWithSignature("resolveDispute(address,uint256)"));\n', '    uint256 constant totalSupplyCapForDRQrm = 50;\n', '\n', '    bool internal constructorCheck;\n', '    uint256 public tokenHoldingTime;\n', '    uint256 internal roleIdAllowedToCatgorize;\n', '    uint256 internal maxVoteWeigthPer;\n', '    uint256 internal advisoryBoardMajority;\n', '    uint256 internal totalProposals;\n', '    uint256 internal maxDraftTime;\n', '    uint256 internal votePercRejectAction;\n', '    uint256 internal actionRejectAuthRole;\n', '    uint256 internal drQuorumMulitplier;\n', '\n', '    IMaster public ms;\n', '    IMemberRoles internal memberRole;\n', '    IMarketRegistry internal marketRegistry;\n', '    IProposalCategory internal proposalCategory;\n', '    //Plot Token Instance\n', '    IToken internal tokenInstance;\n', '    ITokenController internal tokenController;\n', '\n', '    mapping(uint256 => uint256) public proposalActionStatus;\n', '    mapping(uint256 => uint256) internal proposalExecutionTime;\n', '    mapping(uint256 => mapping(address => bool)) public isActionRejected;\n', '    mapping(uint256 => uint256) internal actionRejectedCount;\n', '\n', '    uint256 internal actionWaitingTime;\n', '\n', '    enum ActionStatus {Pending, Accepted, Rejected, Executed, NoAction}\n', '\n', '    /**\n', '     * @dev Called whenever an action execution is failed.\n', '     */\n', '    event ActionFailed(uint256 proposalId);\n', '\n', '    /**\n', '     * @dev Called whenever an AB member rejects the action execution.\n', '     */\n', '    event ActionRejected(uint256 indexed proposalId, address rejectedBy);\n', '\n', '    /**\n', '     * @dev Checks if msg.sender is proposal owner\n', '     */\n', '    modifier onlyProposalOwner(uint256 _proposalId) {\n', '        require(\n', '            msg.sender == allProposalData[_proposalId].owner,\n', '            "Not allowed"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if proposal is opened for voting\n', '     */\n', '    modifier voteNotStarted(uint256 _proposalId) {\n', '        require(\n', '            allProposalData[_proposalId].propStatus <\n', '                uint256(ProposalStatus.VotingStarted)\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if msg.sender is allowed to create proposal under given category\n', '     */\n', '    modifier isAllowed(uint256 _categoryId) {\n', '        require(allowedToCreateProposal(_categoryId), "Not allowed");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if msg.sender is allowed categorize proposal\n', '     */\n', '    modifier isAllowedToCategorize() {\n', '        require(allowedToCategorize());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Event emitted whenever a proposal is categorized\n', '     */\n', '    event ProposalCategorized(\n', '        uint256 indexed proposalId,\n', '        address indexed categorizedBy,\n', '        uint256 categoryId\n', '    );\n', '\n', '    /**\n', '     * @dev Creates a new proposal\n', '     * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\n', "     * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\n", '     */\n', '    function createProposal(\n', '        string calldata _proposalTitle,\n', '        string calldata _proposalSD,\n', '        string calldata _proposalDescHash,\n', '        uint256 _categoryId\n', '    ) external isAllowed(_categoryId) {\n', '        require(\n', '            memberRole.checkRole(\n', '                msg.sender,\n', '                uint256(IMemberRoles.Role.TokenHolder)\n', '            ),\n', '            "Not Member"\n', '        );\n', '\n', '        _createProposal(\n', '            _proposalTitle,\n', '            _proposalSD,\n', '            _proposalDescHash,\n', '            _categoryId\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\n', '     */\n', '    function categorizeProposal(\n', '        uint256 _proposalId,\n', '        uint256 _categoryId,\n', '        uint256 _incentive\n', '    ) external voteNotStarted(_proposalId) isAllowedToCategorize {\n', '        uint256 incentive = _incentive;\n', '        bytes memory _functionHash = proposalCategory\n', '            .categoryActionHashes(_categoryId);\n', '        if(keccak256(_functionHash) == swapABMemberHash) {\n', '            incentive = 0;\n', '        }\n', '        _categorizeProposal(_proposalId, _categoryId, incentive, _functionHash);\n', '    }\n', '\n', '    /**\n', '     * @dev Submit proposal with solution\n', '     * @param _proposalId Proposal id\n', '     * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\n', '     */\n', '    function submitProposalWithSolution(\n', '        uint256 _proposalId,\n', '        string calldata _solutionHash,\n', '        bytes calldata _action\n', '    ) external onlyProposalOwner(_proposalId) {\n', '        require(\n', '            allProposalData[_proposalId].propStatus ==\n', '                uint256(ProposalStatus.AwaitingSolution)\n', '        );\n', '\n', '        _proposalSubmission(_proposalId, _solutionHash, _action);\n', '    }\n', '\n', '    /**\n', '     * @dev Creates a new proposal with solution\n', '     * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\n', "     * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\n", '     * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\n', '     */\n', '    function createProposalwithSolution(\n', '        string calldata _proposalTitle,\n', '        string calldata _proposalSD,\n', '        string calldata _proposalDescHash,\n', '        uint256 _categoryId,\n', '        string calldata _solutionHash,\n', '        bytes calldata _action\n', '    ) external isAllowed(_categoryId) {\n', '        uint256 proposalId = totalProposals;\n', '\n', '        _createProposal(\n', '            _proposalTitle,\n', '            _proposalSD,\n', '            _proposalDescHash,\n', '            _categoryId\n', '        );\n', '\n', '        require(_categoryId > 0);\n', '\n', '        _proposalSubmission(proposalId, _solutionHash, _action);\n', '    }\n', '\n', '    /**\n', '     * @dev Submit a vote on the proposal.\n', '     * @param _proposalId to vote upon.\n', '     * @param _solutionChosen is the chosen vote.\n', '     */\n', '    function submitVote(uint256 _proposalId, uint256 _solutionChosen) external {\n', '        require(\n', '            allProposalData[_proposalId].propStatus ==\n', '                uint256(Governance.ProposalStatus.VotingStarted),\n', '            "Not allowed"\n', '        );\n', '\n', '        require(_solutionChosen < allProposalSolutions[_proposalId].length);\n', '\n', '        _submitVote(_proposalId, _solutionChosen);\n', '    }\n', '\n', '    /**\n', '     * @dev Closes the proposal.\n', '     * @param _proposalId of proposal to be closed.\n', '     */\n', '    function closeProposal(uint256 _proposalId) external {\n', '        uint256 category = allProposalData[_proposalId].category;\n', '\n', '        if (\n', '            allProposalData[_proposalId].dateUpd.add(maxDraftTime) <= now &&\n', '            allProposalData[_proposalId].propStatus <\n', '            uint256(ProposalStatus.VotingStarted)\n', '        ) {\n', '            _updateProposalStatus(_proposalId, uint256(ProposalStatus.Denied));\n', '            _transferPLOT(\n', '                address(marketRegistry),\n', '                allProposalData[_proposalId].commonIncentive\n', '            );\n', '        } else {\n', '            require(canCloseProposal(_proposalId) == 1);\n', '            _closeVote(_proposalId, category);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Claims reward for member.\n', '     * @param _memberAddress to claim reward of.\n', '     * @param _maxRecords maximum number of records to claim reward for.\n', '     _proposals list of proposals of which reward will be claimed.\n', '     * @return amount of pending reward.\n', '     */\n', '    function claimReward(address _memberAddress, uint256 _maxRecords)\n', '        external\n', '        returns (uint256 pendingDAppReward)\n', '    {\n', '        uint256 voteId;\n', '        uint256 proposalId;\n', '        uint256 totalVotes = allVotesByMember[_memberAddress].length;\n', '        uint256 lastClaimed = totalVotes;\n', '        uint256 j;\n', '        uint256 i;\n', '        for (\n', '            i = lastRewardClaimed[_memberAddress];\n', '            i < totalVotes && j < _maxRecords;\n', '            i++\n', '        ) {\n', '            voteId = allVotesByMember[_memberAddress][i];\n', '            proposalId = allVotes[voteId].proposalId;\n', '            if (\n', '                proposalVoteTally[proposalId].voters > 0 && allProposalData[proposalId].propStatus >\n', '                    uint256(ProposalStatus.VotingStarted)\n', '            ) {                    \n', '                if (!rewardClaimed[voteId][_memberAddress]) {\n', '                    pendingDAppReward = pendingDAppReward.add(\n', '                        allProposalData[proposalId].commonIncentive.div(\n', '                            proposalVoteTally[proposalId].voters\n', '                        )\n', '                    );\n', '                    rewardClaimed[voteId][_memberAddress] = true;\n', '                    j++;\n', '                }\n', '            } else {\n', '                if (lastClaimed == totalVotes) {\n', '                    lastClaimed = i;\n', '                }\n', '            }\n', '        }\n', '\n', '        if (lastClaimed == totalVotes) {\n', '            lastRewardClaimed[_memberAddress] = i;\n', '        } else {\n', '            lastRewardClaimed[_memberAddress] = lastClaimed;\n', '        }\n', '\n', '        if (j > 0) {\n', '            _transferPLOT(\n', '                _memberAddress,\n', '                pendingDAppReward\n', '            );\n', '            emit RewardClaimed(_memberAddress, pendingDAppReward);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Triggers action of accepted proposal after waiting time is finished\n', '     */\n', '    function triggerAction(uint256 _proposalId) external {\n', '        require(\n', '            proposalActionStatus[_proposalId] ==\n', '                uint256(ActionStatus.Accepted) &&\n', '                proposalExecutionTime[_proposalId] <= now,\n', '            "Cannot trigger"\n', '        );\n', '        _triggerAction(_proposalId, allProposalData[_proposalId].category);\n', '    }\n', '\n', '    /**\n', '     * @dev Provides option to Advisory board member to reject proposal action execution within actionWaitingTime, if found suspicious\n', '     */\n', '    function rejectAction(uint256 _proposalId) external {\n', '        require(\n', '            memberRole.checkRole(msg.sender, actionRejectAuthRole) &&\n', '                proposalExecutionTime[_proposalId] > now\n', '        );\n', '\n', '        require(\n', '            proposalActionStatus[_proposalId] == uint256(ActionStatus.Accepted)\n', '        );\n', '\n', '        require(!isActionRejected[_proposalId][msg.sender]);\n', '\n', '        isActionRejected[_proposalId][msg.sender] = true;\n', '        actionRejectedCount[_proposalId]++;\n', '        emit ActionRejected(_proposalId, msg.sender);\n', '        if (\n', '            actionRejectedCount[_proposalId].mul(100).div(\n', '                memberRole.numberOfMembers(actionRejectAuthRole)\n', '            ) >= votePercRejectAction\n', '        ) {\n', '            proposalActionStatus[_proposalId] = uint256(ActionStatus.Rejected);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Gets Uint Parameters of a code\n', '     * @param code whose details we want\n', '     * @return string value of the code\n', '     * @return associated amount (time or perc or value) to the code\n', '     */\n', '    function getUintParameters(bytes8 code)\n', '        external\n', '        view\n', '        returns (bytes8 codeVal, uint256 val)\n', '    {\n', '        codeVal = code;\n', '\n', '        if (code == "GOVHOLD") { // Governance token holding time\n', '            val = tokenHoldingTime / (1 days);\n', '        } else if (code == "MAXDRFT") { // Maximum draft time for proposals\n', '            val = maxDraftTime / (1 days);\n', '        } else if (code == "ACWT") { //Action wait time\n', '            val = actionWaitingTime / (1 hours);\n', '        } else if (code == "REJAUTH") { // Authorized role to stop executing actions\n', '            val = actionRejectAuthRole;\n', '        } else if (code == "REJCOUNT") { // Majorty percentage for action rejection\n', '            val = votePercRejectAction;\n', '        } else if (code == "MAXVW") { // Max vote weight percentage\n', '            val = maxVoteWeigthPer;\n', '        } else if (code == "ABMAJ") { // Advisory board majority percentage\n', '            val = advisoryBoardMajority;\n', '        } else if (code == "DRQUMR") { // Dispute Resolution Quorum multiplier\n', '            val = drQuorumMulitplier;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Gets all details of a propsal\n', '     * @param _proposalId whose details we want\n', '     * @return proposalId\n', '     * @return category\n', '     * @return status\n', '     * @return finalVerdict\n', '     * @return totalReward\n', '     */\n', '    function proposal(uint256 _proposalId)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 proposalId,\n', '            uint256 category,\n', '            uint256 status,\n', '            uint256 finalVerdict,\n', '            uint256 totalRewar\n', '        )\n', '    {\n', '        return (\n', '            _proposalId,\n', '            allProposalData[_proposalId].category,\n', '            allProposalData[_proposalId].propStatus,\n', '            allProposalData[_proposalId].finalVerdict,\n', '            allProposalData[_proposalId].commonIncentive\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Gets some details of a propsal\n', '     * @param _proposalId whose details we want\n', '     * @return proposalId\n', '     * @return number of all proposal solutions\n', '     * @return amount of votes\n', '     */\n', '    function proposalDetails(uint256 _proposalId)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        return (\n', '            _proposalId,\n', '            allProposalSolutions[_proposalId].length,\n', '            proposalVoteTally[_proposalId].voters\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Gets solution action on a proposal\n', '     * @param _proposalId whose details we want\n', '     * @param _solution whose details we want\n', '     * @return action of a solution on a proposal\n', '     */\n', '    function getSolutionAction(uint256 _proposalId, uint256 _solution)\n', '        external\n', '        view\n', '        returns (uint256, bytes memory)\n', '    {\n', '        return (_solution, allProposalSolutions[_proposalId][_solution]);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets length of propsal\n', '     * @return length of propsal\n', '     */\n', '    function getProposalLength() external view returns (uint256) {\n', '        return totalProposals;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets pending rewards of a member\n', '     * @param _memberAddress in concern\n', '     * @return amount of pending reward\n', '     */\n', '    function getPendingReward(address _memberAddress)\n', '        public\n', '        view\n', '        returns (uint256 pendingDAppReward)\n', '    {\n', '        uint256 proposalId;\n', '        for (\n', '            uint256 i = lastRewardClaimed[_memberAddress];\n', '            i < allVotesByMember[_memberAddress].length;\n', '            i++\n', '        ) {\n', '            if (\n', '                !rewardClaimed[allVotesByMember[_memberAddress][i]][_memberAddress]\n', '            ) {\n', '                proposalId = allVotes[allVotesByMember[_memberAddress][i]]\n', '                    .proposalId;\n', '                if (\n', '                    proposalVoteTally[proposalId].voters > 0 &&\n', '                    allProposalData[proposalId].propStatus >\n', '                    uint256(ProposalStatus.VotingStarted)\n', '                ) {\n', '                    pendingDAppReward = pendingDAppReward.add(\n', '                        allProposalData[proposalId].commonIncentive.div(\n', '                            proposalVoteTally[proposalId].voters\n', '                        )\n', '                    );\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Updates Uint Parameters of a code\n', '     * @param code whose details we want to update\n', '     * @param val value to set\n', '     */\n', '    function updateUintParameters(bytes8 code, uint256 val) public {\n', '        require(ms.isAuthorizedToGovern(msg.sender));\n', '        if (code == "GOVHOLD") {\n', '            tokenHoldingTime = val * 1 days;\n', '        } else if (code == "MAXDRFT") {\n', '            maxDraftTime = val * 1 days;\n', '        } else if (code == "ACWT") {\n', '            actionWaitingTime = val * 1 hours;\n', '        } else if (code == "REJAUTH") {\n', '            actionRejectAuthRole = val;\n', '        } else if (code == "REJCOUNT") {\n', '            votePercRejectAction = val;\n', '        } else if (code == "MAXVW") {\n', '            maxVoteWeigthPer = val;\n', '        } else if (code == "ABMAJ") {\n', '            advisoryBoardMajority = val;\n', '        } else if (code == "DRQUMR") {\n', '            drQuorumMulitplier = val;\n', '        } else {\n', '            revert("Invalid code");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Updates all dependency addresses to latest ones from Master\n', '     */\n', '    function setMasterAddress() public {\n', '        OwnedUpgradeabilityProxy proxy =  OwnedUpgradeabilityProxy(address(uint160(address(this))));\n', '        require(msg.sender == proxy.proxyOwner(),"Sender is not proxy owner.");\n', '\n', '        require(!constructorCheck);\n', '        _initiateGovernance();\n', '        ms = IMaster(msg.sender);\n', '        tokenInstance = IToken(ms.dAppToken());\n', '        memberRole = IMemberRoles(ms.getLatestAddress("MR"));\n', '        proposalCategory = IProposalCategory(ms.getLatestAddress("PC"));\n', '        tokenController = ITokenController(ms.getLatestAddress("TC"));\n', '        marketRegistry = IMarketRegistry(address(uint160(ms.getLatestAddress("PL"))));\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if msg.sender is allowed to create a proposal under given category\n', '     */\n', '    function allowedToCreateProposal(uint256 category)\n', '        public\n', '        view\n', '        returns (bool check)\n', '    {\n', '        if (category == 0) return true;\n', '        uint256[] memory mrAllowed;\n', '        (, , , , mrAllowed, , ) = proposalCategory.category(category);\n', '        for (uint256 i = 0; i < mrAllowed.length; i++) {\n', '            if (\n', '                mrAllowed[i] == 0 ||\n', '                memberRole.checkRole(msg.sender, mrAllowed[i])\n', '            ) return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if msg.sender is allowed to categorize proposals\n', '     */\n', '    function allowedToCategorize()\n', '        public\n', '        view\n', '        returns (bool check)\n', '    {\n', '        return memberRole.checkRole(msg.sender, roleIdAllowedToCatgorize);\n', '    }\n', '\n', '    /**\n', "     * @dev Checks If the proposal voting time is up and it's ready to close\n", '     *      i.e. Closevalue is 1 if proposal is ready to be closed, 2 if already closed, 0 otherwise!\n', '     * @param _proposalId Proposal id to which closing value is being checked\n', '     */\n', '    function canCloseProposal(uint256 _proposalId)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 dateUpdate;\n', '        uint256 pStatus;\n', '        uint256 _closingTime;\n', '        uint256 _roleId;\n', '        uint256 majority;\n', '        pStatus = allProposalData[_proposalId].propStatus;\n', '        dateUpdate = allProposalData[_proposalId].dateUpd;\n', '        (, _roleId, majority, , , _closingTime, ) = proposalCategory.category(\n', '            allProposalData[_proposalId].category\n', '        );\n', '        if (pStatus == uint256(ProposalStatus.VotingStarted)) {\n', '            uint256 numberOfMembers = memberRole.numberOfMembers(_roleId);\n', '            if (\n', '                _roleId == uint256(IMemberRoles.Role.AdvisoryBoard)\n', '            ) {\n', '                if (\n', '                    proposalVoteTally[_proposalId].voteValue[1].mul(100).div(\n', '                        numberOfMembers\n', '                    ) >=\n', '                    majority ||\n', '                    proposalVoteTally[_proposalId].voteValue[1].add(\n', '                        proposalVoteTally[_proposalId].voteValue[0]\n', '                    ) ==\n', '                    numberOfMembers ||\n', '                    dateUpdate.add(_closingTime) <= now\n', '                ) {\n', '                    return 1;\n', '                }\n', '            } else {\n', '                if(_roleId == uint256(IMemberRoles.Role.TokenHolder) ||\n', '                _roleId == uint256(IMemberRoles.Role.DisputeResolution)) {\n', '                    if(dateUpdate.add(_closingTime) <= now)\n', '                        return 1;\n', '                } else if (\n', '                    numberOfMembers <= proposalVoteTally[_proposalId].voters ||\n', '                    dateUpdate.add(_closingTime) <= now\n', '                ) return 1;\n', '            }\n', '        } else if (pStatus > uint256(ProposalStatus.VotingStarted)) {\n', '            return 2;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Gets Id of member role allowed to categorize the proposal\n', '     * @return roleId allowed to categorize the proposal\n', '     */\n', '    function allowedToCatgorize() public view returns (uint256 roleId) {\n', '        return roleIdAllowedToCatgorize;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets vote tally data\n', '     * @param _proposalId in concern\n', '     * @param _solution of a proposal id\n', '     * @return member vote value\n', '     * @return advisory board vote value\n', '     * @return amount of votes\n', '     */\n', '    function voteTallyData(uint256 _proposalId, uint256 _solution)\n', '        public\n', '        view\n', '        returns (uint256, uint256, uint256)\n', '    {\n', '        return (\n', '            proposalVoteTally[_proposalId].voteValue[_solution],\n', '            proposalVoteTally[_proposalId].abVoteValue[_solution],\n', '            proposalVoteTally[_proposalId].voters\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Internal call to create proposal\n', '     * @param _proposalTitle of proposal\n', '     * @param _proposalSD is short description of proposal\n', '     * @param _proposalDescHash IPFS hash value of propsal\n', '     * @param _categoryId of proposal\n', '     */\n', '    function _createProposal(\n', '        string memory _proposalTitle,\n', '        string memory _proposalSD,\n', '        string memory _proposalDescHash,\n', '        uint256 _categoryId\n', '    ) internal {\n', '        uint256 _proposalId = totalProposals;\n', '        allProposalData[_proposalId].owner = msg.sender;\n', '        allProposalData[_proposalId].dateUpd = now;\n', '        allProposalSolutions[_proposalId].push("");\n', '        totalProposals++;\n', '\n', '        emit Proposal(\n', '            msg.sender,\n', '            _proposalId,\n', '            now,\n', '            _proposalTitle,\n', '            _proposalSD,\n', '            _proposalDescHash\n', '        );\n', '\n', '        if (_categoryId > 0) {\n', '            (, , , uint defaultIncentive, bytes memory _functionHash) = proposalCategory\n', '            .categoryActionDetails(_categoryId);\n', '            require(allowedToCategorize() ||\n', '                keccak256(_functionHash) ==\n', '                 resolveDisputeHash ||\n', '                keccak256(_functionHash) == swapABMemberHash\n', '            );\n', '            if(keccak256(_functionHash) == swapABMemberHash) {\n', '                defaultIncentive = 0;\n', '            }\n', '            _categorizeProposal(_proposalId, _categoryId, defaultIncentive, _functionHash);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Internal call to categorize a proposal\n', '     * @param _proposalId of proposal\n', '     * @param _categoryId of proposal\n', '     * @param _incentive is commonIncentive\n', '     */\n', '    function _categorizeProposal(\n', '        uint256 _proposalId,\n', '        uint256 _categoryId,\n', '        uint256 _incentive,\n', '        bytes memory _functionHash\n', '    ) internal {\n', '        require(\n', '            _categoryId > 0 && _categoryId < proposalCategory.totalCategories(),\n', '            "Invalid category"\n', '        );\n', '        if(keccak256(_functionHash) == resolveDisputeHash) {\n', '            require(msg.sender == address(marketRegistry));\n', '        }\n', '        allProposalData[_proposalId].category = _categoryId;\n', '        allProposalData[_proposalId].commonIncentive = _incentive;\n', '        allProposalData[_proposalId].propStatus = uint256(\n', '            ProposalStatus.AwaitingSolution\n', '        );\n', '\n', '        if (_incentive > 0) {\n', '            marketRegistry.transferAssets(\n', '                address(tokenInstance),\n', '                address(this),\n', '                _incentive\n', '            );\n', '        }\n', '\n', '        emit ProposalCategorized(_proposalId, msg.sender, _categoryId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal call to add solution to a proposal\n', '     * @param _proposalId in concern\n', '     * @param _action on that solution\n', '     * @param _solutionHash string value\n', '     */\n', '    function _addSolution(\n', '        uint256 _proposalId,\n', '        bytes memory _action,\n', '        string memory _solutionHash\n', '    ) internal {\n', '        allProposalSolutions[_proposalId].push(_action);\n', '        emit Solution(\n', '            _proposalId,\n', '            msg.sender,\n', '            allProposalSolutions[_proposalId].length.sub(1),\n', '            _solutionHash,\n', '            now\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Internal call to add solution and open proposal for voting\n', '     */\n', '    function _proposalSubmission(\n', '        uint256 _proposalId,\n', '        string memory _solutionHash,\n', '        bytes memory _action\n', '    ) internal {\n', '        uint256 _categoryId = allProposalData[_proposalId].category;\n', '        if (proposalCategory.categoryActionHashes(_categoryId).length == 0) {\n', '            require(keccak256(_action) == keccak256(""));\n', '            proposalActionStatus[_proposalId] = uint256(ActionStatus.NoAction);\n', '        }\n', '\n', '        _addSolution(_proposalId, _action, _solutionHash);\n', '\n', '        _updateProposalStatus(\n', '            _proposalId,\n', '            uint256(ProposalStatus.VotingStarted)\n', '        );\n', '        (, , , , , uint256 closingTime, ) = proposalCategory.category(\n', '            _categoryId\n', '        );\n', '        emit CloseProposalOnTime(_proposalId, closingTime.add(now));\n', '    }\n', '\n', '    /**\n', '     * @dev Internal call to submit vote\n', '     * @param _proposalId of proposal in concern\n', '     * @param _solution for that proposal\n', '     */\n', '    function _submitVote(uint256 _proposalId, uint256 _solution) internal {\n', '        uint256 mrSequence;\n', '        uint256 majority;\n', '        uint256 closingTime;\n', '        (, mrSequence, majority, , , closingTime, ) = proposalCategory.category(\n', '            allProposalData[_proposalId].category\n', '        );\n', '\n', '        require(\n', '            allProposalData[_proposalId].dateUpd.add(closingTime) > now,\n', '            "Closed"\n', '        );\n', '\n', '        require(\n', '            memberProposalVote[msg.sender][_proposalId] == 0,\n', '            "Not allowed"\n', '        );\n', '\n', '        require(memberRole.checkRole(msg.sender, mrSequence), "Not Authorized");\n', '        uint256 totalVotes = allVotes.length;\n', '\n', '        allVotesByMember[msg.sender].push(totalVotes);\n', '        memberProposalVote[msg.sender][_proposalId] = totalVotes;\n', '        tokenController.lockForGovernanceVote(msg.sender, tokenHoldingTime);\n', '\n', '        emit Vote(msg.sender, _proposalId, totalVotes, now, _solution);\n', '        uint256 numberOfMembers = memberRole.numberOfMembers(mrSequence);\n', '        _setVoteTally(_proposalId, _solution, mrSequence);\n', '\n', '        if (\n', '            numberOfMembers == proposalVoteTally[_proposalId].voters &&\n', '            mrSequence != uint256(IMemberRoles.Role.TokenHolder)\n', '        ) {\n', '            emit VoteCast(_proposalId);\n', '        }\n', '    }\n', '\n', '    function _setVoteTally(\n', '        uint256 _proposalId,\n', '        uint256 _solution,\n', '        uint256 mrSequence\n', '    ) internal {\n', '        uint256 voters = 1;\n', '        uint256 voteWeight;\n', '        uint256 tokenBalance = tokenController.totalBalanceOf(msg.sender);\n', '        uint totalSupply = tokenController.totalSupply();\n', '        if (mrSequence != uint(IMemberRoles.Role.AdvisoryBoard) &&\n', '        memberRole.checkRole(msg.sender, uint(IMemberRoles.Role.AdvisoryBoard))\n', '        )\n', '         {\n', '            proposalVoteTally[_proposalId].abVoteValue[_solution]++;\n', '        }\n', '        if (\n', '            mrSequence == uint256(IMemberRoles.Role.TokenHolder)\n', '        ) {\n', '            voteWeight = _minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100));\n', '        } else if (\n', '            mrSequence == uint256(IMemberRoles.Role.DisputeResolution)\n', '        ) {\n', '            voteWeight = tokenController.tokensLockedAtTime(msg.sender, "DR", now);\n', '        } else {\n', '            voteWeight = 1;\n', '        }\n', '        allVotes.push(\n', '            ProposalVote(msg.sender, _proposalId, _solution, tokenBalance, now)\n', '        );\n', '        allProposalData[_proposalId]\n', '            .totalVoteValue = allProposalData[_proposalId].totalVoteValue.add(\n', '            voteWeight\n', '        );\n', '        proposalVoteTally[_proposalId]\n', '            .voteValue[_solution] = proposalVoteTally[_proposalId]\n', '            .voteValue[_solution]\n', '            .add(voteWeight);\n', '        proposalVoteTally[_proposalId].voters =\n', '            proposalVoteTally[_proposalId].voters.add(voters);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets minimum of two numbers\n', '     * @param a one of the two numbers\n', '     * @param b one of the two numbers\n', '     * @return minimum number out of the two\n', '     */\n', '    function _minOf(uint a, uint b) internal pure returns(uint res) {\n', '        res = a;\n', '        if (res > b)\n', '            res = b;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if the vote count against any solution passes the threshold value or not.\n', '     */\n', '    function _checkForThreshold(uint256 _proposalId, uint256 _category)\n', '        internal\n', '        view\n', '        returns (bool check)\n', '    {\n', '        uint256 categoryQuorumPerc;\n', '        uint256 roleAuthorized;\n', '        (, roleAuthorized, , categoryQuorumPerc, , , ) = proposalCategory\n', '            .category(_category);\n', '        if (roleAuthorized == uint256(IMemberRoles.Role.TokenHolder)) {\n', '            check =\n', '                (allProposalData[_proposalId].totalVoteValue).mul(100).div(\n', '                    tokenController.totalSupply()\n', '                ) >=\n', '                categoryQuorumPerc;\n', '        } else if (roleAuthorized == uint256(IMemberRoles.Role.DisputeResolution)) {\n', '            (address marketAddress, ) = abi.decode(allProposalSolutions[_proposalId][1], (address, uint256));\n', '            uint256 totalStakeValueInPlot = IMarket(marketAddress).getTotalStakedValueInPLOT();\n', '            if(allProposalData[_proposalId].totalVoteValue > 0) {\n', '                check =\n', '                    (allProposalData[_proposalId].totalVoteValue) >=\n', '                    (_minOf(totalStakeValueInPlot.mul(drQuorumMulitplier), (tokenController.totalSupply()).mul(100).div(totalSupplyCapForDRQrm)));\n', '            } else {\n', '                check = false;\n', '            }\n', '        } else {\n', '            check =\n', '                (proposalVoteTally[_proposalId].voters).mul(100).div(\n', '                    memberRole.numberOfMembers(roleAuthorized)\n', '                ) >=\n', '                categoryQuorumPerc;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Called when vote majority is reached\n', '     * @param _proposalId of proposal in concern\n', '     * @param _status of proposal in concern\n', '     * @param category of proposal in concern\n', '     * @param max vote value of proposal in concern\n', '     */\n', '    function _callIfMajReached(\n', '        uint256 _proposalId,\n', '        uint256 _status,\n', '        uint256 category,\n', '        uint256 max,\n', '        uint256 role\n', '    ) internal {\n', '        allProposalData[_proposalId].finalVerdict = max;\n', '        _updateProposalStatus(_proposalId, _status);\n', '        emit ProposalAccepted(_proposalId);\n', '        if (\n', '            proposalActionStatus[_proposalId] != uint256(ActionStatus.NoAction)\n', '        ) {\n', '            if (role == actionRejectAuthRole) {\n', '                _triggerAction(_proposalId, category);\n', '            } else {\n', '                proposalActionStatus[_proposalId] = uint256(\n', '                    ActionStatus.Accepted\n', '                );\n', '                bytes memory functionHash = proposalCategory.categoryActionHashes(category);\n', '                if(keccak256(functionHash)\n', '                    == swapABMemberHash ||\n', '                    keccak256(functionHash)\n', '                    == resolveDisputeHash \n', '                ) {\n', '                    _triggerAction(_proposalId, category);\n', '                } else {\n', '                    proposalExecutionTime[_proposalId] = actionWaitingTime.add(now);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to trigger action of accepted proposal\n', '     */\n', '    function _triggerAction(uint256 _proposalId, uint256 _categoryId) internal {\n', '        proposalActionStatus[_proposalId] = uint256(ActionStatus.Executed);\n', '        bytes2 contractName;\n', '        address actionAddress;\n', '        bytes memory _functionHash;\n', '        (, actionAddress, contractName, , _functionHash) = proposalCategory\n', '            .categoryActionDetails(_categoryId);\n', '        if (contractName == "MS") {\n', '            actionAddress = address(ms);\n', '        } else if (contractName != "EX") {\n', '            actionAddress = ms.getLatestAddress(contractName);\n', '        }\n', '        (bool actionStatus, ) = actionAddress.call(\n', '            abi.encodePacked(\n', '                _functionHash,\n', '                allProposalSolutions[_proposalId][1]\n', '            )\n', '        );\n', '        if (actionStatus) {\n', '            emit ActionSuccess(_proposalId);\n', '        } else {\n', '            proposalActionStatus[_proposalId] = uint256(ActionStatus.Accepted);\n', '            emit ActionFailed(_proposalId);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Internal call to update proposal status\n', '     * @param _proposalId of proposal in concern\n', '     * @param _status of proposal to set\n', '     */\n', '    function _updateProposalStatus(uint256 _proposalId, uint256 _status)\n', '        internal\n', '    {\n', '        if (\n', '            _status == uint256(ProposalStatus.Rejected) ||\n', '            _status == uint256(ProposalStatus.Denied)\n', '        ) {\n', '            proposalActionStatus[_proposalId] = uint256(ActionStatus.NoAction);\n', '        }\n', '        allProposalData[_proposalId].dateUpd = now;\n', '        allProposalData[_proposalId].propStatus = _status;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal call to close member voting\n', '     * @param _proposalId of proposal in concern\n', '     * @param category of proposal in concern\n', '     */\n', '    function _closeVote(uint256 _proposalId, uint256 category) internal {\n', '        uint256 majorityVote;\n', '        uint256 mrSequence;\n', '        (, mrSequence, majorityVote, , , , ) = proposalCategory.category(\n', '            category\n', '        );\n', '        bytes memory _functionHash = proposalCategory.categoryActionHashes(category);\n', '        if (_checkForThreshold(_proposalId, category)) {\n', '            if (\n', '                (\n', '                    (\n', '                        proposalVoteTally[_proposalId].voteValue[1]\n', '                            .mul(100)\n', '                    )\n', '                        .div(allProposalData[_proposalId].totalVoteValue)\n', '                ) >= majorityVote\n', '            ) {\n', '                _callIfMajReached(\n', '                    _proposalId,\n', '                    uint256(ProposalStatus.Accepted),\n', '                    category,\n', '                    1,\n', '                    mrSequence\n', '                );\n', '            } else {\n', '                _updateProposalStatus(\n', '                    _proposalId,\n', '                    uint256(ProposalStatus.Rejected)\n', '                );\n', '            }\n', '        } else {\n', '            if ((keccak256(_functionHash) != resolveDisputeHash) &&\n', '             (mrSequence != uint(IMemberRoles.Role.AdvisoryBoard)) &&\n', '             proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\n', '                .div(memberRole.numberOfMembers(uint(IMemberRoles.Role.AdvisoryBoard))) >= advisoryBoardMajority\n', '            ) {\n', '                _callIfMajReached(\n', '                    _proposalId,\n', '                    uint256(ProposalStatus.Accepted),\n', '                    category,\n', '                    1,\n', '                    mrSequence\n', '                );\n', '            } else {\n', '                _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\n', '            }\n', '        }\n', '        if(allProposalData[_proposalId].propStatus > uint256(ProposalStatus.Accepted)) {\n', '            if(keccak256(_functionHash) == resolveDisputeHash) {\n', '                marketRegistry.burnDisputedProposalTokens(_proposalId);\n', '            }\n', '        }\n', '\n', '        if (proposalVoteTally[_proposalId].voters == 0 && allProposalData[_proposalId].commonIncentive > 0) {\n', '            _transferPLOT(\n', '                address(marketRegistry),\n', '                allProposalData[_proposalId].commonIncentive\n', '            );\n', '        }\n', '    }\n', '\n', '    function _transferPLOT(address _recipient, uint256 _amount) internal {\n', '        if(_amount > 0) {\n', '            tokenInstance.transfer(\n', '                _recipient,\n', '                _amount\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev to initiate the governance process\n', '     */\n', '    function _initiateGovernance() internal {\n', '        allVotes.push(ProposalVote(address(0), 0, 0, 0, 0));\n', '        totalProposals = 1;\n', '        tokenHoldingTime = 1 * 3 days;\n', '        constructorCheck = true;\n', '        roleIdAllowedToCatgorize = uint256(IMemberRoles.Role.AdvisoryBoard);\n', '        actionWaitingTime = 1 days;\n', '        actionRejectAuthRole = uint256(IMemberRoles.Role.AdvisoryBoard);\n', '        votePercRejectAction = 60;\n', '        maxVoteWeigthPer = 5;\n', '        advisoryBoardMajority = 60;\n', '        drQuorumMulitplier = 5;\n', '    }\n', '\n', '}']