['// File: contracts/IMultisigCarrier.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract IMultisigCarrier {\n', '\n', '    function approveFrom(\n', '        address caller,\n', '        address payable destination,\n', '        address currencyAddress,\n', '        uint256 amount\n', '    ) public returns (bool);\n', '\n', '}\n', '\n', '// File: contracts/MultisigVault.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', 'contract MultisigVault {\n', '\n', '    address private _carrier;\n', '\n', '    constructor() public {\n', '        _carrier = msg.sender;\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _carrier;\n', '    }\n', '\n', '    function approve(\n', '        address payable destination,\n', '        address currencyAddress,\n', '        uint256 amount\n', '    ) public returns (bool) {\n', '        IMultisigCarrier multisigCarrier = IMultisigCarrier(_carrier);\n', '        return multisigCarrier.approveFrom(msg.sender, destination, currencyAddress, amount);\n', '    }\n', '\n', '    function external_call(address destination, uint value, bytes memory data) public returns (bool) {\n', '        require(msg.sender == _carrier, "Ownable: caller is not the owner");\n', '\n', '        bool result;\n', '        assembly {\n', '            let dataLength := mload(data)\n', '            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n', '            result := call(\n', '                sub(gas(), 34710), // 34710 is the value that solidity is currently emitting\n', '                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n', '                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n', '                destination,\n', '                value,\n', '                d,\n', '                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\n', '                0,\n', '                0                  // Output is ignored, therefore the output size is zero\n', '            )\n', '        }\n', '        return result;\n', '    }\n', '\n', '\n', '    function () external payable {}\n', '}\n', '\n', '// File: contracts/MultisigCarrier.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract MultisigCarrier {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    struct VaultInfo {\n', '        bool initiated;\n', '        uint8 signatureMinThreshold;\n', '        address[] parties;\n', '    }\n', '\n', '    struct Approval {\n', '        uint32 nonce;\n', '        uint8  coincieded;\n', '        bool   finished;\n', '        address[] parties;\n', '    }\n', '\n', '    uint32 private _nonce;\n', '    address private _owner;\n', '\n', '    mapping(\n', '        address => VaultInfo\n', '    ) private _vaultInfos;\n', '\n', '    mapping(\n', '        // MutlisigVault\n', '        address => mapping(\n', '            // Destination\n', '            address => mapping(\n', '                // Currency\n', '                address => mapping(\n', '                    // Amount\n', '                    uint256 => Approval\n', '                )\n', '            )\n', '        )\n', '    ) public _approvals;\n', '\n', '    mapping(uint256 => bool) public _finished;\n', '\n', '    event NewMultisigCarrierCreated(address multisigCarrierAddress);\n', '\n', '    /**\n', '      * @dev Construcor.\n', '      *\n', '      * Requirements:\n', '      * - `_signatureMinThreshold` .\n', '      * - `_parties`.\n', '      */\n', '    constructor() public {\n', '        _owner = msg.sender;\n', '    }\n', '\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Caller is not the owner");\n', '        _;\n', '    }\n', '\n', '\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '\n', '    function createMultisigVault() public returns (address) {\n', '        MultisigVault multisigVault = new MultisigVault();\n', '        VaultInfo storage vaultInfo = _vaultInfos[address(multisigVault)];\n', '        vaultInfo.initiated = true;\n', '\n', '        emit NewMultisigCarrierCreated(address(multisigVault));\n', '\n', '        return address(multisigVault);\n', '    }\n', '\n', '\n', '    function setVaultInfo(\n', '        address vaultAddress,\n', '        uint8 signatureMinThreshold,\n', '        address[] memory parties\n', '    ) public onlyOwner() returns (bool) {\n', '        require(signatureMinThreshold > 0, "Parties are already set");\n', '        require(parties.length > 0 && parties.length <= 10, "Minimum 1, maximum 10 parties");\n', '        require(signatureMinThreshold <= parties.length, "Min signatures mismatches parties array");\n', '\n', '        VaultInfo storage vaultInfo = _vaultInfos[vaultAddress];\n', '        vaultInfo.signatureMinThreshold = signatureMinThreshold;\n', '        vaultInfo.parties = parties;\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    function approve(\n', '        address payable vaultAddress,\n', '        address payable destination,\n', '        address currencyAddress,\n', '        uint256 amount\n', '    ) public returns (bool) {\n', '        approveAndRelease(msg.sender, vaultAddress, destination, currencyAddress, amount);\n', '    }\n', '\n', '    function approveFrom(\n', '        address caller,\n', '        address payable destination,\n', '        address currencyAddress,\n', '        uint256 amount\n', '    ) public returns (bool) {\n', '        approveAndRelease(caller, msg.sender, destination, currencyAddress, amount);\n', '    }\n', '\n', '\n', '    function approveAndRelease(\n', '        address caller,\n', '        address payable vaultAddress,\n', '        address payable destination,\n', '        address currencyAddress,\n', '        uint256 amount\n', '    ) internal returns (bool) {\n', '        VaultInfo storage vaultInfo = _vaultInfos[vaultAddress];\n', '\n', '        require(vaultInfo.initiated, "Vault does not exist");\n', '        require(containsParty(vaultInfo.parties, caller), "Not a member");\n', '\n', '        if (currencyAddress == etherAddress()) {\n', '            address multisig = address(vaultAddress);  // https://biboknow.com/page-ethereum/78597/solidity-0-6-0-addressthis-balance-throws-error-invalid-opcode\n', '            require(multisig.balance >= amount, "Insufficient balance");\n', '        } else {\n', '            require(IERC20(currencyAddress).balanceOf(address(vaultAddress)) >= amount, "Insufficient balance");\n', '        }\n', '\n', '        Approval storage approval = _approvals[vaultAddress][destination][currencyAddress][amount];\n', '\n', '        require(!containsParty(approval.parties, caller), "Party already approved");\n', '\n', '        if (approval.coincieded == 0) {\n', '            _nonce += 1;\n', '            approval.nonce = _nonce;\n', '        }\n', '\n', '        approval.parties.push(caller);\n', '        approval.coincieded += 1;\n', '\n', '        if ( approval.coincieded >= vaultInfo.signatureMinThreshold ) {\n', '            _finished[approval.nonce] = true;\n', '            delete _approvals[vaultAddress][destination][currencyAddress][amount];\n', '\n', '            releaseFunds(vaultAddress, destination, currencyAddress, amount);\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '\n', '    function getNonce(\n', '        address vaultAddress,\n', '        address destination,\n', '        address currencyAddress,\n', '        uint256 amount\n', '    ) public view returns (uint256) {\n', '        Approval storage approval = _approvals[vaultAddress][destination][currencyAddress][amount];\n', '\n', '        return approval.nonce;\n', '    }\n', '\n', '\n', '    function partyCoincieded(\n', '        address vaultAddress,\n', '        address destination,\n', '        address currencyAddress,\n', '        uint256 amount,\n', '        uint256 nonce,\n', '        address partyAddress\n', '    ) public view returns (bool) {\n', '        if ( _finished[nonce] ) {\n', '          return true;\n', '        } else {\n', '          Approval storage approval = _approvals[vaultAddress][destination][currencyAddress][amount];\n', '\n', '          require(approval.nonce == nonce, "Nonce does not match");\n', '\n', '          return containsParty(approval.parties, partyAddress);\n', '        }\n', '    }\n', '\n', '\n', '    function releaseFunds(\n', '        address payable vaultAddress,\n', '        address payable destination,\n', '        address currencyAddress,\n', '        uint256 amount\n', '    ) internal {\n', '        MultisigVault multisigVault = MultisigVault(vaultAddress);\n', '\n', '        if (currencyAddress == etherAddress()) {\n', '            multisigVault.external_call(destination, amount, "");\n', '        } else {\n', '            multisigVault.external_call(currencyAddress, 0, abi.encodeWithSelector(IERC20(currencyAddress).transfer.selector, destination, amount));\n', '        }\n', '    }\n', '\n', '\n', '    function containsParty(address[] memory parties, address party) internal pure returns (bool) {\n', '        for (uint256 i = 0; i < parties.length; i++) {\n', '          if ( parties[i] == party ) {\n', '            return true;\n', '          }\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '\n', '    function etherAddress() public pure returns (address) {\n', '        return address(0x0);\n', '    }\n', '\n', '    function serviceAddress() public pure returns (address) {\n', '        return address(0x0A67A2cdC35D7Db352CfBd84fFF5e5F531dF62d1);\n', '    }\n', '}']