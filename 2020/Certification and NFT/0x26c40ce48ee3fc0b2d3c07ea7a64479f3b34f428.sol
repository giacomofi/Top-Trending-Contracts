['// SPDX-License-Identifier: MIT\n', '\n', '//  ___________      ___.   .__                  \n', '//  \\_   _____/ _____\\_ |__ |  |   ____   _____  \n', '//   |    __)_ /     \\| __ \\|  | _/ __ \\ /     \\ \n', '//   |        \\  Y Y  \\ \\_\\ \\  |_\\  ___/|  Y Y  \\\n', '//  /_______  /__|_|  /___  /____/\\___  >__|_|  /\n', '//          \\/      \\/    \\/          \\/      \\/ \n', '//  ____   ____            .__   __              \n', '//  \\   \\ /   /____   __ __|  |_/  |_            \n', '//   \\   Y   /\\__  \\ |  |  \\  |\\   __\\           \n', '//    \\     /  / __ \\|  |  /  |_|  |             \n', '//     \\___/  (____  /____/|____/__|  ------ https://emblem.pro\n', '//   ___ ___                    .___.__                       ________  \n', '//  /   |   \\_____    ____    __| _/|  |   ___________  ___  _\\_____  \\\n', '// /    ~    \\__  \\  /    \\  / __ | |  | _/ __ \\_  __ \\ \\  \\/ //  ____/ \n', '// \\    Y    // __ \\|   |  \\/ /_/ | |  |_\\  ___/|  | \\/  \\   //       \\ \n', '//  \\___|_  /(____  /___|  /\\____ | |____/\\___  >__|      \\_/ \\_______ \\\n', '//        \\/      \\/     \\/      \\/        \\/                         \\/\n', '\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () internal {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '// File: browser/IERC20Token.sol\n', '\n', 'pragma solidity ^0.6.11;\n', 'interface IERC20Token {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '// File: browser/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.11;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '// File: browser/VaultHandler_v2.sol\n', '\n', 'pragma experimental ABIEncoderV2;\n', 'pragma solidity ^0.6.11;\n', '\n', 'interface IERC721 {\n', '    function burn(uint256 tokenId) external;\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '    function mint( address _to, uint256 _tokenId, string calldata _uri, string calldata _payload) external;\n', '    function changeName(string calldata name, string calldata symbol) external;\n', '    function updateTokenUri(uint256 _tokenId,string memory _uri) external;\n', '    function tokenPayload(uint256 _tokenId) external view returns (string memory);\n', '}\n', '\n', 'interface Ownable {\n', '    function transferOwnership(address newOwner) external;\n', '}\n', '\n', 'interface BasicERC20 {\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', 'contract VaultHandlerV2 is ReentrancyGuard {\n', '    \n', '    using SafeMath for uint256;\n', '    using SafeMath for uint8;\n', '    address payable private owner;\n', '    string public metadataBaseUri;\n', '    bool public initialized;\n', '    address public nftAddress;\n', '    address public paymentAddress;\n', '    address public recipientAddress;\n', '    address public couponAddress;\n', '    uint256 public price;\n', '    \n', '    struct PreMint {\n', '        string payload;\n', '        bytes32 preImage;\n', '    }\n', '\n', '    \n', '    // mapping(uint => PreMint) public tokenIdToPreMint;\n', '    mapping(address => mapping(uint => PreMint)) preMints;\n', '    mapping(address => uint) preMintCounts;\n', '    \n', '    // event for EVM logging\n', '    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n', '    \n', '    // modifier to check if caller is owner\n', '    modifier isOwner() {\n', "        // If the first argument of 'require' evaluates to 'false', execution terminates and all\n", '        // changes to the state and to Ether balances are reverted.\n', '        // This used to consume all gas in old EVM versions, but not anymore.\n', "        // It is often a good idea to use 'require' to check if functions are called correctly.\n", '        // As a second argument, you can also provide an explanation about what went wrong.\n', '        require(msg.sender == owner, "Caller is not owner");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Change owner\n', '     * @param newOwner address of new owner\n', '     */\n', '    function transferOwnership(address payable newOwner) public isOwner {\n', '        emit OwnerSet(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '    \n', '    /**\n', '     * @dev Return owner address \n', '     * @return address of owner\n', '     */\n', '    function getOwner() external view returns (address) {\n', '        return owner;\n', '    }\n', '    \n', '    constructor(address _nftAddress, address _paymentAddress, address _recipientAddress, uint256 _price) public {\n', "        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\n", '        emit OwnerSet(address(0), owner);\n', '        metadataBaseUri = "http://104.154.252.216/meta/";\n', '        nftAddress = _nftAddress;\n', '        paymentAddress = _paymentAddress;\n', '        recipientAddress = _recipientAddress;\n', '        initialized = true;\n', '        uint decimals = BasicERC20(paymentAddress).decimals();\n', '        price = _price * 10 ** decimals;\n', '    }\n', '    \n', '    function claim(uint256 tokenId) public isOwner {\n', '        IERC721 token = IERC721(nftAddress);\n', '        token.burn(tokenId);\n', '    }\n', '    \n', '    function buyWithPaymentOnly(address _to, uint256 _tokenId, string calldata image) public payable {\n', '        IERC20Token paymentToken = IERC20Token(paymentAddress);\n', '        IERC721 nftToken = IERC721(nftAddress);\n', '        PreMint memory preMint = preMints[msg.sender][_tokenId];\n', "        require(preMint.preImage == sha256(abi.encodePacked(image)), 'Payload does not match'); // Payload should match\n", "        require(paymentToken.transferFrom(msg.sender, address(recipientAddress), price), 'Transfer ERROR'); // Payment sent to recipient\n", '        string memory _uri = concat(metadataBaseUri, uintToStr(_tokenId));\n', '        nftToken.mint(_to, _tokenId, _uri, preMint.payload);\n', '        delete preMints[msg.sender][_tokenId];\n', '        preMintCounts[msg.sender] = preMintCounts[msg.sender].sub(1);\n', '    }\n', '    \n', '    function addPreMint(address _for, string calldata _payload, uint256 _tokenId, bytes32 preImage) public isOwner {\n', '        try IERC721(nftAddress).tokenPayload(_tokenId) returns (string memory) {\n', "            revert('NFT Exists with this ID');\n", '        } catch {\n', "            require(!_duplicate(_for, _tokenId), 'Duplicate PreMint');\n", '            preMintCounts[_for] = preMintCounts[_for].add(1);\n', '            preMints[_for][_tokenId] = PreMint(_payload, preImage);\n', '        }\n', '    }\n', '    \n', '    function _duplicate(address _for, uint256 _tokenId) internal view returns (bool) {\n', '        string memory data = preMints[_for][_tokenId].payload;\n', "        bytes32 NULL = keccak256(bytes(''));\n", '        return keccak256(bytes(data)) != NULL;\n', '    }\n', '    \n', '    function deletePreMint(address _for, uint256 _tokenId) public isOwner {\n', '        preMintCounts[_for] = preMintCounts[_for].sub(1);\n', '        delete preMints[_for][_tokenId];\n', '    }\n', '    \n', '    function getPreMint(address _for, uint256 _tokenId) public view returns (PreMint memory) {\n', '        return preMints[_for][_tokenId];\n', '    }\n', '    \n', '    function checkPreMintImage(string memory image, bytes32 preImage) public pure returns (bytes32, bytes32, bool) {\n', '        bytes32 calculated = sha256(abi.encodePacked(image));\n', '        bytes32 preBytes = preImage;\n', '        return (calculated, preBytes, calculated == preBytes);\n', '    }\n', '    \n', '    function getPreMintCount(address _for) public view returns (uint length) {\n', '        return preMintCounts[_for];\n', '    }\n', '    \n', '    function changeMetadataBaseUri(string calldata _uri) public isOwner {\n', '        metadataBaseUri = _uri;\n', '    }\n', '    \n', '    function transferNftOwnership(address newOwner) external isOwner {\n', '        Ownable nftToken = Ownable(nftAddress);\n', '        nftToken.transferOwnership(newOwner);\n', '    }\n', '    \n', '    function mint( address _to, uint256 _tokenId, string calldata _uri, string calldata _payload) external isOwner {\n', '        IERC721 nftToken = IERC721(nftAddress);\n', '        nftToken.mint(_to, _tokenId, _uri, _payload);\n', '    }\n', '    \n', '    function changeName(string calldata name, string calldata symbol) external isOwner {\n', '        IERC721 nftToken = IERC721(nftAddress);\n', '        nftToken.changeName(name, symbol);\n', '    }\n', '    \n', '    function updateTokenUri(uint256 _tokenId,string memory _uri) external isOwner {\n', '        IERC721 nftToken = IERC721(nftAddress);\n', '        nftToken.updateTokenUri(_tokenId, _uri);\n', '    }\n', '    \n', '    function getPaymentDecimals() public view returns (uint8){\n', '        BasicERC20 token = BasicERC20(paymentAddress);\n', '        return token.decimals();\n', '    }\n', '    \n', '    function changePayment(address payment) public isOwner {\n', '       paymentAddress = payment;\n', '    }\n', '    \n', '    function changeCoupon(address coupon) public isOwner {\n', '       couponAddress = coupon;\n', '    }\n', '    \n', '    function changeRecipient(address _recipient) public isOwner {\n', '       recipientAddress = _recipient;\n', '    }\n', '    \n', '    function changeNft(address token) public isOwner {\n', '        nftAddress = token;\n', '    }\n', '    \n', '    function changePrice(uint256 _price) public isOwner {\n', '        uint decimals = BasicERC20(paymentAddress).decimals();\n', '        price = _price * 10 ** decimals;\n', '    }\n', '    \n', '    function concat(string memory a, string memory b) internal pure returns (string memory) {\n', '        return string(abi.encodePacked(a, b));\n', '    }\n', '    \n', '    /// @notice converts number to string\n', '    /// @dev source: https://github.com/provable-things/ethereum-api/blob/master/oraclizeAPI_0.5.sol#L1045\n', '    /// @param _i integer to convert\n', '    /// @return _uintAsString\n', '    function uintToStr(uint _i) internal pure returns (string memory _uintAsString) {\n', '        uint number = _i;\n', '        if (number == 0) {\n', '            return "0";\n', '        }\n', '        uint j = number;\n', '        uint len;\n', '        while (j != 0) {\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (number != 0) {\n', '            bstr[k--] = byte(uint8(48 + number % 10));\n', '            number /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '    \n', '    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\n', '        bytes memory tempEmptyStringTest = bytes(source);\n', '        if (tempEmptyStringTest.length == 0) {\n', '            return 0x0;\n', '        }\n', '    \n', '        assembly {\n', '            result := mload(add(source, 32))\n', '        }\n', '    }\n', '    function bytes32ToStr(bytes32 _bytes32) public pure returns (string memory) {\n', '\n', '        // string memory str = string(_bytes32);\n', '        // TypeError: Explicit type conversion not allowed from "bytes32" to "string storage pointer"\n', '        // thus we should fist convert bytes32 to bytes (to dynamically-sized byte array)\n', '    \n', '        bytes memory bytesArray = new bytes(32);\n', '        for (uint256 i; i < 32; i++) {\n', '            bytesArray[i] = _bytes32[i];\n', '            }\n', '        return string(bytesArray);\n', '    }\n', '}']