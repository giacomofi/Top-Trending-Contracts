['/*\n', 'https://powerpool.finance/\n', '\n', '          wrrrw r wrr\n', '         ppwr rrr wppr0       prwwwrp                                 prwwwrp                   wr0\n', '        rr 0rrrwrrprpwp0      pp   pr  prrrr0 pp   0r  prrrr0  0rwrrr pp   pr  prrrr0  prrrr0    r0\n', '        rrp pr   wr00rrp      prwww0  pp   wr pp w00r prwwwpr  0rw    prwww0  pp   wr pp   wr    r0\n', '        r0rprprwrrrp pr0      pp      wr   pr pp rwwr wr       0r     pp      wr   pr wr   pr    r0\n', '         prwr wrr0wpwr        00        www0   0w0ww    www0   0w     00        www0    www0   0www0\n', '          wrr ww0rrrr\n', '\n', '*/\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\n', '\n', 'pragma solidity >=0.4.24 <0.7.0;\n', '\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract ContextUpgradeSafe is Initializable {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {\n', '\n', '\n', '    }\n', '\n', '\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '\n', '    function __Ownable_init() internal initializer {\n', '        __Context_init_unchained();\n', '        __Ownable_init_unchained();\n', '    }\n', '\n', '    function __Ownable_init_unchained() internal initializer {\n', '\n', '\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[49] private __gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.6.2;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'contract ReentrancyGuardUpgradeSafe is Initializable {\n', '    bool private _notEntered;\n', '\n', '\n', '    function __ReentrancyGuard_init() internal initializer {\n', '        __ReentrancyGuard_init_unchained();\n', '    }\n', '\n', '    function __ReentrancyGuard_init_unchained() internal initializer {\n', '\n', '\n', '        // Storing an initial non-zero value makes deployment a bit more\n', '        // expensive, but in exchange the refund on every call to nonReentrant\n', '        // will be lower in amount. Since refunds are capped to a percetange of\n', "        // the total transaction's gas, it is best to keep them low in cases\n", '        // like this one, to increase the likelihood of the full refund coming\n', '        // into effect.\n', '        _notEntered = true;\n', '\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _notEntered = false;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '\n', '    uint256[49] private __gap;\n', '}\n', '\n', '// File: contracts/interfaces/ILpTokenMigrator.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '// note "contracts-ethereum-package" (but not "contracts") version of the package\n', '\n', '\n', 'interface ILpTokenMigrator {\n', '    // Perform LP token migration from legacy UniswapV2 to PowerSwap.\n', '    // Take the current LP token address and return the new LP token address.\n', "    // Migrator should have full access to the caller's LP token.\n", '    // Return the new LP token address.\n', '    //\n', '    // XXX Migrator must have allowance access to UniswapV2 LP tokens.\n', '    // PowerSwap must mint EXACTLY the same amount of PowerSwap LP tokens or\n', '    // else something bad will happen. Traditional UniswapV2 does not\n', '    // do that so be careful!\n', '    function migrate(IERC20 token, uint8 poolType) external returns (IERC20);\n', '}\n', '\n', '// File: contracts/interfaces/IVestedLPMining.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '/**\n', ' * @notice\n', ' */\n', 'interface IVestedLPMining {\n', '\n', '    /**\n', '    * @notice Initializes the storage of the contract\n', '    * @dev "constructor" to be called on a new proxy deployment\n', '    * @dev Sets the contract `owner` account to the deploying account\n', '    */\n', '    function initialize(\n', '        IERC20 _cvp,\n', '        address _reservoir,\n', '        uint256 _cvpPerBlock,\n', '        uint256 _startBlock,\n', '        uint256 _cvpVestingPeriodInBlocks\n', '    ) external;\n', '\n', '    function poolLength() external view returns (uint256);\n', '\n', '    /// @notice Add a new pool (only the owner may call)\n', '    function add(\n', '        uint256 _allocPoint,\n', '        IERC20 _lpToken,\n', '        uint8 _poolType,\n', '        bool _votesEnabled\n', '    ) external;\n', '\n', '    /// @notice Update parameters of the given pool (only the owner may call)\n', '    function set(\n', '        uint256 _pid,\n', '        uint256 _allocPoint,\n', '        uint8 _poolType,\n', '        bool _votesEnabled\n', '    ) external;\n', '\n', '    /// @notice Set the migrator contract (only the owner may call)\n', '    function setMigrator(ILpTokenMigrator _migrator) external;\n', '\n', '    /// @notice Set CVP reward per block (only the owner may call)\n', '    /// @dev Consider updating pool before calling this function\n', '    function setCvpPerBlock(uint256 _cvpPerBlock) external;\n', '\n', '    /// @notice Set CVP vesting period in blocks (only the owner may call)\n', '    function setCvpVestingPeriodInBlocks(uint256 _cvpVestingPeriodInBlocks) external;\n', '\n', '    /// @notice Migrate LP token to another LP contract\n', '    function migrate(uint256 _pid) external;\n', '\n', '    /// @notice Return reward multiplier over the given _from to _to block\n', '    function getMultiplier(uint256 _from, uint256 _to) external pure returns (uint256);\n', '\n', '    /// @notice Return the amount of pending CVPs entitled to the given user of the pool\n', '    function pendingCvp(uint256 _pid, address _user) external view returns (uint256);\n', '\n', '    /// @notice Return the amount of CVP tokens which may be vested to a user of a pool in the current block\n', '    function vestableCvp(uint256 _pid, address user) external view returns (uint256);\n', '\n', '    /// @notice Return `true` if the LP Token is added to created pools\n', '    function isLpTokenAdded(IERC20 _lpToken) external view returns (bool);\n', '\n', '    /// @notice Update reward computation params for all pools\n', '    /// @dev Be careful of gas spending\n', '    function massUpdatePools() external;\n', '\n', '    /// @notice Update CVP tokens allocation for the given pool\n', '    function updatePool(uint256 _pid) external;\n', '\n', '    /// @notice Deposit the given amount of LP tokens to the given pool\n', '    function deposit(uint256 _pid, uint256 _amount) external;\n', '\n', '    /// @notice Withdraw the given amount of LP tokens from the given pool\n', '    function withdraw(uint256 _pid, uint256 _amount) external;\n', '\n', '    /// @notice Withdraw LP tokens without caring about pending CVP tokens. EMERGENCY ONLY.\n', '    function emergencyWithdraw(uint256 _pid) external;\n', '\n', '    /// @notice Write votes of the given user at the current block\n', '    function checkpointVotes(address _user) external;\n', '\n', '    /// @notice Get CVP amount and the share of CVPs in LP pools for the given account and the checkpoint\n', '    function getCheckpoint(address account, uint32 checkpointId)\n', '    external view returns (uint32 fromBlock, uint96 cvpAmount, uint96 pooledCvpShare);\n', '\n', '    event AddLpToken(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n', '    event SetLpToken(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n', '    event SetMigrator(address indexed migrator);\n', '    event SetCvpPerBlock(uint256 cvpPerBlock);\n', '    event SetCvpVestingPeriodInBlocks(uint256 cvpVestingPeriodInBlocks);\n', '    event MigrateLpToken(address indexed oldLpToken, address indexed newLpToken, uint256 indexed pid);\n', '\n', '    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n', '\n', '    event CheckpointTotalLpVotes(uint256 lpVotes);\n', '    event CheckpointUserLpVotes(address indexed user, uint256 indexed pid, uint256 lpVotes);\n', '    event CheckpointUserVotes(address indexed user, uint256 pendedVotes, uint256 lpVotesShare);\n', '}\n', '\n', '// File: contracts/lib/ReservedSlots.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @dev Slots reserved for possible storage layout changes (it neither spends gas nor adds extra bytecode)\n', 'contract ReservedSlots {\n', '    uint256[100] private __gap;\n', '}\n', '\n', '// File: contracts/lib/SafeMath96.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeMath96 {\n', '\n', '    function add(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n', '        uint96 c = a + b;\n', '        require(c >= a, errorMessage);\n', '        return c;\n', '    }\n', '\n', '    function add(uint96 a, uint96 b) internal pure returns (uint96) {\n', '        return add(a, b, "SafeMath96: addition overflow");\n', '    }\n', '\n', '    function sub(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    function sub(uint96 a, uint96 b) internal pure returns (uint96) {\n', '        return sub(a, b, "SafeMath96: subtraction overflow");\n', '    }\n', '\n', '    function average(uint96 a, uint96 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '\n', '    function fromUint(uint n, string memory errorMessage) internal pure returns (uint96) {\n', '        require(n < 2**96, errorMessage);\n', '        return uint96(n);\n', '    }\n', '\n', '    function fromUint(uint n) internal pure returns (uint96) {\n', '        return fromUint(n, "SafeMath96: exceeds 96 bits");\n', '    }\n', '}\n', '\n', '// File: contracts/lib/SafeMath32.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeMath32 {\n', '\n', '    function add(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\n', '        uint32 c = a + b;\n', '        require(c >= a, errorMessage);\n', '        return c;\n', '    }\n', '\n', '    function add(uint32 a, uint32 b) internal pure returns (uint32) {\n', '        return add(a, b, "SafeMath32: addition overflow");\n', '    }\n', '\n', '    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n', '        return sub(a, b, "SafeMath32: subtraction overflow");\n', '    }\n', '\n', '    function fromUint(uint n, string memory errorMessage) internal pure returns (uint32) {\n', '        require(n < 2**32, errorMessage);\n', '        return uint32(n);\n', '    }\n', '\n', '    function fromUint(uint n) internal pure returns (uint32) {\n', '        return fromUint(n, "SafeMath32: exceeds 32 bits");\n', '    }\n', '}\n', '\n', '// File: contracts/lib/DelegatableCheckpoints.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'library DelegatableCheckpoints {\n', '\n', '    /// @dev A checkpoint storing some data effective from a given block\n', '    struct Checkpoint {\n', '        uint32 fromBlock;\n', '        uint192 data;\n', '        // uint32 __reserved;\n', '    }\n', '\n', "    /// @dev A set of checkpoints and a 'delegatee'\n", '    struct Record {\n', '        /// @dev new slot\n', '        uint32 numCheckpoints;\n', '        uint32 lastCheckpointBlock;\n', '        address delegatee;\n', '        // uint32 __reserved;\n', '\n', '        /// @dev new slot\n', '        // Checkpoints by IDs\n', '        mapping (uint32 => Checkpoint) checkpoints;\n', '        // @dev Checkpoint IDs get counted from 1 (but not from 0) -\n', "        // the 1st checkpoint has ID of 1, and the last checkpoint' ID is `numCheckpoints`\n", '    }\n', '\n', '    function getCheckpoint(Record storage record, uint checkpointId)\n', '    internal view returns (uint32 fromBlock, uint192 data)\n', '    {\n', '        return checkpointId == 0 || checkpointId > record.numCheckpoints\n', '            ? (0, 0)\n', '            : _getCheckpoint(record, uint32(checkpointId));\n', '    }\n', '\n', '    function _getCheckpoint(Record storage record, uint32 checkpointId)\n', '    internal view returns (uint32 fromBlock, uint192 data)\n', '    {\n', '        return (record.checkpoints[checkpointId].fromBlock, record.checkpoints[checkpointId].data);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the data recorded in the latest checkpoint of the given record\n', '     */\n', '    function getLatestData(Record storage record)\n', '    internal view returns (uint192)\n', '    {\n', '        Record memory _record = record;\n', '        return _record.numCheckpoints == 0\n', '        ? 0\n', '        : record.checkpoints[_record.numCheckpoints].data;\n', '    }\n', '\n', '    /**\n', "     * @dev Returns the prior data written in the given record' checkpoints as of a block number\n", '     * (reverts if the requested block has not been finalized)\n', '     * @param record The record with checkpoints\n', '     * @param blockNumber The block number to get the data at\n', '     * @param checkpointId Optional ID of a checkpoint to first look into\n', '     * @return The data effective as of the given block\n', '     */\n', '    function getPriorData(Record storage record, uint blockNumber, uint checkpointId)\n', '    internal view returns (uint192)\n', '    {\n', '        uint32 blockNum = _safeMinedBlockNum(blockNumber);\n', '        Record memory _record = record;\n', '        Checkpoint memory cp;\n', '\n', "        // First check specific checkpoint, if it's provided\n", '        if (checkpointId != 0) {\n', '            require(checkpointId <= _record.numCheckpoints, "ChPoints: invalid checkpoint id");\n', '            uint32 cpId = uint32(checkpointId);\n', '\n', '            cp = record.checkpoints[cpId];\n', '            if (cp.fromBlock == blockNum) {\n', '                return cp.data;\n', '            } else if (cp.fromBlock < blockNum) {\n', '                if (cpId == _record.numCheckpoints) {\n', '                    return cp.data;\n', '                }\n', '                uint32 nextFromBlock = record.checkpoints[cpId + 1].fromBlock;\n', '                if (nextFromBlock > blockNum) {\n', '                    return cp.data;\n', '                }\n', '            }\n', '        }\n', '\n', '        // Finally, search trough all checkpoints\n', '        ( , uint192 data) = _findCheckpoint(record, _record.numCheckpoints, blockNum);\n', '        return data;\n', '    }\n', '\n', '    /**\n', '     * @dev Finds a checkpoint in the given record for the given block number\n', '     * (reverts if the requested block has not been finalized)\n', '     * @param record The record with checkpoints\n', '     * @param blockNumber The block number to get the checkpoint at\n', '     * @return id The checkpoint ID\n', '     * @return data The checkpoint data\n', '     */\n', '    function findCheckpoint(Record storage record, uint blockNumber)\n', '    internal view returns (uint32 id, uint192 data)\n', '    {\n', '        uint32 blockNum = _safeMinedBlockNum(blockNumber);\n', '        uint32 numCheckpoints = record.numCheckpoints;\n', '\n', '        (id, data) = _findCheckpoint(record, numCheckpoints, blockNum);\n', '    }\n', '\n', '    /**\n', '     * @dev Writes a checkpoint with given data to the given record and returns the checkpoint ID\n', '     */\n', '    function writeCheckpoint(Record storage record, uint192 data)\n', '    internal returns (uint32 id)\n', '    {\n', '        uint32 blockNum = _safeBlockNum(block.number);\n', '        Record memory _record = record;\n', '\n', '        uint192 oldData = _record.numCheckpoints > 0 ? record.checkpoints[_record.numCheckpoints].data : 0;\n', '        bool isChanged = data != oldData;\n', '\n', '        if (_record.lastCheckpointBlock != blockNum) {\n', '            _record.numCheckpoints = _record.numCheckpoints + 1; // overflow chance ignored\n', '            record.numCheckpoints = _record.numCheckpoints;\n', '            record.lastCheckpointBlock = blockNum;\n', '            isChanged = true;\n', '        }\n', '        if (isChanged) {\n', '            record.checkpoints[_record.numCheckpoints] = Checkpoint(blockNum, data);\n', '        }\n', '        id = _record.numCheckpoints;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the given record properties (w/o mappings)\n', '     */\n', '    function getProperties(Record storage record) internal view returns (uint32, uint32, address) {\n', '        return (record.numCheckpoints, record.lastCheckpointBlock, record.delegatee);\n', '    }\n', '\n', '    /**\n', '     * @dev Writes given delegatee to the given record\n', '     */\n', '    function writeDelegatee(Record storage record, address delegatee) internal {\n', '        record.delegatee = delegatee;\n', '    }\n', '\n', '    function _safeBlockNum(uint256 blockNumber) private pure returns (uint32) {\n', '        require(blockNumber < 2**32, "ChPoints: blockNum >= 2**32");\n', '        return uint32(blockNumber);\n', '    }\n', '\n', '    function _safeMinedBlockNum(uint256 blockNumber) private view returns (uint32) {\n', '        require(blockNumber < block.number, "ChPoints: block not yet mined");\n', '        return _safeBlockNum(blockNumber);\n', '    }\n', '\n', '    function _findCheckpoint(Record storage record, uint32 numCheckpoints, uint32 blockNum)\n', '    private view returns (uint32, uint192)\n', '    {\n', '        Checkpoint memory cp;\n', '\n', '        // Check special cases first\n', '        if (numCheckpoints == 0) {\n', '            return (0, 0);\n', '        }\n', '        cp = record.checkpoints[numCheckpoints];\n', '        if (cp.fromBlock <= blockNum) {\n', '            return (numCheckpoints, cp.data);\n', '        }\n', '        if (record.checkpoints[1].fromBlock > blockNum) {\n', '            return (0, 0);\n', '        }\n', '\n', '        uint32 lower = 1;\n', '        uint32 upper = numCheckpoints;\n', '        while (upper > lower) {\n', '            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n', '            cp = record.checkpoints[center];\n', '            if (cp.fromBlock == blockNum) {\n', '                return (center, cp.data);\n', '            } else if (cp.fromBlock < blockNum) {\n', '                lower = center;\n', '            } else {\n', '                upper = center - 1;\n', '            }\n', '        }\n', '        return (lower, record.checkpoints[lower].data);\n', '    }\n', '}\n', '\n', '// File: contracts/DelegatableVotes.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', 'abstract contract DelegatableVotes {\n', '    using SafeMath96 for uint96;\n', '    using DelegatableCheckpoints for DelegatableCheckpoints.Record;\n', '\n', '    /**\n', '     * @notice Votes computation data for each account\n', '     * @dev Data adjusted to account "delegated" votes\n', '     * @dev For the contract address, stores shared for all accounts data\n', '     */\n', '    mapping (address => DelegatableCheckpoints.Record) public book;\n', '\n', '    /**\n', '     * @dev Data on votes which an account may delegate or has already delegated\n', '     */\n', '    mapping (address => uint192) internal delegatables;\n', '\n', "    /// @notice The event is emitted when a delegate account' vote balance changes\n", '    event CheckpointBalanceChanged(address indexed delegate, uint previousBalance, uint newBalance);\n', '\n', "    /// @notice An event that's emitted when an account changes its delegate\n", '    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n', '\n', '    /**\n', '     * @notice Get the "delegatee" account for the message sender\n', '     */\n', '    function delegatee() public view returns (address) {\n', '        return book[msg.sender].delegatee;\n', '    }\n', '\n', '    /**\n', '     * @notice Delegate votes from `msg.sender` to `delegatee`\n', '     * @param delegatee The address to delegate votes to\n', '     */\n', '    function delegate(address delegatee) public {\n', '        require(delegatee != address(this), "delegate: can\'t delegate to contract address");\n', '        return _delegate(msg.sender, delegatee);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the current votes balance for `account`\n', '     * @param account The address to get votes balance\n', '     * @return The number of current votes for `account`\n', '     */\n', '    function getCurrentVotes(address account) external view returns (uint96) {\n', '        uint192 userData = book[account].getLatestData();\n', '        if (userData == 0) return 0;\n', '\n', '        uint192 sharedData = book[address(this)].getLatestData();\n', '        return _computeUserVotes(userData, sharedData);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine the prior number of votes for the given account as of the given block\n', '     * @dev To prevent misinformation, the call reverts if the block requested is not finalized\n', '     * @param account The address of the account to get votes for\n', '     * @param blockNumber The block number to get votes at\n', '     * @return The number of votes the account had as of the given block\n', '     */\n', '    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n', '        return getPriorVotes(account, blockNumber, 0, 0);\n', '    }\n', '\n', '    /**\n', '     * @notice Gas-optimized version of the `getPriorVotes` function -\n', '     * it accepts IDs of checkpoints to look for voice data as of the given block in\n', '     * (if the checkpoints miss the data, it get searched through all checkpoints recorded)\n', '     * @dev Call (off-chain) the `findCheckpoints` function to get needed IDs\n', '     * @param account The address of the account to get votes for\n', '     * @param blockNumber The block number to get votes at\n', '     * @param userCheckpointId ID of the checkpoint to look for the user data first\n', '     * @param userCheckpointId ID of the checkpoint to look for the shared data first\n', '     * @return The number of votes the account had as of the given block\n', '     */\n', '    function getPriorVotes(\n', '        address account,\n', '        uint blockNumber,\n', '        uint32 userCheckpointId,\n', '        uint32 sharedCheckpointId\n', '    ) public view returns (uint96)\n', '    {\n', '        uint192 userData = book[account].getPriorData(blockNumber, userCheckpointId);\n', '        if (userData == 0) return 0;\n', '\n', '        uint192 sharedData = book[address(this)].getPriorData(blockNumber, sharedCheckpointId);\n', '        return _computeUserVotes(userData, sharedData);\n', '    }\n', '\n', "    /// @notice Returns IDs of checkpoints which store the given account' voice computation data\n", '    /// @dev Intended for off-chain use (by UI)\n', '    function findCheckpoints(address account, uint256 blockNumber)\n', '    external view returns (uint32 userCheckpointId, uint32 sharedCheckpointId)\n', '    {\n', '        require(account != address(0), "findCheckpoints: zero account");\n', '        (userCheckpointId, ) = book[account].findCheckpoint(blockNumber);\n', '        (sharedCheckpointId, ) = book[address(this)].findCheckpoint(blockNumber);\n', '    }\n', '\n', '    function _getCheckpoint(address account, uint32 checkpointId)\n', '    internal view returns (uint32 fromBlock, uint192 data)\n', '    {\n', '        (fromBlock, data) = book[account].getCheckpoint(checkpointId);\n', '    }\n', '\n', '    function _writeSharedData(uint192 data) internal {\n', '        book[address(this)].writeCheckpoint(data);\n', '    }\n', '\n', '    function _writeUserData(address account, uint192 data) internal {\n', '        DelegatableCheckpoints.Record storage src = book[account];\n', '        address delegatee = src.delegatee;\n', '        DelegatableCheckpoints.Record storage dst = delegatee == address(0) ? src : book[delegatee];\n', '\n', '        dst.writeCheckpoint(\n', '           // keep in mind voices which others could have delegated\n', '            _computeUserData(dst.getLatestData(), data, delegatables[account])\n', '        );\n', '        delegatables[account] = data;\n', '    }\n', '\n', '    function _moveUserData(address account, address from, address to) internal {\n', '        DelegatableCheckpoints.Record storage src;\n', '        DelegatableCheckpoints.Record storage dst;\n', '\n', '        if (from == address(0)) { // no former delegatee\n', '            src = book[account];\n', '            dst = book[to];\n', '        }\n', '        else if (to == address(0)) { // delegation revoked\n', '            src = book[from];\n', '            dst = book[account];\n', '        }\n', '        else {\n', '            src = book[from];\n', '            dst = book[to];\n', '        }\n', '        uint192 delegatable = delegatables[account];\n', '\n', '        uint192 srcPrevData = src.getLatestData();\n', '        uint192 srcData = _computeUserData(srcPrevData, 0, delegatable);\n', '        if (srcPrevData != srcData) src.writeCheckpoint(srcData);\n', '\n', '        uint192 dstPrevData = dst.getLatestData();\n', '        uint192 dstData = _computeUserData(dstPrevData, delegatable, 0);\n', '        if (dstPrevData != dstData) dst.writeCheckpoint(dstData);\n', '    }\n', '\n', '    function _delegate(address delegator, address delegatee) internal {\n', '        address currentDelegate = book[delegator].delegatee;\n', '        book[delegator].delegatee = delegatee;\n', '\n', '        emit DelegateChanged(delegator, currentDelegate, delegatee);\n', '\n', '        _moveUserData(delegator, currentDelegate, delegatee);\n', '    }\n', '\n', '    function _computeUserVotes(uint192 userData, uint192 sharedData) internal pure virtual returns (uint96 votes);\n', '\n', '    function _computeUserData(uint192 prevData, uint192 newDelegated, uint192 prevDelegated)\n', '    internal pure virtual returns (uint192 userData)\n', '    {\n', '        (uint96 prevA, uint96 prevB) = _unpackData(prevData);\n', '        (uint96 newDelegatedA, uint96 newDelegatedB) = _unpackData(newDelegated);\n', '        (uint96 prevDelegatedA, uint96 prevDelegatedB) = _unpackData(prevDelegated);\n', '        userData = _packData(\n', '            _getNewValue(prevA, newDelegatedA, prevDelegatedA),\n', '            _getNewValue(prevB, newDelegatedB, prevDelegatedB)\n', '        );\n', '    }\n', '\n', '    function _unpackData(uint192 data) internal pure virtual returns (uint96 valA, uint96 valB) {\n', '        return (uint96(data >> 96), uint96((data << 96) >> 96));\n', '    }\n', '\n', '    function _packData(uint96 valA, uint96 valB) internal pure  virtual returns (uint192 data) {\n', '        return ((uint192(valA) << 96) | uint192(valB));\n', '    }\n', '\n', '    function _getNewValue(uint96 val, uint96 more, uint96 less) internal pure  virtual returns (uint96 newVal) {\n', '        if (more == less) {\n', '            newVal = val;\n', '        } else if (more > less) {\n', '            newVal = val.add(more.sub(less));\n', '        } else {\n', '            uint96 decrease = less.sub(more);\n', '            newVal = val > decrease ? val.sub(decrease) : 0;\n', '        }\n', '    }\n', '\n', '    uint256[50] private _gap; // reserved\n', '}\n', '\n', '// File: contracts/VestedLPMining.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract VestedLPMining is\n', '    OwnableUpgradeSafe,\n', '    ReentrancyGuardUpgradeSafe,\n', '    ReservedSlots,\n', '    DelegatableVotes,\n', '    IVestedLPMining\n', '{\n', '    using SafeMath for uint256;\n', '    using SafeMath96 for uint96;\n', '    using SafeMath32 for uint32;\n', '\n', '    using SafeERC20 for IERC20;\n', '\n', '    /// @dev properties grouped to optimize storage costs\n', '\n', '    struct User {\n', '        /// @dev new slot\n', '        uint32 lastUpdateBlock;   // block when the params (below) were updated\n', '        uint32 vestingBlock;      // block by when all entitled CVP tokens to be vested\n', '        uint96 pendedCvp;         // amount of CVPs tokens entitled but not yet vested to the user\n', '        uint96 cvpAdjust;         // adjustments for pended CVP tokens amount computation\n', '                                  // (with regard to LP token deposits/withdrawals in the past)\n', '        /// @dev new slot\n', '        uint256 lptAmount;        // amount of LP tokens the user has provided to a pool\n', '        /** @dev\n', '         * At any time, the amount of CVP tokens entitled to a user but not yet vested is the sum of:\n', '         * (1) CVP token amount entitled after the user last time deposited or withdrawn LP tokens\n', '         *     = (user.lptAmount * pool.accCvpPerLpt) - user.cvpAdjust\n', '         * (2) CVP token amount entitled before the last deposit or withdrawal but not yet vested\n', '         *     = user.pendedCvp\n', '         *\n', '         * Whenever a user deposits or withdraws LP tokens to a pool:\n', '         *   1. `pool.accCvpPerLpt` for the pool gets updated;\n', '         *   2. CVP token amounts to be entitled and vested to the user get computed;\n', '         *   3. Token amount which may be vested get sent to the user;\n', "         *   3. User' `lptAmount`, `cvpAdjust` and `pendedCvp` get updated.\n", '         *\n', '         * Note comments on vesting rules in the `function _computeCvpVesting` code bellow.\n', '         */\n', '    }\n', '\n', '    struct Pool {\n', '        /// @dev new slot\n', '        IERC20 lpToken;           // address of the LP token contract\n', '        bool votesEnabled;        // if the pool is enabled to write votes\n', '        uint8 poolType;           // pool type (1 - Uniswap, 2 - Balancer)\n', '        uint32 allocPoint;        // points assigned to the pool, which affect CVPs distribution between pools\n', '        uint32 lastUpdateBlock;   // latest block when the pool params which follow was updated\n', '        /// @dev new slot\n', '        uint256 accCvpPerLpt;     // accumulated distributed CVPs per one deposited LP token, times 1e12\n', '    }\n', '    // scale factor for `accCvpPerLpt`\n', '    uint256 internal constant SCALE = 1e12;\n', '\n', '    /// @dev new slot\n', '    // The CVP TOKEN\n', '    IERC20 public cvp;\n', '    // Total amount of CVP tokens pended (not yet vested to users)\n', '    uint96 public cvpVestingPool;\n', '\n', '    /// @dev new slot\n', '    // Reservoir address\n', '    address public reservoir;\n', '    // Vesting duration in blocks\n', '    uint32 public cvpVestingPeriodInBlocks;\n', '    // The block number when CVP mining starts\n', '    uint32 public startBlock;\n', '    // The amount of CVP tokens rewarded to all pools every block\n', '    uint96 public cvpPerBlock;\n', '\n', '    /// @dev new slot\n', '    // The migrator contract (only the owner may assign it)\n', '    ILpTokenMigrator public migrator;\n', '\n', '    // Params of each pool\n', '    Pool[] public pools;\n', '    // Pid (i.e. the index in `pools`) of each pool by its LP token address\n', '    mapping(address => uint256) public poolPidByAddress;\n', '    // Params of each user that stakes LP tokens, by the Pid and the user address\n', '    mapping (uint256 => mapping (address => User)) public users;\n', '    // Sum of allocation points for all pools\n', '    uint256 public totalAllocPoint = 0;\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function initialize(\n', '        IERC20 _cvp,\n', '        address _reservoir,\n', '        uint256 _cvpPerBlock,\n', '        uint256 _startBlock,\n', '        uint256 _cvpVestingPeriodInBlocks\n', '    ) external override initializer {\n', '        __Ownable_init();\n', '        __ReentrancyGuard_init_unchained();\n', '\n', '        cvp = _cvp;\n', '        reservoir = _reservoir;\n', '        startBlock = SafeMath32.fromUint(_startBlock, "VLPMining: too big startBlock");\n', '        cvpVestingPeriodInBlocks = SafeMath32.fromUint(_cvpVestingPeriodInBlocks, "VLPMining: too big vest period");\n', '        setCvpPerBlock(_cvpPerBlock);\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function poolLength() external view override returns (uint256) {\n', '        return pools.length;\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function add(uint256 _allocPoint, IERC20 _lpToken, uint8 _poolType, bool _votesEnabled)\n', '    public override onlyOwner\n', '    {\n', '        require(!isLpTokenAdded(_lpToken), "VLPMining: token already added");\n', '\n', '        massUpdatePools();\n', '        uint32 blockNum = _currBlock();\n', '        uint32 lastUpdateBlock = blockNum > startBlock ? blockNum : startBlock;\n', '        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n', '\n', '        uint256 pid = pools.length;\n', '        pools.push(Pool({\n', '            lpToken: _lpToken,\n', '            votesEnabled: _votesEnabled,\n', '            poolType: _poolType,\n', '            allocPoint: SafeMath32.fromUint(_allocPoint, "VLPMining: too big allocation"),\n', '            lastUpdateBlock: lastUpdateBlock,\n', '            accCvpPerLpt: 0\n', '        }));\n', '        poolPidByAddress[address(_lpToken)] = pid;\n', '\n', '        emit AddLpToken(address(_lpToken), pid, _allocPoint);\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function set(uint256 _pid, uint256 _allocPoint, uint8 _poolType, bool _votesEnabled)\n', '    public override onlyOwner\n', '    {\n', '        massUpdatePools();\n', '        totalAllocPoint = totalAllocPoint.sub(uint256(pools[_pid].allocPoint)).add(_allocPoint);\n', '        pools[_pid].allocPoint = SafeMath32.fromUint(_allocPoint, "VLPMining: too big allocation");\n', '        pools[_pid].votesEnabled = _votesEnabled;\n', '        pools[_pid].poolType = _poolType;\n', '\n', '        emit SetLpToken(address(pools[_pid].lpToken), _pid, _allocPoint);\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function setMigrator(ILpTokenMigrator _migrator) public override onlyOwner {\n', '        migrator = _migrator;\n', '\n', '        emit SetMigrator(address(_migrator));\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function setCvpPerBlock(uint256 _cvpPerBlock) public override onlyOwner {\n', '        cvpPerBlock = SafeMath96.fromUint(_cvpPerBlock, "VLPMining: too big cvpPerBlock");\n', '\n', '        emit SetCvpPerBlock(_cvpPerBlock);\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function setCvpVestingPeriodInBlocks(uint256 _cvpVestingPeriodInBlocks) public override onlyOwner {\n', '        cvpVestingPeriodInBlocks = SafeMath32.fromUint(\n', '            _cvpVestingPeriodInBlocks,\n', '            "VLPMining: too big cvpVestingPeriodInBlocks"\n', '        );\n', '\n', '        emit SetCvpVestingPeriodInBlocks(_cvpVestingPeriodInBlocks);\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    /// @dev Anyone may call, so we have to trust the migrator contract\n', '    function migrate(uint256 _pid) public override nonReentrant {\n', '        require(address(migrator) != address(0), "VLPMining: no migrator");\n', '        Pool storage pool = pools[_pid];\n', '        IERC20 lpToken = pool.lpToken;\n', '        uint256 bal = lpToken.balanceOf(address(this));\n', '        lpToken.safeApprove(address(migrator), bal);\n', '        IERC20 newLpToken = migrator.migrate(lpToken, pool.poolType);\n', '        require(bal == newLpToken.balanceOf(address(this)), "VLPMining: invalid migration");\n', '        pool.lpToken = newLpToken;\n', '\n', '        delete poolPidByAddress[address(lpToken)];\n', '        poolPidByAddress[address(newLpToken)] = _pid;\n', '\n', '        emit MigrateLpToken(address(lpToken), address(newLpToken), _pid);\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function getMultiplier(uint256 _from, uint256 _to) public pure override returns (uint256) {\n', '        return _to.sub(_from, "VLPMining: _to exceeds _from");\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function pendingCvp(uint256 _pid, address _user) external view override returns (uint256) {\n', '        if (_pid >= pools.length) return 0;\n', '\n', '        Pool memory _pool = pools[_pid];\n', '        User storage user = users[_pid][_user];\n', '\n', '        _computePoolReward(_pool);\n', '        uint96 newlyEntitled = _computeCvpToEntitle(\n', '            user.lptAmount,\n', '            user.cvpAdjust,\n', '            _pool.accCvpPerLpt\n', '        );\n', '\n', '        return uint256(newlyEntitled.add(user.pendedCvp));\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function vestableCvp(uint256 _pid, address user) external view override returns (uint256) {\n', '        Pool memory _pool = pools[_pid];\n', '        User memory _user = users[_pid][user];\n', '\n', '        _computePoolReward(_pool);\n', '        ( , uint256 newlyVested) = _computeCvpVesting(_user, _pool.accCvpPerLpt);\n', '\n', '        return newlyVested;\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function isLpTokenAdded(IERC20 _lpToken) public view override returns (bool) {\n', '        uint256 pid = poolPidByAddress[address(_lpToken)];\n', '        return pools.length > pid && address(pools[pid].lpToken) == address(_lpToken);\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function massUpdatePools() public override {\n', '        uint256 length = pools.length;\n', '        for (uint256 pid = 0; pid < length; ++pid) {\n', '            updatePool(pid);\n', '        }\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function updatePool(uint256 _pid) public override nonReentrant {\n', '        Pool storage pool = pools[_pid];\n', '        _doPoolUpdate(pool);\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function deposit(uint256 _pid, uint256 _amount) public override nonReentrant {\n', '        _validatePoolId(_pid);\n', '\n', '        Pool storage pool = pools[_pid];\n', '        User storage user = users[_pid][msg.sender];\n', '\n', '        _doPoolUpdate(pool);\n', '        _vestUserCvp(user, pool.accCvpPerLpt);\n', '\n', '        if(_amount != 0) {\n', '            pool.lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n', '            user.lptAmount = user.lptAmount.add(_amount);\n', '        }\n', '        user.cvpAdjust = _computeCvpAdjustment(user.lptAmount, pool.accCvpPerLpt);\n', '        emit Deposit(msg.sender, _pid, _amount);\n', '\n', '        _doCheckpointVotes(msg.sender);\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function withdraw(uint256 _pid, uint256 _amount) public override nonReentrant {\n', '        _validatePoolId(_pid);\n', '\n', '        Pool storage pool = pools[_pid];\n', '        User storage user = users[_pid][msg.sender];\n', '        require(user.lptAmount >= _amount, "VLPMining: amount exceeds balance");\n', '\n', '        _doPoolUpdate(pool);\n', '        _vestUserCvp(user, pool.accCvpPerLpt);\n', '\n', '        if(_amount != 0) {\n', '            user.lptAmount = user.lptAmount.sub(_amount);\n', '            pool.lpToken.safeTransfer(msg.sender, _amount);\n', '        }\n', '        user.cvpAdjust = _computeCvpAdjustment(user.lptAmount, pool.accCvpPerLpt);\n', '        emit Withdraw(msg.sender, _pid, _amount);\n', '\n', '        _doCheckpointVotes(msg.sender);\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function emergencyWithdraw(uint256 _pid) public override nonReentrant {\n', '        _validatePoolId(_pid);\n', '\n', '        Pool storage pool = pools[_pid];\n', '        User storage user = users[_pid][msg.sender];\n', '\n', '        pool.lpToken.safeTransfer(msg.sender, user.lptAmount);\n', '        emit EmergencyWithdraw(msg.sender, _pid, user.lptAmount);\n', '\n', '        if (user.pendedCvp > 0) {\n', "            // TODO: Make user.pendedCvp be updated as of the pool' lastUpdateBlock\n", '            if (user.pendedCvp > cvpVestingPool) {\n', '                cvpVestingPool = cvpVestingPool.sub(user.pendedCvp);\n', '            } else {\n', '                cvpVestingPool = 0;\n', '            }\n', '        }\n', '\n', '        user.lptAmount = 0;\n', '        user.cvpAdjust = 0;\n', '        user.pendedCvp = 0;\n', '        user.vestingBlock = 0;\n', '\n', '        _doCheckpointVotes(msg.sender);\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function checkpointVotes(address _user) public override nonReentrant {\n', '        _doCheckpointVotes(_user);\n', '    }\n', '\n', '    /// @inheritdoc IVestedLPMining\n', '    function getCheckpoint(address account, uint32 checkpointId)\n', '    external override view returns (uint32 fromBlock, uint96 cvpAmount, uint96 pooledCvpShare)\n', '    {\n', '        uint192 data;\n', '        (fromBlock, data) = _getCheckpoint(account, checkpointId);\n', '        (cvpAmount, pooledCvpShare) = _unpackData(data);\n', '    }\n', '\n', '    function _doCheckpointVotes(address _user) internal {\n', '        uint256 length = pools.length;\n', '        uint96 userPendedCvp = 0;\n', '        uint256 userTotalLpCvp = 0;\n', '        uint96 totalLpCvp = 0;\n', '        for (uint256 pid = 0; pid < length; ++pid) {\n', '            userPendedCvp = userPendedCvp.add(users[pid][_user].pendedCvp);\n', '\n', '            Pool storage pool = pools[pid];\n', '            uint96 lpCvp = SafeMath96.fromUint(\n', '                cvp.balanceOf(address(pool.lpToken)),\n', '                // this and similar error messages are not intended for end-users\n', '                "VLPMining::_doCheckpointVotes:1"\n', '            );\n', '            totalLpCvp = totalLpCvp.add(lpCvp);\n', '\n', '            if (!pool.votesEnabled) {\n', '                continue;\n', '            }\n', '\n', '            uint256 lptTotalSupply = pool.lpToken.totalSupply();\n', '            uint256 lptAmount = users[pid][_user].lptAmount;\n', '            if (lptAmount != 0 && lptTotalSupply != 0) {\n', '                uint256 cvpPerLpt = uint256(lpCvp).mul(SCALE).div(lptTotalSupply);\n', '                uint256 userLpCvp = lptAmount.mul(cvpPerLpt).div(SCALE);\n', '                userTotalLpCvp = userTotalLpCvp.add(userLpCvp);\n', '\n', '                emit CheckpointUserLpVotes(_user, pid, userLpCvp);\n', '            }\n', '        }\n', '\n', '        uint96 lpCvpUserShare = (userTotalLpCvp == 0 || totalLpCvp == 0)\n', '            ? 0\n', '            : SafeMath96.fromUint(\n', '                userTotalLpCvp.mul(SCALE).div(totalLpCvp),\n', '                "VLPMining::_doCheckpointVotes:2"\n', '            );\n', '\n', '        emit CheckpointTotalLpVotes(totalLpCvp);\n', '        emit CheckpointUserVotes(_user, uint256(userPendedCvp), lpCvpUserShare);\n', '\n', '        _writeUserData(_user, _packData(userPendedCvp, lpCvpUserShare));\n', '        _writeSharedData(_packData(totalLpCvp, 0));\n', '    }\n', '\n', '    function _transferCvp(address _to, uint256 _amount) internal {\n', '        SafeERC20.safeTransferFrom(cvp, reservoir, _to, _amount);\n', '    }\n', '\n', '    /// @dev must be guarded for reentrancy\n', '    function _doPoolUpdate(Pool storage pool) internal {\n', '        Pool memory _pool = pool;\n', '        uint32 prevBlock = _pool.lastUpdateBlock;\n', '        uint256 prevAcc = _pool.accCvpPerLpt;\n', '\n', '        uint256 cvpReward = _computePoolReward(_pool);\n', '        if (cvpReward != 0) {\n', '            cvpVestingPool = cvpVestingPool.add(\n', '                SafeMath96.fromUint(cvpReward, "VLPMining::_doPoolUpdate:1"),\n', '                "VLPMining::_doPoolUpdate:2"\n', '            );\n', '        }\n', '        if (_pool.accCvpPerLpt > prevAcc) {\n', '            pool.accCvpPerLpt = _pool.accCvpPerLpt;\n', '        }\n', '        if (_pool.lastUpdateBlock > prevBlock) {\n', '            pool.lastUpdateBlock = _pool.lastUpdateBlock;\n', '        }\n', '    }\n', '\n', '    function _vestUserCvp(User storage user, uint256 accCvpPerLpt) internal {\n', '        User memory _user = user;\n', '        uint32 prevVestingBlock = _user.vestingBlock;\n', '        uint32 prevUpdateBlock = _user.lastUpdateBlock;\n', '        (uint256 newlyEntitled, uint256 newlyVested) = _computeCvpVesting(_user, accCvpPerLpt);\n', '\n', '        if (newlyEntitled != 0) {\n', '            user.pendedCvp = _user.pendedCvp;\n', '        }\n', '        if (newlyVested != 0) {\n', '            if (newlyVested > cvpVestingPool) newlyVested = uint256(cvpVestingPool);\n', '            cvpVestingPool = cvpVestingPool.sub(\n', '                SafeMath96.fromUint(newlyVested, "VLPMining::_vestUserCvp:1"),\n', '                "VLPMining::_vestUserCvp:2"\n', '            );\n', '            _transferCvp(msg.sender, newlyVested);\n', '        }\n', '        if (_user.vestingBlock > prevVestingBlock) {\n', '            user.vestingBlock = _user.vestingBlock;\n', '        }\n', '        if (_user.lastUpdateBlock > prevUpdateBlock) {\n', '            user.lastUpdateBlock = _user.lastUpdateBlock;\n', '        }\n', '    }\n', '\n', '    /* @dev Compute the amount of CVP tokens to be entitled and vested to a user of a pool\n', '     * ... and update the `_user` instance (in the memory):\n', '     *   `_user.pendedCvp` gets increased by `newlyEntitled - newlyVested`\n', '     *   `_user.vestingBlock` set to the updated value\n', '     *   `_user.lastUpdateBlock` set to the current block\n', '     *\n', '     * @param _user - user to compute tokens for\n', "     * @param accCvpPerLpt - value of the pool' `pool.accCvpPerLpt`\n", '     * @return newlyEntitled - CVP amount to entitle (on top of tokens entitled so far)\n', '     * @return newlyVested - CVP amount to vest (on top of tokens already vested)\n', '     */\n', '    function _computeCvpVesting(User memory _user, uint256 accCvpPerLpt)\n', '    internal view returns (uint256 newlyEntitled, uint256 newlyVested)\n', '    {\n', '        uint32 prevBlock = _user.lastUpdateBlock;\n', '        _user.lastUpdateBlock = _currBlock();\n', '        if (prevBlock >= _user.lastUpdateBlock) {\n', '            return (0, 0);\n', '        }\n', '\n', '        uint32 age = _user.lastUpdateBlock - prevBlock;\n', '\n', '        // Tokens which are to be entitled starting from the `user.lastUpdateBlock`, shall be\n', '        // vested proportionally to the number of blocks already minted within the period between\n', '        // the `user.lastUpdateBlock` and `cvpVestingPeriodInBlocks` following the current block\n', '        newlyEntitled = uint256(_computeCvpToEntitle(_user.lptAmount, _user.cvpAdjust, accCvpPerLpt));\n', '        uint256 newToVest = newlyEntitled == 0 ? 0 : (\n', '            newlyEntitled.mul(uint256(age)).div(uint256(age + cvpVestingPeriodInBlocks))\n', '        );\n', '\n', '        // Tokens which have been pended since the `user.lastUpdateBlock` shall be vested:\n', '        // - in full, if the `user.vestingBlock` has been mined\n', '        // - otherwise, proportionally to the number of blocks already mined so far in the period\n', '        //   between the `user.lastUpdateBlock` and the `user.vestingBlock` (not yet mined)\n', '        uint256 pended = uint256(_user.pendedCvp);\n', '        age = _user.lastUpdateBlock >= _user.vestingBlock\n', '            ? cvpVestingPeriodInBlocks\n', '            : _user.lastUpdateBlock - prevBlock;\n', '        uint256 pendedToVest = pended == 0 ? 0 : (\n', '            age >= cvpVestingPeriodInBlocks\n', '                ? pended\n', '                : pended.mul(uint256(age)).div(uint256(_user.vestingBlock - prevBlock))\n', '        );\n', '\n', '        newlyVested = pendedToVest.add(newToVest);\n', '        _user.pendedCvp = SafeMath96.fromUint(\n', '            uint256(_user.pendedCvp).add(newlyEntitled).sub(newlyVested),\n', '            "VLPMining::computeCvpVest:1"\n', '        );\n', '\n', '        // Amount of CVP token pended (i.e. not yet vested) from now\n', '        uint256 remainingPended = pended == 0 ? 0 : pended.sub(pendedToVest);\n', '        uint256 unreleasedNewly = newlyEntitled == 0 ? 0 : newlyEntitled.sub(newToVest);\n', '        uint256 pending = remainingPended.add(unreleasedNewly);\n', '\n', '        // Compute the vesting block (i.e. when the pended tokens to be all vested)\n', '        uint256 period = 0;\n', '        if (remainingPended == 0 || pending == 0) {\n', '            // newly entitled CVPs only or nothing remain pended\n', '            period = cvpVestingPeriodInBlocks;\n', '        } else {\n', '            // "old" CVPs and, perhaps, "new" CVPs are pending - the weighted average applied\n', '            age = _user.vestingBlock - _user.lastUpdateBlock;\n', '            period = (\n', '                (remainingPended.mul(age))\n', '                .add(unreleasedNewly.mul(cvpVestingPeriodInBlocks))\n', '            ).div(pending);\n', '        }\n', '        _user.vestingBlock = _user.lastUpdateBlock + (\n', '            cvpVestingPeriodInBlocks > uint32(period) ? uint32(period) : cvpVestingPeriodInBlocks\n', '        );\n', '\n', '        return (newlyEntitled, newlyVested);\n', '    }\n', '\n', '    function _computePoolReward(Pool memory _pool)\n', '    internal view returns (uint256 poolCvpReward)\n', '    {\n', '        poolCvpReward = 0;\n', '        uint32 blockNum = _currBlock();\n', '        if (blockNum > _pool.lastUpdateBlock) {\n', "            uint256 multiplier = uint256(blockNum - _pool.lastUpdateBlock); // can't overflow\n", '            _pool.lastUpdateBlock = blockNum;\n', '\n', '            uint256 lptBalance = _pool.lpToken.balanceOf(address(this));\n', '            if (lptBalance != 0) {\n', '                poolCvpReward = multiplier\n', '                    .mul(uint256(cvpPerBlock))\n', '                    .mul(uint256(_pool.allocPoint))\n', '                    .div(totalAllocPoint);\n', '\n', '                _pool.accCvpPerLpt = _pool.accCvpPerLpt.add(poolCvpReward.mul(SCALE).div(lptBalance));\n', '            }\n', '        }\n', '    }\n', '\n', '    function _computeUserVotes(uint192 userData, uint192 sharedData)\n', '    internal override pure returns (uint96 votes)\n', '    {\n', '        (uint96 ownCvp, uint96 pooledCvpShare) = _unpackData(userData);\n', '        (uint96 totalPooledCvp, ) = _unpackData(sharedData);\n', '\n', '        if (pooledCvpShare == 0) {\n', '            votes = ownCvp;\n', '        } else {\n', '            uint256 pooledCvp = uint256(pooledCvpShare).mul(totalPooledCvp).div(SCALE);\n', '            votes = ownCvp.add(SafeMath96.fromUint(pooledCvp, "VLPMining::_computeVotes"));\n', '        }\n', '    }\n', '\n', '    function _computeCvpToEntitle(uint256 userLpt, uint96 userCvpAdjust, uint256 poolAccCvpPerLpt)\n', '    private pure returns (uint96)\n', '    {\n', '        return userLpt == 0 ? 0 : (\n', '            SafeMath96.fromUint(userLpt.mul(poolAccCvpPerLpt).div(SCALE), "VLPMining::computeCvp:1")\n', '                .sub(userCvpAdjust, "VLPMining::computeCvp:2")\n', '        );\n', '    }\n', '\n', '    function _computeCvpAdjustment(uint256 lptAmount, uint256 accCvpPerLpt)\n', '    private pure returns (uint96)\n', '    {\n', '        return SafeMath96.fromUint(\n', '            lptAmount.mul(accCvpPerLpt).div(SCALE),\n', '            "VLPMining::_computeCvpAdj"\n', '        );\n', '    }\n', '\n', '    function _validatePoolId(uint256 pid) private view {\n', '        require(pid < pools.length, "VLPMining: invalid pool id");\n', '    }\n', '\n', '    function _currBlock() private view returns (uint32) {\n', '        return SafeMath32.fromUint(block.number, "VLPMining::_currBlock:overflow");\n', '    }\n', '}']