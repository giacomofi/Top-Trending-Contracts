['pragma solidity ^0.6.8;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n', '// Subject to the MIT license.\n', '/**\n', ' * @dev String operations.\n', ' */\n', 'library Strings {\n', '    /**\n', '     * @dev Converts a `uint256` to its ASCII `string` representation.\n', '     */\n', '    function toString(uint256 value) internal pure returns (string memory) {\n', "        // Inspired by OraclizeAPI's implementation - MIT licence\n", '        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n', '\n', '        if (value == 0) {\n', '            return "0";\n', '        }\n', '        uint256 temp = value;\n', '        uint256 digits;\n', '        while (temp != 0) {\n', '            digits++;\n', '            temp /= 10;\n', '        }\n', '        bytes memory buffer = new bytes(digits);\n', '        uint256 index = digits - 1;\n', '        temp = value;\n', '        while (temp != 0) {\n', '            buffer[index--] = byte(uint8(48 + temp % 10));\n', '            temp /= 10;\n', '        }\n', '        return string(buffer);\n', '    }\n', '}\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, errorMessage);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot underflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction underflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot underflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, errorMessage);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers.\n', '     * Reverts on division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers.\n', '     * Reverts with custom message on division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '/**\n', ' * @title ERC 20 Token Standard Interface\n', ' *  https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface EIP20Interface {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    function transfer(address dst, uint256 amount) external returns (bool success);\n', '\n', '    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool success);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 amount);\n', '    event Approval(address indexed owner, address indexed spender, uint256 amount);\n', '}\n', ' /*\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n', '     * by `operator` from `from`, this function is called.\n', '     *\n', '     * It must return its Solidity selector to confirm the token transfer.\n', '     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n', '     *\n', '     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n', '}\n', 'contract CallOption {\n', '  using SafeMath for uint256;\n', '  using Strings for uint256;\n', '  using Address for address;\n', '\n', '  struct PremiumInfo {\n', '    address premiumToken;\n', '    uint premiumAmt;\n', '    bool premiumRedeemed;\n', '    uint premiumPlatformFee;\n', '    uint sellerPremium;\n', '  }\n', '\n', '  struct UnderlyingInfo {\n', '    address underlyingCurrency;\n', '    uint underlyingAmt;\n', '    bool redeemed;\n', '    bool isCall;\n', '  }\n', '\n', '  struct Option {\n', '    // Proposal high level\n', '    uint proposalExpiresAt;\n', '    address seller;\n', '    address buyer;\n', '    \n', '    // Proposal premium\n', '    PremiumInfo premiumInfo;\n', '    \n', '    // Underlying\n', '    UnderlyingInfo underlyingInfo;\n', '\n', '    // Strike price\n', '    address strikeCurrency;\n', '    uint strikeAmt;\n', '  \n', '    // Acceptance state\n', '    bool sellerAccepted;\n', '    bool buyerAccepted;\n', '\n', '    // Option \n', '    uint optionExpiresAt;\n', '    bool cancelled;\n', '    bool executed;\n', '  }\n', '\n', '  event UnderlyingDeposited(uint indexed optionUID, address seller, address token, uint amount);  \n', '  event PremiumDeposited(uint indexed optionUID, address buyer, address token, uint amount);  \n', '  event SellerAccepted(uint indexed optionUID, address seller);\n', '  event BuyerAccepted(uint indexed optionUID, address buyer);\n', '  event BuyerCancelled(uint indexed optionUID, address buyer);\n', '  event SellerCancelled(uint indexed optionUID, address seller);\n', '  event BuyerPremiumRefunded(uint indexed optionUID, address buyer);\n', '  event SellerUnderlyingRedeemed(uint indexed optionUID, address seller);\n', '  event SellerRedeemedPremium(uint indexed optionUID, address seller);\n', '  event TransferSeller(uint indexed optionUID, address oldSeller, address newSeller);\n', '  \n', '  event OptionExecuted(uint indexed optionUID);\n', '\n', '    /// @dev This emits when ownership of any NFT changes by any mechanism.\n', '    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n', '    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n', '    ///  may be created and assigned without emitting Transfer. At the time of\n', '    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '\n', '    /// @dev This emits when the approved address for an NFT is changed or\n', '    ///  reaffirmed. The zero address indicates there is no approved address.\n', '    ///  When a Transfer event emits, this also indicates that the approved\n', '    ///  address for that NFT (if any) is reset to none.\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '\n', '    /// @dev This emits when an operator is enabled or disabled for an owner.\n', '    ///  The operator can manage all NFTs of the owner.\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  // Maps user to the IDS of their associated options\n', '  mapping(address => uint[]) public userOptions;\n', '  \n', '  // Stores the state of all the options\n', '  Option[] public options;\n', '\n', '  // Fee taken out of the premiums collected\n', '  uint public platformFee = 5; // 0.005 \n', ' \n', '  // Address which collected fees are directed to\n', '  address public feeBeneficiaryAddress;\n', '\n', '  // Fees that are withdrawable\n', '  mapping(address => uint) public platformFeeBalances;\n', '\n', '  // Mapping from token ID to approved address\n', '  mapping (uint256 => address) private _tokenApprovals;\n', '\n', '  // Mapping from owner to operator approvals\n', '  mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '\n', '  string public constant symbol = "OPTION-SWAP";\n', '  string public constant name = "ERC-20 Option (OptionSwap.finance)";\n', '\n', '  address public admin;\n', '\n', '  constructor() public {\n', '    admin = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @notice Propose a new option with the following criteria \n', '   */\n', '  function propose(address seller, address buyer, uint proposalExpiresAt, uint optionExpiresAt, \n', '                        address premiumToken, uint premiumAmt, \n', '                        address underlyingCurrency, uint underlyingAmt, \n', '                        address strikeCurrency, uint strikeAmt, bool isCall) public {\n', '    \n', '    require((seller == msg.sender) || (buyer == msg.sender), "Must be either the seller or buyer");\n', '\n', '    require(proposalExpiresAt <= optionExpiresAt, "Option cannot expire before proposal");\n', '\n', '    // Compute the seller premium to be earned and associated platform fee from the premium\n', '    (uint sellerPremium, uint platformFeePremium) = _computePremiumSplit(premiumAmt, EIP20Interface(premiumToken).decimals());\n', '    \n', '    // Add the option to list of options\n', '    options.push(Option(\n', '      { \n', '          seller: seller, \n', '          buyer: buyer, \n', '          proposalExpiresAt: proposalExpiresAt, \n', '          premiumInfo: PremiumInfo({ \n', '            premiumToken: premiumToken, \n', '            premiumAmt: premiumAmt, \n', '            premiumRedeemed: false,\n', '            premiumPlatformFee: platformFeePremium,\n', '            sellerPremium: sellerPremium}),\n', '          underlyingInfo: UnderlyingInfo({ \n', '            underlyingCurrency: underlyingCurrency, \n', '            underlyingAmt: underlyingAmt, \n', '            isCall: isCall,\n', '            redeemed: false }),\n', '          strikeCurrency: strikeCurrency,\n', '          strikeAmt: strikeAmt,\n', '          optionExpiresAt: optionExpiresAt,\n', '          cancelled: false,\n', '          executed: false,\n', '          sellerAccepted: false,\n', '          buyerAccepted: false\n', '      }));\n', '    \n', '    // If sender is the seller, transfer underlying and update tracking state\n', '    if (msg.sender == seller) {\n', '      _acceptSeller(options.length - 1);\n', '    }\n', '    \n', '    // If sender is the buyer, transfer premium and update tracking state \n', '    if (msg.sender == buyer) {\n', '      _acceptBuyer(options.length - 1);\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * @notice Compute how much of the premium goes to the seller and how much to the platform \n', '   */\n', '  function _computePremiumSplit(uint premium, uint decimals) public view returns(uint, uint) {\n', '    require(decimals <= 78, "_computePremiumSplit(): too many decimals will overflow"); \n', '    require(decimals >= 3, "_computePremiumSplit(): too few decimals will underflow"); \n', '    uint platformFeeDoubleScaled = premium.mul(platformFee * (10 ** (decimals - 3)));\n', '    \n', '    uint platformFeeCollected = platformFeeDoubleScaled.div(10 ** (decimals));\n', '\n', '    uint redeemable = premium.sub(platformFeeCollected);\n', '    return (redeemable, platformFeeCollected);\n', '  }\n', '\n', '  /**\n', '   * @notice Allows Seller to redeem their premium after the option has been accepted by the buyer \n', '   */\n', '  function redeemPremium(uint optionUID) public {\n', '    Option storage option = options[optionUID];\n', '    \n', '    // Can only redeem premium once\n', '    require(!option.premiumInfo.premiumRedeemed, "redeemPremium(): premium already redeemed");\n', '    \n', '    if(option.cancelled || proposalExpired(optionUID)){\n', '      bool isBuyer = option.buyer == msg.sender; \n', '      require(isBuyer, "redeemPremium(): only buyer can redeem when proposal expired");\n', '     \n', '      // Track premium redeemed \n', '      option.premiumInfo.premiumRedeemed = true; \n', '    \n', "      // Transfer buyer's premium back to themself \n", '      EIP20Interface token = EIP20Interface(option.premiumInfo.premiumToken);\n', '      bool success = token.transfer(option.buyer, option.premiumInfo.premiumAmt);\n', '      require(success, "redeemPremium(): premium transfer failed"); \n', '     \n', '      emit BuyerPremiumRefunded(optionUID, msg.sender);\n', '      return;\n', '    }\n', '    \n', '    // Only the seller may redeem the premium \n', '    bool isSeller = option.seller == msg.sender; \n', '    \n', '    require(isSeller, "redeemPremium(): only option seller can redeem");\n', '    \n', "    // Cannot redeem an option that hasn't been accepted  \n", '    require(option.buyerAccepted && option.sellerAccepted, "redeemPremium(): option hasn\'t been accepted");\n', '    \n', '    // Track premium redeemed \n', '    option.premiumInfo.premiumRedeemed = true; \n', '    \n', '    // Update platform fee balances to include their split of the premium \n', '    platformFeeBalances[option.premiumInfo.premiumToken] = platformFeeBalances[option.premiumInfo.premiumToken].add(option.premiumInfo.premiumPlatformFee);\n', '    \n', "    // Transfer seller's premium earned to themself \n", '    EIP20Interface token = EIP20Interface(option.premiumInfo.premiumToken);\n', '    bool success = token.transfer(option.seller, option.premiumInfo.sellerPremium);\n', '    require(success, "redeemPremium(): premium transfer failed"); \n', '  \n', '    emit SellerRedeemedPremium(optionUID, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice Status for whether time has expired for the option to be executed \n', '   */\n', '  function optionExpired(uint optionUID) public view returns(bool) {\n', '    Option memory option = options[optionUID];\n', '    if (option.optionExpiresAt > now) \n', '      return false;\n', '    else\n', '      return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Status for whether time has expired for the option proposal to be accepted \n', '   */\n', '  function proposalExpired(uint optionUID) public view returns (bool) {\n', '    Option memory option = options[optionUID];\n', '    if (option.sellerAccepted && option.buyerAccepted)\n', '      return false;\n', '    if (option.proposalExpiresAt > now) \n', '      return false;\n', '    else\n', '      return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Allow the seller to redeem their underlying if option goes unused (cancelled, proposal expired, option expired)\n', '   */\n', '  function redeemUnderlying(uint optionUID) public {\n', '    Option storage option = options[optionUID];\n', '    \n', '    // Must be seller to redeem underlying\n', '    bool isSeller = option.seller == msg.sender; \n', '    require(isSeller, "redeemUnderlying(): only seller may redeem");\n', '    \n', '    require(!option.underlyingInfo.redeemed, "redeemUnderlying(): redeemed, nothing remaining to redeem");\n', '    require(!option.executed, "redeemUnderlying(): executed, nothing to redeem");\n', '    require(option.cancelled || optionExpired(optionUID) || proposalExpired(optionUID), "redeemUnderlying(): must be cancelled or expired to redeem");\n', '\n', '    // Mark as redeemed to ensure only gets redeemed once \n', '    option.underlyingInfo.redeemed = true;\n', '   \n', '    emit SellerUnderlyingRedeemed(optionUID, msg.sender);\n', '\n', '    // Transfer underlying back to the seller\n', '    EIP20Interface token = EIP20Interface(option.underlyingInfo.underlyingCurrency);\n', '    bool success = token.transfer(option.seller, option.underlyingInfo.underlyingAmt);\n', '    require(success, "redeemUnderlying(): premium transfer failed"); \n', '  }\n', '\n', '  /**\n', '   * @notice Allows buyer to transfer ownership of option to another user \n', '   */\n', '  function transferSeller(uint optionUID, address newSeller) public {\n', '    Option storage option = options[optionUID];\n', '    \n', '    // Only the seller may transfer an option\n', '    bool isSeller = option.seller == msg.sender; \n', '    require(isSeller, "transferSeller(): must be seller");\n', '    \n', '    // Update option buyer \n', '    option.seller = newSeller; \n', '    userOptions[newSeller].push(optionUID);\n', '    \n', '    emit TransferSeller(optionUID, msg.sender, newSeller);\n', '  }\n', '\n', '  /**\n', '   * @notice Buyer supplies strike amount from strike currency to receive underlying \n', '   */\n', '  function execute(uint optionUID) public {\n', '    Option storage option = options[optionUID];\n', '    \n', '    // Only the buyer may execute the option\n', '    bool isBuyer = option.buyer == msg.sender; \n', '    require(isBuyer, "execute(): Must be option owner");\n', '    \n', '    // Nothing to execute w/o both accepting the option\n', '    require(option.buyerAccepted && option.sellerAccepted, "execute(): must be a fully accepted option");\n', '    \n', '    // Cannot execute once expired\n', '    require(!optionExpired(optionUID), "execute(): option expired");\n', '    \n', '    // Cannot execute more than once\n', '    require(!option.executed, "execute(): already executed");\n', '\n', '    // Mark as executed\n', '    option.executed = true;\n', '     \n', '    // 1st Transfer the strike amount from the option buyer\n', '    EIP20Interface token = EIP20Interface(option.strikeCurrency);\n', '    bool success = token.transferFrom(option.buyer, address(this), option.strikeAmt);\n', '    require(success, "execute(): strike transfer failed"); \n', '    \n', '    // 2nd Transfer the strike amount to the option seller \n', '    success = token.transfer(option.seller, option.strikeAmt);\n', '    require(success, "execute(): strike transfer failed"); \n', '    \n', '    // 3rd Transfer the underlying to the option buyer\n', '    EIP20Interface tokenUnderlying = EIP20Interface(option.underlyingInfo.underlyingCurrency);\n', '    success = tokenUnderlying.transfer(option.buyer, option.underlyingInfo.underlyingAmt);\n', '    \n', '    emit OptionExecuted(optionUID);\n', '\n', '    require(success, "execute(): underlying transfer failed"); \n', '  }\n', '\n', '  /**\n', '   * @notice If buyer or seller sets status fields and transfers either the premium or underlying  \n', '   */\n', '  function accept(uint optionUID) public {\n', '    Option memory option = options[optionUID];\n', '    bool isSeller = option.seller == msg.sender || option.seller == address(0);\n', '    bool isBuyer = option.buyer == msg.sender || option.buyer == address(0);\n', '    require(isSeller || isBuyer, "accept(): Must either buyer or seller");\n', '\n', '    if (isBuyer){ \n', '      _acceptBuyer(optionUID);\n', '    }\n', '    else if (isSeller) {\n', '      _acceptSeller(optionUID);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice If buyer or seller sets status fields and transfers either the premium or underlying  \n', '   */\n', '  function cancel(uint optionUID) public {\n', '    Option memory option = options[optionUID];\n', '    bool isSeller = option.seller == msg.sender; \n', '    bool isBuyer = option.buyer == msg.sender; \n', '    require(isSeller || isBuyer, "cancel(): only sellers and buyers can cancel"); \n', '    \n', '    if (isSeller) {\n', '      _cancelSeller(optionUID);\n', '    }\n', '    else if (isBuyer) {\n', '      _cancelBuyer(optionUID);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Seller calls cancel before buyer accepts, returns underlying \n', '   */\n', '  function _cancelSeller(uint optionUID) internal {\n', '    Option memory option = options[optionUID];\n', '    require(option.sellerAccepted, "_cancelSeller(): cannot cancel before accepting");\n', '    require(!option.buyerAccepted, "_cancelSeller(): already accepted");\n', '    require(!option.cancelled, "_cancelSeller(): already cancelled");\n', '    // Cancel the option\n', '    options[optionUID].cancelled = true;\n', '  \n', '    emit SellerCancelled(optionUID, msg.sender);\n', '    \n', '    // Redeem the underlying\n', '    redeemUnderlying(optionUID);\n', '  }\n', '\n', '  /**\n', '   * @notice Buyer calls cancel before buyer accepts, returns full premium no fees deducted \n', '   */\n', '  function _cancelBuyer(uint optionUID) internal {\n', '    Option memory option = options[optionUID];\n', '    require(option.buyerAccepted, "_cancelBuyer(): cannot cancel before accepting");\n', '    require(!option.sellerAccepted, "_cancelBuyer(): already accepted");\n', '    require(!option.cancelled, "already cancelled");\n', '    \n', '    // Cancel the option\n', '    options[optionUID].cancelled = true;\n', '    \n', '    emit BuyerCancelled(optionUID, msg.sender);\n', '    \n', '    // Return the buyers premium  \n', '    redeemPremium(optionUID);\n', '  }\n', '\n', '  /**\n', '   * @notice Seller accepts option, transfers underlying amount, if buyer paid premium redeem it \n', '   */\n', '  function _acceptSeller(uint optionUID) internal {\n', '    Option storage option = options[optionUID];\n', '    require(!option.sellerAccepted, "seller already accepted");\n', '    \n', '    // Mark as seller accepted\n', '    option.sellerAccepted = true;\n', '    \n', '    // transfer specified tokens\n', '    EIP20Interface token = EIP20Interface(option.underlyingInfo.underlyingCurrency);\n', '    bool success = token.transferFrom(msg.sender, address(this), option.underlyingInfo.underlyingAmt);\n', '    require(success, "_acceptSeller(): Failed to transfer underlying");\n', '\n', '    // Emit event\n', '    emit UnderlyingDeposited(optionUID, msg.sender, option.underlyingInfo.underlyingCurrency, option.underlyingInfo.underlyingAmt);\n', '\n', '    // If option seller was universal, set it to the sender\n', '    if (option.seller == address(0)) {\n', '      options[optionUID].seller = msg.sender;\n', '    }\n', '    userOptions[msg.sender].push(optionUID);\n', '\n', '    // If buyer already accepted, redeem premium\n', '    if (option.buyerAccepted) {\n', '      redeemPremium(optionUID);\n', '    }\n', '\n', '    emit SellerAccepted(optionUID, msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice Buyer accepts option, transfers premium \n', '   */\n', '  function _acceptBuyer(uint optionUID) internal {\n', '    Option storage option = options[optionUID];\n', '    require(!option.buyerAccepted, "buyer already accepted");\n', '    \n', '    // Mark as buyer accepted\n', '    option.buyerAccepted = true;\n', '   \n', '    // transfer specified premium \n', '    EIP20Interface token = EIP20Interface(option.premiumInfo.premiumToken);\n', '    bool success = token.transferFrom(msg.sender, address(this), option.premiumInfo.premiumAmt);\n', '    require(success, "Failed to transfer premium");\n', '    \n', '    // If option buyer was universal, set it to the sender\n', '    if (option.buyer == address(0)) {\n', '      options[optionUID].buyer = msg.sender;\n', '    }\n', '      \n', '    userOptions[msg.sender].push(optionUID);\n', '    \n', '    emit PremiumDeposited(optionUID, msg.sender, option.premiumInfo.premiumToken, option.premiumInfo.premiumAmt);\n', '    emit BuyerAccepted(optionUID, msg.sender);\n', '  }\n', '  \n', '  //------------------------\n', '  //  Status functions\n', '  //------------------------\n', '  \n', '  function canAccept(uint optionUID) public view returns(bool) {\n', '    Option memory option = options[optionUID];\n', '    return (!option.buyerAccepted || !option.sellerAccepted) && !proposalExpired(optionUID); \n', '  }\n', '\n', '  function canCancel(uint optionUID) public view returns(bool) {\n', '    Option memory option = options[optionUID];\n', '    return (!option.buyerAccepted || !option.sellerAccepted) && !proposalExpired(optionUID); \n', '  }\n', '\n', '  function canExecute(uint optionUID) public view returns(bool) {\n', '    Option memory option = options[optionUID];\n', '    return !option.executed && (option.buyerAccepted && option.sellerAccepted) && !optionExpired(optionUID); \n', '  }\n', '  \n', '  function canRedeemPremium(uint optionUID) public view returns(bool) {\n', '    Option memory option = options[optionUID];\n', '    return (option.buyerAccepted && option.sellerAccepted) && !option.premiumInfo.premiumRedeemed; \n', '  }\n', '  \n', '  function canRedeemUnderlying(uint optionUID) public view returns(bool) {\n', '    Option memory option = options[optionUID];\n', '    if (option.cancelled || optionExpired(optionUID) || proposalExpired(optionUID))\n', '      return !option.underlyingInfo.redeemed && !option.executed;\n', '    else\n', '      return false;\n', '  }\n', '  \n', '  //------------------------\n', '  // NFT Functions\n', '  //------------------------\n', '    function balanceOf(address _owner) external view returns (uint256) {\n', '      uint count = 0;\n', '      for(uint i; i< options.length; i++) {\n', '        if(options[i].seller == _owner || options[i].buyer == _owner) {\n', '          if(options[i].sellerAccepted && options[i].buyerAccepted) {\n', '            count += 1;\n', '          }\n', '        }\n', '      }\n', '      return count;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '      uint count = 0;\n', '      for(uint i; i< options.length; i++) {\n', '        if(options[i].sellerAccepted && options[i].buyerAccepted) {\n', '          count += 1;\n', '        }\n', '      }\n', '      return count;\n', '    }\n', '\n', '    function baseTokenURI() public view returns (string memory) {\n', '      return "https://metadata.optionswap.finance/";\n', '    }\n', '\n', '    function tokenURI(uint256 tokenId) external view returns (string memory) {\n', '        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n', '\n', '        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n', '        return string(abi.encodePacked(baseTokenURI(), tokenId.toString()));\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns (address) {\n', '      Option memory option = options[_tokenId];\n', '      return option.buyer;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-approve}.\n', '     */\n', '    function approve(address to, uint256 tokenId) public {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner, "ERC721: approval to current owner");\n', '\n', '        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\n', '            "ERC721: approve caller is not owner nor approved for all"\n', '        );\n', '\n', '        _approve(to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-getApproved}.\n', '     */\n', '    function getApproved(uint256 tokenId) public view returns (address) {\n', '        require(_exists(tokenId), "ERC721: approved query for nonexistent token");\n', '\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-setApprovalForAll}.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) public {\n', '        require(operator != msg.sender, "ERC721: approve to caller");\n', '\n', '        _operatorApprovals[msg.sender][operator] = approved;\n', '        emit ApprovalForAll(msg.sender, operator, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-isApprovedForAll}.\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-transferFrom}.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', '        //solhint-disable-next-line max-line-length\n', '        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");\n', '\n', '        _transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n', '        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");\n', '        _safeTransfer(from, to, tokenId, _data);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n', '     *\n', '     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n', '     * implement alternative mechanisms to perform token transfer, such as signature-based.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {\n', '        _transfer(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether `tokenId` exists.\n', '     *\n', '     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n', '     *\n', '     * Tokens start existing when they are minted (`_mint`),\n', '     * and stop existing when they are burned (`_burn`).\n', '     */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        return options[tokenId].buyer != address(0); \n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        require(_exists(tokenId), "ERC721: operator query for nonexistent token");\n', '        address owner = ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '  \n', '     /**\n', '     * @dev Transfers `tokenId` from `from` to `to`.\n', '     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _transfer(address from, address to, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");\n', '        require(to != address(0), "ERC721: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(from, to, tokenId);\n', '\n', '        // Clear approvals from the previous owner\n', '        _approve(address(0), tokenId);\n', '\n', '        Option storage option = options[tokenId];\n', '        option.buyer = to;\n', '        userOptions[to].push(tokenId);\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '     /**\n', '     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n', '     * The call is not executed if the target address is not a contract.\n', '     *\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        private returns (bool)\n', '    {\n', '        bytes4 _ERC721_RECEIVED = 0x150b7a02;\n', '        if (to.isContract()) {\n', '            return true;\n', '        }\n', '        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n', '            IERC721Receiver(to).onERC721Received.selector,\n', '            msg.sender,\n', '            from,\n', '            tokenId,\n', '            _data\n', '        ), "ERC721: transfer to non ERC721Receiver implementer");\n', '        bytes4 retval = abi.decode(returndata, (bytes4));\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '\n', '    function _approve(address to, uint256 tokenId) private {\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(ownerOf(tokenId), to, tokenId);\n', '    }\n', '\n', '  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}\n', '\n', '  //------------------------\n', '  //  Lens functions\n', '  //------------------------\n', ' \n', '  // Returns the options data for a given account\n', '  function optionsForAccount(address account) public view returns(uint[] memory) {\n', '    if (userOptions[account].length == 0) {\n', '      uint[] memory blank;\n', '      return blank;\n', '    }\n', '    return userOptions[account];\n', '  }\n', '  \n', '  // Returns all the options \n', '  function getOptions() public view returns(Option[] memory) {\n', '    return options;\n', '  }\n', '\n', '\n', '  //------------------------\n', '  //  Admin functions\n', '  //------------------------\n', '  \n', '  // Updates the platform fee, only affects new options created\n', '  function __updateFee(uint newPlatformFee) public {\n', '    require(msg.sender == admin, "__updateFee(): must be admin");\n', '    platformFee = newPlatformFee;\n', '  }\n', '\n', '  function __redeemPlatformFee(uint amount, address tokenAddress) public {\n', '    require(msg.sender == admin, "__redeemPlatformFee(): must be admin");\n', '    require(platformFeeBalances[tokenAddress] >= amount, "__redeemPlatformFee(): requested redemption too large");\n', '\n', '    // Update total balance\n', '    platformFeeBalances[tokenAddress] = platformFeeBalances[tokenAddress].sub(amount);\n', '    \n', '    // Perform transfer\n', '    EIP20Interface token = EIP20Interface(tokenAddress);\n', '    bool success = token.transfer(msg.sender, amount);\n', '    require(success, "Failed to transfer premium");\n', '  }\n', '\n', '\n', '}']