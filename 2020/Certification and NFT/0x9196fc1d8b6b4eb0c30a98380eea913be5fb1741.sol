['/*\n', '\n', '\n', '  _  ___                      __   _   _            _    _ _ _ _ \n', ' | |/ (_)                    / _| | | | |          | |  | (_) | |\n', " | ' / _ _ __   __ _    ___ | |_  | |_| |__   ___  | |__| |_| | |\n", " |  < | | '_ \\ / _` |  / _ \\|  _| | __| '_ \\ / _ \\ |  __  | | | |\n", ' | . \\| | | | | (_| | | (_) | |   | |_| | | |  __/ | |  | | | | |\n', ' |_|\\_\\_|_| |_|\\__, |  \\___/|_|    \\__|_| |_|\\___| |_|  |_|_|_|_|\n', '                __/ |                                            \n', '               |___/                                             \n', '\n', 'Play game at https://lailune.github.io/KingOfTheHill\n', 'Original repo: https://github.com/lailune/KingOfTheHill\n', 'by @lailune\n', '\n', "Don't forget MetaMask!\n", '***************************\n', 'HeyHo! \n', '\n', 'Who Wants to Become King of the Hill? Everybody wants!\n', '\n', 'What to get the king of the hill? All the riches!\n', '\n', "Become the king of the mountain and claim all the riches saved on this contract! Trust me, it's worth it!\n", '\n', "Who will be in charge and take everything, and who will lose? It's up to you to decide. Take action!\n", '\n', '*/\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract KingOfTheHill{\n', '    using SafeMath for uint256;\n', '\n', "    //It's me\n", '    address payable private _owner;\n', '\n', '    //Last income block\n', '    uint256 public lastKingBlock;\n', '\n', '    //Current King of Hill\n', '    address payable public currentKing;\n', '\n', '    //Current balance\n', '    uint256 public currentBalance = 0;\n', '\n', '    //Min participant bid (25 cent)\n', '    uint256 public  minBid = 725000 gwei;\n', '\n', '    //Min Bid incrase for every bid\n', '    uint public constant BID_INCRASE = 29000 gwei;\n', '\n', '    //Revenue for me :)\n', '    uint public constant OWNER_REVENUE_PERCENT = 5;\n', '\n', '    //Wait for 6000 block to claim all money on game start\n', '    uint public constant START_BLOCK_DISTANCE = 6000;\n', '\n', '\n', '    //Wait for 5 blocks in game barely finished\n', '    uint public constant MIN_BLOCK_DISTANCE = 5;\n', '\n', '    //Current block distance\n', '    uint public blockDistance = START_BLOCK_DISTANCE;\n', '\n', '\n', '\n', '    //We have a new king! All glory to new king!\n', '    event NewKing(address indexed user, uint256 amount);\n', '\n', '    //We have a winner\n', '    event Winner(address indexed user, uint256 amount);\n', '\n', '    /**\n', '     * Were we go\n', '     */\n', '    constructor () public payable {\n', '        _owner = msg.sender;\n', '        lastKingBlock = block.number;\n', '    }\n', '\n', '    /**\n', '     * Place a bid for game\n', '     */\n', '    function placeABid() public payable{\n', '      uint256  income = msg.value;\n', '\n', '\n', '      require(income >= minBid, "Bid should be greater than min bid");\n', '\n', '      //Calculate owner revenue\n', '      uint256 ownerRevenue = income.mul(OWNER_REVENUE_PERCENT).div(100);\n', '\n', '      //Calculate real income value\n', '      uint256 realIncome = income.sub(ownerRevenue);\n', '\n', '      //Check is ok\n', '      require(ownerRevenue != 0 && realIncome !=0,"Income too small");\n', '\n', '\n', '      //Change current contract balance\n', '      currentBalance = currentBalance.add(realIncome);\n', '\n', '      //Save all changes\n', '      currentKing = msg.sender;\n', '      lastKingBlock = block.number;\n', '\n', '      //Change block distance\n', '      blockDistance = blockDistance - 1;\n', '      if(blockDistance < MIN_BLOCK_DISTANCE){\n', '          blockDistance = MIN_BLOCK_DISTANCE;\n', '      }\n', '\n', '      //Change minimal bid\n', '      minBid = minBid.add(BID_INCRASE);\n', '\n', '\n', '      //Send owner revenue\n', '      _owner.transfer(ownerRevenue);\n', '\n', '      //We have a new King!\n', '      emit NewKing(msg.sender, realIncome);\n', '    }\n', '\n', '    receive() external payable {\n', '        placeABid();\n', '    }\n', '\n', '    /**\n', '     * Claim the revenue\n', '     */\n', '    function claim() public payable {\n', '\n', '        //Check King is a king\n', '        require(currentKing == msg.sender, "You are not king");\n', '\n', '        //Check balance\n', '        require(currentBalance > 0, "The treasury is empty");\n', '\n', '        //Check wait\n', '        require(block.number - lastKingBlock >= blockDistance, "You can pick up the reward only after waiting for the minimum time");\n', '\n', '\n', '        //Transfer money to winner\n', '        currentKing.transfer(currentBalance);\n', '\n', '        //Emit winner event\n', '        emit Winner(msg.sender, currentBalance);\n', '\n', '\n', '        //Reset game\n', '        currentBalance = 0;\n', '        currentKing = address(0x0);\n', '        lastKingBlock = block.number;\n', '        blockDistance = START_BLOCK_DISTANCE;\n', '        minBid = 725000 gwei;\n', '    }\n', '\n', '    /**\n', '     * How many blocks remain for claim\n', '     */\n', '    function blocksRemain() public view returns (uint){\n', '\n', '        if(block.number - lastKingBlock > blockDistance){\n', '            return 0;\n', '        }\n', '\n', '        return blockDistance - (block.number - lastKingBlock);\n', '    }\n', '\n', '}']