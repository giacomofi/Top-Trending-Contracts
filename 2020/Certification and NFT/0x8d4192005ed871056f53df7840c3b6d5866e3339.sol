['pragma solidity ^0.5.16;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '          return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract LockIdGen {\n', '\n', '    uint256 public requestCount;\n', '\n', '    constructor() public {\n', '        requestCount = 0;\n', '    }\n', '\n', '    function generateLockId() internal returns (bytes32 lockId) {\n', '        return keccak256(abi.encodePacked(blockhash(block.number-1), address(this), ++requestCount));\n', '    }\n', '}\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * This test is non-exhaustive, and there may be false-negatives: during the\n', "     * execution of a contract's constructor, its address will be reported as\n", '     * not containing a contract.\n', '     *\n', '     * IMPORTANT: It is unsafe to assume that an address for which this\n', '     * function returns false is an externally-owned account (EOA) and not a\n', '     * contract.\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(StandardToken token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(StandardToken token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(StandardToken token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(StandardToken token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(StandardToken token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(ERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'contract ManagerUpgradeable is LockIdGen {\n', '\n', '    struct ChangeRequest {\n', '        address proposedNew;\n', '        address proposedClear;\n', '    }\n', '\n', '    // address public custodian;\n', '    mapping (address => address) public managers;\n', '\n', '    mapping (bytes32 => ChangeRequest) public changeReqs;\n', '\n', '    uint256     public    mancount  ;\n', '\n', '    // CONSTRUCTOR\n', '    constructor(\n', '         address  [] memory _mans\n', '    )\n', '      LockIdGen()\n', '      public\n', '    {\n', '        uint256 numMans = _mans.length;\n', '        for (uint256 i = 0; i < numMans; i++) {\n', '          address pto = _mans[i];\n', '          require(pto != address(0));\n', '          managers[pto] = pto;\n', '        }\n', '        mancount = 0;\n', '    }\n', '\n', '    modifier onlyManager {\n', '        require(msg.sender == managers[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    // for manager change\n', '    function requestChange(address _new,address _clear) public onlyManager returns (bytes32 lockId) {\n', '        require( _clear != address(0) || _new != address(0) );\n', '\n', '        require( _clear == address(0) || managers[_clear] == _clear);\n', '\n', '        lockId = generateLockId();\n', '\n', '        changeReqs[lockId] = ChangeRequest({\n', '            proposedNew: _new,\n', '            proposedClear: _clear\n', '        });\n', '\n', '        emit ChangeRequested(lockId, msg.sender, _new,_clear);\n', '    }\n', '\n', '    event ChangeRequested(\n', '        bytes32 _lockId,\n', '        address _msgSender,\n', '        address _new,\n', '        address _clear\n', '    );\n', '\n', '   function confirmChange(bytes32 _lockId) public onlyManager {\n', '        ChangeRequest storage changeRequest = changeReqs[_lockId];\n', '        require( changeRequest.proposedNew != address(0) || changeRequest.proposedClear != address(0));\n', '\n', '        if(changeRequest.proposedNew != address(0))\n', '        {\n', '            managers[changeRequest.proposedNew] = changeRequest.proposedNew;\n', '            mancount = mancount + 1;\n', '        }\n', '\n', '        if(changeRequest.proposedClear != address(0))\n', '        {\n', '            delete managers[changeRequest.proposedClear];\n', '            mancount = mancount - 1;\n', '        }\n', '\n', '        delete changeReqs[_lockId];\n', '\n', '        emit ChangeConfirmed(_lockId, changeRequest.proposedNew,changeRequest.proposedClear);\n', '    }\n', '    event ChangeConfirmed(bytes32 _lockId, address _newCustodian, address _clearCustodian);\n', '\n', '    function sweepChange(bytes32 _lockId) public onlyManager {\n', '        ChangeRequest storage changeRequest=changeReqs[_lockId];\n', '        require((changeRequest.proposedNew != address(0) || changeRequest.proposedClear != address(0) ));\n', '        delete changeReqs[_lockId];\n', '        emit ChangeSweep(_lockId, msg.sender);\n', '    }\n', '    event ChangeSweep(bytes32 _lockId, address _sender);\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '    // events\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // public functions\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address addr) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    // events\n', '    event Approval(address indexed owner, address indexed agent, uint256 value);\n', '\n', '    // public functions\n', '    function allowance(address owner, address agent) public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address agent, uint256 value) public returns (bool);\n', '\n', '}\n', '\n', 'contract DFK is ManagerUpgradeable {\n', '            \n', '    //liquidity +\n', '    function stakingDeposit(uint256 value) public payable returns (bool);\n', '\n', '    //profit +\n', '    function profit2Staking(uint256 value)public  returns (bool success);\n', '    \n', '\t\n', '    function withdrawProfit(address to)public  returns (bool success);\n', '    \n', '\t\n', '    function withdrawStaking(address to,uint256 value)public  returns (bool success);\n', '    \n', '\t\n', '    function withdrawAll(address to)public  returns (bool success);\n', '\n', '    \n', '\t\n', '    function totalMiners() public view returns (uint256);\n', '\n', '    function totalStaking() public view returns (uint256);\n', '\n', '\t\n', '    function poolBalance() public view returns (uint256);\n', '\n', '\t\n', '    function minedBalance() public view returns (uint256);\n', '\n', '\t\n', '    function stakingBalance(address miner) public view returns (uint256);\n', '\n', '\n', '    function profitBalance(address miner) public view returns (uint256);\n', '\n', '    \n', '    \n', '    function pauseStaking()public  returns (bool success);\n', '    \n', '    \n', '    function resumeStaking()public  returns (bool success);\n', '\n', '}\n', '\n', 'contract DFKProxy is DFK {\n', '            \n', '    DFK  public impl;\n', '\n', '\n', '    constructor(address [] memory _mans) public ManagerUpgradeable(_mans){\n', '        impl = DFK(0x0);\n', '    }\n', '\n', '\n', '    function requestImplChange(address _newDFK) public onlyManager returns (bytes32 ) {\n', '        require(_newDFK != address(0));\n', '        impl = DFK(_newDFK);\n', '    }\n', '\n', '\n', '\n', '    function stakingDeposit(uint256 value) public payable returns (bool){\n', '        return impl.stakingDeposit(value);\n', '    }\n', '\n', '\n', '\n', '    function profit2Staking(uint256 value)public  returns (bool success){\n', '        return impl.profit2Staking(value);\n', '    }\n', '\n', '\n', '    function withdrawProfit(address to)public  returns (bool success){\n', '        return impl.withdrawProfit(to);\n', '    }\n', '\n', '\n', '    function withdrawStaking(address to,uint256 value)public  returns (bool success){\n', '        return impl.withdrawStaking(to,value);\n', '    }\n', '    \n', '    \n', '    function withdrawAll(address to)public  returns (bool success){\n', '        return impl.withdrawAll(to);\n', '    }\n', '    \n', '\n', '\n', '    function totalMiners() public view returns (uint256)\n', '    {\n', '        return impl.totalMiners();\n', '    }\n', '\n', '\n', '    function totalStaking() public view returns (uint256)\n', '    {\n', '        return impl.totalStaking();\n', '    }\n', '\n', '\n', '    function poolBalance() public view returns (uint256)\n', '    {\n', '        return impl.poolBalance();\n', '    }\n', '\n', '\n', '    function minedBalance() public view returns (uint256)\n', '    {\n', '        return impl.minedBalance();\n', '    }\n', '\n', '\n', '    function stakingBalance(address miner) public view returns (uint256)\n', '    {\n', '        return impl.stakingBalance(miner);\n', '    }\n', '\n', '\n', '\n', '    function profitBalance(address miner) public view returns (uint256)\n', '    {\n', '        return impl.profitBalance(miner);\n', '    }\n', '\n', '\n', '\n', '    function pauseStaking()public  returns (bool success)\n', '    {\n', '        return impl.pauseStaking();\n', '    }\n', '    \n', '    \n', '    function resumeStaking()public  returns (bool success)\n', '    {\n', '        return impl.resumeStaking();\n', '    }\n', '\n', '}\n', '\n', 'contract DFKImplement is DFK {\n', '\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for StandardToken;\n', '\n', '    int public status; \n', '\n', '    struct StakingLog{\n', '        uint256   staking_time;\n', '        uint256   profit_time;\n', '        uint256   staking_value;\n', '        uint256   unstaking_value; \n', '    }\n', '    mapping(address => StakingLog) public stakings;\n', '\n', '    uint256  public cleanup_time;\n', '\n', '    uint256  public profit_period;\n', '\n', '    uint256  public period_bonus; \n', '\n', '    mapping(address => uint256) public balanceProfit;\n', '    mapping(address => uint256) public balanceStaking;\n', '\n', '    StandardToken    public     dfkToken;\n', '\n', '    uint256 public  _totalMiners;\n', '    uint256 public  _totalStaking; \n', '    uint256 public  totalProfit;\n', '\n', '    uint256 public  minePoolBalance; \n', '\n', '    modifier onStaking {\n', '        require(status == 1,"please start minner");\n', '        _;\n', '    }\n', '    event ProfitLog(\n', '        address indexed from,\n', '        uint256 profit_time, \n', '        uint256 staking_value,\n', '        uint256 unstaking_value,\n', '        uint256 profit_times, \n', '        uint256 profit\n', '    );\n', '\n', '    constructor(address _dfkToken,int decimals,address  [] memory _mans) public ManagerUpgradeable(_mans){\n', '        status = 0;\n', '        cleanup_time = now;\n', '        profit_period = 24*3600; \n', '        period_bonus = 100000*(10 ** uint256(decimals));\n', '        cleanup_time = now;\n', '        dfkToken = StandardToken(_dfkToken);\n', '    }\n', '\n', '     \n', '    function addMinePool(uint256 stakevalue) public onStaking payable returns (uint256){\n', '        require(stakevalue>0);\n', '\n', '        // user must call prove first.\n', '        dfkToken.safeTransferFrom(msg.sender,address(this),stakevalue);\n', '\n', '        minePoolBalance = minePoolBalance.add(stakevalue);\n', '\n', '        return minePoolBalance;\n', '    }\n', '\n', '\n', '      \n', '    function stakingDeposit(uint256 stakevalue) public onStaking payable returns (bool){\n', '        require(stakevalue>0,"stakevalue is gt zero");\n', '\n', '        // user must call prove first.\n', '        dfkToken.transferFrom(msg.sender,address(this),stakevalue);\n', '\n', '        _totalStaking = _totalStaking.add(stakevalue);\n', '         \n', '        return addMinerStaking(msg.sender,stakevalue);\n', '    }\n', '\n', '\n', '    function addMinerStaking(address miner,uint256 stakevalue) internal  returns (bool){\n', '        balanceStaking[miner] = balanceStaking[miner].add(stakevalue);\n', '        \n', '        StakingLog memory slog=stakings[miner];\n', '\n', '        if(slog.profit_time < cleanup_time){ \n', '            stakings[miner] = StakingLog({\n', '                staking_time:now,\n', '                profit_time:now,\n', '                staking_value:0,\n', '                unstaking_value:stakevalue\n', '            });\n', '            _totalMiners = _totalMiners.add(1);\n', '        }else if(now.sub(slog.profit_time) >= profit_period){ \n', '            uint256   profit_times = now.sub(slog.profit_time).div(profit_period); \n', '            \n', '            stakings[miner] = StakingLog({\n', '                staking_time:now,\n', '                profit_time:now,\n', '                staking_value:slog.staking_value.add(slog.unstaking_value),\n', '                unstaking_value:stakevalue\n', '            });\n', '            \n', '            \n', '            uint256   profit =  period_bonus.mul(stakings[miner].staking_value).mul(profit_times).div(_totalStaking);\n', '            emit ProfitLog(miner,stakings[miner].profit_time,stakings[miner].staking_value,stakings[miner].unstaking_value,profit_times,profit);\n', '            require(minePoolBalance>=profit,"minePoolBalance lt profit");\n', '            minePoolBalance = minePoolBalance.sub(profit);\n', '\n', '             \n', '            balanceProfit[miner]=balanceProfit[miner].add(profit);\n', '            totalProfit = totalProfit.add(profit);\n', '\n', '        }else { \n', '            stakings[miner] = StakingLog({\n', '                staking_time:now,\n', '                profit_time:slog.profit_time,\n', '                staking_value:slog.staking_value,\n', '                unstaking_value:slog.unstaking_value.add(stakevalue)\n', '            });\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '     \n', '    function profit2Staking(uint256 value)public onStaking returns (bool success){\n', '        \n', '        require(balanceProfit[msg.sender]>=value);\n', '        balanceProfit[msg.sender] = balanceProfit[msg.sender].sub(value);\n', '        return addMinerStaking(msg.sender,value);\n', '\n', '    }\n', '\n', '     \n', '    function withdrawProfit(address to)public  returns (bool success){\n', '        \n', '        require(to != address(0));\n', '\n', '        addMinerStaking(msg.sender,0);\n', '\n', '        uint256 profit = balanceProfit[msg.sender];\n', '        balanceProfit[msg.sender] = 0;\n', '\n', '        require(dfkToken.transfer(to,profit));\n', '\n', '        return true;\n', '\n', '    }\n', '\n', '     \n', '    function withdrawStaking(address to,uint256 value)public  returns (bool success){\n', '        require(value>0);\n', '        require(to != address(0));\n', '        require(balanceStaking[msg.sender]>=value);\n', '        require(_totalStaking>=value);\n', '        \n', '        _totalStaking=_totalStaking.sub(value);\n', '        \n', '        balanceStaking[msg.sender] = balanceStaking[msg.sender].sub(value);\n', '        StakingLog memory slog=stakings[msg.sender];\n', '        \n', '         \n', '        stakings[msg.sender] = StakingLog({\n', '            staking_time:now,\n', '            profit_time:slog.profit_time,\n', '            staking_value:0,\n', '            unstaking_value:balanceStaking[msg.sender]\n', '        });\n', '        \n', '        require(dfkToken.transfer(to,value));\n', '        \n', '        return true;\n', '    }\n', '\n', '      \n', '    function withdrawAll(address to)public  returns (bool success){\n', '        require(to != address(0));\n', '        \n', '        addMinerStaking(msg.sender,0);\n', '        \n', '        _totalStaking=_totalStaking.sub(balanceStaking[msg.sender]);\n', '        \n', '        uint256 total=balanceStaking[msg.sender].add(balanceProfit[msg.sender]);\n', '\n', '        balanceProfit[msg.sender]=0;\n', '        balanceStaking[msg.sender] = 0;\n', '         \n', '        stakings[msg.sender] = StakingLog({\n', '            staking_time:0,\n', '            profit_time:0,\n', '            staking_value:0,\n', '            unstaking_value:0\n', '        });\n', '        // _totalMiners=_totalMiners.sub(1);\n', '        require(dfkToken.transfer(to,total));\n', '        \n', '        return true;\n', '    }\n', '    \n', '    \n', '    function totalMiners() public view returns (uint256){\n', '        return _totalMiners;\n', '    }\n', '\n', '     \n', '    function totalStaking() public view returns (uint256){\n', '        return _totalStaking;\n', '\n', '    }\n', '     \n', '    function poolBalance() public view returns (uint256){\n', '        return minePoolBalance;\n', '    }\n', '\n', '     \n', '    function minedBalance() public view returns (uint256){\n', '        return totalProfit;\n', '    }\n', '\n', '     \n', '    function stakingBalance(address miner) public view returns (uint256){\n', '        return balanceStaking[miner];\n', '    }\n', '\n', '\n', '     \n', '    function profitBalance(address miner) public view returns (uint256){\n', '        return balanceProfit[miner];\n', '    }\n', '\n', '     \n', '    function pauseStaking()public onlyManager  returns (bool ){\n', '        status = 0;\n', '    }\n', '    \n', '     \n', '    function resumeStaking()public onlyManager returns (bool ){\n', '       status = 1;\n', '    }\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  // public variables\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals = 18;\n', '\n', '  // internal variables\n', '  uint256 _totalSupply;\n', '  mapping(address => uint256) _balances;\n', '\n', '  // events\n', '\n', '  // public functions\n', '  function totalSupply() public view returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '\n', '  function balanceOf(address addr) public view returns (uint256 balance) {\n', '    return _balances[addr];\n', '  }\n', '\n', '  function transfer(address to, uint256 value) public returns (bool) {\n', '    require(to != address(0));\n', '    require(value <= _balances[msg.sender]);\n', '\n', '    _balances[msg.sender] = _balances[msg.sender].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '    emit Transfer(msg.sender, to, value);\n', '    return true;\n', '  }\n', '\n', '  // internal functions\n', '\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '  // public variables\n', '\n', '  // internal variables\n', '  mapping (address => mapping (address => uint256)) _allowances;\n', '\n', '  // events\n', '\n', '  // public functions\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '    require(to != address(0));\n', '    require(value <= _balances[from],"value lt from");\n', '    require(value <= _allowances[from][msg.sender],"value lt _allowances from ");\n', '\n', '    _balances[from] = _balances[from].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '    _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);\n', '    emit Transfer(from, to, value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address agent, uint256 value) public returns (bool) {\n', '    _allowances[msg.sender][agent] = value;\n', '    emit Approval(msg.sender, agent, value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address owner, address agent) public view returns (uint256) {\n', '    return _allowances[owner][agent];\n', '  }\n', '\n', '  function increaseApproval(address agent, uint value) public returns (bool) {\n', '    _allowances[msg.sender][agent] = _allowances[msg.sender][agent].add(value);\n', '    emit Approval(msg.sender, agent, _allowances[msg.sender][agent]);\n', '    return true;\n', '  }\n', '\n', '  function decreaseApproval(address agent, uint value) public returns (bool) {\n', '    uint allowanceValue = _allowances[msg.sender][agent];\n', '    if (value > allowanceValue) {\n', '      _allowances[msg.sender][agent] = 0;\n', '    } else {\n', '      _allowances[msg.sender][agent] = allowanceValue.sub(value);\n', '    }\n', '    emit Approval(msg.sender, agent, _allowances[msg.sender][agent]);\n', '    return true;\n', '  }\n', '  // internal functions\n', '}\n', '\n', 'contract DFKToken is StandardToken {\n', '  // public variables\n', '  string public name = "Defiking";\n', '  string public symbol = "DFK";\n', '  uint8 public decimals = 18;\n', '\n', '  // internal variables\n', ' \n', '  // events\n', '\n', '  // public functions\n', '  constructor() public {\n', '    //init _totalSupply\n', '    _totalSupply = 1000000000 * (10 ** uint256(decimals));\n', '\n', '    _balances[msg.sender] = _totalSupply;\n', '    emit Transfer(address(0x0), msg.sender, _totalSupply);\n', '  }\n', '\n', '  // internal functions\n', '}']