['// File: contracts/interfaces/IERC20Token.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'interface IERC20Token {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function allowance(address _owner, address _spender) external view returns (uint256);\n', '\n', '    function transfer(address _to, uint256 _value) external returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '    function approve(address _spender, uint256 _value) external returns (bool);\n', '}\n', '\n', '// File: contracts/utility/Utils.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', '  * @dev Utilities & Common Modifiers\n', '*/\n', 'contract Utils {\n', '    // verifies that a value is greater than zero\n', '    modifier greaterThanZero(uint256 _value) {\n', '        _greaterThanZero(_value);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _greaterThanZero(uint256 _value) internal pure {\n', '        require(_value > 0, "ERR_ZERO_VALUE");\n', '    }\n', '\n', "    // validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        _validAddress(_address);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _validAddress(address _address) internal pure {\n', '        require(_address != address(0), "ERR_INVALID_ADDRESS");\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        _notThis(_address);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _notThis(address _address) internal view {\n', '        require(_address != address(this), "ERR_ADDRESS_IS_SELF");\n', '    }\n', '}\n', '\n', '// File: contracts/utility/SafeMath.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', '  * @dev Library for basic math operations with overflow/underflow protection\n', '*/\n', 'library SafeMath {\n', '    /**\n', '      * @dev returns the sum of _x and _y, reverts if the calculation overflows\n', '      *\n', '      * @param _x   value 1\n', '      * @param _y   value 2\n', '      *\n', '      * @return sum\n', '    */\n', '    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        require(z >= _x, "ERR_OVERFLOW");\n', '        return z;\n', '    }\n', '\n', '    /**\n', '      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\n', '      *\n', '      * @param _x   minuend\n', '      * @param _y   subtrahend\n', '      *\n', '      * @return difference\n', '    */\n', '    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        require(_x >= _y, "ERR_UNDERFLOW");\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\n', '      *\n', '      * @param _x   factor 1\n', '      * @param _y   factor 2\n', '      *\n', '      * @return product\n', '    */\n', '    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        // gas optimization\n', '        if (_x == 0)\n', '            return 0;\n', '\n', '        uint256 z = _x * _y;\n', '        require(z / _x == _y, "ERR_OVERFLOW");\n', '        return z;\n', '    }\n', '\n', '    /**\n', '      * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '      *\n', '      * @param _x   dividend\n', '      * @param _y   divisor\n', '      *\n', '      * @return quotient\n', '    */\n', '    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        require(_y > 0, "ERR_DIVIDE_BY_ZERO");\n', '        uint256 c = _x / _y;\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: contracts/ERC20Token.sol\n', '\n', '// SPDX-License-Identifier: SEE LICENSE IN LICENSE\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '/**\n', '  * @dev ERC20 Standard Token implementation\n', '*/\n', 'contract ERC20Token is IERC20Token, Utils {\n', '    using SafeMath for uint256;\n', '\n', '\n', '    string public override name;\n', '    string public override symbol;\n', '    uint8 public override decimals;\n', '    uint256 public override totalSupply;\n', '    mapping (address => uint256) public override balanceOf;\n', '    mapping (address => mapping (address => uint256)) public override allowance;\n', '\n', '    /**\n', '      * @dev triggered when tokens are transferred between wallets\n', '      *\n', '      * @param _from    source address\n', '      * @param _to      target address\n', '      * @param _value   transfer amount\n', '    */\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    /**\n', '      * @dev triggered when a wallet allows another wallet to transfer tokens from on its behalf\n', '      *\n', '      * @param _owner   wallet that approves the allowance\n', '      * @param _spender wallet that receives the allowance\n', '      * @param _value   allowance amount\n', '    */\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    /**\n', '      * @dev initializes a new ERC20Token instance\n', '      *\n', '      * @param _name        token name\n', '      * @param _symbol      token symbol\n', '      * @param _decimals    decimal points, for display purposes\n', '      * @param _totalSupply total supply of token units\n', '    */\n', '    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) public {\n', '        // validate input\n', '        require(bytes(_name).length > 0, "ERR_INVALID_NAME");\n', '        require(bytes(_symbol).length > 0, "ERR_INVALID_SYMBOL");\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        totalSupply = _totalSupply;\n', '        balanceOf[msg.sender] = _totalSupply;\n', '    }\n', '\n', '    /**\n', '      * @dev transfers tokens to a given address\n', '      * throws on any error rather then return a false flag to minimize user errors\n', '      *\n', '      * @param _to      target address\n', '      * @param _value   transfer amount\n', '      *\n', "      * @return true if the transfer was successful, false if it wasn't\n", '    */\n', '    function transfer(address _to, uint256 _value)\n', '        public\n', '        virtual\n', '        override\n', '        validAddress(_to)\n', '        returns (bool)\n', '    {\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '      * @dev transfers tokens to a given address on behalf of another address\n', '      * throws on any error rather then return a false flag to minimize user errors\n', '      *\n', '      * @param _from    source address\n', '      * @param _to      target address\n', '      * @param _value   transfer amount\n', '      *\n', "      * @return true if the transfer was successful, false if it wasn't\n", '    */\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        virtual\n', '        override\n', '        validAddress(_from)\n', '        validAddress(_to)\n', '        returns (bool)\n', '    {\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);\n', '        balanceOf[_to] = balanceOf[_to].add(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '      * @dev allows another account/contract to transfers tokens on behalf of the caller\n', '      * throws on any error rather then return a false flag to minimize user errors\n', '      *\n', '      * also, to minimize the risk of the approve/transferFrom attack vector\n', '      * (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\n', '      * in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\n', '      *\n', '      * @param _spender approved address\n', '      * @param _value   allowance amount\n', '      *\n', "      * @return true if the approval was successful, false if it wasn't\n", '    */\n', '    function approve(address _spender, uint256 _value)\n', '        public\n', '        virtual\n', '        override\n', '        validAddress(_spender)\n', '        returns (bool)\n', '    {\n', "        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\n", '        require(_value == 0 || allowance[msg.sender][_spender] == 0, "ERR_INVALID_AMOUNT");\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/utility/interfaces/IOwned.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'interface IOwned {\n', "    // this function isn't since the compiler emits automatically generated getter functions as external\n", '    function owner() external view returns (address);\n', '\n', '    function transferOwnership(address _newOwner) external;\n', '    function acceptOwnership() external;\n', '}\n', '\n', '// File: contracts/utility/interfaces/ITokenHolder.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '/*\n', '    Token Holder interface\n', '*/\n', 'interface ITokenHolder is IOwned {\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) external;\n', '}\n', '\n', '// File: contracts/utility/interfaces/IConverterAnchor.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '/*\n', '    Converter Anchor interface\n', '*/\n', 'interface IConverterAnchor is IOwned, ITokenHolder {\n', '}\n', '\n', '// File: contracts/interfaces/ISmartToken.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '/*\n', '    Smart Token interface\n', '*/\n', 'interface ISmartToken is IConverterAnchor, IERC20Token {\n', '    function disableTransfers(bool _disable) external;\n', '    function issue(address _to, uint256 _amount) external;\n', '    function destroy(address _from, uint256 _amount) external;\n', '}\n', '\n', '// File: contracts/utility/Owned.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/**\n', '  * @dev Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public override owner;\n', '    address public newOwner;\n', '\n', '    /**\n', '      * @dev triggered when the owner is updated\n', '      *\n', '      * @param _prevOwner previous owner\n', '      * @param _newOwner  new owner\n', '    */\n', '    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n', '\n', '    /**\n', '      * @dev initializes a new Owned instance\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        _ownerOnly();\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _ownerOnly() internal view {\n', '        require(msg.sender == owner, "ERR_ACCESS_DENIED");\n', '    }\n', '\n', '    /**\n', '      * @dev allows transferring the contract ownership\n', '      * the new owner still needs to accept the transfer\n', '      * can only be called by the contract owner\n', '      *\n', '      * @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public override ownerOnly {\n', '        require(_newOwner != owner, "ERR_SAME_OWNER");\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '      * @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() override public {\n', '        require(msg.sender == newOwner, "ERR_ACCESS_DENIED");\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/utility/TokenHandler.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'contract TokenHandler {\n', '    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256("approve(address,uint256)"));\n', '    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256("transfer(address,uint256)"));\n', '    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256("transferFrom(address,address,uint256)"));\n', '\n', '    /**\n', "      * @dev executes the ERC20 token's `approve` function and reverts upon failure\n", '      * the main purpose of this function is to prevent a non standard ERC20 token\n', '      * from failing silently\n', '      *\n', '      * @param _token   ERC20 token address\n', '      * @param _spender approved address\n', '      * @param _value   allowance amount\n', '    */\n', '    function safeApprove(IERC20Token _token, address _spender, uint256 _value) internal {\n', '        (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_APPROVE_FAILED');\n", '    }\n', '\n', '    /**\n', "      * @dev executes the ERC20 token's `transfer` function and reverts upon failure\n", '      * the main purpose of this function is to prevent a non standard ERC20 token\n', '      * from failing silently\n', '      *\n', '      * @param _token   ERC20 token address\n', '      * @param _to      target address\n', '      * @param _value   transfer amount\n', '    */\n', '    function safeTransfer(IERC20Token _token, address _to, uint256 _value) internal {\n', '       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FAILED');\n", '    }\n', '\n', '    /**\n', "      * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\n", '      * the main purpose of this function is to prevent a non standard ERC20 token\n', '      * from failing silently\n', '      *\n', '      * @param _token   ERC20 token address\n', '      * @param _from    source address\n', '      * @param _to      target address\n', '      * @param _value   transfer amount\n', '    */\n', '    function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) internal {\n', '       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FROM_FAILED');\n", '    }\n', '}\n', '\n', '// File: contracts/utility/TokenHolder.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', "  * @dev We consider every contract to be a 'token holder' since it's currently not possible\n", '  * for a contract to deny receiving tokens.\n', '  *\n', "  * The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\n", '  * the owner to send tokens that were sent to the contract by mistake back to their sender.\n', '  *\n', '  * Note that we use the non standard ERC-20 interface which has no return value for transfer\n', '  * in order to support both non standard as well as standard token contracts.\n', '  * see https://github.com/ethereum/solidity/issues/4116\n', '*/\n', 'contract TokenHolder is ITokenHolder, TokenHandler, Owned, Utils {\n', '    /**\n', '      * @dev withdraws tokens held by the contract and sends them to an account\n', '      * can only be called by the owner\n', '      *\n', '      * @param _token   ERC20 token contract address\n', '      * @param _to      account to receive the new amount\n', '      * @param _amount  amount to withdraw\n', '    */\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        virtual\n', '        override\n', '        ownerOnly\n', '        validAddress(address(_token))\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        safeTransfer(_token, _to, _amount);\n', '    }\n', '}\n', '\n', '// File: contracts/SmartToken.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '  * @dev Smart Token\n', '  *\n', "  * 'Owned' is specified here for readability reasons\n", '*/\n', 'contract SmartToken is ISmartToken, Owned, ERC20Token, TokenHolder {\n', '    using SafeMath for uint256;\n', '\n', '    uint16 public constant version = 4;\n', '\n', '    bool public transfersEnabled = true;    // true if transfer/transferFrom are enabled, false otherwise\n', '\n', '    /**\n', '      * @dev triggered when the total supply is increased\n', '      *\n', '      * @param _amount  amount that gets added to the supply\n', '    */\n', '    event Issuance(uint256 _amount);\n', '\n', '    /**\n', '      * @dev triggered when the total supply is decreased\n', '      *\n', '      * @param _amount  amount that gets removed from the supply\n', '    */\n', '    event Destruction(uint256 _amount);\n', '\n', '    /**\n', '      * @dev initializes a new SmartToken instance\n', '      *\n', '      * @param _name       token name\n', '      * @param _symbol     token short symbol, minimum 1 character\n', '      * @param _decimals   for display purposes only\n', '    */\n', '    constructor(string memory _name, string memory _symbol, uint8 _decimals)\n', '        public\n', '        ERC20Token(_name, _symbol, _decimals, 0)\n', '    {\n', '    }\n', '\n', '    // allows execution only when transfers are enabled\n', '    modifier transfersAllowed {\n', '        _transfersAllowed();\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _transfersAllowed() internal view {\n', '        require(transfersEnabled, "ERR_TRANSFERS_DISABLED");\n', '    }\n', '\n', '    /**\n', '      * @dev disables/enables transfers\n', '      * can only be called by the contract owner\n', '      *\n', '      * @param _disable    true to disable transfers, false to enable them\n', '    */\n', '    function disableTransfers(bool _disable) public override ownerOnly {\n', '        transfersEnabled = !_disable;\n', '    }\n', '\n', '    /**\n', '      * @dev increases the token supply and sends the new tokens to the given account\n', '      * can only be called by the contract owner\n', '      *\n', '      * @param _to      account to receive the new amount\n', '      * @param _amount  amount to increase the supply by\n', '    */\n', '    function issue(address _to, uint256 _amount)\n', '        public\n', '        override\n', '        ownerOnly\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balanceOf[_to] = balanceOf[_to].add(_amount);\n', '\n', '        emit Issuance(_amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '    }\n', '\n', '    /**\n', '      * @dev removes tokens from the given account and decreases the token supply\n', '      * can only be called by the contract owner\n', '      *\n', '      * @param _from    account to remove the amount from\n', '      * @param _amount  amount to decrease the supply by\n', '    */\n', '    function destroy(address _from, uint256 _amount) public override ownerOnly {\n', '        balanceOf[_from] = balanceOf[_from].sub(_amount);\n', '        totalSupply = totalSupply.sub(_amount);\n', '\n', '        emit Transfer(_from, address(0), _amount);\n', '        emit Destruction(_amount);\n', '    }\n', '\n', '    // ERC20 standard method overrides with some extra functionality\n', '\n', '    /**\n', '      * @dev send coins\n', '      * throws on any error rather then return a false flag to minimize user errors\n', '      * in addition to the standard checks, the function throws if transfers are disabled\n', '      *\n', '      * @param _to      target address\n', '      * @param _value   transfer amount\n', '      *\n', "      * @return true if the transfer was successful, false if it wasn't\n", '    */\n', '    function transfer(address _to, uint256 _value)\n', '        public\n', '        override(IERC20Token, ERC20Token)\n', '        transfersAllowed\n', '        returns (bool)\n', '    {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /**\n', '      * @dev an account/contract attempts to get the coins\n', '      * throws on any error rather then return a false flag to minimize user errors\n', '      * in addition to the standard checks, the function throws if transfers are disabled\n', '      *\n', '      * @param _from    source address\n', '      * @param _to      target address\n', '      * @param _value   transfer amount\n', '      *\n', "      * @return true if the transfer was successful, false if it wasn't\n", '    */\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        override(IERC20Token, ERC20Token)\n', '        transfersAllowed\n', '        returns (bool) \n', '    {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}']