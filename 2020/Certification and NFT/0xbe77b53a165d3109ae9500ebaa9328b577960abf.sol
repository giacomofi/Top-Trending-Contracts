['#@version 0.2.7\n', '"""\n', '@title Yearn Token Vault\n', '@license GNU AGPLv3\n', '@author yearn.finance\n', '@notice\n', '    Yearn Token Vault. Holds an underlying token, and allows users to interact\n', '    with the Yearn ecosystem through Strategies connected to the Vault.\n', '    Vaults are not limited to a single Strategy, they can have as many Strategies\n', '    as can be designed (however the withdrawal queue is capped at 20.)\n', '\n', '    Deposited funds are moved into the most impactful strategy that has not\n', '    already reached its limit for assets under management, regardless of which\n', "    Strategy a user's funds end up in, they receive their portion of yields\n", '    generated across all Strategies.\n', '\n', '    When a user withdraws, if there are no funds sitting undeployed in the\n', '    Vault, the Vault withdraws funds from Strategies in the order of least\n', "    impact. (Funds are taken from the Strategy that will disturb everyone's\n", '    gains the least, then the next least, etc.) In order to achieve this, the\n', "    withdrawal queue's order must be properly set and managed by the community\n", '    (through governance).\n', '\n', '    Vault Strategies are parameterized to pursue the highest risk-adjusted yield.\n', '\n', '    There is an "Emergency Shutdown" mode. When the Vault is put into emergency\n', '    shutdown, assets will be recalled from the Strategies as quickly as is\n', '    practical (given on-chain conditions), minimizing loss. Deposits are\n', '    halted, new Strategies may not be added, and each Strategy exits with the\n', '    minimum possible damage to position, while opening up deposits to be\n', '    withdrawn by users. There are no restrictions on withdrawals above what is\n', '    expected under Normal Operation.\n', '\n', '    For further details, please refer to the specification:\n', '    https://github.com/iearn-finance/yearn-vaults/blob/master/SPECIFICATION.md\n', '"""\n', '\n', 'API_VERSION: constant(String[28]) = "0.1.3"\n', '\n', '# TODO: Add ETH Configuration\n', '# TODO: Add Delegated Configuration\n', 'from vyper.interfaces import ERC20\n', '\n', 'implements: ERC20\n', '\n', 'interface DetailedERC20:\n', '    def name() -> String[42]: view\n', '    def symbol() -> String[20]: view\n', '    def decimals() -> uint256: view\n', '\n', 'interface Strategy:\n', '    def distributeRewards(_shares: uint256): nonpayable\n', '    def estimatedTotalAssets() -> uint256: view\n', '    def withdraw(_amount: uint256): nonpayable\n', '    def migrate(_newStrategy: address): nonpayable\n', '\n', 'event Transfer:\n', '    sender: indexed(address)\n', '    receiver: indexed(address)\n', '    value: uint256\n', '\n', 'event Approval:\n', '    owner: indexed(address)\n', '    spender: indexed(address)\n', '    value: uint256\n', '\n', '\n', 'name: public(String[64])\n', 'symbol: public(String[32])\n', 'decimals: public(uint256)\n', '\n', 'balanceOf: public(HashMap[address, uint256])\n', 'allowance: public(HashMap[address, HashMap[address, uint256]])\n', 'totalSupply: public(uint256)\n', '\n', 'token: public(ERC20)\n', 'governance: public(address)\n', 'guardian: public(address)\n', 'pendingGovernance: address\n', '\n', 'struct StrategyParams:\n', "    performanceFee: uint256  # Strategist's fee (basis points)\n", '    activation: uint256  # Activation block.number\n', '    debtLimit: uint256  # Maximum borrow amount\n', '    rateLimit: uint256  # Increase/decrease per block\n', '    lastReport: uint256  # block.number of the last time a report occured\n', '    totalDebt: uint256  # Total outstanding debt that Strategy has\n', '    totalReturns: uint256  # Total returns that Strategy has realized for Vault\n', '\n', 'event StrategyAdded:\n', '    strategy: indexed(address)\n', '    debtLimit: uint256  # Maximum borrow amount\n', '    rateLimit: uint256  # Increase/decrease per block\n', "    performanceFee: uint256  # Strategist's fee (basis points)\n", '\n', 'event StrategyReported:\n', '    strategy: indexed(address)\n', '    returnAdded: uint256\n', '    debtAdded: uint256\n', '    totalReturn: uint256\n', '    totalDebt: uint256\n', '    debtLimit: uint256\n', '\n', '# NOTE: Track the total for overhead targeting purposes\n', 'strategies: public(HashMap[address, StrategyParams])\n', 'MAXIMUM_STRATEGIES: constant(uint256) = 20\n', '\n', '# Ordering that `withdraw` uses to determine which strategies to pull funds from\n', '# NOTE: Does *NOT* have to match the ordering of all the current strategies that\n', '#       exist, but it is recommended that it does or else withdrawal depth is\n', '#       limited to only those inside the queue.\n', '# NOTE: Ordering is determined by governance, and should be balanced according\n', '#       to risk, slippage, and/or volatility. Can also be ordered to increase the\n', '#       withdrawal speed of a particular Strategy.\n', '# NOTE: The first time a ZERO_ADDRESS is encountered, it stops withdrawing\n', 'withdrawalQueue: public(address[MAXIMUM_STRATEGIES])\n', '\n', 'emergencyShutdown: public(bool)\n', '\n', 'depositLimit: public(uint256)  # Limit for totalAssets the Vault can hold\n', 'debtLimit: public(uint256)  # Debt limit for the Vault across all strategies\n', 'totalDebt: public(uint256)  # Amount of tokens that all strategies have borrowed\n', 'lastReport: public(uint256)  # Number of blocks since last report\n', '\n', 'rewards: public(address)  # Rewards contract where Governance fees are sent to\n', 'managementFee: public(uint256)  # Governance Fee for management of Vault (given to `rewards`)\n', 'performanceFee: public(uint256)  # Governance Fee for performance of Vault (given to `rewards`)\n', 'FEE_MAX: constant(uint256) = 10_000  # 100%, or 10k basis points\n', 'BLOCKS_PER_YEAR: constant(uint256) = 2_300_000\n', '\n', '@external\n', 'def __init__(\n', '    _token: address,\n', '    _governance: address,\n', '    _rewards: address,\n', '    _nameOverride: String[64],\n', '    _symbolOverride: String[32]\n', '):\n', '    """\n', '    @notice\n', '        Initializes the Vault, this is called only once, when the contract is\n', '        deployed.\n', '        The performance fee is set to 4.5% of yield, per Strategy.\n', '        The management fee is set to 2%, per year.\n', '        There is no initial deposit limit.\n', '    @dev\n', "        If `_nameOverride` is not specified, the name will be 'yearn'\n", '        combined with the name of _token.\n', '\n', "        If `_symbolOverride` is not specified, the symbol will be 'y'\n", '        combined with the symbol of _token.\n', '    @param _token The token that may be deposited into this Vault.\n', '    @param _governance The address authorized for governance interactions.\n', '    @param _rewards The address to distribute rewards to.\n', '    @param _nameOverride Specify a custom Vault name. Leave empty for default choice.\n', '    @param _symbolOverride Specify a custom Vault symbol name. Leave empty for default choice.\n', '    """\n', '    # TODO: Non-detailed Configuration?\n', '    self.token = ERC20(_token)\n', '    if _nameOverride == "":\n', '        self.name = concat(DetailedERC20(_token).symbol(), " yVault")\n', '    else:\n', '        self.name = _nameOverride\n', '    if _symbolOverride == "":\n', '        self.symbol = concat("yv", DetailedERC20(_token).symbol())\n', '    else:\n', '        self.symbol = _symbolOverride\n', '    self.decimals = DetailedERC20(_token).decimals()\n', '    self.governance = _governance\n', '    self.rewards = _rewards\n', '    self.guardian = msg.sender\n', '    self.performanceFee = 450  # 4.5% of yield (per Strategy)\n', '    self.managementFee = 200  # 2% per year\n', '    self.depositLimit = MAX_UINT256  # Start unlimited\n', '    self.lastReport = block.number\n', '\n', '\n', '@pure\n', '@external\n', 'def apiVersion() -> String[28]:\n', '    """\n', '    @notice\n', '        Used to track the deployed version of this contract. In practice you\n', "        can use this version number to compare with yEarn's GitHub and\n", '        determine which version of the source matches this deployed contract.\n', '    @return API_VERSION which holds the current version of this contract.\n', '    """\n', '    return API_VERSION\n', '\n', '\n', '@external\n', 'def setName(_name: String[42]):\n', '    assert msg.sender == self.governance\n', '    self.name = _name\n', '\n', '\n', '@external\n', 'def setSymbol(_symbol: String[20]):\n', '    assert msg.sender == self.governance\n', '    self.symbol = _symbol\n', '\n', '\n', '# 2-phase commit for a change in governance\n', '@external\n', 'def setGovernance(_governance: address):\n', '    """\n', '    @notice\n', '        Nominate a new address to use as governance.\n', '\n', '        The change does not go into effect immediately. This function sets a\n', '        pending change, and the governance address is not updated until\n', '        the proposed governance address has accepted the responsibility.\n', '\n', '        This may only be called by the current governance address.\n', '    @param _governance The address requested to take over Vault governance.\n', '    """\n', '    assert msg.sender == self.governance\n', '    self.pendingGovernance = _governance\n', '\n', '\n', '@external\n', 'def acceptGovernance():\n', '    """\n', '    @notice\n', '        Once a new governance address has been proposed using setGovernance(),\n', '        this function may be called by the proposed address to accept the\n', '        responsibility of taking over governance for this contract.\n', '\n', '        This may only be called by the proposed governance address.\n', '    @dev\n', '        setGovernance() should be called by the existing governance address,\n', '        prior to calling this function.\n', '    """\n', '    assert msg.sender == self.pendingGovernance\n', '    self.governance = msg.sender\n', '\n', '\n', '@external\n', 'def setRewards(_rewards: address):\n', '    """\n', '    @notice\n', '        Changes the rewards address. Any distributed rewards\n', '        will cease flowing to the old address and begin flowing\n', '        to this address once the change is in effect.\n', '\n', '        This will not change any Strategy reports in progress, only\n', '        new reports made after this change goes into effect.\n', '\n', '        This may only be called by governance.\n', '    @param _rewards The address to use for collecting rewards.\n', '    """\n', '    assert msg.sender == self.governance\n', '    self.rewards = _rewards\n', '\n', '\n', '@external\n', 'def setDepositLimit(_limit: uint256):\n', '    """\n', '    @notice\n', '        Changes the maximum amount of tokens that can be deposited in this Vault.\n', '\n', '        Note, this is not how much may be deposited by a single depositor,\n', '        but the maximum amount that may be deposited across all depositors.\n', '\n', '        This may only be called by governance.\n', '    @param _limit The new deposit limit to use.\n', '    """\n', '    assert msg.sender == self.governance\n', '    self.depositLimit = _limit\n', '\n', '\n', '@external\n', 'def setPerformanceFee(_fee: uint256):\n', '    """\n', '    @notice\n', '        Used to change the value of `performanceFee`.\n', '\n', '        This may only be called by governance.\n', '    @param _fee The new performance fee to use.\n', '    """\n', '    assert msg.sender == self.governance\n', '    self.performanceFee = _fee\n', '\n', '\n', '@external\n', 'def setManagementFee(_fee: uint256):\n', '    """\n', '    @notice\n', '        Used to change the value of `managementFee`.\n', '\n', '        This may only be called by governance.\n', '    @param _fee The new management fee to use.\n', '    """\n', '    assert msg.sender == self.governance\n', '    self.managementFee = _fee\n', '\n', '\n', '@external\n', 'def setGuardian(_guardian: address):\n', '    """\n', '    @notice\n', '        Used to change the address of `guardian`.\n', '\n', '        This may only be called by governance or the existing guardian.\n', '    @param _guardian The new guardian address to use.\n', '    """\n', '    assert msg.sender in [self.guardian, self.governance]\n', '    self.guardian = _guardian\n', '\n', '\n', '@external\n', 'def setEmergencyShutdown(_active: bool):\n', '    """\n', '    @notice\n', '        Activates or deactivates Vault mode where all Strategies go into full\n', '        withdrawal.\n', '\n', '        During Emergency Shutdown:\n', '        1. No Users may deposit into the Vault (but may withdraw as usual.)\n', '        2. Governance may not add new Strategies.\n', '        3. Each Strategy must pay back their debt as quickly as reasonable to\n', '            minimally affect their position.\n', '        4. Only Governance may undo Emergency Shutdown.\n', '\n', '        See contract level note for further details.\n', '\n', '        This may only be called by governance or the guardian.\n', '    @param _active\n', '        If true, the Vault goes into Emergency Shutdown. If false, the Vault\n', '        goes back into Normal Operation.\n', '    """\n', '    assert msg.sender in [self.guardian, self.governance]\n', '    self.emergencyShutdown = _active\n', '\n', '\n', '@external\n', 'def setWithdrawalQueue(_queue: address[MAXIMUM_STRATEGIES]):\n', '    """\n', '    @notice\n', '        Updates the withdrawalQueue to match the addresses and order specified\n', '        by `_queue`.\n', '\n', '        There can be fewer strategies than the maximum, as well as fewer than\n', '        the total number of strategies active in the vault. `withdrawalQueue`\n', '        will be updated in a gas-efficient manner, assuming the input is well-\n', '        ordered with 0x0 only at the end.\n', '\n', '        This may only be called by governance.\n', '    @dev\n', '        This is order sensitive, specify the addresses in the order in which\n', '        funds should be withdrawn (so `_queue`[0] is the first Strategy withdrawn\n', '        from, `_queue`[1] is the second, etc.)\n', '\n', '        This means that the least impactful Strategy (the Strategy that will have\n', '        its core positions impacted the least by having funds removed) should be\n', '        at `_queue`[0], then the next least impactful at `_queue`[1], and so on.\n', '    @param _queue\n', '        The array of addresses to use as the new withdrawal queue. This is\n', '        order sensitive.\n', '    """\n', '    assert msg.sender == self.governance\n', '    # HACK: Temporary until Vyper adds support for Dynamic arrays\n', '    for i in range(MAXIMUM_STRATEGIES):\n', '        if _queue[i] == ZERO_ADDRESS and self.withdrawalQueue[i] == ZERO_ADDRESS:\n', '            break\n', '        assert self.strategies[_queue[i]].activation > 0\n', '        self.withdrawalQueue[i] = _queue[i]\n', '\n', '\n', '@internal\n', 'def _transfer(_from: address, _to: address, _value: uint256):\n', '    # See note on `transfer()`.\n', '\n', '    # Protect people from accidentally sending their shares to bad places\n', '    assert not (_to in [self, ZERO_ADDRESS])\n', '    self.balanceOf[_from] -= _value\n', '    self.balanceOf[_to] += _value\n', '    log Transfer(_from, _to, _value)\n', '\n', '\n', '@external\n', 'def transfer(_to: address, _value: uint256) -> bool:\n', '    """\n', '    @notice\n', "        Transfers shares from the caller's address to `_to`. This function\n", '        will always return true, unless the user is attempting to transfer\n', "        shares to this contract's address, or to 0x0.\n", '    @param _to\n', "        The address shares are being transferred to. Must not be this contract's\n", '        address, must not be 0x0.\n', '    @param _value The quantity of shares to transfer.\n', '    @return\n', "        True if transfer is sent to an address other than this contract's or\n", '        0x0, otherwise the transaction will fail.\n', '    """\n', '    self._transfer(msg.sender, _to, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def transferFrom(_from : address, _to : address, _value : uint256) -> bool:\n', '    """\n', '    @notice\n', '        Transfers `_value` shares from `_from` to `_to`. This operation will\n', '        always return true, unless the user is attempting to transfer shares\n', "        to this contract's address, or to 0x0.\n", '\n', '        Unless the caller has given this contract unlimited approval,\n', "        transfering shares will decrement the caller's `allowance` by `_value`.\n", '    @param _from The address shares are being transferred from.\n', '    @param _to\n', "        The address shares are being transferred to. Must not be this contract's\n", '        address, must not be 0x0.\n', '    @param _value The quantity of shares to transfer.\n', '    @return\n', "        True if transfer is sent to an address other than this contract's or\n", '        0x0, otherwise the transaction will fail.\n', '    """\n', '    if self.allowance[_from][msg.sender] < MAX_UINT256:  # Unlimited approval (saves an SSTORE)\n', '       self.allowance[_from][msg.sender] -= _value\n', '    self._transfer(_from, _to, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def approve(_spender : address, _value : uint256) -> bool:\n', '    """\n', '    @dev Approve the passed address to spend the specified amount of tokens on behalf of\n', '         `msg.sender`. Beware that changing an allowance with this method brings the risk\n', '         that someone may use both the old and the new allowance by unfortunate transaction\n', '         ordering. See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    @param _spender The address which will spend the funds.\n', '    @param _value The amount of tokens to be spent.\n', '    """\n', '    self.allowance[msg.sender][_spender] = _value\n', '    log Approval(msg.sender, _spender, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def increaseAllowance(_spender : address, _value : uint256) -> bool:\n', '    """\n', '    @dev Increase the allowance of the passed address to spend the total amount of tokens\n', '         on behalf of msg.sender. This method mitigates the risk that someone may use both\n', '         the old and the new allowance by unfortunate transaction ordering.\n', '         See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    @param _spender The address which will spend the funds.\n', '    @param _value The amount of tokens to increase the allowance by.\n', '    """\n', '    self.allowance[msg.sender][_spender] += _value\n', '    log Approval(msg.sender, _spender, self.allowance[msg.sender][_spender])\n', '    return True\n', '\n', '\n', '@external\n', 'def decreaseAllowance(_spender : address, _value : uint256) -> bool:\n', '    """\n', '    @dev Decrease the allowance of the passed address to spend the total amount of tokens\n', '         on behalf of msg.sender. This method mitigates the risk that someone may use both\n', '         the old and the new allowance by unfortunate transaction ordering.\n', '         See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    @param _spender The address which will spend the funds.\n', '    @param _value The amount of tokens to decrease the allowance by.\n', '    """\n', '    self.allowance[msg.sender][_spender] -= _value\n', '    log Approval(msg.sender, _spender, self.allowance[msg.sender][_spender])\n', '    return True\n', '\n', '\n', '@view\n', '@internal\n', 'def _totalAssets() -> uint256:\n', '    # See note on `totalAssets()`.\n', '    return self.token.balanceOf(self) + self.totalDebt\n', '\n', '\n', '@view\n', '@external\n', 'def totalAssets() -> uint256:\n', '    """\n', '    @notice\n', '        Returns the total quantity of all assets under control of this\n', "        Vault, whether they're loaned out to a Strategy, or currently held in\n", '        the Vault.\n', '    @return The total assets under control of this Vault.\n', '    """\n', '    return self._totalAssets()\n', '\n', '\n', '@view\n', '@internal\n', 'def _balanceSheetOfStrategy(_strategy: address) -> uint256:\n', '    # See note on `balanceSheetOfStrategy()`.\n', '    return Strategy(_strategy).estimatedTotalAssets()\n', '\n', '\n', '@view\n', '@external\n', 'def balanceSheetOfStrategy(_strategy: address) -> uint256:\n', '    """\n', '    @notice\n', '        Provide an accurate estimate for the total amount of assets\n', '        (principle + return) that `_strategy` is currently managing,\n', '        denominated in terms of `_token`.\n', '\n', '        This total is the total realizable value that could *actually* be\n', '        obtained from this Strategy if it were to divest its entire position\n', '        based on current on-chain conditions.\n', '    @param _strategy The Strategy to estimate the realizable assets of.\n', '    @return An estimate of the total realizable assets in `_strategy`.\n', '    """\n', '    return self._balanceSheetOfStrategy(_strategy)\n', '\n', '\n', '@view\n', '@external\n', 'def totalBalanceSheet(_strategies: address[2 * MAXIMUM_STRATEGIES]) -> uint256:\n', '    """\n', '    @notice\n', '        Measure the total balance sheet of this Vault, using the list of\n', '        strategies given above.\n', '        (2x the expected maximum is used to ensure completeness.)\n', '        NOTE: The safety of this function depends *entirely* on the list of\n', '            strategies given as the function argument. Care should be taken to\n', '            choose this list to ensure that the estimate is accurate. No\n', '            additional checking is used.\n', '        NOTE: Guardian should use this value vs. `totalAssets()` to determine\n', '            if a condition exists where the Vault is experiencing a dangerous\n', "            'balance sheet' attack, leading Vault shares to be worth less than\n", '            what their price on paper is (based on their debt)\n', '    @param _strategies\n', '        A list of strategies managed by this Vault, which will be included in\n', '        the balance sheet calculation.\n', '    @return The total balance sheet of this Vault.\n', '    """\n', '    balanceSheet: uint256 = self.token.balanceOf(self)\n', '\n', '    for strategy in _strategies:\n', '        if strategy == ZERO_ADDRESS:\n', '            break\n', '        balanceSheet += self._balanceSheetOfStrategy(strategy)\n', '\n', '    return balanceSheet\n', '\n', '\n', '@internal\n', 'def _issueSharesForAmount(_to: address, _amount: uint256) -> uint256:\n', '    # Issues `_amount` Vault shares to `_to`.\n', '    # Shares must be issued prior to taking on new collateral, or\n', '    # calculation will be wrong. This means that only *trusted* tokens\n', '    # (with no capability for exploitive behavior) can be used.\n', '    shares: uint256 = 0\n', '    # HACK: Saves 2 SLOADs (~4000 gas)\n', '    totalSupply: uint256 = self.totalSupply\n', '    if totalSupply > 0:\n', '        # Mint amount of shares based on what the Vault is managing overall\n', '        shares = _amount * totalSupply / self._totalAssets()\n', '    else:\n', '        # No existing shares, so mint 1:1\n', '        shares = _amount\n', '\n', '    # Mint new shares\n', '    self.totalSupply = totalSupply + shares\n', '    self.balanceOf[_to] += shares\n', '    log Transfer(ZERO_ADDRESS, _to, shares)\n', '\n', '    return shares\n', '\n', '\n', '@external\n', 'def deposit(_amount: uint256 = MAX_UINT256, _recipient: address = msg.sender) -> uint256:\n', '    """\n', '    @notice\n', '        Deposits `_amount` `token`, issuing shares to `_recipient`. If the\n', '        Vault is in Emergency Shutdown, deposits will not be accepted and this\n', '        call will fail.\n', '    @dev\n', '        Measuring quantity of shares to issues is based on the total\n', '        outstanding debt that this contract has ("expected value") instead\n', '        of the total balance sheet it has ("estimated value") has important\n', '        security considerations, and is done intentionally. If this value were\n', '        measured against external systems, it could be purposely manipulated by\n', '        an attacker to withdraw more assets than they otherwise should be able\n', '        to claim by redeeming their shares.\n', '\n', '        On deposit, this means that shares are issued against the total amount\n', '        that the deposited capital can be given in service of the debt that\n', '        Strategies assume. If that number were to be lower than the "expected\n', '        value" at some future point, depositing shares via this method could\n', '        entitle the depositor to *less* than the deposited value once the\n', '        "realized value" is updated from further reports by the Strategies\n', '        to the Vaults.\n', '\n', '        Care should be taken by integrators to account for this discrepancy,\n', '        by using the view-only methods of this contract (both off-chain and\n', '        on-chain) to determine if depositing into the Vault is a "good idea".\n', '    @param _amount The quantity of tokens to deposit, defaults to all.\n', '    @param _recipient\n', '        The address to issue the shares in this Vault to. Defaults to the\n', "        caller's address.\n", '    @return The issued Vault shares.\n', '    """\n', '    assert not self.emergencyShutdown  # Deposits are locked out\n', '\n', '    amount: uint256 = _amount\n', '\n', '    # If _amount not specified, transfer the full token balance\n', '    if amount == MAX_UINT256:\n', '        amount = self.token.balanceOf(msg.sender)\n', '\n', '    # Ensure we are depositing something\n', '    assert amount > 0\n', '\n', '    # Ensure deposit limit is respected\n', '    assert self._totalAssets() + amount <= self.depositLimit\n', '\n', '    # Issue new shares (needs to be done before taking deposit to be accurate)\n', '    # Shares are issued to recipient (may be different from msg.sender)\n', '    # See @dev note, above.\n', '    shares: uint256 = self._issueSharesForAmount(_recipient, amount)\n', '\n', '    # Get new collateral\n', '    reserve: uint256 = self.token.balanceOf(self)\n', '    # Tokens are transferred from msg.sender (may be different from _recipient)\n', '    self.token.transferFrom(msg.sender, self, amount)\n', '    # TODO: `Deflationary` configuration only\n', '    assert self.token.balanceOf(self) - reserve == amount  # Deflationary token check\n', '\n', '    return shares  # Just in case someone wants them\n', '\n', '\n', '@view\n', '@internal\n', 'def _shareValue(_shares: uint256) -> uint256:\n', '    # Determines the current value of `_shares`.\n', '    return (_shares * (self._totalAssets())) / self.totalSupply\n', '\n', '\n', '@view\n', '@internal\n', 'def _sharesForAmount(_amount: uint256) -> uint256:\n', '    # Determines how many shares `_amount` of token would receive.\n', '    # See dev note on `deposit`.\n', '    if self._totalAssets() > 0:\n', '        return (_amount * self.totalSupply) / self._totalAssets()\n', '    else:\n', '        return 0\n', '\n', '\n', '@view\n', '@external\n', 'def maxAvailableShares() -> uint256:\n', '    """\n', '    @notice\n', '        Determines the total quantity of shares this Vault can provide,\n', '        factoring in assets currently residing in the Vault, as well as\n', '        those deployed to strategies.\n', '    @dev Regarding how shares are calculated, see dev note on `deposit`.\n', '    @return The total quantity of shares this Vault can provide.\n', '    """\n', '    shares: uint256 = self._sharesForAmount(self.token.balanceOf(self))\n', '\n', '    for strategy in self.withdrawalQueue:\n', '        if strategy == ZERO_ADDRESS:\n', '            break\n', '        shares += self._sharesForAmount(self.strategies[strategy].totalDebt)\n', '\n', '    return shares\n', '\n', '\n', '@external\n', 'def withdraw(_shares: uint256 = MAX_UINT256, _recipient: address = msg.sender) -> uint256:\n', '    """\n', '    @notice\n', "        Withdraws the calling account's tokens from this Vault, redeeming\n", '        amount `_shares` for an appropriate amount of tokens.\n', '\n', '        See note on `setWithdrawalQueue` for further details of withdrawal\n', '        ordering and behavior.\n', '    @dev\n', '        Measuring the value of shares is based on the total outstanding debt\n', '        that this contract has ("expected value") instead of the total balance\n', '        sheet it has ("estimated value") has important security considerations,\n', '        and is done intentionally. If this value were measured against external\n', '        systems, it could be purposely manipulated by an attacker to withdraw\n', '        more assets than they otherwise should be able to claim by redeeming\n', '        their shares.\n', '\n', '        On withdrawal, this means that shares are redeemed against the total\n', '        amount that the deposited capital had "realized" since the point it\n', '        was deposited, up until the point it was withdrawn. If that number\n', '        were to be higher than the "expected value" at some future point,\n', '        withdrawing shares via this method could entitle the depositor to\n', '        *more* than the expected value once the "realized value" is updated\n', '        from further reports by the Strategies to the Vaults.\n', '\n', '        Under exceptional scenarios, this could cause earlier withdrawals to\n', '        earn "more" of the underlying assets than Users might otherwise be\n', "        entitled to, if the Vault's estimated value were otherwise measured\n", '        through external means, accounting for whatever exceptional scenarios\n', "        exist for the Vault (that aren't covered by the Vault's own design.)\n", '    @param _shares How many shares to redeem for tokens, defaults to all.\n', '    @param _recipient\n', '        The address to issue the shares in this Vault to. Defaults to the\n', "        caller's address.\n", '    @return The quantity of tokens redeemable for `_shares`.\n', '    """\n', '    shares: uint256 = _shares  # May reduce this number below\n', '\n', '    # If _shares not specified, transfer full share balance\n', '    if shares == MAX_UINT256:\n', '        shares = self.balanceOf[msg.sender]\n', '\n', '    # Limit to only the shares they own\n', '    assert shares <= self.balanceOf[msg.sender]\n', '\n', '    # See @dev note, above.\n', '    value: uint256 = self._shareValue(shares)\n', '\n', '    if value > self.token.balanceOf(self):\n', '        # We need to go get some from our strategies in the withdrawal queue\n', '        # NOTE: This performs forced withdrawals from each Strategy. There is\n', '        #       a 0.5% withdrawal fee assessed on each forced withdrawal (<= 0.5% total)\n', '        for strategy in self.withdrawalQueue:\n', '            if strategy == ZERO_ADDRESS:\n', "                break  # We've exhausted the queue\n", '\n', '            amountNeeded: uint256 = value - self.token.balanceOf(self)\n', '\n', '            if amountNeeded == 0:\n', "                break  # We're done withdrawing\n", '\n', "            # NOTE: Don't withdraw more than the debt so that Strategy can still\n", '            #       continue to work based on the profits it has\n', '            # NOTE: This means that user will lose out on any profits that each\n', '            #       Strategy in the queue would return on next harvest, benefiting others\n', '            amountNeeded = min(amountNeeded, self.strategies[strategy].totalDebt)\n', '            if amountNeeded == 0:\n', '                continue  # Nothing to withdraw from this Strategy, try the next one\n', '\n', '            # Force withdraw amount from each Strategy in the order set by governance\n', '            before: uint256 = self.token.balanceOf(self)\n', '            Strategy(strategy).withdraw(amountNeeded)\n', '            withdrawn: uint256 = self.token.balanceOf(self) - before\n', '\n', '            # Reduce the Strategy\'s debt by the amount withdrawn ("realized returns")\n', '            # NOTE: This doesn\'t add to returns as it\'s not earned by "normal means"\n', '            self.strategies[strategy].totalDebt -= withdrawn\n', '            self.totalDebt -= withdrawn\n', '\n', '    # NOTE: We have withdrawn everything possible out of the withdrawal queue\n', "    #       but we still don't have enough to fully pay them back, so adjust\n", "    #       to the total amount we've freed up through forced withdrawals\n", '    if value > self.token.balanceOf(self):\n', '        value = self.token.balanceOf(self)\n', '        shares = self._sharesForAmount(value)\n', '\n', '    # Burn shares (full value of what is being withdrawn)\n', '    self.totalSupply -= shares\n', '    self.balanceOf[msg.sender] -= shares\n', '    log Transfer(msg.sender, ZERO_ADDRESS, shares)\n', '\n', '    # Withdraw remaining balance to _recipient (may be different to msg.sender) (minus fee)\n', '    self.token.transfer(_recipient, value)\n', '\n', '    return value\n', '\n', '\n', '@view\n', '@external\n', 'def pricePerShare() -> uint256:\n', '    """\n', '    @notice Gives the price for a single Vault share.\n', '    @dev See dev note on `withdraw`.\n', '    @return The value of a single share.\n', '    """\n', '    return self._shareValue(10 ** self.decimals)\n', '\n', '\n', '@internal\n', 'def _organizeWithdrawalQueue():\n', '    # Reorganize `withdrawalQueue` based on premise that if there is an\n', '    # empty value between two actual values, then the empty value should be\n', '    # replaced by the later value.\n', '    # NOTE: Relative ordering of non-zero values is maintained.\n', '    offset: uint256 = 0\n', '    for idx in range(MAXIMUM_STRATEGIES):\n', '        strategy: address = self.withdrawalQueue[idx]\n', '        if strategy == ZERO_ADDRESS:\n', '            offset += 1  # how many values we need to shift, always `<= idx`\n', '        elif offset > 0:\n', '            self.withdrawalQueue[idx-offset] = strategy\n', '            self.withdrawalQueue[idx] = ZERO_ADDRESS\n', '\n', '\n', '@external\n', 'def addStrategy(\n', '    _strategy: address,\n', '    _debtLimit: uint256,\n', '    _rateLimit: uint256,\n', '    _performanceFee: uint256,\n', '):\n', '    """\n', '    @notice\n', '        Add a Strategy to the Vault.\n', '\n', '        This may only be called by governance.\n', '    @dev\n', '        The Strategy will be appended to `withdrawalQueue`, call\n', '        `setWithdrawalQueue` to change the order.\n', '    @param _strategy The address of the Strategy to add.\n', '    @param _debtLimit The quantity of assets `_strategy` can manage.\n', '    @param _rateLimit\n', '        How many assets per block this Vault may deposit to or withdraw from\n', '        `_strategy`.\n', '    @param _performanceFee\n', "        The fee the strategist will receive based on this Vault's performance.\n", '    """\n', '    assert msg.sender == self.governance\n', '    assert self.strategies[_strategy].activation == 0\n', '    self.strategies[_strategy] = StrategyParams({\n', '        performanceFee: _performanceFee,\n', '        activation: block.number,\n', '        debtLimit: _debtLimit,\n', '        rateLimit: _rateLimit,\n', '        lastReport: block.number,\n', '        totalDebt: 0,\n', '        totalReturns: 0,\n', '    })\n', '    self.debtLimit += _debtLimit\n', '    log StrategyAdded(_strategy, _debtLimit, _rateLimit, _performanceFee)\n', '\n', '    # queue is full\n', '    assert self.withdrawalQueue[MAXIMUM_STRATEGIES-1] == ZERO_ADDRESS\n', '    self.withdrawalQueue[MAXIMUM_STRATEGIES-1] = _strategy\n', '    self._organizeWithdrawalQueue()\n', '\n', '\n', '@external\n', 'def updateStrategyDebtLimit(\n', '    _strategy: address,\n', '    _debtLimit: uint256,\n', '):\n', '    """\n', '    @notice\n', '        Change the quantity of assets `_strategy` may manage.\n', '\n', '        This may only be called by governance.\n', '    @param _strategy The Strategy to update.\n', '    @param _debtLimit The quantity of assets `_strategy` may now manage.\n', '    """\n', '    assert msg.sender == self.governance\n', '    assert self.strategies[_strategy].activation > 0\n', '    self.debtLimit -= self.strategies[_strategy].debtLimit\n', '    self.strategies[_strategy].debtLimit = _debtLimit\n', '    self.debtLimit += _debtLimit\n', '\n', '\n', '@external\n', 'def updateStrategyRateLimit(\n', '    _strategy: address,\n', '    _rateLimit: uint256,\n', '):\n', '    """\n', '    @notice\n', '        Change the quantity assets per block this Vault may deposit to or\n', '        withdraw from `_strategy`.\n', '\n', '        This may only be called by governance.\n', '    @param _strategy The Strategy to update.\n', '    @param _rateLimit The quantity of assets `_strategy` may now manage.\n', '    """\n', '    assert msg.sender == self.governance\n', '    assert self.strategies[_strategy].activation > 0\n', '    self.strategies[_strategy].rateLimit = _rateLimit\n', '\n', '\n', '@external\n', 'def updateStrategyPerformanceFee(\n', '    _strategy: address,\n', '    _performanceFee: uint256,\n', '):\n', '    """\n', '    @notice\n', "        Change the fee the strategist will receive based on this Vault's\n", '        performance.\n', '\n', '        This may only be called by governance.\n', '    @param _strategy The Strategy to update.\n', '    @param _performanceFee The new fee the strategist will receive.\n', '    """\n', '    assert msg.sender == self.governance\n', '    assert self.strategies[_strategy].activation > 0\n', '    self.strategies[_strategy].performanceFee = _performanceFee\n', '\n', '\n', '@external\n', 'def migrateStrategy(_oldVersion: address, _newVersion: address):\n', '    """\n', '    @notice\n', '        Migrates a Strategy, including all assets from `_oldVersion` to\n', '        `_newVersion`.\n', '\n', '        This may only be called by governance.\n', '    @dev\n', '        Strategy must successfully migrate all capital and positions to new\n', '        Strategy, or else this will upset the balance of the Vault.\n', '\n', '        The new Strategy should be "empty" e.g. have no prior commitments to\n', '        this Vault, otherwise it could have issues.\n', '    @param _oldVersion The existing Strategy to migrate from.\n', '    @param _newVersion The new Strategy to migrate to.\n', '    """\n', '    assert msg.sender == self.governance\n', '\n', '    assert self.strategies[_oldVersion].activation > 0\n', '    assert self.strategies[_newVersion].activation == 0\n', '\n', '    strategy: StrategyParams = self.strategies[_oldVersion]\n', '    self.strategies[_oldVersion] = empty(StrategyParams)\n', '    self.strategies[_newVersion] = strategy\n', '\n', '    Strategy(_oldVersion).migrate(_newVersion)\n', '    # TODO: Ensure a smooth transition in terms of  Strategy return\n', '\n', '    for idx in range(MAXIMUM_STRATEGIES):\n', '        if self.withdrawalQueue[idx] == _oldVersion:\n', '            self.withdrawalQueue[idx] = _newVersion\n', "            return  # Don't need to reorder anything because we swapped\n", '\n', '\n', '@external\n', 'def revokeStrategy(_strategy: address = msg.sender):\n', '    """\n', '    @notice\n', '        Revoke a Strategy, setting its debt limit to 0 and preventing any\n', '        future deposits.\n', '\n', '        This function should only be used in the scenario where the Strategy is\n', '        being retired but no migration of the positions are possible, or in the\n', '        extreme scenario that the Strategy needs to be put into "Emergency Exit"\n', '        mode in order for it to exit as quickly as possible. The latter scenario\n', '        could be for any reason that is considered "critical" that the Strategy\n', '        exits its position as fast as possible, such as a sudden change in market\n', '        conditions leading to losses, or an imminent failure in an external\n', '        dependency.\n', '\n', '        This may only be called by governance, the guardian, or the Strategy\n', '        itself. Note that a Strategy will only revoke itself during emergency\n', '        shutdown.\n', '    @param _strategy The Strategy to revoke.\n', '    """\n', '    assert msg.sender in [_strategy, self.governance, self.guardian]\n', '    self.debtLimit -= self.strategies[_strategy].debtLimit\n', '    self.strategies[_strategy].debtLimit = 0\n', '\n', '\n', '@external\n', 'def addStrategyToQueue(_strategy: address):\n', '    """\n', '    @notice\n', '        Adds `_strategy` to `withdrawalQueue`.\n', '\n', '        This may only be called by governance.\n', '    @dev\n', '        The Strategy will be appended to `withdrawalQueue`, call\n', '        `setWithdrawalQueue` to change the order.\n', '    @param _strategy The Strategy to add.\n', '    """\n', '    assert msg.sender == self.governance\n', '    # Must be a current Strategy\n', '    assert self.strategies[_strategy].activation > 0 and self.strategies[_strategy].totalDebt > 0\n', '    # Check if queue is full\n', '    assert self.withdrawalQueue[MAXIMUM_STRATEGIES-1] == ZERO_ADDRESS\n', "    # Can't already be in the queue\n", '    for strategy in self.withdrawalQueue:\n', '        if strategy == ZERO_ADDRESS:\n', '            break\n', '        assert strategy != _strategy\n', '    self.withdrawalQueue[MAXIMUM_STRATEGIES-1] = _strategy\n', '    self._organizeWithdrawalQueue()\n', '\n', '\n', '@external\n', 'def removeStrategyFromQueue(_strategy: address):\n', '    """\n', '    @notice\n', '        Remove `_strategy` from `withdrawalQueue`.\n', '\n', '        This may only be called by governance.\n', '    @dev\n', "        We don't do this with revokeStrategy because it should still\n", "        be possible to withdraw from the Strategy if it's unwinding.\n", '    @param _strategy The Strategy to add.\n', '    """\n', '    assert msg.sender == self.governance\n', '    for idx in range(MAXIMUM_STRATEGIES):\n', '        if self.withdrawalQueue[idx] == _strategy:\n', '            self.withdrawalQueue[idx] = ZERO_ADDRESS\n', '            self._organizeWithdrawalQueue()\n', '            return  # We found the right location and cleared it\n', "    raise  # We didn't find the Strategy in the queue\n", '\n', '\n', '@view\n', '@internal\n', 'def _debtOutstanding(_strategy: address) -> uint256:\n', '    # See note on `debtOutstanding()`.\n', '    strategy_debtLimit: uint256 = self.strategies[_strategy].debtLimit\n', '    strategy_totalDebt: uint256 = self.strategies[_strategy].totalDebt\n', '\n', '    if self.emergencyShutdown:\n', '        return strategy_totalDebt\n', '    elif strategy_totalDebt <= strategy_debtLimit:\n', '        return 0\n', '    else:\n', '        return strategy_totalDebt - strategy_debtLimit\n', '\n', '\n', '@view\n', '@external\n', 'def debtOutstanding(_strategy: address = msg.sender) -> uint256:\n', '    """\n', '    @notice\n', '        Determines if `_strategy` is past its debt limit and if any tokens\n', '        should be withdrawn to the Vault.\n', '    @param _strategy The Strategy to check. Defaults to the caller.\n', '    @return The quantity of tokens to withdraw.\n', '    """\n', '    return self._debtOutstanding(_strategy)\n', '\n', '\n', '@view\n', '@internal\n', 'def _creditAvailable(_strategy: address) -> uint256:\n', '    # See note on `creditAvailable()`.\n', '    if self.emergencyShutdown:\n', '        return 0\n', '\n', '    strategy_debtLimit: uint256 = self.strategies[_strategy].debtLimit\n', '    strategy_totalDebt: uint256 = self.strategies[_strategy].totalDebt\n', '    strategy_rateLimit: uint256 = self.strategies[_strategy].rateLimit\n', '    strategy_lastReport: uint256 = self.strategies[_strategy].lastReport\n', '\n', '    # Exhausted credit line\n', '    if strategy_debtLimit <= strategy_totalDebt or self.debtLimit <= self.totalDebt:\n', '        return 0\n', '\n', '    # Start with debt limit left for the Strategy\n', '    available: uint256 = strategy_debtLimit - strategy_totalDebt\n', '\n', '    # Adjust by the global debt limit left\n', '    available = min(available, self.debtLimit - self.totalDebt)\n', '\n', '    # Adjust by the rate limit algorithm (limits the step size per reporting period)\n', '    blockDelta: uint256 = block.number - strategy_lastReport\n', '    # NOTE: Protect against unnecessary overflow faults here\n', '    # NOTE: Set `strategy_rateLimit` to a really high number to disable the rate limit\n', '    # NOTE: *NEVER* set `strategy_rateLimit` to 0 or else this will always throw\n', '    if available / strategy_rateLimit >= blockDelta:\n', '        available = min(available, strategy_rateLimit * blockDelta)\n', '\n', '    # Can only borrow up to what the contract has in reserve\n', '    # NOTE: Running near 100% is discouraged\n', '    return min(available, self.token.balanceOf(self))\n', '\n', '\n', '@view\n', '@external\n', 'def creditAvailable(_strategy: address = msg.sender) -> uint256:\n', '    """\n', '    @notice\n', '        Amount of tokens in Vault a Strategy has access to as a credit line.\n', '\n', "        This will check the Strategy's debt limit, as well as the tokens\n", '        available in the Vault, and determine the maximum amount of tokens\n', '        (if any) the Strategy may draw on.\n', '\n', '        In the rare case the Vault is in emergency shutdown this will return 0.\n', '    @param _strategy The Strategy to check. Defaults to caller.\n', '    @return The quantity of tokens available for the Strategy to draw on.\n', '    """\n', '    return self._creditAvailable(_strategy)\n', '\n', '\n', '@view\n', '@internal\n', 'def _expectedReturn(_strategy: address) -> uint256:\n', '    # See note on `expectedReturn()`.\n', '    strategy_lastReport: uint256 = self.strategies[_strategy].lastReport\n', '    strategy_totalReturns: uint256 = self.strategies[_strategy].totalReturns\n', '    strategy_activation: uint256 = self.strategies[_strategy].activation\n', '\n', '    blockDelta: uint256 = (block.number - strategy_lastReport)\n', '    if blockDelta > 0:\n', '        return (strategy_totalReturns * blockDelta) / (block.number - strategy_activation)\n', '    else:\n', '        return 0  # Covers the scenario when block.number == strategy_activation\n', '\n', '\n', '@view\n', '@external\n', 'def expectedReturn(_strategy: address = msg.sender) -> uint256:\n', '    """\n', '    @notice\n', '        Provide an accurate expected value for the return this `_strategy`\n', '        would provide to the Vault the next time `report()` is called\n', '        (since the last time it was called).\n', '    @param _strategy The Strategy to determine the expected return for. Defaults to caller.\n', '    @return\n', '        The anticipated amount `_strategy` should make on its investment\n', '        since its last report.\n', '    """\n', '    return self._expectedReturn(_strategy)\n', '\n', '\n', '@external\n', 'def report(_return: uint256) -> uint256:\n', '    """\n', '    @notice\n', '        Reports the amount of assets the calling Strategy has free (usually in\n', '        terms of ROI).\n', '\n', '        This may only be called by a Strategy managed by this Vault.\n', '    @dev\n', '        For approved strategies, this is the most efficient behavior.\n', '        The Strategy reports back what it has free, then Vault "decides"\n', '        whether to take some back or give it more. Note that the most it can\n', '        take is `_return`, and the most it can give is all of the remaining\n', '        reserves. Anything outside of those bounds is abnormal behavior.\n', '\n', '        All approved strategies must have increased diligence around\n', '        calling this function, as abnormal behavior could become catastrophic.\n', '    @param _return\n', "        Amount Strategy has made on it's investment since its last report,\n", '        and is free to be given back to Vault as earnings\n', '    @return Amount of debt outstanding (iff totalDebt > debtLimit).\n', '    """\n', '\n', '    # Only approved strategies can call this function\n', '    assert self.strategies[msg.sender].activation > 0\n', '\n', '    # Outstanding debt the Vault wants to take back from the Strategy (if any)\n', '    debt: uint256 = self._debtOutstanding(msg.sender)\n', '\n', '    # Issue new shares to cover fees\n', '    # NOTE: In effect, this reduces overall share price by the combined fee\n', '    governance_fee: uint256 = (\n', '        self._totalAssets() * (block.number - self.lastReport) * self.managementFee\n', '    ) / FEE_MAX / BLOCKS_PER_YEAR\n', '    self.lastReport = block.number\n', '    strategist_fee: uint256 = 0  # Only applies in certain conditions\n', '\n', '    # NOTE: Applies if Strategy is not shutting down, or it is but all debt paid off\n', "    # NOTE: No fee is taken when a Strategy is unwinding it's position, until all debt is paid\n", '    if  _return > debt:\n', '        strategist_fee = (\n', '            (_return - debt) * self.strategies[msg.sender].performanceFee\n', '        ) / FEE_MAX\n', '        governance_fee += (_return - debt) * self.performanceFee / FEE_MAX\n', '\n', '    # NOTE: This must be called prior to taking new collateral,\n', '    #       or the calculation will be wrong!\n', '    # NOTE: This must be done at the same time, to ensure the relative\n', '    #       ratio of governance_fee : strategist_fee is kept intact\n', '    total_fee: uint256 = governance_fee + strategist_fee\n', '    reward: uint256 = self._issueSharesForAmount(self, total_fee)\n', '\n', '    # Send the rewards out as new shares in this Vault\n', '    if strategist_fee > 0:\n', '        strategist_reward: uint256 = (strategist_fee * reward) / total_fee\n', '        self._transfer(self, msg.sender, strategist_reward)\n', '        Strategy(msg.sender).distributeRewards(strategist_reward)\n', '    # NOTE: Governance earns any dust leftover from flooring math above\n', '    self._transfer(self, self.rewards, self.balanceOf[self])\n', '\n', '    # Compute the line of credit the Vault is able to offer the Strategy (if any)\n', '    credit: uint256 = self._creditAvailable(msg.sender)\n', '\n', '    # Give/take balance to Strategy, based on the difference between the return and\n', '    # the credit increase we are offering (if any)\n', '    # NOTE: This is just used to adjust the balance of tokens between the Strategy and\n', "    #       the Vault based on the Strategy's debt limit (as well as the Vault's).\n", '    if _return < credit:  # credit surplus, give to Strategy\n', '        self.token.transfer(msg.sender, credit - _return)\n', '    elif _return > credit:  # credit deficit, take from Strategy\n', '        self.token.transferFrom(msg.sender, self, _return - credit)\n', '\n', "    # else, don't do anything because it is performing well as is\n", '\n', '    # Update the actual debt based on the full credit we are extending to the Strategy\n', '    # or the returns if we are taking funds back\n', '    # NOTE: credit + self.strategies[msg.sender].totalDebt is always < self.debtLimit\n', '    # NOTE: At least one of `credit` or `debt` is always 0 (both can be 0)\n', '    if credit > 0:\n', '        self.strategies[msg.sender].totalDebt += credit\n', '        self.totalDebt += credit\n', '\n', '        # Returns are always "realized gains"\n', '        self.strategies[msg.sender].totalReturns += _return\n', '\n', "    elif debt > 0:  # We're repaying debt now, so there are no gains\n", '        if _return <= debt:\n', '            # Pay down our debt with profit\n', '            # NOTE: Cannot return more than you borrowed\n', '            self.strategies[msg.sender].totalDebt -= _return\n', '            self.totalDebt -= _return\n', '            debt -= _return  # Debt payment complete (to report back to Strategy)\n', '\n', '        else:\n', '            # Finish off our debt payments here\n', '            self.totalDebt -= debt\n', '            self.strategies[msg.sender].totalDebt -= debt\n', '\n', '            # Returns are always "realized gains" (after we have paid off our debt)\n', '            self.strategies[msg.sender].totalReturns += _return - debt\n', '            debt = 0  # All debts paid off (to report back to Strategy)\n', '\n', '    elif _return > 0:  # No debt to pay, nor credit to expand with, add to profit!\n', '        self.strategies[msg.sender].totalReturns += _return\n', '\n', '    # else, no credit/debt to manage, nor returns to report. Nothing really happened!\n', '\n', '    # Update reporting time\n', '    self.strategies[msg.sender].lastReport = block.number\n', '\n', '    log StrategyReported(\n', '        msg.sender,\n', '        _return,\n', '        credit,\n', '        self.strategies[msg.sender].totalReturns,\n', '        self.strategies[msg.sender].totalDebt,\n', '        self.strategies[msg.sender].debtLimit,\n', '    )\n', '\n', '    if self.strategies[msg.sender].totalDebt == 0 or self.emergencyShutdown:\n', '        # Take every last penny the Strategy has (Emergency Exit/revokeStrategy)\n', '        # NOTE: This is different than `debt` in order to extract *all* of the returns\n', '        return self._balanceSheetOfStrategy(msg.sender)\n', '    else:\n', '        # Otherwise, just return what we have as debt outstanding\n', '        return debt\n', '\n', '\n', '@internal\n', 'def erc20_safe_transfer(_token: address, _to: address, _value: uint256):\n', '    # Used only to send tokens that are not the type managed by this Vault.\n', '    # HACK: Used to handle non-compliant tokens like USDT\n', '    _response: Bytes[32] = raw_call(\n', '        _token,\n', '        concat(\n', '            method_id("transfer(address,uint256)"),\n', '            convert(_to, bytes32),\n', '            convert(_value, bytes32)\n', '        ),\n', '        max_outsize=32\n', '    )\n', '    if len(_response) > 0:\n', '        assert convert(_response, bool), "Transfer failed!"\n', '\n', '\n', '@external\n', 'def sweep(_token: address):\n', '    """\n', '    @notice\n', '        Removes tokens from this Vault that are not the type of token managed\n', '        by this Vault. This may be used in case of accidentally sending the\n', '        wrong kind of token to this Vault.\n', '\n', '        Tokens will be sent to `governance`.\n', '\n', '        This will fail if an attempt is made to sweep the tokens that this\n', '        Vault manages.\n', '\n', '        This may only be called by governance.\n', '    @param _token The token to transfer out of this vault.\n', '    """\n', '    assert msg.sender == self.governance\n', "    # Can't be used to steal what this Vault is protecting\n", '    assert _token != self.token.address\n', '    self.erc20_safe_transfer(_token, self.governance, ERC20(_token).balanceOf(self))']