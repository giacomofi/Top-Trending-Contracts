['// SPDX-License-Identifier: GPL-3.0-only\n', '\n', 'pragma solidity 0.7.4;\n', '\n', 'library SafeMathLib {\n', '  function times(uint a, uint b) public pure returns (uint) {\n', '    uint c = a * b;\n', "    require(a == 0 || c / a == b, 'Overflow detected');\n", '    return c;\n', '  }\n', '\n', '  function minus(uint a, uint b) public pure returns (uint) {\n', "    require(b <= a, 'Underflow detected');\n", '    return a - b;\n', '  }\n', '\n', '  function plus(uint a, uint b) public pure returns (uint) {\n', '    uint c = a + b;\n', "    require(c>=a && c>=b, 'Overflow detected');\n", '    return c;\n', '  }\n', '\n', '}\n']
['// SPDX-License-Identifier: GPL-3.0-only\n', '\n', 'pragma solidity 0.7.4;\n', '\n', 'import "./SafeMathLib.sol";\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n', '     * by `operator` from `from`, this function is called.\n', '     *\n', '     * It must return its Solidity selector to confirm the token transfer.\n', '     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n', '     *\n', '     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n', '}\n', '\n', '// ERC 721\n', 'contract Identity {\n', '    using SafeMathLib for uint;\n', '\n', '    mapping (uint => address) public owners;\n', '    mapping (address => uint) public balances;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping (address => bool)) public operatorApprovals;\n', '    mapping (uint => address) public tokenApprovals;\n', '\n', '    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n', '    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    /*\n', "     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n", "     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n", "     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n", "     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n", "     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n", "     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n", "     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n", '     *\n', '     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n', '     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n', '     */\n', '    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '\n', '    /*\n', "     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n", '     */\n', '    bytes4 private constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '\n', '    uint public identityIncreaseFactor = 2;\n', '    uint public identityIncreaseDenominator = 1;\n', '    uint public lastIdentityPrice = 100 * 1 ether; // burn cost of making an identity, in IERC20\n', '    uint public identityDecayFactor = 1 ether / 100;\n', '    uint public identityPriceFloor = 100 * 1 ether;\n', '    uint public numIdentities = 0;\n', '    uint public lastPurchaseBlock;\n', '\n', '    address public management;\n', '\n', '    IERC20 public token;\n', '\n', '    event ManagementUpdated(address oldManagement, address newManagement);\n', '    event TokenSet(address token);\n', '    event IdentityIncreaseFactorUpdated(uint oldIdIncreaseFactor, uint newIdIncreaseFactor);\n', '    event IdentityIncreaseDenominatorUpdated(uint oldIdIncreaseDenominator, uint newIdIncreaseDenominator);\n', '    event IdentityDecayFactorUpdated(uint oldIdDecayFactor, uint newIdDecayFactor);\n', '    event IdentityPriceFloorUpdated(uint oldIdPriceFloor, uint newIdPriceFloor);\n', '    event IdentityCreated(address indexed owner, uint indexed token);\n', '\n', '\n', '    /// @dev This emits when ownership of any NFT changes by any mechanism.\n', '    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n', '    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n', '    ///  may be created and assigned without emitting Transfer. At the time of\n', '    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /// @dev This emits when the approved address for an NFT is changed or\n', '    ///  reaffirmed. The zero address indicates there is no approved address.\n', '    ///  When a Transfer event emits, this also indicates that the approved\n', '    ///  address for that NFT (if any) is reset to none.\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /// @dev This emits when an operator is enabled or disabled for an owner.\n', '    ///  The operator can manage all NFTs of the owner.\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    modifier managementOnly() {\n', "        require (msg.sender == management, 'Identity: Only management may call this');\n", '        _;\n', '    }\n', '\n', '    constructor(address mgmt) {\n', '        management = mgmt;\n', '        lastPurchaseBlock = block.number;\n', '    }\n', '\n', '    function setToken(address tokenAddr) public managementOnly {\n', '        token = IERC20(tokenAddr);\n', '        emit TokenSet(tokenAddr);\n', '    }\n', '\n', '    // this function creates an identity by burning the IERC20. Anyone can call it.\n', '    function createMyIdentity(uint maxPrice) public {\n', '        uint identityPrice = getIdentityPrice();\n', '        require(maxPrice >= identityPrice || maxPrice == 0, "Identity: current price exceeds user maximum");\n', '        token.transferFrom(msg.sender, address(0), identityPrice);\n', '        createIdentity(msg.sender);\n', '        lastIdentityPrice = identityPrice.times(identityIncreaseFactor) / identityIncreaseDenominator;\n', '        lastPurchaseBlock = block.number;\n', '    }\n', '\n', '    // this function creates an identity for free. Only management can call it.\n', '    function createIdentityFor(address newId) public managementOnly {\n', '        createIdentity(newId);\n', '    }\n', '\n', '    function createIdentity(address owner) internal {\n', '        numIdentities = numIdentities.plus(1);\n', '        owners[numIdentities] = owner;\n', '        balances[owner] = balances[owner].plus(1);\n', '        emit Transfer(address(0), owner, numIdentities);\n', '        emit IdentityCreated(owner, numIdentities);\n', '    }\n', '\n', '    function getIdentityPrice() public view returns (uint) {\n', '        uint decay = identityDecayFactor.times(block.number.minus(lastPurchaseBlock));\n', '        if (lastIdentityPrice < decay.plus(identityPriceFloor)) {\n', '            return identityPriceFloor;\n', '        } else {\n', '            return lastIdentityPrice.minus(decay);\n', '        }\n', '    }\n', '\n', '    /// ================= SETTERS =======================================\n', '\n', '    // change the management key\n', '    function setManagement(address newMgmt) public managementOnly {\n', '        address oldMgmt =  management;\n', '        management = newMgmt;\n', '        emit ManagementUpdated(oldMgmt, newMgmt);\n', '    }\n', '\n', '    function setIdentityIncreaseFactor(uint newIncreaseFactor) public managementOnly {\n', '        uint oldIncreaseFactor = identityIncreaseFactor;\n', '        identityIncreaseFactor = newIncreaseFactor;\n', '        emit IdentityIncreaseFactorUpdated(oldIncreaseFactor, newIncreaseFactor);\n', '    }\n', '\n', '    function setIdentityIncreaseDenominator(uint newIncreaseDenominator) public managementOnly {\n', '        uint oldIncreaseDenominator = identityIncreaseDenominator;\n', '        identityIncreaseDenominator = newIncreaseDenominator;\n', '        emit IdentityIncreaseDenominatorUpdated(oldIncreaseDenominator, newIncreaseDenominator);\n', '    }\n', '\n', '    function setIdentityDecayFactor(uint newDecayFactor) public managementOnly {\n', '        uint oldDecayFactor = identityDecayFactor;\n', '        identityDecayFactor = newDecayFactor;\n', '        emit IdentityDecayFactorUpdated(oldDecayFactor, newDecayFactor);\n', '    }\n', '\n', '    function setIdentityPriceFloor(uint newPriceFloor) public managementOnly {\n', '        uint oldFloor = identityPriceFloor;\n', '        identityPriceFloor = newPriceFloor;\n', '        emit IdentityPriceFloorUpdated(oldFloor, newPriceFloor);\n', '    }\n', '\n', '    /// ================= ERC 721 FUNCTIONS =============================================\n', '\n', '    /// @notice Count all NFTs assigned to an owner\n', '    /// @dev NFTs assigned to the zero address are considered invalid, and this\n', '    ///  function throws for queries about the zero address.\n', '    /// @param owner An address for whom to query the balance\n', '    /// @return The number of NFTs owned by `owner`, possibly zero\n', '    function balanceOf(address owner) external view returns (uint256) {\n', '        return balances[owner];\n', '    }\n', '\n', '    /// @notice Find the owner of an NFT\n', '    /// @dev NFTs assigned to zero address are considered invalid, and queries\n', '    ///  about them do throw.\n', '    /// @param tokenId The identifier for an NFT\n', '    /// @return The address of the owner of the NFT\n', '    function ownerOf(uint256 tokenId) external view returns (address)  {\n', '        address owner = owners[tokenId];\n', "        require(owner != address(0), 'No such token');\n", '        return owner;\n', '    }\n', '\n', '    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '    ///  TO CONFIRM THAT `to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '    ///  THEY MAY BE PERMANENTLY LOST\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `from` is\n', '    ///  not the current owner. Throws if `to` is the zero address. Throws if\n', '    ///  `tokenId` is not a valid NFT.\n', '    /// @param from The current owner of the NFT\n', '    /// @param to The new owner\n', '    /// @param tokenId The NFT to transfer\n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', "        require(isApproved(msg.sender, tokenId), 'Identity: Unapproved transfer');\n", '        transfer(from, to, tokenId);\n', '    }\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `from` is\n', '    ///  not the current owner. Throws if `to` is the zero address. Throws if\n', '    ///  `tokenId` is not a valid NFT. When transfer is complete, this function\n', '    ///  checks if `to` is a smart contract (code size > 0). If so, it calls\n', '    ///  `onERC721Received` on `to` and throws if the return value is not\n', '    ///  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.\n', '    /// @param from The current owner of the NFT\n', '    /// @param to The new owner\n', '    /// @param tokenId The NFT to transfer\n', '    /// @param data Additional data with no specified format, sent in call to `to`\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {\n', '        transferFrom(from, to, tokenId);\n', '        require(checkOnERC721Received(from, to, tokenId, data), "Identity: transfer to non ERC721Receiver implementer");\n', '    }\n', '\n', '    /// @notice Transfers the ownership of an NFT from one address to another address\n', '    /// @dev This works identically to the other function with an extra data parameter,\n', '    ///  except this function just sets data to "".\n', '    /// @param from The current owner of the NFT\n', '    /// @param to The new owner\n', '    /// @param tokenId The NFT to transfer\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n', "        safeTransferFrom(from, to, tokenId, '');\n", '    }\n', '\n', '\n', '    /// @notice Change or reaffirm the approved address for an NFT\n', '    /// @dev The zero address indicates there is no approved address.\n', '    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n', '    ///  operator of the current owner.\n', '    /// @param approved The new approved NFT controller\n', '    /// @param tokenId The NFT to approve\n', '    function approve(address approved, uint256 tokenId) public {\n', '        address owner = owners[tokenId];\n', "        require(isApproved(msg.sender, tokenId), 'Identity: Not authorized to approve');\n", "        require(owner != approved, 'Identity: Approving self not allowed');\n", '        tokenApprovals[tokenId] = approved;\n', '        emit Approval(owner, approved, tokenId);\n', '    }\n', '\n', '    /// @notice Enable or disable approval for a third party ("operator") to manage\n', "    ///  all of `msg.sender`'s assets\n", '    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n', '    ///  multiple operators per owner.\n', '    /// @param operator Address to add to the set of authorized operators\n', '    /// @param approved True if the operator is approved, false to revoke approval\n', '    function setApprovalForAll(address operator, bool approved) external {\n', '        operatorApprovals[msg.sender][operator] = approved;\n', '        emit ApprovalForAll(msg.sender, operator, approved);\n', '    }\n', '\n', '    /// @notice Get the approved address for a single NFT\n', '    /// @dev Throws if `tokenId` is not a valid NFT.\n', '    /// @param tokenId The NFT to find the approved address for\n', '    /// @return The approved address for this NFT, or the zero address if there is none\n', '    function getApproved(uint256 tokenId) external view returns (address) {\n', '        address owner = owners[tokenId];\n', "        require(owner != address(0), 'Identity: Invalid tokenId');\n", '        return tokenApprovals[tokenId];\n', '    }\n', '\n', '    /// @notice Query if an address is an authorized operator for another address\n', '    /// @param owner The address that owns the NFTs\n', '    /// @param operator The address that acts on behalf of the owner\n', '    /// @return True if `operator` is an approved operator for `owner`, false otherwise\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n', '        return operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /// ================ UTILS =========================\n', '    function isApproved(address operator, uint tokenId) public view returns (bool) {\n', '        address owner = owners[tokenId];\n', '        return (\n', '            operator == owner ||\n', '            operatorApprovals[owner][operator] ||\n', '            tokenApprovals[tokenId] == operator\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` from `from` to `to`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address from, address to, uint256 tokenId) internal {\n', '        require(owners[tokenId] == from, "Identity: Transfer of token that is not own");\n', '        require(to != address(0), "Identity: transfer to the zero address");\n', '\n', '        // Clear approvals from the previous owner\n', '        approve(address(0), tokenId);\n', '\n', '        owners[tokenId] = to;\n', '        balances[from] = balances[from].minus(1);\n', '        balances[to] = balances[to].plus(1);\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for non-contract addresses\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n', '     * The call is not executed if the target address is not a contract.\n', '     *\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param data bytes optional data to send along with the call\n', '     * @return bool whether the call correctly returned the expected magic value\n', '     */\n', '    function checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n', '        private returns (bool)\n', '    {\n', '        if (!isContract(to)) {\n', '            return true;\n', '        }\n', '        IERC721Receiver target = IERC721Receiver(to);\n', '        bytes4 retval = target.onERC721Received(from, to, tokenId, data);\n', '        return ERC721_RECEIVED == retval;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n', '        return (\n', '            interfaceId == INTERFACE_ID_ERC721 ||\n', '            interfaceId == INTERFACE_ID_ERC165\n', '        );\n', '    }\n', '\n', '}\n']
