['pragma solidity >0.5.99 <0.8.0;\n', '\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n']
['pragma solidity >0.5.99 <0.8.0;\n', '\n', 'import "./Owner.sol";\n', 'import "./SafeMath.sol";\n', 'import "./ERC20Interface.sol";\n', '\n', 'contract Tanga is ERC20Interface,SafeMath,Owner\n', '{\n', '    string private Token;\n', '    string private Abbrivation;\n', '    uint256 private decimals;\n', '    uint256 private totalsupply;\n', '    \n', '    \n', '    mapping(address => uint256) Balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '    \n', '    constructor() public\n', '    {\n', '        Token = "Tanga";\n', '        Abbrivation = "TGR";\n', '        decimals = 2;\n', '        totalsupply = 23000000000;\n', '        Balances[getOwner()] = 23000000000;\n', '    }\n', '    \n', '    \n', '    function totalSupply() public view override returns (uint256)\n', '    {\n', '        return totalsupply;\n', '    }\n', '    \n', '    function balanceOf(address tokenOwner) public override view returns (uint balance)\n', '    {\n', '        return Balances[tokenOwner];\n', '    }\n', '    \n', '    function allowance(address from, address who) isblacklisted(from) public override view returns (uint remaining)\n', '    {\n', '        return allowed[from][who];\n', '    }\n', '    \n', '    function transfer(address to, uint tokens) isblacklisted(msg.sender) public override returns (bool success)\n', '    {\n', '        Balances[msg.sender] = safeSub(Balances[msg.sender],tokens);\n', '        Balances[to] = safeAdd(Balances[to],tokens);\n', '       emit Transfer(msg.sender,to,tokens);\n', '        return true;\n', '    }\n', '    \n', '    function approve(address to, uint tokens) isblacklisted(msg.sender) public override returns (bool success)\n', '    {\n', '        allowed[msg.sender][to] = tokens;\n', '        emit Approval(msg.sender,to,tokens);\n', '        return true;\n', '    }\n', '    function transferFrom(address from, address to, uint tokens) isblacklisted(from) public override returns (bool success)\n', '    {\n', '        require(allowed[from][msg.sender] >= tokens ,"Not sufficient allowance");\n', '        Balances[from] = safeSub(Balances[from],tokens);\n', '        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender],tokens);\n', '        Balances[to] = safeAdd(Balances[to],tokens);\n', '        emit Transfer(from,to,tokens);\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '\n']
['pragma solidity >0.5.99 <0.8.0;\n', '\n', 'abstract contract  ERC20Interface {\n', '    function totalSupply() virtual public view returns (uint);\n', '    function balanceOf(address tokenOwner) virtual public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) virtual public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) virtual public returns (bool success);\n', '    function approve(address spender, uint tokens) virtual public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) virtual public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n']
['pragma solidity >0.5.99 <0.8.0;\n', '\n', '    contract Owner\n', '    {\n', '        address private _owner;\n', '        mapping(address=> bool) blacklist;\n', '        event AddToBlackList(address _blacklisted);\n', '        event RemoveFromBlackList(address _whitelisted);\n', '        constructor() public \n', '        {\n', '            _owner = msg.sender;\n', '        }\n', '        \n', '        function getOwner() public view returns(address) { return _owner; }\n', '        \n', '        modifier isOwner()\n', '        {\n', "            require(msg.sender == _owner,'Your are not Authorized user');\n", '            _;\n', '            \n', '        }\n', '        \n', '        modifier isblacklisted(address holder)\n', '        {\n', '            require(blacklist[holder] == false,"You are blacklisted");\n', '            _;\n', '        }\n', '        \n', '        function chnageOwner(address newOwner) isOwner() external\n', '        {\n', '            _owner = newOwner;\n', '        }\n', '        \n', '        function addtoblacklist (address blacklistaddress) isOwner()  public\n', '        {\n', '            blacklist[blacklistaddress] = true;\n', '            emit AddToBlackList(blacklistaddress);\n', '        }\n', '        \n', '        function removefromblacklist (address whitelistaddress) isOwner()  public\n', '        {\n', '            blacklist[whitelistaddress]=false;\n', '            emit RemoveFromBlackList(whitelistaddress);\n', '        }\n', '        \n', '        function showstateofuser(address _address) public view returns (bool)\n', '        {\n', '            return blacklist[_address];\n', '        }\n', '    }\n']
