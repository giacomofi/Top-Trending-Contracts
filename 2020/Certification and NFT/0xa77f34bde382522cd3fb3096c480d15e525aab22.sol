['pragma solidity 0.5.17;\n', '\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract LVTokenStorage {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    bool internal _notEntered;\n', '\n', '    string public name;\n', '\n', '    string public symbol;\n', '\n', '    uint8 public decimals;\n', '\n', '    address public gov;\n', '\n', '    address public pendingGov;\n', '\n', '    address public rebaser;\n', '\n', '    address public incentivizer;\n', '\n', '    uint256 public totalSupply;\n', '\n', '    uint256 public constant internalDecimals = 10**24;\n', '\n', '    uint256 public constant BASE = 10**18;\n', '\n', '    uint256 public lvsScalingFactor;\n', '\n', '    mapping (address => uint256) internal _lvBalances;\n', '\n', '    mapping (address => mapping (address => uint256)) internal _allowedFragments;\n', '\n', '    uint256 public initSupply;\n', '\n', '}\n', '\n', 'contract LVGovernanceStorage {\n', '    mapping (address => address) internal _delegates;\n', '    struct Checkpoint {\n', '        uint32 fromBlock;\n', '        uint256 votes;\n', '    }\n', '\n', '    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n', '    mapping (address => uint32) public numCheckpoints;\n', '    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");\n', '    bytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");\n', '    mapping (address => uint) public nonces;\n', '}\n', '\n', 'contract LVTokenInterface is LVTokenStorage, LVGovernanceStorage {\n', '    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n', '    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n', '    event Rebase(uint256 epoch, uint256 prevLvsScalingFactor, uint256 newLvsScalingFactor);\n', '    event NewPendingGov(address oldPendingGov, address newPendingGov);\n', '    event NewGov(address oldGov, address newGov);\n', '    event NewRebaser(address oldRebaser, address newRebaser);\n', '    event NewIncentivizer(address oldIncentivizer, address newIncentivizer);\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '    event Approval(address indexed owner, address indexed spender, uint amount);\n', '    event Mint(address to, uint256 amount);\n', '\n', '    function transfer(address to, uint256 value) external returns(bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns(bool);\n', '    function balanceOf(address who) external view returns(uint256);\n', '    function balanceOfUnderlying(address who) external view returns(uint256);\n', '    function allowance(address owner_, address spender) external view returns(uint256);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n', '    function maxScalingFactor() external view returns (uint256);\n', '\n', '    function getPriorVotes(address account, uint blockNumber) external view returns (uint256);\n', '    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\n', '    function delegate(address delegatee) external;\n', '    function delegates(address delegator) external view returns (address);\n', '    function getCurrentVotes(address account) external view returns (uint256);\n', '\n', '    function mint(address to, uint256 amount) external returns (bool);\n', '    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);\n', '    function _setRebaser(address rebaser_) external;\n', '    function _setIncentivizer(address incentivizer_) external;\n', '    function _setPendingGov(address pendingGov_) external;\n', '    function _acceptGov() external;\n', '}\n', '\n', 'contract LVGovernanceToken is LVTokenInterface {\n', '    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n', '    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n', '    function delegates(address delegator)\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return _delegates[delegator];\n', '    }\n', '\n', '    function delegate(address delegatee) external {\n', '        return _delegate(msg.sender, delegatee);\n', '    }\n', '\n', '    function delegateBySig(\n', '        address delegatee,\n', '        uint nonce,\n', '        uint expiry,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '        external\n', '    {\n', '        bytes32 domainSeparator = keccak256(\n', '            abi.encode(\n', '                DOMAIN_TYPEHASH,\n', '                keccak256(bytes(name)),\n', '                getChainId(),\n', '                address(this)\n', '            )\n', '        );\n', '\n', '        bytes32 structHash = keccak256(\n', '            abi.encode(\n', '                DELEGATION_TYPEHASH,\n', '                delegatee,\n', '                nonce,\n', '                expiry\n', '            )\n', '        );\n', '\n', '        bytes32 digest = keccak256(\n', '            abi.encodePacked(\n', '                "\\x19\\x01",\n', '                domainSeparator,\n', '                structHash\n', '            )\n', '        );\n', '\n', '        address signatory = ecrecover(digest, v, r, s);\n', '        require(signatory != address(0), "LV::delegateBySig: invalid signature");\n', '        require(nonce == nonces[signatory]++, "LV::delegateBySig: invalid nonce");\n', '        require(now <= expiry, "LV::delegateBySig: signature expired");\n', '        return _delegate(signatory, delegatee);\n', '    }\n', '    function getCurrentVotes(address account)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint32 nCheckpoints = numCheckpoints[account];\n', '        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n', '    }\n', '    function getPriorVotes(address account, uint blockNumber)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        require(blockNumber < block.number, "LV::getPriorVotes: not yet determined");\n', '\n', '        uint32 nCheckpoints = numCheckpoints[account];\n', '        if (nCheckpoints == 0) {\n', '            return 0;\n', '        }\n', '\n', '        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n', '            return checkpoints[account][nCheckpoints - 1].votes;\n', '        }\n', '\n', '        if (checkpoints[account][0].fromBlock > blockNumber) {\n', '            return 0;\n', '        }\n', '\n', '        uint32 lower = 0;\n', '        uint32 upper = nCheckpoints - 1;\n', '        while (upper > lower) {\n', '            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n', '            Checkpoint memory cp = checkpoints[account][center];\n', '            if (cp.fromBlock == blockNumber) {\n', '                return cp.votes;\n', '            } else if (cp.fromBlock < blockNumber) {\n', '                lower = center;\n', '            } else {\n', '                upper = center - 1;\n', '            }\n', '        }\n', '        return checkpoints[account][lower].votes;\n', '    }\n', '\n', '    function _delegate(address delegator, address delegatee)\n', '        internal\n', '    {\n', '        address currentDelegate = _delegates[delegator];\n', '        uint256 delegatorBalance = _lvBalances[delegator]; // balance of underlying LVs (not scaled);\n', '        _delegates[delegator] = delegatee;\n', '\n', '        emit DelegateChanged(delegator, currentDelegate, delegatee);\n', '\n', '        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n', '    }\n', '\n', '    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n', '        if (srcRep != dstRep && amount > 0) {\n', '            if (srcRep != address(0)) {\n', '                // decrease old representative\n', '                uint32 srcRepNum = numCheckpoints[srcRep];\n', '                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n', '                uint256 srcRepNew = srcRepOld.sub(amount);\n', '                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n', '            }\n', '\n', '            if (dstRep != address(0)) {\n', '                // increase new representative\n', '                uint32 dstRepNum = numCheckpoints[dstRep];\n', '                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n', '                uint256 dstRepNew = dstRepOld.add(amount);\n', '                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n', '            }\n', '        }\n', '    }\n', '\n', '    function _writeCheckpoint(\n', '        address delegatee,\n', '        uint32 nCheckpoints,\n', '        uint256 oldVotes,\n', '        uint256 newVotes\n', '    )\n', '        internal\n', '    {\n', '        uint32 blockNumber = safe32(block.number, "LV::_writeCheckpoint: block number exceeds 32 bits");\n', '\n', '        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n', '            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n', '        } else {\n', '            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n', '            numCheckpoints[delegatee] = nCheckpoints + 1;\n', '        }\n', '\n', '        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n', '    }\n', '\n', '    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n', '        require(n < 2**32, errorMessage);\n', '        return uint32(n);\n', '    }\n', '\n', '    function getChainId() internal pure returns (uint) {\n', '        uint256 chainId;\n', '        assembly { chainId := chainid() }\n', '        return chainId;\n', '    }\n', '}\n', '\n', 'contract LVToken is LVGovernanceToken {\n', '    modifier onlyGov() {\n', '        require(msg.sender == gov);\n', '        _;\n', '    }\n', '\n', '    modifier onlyRebaser() {\n', '        require(msg.sender == rebaser);\n', '        _;\n', '    }\n', '\n', '    modifier onlyMinter() {\n', '        require(msg.sender == rebaser || msg.sender == incentivizer || msg.sender == gov, "not minter");\n', '        _;\n', '    }\n', '\n', '    modifier validRecipient(address to) {\n', '        require(to != address(0x0));\n', '        require(to != address(this));\n', '        _;\n', '    }\n', '\n', '    function initialize(\n', '        string memory name_,\n', '        string memory symbol_,\n', '        uint8 decimals_\n', '    )\n', '        public\n', '    {\n', '        require(lvsScalingFactor == 0, "already initialized");\n', '        name = name_;\n', '        symbol = symbol_;\n', '        decimals = decimals_;\n', '    }\n', '    function maxScalingFactor()\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _maxScalingFactor();\n', '    }\n', '\n', '    function _maxScalingFactor()\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return uint256(-1) / initSupply;\n', '    }\n', '\n', '    function mint(address to, uint256 amount)\n', '        external\n', '        onlyMinter\n', '        returns (bool)\n', '    {\n', '        _mint(to, amount);\n', '        return true;\n', '    }\n', '\n', '    function _mint(address to, uint256 amount)\n', '        internal\n', '    {\n', '      totalSupply = totalSupply.add(amount);\n', '      uint256 lvValue = amount.mul(internalDecimals).div(lvsScalingFactor);\n', '      initSupply = initSupply.add(lvValue);\n', '      require(lvsScalingFactor <= _maxScalingFactor(), "max scaling factor too low");\n', '      _lvBalances[to] = _lvBalances[to].add(lvValue);\n', '      _moveDelegates(address(0), _delegates[to], lvValue);\n', '      emit Mint(to, amount);\n', '    }\n', '\n', '    function transfer(address to, uint256 value)\n', '        external\n', '        validRecipient(to)\n', '        returns (bool)\n', '    {\n', '        uint256 lvValue = value.mul(internalDecimals).div(lvsScalingFactor);\n', '        _lvBalances[msg.sender] = _lvBalances[msg.sender].sub(lvValue);\n', '        _lvBalances[to] = _lvBalances[to].add(lvValue);\n', '        emit Transfer(msg.sender, to, value);\n', '\n', '        _moveDelegates(_delegates[msg.sender], _delegates[to], lvValue);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value)\n', '        external\n', '        validRecipient(to)\n', '        returns (bool)\n', '    {\n', '        _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender].sub(value);\n', '        uint256 lvValue = value.mul(internalDecimals).div(lvsScalingFactor);\n', '        _lvBalances[from] = _lvBalances[from].sub(lvValue);\n', '        _lvBalances[to] = _lvBalances[to].add(lvValue);\n', '        emit Transfer(from, to, value);\n', '\n', '        _moveDelegates(_delegates[from], _delegates[to], lvValue);\n', '        return true;\n', '    }\n', '    function balanceOf(address who)\n', '      external\n', '      view\n', '      returns (uint256)\n', '    {\n', '      return _lvBalances[who].mul(lvsScalingFactor).div(internalDecimals);\n', '    }\n', '    function balanceOfUnderlying(address who)\n', '      external\n', '      view\n', '      returns (uint256)\n', '    {\n', '      return _lvBalances[who];\n', '    }\n', '    function allowance(address owner_, address spender)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _allowedFragments[owner_][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 value)\n', '        external\n', '        returns (bool)\n', '    {\n', '        _allowedFragments[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue)\n', '        external\n', '        returns (bool)\n', '    {\n', '        _allowedFragments[msg.sender][spender] =\n', '            _allowedFragments[msg.sender][spender].add(addedValue);\n', '        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue)\n', '        external\n', '        returns (bool)\n', '    {\n', '        uint256 oldValue = _allowedFragments[msg.sender][spender];\n', '        if (subtractedValue >= oldValue) {\n', '            _allowedFragments[msg.sender][spender] = 0;\n', '        } else {\n', '            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    function _setRebaser(address rebaser_)\n', '        external\n', '        onlyGov\n', '    {\n', '        address oldRebaser = rebaser;\n', '        rebaser = rebaser_;\n', '        emit NewRebaser(oldRebaser, rebaser_);\n', '    }\n', '\n', '    function _setIncentivizer(address incentivizer_)\n', '        external\n', '        onlyGov\n', '    {\n', '        address oldIncentivizer = incentivizer;\n', '        incentivizer = incentivizer_;\n', '        emit NewIncentivizer(oldIncentivizer, incentivizer_);\n', '    }\n', '\n', '    function _setPendingGov(address pendingGov_)\n', '        external\n', '        onlyGov\n', '    {\n', '        address oldPendingGov = pendingGov;\n', '        pendingGov = pendingGov_;\n', '        emit NewPendingGov(oldPendingGov, pendingGov_);\n', '    }\n', '\n', '    function _acceptGov()\n', '        external\n', '    {\n', '        require(msg.sender == pendingGov, "!pending");\n', '        address oldGov = gov;\n', '        gov = pendingGov;\n', '        pendingGov = address(0);\n', '        emit NewGov(oldGov, gov);\n', '    }\n', '\n', '    function rebase(\n', '        uint256 epoch,\n', '        uint256 indexDelta,\n', '        bool positive\n', '    )\n', '        external\n', '        onlyRebaser\n', '        returns (uint256)\n', '    {\n', '        if (indexDelta == 0) {\n', '          emit Rebase(epoch, lvsScalingFactor, lvsScalingFactor);\n', '          return totalSupply;\n', '        }\n', '\n', '        uint256 prevLvsScalingFactor = lvsScalingFactor;\n', '\n', '        if (!positive) {\n', '           lvsScalingFactor = lvsScalingFactor.mul(BASE.sub(indexDelta)).div(BASE);\n', '        } else {\n', '            uint256 newScalingFactor = lvsScalingFactor.mul(BASE.add(indexDelta)).div(BASE);\n', '            if (newScalingFactor < _maxScalingFactor()) {\n', '                lvsScalingFactor = newScalingFactor;\n', '            } else {\n', '              lvsScalingFactor = _maxScalingFactor();\n', '            }\n', '        }\n', '\n', '        totalSupply = initSupply.mul(lvsScalingFactor);\n', '        emit Rebase(epoch, prevLvsScalingFactor, lvsScalingFactor);\n', '        return totalSupply;\n', '    }\n', '}\n', '\n', 'contract LV is LVToken {\n', '    function initialize(\n', '        string memory name_,\n', '        string memory symbol_,\n', '        uint8 decimals_,\n', '        address initial_owner,\n', '        uint256 initSupply_\n', '    )\n', '        public\n', '    {\n', '        require(initSupply_ > 0, "0 init supply");\n', '\n', '        super.initialize(name_, symbol_, decimals_);\n', '\n', '        initSupply = initSupply_.mul(10**24/ (BASE));\n', '        totalSupply = initSupply_;\n', '        lvsScalingFactor = BASE;\n', '        _lvBalances[initial_owner] = initSupply_.mul(10**24 / (BASE));\n', '    }\n', '}']