['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.9;\n', '\n', '// After deploy and setup necessaries rules and addresses, need to change the Owner address to the GovernanceProxy address.\n', 'import "./Ownable.sol";\n', 'import "./EnumerableSet.sol";\n', '\n', 'interface IWhitelist {\n', '    function address_belongs(address _who) external view returns (address);\n', '    function getUserWallets(address _which) external view returns (address[] memory);\n', '}\n', '\n', 'interface IERC20Token {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '}\n', '\n', '// The GovernanceProxy contract address should be the Owner of other contracts which setting we will change.\n', 'interface IGovernanceProxy {\n', '    function trigger(address contr, bytes calldata params) external;\n', '    function acceptGovernanceAddress() external;\n', '}\n', '\n', 'contract Governance is Ownable {\n', '    using EnumerableSet for EnumerableSet.AddressSet;\n', '\n', '    EnumerableSet.AddressSet walletsCEO;    // wallets of CEO. It should participate in votes with Absolute majority, otherwise Escrowed wallets will not be counted.\n', '    uint256 public requiredCEO;             // number COE wallets require to participate in vote\n', '\n', '    IGovernanceProxy public governanceProxy;\n', '    IERC20Token[4] public tokenContract; // tokenContract[0] = MainToken, tokenContract[1] = ETN, tokenContract[2] = STOCK\n', "    IERC20Token[4] public escrowContract; // contract that hold (lock) investor's pre-minted tokens (0-Main, 1-ETN, 2-STOCK)\n", '    uint256[4] public circulationSupply;   // Circulation Supply of according tokens\n', '    uint256[4] public circulationSupplyUpdated; // timestamp when Circulation Supply was updated\n', '    IWhitelist public whitelist;    // whitelist contract\n', '    uint256 public closeTime;   // timestamp when votes will close\n', '    uint256 public expeditedLevel = 10; // user who has this percentage of Main token circulation supply can expedite voting\n', '    uint256 public absoluteLevel = 90; // this percentage of participants voting power considering as Absolute Majority\n', '\n', '    enum Vote {None, Yea, Nay}\n', '    enum Status {New, Canceled, Approved, Rejected, Pending}\n', '\n', '    struct Rule {\n', '        address contr;      // contract address which have to be triggered\n', '        uint8[4] majority;  // require more than this percentage of participants voting power (in according tokens).\n', '        string funcAbi;     // function ABI (ex. "setGroupBonusRatio(uint256)")\n', '    }\n', '\n', '    Rule[] rules;\n', '\n', '    struct Ballot {\n', '        uint256 closeVote; // timestamp when vote will close\n', '        uint256 ruleId; // rule which edit\n', '        bytes args; // ABI encoded arguments for proposal which is required to call appropriate function\n', '        Status status;\n', '        address creator;    // wallet address of ballot creator.\n', '        uint256[4] votesYea;  // YEA votes according communities (tokens)\n', '        uint256[4] totalVotes;  // The total voting power od all participant according communities (tokens)\n', '        address[] participant;  // the users who voted (primary address)\n', '        uint256 processedParticipants; // The number of participant that was verified. Uses to split verification on many transactions\n', '        mapping (address => Vote) votes; //Vote: Yea or Nay. If None -the user did not vote.\n', '        mapping (address => mapping (uint256 => uint256)) power;   // Voting power. primary address => community index => voting power\n', '        uint256 ceoParticipate; //number of ceo wallets participated at voting\n', '    }\n', '\n', '    Ballot[] ballots;\n', '\n', '    uint256 public unprocessedBallot; // The start index of ballots which are unprocessed and maybe ready for vote.\n', '\n', '    mapping (address => bool) public blockedWallets;    // The wallets which are excluded from voting\n', '    mapping (uint256 => mapping(address => bool)) public isInEscrow;    // The wallets which may has pre-minted tokens. Token index => wallet\n', '    mapping (uint256 => address[]) excluded; // The list of address that should be subtracted from TotalSupply to calculate Circulation Supply.\n', '                                             // ex. Company wallet, Downside protection, Vault smart contract.\n', '\n', '    event AddRule(address indexed contractAddress, string funcAbi, uint8[4] majorMain);\n', '    event SetNewAddress(address indexed previousAddress, address indexed newAddress);\n', '    event BlockWallet(address indexed walletAddress, bool isAdded);\n', '    event AddBallot(address indexed creator, uint256 indexed ruleId, uint256 indexed ballotId);\n', '    event ExpeditedBallot(uint256 indexed ballotId, uint256 indexed closeTime);\n', '    event ApplyBallot(uint256 indexed ruleId, uint256 indexed ballotId);\n', '    event NewVote(address indexed voter, address indexed primary, uint256 indexed ballotId);\n', '    event ChangeVote(address indexed voter, address indexed primary, uint256 indexed ballotId);\n', '    event PosableMajority(uint256 indexed ballotId);\n', '    event CEOWallet(address indexed wallet, bool add);\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the one of COE wallets.\n', '     */\n', '    modifier onlyCEO() {\n', '        require(walletsCEO.contains(msg.sender),"Not CEO");\n', '        _;\n', '    }\n', '\n', '    constructor(address CEO_wallet) public {\n', '        require(CEO_wallet != address(0),"Zero address not allowed");\n', '        // add rule with Absolute majority (above 90% participants) which allow to add another rules\n', '        rules.push(Rule(address(this), [90,0,0,0], "addRule(address,uint8[4],string)"));\n', '        walletsCEO.add(CEO_wallet);\n', '        requiredCEO = 1;\n', '    }\n', '\n', '\n', '    function addCEOWallet(address CEO_wallet) external onlyCEO {\n', '        require(CEO_wallet != address(0),"Zero address not allowed");\n', '        walletsCEO.add(CEO_wallet);\n', '        requiredCEO = walletsCEO.length();\n', '        emit CEOWallet(CEO_wallet, true);\n', '    }\n', '\n', '    function removeCEOWallet(address CEO_wallet) external onlyCEO {\n', '        require(CEO_wallet != address(0),"Zero address not allowed");\n', '        require(walletsCEO.length() > 1, "Should left at least one CEO wallet");\n', '        walletsCEO.remove(CEO_wallet);\n', '        requiredCEO = walletsCEO.length();\n', '        emit CEOWallet(CEO_wallet, false);\n', '    }\n', '\n', '    function setRequiredCEO(uint256 req) external onlyCEO {\n', '        require(req <= walletsCEO.length(),"More then added wallets");\n', '        requiredCEO = req;\n', '    }\n', '\n', '    function getWalletsCEO() external view returns(address[] memory wallets) {\n', '        return walletsCEO._values;\n', '    }\n', '\n', '    /**\n', '     * @dev Accept Governance in case changing voting contract.\n', '     */    \n', '    function acceptGovernanceAddress() external onlyOwner {\n', '        governanceProxy.acceptGovernanceAddress();\n', '    }\n', '\n', '    /**\n', '     * @dev Calculation Supply = Total Supply - Total balance on Excluded wallets.\n', '     * @param index The index of token (0 - Main, 1 - ETN, 2 - STOCK).\n', '     * @return list of excluded address.\n', '     */\n', '    function getExcluded(uint256 index) external view returns(address[] memory) {\n', '        require(index >= 0 && index < 4, "Wrong index");\n', '        return excluded[index];\n', '    }\n', '\n', '    /**\n', '     * @dev Add addresses to excluded list\n', '     * @param index The index of token (0 - Main, 1 - ETN, 2 - STOCK).\n', '     * @param wallet List of addresses to add\n', '     */\n', '    function addExcluded(uint256 index, address[] memory wallet) external onlyOwner {\n', '        require(index >= 0 && index < 4, "Wrong index");\n', '        for (uint i = 0; i < wallet.length; i++) {\n', '            require(wallet[i] != address(0),"Zero address not allowed");\n', '            excluded[index].push(wallet[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Remove addresses from excluded list\n', '     * @param index The index of token (0 - Main, 1 - ETN, 2 - STOCK).\n', '     * @param wallet The address to remove\n', '     */\n', '    function removeExcluded(uint256 index, address wallet) external onlyOwner {\n', '        require(index >= 0 && index < 4, "Wrong index");\n', '        require(wallet != address(0),"Zero address not allowed");\n', '        uint len = excluded[index].length;\n', '        for (uint i = 0; i < len; i++) {\n', '            if (excluded[index][i] == wallet) {\n', '                excluded[index][i] = excluded[index][len-1];\n', '                excluded[index].pop();\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Set percentage of participants voting power considering as Absolute Majority\n', '     * @param level The percentage\n', '     */\n', '    function setAbsoluteLevel(uint256 level) external onlyOwner {\n', '        require(level > 50 && level <= 100, "Wrong level");\n', '        absoluteLevel = level;\n', '    }\n', '\n', '    /**\n', '     * @dev Set percentage of total circulation that allows user to expedite proposal\n', '     * @param level The percentage\n', '     */\n', '    function setExpeditedLevel(uint256 level) external onlyOwner {\n', '        require(level >= 1 && level <= 100, "Wrong level");\n', '        expeditedLevel = level;\n', '    }\n', '\n', '    /**\n', '     * @dev Add/Remove address from the list of wallets which is disallowed to vote.\n', '     * @param wallet The address to add or remove.\n', '     * @param add Add to the list if true (1) or remove from the list if false (0).\n', '     */\n', '    function manageBlockedWallet(address wallet, bool add) external onlyOwner {\n', '        emit BlockWallet(wallet, add);\n', '        blockedWallets[wallet] = add;\n', '    }\n', '\n', '    /**\n', '     * @dev Set token contract address.\n', '     * @param token The address of token contract.\n', '     * @param index The index of token: 0 - Main, 1 - ETN, 2 - STOCK.\n', '     */\n', '    function setTokenContract(IERC20Token token, uint index) external onlyOwner {\n', '        require(token != IERC20Token(0) && tokenContract[index] == IERC20Token(0),"Change address not allowed");\n', '        tokenContract[index] = token;\n', '    }\n', '\n', '    /**\n', '     * @dev Set Escrow contract address, where pre-minted tokens locked (index of token: 0 - Main, 1 - ETN, 2 - STOCK).\n', '     * @param escrow The address of token contract.\n', '     * @param index The index of token: 0 - Main, 1 - ETN, 2 - STOCK.\n', '     */\n', '    function setEscrowContract(IERC20Token escrow, uint index) external onlyOwner {\n', '        require(escrow != IERC20Token(0),"Change address not allowed");\n', '        escrowContract[index] = escrow;\n', '    }\n', '\n', '    /**\n', '     * @dev Set whitelist contract address to a newAddr.\n', '     * @param newAddr The address of whitelist contract.\n', '     */\n', '    function setWhitelist(address newAddr) external onlyOwner {\n', '        require(newAddr != address(0),"Zero address not allowed");\n', '        emit SetNewAddress(address(whitelist), newAddr);\n', '        whitelist = IWhitelist(newAddr);\n', '    }\n', '\n', '    /**\n', '     * @dev Set Governance Proxy contract address to a newAddr.\n', '     * @param newAddr The address of Governance Proxy contract.\n', '     */\n', '    function setGovernanceProxy(address newAddr) external onlyOwner {\n', '        require(newAddr != address(0),"Zero address not allowed");\n', '        emit SetNewAddress(address(governanceProxy), newAddr);\n', '        governanceProxy = IGovernanceProxy(newAddr);\n', '    }\n', '\n', '    /**\n', '     * @dev Update time when new votes will close. Should be called after 00:00:00 UTC 1st day of each month\n', '     */\n', '    function updateCloseTime() external {\n', '        require(closeTime < block.timestamp, "Wait for 1st day of month"); // close time is not passed\n', '        (uint year, uint month, uint day) = timestampToDate(block.timestamp);\n', '        day = 1;\n', '        if (month == 12) {\n', '            year++;\n', '            month = 1;\n', '        }\n', '        else {\n', '            month++;\n', '        }\n', '        closeTime = timestampFromDateTime(year, month, day, 0, 0, 0);    // 1st day of each month at 00:00:00 UTC\n', '        uint len = ballots.length;\n', '        for (uint i = unprocessedBallot; i < len; i++) {\n', '            if (ballots[i].status == Status.Pending) {\n', '                if(ballots[i].closeVote == 0)\n', '                    ballots[i].closeVote = closeTime;\n', '                else\n', '                    ballots[i].closeVote += closeTime; // Expedited vote\n', '                ballots[i].status = Status.New;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Add wallet that received pre-minted tokens.\n', '     * @param wallet The address of wallet.\n', '     * @return true if address added.\n', '     */\n', '    function addPremintedWallet(address wallet) external returns(bool){\n', '        for (uint i = 0; i < 4; i++ ) {\n', '            if(address(escrowContract[i]) == msg.sender) {\n', '                isInEscrow[i][wallet] = true;\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Add new rule - function that call target contract to change setting.\n', '     * @param contr The contract address which have to be triggered\n', '     * @param majority The majority level (%) for the tokens (index: 0 - Main, 1 - ETN, 2 - STOCK).\n', '     * @param funcAbi The function ABI (ex. "setGroupBonusRatio(uint256)")\n', '     */\n', '    function addRule(\n', '            address contr,\n', '            uint8[4] memory majority,\n', '            string memory funcAbi\n', '        ) external onlyOwner {\n', '        require(contr != address(0), "Zero address");\n', '        rules.push(Rule(contr, majority, funcAbi));\n', '        emit AddRule(contr, funcAbi, majority);\n', '    }\n', '\n', '    /**\n', '     * @dev Change majority levels of rules.\n', '     * @param ruleId The rules index\n', '     * @param majority The majority level (%) for the tokens (index: 0 - Main, 1 - ETN, 2 - STOCK).\n', '     */\n', '    function changeRuleMajority(uint256 ruleId, uint8[4] memory majority) external onlyOwner {\n', '        Rule storage r = rules[ruleId];\n', '        r.majority = majority;\n', '    }\n', '\n', '    /**\n', '     * @dev Change destination contract address of rules.\n', '     * @param ruleId The rules index\n', '     * @param contr The new contract address of selected rule.\n', '     */\n', '    function changeRuleAddress(uint256 ruleId, address contr) external onlyOwner {\n', '        require(contr != address(0), "Zero address");\n', '        Rule storage r = rules[ruleId];\n', '        r.contr = contr;\n', '    }\n', '\n', '    /**\n', '     * @dev Get total number of rules.\n', '     * @return The total number of rules.\n', '     */\n', '    function getTotalRules() external view returns(uint256) {\n', '        return rules.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Get rules details.\n', '     * @param ruleId The rules index\n', '     * @return contr The contract address\n', '     * @return majority The level of majority in according tokens\n', '     * @return funcAbi The function Abi\n', '     */\n', '    function getRule(uint256 ruleId) external view\n', '        returns(address contr,\n', '        uint8[4] memory majority,\n', '        string memory funcAbi)\n', '    {\n', '        Rule storage r = rules[ruleId];\n', '        return (r.contr, r.majority, r.funcAbi);\n', '    }\n', '\n', '    /**\n', '     * @dev Get total number of ballots.\n', '     * @return The total number of ballots.\n', '     */\n', '    function getTotalBallots() external view returns(uint256) {\n', '        return ballots.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Get ballot details. Uses to show the list of available proposal for voting\n', '     * @param ballotId The ballot index\n', '     * @return closeVote\n', '     * @return ruleId\n', '     * @return args\n', '     * @return status\n', '     * @return creator\n', '     * @return totalVotes\n', '     * @return votesYea\n', '     */\n', '    function getBallot(uint256 ballotId)\n', '        external view returns(\n', '        uint256 closeVote,\n', '        uint256 ruleId,\n', '        bytes memory args,\n', '        Status status,\n', '        address creator,\n', '        uint256[4] memory totalVotes,\n', '        uint256[4] memory votesYea)\n', '    {\n', '        Ballot storage b = ballots[ballotId];\n', '        return (b.closeVote, b.ruleId, b.args, b.status, b.creator,b.totalVotes,b.votesYea);\n', '    }\n', '\n', '    /**\n', '     * @dev Get number of participants who vote for ballot.\n', '     * @param ballotId The ballot index\n', '     * @return number of participants who take pert in voting\n', '     */\n', '    function getParticipantsNumber(uint256 ballotId) external view returns(uint256) {\n', '        return ballots[ballotId].participant.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Get number of participant who vote for ballot.\n', '     * @param ballotId The ballot index\n', '     * @param start The start position (index) to return data.\n', '     * @param number The number of records (positions) to return.\n', '     * @return participants The list of participant primary addresses\n', '     * @return mainVotes The ist of voting power in main (JNTR) tokens\n', '     * @return etnVotes The ist of voting power in ETN tokens\n', '     * @return stockVotes The ist of voting power in Stock tokens\n', '     * @return votes The list of votes (1 -Yea, 2 -Nay).\n', '     */\n', '    function getParticipants(uint256 ballotId, uint256 start, uint256 number) external view\n', '        returns(address[] memory participants,\n', '        uint256[] memory mainVotes,\n', '        uint256[] memory etnVotes,\n', '        uint256[] memory stockVotes,\n', '        Vote[] memory votes)\n', '    {\n', '        Ballot storage b = ballots[ballotId];\n', '        participants = new address[](number);\n', '        mainVotes = new uint256[](number);\n', '        etnVotes = new uint256[](number);\n', '        stockVotes = new uint256[](number);\n', '        votes = new Vote[](number);\n', '        uint256 len = number;\n', '        if (start + number > b.participant.length)\n', '            len = b.participant.length - start;\n', '        for(uint i = 0; i < len; i++) {\n', '            participants[i] = b.participant[start + i];\n', '            mainVotes[i] = b.power[participants[i]][0]; // voting power in community A (Main token)\n', '            etnVotes[i] = b.power[participants[i]][1]; // voting power in community B (ETN token)\n', '            stockVotes[i] = b.power[participants[i]][2]; // voting power in community C (STOCK token)\n', '            votes[i] = b.votes[participants[i]];\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Create new proposal (ballot)\n', '     * @param ruleId The rule id which parameter propose to change.\n', '     * @param args The list of parameters.\n', '     * @param isExpedited The proposal should be expedited if user have more then 10% of circulation supply.\n', '     */\n', '    function createBallot(uint256 ruleId, bytes memory args, bool isExpedited) external {\n', '        require(ruleId < rules.length,"Wrong rule ID");\n', '        Rule storage r = rules[ruleId];\n', '        _getCirculation(r.majority);   //require update circulationSupply of Main token\n', '        (address primary, uint256[4] memory power) = _getVotingPower(msg.sender, r.majority, false, true);\n', '        uint256 highestPercentage;\n', '        for (uint i = 0; i < 4; i++) {\n', '            if (circulationSupply[i] > 0) {\n', '                uint256 percentage = power[i] * 100 / circulationSupply[i]; // ownership percentage of token\n', '                if (percentage > highestPercentage) highestPercentage = percentage;\n', '            }\n', '        }\n', '        require(highestPercentage > 0, "Less then 1% of circulationSupply");\n', '        uint256 ballotId = ballots.length;\n', '        Ballot memory b;\n', '        b.ruleId = ruleId;\n', '        b.args = args;\n', '        b.creator = msg.sender;\n', '        b.votesYea = power;\n', '        b.totalVotes = power;\n', '\n', '        if(highestPercentage >= expeditedLevel && isExpedited && r.majority[0] < absoluteLevel) {\n', '            // proposal can be expedited if user has 10% of Main token circulation supply\n', '            // and requiring majority is less then 90%\n', '            b.closeVote = 24 hours;\n', '        }\n', '\n', '        if (block.timestamp + 24 hours <= closeTime) {\n', '            if(b.closeVote == 0)\n', '                b.closeVote = closeTime;\n', '            else {\n', '                b.closeVote += block.timestamp; // Expedited vote\n', '                emit ExpeditedBallot(ballotId, b.closeVote);\n', '            }\n', '        }\n', '        else {\n', '            b.status = Status.Pending;\n', '        }\n', '        ballots.push(b);\n', '        emit AddBallot(msg.sender, ruleId, ballotId);\n', '        // Add vote Yea\n', '        ballots[ballotId].participant.push(primary); // add creator primary address as participant\n', '        ballots[ballotId].votes[primary] = Vote.Yea;\n', '        for (uint i = 0; i < 4; i++) {\n', '            if (power[i] > 0) {\n', '                ballots[ballotId].power[primary][i] = power[i];\n', '            }\n', '        }\n', '        emit NewVote(msg.sender, primary, ballotId);\n', '\n', '        if (highestPercentage >= 50) {\n', '            // Check creator voting power for majority 50%+1 of total circulation supply\n', '            if (_checkMajority(r.majority, power, power, false) == Vote.Yea) { // check Instant execution\n', '                ballots[ballotId].status = Status.Approved;\n', '                _executeBallot(ballotId);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Cancel proposal.\n', '     * @param ballotId The ballot index\n', '     */\n', '    function cancelBallot(uint256 ballotId) external {\n', '        require(ballotId < ballots.length,"Wrong ballot ID");\n', '        Ballot storage b = ballots[ballotId];\n', '        require(msg.sender == b.creator,"Only creator can cancel");\n', '        b.closeVote = block.timestamp;\n', '        b.status = Status.Canceled;\n', '        if (unprocessedBallot == ballotId) unprocessedBallot++;\n', '    }\n', '\n', '    /**\n', '     * @dev Vote for proposal.\n', '     * @param ballotId The ballot index\n', '     * @param v The user vote (1 - Yea, 2 - Nay)\n', '     */\n', '    function vote(uint256 ballotId, Vote v) external {\n', '        require(ballotId < ballots.length,"Wrong ballot ID");\n', '        Ballot storage b = ballots[ballotId];\n', '        require(v != Vote.None, "Should vote Yea or Nay");\n', '        require(b.status == Status.New, "Voting for disallowed");\n', '        require(b.closeVote > block.timestamp, "Ballot expired");\n', '        (address primary, uint256[4] memory power) = _getVotingPower(msg.sender, rules[b.ruleId].majority, false, true);\n', '        if (b.votes[primary] == Vote.None) {\n', '            // Add vote\n', '            b.participant.push(primary); // add creator primary address as participant\n', '            b.votes[primary] = v;\n', '            for (uint i = 0; i < 4; i++) {\n', '                if (power[i] > 0) {\n', "                    b.power[primary][i] = power[i];  // store user's voting power\n", '                    b.totalVotes[i] += power[i];\n', '                    if (v == Vote.Yea)\n', '                        b.votesYea[i] += power[i];\n', '                }\n', '            }\n', '            // add CEO wallet as participant only for Absolute majority voting\n', '            if (rules[b.ruleId].majority[0] >= absoluteLevel && walletsCEO.contains(msg.sender)) {\n', '                b.ceoParticipate++;\n', '            }\n', '            emit NewVote(msg.sender, primary, ballotId);\n', '        }\n', '        else if (b.votes[primary] != v) {\n', '            // Change vote\n', '            b.votes[primary] = v;\n', '            for (uint i = 0; i < 4; i++) {\n', '                if (power[i] > 0) {\n', '                    if (v == Vote.Yea)\n', '                        b.votesYea[i] += power[i];\n', '                    else\n', '                        b.votesYea[i] -= b.power[primary][i];   // remove previous votes\n', '                    b.totalVotes[i] = b.totalVotes[i] + power[i] - b.power[primary][i];\n', "                    b.power[primary][i] = power[i];  // store user's voting power\n", '                }\n', '            }\n', '            emit ChangeVote(msg.sender, primary, ballotId);\n', '        }\n', '\n', '        if (_checkMajority(rules[b.ruleId].majority, b.votesYea, b.totalVotes, false) != Vote.None) { // check Instant execution\n', '            // Server-side may watch for PosableMajority event.\n', '            // If it emitted the server-side may call verify function to apply changes without waiting voting close.\n', '            emit PosableMajority(ballotId);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Verify voting. Can be called many times if there are too many participants which cause Out of Gas error.\n', '     * @param ballotId The ballot index\n', '     * @param part The number of participant to verify. Uses to avoid Out of Gas.\n', '     */\n', '    function verify(uint256 ballotId, uint part) external {\n', '        _verify(ballotId, part);\n', '    }\n', '\n', '    /**\n', '     * @dev Verify next unverified voting. Can be called many times if there are too many participants which cause Out of Gas error.\n', '     * @param part The number of participant to verify. Uses to avoid Out of Gas.\n', '     */\n', '    function verifyNext(uint part) external {\n', '        uint len = ballots.length;\n', '        for (uint i = unprocessedBallot; i < len; i++) {\n', '            if (ballots[i].status == Status.New) {\n', '                _verify(i, part);\n', '                return; // exit after verification to avoid Out of Gas error\n', '            }\n', '            else if (ballots[i].status != Status.Pending && unprocessedBallot == i)\n', '                unprocessedBallot++;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate Circulation Supply = Total supply - sum(excluded addresses balance)\n', '     */\n', '    function getCirculation() external {\n', '        uint8[4] memory m;\n', '        for (uint i = 0; i < 4; i++) {\n', '            if (tokenContract[i] != IERC20Token(0))\n', '                m[i] = 50;\n', '        }\n', '        _getCirculation(m);\n', '    }\n', '\n', '    /**\n', '     * @dev Apply changes from ballot.\n', '     * @param ballotId The ballot index\n', '     */\n', '    function _executeBallot(uint256 ballotId) internal {\n', '        require(ballots[ballotId].status == Status.Approved,"Ballot is not Approved");\n', '        Ballot storage b = ballots[ballotId];\n', '        Rule storage r = rules[b.ruleId];\n', '        bytes memory command;\n', '        command = abi.encodePacked(bytes4(keccak256(bytes(r.funcAbi))), b.args);\n', '        governanceProxy.trigger(r.contr, command);\n', '        b.closeVote = block.timestamp;\n', '        if (unprocessedBallot == ballotId) unprocessedBallot++;\n', '        emit ApplyBallot(b.ruleId, ballotId);\n', '    }\n', '\n', '    /**\n', '     * @dev Verify voting. Can be called many times if there are too many participants which cause Out of Gas error.\n', '     * @param ballotId The ballot index\n', '     * @param part The number of participant to verify. Uses to avoid Out of Gas.\n', '     */\n', '    function _verify(uint256 ballotId, uint part) internal {\n', '        require(ballotId < ballots.length,"Wrong ballot ID");\n', '        Ballot storage b = ballots[ballotId];\n', '        Rule storage r = rules[b.ruleId];\n', '        require(b.status == Status.New, "Can not be verified");\n', '        uint256[4] memory totalVotes;\n', '        uint256[4] memory totalYea;\n', '        if (b.processedParticipants > 0) {  // continue verification\n', '            totalVotes = b.totalVotes;\n', '            totalYea = b.votesYea;\n', '        }\n', '        uint256 len = b.processedParticipants + part;\n', '        if (len > b.participant.length || b.closeVote > block.timestamp) // if voting is not closed only etire number of participants should be count\n', '            len = b.participant.length;\n', '        bool acceptEscrowed = true;\n', '        if (r.majority[0] >= absoluteLevel && b.ceoParticipate < requiredCEO)  // only for Absolute majority voting\n', '            acceptEscrowed = false; // reject escrowed wallets if CED did not vote with required number of wallets\n', '        for (uint i = b.processedParticipants; i < len; i++) {\n', '            (address primary, uint256[4] memory power) = _getVotingPower(b.participant[i], r.majority, true, acceptEscrowed);\n', '            for (uint j = 0; j < 4; j++) {\n', '                if (power[j] > 0) {\n', '                    totalVotes[j] += power[j];\n', '                    if (b.votes[primary] == Vote.Yea){\n', '                        totalYea[j] += power[j];\n', '                    }\n', '                }\n', "                b.power[primary][j] = power[j]; // store user's voting power\n", '            }\n', '        }\n', '        b.processedParticipants = len;\n', '        b.votesYea = totalYea;\n', '        b.totalVotes = totalVotes;\n', '        Vote result;\n', '        if (len == b.participant.length) {\n', '            // Check Absolute majority at first\n', '            _getCirculation(r.majority);\n', '            if (b.closeVote < block.timestamp) // if vote closed\n', '            {\n', '                result = _checkMajority(r.majority, totalYea, totalVotes, true);\n', '                if (result == Vote.None) result = Vote.Nay; // if no required majority then reject proposal\n', '            }\n', '            else\n', '                result = _checkMajority(r.majority, totalYea, totalVotes, false);  // Check majority for instant execution\n', '            if (result == Vote.Yea) {\n', '                b.status = Status.Approved;\n', '                _executeBallot(ballotId);\n', '            }\n', '            else if (result == Vote.Nay) {\n', '                b.status = Status.Rejected;\n', '                b.closeVote = block.timestamp;\n', '                if (unprocessedBallot == ballotId) unprocessedBallot++;\n', '            }\n', '            else\n', '                b.processedParticipants = 0; //continue voting and reset counter to be able recount votes\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate Circulation Supply = Total supply - sum(excluded addresses balance).\n', '     * @param tokensApply if element of array = 0 then exclude that token (index: 0 = MainToken, 1 = ETN, 2 = STOCK)\n', '     * @param votesYea The total voting power said Yea.\n', '     * @param totalVotes The total voting power of all participants.\n', '     * @param isClosed the voting is closed\n', '     * @return result the majority Yea (1), Nay (2) in case absolute majority, or None (0) if no majority.\n', '    */\n', '    function _checkMajority(\n', '        uint8[4] memory tokensApply,\n', '        uint256[4] memory votesYea,\n', '        uint256[4] memory totalVotes,\n', '        bool isClosed)\n', '        internal view returns(Vote result)\n', '    {\n', '        uint256 majorityYea;\n', '        uint256 majorityNay;\n', '        uint256 requireMajority;\n', '        for (uint i = 0; i < 4; i++) {\n', '            if (tokensApply[i] != 0) {\n', '                requireMajority++;\n', '                // check majority of circulation supply at first\n', '                if (votesYea[i] * 2 > circulationSupply[i])\n', '                    majorityYea++;   // the voting power is more then 50% of circulation supply\n', '                else if ((totalVotes[i]-votesYea[i]) * 2 > circulationSupply[i])\n', '                    majorityNay++;   // the voting power is more then 50% of circulation supply\n', '                else if (isClosed && votesYea[i] > totalVotes[i] * tokensApply[i] / 100)\n', '                    majorityYea++;   // the voting power is more then require of all participants total votes power\n', '            }\n', '        }\n', '        if (majorityYea == requireMajority) result = Vote.Yea;\n', '        else if (majorityNay == requireMajority) result = Vote.Nay;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate Circulation Supply = Total supply - sum(excluded addresses balance)\n', '     * @param tokensApply if element of array = 0 then exclude that token (index: 0 = MainToken, 1 = ETN, 2 = STOCK)\n', '     */\n', '    function _getCirculation(uint8[4] memory tokensApply) internal {\n', '        uint256[4] memory total;\n', '        for (uint i = 0; i < 4; i++) {\n', '            if (tokensApply[i] != 0 && circulationSupplyUpdated[i] != block.timestamp) {\n', '                uint len = excluded[i].length;\n', '                for (uint j = 0; j < len; j++) {\n', '                    total[i] += tokenContract[i].balanceOf(excluded[i][j]);\n', '                    if (escrowContract[i] != IERC20Token(0) && isInEscrow[i][excluded[i][j]]) {\n', '                        total[i] += escrowContract[i].balanceOf(excluded[i][j]);\n', '                    }\n', '                }\n', '                uint256 t = IERC20Token(tokenContract[i]).totalSupply();\n', '                require(t >= total[i], "Total Supply less then accounts balance");\n', '                circulationSupply[i] = t - total[i];\n', '                circulationSupplyUpdated[i] = block.timestamp;  // timestamp when circulationSupply updates\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate Voting Power of voter in provided communities (tokens)\n', '     * @param voter The wallet address of voter.\n', '     * @param tokensApply if element of array = 0 then exclude that token (index: 0 = MainToken, 1 = ETN, 2 = STOCK)\n', '     * @param isPrimary is true when voter address is primary address. Uses in verify function.\n', '     * @return primary - The primary address the wallet belong.\n', '     * @return votingPower - the voting power according communities.\n', '     */\n', '    function _getVotingPower(address voter, uint8[4] memory tokensApply, bool isPrimary, bool acceptEscrowed) internal view\n', '        returns(address primary, uint256[4] memory votingPower)\n', '    {\n', '        if (isPrimary)\n', '            primary = voter;\n', '        else\n', '            primary = whitelist.address_belongs(voter);\n', '        require (!blockedWallets[primary], "Wallet is blocked for voting");\n', '        address[] memory userWallets;\n', '        if (primary != address(0)) {\n', '            userWallets = whitelist.getUserWallets(primary);\n', '        }\n', '        else {\n', '            primary = voter;\n', '            userWallets = new address[](0);\n', '        }\n', '        bool hasPower = false;\n', '    \n', '        for (uint i = 0; i < 4; i++) {\n', '            if (tokensApply[i] != 0) {\n', '                votingPower[i] += tokenContract[i].balanceOf(primary);\n', '                if (acceptEscrowed && escrowContract[i] != IERC20Token(0) && isInEscrow[i][primary]) {\n', '                    votingPower[i] += escrowContract[i].balanceOf(primary);\n', '                }\n', '                for(uint j = 0; j < userWallets.length; j++) {\n', '                    votingPower[i] += tokenContract[i].balanceOf(userWallets[j]);\n', '                    if (acceptEscrowed && escrowContract[i] != IERC20Token(0) && isInEscrow[i][userWallets[j]]) {\n', '                        votingPower[i] += escrowContract[i].balanceOf(userWallets[j]);\n', '                    }\n', '                }\n', '                if (votingPower[i] > 0) hasPower = true;\n', '            }\n', '        }\n', '        require(isPrimary || hasPower, "No voting power");\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate number of days from 1/1/1970 to selected date.\n', '     * @param year The year number\n', '     * @param month The month number\n', '     * @param day The day number\n', '     * @return _days number of day.\n', '     */\n', '    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n', '        require(year >= 1970);\n', '        int _year = int(year);\n', '        int _month = int(month);\n', '        int _day = int(day);\n', '\n', '        int __days = _day\n', '          - 32075\n', '          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n', '          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n', '          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n', '          - 2440588;\n', '\n', '        _days = uint(__days);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate timestamp (UNIX time) of selected date and time.\n', '     * @param year The year number\n', '     * @param month The month number\n', '     * @param day The day number\n', '     * @param hour number of hours\n', '     * @param minute number of minutes\n', '     * @param second number of seconds\n', '     * @return timestamp UNIX time\n', '     */\n', '    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n', '        timestamp = _daysFromDate(year, month, day) * 86400 + hour * 3600 + minute * 60 + second;\n', '    }\n', '\n', '    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n', '        int __days = int(_days);\n', '\n', '        int L = __days + 68569 + 2440588;\n', '        int N = 4 * L / 146097;\n', '        L = L - (146097 * N + 3) / 4;\n', '        int _year = 4000 * (L + 1) / 1461001;\n', '        L = L - 1461 * _year / 4 + 31;\n', '        int _month = 80 * L / 2447;\n', '        int _day = L - 2447 * _month / 80;\n', '        L = _month / 11;\n', '        _month = _month + 2 - 12 * L;\n', '        _year = 100 * (N - 49) + _year + L;\n', '\n', '        year = uint(_year);\n', '        month = uint(_month);\n', '        day = uint(_day);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate date from timestamp (UNIX time) .\n', '     * @param timestamp UNIX time\n', '     * @return year The year number\n', '     * @return month The month number\n', '     * @return day The day number\n', '     */\n', '    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n', '        (year, month, day) = _daysToDate(timestamp / 86400);\n', '    }\n', '}\n']
['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.9;\n', '\n', '/**\n', ' * @dev Library for managing\n', ' * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n', ' * types.\n', ' *\n', ' * Sets have the following properties:\n', ' *\n', ' * - Elements are added, removed, and checked for existence in constant time\n', ' * (O(1)).\n', ' * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n', ' *\n', ' * ```\n', ' * contract Example {\n', ' *     // Add the library methods\n', ' *     using EnumerableSet for EnumerableSet.AddressSet;\n', ' *\n', ' *     // Declare a set state variable\n', ' *     EnumerableSet.AddressSet private mySet;\n', ' * }\n', ' * ```\n', ' *\n', ' * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n', ' * (`UintSet`) are supported.\n', ' */\n', 'library EnumerableSet {\n', '\n', '    struct AddressSet {\n', '        // Storage of set values\n', '        address[] _values;\n', '\n', '        // Position of the value in the `values` array, plus 1 because index 0\n', '        // means a value is not in the set.\n', '        mapping (address => uint256) _indexes;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(AddressSet storage set, address value) internal returns (bool) {\n', '        if (!contains(set, value)) {\n', '            set._values.push(value);\n', '            // The value is stored at length-1, but we add 1 to all indexes\n', '            // and use 0 as a sentinel value\n', '            set._indexes[value] = set._values.length;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(AddressSet storage set, address value) internal returns (bool) {\n', "        // We read and store the value's index to prevent multiple reads from the same storage slot\n", '        uint256 valueIndex = set._indexes[value];\n', '\n', '        if (valueIndex != 0) { // Equivalent to contains(set, value)\n', '            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n', "            // the array, and then remove the last element (sometimes called as 'swap and pop').\n", '            // This modifies the order of the array, as noted in {at}.\n', '\n', '            uint256 toDeleteIndex = valueIndex - 1;\n', '            uint256 lastIndex = set._values.length - 1;\n', '\n', '            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n', "            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n", '\n', '            address lastvalue = set._values[lastIndex];\n', '\n', '            // Move the last value to the index where the value to delete is\n', '            set._values[toDeleteIndex] = lastvalue;\n', '            // Update the index for the moved value\n', '            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n', '\n', '            // Delete the slot where the moved value was stored\n', '            set._values.pop();\n', '\n', '            // Delete the index for the deleted slot\n', '            delete set._indexes[value];\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(AddressSet storage set, address value) internal view returns (bool) {\n', '        return set._indexes[value] != 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values on the set. O(1).\n', '     */\n', '    function length(AddressSet storage set) internal view returns (uint256) {\n', '        return set._values.length;\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n', '        require(set._values.length > index, "EnumerableSet: index out of bounds");\n', '        return set._values[index];\n', '    }\n', '}\n']
['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.9;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' *\n', ' * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\n', ' * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n', ' * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n', ' * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(),"Not Owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0),"Zero address not allowed");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}']
