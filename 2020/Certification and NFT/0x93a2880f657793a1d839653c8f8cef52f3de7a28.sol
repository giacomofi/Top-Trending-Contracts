['pragma solidity ^0.5.0;\n', '\n', 'contract Context {\n', '\n', '    constructor () internal { }\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'interface IERC165 {\n', '    \n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', 'contract IERC721Receiver {\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n', '    public returns (bytes4);\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', 'library Counters {\n', '    using SafeMath for uint256;\n', '\n', '    struct Counter {\n', '        uint256 _value; // default: 0\n', '    }\n', '\n', '    function current(Counter storage counter) internal view returns (uint256) {\n', '        return counter._value;\n', '    }\n', '\n', '    function increment(Counter storage counter) internal {\n', '        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n', '        counter._value += 1;\n', '    }\n', '\n', '    function decrement(Counter storage counter) internal {\n', '        counter._value = counter._value.sub(1);\n', '    }\n', '}\n', '\n', 'contract ERC165 is IERC165 {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor () internal {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', 'contract ERC721 is Context, ERC165, IERC721 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '    using Counters for Counters.Counter;\n', '\n', '    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '    mapping (uint256 => address) private _tokenOwner;\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '    mapping (address => Counters.Counter) private _ownedTokensCount;\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '\n', '    constructor () public {\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '    }\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        require(owner != address(0), "ERC721: balance query for the zero address");\n', '\n', '        return _ownedTokensCount[owner].current();\n', '    }\n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        address owner = _tokenOwner[tokenId];\n', '        require(owner != address(0), "ERC721: owner query for nonexistent token");\n', '\n', '        return owner;\n', '    }\n', '    function approve(address to, uint256 tokenId) public {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner, "ERC721: approval to current owner");\n', '\n', '        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n', '            "ERC721: approve caller is not owner nor approved for all"\n', '        );\n', '\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(owner, to, tokenId);\n', '    }\n', '    function getApproved(uint256 tokenId) public view returns (address) {\n', '        require(_exists(tokenId), "ERC721: approved query for nonexistent token");\n', '\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '    function setApprovalForAll(address to, bool approved) public {\n', '        require(to != _msgSender(), "ERC721: approve to caller");\n', '\n', '        _operatorApprovals[_msgSender()][to] = approved;\n', '        emit ApprovalForAll(_msgSender(), to, approved);\n', '    }\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', '        //solhint-disable-next-line max-line-length\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");\n', '\n', '        _transferFrom(from, to, tokenId);\n', '    }\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");\n', '        _safeTransferFrom(from, to, tokenId, _data);\n', '    }\n', '    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\n', '        _transferFrom(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        address owner = _tokenOwner[tokenId];\n', '        return owner != address(0);\n', '    }\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        require(_exists(tokenId), "ERC721: operator query for nonexistent token");\n', '        address owner = ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '    function _safeMint(address to, uint256 tokenId) internal {\n', '        _safeMint(to, tokenId, "");\n', '    }\n', '    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n', '        _mint(to, tokenId);\n', '        require(_checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        require(to != address(0), "ERC721: mint to the zero address");\n', '        require(!_exists(tokenId), "ERC721: token already minted");\n', '\n', '        _tokenOwner[tokenId] = to;\n', '        _ownedTokensCount[to].increment();\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == owner, "ERC721: burn of token that is not own");\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[owner].decrement();\n', '        _tokenOwner[tokenId] = address(0);\n', '\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '    function _burn(uint256 tokenId) internal {\n', '        _burn(ownerOf(tokenId), tokenId);\n', '    }\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");\n', '        require(to != address(0), "ERC721: transfer to the zero address");\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[from].decrement();\n', '        _ownedTokensCount[to].increment();\n', '\n', '        _tokenOwner[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        internal returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\n', '            IERC721Receiver(to).onERC721Received.selector,\n', '            _msgSender(),\n', '            from,\n', '            tokenId,\n', '            _data\n', '        ));\n', '        if (!success) {\n', '            if (returndata.length > 0) {\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert("ERC721: transfer to non ERC721Receiver implementer");\n', '            }\n', '        } else {\n', '            bytes4 retval = abi.decode(returndata, (bytes4));\n', '            return (retval == _ERC721_RECEIVED);\n', '        }\n', '    }\n', '    function _clearApproval(uint256 tokenId) private {\n', '        if (_tokenApprovals[tokenId] != address(0)) {\n', '            _tokenApprovals[tokenId] = address(0);\n', '        }\n', '    }\n', '}\n', '\n', 'contract IERC721Enumerable is IERC721 {\n', '    function totalSupply() public view returns (uint256);\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n', '\n', '    function tokenByIndex(uint256 index) public view returns (uint256);\n', '}\n', '\n', 'contract ERC721Enumerable is Context, ERC165, ERC721, IERC721Enumerable {\n', '    mapping(address => uint256[]) private _ownedTokens;\n', '    mapping(uint256 => uint256) private _ownedTokensIndex;\n', '    uint256[] private _allTokens;\n', '    mapping(uint256 => uint256) private _allTokensIndex;\n', '    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n', '\n', '    constructor () public {\n', '        // register the supported interface to conform to ERC721Enumerable via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n', '    }\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n', '        require(index < balanceOf(owner), "ERC721Enumerable: owner index out of bounds");\n', '        return _ownedTokens[owner][index];\n', '    }\n', '    function totalSupply() public view returns (uint256) {\n', '        return _allTokens.length;\n', '    }\n', '    function tokenByIndex(uint256 index) public view returns (uint256) {\n', '        require(index < totalSupply(), "ERC721Enumerable: global index out of bounds");\n', '        return _allTokens[index];\n', '    }\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        super._transferFrom(from, to, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(from, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '    }\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        super._mint(to, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '\n', '        _addTokenToAllTokensEnumeration(tokenId);\n', '    }\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        super._burn(owner, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(owner, tokenId);\n', '        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n', '        _ownedTokensIndex[tokenId] = 0;\n', '\n', '        _removeTokenFromAllTokensEnumeration(tokenId);\n', '    }\n', '    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n', '        return _ownedTokens[owner];\n', '    }\n', '    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n', '        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n', '        _ownedTokens[to].push(tokenId);\n', '    }\n', '    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n', '        _allTokensIndex[tokenId] = _allTokens.length;\n', '        _allTokens.push(tokenId);\n', '    }\n', '    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n', '        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n', '        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n', '\n', '            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '        }\n', '        _ownedTokens[from].length--;\n', '    }\n', '    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n', '        uint256 lastTokenIndex = _allTokens.length.sub(1);\n', '        uint256 tokenIndex = _allTokensIndex[tokenId];\n', '        uint256 lastTokenId = _allTokens[lastTokenIndex];\n', '\n', '        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '        _allTokens.length--;\n', '        _allTokensIndex[tokenId] = 0;\n', '    }\n', '}\n', '\n', 'contract IERC721Metadata is IERC721 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', 'contract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\n', '    string private _name;\n', '    string private _symbol;\n', '    string private _baseURI;\n', '    mapping(uint256 => string) private _tokenURIs;\n', '    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n', '\n', '    constructor (string memory name, string memory symbol) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n', '    }\n', '    function name() external view returns (string memory) {\n', '        return _name;\n', '    }\n', '    function symbol() external view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '    function tokenURI(uint256 tokenId) external view returns (string memory) {\n', '        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n', '\n', '        string memory _tokenURI = _tokenURIs[tokenId];\n', '\n', '        // Even if there is a base URI, it is only appended to non-empty token-specific URIs\n', '        if (bytes(_tokenURI).length == 0) {\n', '            return "";\n', '        } else {\n', '            // abi.encodePacked is being used to concatenate strings\n', '            return string(abi.encodePacked(_baseURI, _tokenURI));\n', '        }\n', '    }\n', '    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {\n', '        require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");\n', '        _tokenURIs[tokenId] = _tokenURI;\n', '    }\n', '    function _setBaseURI(string memory baseURI) internal {\n', '        _baseURI = baseURI;\n', '    }\n', '    function baseURI() external view returns (string memory) {\n', '        return _baseURI;\n', '    }\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        super._burn(owner, tokenId);\n', '\n', '        // Clear metadata (if any)\n', '        if (bytes(_tokenURIs[tokenId]).length != 0) {\n', '            delete _tokenURIs[tokenId];\n', '        }\n', '    }\n', '}\n', '\n', 'contract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n', '    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n', '        // solhint-disable-previous-line no-empty-blocks\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '    bool private _notEntered;\n', '\n', '    constructor () internal {\n', '        _notEntered = true;\n', '    }\n', '    modifier nonReentrant() {\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '        _notEntered = false;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '}\n', '\n', 'interface Pool1  {\n', '    function changeDependentContractAddress() external;\n', '    function makeCoverBegin(\n', '        address smartCAdd,\n', '        bytes4 coverCurr,\n', '        uint[] calldata coverDetails,\n', '        uint16 coverPeriod,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '        payable;\n', '    function makeCoverUsingCA(\n', '        address smartCAdd,\n', '        bytes4 coverCurr,\n', '        uint[] calldata coverDetails,\n', '        uint16 coverPeriod,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external;\n', '    function getWei(uint amount) external view returns(uint);\n', '    function sellNXMTokens(uint _amount) external  returns (bool);\n', '}\n', '\n', 'contract INXMMaster {\n', '    address public tokenAddress;\n', '    address public owner;\n', '    uint public pauseTime;\n', '    function masterInitialized() external view returns(bool);\n', '    function isPause() external view returns(bool check);\n', '    function isMember(address _add) external view returns(bool);\n', '    function getLatestAddress(bytes2 _contractName) external view returns(address payable contractAddress);\n', '}\n', '\n', 'interface DSValue {\n', '    function peek() external view returns (bytes32, bool);\n', '    function read() external view returns (bytes32);\n', '}\n', '\n', 'interface PoolData {\n', '\n', '    struct ApiId {\n', '        bytes4 typeOf;\n', '        bytes4 currency;\n', '        uint id;\n', '        uint64 dateAdd;\n', '        uint64 dateUpd;\n', '    }\n', '\n', '    struct CurrencyAssets {\n', '        address currAddress;\n', '        uint baseMin;\n', '        uint varMin;\n', '    }\n', '\n', '    struct InvestmentAssets {\n', '        address currAddress;\n', '        bool status;\n', '        uint64 minHoldingPercX100;\n', '        uint64 maxHoldingPercX100;\n', '        uint8 decimals;\n', '    }\n', '\n', '    struct IARankDetails {\n', '        bytes4 maxIACurr;\n', '        uint64 maxRate;\n', '        bytes4 minIACurr;\n', '        uint64 minRate;\n', '    }\n', '\n', '    struct McrData {\n', '        uint mcrPercx100;\n', '        uint mcrEther;\n', '        uint vFull; //Pool funds\n', '        uint64 date;\n', '    }\n', '\n', '    function setCapReached(uint val) external;\n', '    function getInvestmentAssetDecimals(bytes4 curr) external returns(uint8 decimal);\n', '    function getCurrencyAssetAddress(bytes4 curr) external view returns(address);\n', '    function getInvestmentAssetAddress(bytes4 curr) external view returns(address);\n', '    function getInvestmentAssetStatus(bytes4 curr) external view returns(bool status);\n', '\n', '}\n', '\n', 'interface QuotationData {\n', '\n', '    enum HCIDStatus { NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover }\n', '    enum CoverStatus { Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested }\n', '\n', '    struct Cover {\n', '        address payable memberAddress;\n', '        bytes4 currencyCode;\n', '        uint sumAssured;\n', '        uint16 coverPeriod;\n', '        uint validUntil;\n', '        address scAddress;\n', '        uint premiumNXM;\n', '    }\n', '\n', '    struct HoldCover {\n', '        uint holdCoverId;\n', '        address payable userAddress;\n', '        address scAddress;\n', '        bytes4 coverCurr;\n', '        uint[] coverDetails;\n', '        uint16 coverPeriod;\n', '    }\n', '\n', '    function getCoverLength() external returns(uint len);\n', '    function getAuthQuoteEngine() external returns(address _add);\n', '    function getAllCoversOfUser(address _add) external returns(uint[] memory allCover);\n', '    function getUserCoverLength(address _add) external returns(uint len);\n', '    function getCoverStatusNo(uint _cid) external returns(uint8);\n', '    function getCoverPeriod(uint _cid) external returns(uint32 cp);\n', '    function getCoverSumAssured(uint _cid) external returns(uint sa);\n', '    function getCurrencyOfCover(uint _cid) external returns(bytes4 curr);\n', '    function getValidityOfCover(uint _cid) external returns(uint date);\n', '    function getscAddressOfCover(uint _cid) external returns(uint, address);\n', '    function getCoverMemberAddress(uint _cid) external returns(address payable _add);\n', '    function getCoverPremiumNXM(uint _cid) external returns(uint _premiumNXM);\n', '    function getCoverDetailsByCoverID1(\n', '        uint _cid\n', '    )\n', '        external\n', '        returns (\n', '            uint cid,\n', '            address _memberAddress,\n', '            address _scAddress,\n', '            bytes4 _currencyCode,\n', '            uint _sumAssured,\n', '            uint premiumNXM\n', '        );\n', '    function getCoverDetailsByCoverID2(\n', '        uint _cid\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            uint cid,\n', '            uint8 status,\n', '            uint sumAssured,\n', '            uint16 coverPeriod,\n', '            uint validUntil\n', '        );\n', '    function getHoldedCoverDetailsByID1(\n', '        uint _hcid\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            uint hcid,\n', '            address scAddress,\n', '            bytes4 coverCurr,\n', '            uint16 coverPeriod\n', '        );\n', '    function getUserHoldedCoverLength(address _add) external returns (uint);\n', '    function getUserHoldedCoverByIndex(address _add, uint index) external returns (uint);\n', '    function getHoldedCoverDetailsByID2(\n', '        uint _hcid\n', '    )\n', '        external\n', '        returns (\n', '            uint hcid,\n', '            address payable memberAddress,\n', '            uint[] memory coverDetails\n', '        );\n', '    function getTotalSumAssuredSC(address _add, bytes4 _curr) external returns(uint amount);\n', '\n', '}\n', '\n', 'contract TokenData {\n', '    function lockTokenTimeAfterCoverExp() external returns (uint);\n', '}\n', '\n', 'interface Claims {\n', '    function getClaimbyIndex(uint _claimId) external view returns (\n', '        uint claimId,\n', '        uint status,\n', '        int8 finalVerdict,\n', '        address claimOwner,\n', '        uint coverId\n', '    );\n', '    function submitClaim(uint coverId) external;\n', '}\n', '\n', 'contract ClaimsData {\n', '    function actualClaimLength() external view returns(uint);\n', '}\n', '\n', 'interface NXMToken {\n', '    function balanceOf(address owner) external view returns (uint256);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '}\n', '\n', 'library NexusMutualCover {\n', '    using SafeMath for uint;\n', '\n', '    INXMMaster constant public nxMaster = INXMMaster(0x3A2d0E5773dd6A345Eda543b14C6Ca6B51c6CC0A);\n', '\n', '    enum CoverStatus {\n', '        Active,\n', '        ClaimAccepted,\n', '        ClaimDenied,\n', '        CoverExpired,\n', '        ClaimSubmitted,\n', '        Requested\n', '    }\n', '\n', '    enum ClaimStatus {\n', '        PendingClaimAssessorVote, // 0\n', '        PendingClaimAssessorVoteDenied, // 1\n', '        PendingClaimAssessorVoteThresholdNotReachedAccept, // 2\n', '        PendingClaimAssessorVoteThresholdNotReachedDeny, // 3\n', '        PendingClaimAssessorConsensusNotReachedAccept, // 4\n', '        PendingClaimAssessorConsensusNotReachedDeny, // 5\n', '        FinalClaimAssessorVoteDenied, // 6\n', '        FinalClaimAssessorVoteAccepted, // 7\n', '        FinalClaimAssessorVoteDeniedMVAccepted, // 8\n', '        FinalClaimAssessorVoteDeniedMVDenied, // 9\n', '        FinalClaimAssessorVotAcceptedMVNoDecision, // 10\n', '        FinalClaimAssessorVoteDeniedMVNoDecision, // 11\n', '        ClaimAcceptedPayoutPending, // 12\n', '        ClaimAcceptedNoPayout, // 13\n', '        ClaimAcceptedPayoutDone // 14\n', '    }\n', '\n', '    function buyCover(\n', '        address coveredContractAddress,\n', '        bytes4 coverCurrency,\n', '        uint[] memory coverDetails,\n', '        uint16 coverPeriod,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) internal returns (uint coverId) {\n', '\n', '        uint coverPrice = coverDetails[1];\n', '        Pool1 pool1 = Pool1(nxMaster.getLatestAddress("P1"));\n', '        if (coverCurrency == "ETH") {\n', '            pool1.makeCoverBegin.value(coverPrice)(coveredContractAddress, coverCurrency, coverDetails, coverPeriod, _v, _r, _s);\n', '        } else {\n', '            address payable pool1Address = address(uint160(address(pool1)));\n', '            PoolData poolData = PoolData(nxMaster.getLatestAddress("PD"));\n', '            IERC20 erc20 = IERC20(poolData.getCurrencyAssetAddress(coverCurrency));\n', '            erc20.approve(pool1Address, coverPrice);\n', '            pool1.makeCoverUsingCA(coveredContractAddress, coverCurrency, coverDetails, coverPeriod, _v, _r, _s);\n', '        }\n', '\n', '        QuotationData quotationData = QuotationData(nxMaster.getLatestAddress("QD"));\n', '        // *assumes* the newly created claim is appended at the end of the list covers\n', '        coverId = quotationData.getCoverLength().sub(1);\n', '    }\n', '\n', '    function submitClaim(uint coverId) internal returns (uint) {\n', '        Claims claims = Claims(nxMaster.getLatestAddress("CL"));\n', '        claims.submitClaim(coverId);\n', '\n', '        ClaimsData claimsData = ClaimsData(nxMaster.getLatestAddress("CD"));\n', '        uint claimId = claimsData.actualClaimLength() - 1;\n', '        return claimId;\n', '    }\n', '    \n', '    function getMemberRoles() external view returns (address) {\n', '        return nxMaster.getLatestAddress("MR");\n', '    }\n', '\n', '    function getCover(\n', '        uint coverId\n', '    ) internal view returns (\n', '        uint cid,\n', '        uint8 status,\n', '        uint sumAssured,\n', '        uint16 coverPeriod,\n', '        uint validUntil\n', '    ) {\n', '        QuotationData quotationData = QuotationData(nxMaster.getLatestAddress("QD"));\n', '        return quotationData.getCoverDetailsByCoverID2(coverId);\n', '    }\n', '\n', '    function sellNXMTokens(uint amount) internal returns (uint ethValue) {\n', '        address payable pool1Address = nxMaster.getLatestAddress("P1");\n', '        Pool1 p1 = Pool1(pool1Address);\n', '\n', '        NXMToken nxmToken = NXMToken(nxMaster.tokenAddress());\n', '\n', '        ethValue = p1.getWei(amount);\n', '        nxmToken.approve(pool1Address, amount);\n', '        p1.sellNXMTokens(amount);\n', '    }\n', '\n', '    function getCurrencyAssetAddress(bytes4 currency) internal view returns (address) {\n', '        PoolData pd = PoolData(nxMaster.getLatestAddress("PD"));\n', '        return pd.getCurrencyAssetAddress(currency);\n', '    }\n', '\n', '    function getLockTokenTimeAfterCoverExpiry() internal returns (uint) {\n', '        TokenData tokenData = TokenData(nxMaster.getLatestAddress("TD"));\n', '        return tokenData.lockTokenTimeAfterCoverExp();\n', '    }\n', '\n', '    function getTokenAddress() internal view returns (address) {\n', '        return nxMaster.tokenAddress();\n', '    }\n', '\n', '    function payoutIsCompleted(uint claimId) internal view returns (bool) {\n', '        uint256 status;\n', '        Claims claims = Claims(nxMaster.getLatestAddress("CL"));\n', '        (, status, , , ) = claims.getClaimbyIndex(claimId);\n', '        return status == uint(ClaimStatus.FinalClaimAssessorVoteAccepted)\n', '            || status == uint(ClaimStatus.ClaimAcceptedPayoutDone);\n', '    }\n', '}\n', '\n', 'interface MemberRoles {\n', '    function switchMembership(address) external;\n', '}\n', '\n', 'contract yInsure is\n', '  ERC721Full("yInsureNFT", "yNFT"),\n', '  Ownable,\n', '  ReentrancyGuard {\n', '\n', '  struct Token {\n', '    uint expirationTimestamp;\n', '    bytes4 coverCurrency;\n', '    uint coverAmount;\n', '    uint coverPrice;\n', '    uint coverPriceNXM;\n', '    uint expireTime;\n', '    uint generationTime;\n', '    uint coverId;\n', '    bool claimInProgress;\n', '    uint claimId;\n', '  }\n', '\n', '  event ClaimRedeemed (\n', '    address receiver,\n', '    uint value,\n', '    bytes4 currency\n', '  );\n', '  \n', '  bytes4 internal constant ethCurrency = "ETH";\n', '\n', '  uint public distributorFeePercentage;\n', '  uint256 internal issuedTokensCount;\n', '  mapping(uint256 => Token) public tokens;\n', '\n', '  mapping(bytes4 => uint) public withdrawableTokens;\n', '\n', '  constructor(uint _distributorFeePercentage) public {\n', '    distributorFeePercentage = _distributorFeePercentage;\n', '  }\n', '  \n', '  function membership() external view returns (address) {\n', '      return NexusMutualCover.getMemberRoles();\n', '  }\n', '  \n', '  function switchMembership(address _newMembership) external onlyOwner {\n', '      MemberRoles(NexusMutualCover.getMemberRoles()).switchMembership(_newMembership);\n', '  }\n', '\n', '  // Arguments to be passed as coverDetails, from the quote api:\n', '  //    coverDetails[0] = coverAmount;\n', '  //    coverDetails[1] = coverPrice;\n', '  //    coverDetails[2] = coverPriceNXM;\n', '  //    coverDetails[3] = expireTime;\n', '  //    coverDetails[4] = generationTime;\n', '  function buyCover(\n', '        address coveredContractAddress,\n', '        bytes4 coverCurrency,\n', '        uint[] calldata coverDetails,\n', '        uint16 coverPeriod,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '  )\n', '     external\n', '     payable\n', '  {\n', '\n', '    uint coverPrice = coverDetails[1];\n', '    uint requiredValue = distributorFeePercentage.mul(coverPrice).div(100).add(coverPrice);\n', '    if (coverCurrency == "ETH") {\n', '      require(msg.value == requiredValue, "Incorrect value sent");\n', '    } else {\n', '      IERC20 erc20 = IERC20(NexusMutualCover.getCurrencyAssetAddress(coverCurrency));\n', '      require(erc20.transferFrom(msg.sender, address(this), requiredValue), "Transfer failed");\n', '    }\n', '\n', '    uint coverId = NexusMutualCover.buyCover(coveredContractAddress, coverCurrency, coverDetails, coverPeriod, _v, _r, _s);\n', '    withdrawableTokens[coverCurrency] = withdrawableTokens[coverCurrency].add(requiredValue.sub(coverPrice));\n', '\n', '    // mint token\n', '    uint256 nextTokenId = issuedTokensCount++;\n', '    uint expirationTimestamp = block.timestamp + NexusMutualCover.getLockTokenTimeAfterCoverExpiry() + coverPeriod * 1 days;\n', '    tokens[nextTokenId] = Token(expirationTimestamp,\n', '      coverCurrency,\n', '      coverDetails[0],\n', '      coverDetails[1],\n', '      coverDetails[2],\n', '      coverDetails[3],\n', '      coverDetails[4],\n', '      coverId, false, 0);\n', '    _mint(msg.sender, nextTokenId);\n', '  }\n', '\n', '  function submitClaim(\n', '    uint256 tokenId\n', '  )\n', '    external\n', '    onlyTokenApprovedOrOwner(tokenId)\n', '  {\n', '\n', '    if (tokens[tokenId].claimInProgress) {\n', '      uint8 coverStatus;\n', '      (, coverStatus, , , ) = NexusMutualCover.getCover(tokens[tokenId].coverId);\n', '      require(coverStatus == uint8(NexusMutualCover.CoverStatus.ClaimDenied),\n', '        "Can submit another claim only if the previous one was denied.");\n', '    }\n', '    require(tokens[tokenId].expirationTimestamp > block.timestamp, "Token is expired");\n', '\n', '    uint claimId = NexusMutualCover.submitClaim(tokens[tokenId].coverId);\n', '\n', '    tokens[tokenId].claimInProgress = true;\n', '    tokens[tokenId].claimId = claimId;\n', '  }\n', '\n', '  function redeemClaim(\n', '    uint256 tokenId\n', '  )\n', '    public\n', '    onlyTokenApprovedOrOwner(tokenId)\n', '    nonReentrant\n', '  {\n', '    require(tokens[tokenId].claimInProgress, "No claim is in progress");\n', '    uint8 coverStatus;\n', '    uint sumAssured;\n', '    (, coverStatus, sumAssured, , ) = NexusMutualCover.getCover(tokens[tokenId].coverId);\n', '\n', '    require(coverStatus == uint8(NexusMutualCover.CoverStatus.ClaimAccepted), "Claim is not accepted");\n', '    require(NexusMutualCover.payoutIsCompleted(tokens[tokenId].coverId), "Claim accepted but payout not completed");\n', '\n', '    _burn(tokenId);\n', '    _sendAssuredSum(tokens[tokenId].coverCurrency, sumAssured);\n', '    emit ClaimRedeemed(msg.sender, sumAssured, tokens[tokenId].coverCurrency);\n', '  }\n', '\n', '  function _sendAssuredSum(\n', '    bytes4 coverCurrency,\n', '    uint sumAssured\n', '    )\n', '    internal\n', '  {\n', '    if (coverCurrency == ethCurrency) {\n', '      msg.sender.transfer(sumAssured);\n', '    } else {\n', '      IERC20 erc20 = IERC20(NexusMutualCover.getCurrencyAssetAddress(coverCurrency));\n', '      require(erc20.transfer(msg.sender, sumAssured), "Transfer failed");\n', '    }\n', '  }\n', '\n', '  function getCoverStatus(uint256 tokenId) external view returns (uint8 coverStatus, bool payoutCompleted) {\n', '    (, coverStatus, , , ) = NexusMutualCover.getCover(tokens[tokenId].coverId);\n', '    payoutCompleted = NexusMutualCover.payoutIsCompleted(tokenId);\n', '  }\n', '\n', '  function nxmTokenApprove(address _spender, uint256 _value)\n', '  public\n', '  onlyOwner\n', '  {\n', '    IERC20 nxmToken = IERC20(NexusMutualCover.getTokenAddress());\n', '    nxmToken.approve(_spender, _value);\n', '  }\n', '\n', '  function withdrawEther(address payable _recipient, uint256 _amount)\n', '    external\n', '    onlyOwner\n', '    nonReentrant\n', '  {\n', '    require(withdrawableTokens[ethCurrency] >= _amount, "Not enough ETH");\n', '    withdrawableTokens[ethCurrency] = withdrawableTokens[ethCurrency].sub(_amount);\n', '    _recipient.transfer(_amount);\n', '  }\n', '\n', '  function withdrawTokens(address payable _recipient, uint256 _amount, bytes4 _currency)\n', '    external\n', '    onlyOwner\n', '    nonReentrant\n', '  {\n', '    require(withdrawableTokens[_currency] >= _amount, "Not enough tokens");\n', '    withdrawableTokens[_currency] = withdrawableTokens[_currency].sub(_amount);\n', '\n', '    IERC20 erc20 = IERC20(NexusMutualCover.getCurrencyAssetAddress(_currency));\n', '    require(erc20.transfer(_recipient, _amount), "Transfer failed");\n', '  }\n', '\n', '  function sellNXMTokens(uint amount)\n', '    external\n', '    onlyOwner\n', '  {\n', '    uint ethValue = NexusMutualCover.sellNXMTokens(amount);\n', '    withdrawableTokens[ethCurrency] = withdrawableTokens[ethCurrency].add(ethValue);\n', '  }\n', '\n', '  modifier onlyTokenApprovedOrOwner(uint256 tokenId) {\n', '    require(_isApprovedOrOwner(msg.sender, tokenId), "Not approved or owner");\n', '    _;\n', '  }\n', '\n', '  function () payable external {\n', '  }\n', '}']