['// SPDX-License-Identifier: Apache-2.0\n', 'pragma solidity ^0.7.0;\n', '// File: contracts/lib/AddressUtil.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Utility Functions for addresses\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library AddressUtil\n', '{\n', '    using AddressUtil for *;\n', '\n', '    function isContract(\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(addr) }\n', '        return (codehash != 0x0 &&\n', '                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n', '    }\n', '\n', '    function toPayable(\n', '        address addr\n', '        )\n', '        internal\n', '        pure\n', '        returns (address payable)\n', '    {\n', '        return payable(addr);\n', '    }\n', '\n', '    // Works like address.send but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETH(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        if (amount == 0) {\n', '            return true;\n', '        }\n', '        address payable recipient = to.toPayable();\n', '        /* solium-disable-next-line */\n', '        (success,) = recipient.call{value: amount, gas: gasLimit}("");\n', '    }\n', '\n', '    // Works like address.transfer but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETHAndVerify(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        success = to.sendETH(amount, gasLimit);\n', '        require(success, "TRANSFER_FAILURE");\n', '    }\n', '\n', '    // Works like call but is slightly more efficient when data\n', '    // needs to be copied from memory to do the call.\n', '    function fastCall(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bool success, bytes memory returnData)\n', '    {\n', '        if (to != address(0)) {\n', '            assembly {\n', '                // Do the call\n', '                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\n', '                // Copy the return data\n', '                let size := returndatasize()\n', '                returnData := mload(0x40)\n', '                mstore(returnData, size)\n', '                returndatacopy(add(returnData, 32), 0, size)\n', '                // Update free memory pointer\n', '                mstore(0x40, add(returnData, add(32, size)))\n', '            }\n', '        }\n', '    }\n', '\n', '    // Like fastCall, but throws when the call is unsuccessful.\n', '    function fastCallAndVerify(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bytes memory returnData)\n', '    {\n', '        bool success;\n', '        (success, returnData) = fastCall(to, gasLimit, value, data);\n', '        if (!success) {\n', '            assembly {\n', '                revert(add(returnData, 32), mload(returnData))\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ERC20.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'abstract contract ERC20\n', '{\n', '    function totalSupply()\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint);\n', '\n', '    function balanceOf(\n', '        address who\n', '        )\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '        )\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function approve(\n', '        address spender,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/lib/ERC20SafeTransfer.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title ERC20 safe transfer\n', '/// @dev see https://github.com/sec-bit/badERC20Fix\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library ERC20SafeTransfer\n', '{\n', '    function safeTransferAndVerify(\n', '        address token,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '    {\n', '        safeTransferWithGasLimitAndVerify(\n', '            token,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return safeTransferWithGasLimit(\n', '            token,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferWithGasLimitAndVerify(\n', '        address token,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '    {\n', '        require(\n', '            safeTransferWithGasLimit(token, to, value, gasLimit),\n', '            "TRANSFER_FAILURE"\n', '        );\n', '    }\n', '\n', '    function safeTransferWithGasLimit(\n', '        address token,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', "        // A transfer is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transfer(address,uint256)")) = 0xa9059cbb\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            bytes4(0xa9059cbb),\n', '            to,\n', '            value\n', '        );\n', '        (bool success, ) = token.call{gas: gasLimit}(callData);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function safeTransferFromAndVerify(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '    {\n', '        safeTransferFromWithGasLimitAndVerify(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return safeTransferFromWithGasLimit(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferFromWithGasLimitAndVerify(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '    {\n', '        bool result = safeTransferFromWithGasLimit(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasLimit\n', '        );\n', '        require(result, "TRANSFER_FAILURE");\n', '    }\n', '\n', '    function safeTransferFromWithGasLimit(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', "        // A transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transferFrom(address,address,uint256)")) = 0x23b872dd\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            bytes4(0x23b872dd),\n', '            from,\n', '            to,\n', '            value\n', '        );\n', '        (bool success, ) = token.call{gas: gasLimit}(callData);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function checkReturnValue(\n', '        bool success\n', '        )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', "        // A transfer/transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '        if (success) {\n', '            assembly {\n', '                switch returndatasize()\n', "                // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded\n", '                case 0 {\n', '                    success := 1\n', '                }\n', '                // Standard ERC20: a single boolean value is returned which needs to be true\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    success := mload(0)\n', '                }\n', '                // None of the above: not successful\n', '                default {\n', '                    success := 0\n', '                }\n', '            }\n', '        }\n', '        return success;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Drainable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title Drainable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Standard functionality to allow draining funds from a contract.\n', 'abstract contract Drainable\n', '{\n', '    using AddressUtil       for address;\n', '    using ERC20SafeTransfer for address;\n', '\n', '    event Drained(\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '    );\n', '\n', '    function drain(\n', '        address to,\n', '        address token\n', '        )\n', '        external\n', '        returns (uint amount)\n', '    {\n', '        require(canDrain(msg.sender, token), "UNAUTHORIZED");\n', '\n', '        if (token == address(0)) {\n', '            amount = address(this).balance;\n', '            to.sendETHAndVerify(amount, gasleft());   // ETH\n', '        } else {\n', '            amount = ERC20(token).balanceOf(address(this));\n', '            token.safeTransferAndVerify(to, amount);  // ERC20 token\n', '        }\n', '\n', '        emit Drained(to, token, amount);\n', '    }\n', '\n', '    // Needs to return if the address is authorized to call drain.\n', '    function canDrain(address drainer, address token)\n', '        public\n', '        virtual\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/lib/AddressSet.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title AddressSet\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract AddressSet\n', '{\n', '    struct Set\n', '    {\n', '        address[] addresses;\n', '        mapping (address => uint) positions;\n', '        uint count;\n', '    }\n', '    mapping (bytes32 => Set) private sets;\n', '\n', '    function addAddressToSet(\n', '        bytes32 key,\n', '        address addr,\n', '        bool    maintainList\n', '        ) internal\n', '    {\n', '        Set storage set = sets[key];\n', '        require(set.positions[addr] == 0, "ALREADY_IN_SET");\n', '\n', '        if (maintainList) {\n', '            require(set.addresses.length == set.count, "PREVIOUSLY_NOT_MAINTAILED");\n', '            set.addresses.push(addr);\n', '        } else {\n', '            require(set.addresses.length == 0, "MUST_MAINTAIN");\n', '        }\n', '\n', '        set.count += 1;\n', '        set.positions[addr] = set.count;\n', '    }\n', '\n', '    function removeAddressFromSet(\n', '        bytes32 key,\n', '        address addr\n', '        )\n', '        internal\n', '    {\n', '        Set storage set = sets[key];\n', '        uint pos = set.positions[addr];\n', '        require(pos != 0, "NOT_IN_SET");\n', '\n', '        delete set.positions[addr];\n', '        set.count -= 1;\n', '\n', '        if (set.addresses.length > 0) {\n', '            address lastAddr = set.addresses[set.count];\n', '            if (lastAddr != addr) {\n', '                set.addresses[pos - 1] = lastAddr;\n', '                set.positions[lastAddr] = pos;\n', '            }\n', '            set.addresses.pop();\n', '        }\n', '    }\n', '\n', '    function removeSet(bytes32 key)\n', '        internal\n', '    {\n', '        delete sets[key];\n', '    }\n', '\n', '    function isAddressInSet(\n', '        bytes32 key,\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return sets[key].positions[addr] != 0;\n', '    }\n', '\n', '    function numAddressesInSet(bytes32 key)\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        Set storage set = sets[key];\n', '        return set.count;\n', '    }\n', '\n', '    function addressesInSet(bytes32 key)\n', '        internal\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        Set storage set = sets[key];\n', '        require(set.count == set.addresses.length, "NOT_MAINTAINED");\n', '        return sets[key].addresses;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Ownable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Ownable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable\n', '{\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      new owner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership()\n', '        public\n', '        onlyOwner\n', '    {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Claimable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Claimable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable\n', '{\n', '    address public pendingOwner;\n', '\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0) && newOwner != owner, "INVALID_ADDRESS");\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        public\n', '        onlyPendingOwner\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/OwnerManagable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', 'contract OwnerManagable is Claimable, AddressSet\n', '{\n', '    bytes32 internal constant MANAGER = keccak256("__MANAGED__");\n', '\n', '    event ManagerAdded  (address indexed manager);\n', '    event ManagerRemoved(address indexed manager);\n', '\n', '    modifier onlyManager\n', '    {\n', '        require(isManager(msg.sender), "NOT_MANAGER");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrManager\n', '    {\n', '        require(msg.sender == owner || isManager(msg.sender), "NOT_OWNER_OR_MANAGER");\n', '        _;\n', '    }\n', '\n', '    constructor() Claimable() {}\n', '\n', '    /// @dev Gets the managers.\n', '    /// @return The list of managers.\n', '    function managers()\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        return addressesInSet(MANAGER);\n', '    }\n', '\n', '    /// @dev Gets the number of managers.\n', '    /// @return The numer of managers.\n', '    function numManagers()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return numAddressesInSet(MANAGER);\n', '    }\n', '\n', '    /// @dev Checks if an address is a manger.\n', '    /// @param addr The address to check.\n', '    /// @return True if the address is a manager, False otherwise.\n', '    function isManager(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return isAddressInSet(MANAGER, addr);\n', '    }\n', '\n', '    /// @dev Adds a new manager.\n', '    /// @param manager The new address to add.\n', '    function addManager(address manager)\n', '        public\n', '        onlyOwner\n', '    {\n', '        addManagerInternal(manager);\n', '    }\n', '\n', '    /// @dev Removes a manager.\n', '    /// @param manager The manager to remove.\n', '    function removeManager(address manager)\n', '        public\n', '        onlyOwner\n', '    {\n', '        removeAddressFromSet(MANAGER, manager);\n', '        emit ManagerRemoved(manager);\n', '    }\n', '\n', '    function addManagerInternal(address manager)\n', '        internal\n', '    {\n', '        addAddressToSet(MANAGER, manager, true);\n', '        emit ManagerAdded(manager);\n', '    }\n', '}\n', '\n', '// File: contracts/aux/FeeCollector.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '/// @title FeeCollector\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract FeeCollector is Drainable, OwnerManagable\n', '{\n', '    function canDrain(address drainer, address /*token*/)\n', '        public\n', '        override\n', '        view\n', '        returns (bool)\n', '    {\n', '        return isManager(drainer) || drainer == owner;\n', '    }\n', '\n', '    // Allow receiving ETH\n', '    receive() payable external {}\n', '}']