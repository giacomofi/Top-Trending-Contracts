['// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.8;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/GSN/Context.sol\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: contracts/access/Roles.sol\n', '\n', '/**\n', ' * @title Roles\n', ' * @notice copied from openzeppelin-solidity\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev Give an account access to this role.\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(!has(role, account), "Roles: account already has role");\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev Remove an account's access to this role.\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(has(role, account), "Roles: account does not have role");\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if an account has this role.\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0), "Roles: account is the zero address");\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '// File: contracts/access/WhitelistAdminRole.sol\n', '\n', '/**\n', ' * @title WhitelistAdminRole\n', ' * @notice copied from openzeppelin-solidity\n', ' * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\n', ' */\n', 'contract WhitelistAdminRole is Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistAdminAdded(address indexed account);\n', '    event WhitelistAdminRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelistAdmins;\n', '\n', '    constructor () internal {\n', '        _addWhitelistAdmin(_msgSender());\n', '    }\n', '\n', '    modifier onlyWhitelistAdmin() {\n', '        require(isWhitelistAdmin(_msgSender()), "WhitelistAdminRole: caller does not have the WhitelistAdmin role");\n', '        _;\n', '    }\n', '\n', '    function isWhitelistAdmin(address account) public view returns (bool) {\n', '        return _whitelistAdmins.has(account);\n', '    }\n', '\n', '    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\n', '        _addWhitelistAdmin(account);\n', '    }\n', '\n', '    function renounceWhitelistAdmin() public {\n', '        _removeWhitelistAdmin(_msgSender());\n', '    }\n', '\n', '    function _addWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.add(account);\n', '        emit WhitelistAdminAdded(account);\n', '    }\n', '\n', '    function _removeWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.remove(account);\n', '        emit WhitelistAdminRemoved(account);\n', '    }\n', '}\n', '\n', '// File: contracts/access/WhitelistedRole.sol\n', '\n', '\n', '/**\n', ' * @title WhitelistedRole\n', ' * @notice copied from openzeppelin-solidity\n', ' * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\n', ' * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\n', ' * it), and not Whitelisteds themselves.\n', ' */\n', 'contract WhitelistedRole is Context, WhitelistAdminRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistedAdded(address indexed account);\n', '    event WhitelistedRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelisteds;\n', '\n', '    modifier onlyWhitelisted() {\n', '        require(isWhitelisted(_msgSender()), "WhitelistedRole: caller does not have the Whitelisted role");\n', '        _;\n', '    }\n', '\n', '    function isWhitelisted(address account) public view returns (bool) {\n', '        return _whitelisteds.has(account);\n', '    }\n', '\n', '    function addWhitelisted(address account) public onlyWhitelistAdmin {\n', '        _addWhitelisted(account);\n', '    }\n', '\n', '    function removeWhitelisted(address account) public onlyWhitelistAdmin {\n', '        _removeWhitelisted(account);\n', '    }\n', '\n', '    function renounceWhitelisted() public {\n', '        _removeWhitelisted(_msgSender());\n', '    }\n', '\n', '    function _addWhitelisted(address account) internal {\n', '        _whitelisteds.add(account);\n', '        emit WhitelistedAdded(account);\n', '    }\n', '\n', '    function _removeWhitelisted(address account) internal {\n', '        _whitelisteds.remove(account);\n', '        emit WhitelistedRemoved(account);\n', '    }\n', '}\n', '\n', '// File: contracts/acquisition/ITokenPool.sol\n', '\n', '/**\n', ' * @title ITokenPool\n', ' * @notice provides interface for token pool where ERC20 tokens can be deposited and withdraw\n', '*/\n', 'interface ITokenPool {\n', '\n', '    /**\n', '    * @notice deposit token into the pool from the source\n', '    * @param amount     amount of token to deposit\n', '    * @return true if success\n', '    */\n', '    function depositAssetToken(uint256 amount) external returns (bool);\n', '\n', '    /**\n', '    * @notice withdraw token from the pool back to the source\n', '    * @param amount     amount of token to withdraw\n', '    * @return true if success\n', '    */\n', '    function withdrawAssetToken(uint256 amount) external returns (bool);\n', '}\n', '\n', '// File: contracts/acquisition/ERC20TokenProxy.sol\n', '\n', '\n', '/**\n', ' * @title ERC20TokenProxy\n', ' * @notice Proxy contract for managing ERC20 tokens with access control, so control can be shared between parties\n', '*/\n', 'contract ERC20TokenProxy is WhitelistedRole {\n', '\n', '    constructor() public {\n', '        _addWhitelisted(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @notice invoke the transfer function of the specified token\n', '    * @param token      the token being accessed\n', '    * @param to         acount to transfer to\n', '    * @param value      amount of tokens to transfer\n', '    * @return true if success\n', '    */\n', '    function transfer(address token, address to, uint256 value) external onlyWhitelisted returns (bool) {\n', '        IERC20(token).transfer(to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @notice invoke the appove function of the specified token\n', '    * @param token      the token being accessed\n', '    * @param spender    account to approve\n', '    * @param value      amount to approve\n', '    * @return true if success\n', '    */\n', '    function approve(address token, address spender, uint256 value) external onlyWhitelisted returns (bool) {\n', '        IERC20(token).approve(spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @notice invoke the transferFrom function of the specified token\n', '    * @param token      the token being accessed\n', '    * @param from       acount to transfer from\n', '    * @param to         acount to transfer to\n', '    * @param value      amount of tokens to transfer\n', '    * @return true if success\n', '    */\n', '    function transferFrom(address token, address from, address to, uint256 value) external onlyWhitelisted returns (bool) {\n', '        IERC20(token).transferFrom(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @notice deposit token into a token pool\n', '    * @param poolAddress    address of the token pool\n', '    * @param amount         amount of token to deposit\n', '    * @return true if success\n', '    */\n', '    function depositToTokenPool(address poolAddress, uint256 amount) external onlyWhitelisted returns (bool) {\n', '        return ITokenPool(poolAddress).depositAssetToken(amount);\n', '    }\n', '\n', '    /**\n', '    * @notice withdraw token from a token pool\n', '    * @param poolAddress    address of the token pool\n', '    * @param amount         amount of token to withdraw\n', '    * @return true if success\n', '    */\n', '    function withdrawFromTokenPool(address poolAddress, uint256 amount) external onlyWhitelisted returns (bool) {\n', '        return ITokenPool(poolAddress).withdrawAssetToken(amount);\n', '    }\n', '}']