['// SPDX-License-Identifier: GPL-3.0-only\n', '\n', 'pragma solidity 0.7.4;\n', '\n', 'library SafeMathLib {\n', '  function times(uint a, uint b) public pure returns (uint) {\n', '    uint c = a * b;\n', "    require(a == 0 || c / a == b, 'Overflow detected');\n", '    return c;\n', '  }\n', '\n', '  function minus(uint a, uint b) public pure returns (uint) {\n', "    require(b <= a, 'Underflow detected');\n", '    return a - b;\n', '  }\n', '\n', '  function plus(uint a, uint b) public pure returns (uint) {\n', '    uint c = a + b;\n', "    require(c>=a && c>=b, 'Overflow detected');\n", '    return c;\n', '  }\n', '\n', '}\n']
['// SPDX-License-Identifier: GPL-3.0-only\n', '\n', 'pragma solidity 0.7.4;\n', '\n', 'import "./SafeMathLib.sol";\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '\n', 'contract Trollbox {\n', '    using SafeMathLib for uint;\n', '\n', '    /**\n', '        Votes are a mapping from choices to weights, plus a metadataHash, which references an arbitrary bit of metadata\n', '        stored on IPFS. The meaning of these choices is not stored on chain, only the index. For example, if  the choices\n', '        are ["BTC", "ETH", "DASH"],  and the user  wants to put 3 votes on BTC, 5 votes on ETH and 4 on DASH, then this\n', '        will be recorded as weights[1]  = 3; weights[2]  = 5; weights[3] = 4; The choices are indexed starting on 1 to\n', '        prevent confusion caused by empty votes.\n', '    **/\n', '    struct Vote {\n', '        mapping(uint => uint) weights;\n', '        bytes32 metadataHash;\n', '    }\n', '\n', '    /**\n', '        Rounds occur with some frequency and represent a complete cycle of prediction->resolution. Each round has an id,\n', "        which represents it's location in a linear sequence of rounds of the same type. It stores a mapping of voter\n", '        ids to votes and records the winning option when the round is resolved.\n', '    **/\n', '    struct Round {\n', '        uint roundId;\n', '        mapping (uint => Vote) votes;\n', '        mapping (uint => uint) voteTotals;\n', '        uint winningOption;\n', '    }\n', '\n', '    /**\n', '        A tournament is a linear sequence of rounds of the same type. Tournaments are identified by an integer that\n', '        increases sequentially with each tournament. Tournaments also have hash for storing off-chain metadata about the\n', '        tournament. A tournament has a set wavelength and phase, called roundLengthSeconds and startDate, respectively. Each\n', "        tournament also has it's own set of voice credits, which is a mapping from address to balance. The rounds\n", '        mapping takes a round id and spits out a Round struct. The tokenRoundBonus attribute describes how much IERC20 to be\n', '        distributed to the voters each round. The tokenListENS stores the ENS address of a token list that forms the\n', '        choices of the tournament.\n', '    **/\n', '    struct Tournament {\n', '        uint tournamentId;\n', '        bytes32 metadataHash;  // ipfs hash of more verbose description, possibly multimedia\n', '        uint startTime;\n', '        uint roundLengthSeconds;\n', '        uint tokenRoundBonus;\n', '        uint minimumRank;\n', '        uint voiceUBI;   // number of voice credits available to spend each round\n', '        bytes32 tokenListENS;\n', '        address winnerOracle;  // address that sets the winner for a tournament\n', '        mapping (uint => uint) voiceCredits;\n', '        mapping (uint => Round) rounds;\n', '    }\n', '\n', '    /**\n', '        An identity is purchased with IERC20 and stores the creation time and a mapping of tournament id to the last round\n', '        id that the identity voted in, which is used for deferred reward computation.\n', '    **/\n', '    struct IdMetadata {\n', '        mapping (uint => uint) lastRoundVoted;\n', '//        uint firstTimeVoted;\n', '//        uint timesVoted;\n', '        uint cumulativeBonus;\n', '        uint rank;\n', '    }\n', '\n', '    address public management; // authoritative key that can make important decisions, can be DAO address later\n', '    address public rankManager;\n', '    IERC20 public token;\n', '    IERC721 public identity;\n', '\n', '    uint public numTournaments = 0; // a counter to know what index to assign to new tournaments\n', '    bytes32 public siteHash;\n', '\n', '    mapping (uint => Tournament) public tournaments; // mapping from tournament id to tournament struct\n', '    mapping (uint => IdMetadata) public identities; // mapping from address to identity struct\n', '    mapping (uint => uint) public tokensWon; // tokensWon[voterId] = fvt-wei owed\n', '    mapping (uint => mapping (uint => mapping (uint => bool))) public syncMap; // syncMap[voterId][tournamentId][roundId] = true/false\n', '\n', '    // events for consumption by off chain systems\n', '    event VoteOccurred(uint indexed tournamentId, uint indexed roundId, uint indexed voterId, uint[] choices, uint[] weights, bytes32 metadata);\n', '    event RoundResolved(uint indexed tournamentId, uint roundId, uint winningChoice);\n', '    event TournamentCreated(uint tournamentId, bytes32 metadataHash, uint startTime, uint roundLengthSeconds, uint tokenRoundBonus, uint minimumRank, uint voiceUBI, bytes32 tokenListENS, address winnerOracle);\n', '    event ManagementUpdated(address oldManagement, address newManagement);\n', '    event SiteHashUpdated(bytes32 oldSiteHash, bytes32 newSiteHash);\n', '    event RankUpdated(uint voterId, uint oldRank, uint newRank);\n', '    event RankManagerUpdated(address oldManager, address newManager);\n', '    event TournamentUpdated(uint tournamentId, bytes32 metadataHash, uint tokenRoundBonus, uint minimumRank, uint voiceUBI, bytes32 tokenListENS, address winnerOracle);\n', '    event AccountSynced(uint tournamentId, uint voterId);\n', '\n', '    modifier managementOnly() {\n', "        require (msg.sender == management, 'Only management may call this');\n", '        _;\n', '    }\n', '\n', '    constructor(address mgmt, address rankMgmt, address id) {\n', '        management = mgmt;\n', '        rankManager = rankMgmt;\n', '        identity = IERC721(id);\n', '    }\n', '\n', '    // this function creates a new tournament type, only management can call it\n', '    function createTournament(\n', '        bytes32 hash,\n', '        uint startTime,\n', '        uint roundLengthSeconds,\n', '        uint tokenRoundBonus,\n', '        bytes32 tokenListENS,\n', '        address oracle,\n', '        uint minRank,\n', '        uint voiceUBI) public managementOnly {\n', '        numTournaments = numTournaments.plus(1);\n', '        Tournament storage tournament = tournaments[numTournaments];\n', '        tournament.metadataHash = hash;\n', '        tournament.startTime = startTime == 0 ? block.timestamp : startTime;\n', '        tournament.tournamentId = numTournaments;\n', '        tournament.roundLengthSeconds = roundLengthSeconds;\n', '        tournament.tokenRoundBonus = tokenRoundBonus;\n', '        tournament.minimumRank = minRank;\n', '        tournament.voiceUBI = voiceUBI;\n', '        tournament.tokenListENS = tokenListENS;\n', '        tournament.winnerOracle = oracle;\n', '        emit TournamentCreated(numTournaments, hash, startTime, roundLengthSeconds, tokenRoundBonus, minRank, voiceUBI, tokenListENS, oracle);\n', '    }\n', '\n', '\n', '\n', '    // this completes the round, and assigns it a winning choice, which enables deferred updates to voice credits\n', '    function resolveRound(uint tournamentId, uint roundId, uint winningOption) public {\n', '        Tournament storage tournament = tournaments[tournamentId];\n', "        require(msg.sender == tournament.winnerOracle, 'Only winner oracle can call this');\n", '        uint currentRoundId = getCurrentRoundId(tournamentId);\n', '        Round storage round = tournament.rounds[roundId];\n', "        require(roundAlreadyResolved(tournamentId, roundId) == false, 'Round already resolved');\n", "        require(currentRoundId > roundId + 1, 'Too early to resolve');\n", '        round.roundId = roundId;\n', '        round.winningOption = winningOption;\n', '        emit RoundResolved(tournamentId, roundId, winningOption);\n', '    }\n', '\n', '    function voteCheck(uint voterId, uint tournamentId, uint roundId) internal view {\n', "        require(roundId > 0, 'Tournament not started yet');\n", "        require(identity.ownerOf(voterId) == msg.sender, 'Must own identity to vote with it');\n", "        require(roundId > identities[voterId].lastRoundVoted[tournamentId], 'Can only vote one time per round');\n", "        require(tournaments[tournamentId].minimumRank <= identities[voterId].rank, 'Insufficient rank to participate in this tournament');\n", '    }\n', '\n', '    // this is called by an identity that wishes to vote on a given tournament, with the choices and weights\n', '    function vote(\n', '        uint voterId,\n', '        uint tournamentId,\n', '        uint[] memory choices,\n', '        uint[] memory weights,\n', '        bytes32 hash,\n', '        uint updateRoundId\n', '    ) public {\n', '        uint roundId = getCurrentRoundId(tournamentId);\n', '        Round storage currentRound = tournaments[tournamentId].rounds[roundId];\n', '\n', '        voteCheck(voterId, tournamentId, roundId);\n', "        require(choices.length == weights.length, 'Mismatched choices and lengths');\n", '\n', '        updateAccount(voterId, tournamentId, updateRoundId);\n', '\n', '        identities[voterId].lastRoundVoted[tournamentId] = roundId;\n', '\n', '        Vote storage currentVote = currentRound.votes[voterId];\n', '        currentVote.metadataHash = hash;\n', '        uint balance = getVoiceCredits(tournamentId, voterId);\n', '        uint sum = 0;\n', '\n', '        for (uint i = 0; i < weights.length; i++) {\n', '            currentVote.weights[choices[i]] = weights[i];\n', '            currentRound.voteTotals[choices[i]] = currentRound.voteTotals[choices[i]].plus(weights[i]);\n', '            sum = sum.plus(weights[i].times(weights[i]));\n', '        }\n', "        require(sum <= balance, 'Must not spend more than your balance');\n", '\n', '        emit VoteOccurred(tournamentId, roundId, voterId, choices, weights, hash);\n', '    }\n', '\n', '    function withdrawWinnings(uint voterId) public {\n', '        uint winnings = tokensWon[voterId];\n', '        address owner = identity.ownerOf(voterId);\n', "        require(winnings > 0, 'Nothing to withdraw');\n", "        // doing it this way out of re-entry avoidance habit, not because it's actually possible here\n", '        tokensWon[voterId] = 0;\n', '        token.transfer(owner, winnings);\n', '    }\n', '\n', '    // this actually updates the voice credit balance to include the reward\n', '    function updateAccount(uint voterId, uint tournamentId, uint roundId) public {\n', '        IdMetadata storage id = identities[voterId];\n', '        Tournament storage tournament = tournaments[tournamentId];\n', '        bool roundResolved = roundAlreadyResolved(tournamentId, roundId);\n', '        bool shouldSync = isSynced(voterId, tournamentId, roundId) == false;\n', '\n', '        if (shouldSync && roundResolved) {\n', '            // idempotent condition, call twice, update once, since this function is public\n', '            syncMap[voterId][tournamentId][roundId] = true; // idempotence\n', '\n', '            (uint voiceCreditBonus, uint tokenBonus) = getRoundBonus(voterId, tournamentId, roundId);\n', '            tournament.voiceCredits[voterId] = getVoiceCredits(tournamentId, voterId).plus(voiceCreditBonus);\n', '            tokensWon[voterId] = tokensWon[voterId].plus(tokenBonus);\n', '            id.cumulativeBonus = id.cumulativeBonus.plus(voiceCreditBonus);\n', '            emit AccountSynced(tournamentId, voterId);\n', '        }\n', '    }\n', '\n', '\n', '/**\n', '====================================== GETTERS ==========================================================\n', '**/\n', '    function getRound(uint tournamentId, uint roundId) public view returns (uint[2] memory) {\n', '        Round storage round = tournaments[tournamentId].rounds[roundId];\n', '        return [round.roundId, round.winningOption];\n', '    }\n', '\n', '    // this computes the id of the current round for a given tournament, starting with round 1 on the startTime\n', '    function getCurrentRoundId(uint tournamentId) public view returns (uint) {\n', '        Tournament storage tournament = tournaments[tournamentId];\n', '        uint startTime = tournament.startTime;\n', '        uint roundLengthSeconds = tournament.roundLengthSeconds;\n', '        if (block.timestamp >= startTime) {\n', '            return 1 + ((block.timestamp - startTime) / roundLengthSeconds);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function getVoiceCredits(uint tournamentId, uint voterId) public view returns (uint) {\n', '        Tournament storage tournament = tournaments[tournamentId];\n', '        uint voiceCredits = tournament.voiceCredits[voterId];\n', '        if (voiceCredits > 0) {\n', '            return voiceCredits;\n', '        } else {\n', '            return tournament.voiceUBI;\n', '        }\n', '    }\n', '\n', '    function getLastRoundVoted(uint tournamentId, uint voterId) public view returns (uint) {\n', '        return identities[voterId].lastRoundVoted[tournamentId];\n', '    }\n', '\n', '    function getVoteTotals(uint tournamentId, uint roundId, uint option) public view returns (uint) {\n', '        return tournaments[tournamentId].rounds[roundId].voteTotals[option];\n', '    }\n', '\n', '    function getVoteMetadata(uint tournamentId, uint roundId, uint voterId) public view returns (bytes32) {\n', '        return tournaments[tournamentId].rounds[roundId].votes[voterId].metadataHash;\n', '    }\n', '\n', '    function getVoiceUBI(uint tournamentId) public view  returns (uint)  {\n', '        return tournaments[tournamentId].voiceUBI;\n', '    }\n', '\n', '    function getRoundResults(uint voterId, uint tournamentId, uint roundId) public view returns (uint, uint) {\n', '        Tournament storage tournament = tournaments[tournamentId];\n', '        Round storage round = tournament.rounds[roundId];\n', '        Vote storage thisVote = round.votes[voterId];\n', '        return (thisVote.weights[round.winningOption], round.voteTotals[round.winningOption]);\n', '    }\n', '\n', '    // this actually updates the voice credit balance to include the reward\n', '    function getRoundBonus(uint voterId, uint tournamentId, uint roundId) public view returns (uint, uint) {\n', '        Tournament storage tournament = tournaments[tournamentId];\n', '        (uint voteWeight, uint totalVotes) = getRoundResults(voterId, tournamentId, roundId);\n', '        uint tokenBonus = 0;\n', '        // if this is the first round voterId has voted in, totalVotes will be 0\n', '        if (totalVotes > 0) {\n', '            tokenBonus = tournament.tokenRoundBonus.times(voteWeight) / totalVotes;\n', '        }\n', '        uint voiceCreditBonus = voteWeight.times(voteWeight);\n', '        return (voiceCreditBonus, tokenBonus);\n', '    }\n', '\n', '    function isSynced(uint voterId, uint tournamentId, uint roundId) public view returns (bool) {\n', '        return syncMap[voterId][tournamentId][roundId];\n', '    }\n', '\n', '    function roundAlreadyResolved(uint tournamentId, uint roundId) public view returns (bool) {\n', '        return tournaments[tournamentId].rounds[roundId].winningOption > 0;\n', '    }\n', '\n', '/**\n', '====================================== SETTERS ==========================================================\n', '**/\n', '\n', '    // change the site hash\n', '    function setSiteHash(bytes32 newHash) public managementOnly {\n', '        bytes32 oldHash = siteHash;\n', '        siteHash = newHash;\n', '        emit SiteHashUpdated(oldHash, newHash);\n', '    }\n', '\n', '    function setRank(uint voterId, uint newRank) public {\n', "        require(msg.sender == rankManager, 'Only rankManager may call this');\n", '        IdMetadata storage id = identities[voterId];\n', '        uint oldRank = id.rank;\n', '        id.rank = newRank;\n', '        emit RankUpdated(voterId, oldRank, newRank);\n', '    }\n', '\n', '    function setToken(address tokenAddr) public managementOnly {\n', '        token = IERC20(tokenAddr);\n', '    }\n', '\n', '    function updateTournament(uint tournamentId, bytes32 newMetadata, uint newBonus,  uint newMinRank, uint newUBI, bytes32 newTokenList, address newOracle) public managementOnly {\n', '        Tournament storage tournament = tournaments[tournamentId];\n', '        tournament.metadataHash = newMetadata;\n', '        // no changing round length\n', '        tournament.tokenRoundBonus = newBonus;\n', '        tournament.minimumRank = newMinRank;\n', '        tournament.voiceUBI = newUBI;\n', '        tournament.tokenListENS = newTokenList;\n', '        tournament.winnerOracle = newOracle;\n', '        emit TournamentUpdated(tournamentId, newMetadata, newBonus, newMinRank, newUBI, newTokenList, newOracle);\n', '    }\n', '\n', '    function setRankManager(address newManager) public managementOnly {\n', '        address oldManager = rankManager;\n', '        rankManager = newManager;\n', '        emit RankManagerUpdated(oldManager, newManager);\n', '    }\n', '\n', '    // change the management key\n', '    function setManagement(address newMgmt) public managementOnly {\n', '        address oldMgmt =  management;\n', '        management = newMgmt;\n', '        emit ManagementUpdated(oldMgmt, newMgmt);\n', '    }\n', '\n', '\n', '}\n']
