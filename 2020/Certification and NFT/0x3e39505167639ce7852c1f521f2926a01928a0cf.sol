['/* solhint-disable no-mix-tabs-and-spaces */\n', '/* solhint-disable indent */\n', '\n', 'pragma solidity 0.5.15;\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of NFTs in `owner`'s account.\n", '     */\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the NFT specified by `tokenId`.\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    /**\n', '     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     *\n', '     *\n', '     * Requirements:\n', '     * - `from`, `to` cannot be zero.\n', '     * - `tokenId` must be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this\n', '     * NFT by either {approve} or {setApprovalForAll}.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '    /**\n', '     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Requirements:\n', '     * - If the caller is not `from`, it must be approved to move this NFT by\n', '     * either {approve} or {setApprovalForAll}.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'contract IERC721Receiver {\n', '    /**\n', '     * @notice Handle the receipt of an NFT\n', '     * @dev The ERC721 smart contract calls this function on the recipient\n', '     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n', '     * otherwise the caller will revert the transaction. The selector to be\n', '     * returned can be obtained as `this.onERC721Received.selector`. This\n', '     * function MAY throw to revert and reject the transfer.\n', '     * Note: the ERC721 contract address is always the message sender.\n', '     * @param operator The address which called `safeTransferFrom` function\n', '     * @param from The address which previously owned the token\n', '     * @param tokenId The NFT identifier which is being transferred\n', '     * @param data Additional data with no specified format\n', '     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n', '    public returns (bytes4);\n', '}\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '/* solhint-disable no-mix-tabs-and-spaces */\n', '/* solhint-disable indent */\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @dev Optional functions from the ERC20 standard.\n', ' */\n', 'contract ERC20Detailed is IERC20 {\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    /**\n', '     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n', '     * these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    constructor (string memory name, string memory symbol, uint8 decimals) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20Mintable}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for `sender`'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n', "     * from the caller's allowance.\n", '     *\n', '     * See {_burn} and {_approve}.\n', '     */\n', '    function _burnFrom(address account, uint256 amount) internal {\n', '        _burn(account, amount);\n', '        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev Give an account access to this role.\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(!has(role, account), "Roles: account already has role");\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev Remove an account's access to this role.\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(has(role, account), "Roles: account does not have role");\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if an account has this role.\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0), "Roles: account is the zero address");\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', 'contract MinterRole is Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event MinterAdded(address indexed account);\n', '    event MinterRemoved(address indexed account);\n', '\n', '    Roles.Role private _minters;\n', '\n', '    constructor () internal {\n', '        _addMinter(_msgSender());\n', '    }\n', '\n', '    modifier onlyMinter() {\n', '        require(isMinter(_msgSender()), "MinterRole: caller does not have the Minter role");\n', '        _;\n', '    }\n', '\n', '    function isMinter(address account) public view returns (bool) {\n', '        return _minters.has(account);\n', '    }\n', '\n', '    function addMinter(address account) public onlyMinter {\n', '        _addMinter(account);\n', '    }\n', '\n', '    function renounceMinter() public {\n', '        _removeMinter(_msgSender());\n', '    }\n', '\n', '    function _addMinter(address account) internal {\n', '        _minters.add(account);\n', '        emit MinterAdded(account);\n', '    }\n', '\n', '    function _removeMinter(address account) internal {\n', '        _minters.remove(account);\n', '        emit MinterRemoved(account);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\n', ' * which have permission to mint (create) new tokens as they see fit.\n', ' *\n', ' * At construction, the deployer of the contract is the only minter.\n', ' */\n', 'contract ERC20Mintable is ERC20, MinterRole {\n', '    /**\n', '     * @dev See {ERC20-_mint}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the {MinterRole}.\n', '     */\n', '    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n', '        _mint(account, amount);\n', '        return true;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Extension of {ERC20Mintable} that adds a cap to the supply of tokens.\n', ' */\n', 'contract ERC20Capped is ERC20Mintable {\n', '    uint256 private _cap;\n', '\n', '    /**\n', '     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n', '     * set once during construction.\n', '     */\n', '    constructor (uint256 cap) public {\n', '        require(cap > 0, "ERC20Capped: cap is 0");\n', '        _cap = cap;\n', '    }\n', '\n', '    /**\n', "     * @dev Returns the cap on the token's total supply.\n", '     */\n', '    function cap() public view returns (uint256) {\n', '        return _cap;\n', '    }\n', '\n', '    /**\n', '     * @dev See {ERC20Mintable-mint}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `value` must not cause the total supply to go over the cap.\n', '     */\n', '    function _mint(address account, uint256 value) internal {\n', '        require(totalSupply().add(value) <= _cap, "ERC20Capped: cap exceeded");\n', '        super._mint(account, value);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @dev Extension of {ERC20} that allows token holders to destroy both their own\n', ' * tokens and those that they have an allowance for, in a way that can be\n', ' * recognized off-chain (via event analysis).\n', ' */\n', 'contract ERC20Burnable is Context, ERC20 {\n', '    /**\n', '     * @dev Destroys `amount` tokens from the caller.\n', '     *\n', '     * See {ERC20-_burn}.\n', '     */\n', '    function burn(uint256 amount) public {\n', '        _burn(_msgSender(), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {ERC20-_burnFrom}.\n', '     */\n', '    function burnFrom(address account, uint256 amount) public {\n', '        _burnFrom(account, amount);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract PauserRole is Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event PauserAdded(address indexed account);\n', '    event PauserRemoved(address indexed account);\n', '\n', '    Roles.Role private _pausers;\n', '\n', '    constructor () internal {\n', '        _addPauser(_msgSender());\n', '    }\n', '\n', '    modifier onlyPauser() {\n', '        require(isPauser(_msgSender()), "PauserRole: caller does not have the Pauser role");\n', '        _;\n', '    }\n', '\n', '    function isPauser(address account) public view returns (bool) {\n', '        return _pausers.has(account);\n', '    }\n', '\n', '    function addPauser(address account) public onlyPauser {\n', '        _addPauser(account);\n', '    }\n', '\n', '    function renouncePauser() public {\n', '        _removePauser(_msgSender());\n', '    }\n', '\n', '    function _addPauser(address account) internal {\n', '        _pausers.add(account);\n', '        emit PauserAdded(account);\n', '    }\n', '\n', '    function _removePauser(address account) internal {\n', '        _pausers.remove(account);\n', '        emit PauserRemoved(account);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' * This module is used through inheritance. It will make available the\n', ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n', ' * the functions of your contract. Note that they will not be pausable by\n', ' * simply including this module, only once the modifiers are put in place.\n', ' */\n', 'contract Pausable is Context, PauserRole {\n', '    /**\n', '     * @dev Emitted when the pause is triggered by a pauser (`account`).\n', '     */\n', '    event Paused(address account);\n', '\n', '    /**\n', '     * @dev Emitted when the pause is lifted by a pauser (`account`).\n', '     */\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    /**\n', '     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n', '     * to the deployer.\n', '     */\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the contract is paused, and false otherwise.\n', '     */\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused, "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused, "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Called by a pauser to pause, triggers stopped state.\n', '     */\n', '    function pause() public onlyPauser whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(_msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Called by a pauser to unpause, returns to normal state.\n', '     */\n', '    function unpause() public onlyPauser whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(_msgSender());\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Pausable token\n', ' * @dev ERC20 with pausable transfers and allowances.\n', ' *\n', ' * Useful if you want to stop trades until the end of a crowdsale, or have\n', ' * an emergency switch for freezing all token transfers in the event of a large\n', ' * bug.\n', ' */\n', 'contract ERC20Pausable is ERC20, Pausable {\n', '    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n', '        return super.transfer(to, value);\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n', '        return super.transferFrom(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n', '        return super.approve(spender, value);\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public whenNotPaused returns (bool) {\n', '        return super.increaseAllowance(spender, addedValue);\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public whenNotPaused returns (bool) {\n', '        return super.decreaseAllowance(spender, subtractedValue);\n', '    }\n', '}\n', '/* solhint-disable no-mix-tabs-and-spaces */\n', '/* solhint-disable indent */\n', '\n', '\n', '\n', '/**\n', '\t* @title Contract managing Shotgun Clause lifecycle\n', '\t* @author Joel Hubert (Metalith.io)\n', '\t* @dev OpenZeppelin contracts are not ready for 0.6.0 yet, using 0.5.16.\n', '\t* @dev This contract is deployed once a Shotgun is initiated by calling the Registry.\n', '\t*/\n', '\n', 'contract ShotgunClause {\n', '\n', '\tusing SafeMath for uint256;\n', '\n', '\tShardGovernor private _shardGovernor;\n', '\tShardRegistry private _shardRegistry;\n', '\n', '\tenum ClaimWinner { None, Claimant, Counterclaimant }\n', '\tClaimWinner private _claimWinner = ClaimWinner.None;\n', '\n', '\tuint private _deadlineTimestamp;\n', '\tuint private _initialOfferInWei;\n', '\tuint private _pricePerShardInWei;\n', '\taddress payable private _initialClaimantAddress;\n', '\tuint private _initialClaimantBalance;\n', '\tbool private _shotgunEnacted = false;\n', '\tuint private _counterWeiContributed;\n', '\taddress[] private _counterclaimants;\n', '\tmapping(address => uint) private _counterclaimContribs;\n', '\n', '\tevent Countercommit(address indexed committer, uint indexed weiAmount);\n', '\tevent EtherCollected(address indexed collector, uint indexed weiAmount);\n', '\n', '\tconstructor(\n', '\t\taddress payable initialClaimantAddress,\n', '\t\tuint initialClaimantBalance,\n', '\t\taddress shardRegistryAddress\n', '\t) public payable {\n', '\t\t_shardGovernor = ShardGovernor(msg.sender);\n', '\t\t_shardRegistry = ShardRegistry(shardRegistryAddress);\n', '\t\t_deadlineTimestamp = now.add(1 * 14 days);\n', '\t\t_initialClaimantAddress = initialClaimantAddress;\n', '\t\t_initialClaimantBalance = initialClaimantBalance;\n', '\t\t_initialOfferInWei = msg.value;\n', '\t\t_pricePerShardInWei = (_initialOfferInWei.mul(10**18)).div(_shardRegistry.cap().sub(_initialClaimantBalance));\n', '\t\t_claimWinner = ClaimWinner.Claimant;\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Contribute Ether to the counterclaim for this Shotgun.\n', '\t\t* @dev Automatically enacts Shotgun once enough Ether is raised and\n', "\t\treturns initial claimant's Ether offer.\n", '\t\t*/\n', '\tfunction counterCommitEther() external payable {\n', '\t\trequire(\n', '\t\t\t_shardRegistry.balanceOf(msg.sender) > 0,\n', '\t\t\t"[counterCommitEther] Account does not own Shards"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\tmsg.value > 0,\n', '\t\t\t"[counterCommitEther] Ether is required"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\t_initialClaimantAddress != address(0),\n', '\t\t\t"[counterCommitEther] Initial claimant does not exist"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\tmsg.sender != _initialClaimantAddress,\n', '\t\t\t"[counterCommitEther] Initial claimant cannot countercommit"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\t!_shotgunEnacted,\n', '\t\t\t"[counterCommitEther] Shotgun already enacted"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\tnow < _deadlineTimestamp,\n', '\t\t\t"[counterCommitEther] Deadline has expired"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\tmsg.value + _counterWeiContributed <= getRequiredWeiForCounterclaim(),\n', '\t\t\t"[counterCommitEther] Ether exceeds goal"\n', '\t\t);\n', '\t\tif (_counterclaimContribs[msg.sender] == 0) {\n', '\t\t\t_counterclaimants.push(msg.sender);\n', '\t\t}\n', '\t\t_counterclaimContribs[msg.sender] = _counterclaimContribs[msg.sender].add(msg.value);\n', '\t\t_counterWeiContributed = _counterWeiContributed.add(msg.value);\n', '\t\temit Countercommit(msg.sender, msg.value);\n', '\t\tif (_counterWeiContributed == getRequiredWeiForCounterclaim()) {\n', '\t\t\t_claimWinner = ClaimWinner.Counterclaimant;\n', '\t\t\tenactShotgun();\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Collect ether from completed Shotgun.\n', "\t\t* @dev Called by Shard Registry after burning caller's Shards.\n", '\t\t* @dev For counterclaimants, returns both the proportional worth of their\n', '\t\tShards in Ether AND any counterclaim contributions they have made.\n', '\t\t* @dev alternative: OpenZeppelin PaymentSplitter\n', '\t\t*/\n', '\tfunction collectEtherProceeds(uint balance, address payable caller) external {\n', '\t\trequire(\n', '\t\t\tmsg.sender == address(_shardRegistry),\n', '\t\t\t"[collectEtherProceeds] Caller not authorized"\n', '\t\t);\n', '\t\tif (_claimWinner == ClaimWinner.Claimant && caller != _initialClaimantAddress) {\n', '\t\t\tuint weiProceeds = (_pricePerShardInWei.mul(balance)).div(10**18);\n', '\t\t\tweiProceeds = weiProceeds.add(_counterclaimContribs[caller]);\n', '\t\t\t_counterclaimContribs[caller] = 0;\n', '\t\t\t(bool success, ) = address(caller).call.value(weiProceeds)("");\n', '\t\t\trequire(success, "[collectEtherProceeds] Transfer failed.");\n', '\t\t\temit EtherCollected(caller, weiProceeds);\n', '\t\t} else if (_claimWinner == ClaimWinner.Counterclaimant && caller == _initialClaimantAddress) {\n', '\t\t\tuint amount = (_pricePerShardInWei.mul(_initialClaimantBalance)).div(10**18);\n', '\t\t\tamount = amount.add(_initialOfferInWei);\n', '\t\t\t_initialClaimantBalance = 0;\n', '\t\t\t(bool success, ) = address(caller).call.value(amount)("");\n', '\t\t\trequire(success, "[collectEtherProceeds] Transfer failed.");\n', '\t\t\temit EtherCollected(caller, amount);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Use by successful counterclaimants to collect Shards from initial claimant.\n', '\t\t*/\n', '\tfunction collectShardProceeds() external {\n', '\t\trequire(\n', '\t\t\t_shotgunEnacted && _claimWinner == ClaimWinner.Counterclaimant,\n', '\t\t\t"[collectShardProceeds] Shotgun has not been enacted or invalid winner"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\t_counterclaimContribs[msg.sender] != 0,\n', '\t\t\t"[collectShardProceeds] Account has not participated in counterclaim"\n', '\t\t);\n', '\t\tuint proportionContributed = (_counterclaimContribs[msg.sender].mul(10**18)).div(_counterWeiContributed);\n', '\t\t_counterclaimContribs[msg.sender] = 0;\n', '\t\tuint shardsToReceive = (proportionContributed.mul(_initialClaimantBalance)).div(10**18);\n', '\t\t_shardGovernor.transferShards(msg.sender, shardsToReceive);\n', '\t}\n', '\n', '\tfunction deadlineTimestamp() external view returns (uint256) {\n', '\t\treturn _deadlineTimestamp;\n', '\t}\n', '\n', '\tfunction shotgunEnacted() external view returns (bool) {\n', '\t\treturn _shotgunEnacted;\n', '\t}\n', '\n', '\tfunction initialClaimantAddress() external view returns (address) {\n', '\t\treturn _initialClaimantAddress;\n', '\t}\n', '\n', '\tfunction initialClaimantBalance() external view returns (uint) {\n', '\t\treturn _initialClaimantBalance;\n', '\t}\n', '\n', '\tfunction initialOfferInWei() external view returns (uint256) {\n', '\t\treturn _initialOfferInWei;\n', '\t}\n', '\n', '\tfunction pricePerShardInWei() external view returns (uint256) {\n', '\t\treturn _pricePerShardInWei;\n', '\t}\n', '\n', '\tfunction claimWinner() external view returns (ClaimWinner) {\n', '\t\treturn _claimWinner;\n', '\t}\n', '\n', '\tfunction counterclaimants() external view returns (address[] memory) {\n', '\t\treturn _counterclaimants;\n', '\t}\n', '\n', '\tfunction getCounterclaimantContribution(address counterclaimant) external view returns (uint) {\n', '\t\treturn _counterclaimContribs[counterclaimant];\n', '\t}\n', '\n', '\tfunction counterWeiContributed() external view returns (uint) {\n', '\t\treturn _counterWeiContributed;\n', '\t}\n', '\n', '\tfunction getContractBalance() external view returns (uint) {\n', '\t\treturn address(this).balance;\n', '\t}\n', '\n', '\tfunction shardGovernor() external view returns (address) {\n', '\t\treturn address(_shardGovernor);\n', '\t}\n', '\n', '\tfunction getRequiredWeiForCounterclaim() public view returns (uint) {\n', '\t\treturn (_pricePerShardInWei.mul(_initialClaimantBalance)).div(10**18);\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Initiate Shotgun enactment.\n', '\t\t* @dev Automatically called if enough Ether is raised by counterclaimants,\n', '\t\tor manually called if deadline expires without successful counterclaim.\n', '\t\t*/\n', '\tfunction enactShotgun() public {\n', '\t\trequire(\n', '\t\t\t!_shotgunEnacted,\n', '\t\t\t"[enactShotgun] Shotgun already enacted"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\t_claimWinner == ClaimWinner.Counterclaimant ||\n', '\t\t\t(_claimWinner == ClaimWinner.Claimant && now > _deadlineTimestamp),\n', '\t\t\t"[enactShotgun] Conditions not met to enact Shotgun Clause"\n', '\t\t);\n', '\t\t_shotgunEnacted = true;\n', '\t\t_shardGovernor.enactShotgun();\n', '\t}\n', '}\n', '\n', '/**\n', '\t* @title ERC20 base for Shards with additional methods related to governance\n', '\t* @author Joel Hubert (Metalith.io)\n', '\t* @dev OpenZeppelin contracts are not ready for 0.6.0 yet, using 0.5.16.\n', '\t*/\n', '\n', 'contract ShardRegistry is ERC20Detailed, ERC20Capped, ERC20Burnable, ERC20Pausable {\n', '\n', '\tShardGovernor private _shardGovernor;\n', '\tenum ClaimWinner { None, Claimant, Counterclaimant }\n', '\tbool private _shotgunDisabled;\n', '\n', '\tconstructor (\n', '\t\tuint256 cap,\n', '\t\tstring memory name,\n', '\t\tstring memory symbol,\n', '\t\tbool shotgunDisabled\n', '\t) ERC20Detailed(name, symbol, 18) ERC20Capped(cap) public {\n', '\t\t_shardGovernor = ShardGovernor(msg.sender);\n', '\t\t_shotgunDisabled = shotgunDisabled;\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Called to initiate Shotgun claim. Requires Ether.\n', "\t\t* @dev Transfers claimant's Shards into Governor contract's custody until\n", '\t\tclaim is resolved.\n', '\t\t* @dev Forwards Ether to Shotgun contract through Governor contract.\n', '\t\t*/\n', '\tfunction lockShardsAndClaim() external payable {\n', '\t\trequire(\n', '\t\t\t\t!_shotgunDisabled,\n', '\t\t\t\t"[lockShardsAndClaim] Shotgun disabled"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\t_shardGovernor.checkLock(),\n', '\t\t\t"[lockShardsAndClaim] NFT not locked, Shotgun cannot be triggered"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\t_shardGovernor.checkShotgunState(),\n', '\t\t\t"[lockShardsAndClaim] Shotgun already in progress"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\tmsg.value > 0,\n', '\t\t\t"[lockShardsAndClaim] Transaction must send ether to activate Shotgun Clause"\n', '\t\t);\n', '\t\tuint initialClaimantBalance = balanceOf(msg.sender);\n', '\t\trequire(\n', '\t\t\tinitialClaimantBalance > 0,\n', '\t\t\t"[lockShardsAndClaim] Account does not own Shards"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\tinitialClaimantBalance < cap(),\n', '\t\t\t"[lockShardsAndClaim] Account owns all Shards"\n', '\t\t);\n', '\t\ttransfer(address(_shardGovernor), balanceOf(msg.sender));\n', '\t\t(bool success) = _shardGovernor.claimInitialShotgun.value(msg.value)(\n', '\t\t\tmsg.sender, initialClaimantBalance\n', '\t\t);\n', '\t\trequire(\n', '\t\t\tsuccess,\n', '\t\t\t"[lockShards] Ether forwarding unsuccessful"\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Called to collect Ether from Shotgun proceeds. Burns Shard holdings.\n', '\t\t* @dev can be called in both Shotgun outcome scenarios by:\n', '\t\t- Initial claimant, if they lose the claim to counterclaimants and their\n', '\t\tShards are bought out\n', '\t\t- Counterclaimants, bought out if initial claimant is successful.\n', '\t\t* @dev initial claimant does not own Shards at this point because they have\n', '\t\tbeen custodied in Governor contract at start of Shotgun.\n', '\t\t* @param shotgunClause address of the relevant Shotgun contract.\n', '\t\t*/\n', '\tfunction burnAndCollectEther(address shotgunClause) external {\n', '\t\tShotgunClause _shotgunClause = ShotgunClause(shotgunClause);\n', '\t\tbool enacted = _shotgunClause.shotgunEnacted();\n', '\t\tif (!enacted) {\n', '\t\t\t_shotgunClause.enactShotgun();\n', '\t\t}\n', '\t\trequire(\n', '\t\t\tenacted || _shotgunClause.shotgunEnacted(),\n', '\t\t\t"[burnAndCollectEther] Shotgun Clause not enacted"\n', '\t\t);\n', '\t\tuint balance = balanceOf(msg.sender);\n', '\t\trequire(\n', '\t\t\tbalance > 0 || msg.sender == _shotgunClause.initialClaimantAddress(),\n', '\t\t\t"[burnAndCollectEther] Account does not own Shards"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\tuint(_shotgunClause.claimWinner()) == uint(ClaimWinner.Claimant) &&\n', '\t\t\tmsg.sender != _shotgunClause.initialClaimantAddress() ||\n', '\t\t\tuint(_shotgunClause.claimWinner()) == uint(ClaimWinner.Counterclaimant) &&\n', '\t\t\tmsg.sender == _shotgunClause.initialClaimantAddress(),\n', '\t\t\t"[burnAndCollectEther] Account does not have right to collect ether"\n', '\t\t);\n', '\t\tburn(balance);\n', '\t\t_shotgunClause.collectEtherProceeds(balance, msg.sender);\n', '\t}\n', '\n', '\tfunction shotgunDisabled() external view returns (bool) {\n', '\t\treturn _shotgunDisabled;\n', '\t}\n', '}\n', '/* solhint-disable no-mix-tabs-and-spaces */\n', '/* solhint-disable indent */\n', '\n', '\n', '\n', '/**\n', '\t* @title Contract managing Shard Offering lifecycle, similar to a crowdsale.\n', '\t* @author Joel Hubert (Metalith.io)\n', '\t* @dev OpenZeppelin contracts are not ready for 0.6.0 yet, using 0.5.16.\n', '\t* @dev Acts as a wallet containing subscriber Ether.\n', '\t*/\n', '\n', 'contract ShardOffering {\n', '\n', '\tusing SafeMath for uint256;\n', '\n', '\tShardGovernor private _shardGovernor;\n', '\tuint private _offeringDeadline;\n', '\tuint private _pricePerShardInWei;\n', '\tuint private _contributionTargetInWei;\n', '\tuint private _liqProviderCutInShards;\n', '\tuint private _artistCutInShards;\n', '\tuint private _offererShardAmount;\n', '\n', '\taddress[] private _contributors;\n', '\tmapping(address => uint) private _contributionsinWei;\n', '\tmapping(address => uint) private _contributionsInShards;\n', '\tmapping(address => bool) private _hasClaimedShards;\n', '\tuint private _totalWeiContributed;\n', '\tuint private _totalShardsClaimed;\n', '\tbool private _offeringCompleted;\n', '\n', '\tevent Contribution(address indexed contributor, uint indexed weiAmount);\n', '\tevent OfferingWrappedUp();\n', '\n', '\tconstructor(\n', '\t\tuint pricePerShardInWei,\n', '\t\tuint shardAmountOffered,\n', '\t\tuint liqProviderCutInShards,\n', '\t\tuint artistCutInShards,\n', '\t\tuint offeringDeadline,\n', '\t\tuint cap\n', '\t) public {\n', '\t\t_pricePerShardInWei = pricePerShardInWei;\n', '\t\t_liqProviderCutInShards = liqProviderCutInShards;\n', '\t\t_artistCutInShards = artistCutInShards;\n', '\t\t_offeringDeadline = offeringDeadline;\n', '\t\t_shardGovernor = ShardGovernor(msg.sender);\n', '\t\t_contributionTargetInWei = (pricePerShardInWei.mul(shardAmountOffered)).div(10**18);\n', '\t\t_offererShardAmount = cap.sub(shardAmountOffered).sub(liqProviderCutInShards).sub(artistCutInShards);\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Contribute Ether to offering.\n', '\t\t* @dev Blocks Offerer from contributing. May be exaggerated.\n', '\t\t* @dev if target Ether amount is raised, automatically transfers Ether to Offerer.\n', '\t\t*/\n', '\tfunction contribute() external payable {\n', '\t\trequire(\n', '\t\t\t!_offeringCompleted,\n', '\t\t\t"[contribute] Offering is complete"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\tmsg.value > 0,\n', '\t\t\t"[contribute] Contribution requires ether"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\tmsg.value <= _contributionTargetInWei - _totalWeiContributed,\n', '\t\t\t"[contribute] Ether value exceeds remaining quota"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\tmsg.sender != _shardGovernor.offererAddress(),\n', '\t\t\t"[contribute] Offerer cannot contribute"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\tnow < _offeringDeadline,\n', '\t\t\t"[contribute] Deadline for offering expired"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\t_shardGovernor.checkLock(),\n', '\t\t\t"[contribute] NFT not locked yet"\n', '\t\t);\n', '\t\tif (_contributionsinWei[msg.sender] == 0) {\n', '\t\t\t_contributors.push(msg.sender);\n', '\t\t}\n', '\t\t_contributionsinWei[msg.sender] = _contributionsinWei[msg.sender].add(msg.value);\n', '\t\tuint shardAmount = (msg.value.mul(10**18)).div(_pricePerShardInWei);\n', '\t\t_contributionsInShards[msg.sender] = _contributionsInShards[msg.sender].add(shardAmount);\n', '\t\t_totalWeiContributed = _totalWeiContributed.add(msg.value);\n', '\t\t_totalShardsClaimed = _totalShardsClaimed.add(shardAmount);\n', '\t\tif (_totalWeiContributed == _contributionTargetInWei) {\n', '\t\t\t_offeringCompleted = true;\n', '\t\t\t(bool success, ) = _shardGovernor.offererAddress().call.value(address(this).balance)("");\n', '\t\t\trequire(success, "[contribute] Transfer failed.");\n', '\t\t}\n', '\t\temit Contribution(msg.sender, msg.value);\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Prematurely end Offering.\n', '\t\t* @dev Called by Governor contract when Offering deadline expires and has not\n', '\t\t* raised the target amount of Ether.\n', '\t\t* @dev reentrancy is guarded in _shardGovernor.checkOfferingAndIssue() by\n', '\t\t`hasClaimedShards`.\n', '\t\t*/\n', '\tfunction wrapUpOffering() external {\n', '\t\trequire(\n', '\t\t\tmsg.sender == address(_shardGovernor),\n', '\t\t\t"[wrapUpOffering] Unauthorized caller"\n', '\t\t);\n', '\t\t_offeringCompleted = true;\n', '\t\t(bool success, ) = _shardGovernor.offererAddress().call.value(address(this).balance)("");\n', '\t\trequire(success, "[wrapUpOffering] Transfer failed.");\n', '\t\temit OfferingWrappedUp();\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Records Shard claim for subcriber.\n', '\t\t* @dev Can only be called by Governor contract on Offering close.\n', '\t\t* @param claimant wallet address of the person claiming the Shards they\n', '\t\tsubscribed to.\n', '\t\t*/\n', '\tfunction claimShards(address claimant) external {\n', '\t\trequire(\n', '\t\t\tmsg.sender == address(_shardGovernor),\n', '\t\t\t"[claimShards] Unauthorized caller"\n', '\t\t);\n', '\t\t_hasClaimedShards[claimant] = true;\n', '\t}\n', '\n', '\tfunction offeringDeadline() external view returns (uint) {\n', '\t\treturn _offeringDeadline;\n', '\t}\n', '\n', '\tfunction getSubEther(address sub) external view returns (uint) {\n', '\t\treturn _contributionsinWei[sub];\n', '\t}\n', '\n', '\tfunction getSubShards(address sub) external view returns (uint) {\n', '\t\treturn _contributionsInShards[sub];\n', '\t}\n', '\n', '\tfunction hasClaimedShards(address claimant) external view returns (bool) {\n', '\t\treturn _hasClaimedShards[claimant];\n', '\t}\n', '\n', '\tfunction pricePerShardInWei() external view returns (uint) {\n', '\t\treturn _pricePerShardInWei;\n', '\t}\n', '\n', '\tfunction offererShardAmount() external view returns (uint) {\n', '\t\treturn _offererShardAmount;\n', '\t}\n', '\n', '\tfunction liqProviderCutInShards() external view returns (uint) {\n', '\t\treturn _liqProviderCutInShards;\n', '\t}\n', '\n', '\tfunction artistCutInShards() external view returns (uint) {\n', '\t\treturn _artistCutInShards;\n', '\t}\n', '\n', '\tfunction offeringCompleted() external view returns (bool) {\n', '\t\treturn _offeringCompleted;\n', '\t}\n', '\n', '\tfunction totalShardsClaimed() external view returns (uint) {\n', '\t\treturn _totalShardsClaimed;\n', '\t}\n', '\n', '\tfunction totalWeiContributed() external view returns (uint) {\n', '\t\treturn _totalWeiContributed;\n', '\t}\n', '\n', '\tfunction contributionTargetInWei() external view returns (uint) {\n', '\t\treturn _contributionTargetInWei;\n', '\t}\n', '\n', '\tfunction getContractBalance() external view returns (uint) {\n', '\t\treturn address(this).balance;\n', '\t}\n', '\n', '\tfunction contributors() external view returns (address[] memory) {\n', '\t\treturn _contributors;\n', '\t}\n', '}\n', '/* solhint-disable no-mix-tabs-and-spaces */\n', '/* solhint-disable indent */\n', '\n', '\n', 'interface IUniswapExchange {\n', '\tfunction removeLiquidity(\n', '\t\tuint256 uniTokenAmount,\n', '\t\tuint256 minEth,\n', '\t\tuint256 minTokens,\n', '\t\tuint256 deadline\n', '\t) external returns(\n', '\t\tuint256, uint256\n', '\t);\n', '\n', '\tfunction transferFrom(\n', '\t\taddress from,\n', '\t\taddress to,\n', '\t\tuint256 value\n', '\t) external returns (bool);\n', '}\n', '\n', '/**\n', '\t* @title Contract managing Shard lifecycle (NFT custody + Shard issuance and redemption)\n', '\t* @author Joel Hubert (Metalith.io)\n', '\t* @dev OpenZeppelin contracts are not ready for 0.6.0 yet, using 0.5.15.\n', '\t* @dev This contract owns the Registry, Offering and any Shotgun contracts,\n', '\t* making it the gateway for core state changes.\n', '\t*/\n', '\n', 'contract ShardGovernor is IERC721Receiver {\n', '\n', '  using SafeMath for uint256;\n', '\n', '\t// Equals `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '\tbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '\n', '\tShardRegistry private _shardRegistry;\n', '\tShardOffering private _shardOffering;\n', '\tShotgunClause private _currentShotgunClause;\n', '\taddress payable private _offererAddress;\n', '\taddress private _nftRegistryAddress;\n', '\taddress payable private _niftexWalletAddress;\n', '\taddress payable private _artistWalletAddress;\n', '\tuint256 private _tokenId;\n', '\n', '\tenum ClaimWinner { None, Claimant, Counterclaimant }\n', '\taddress[] private _shotgunAddressArray;\n', '\tmapping(address => uint) private _shotgunMapping;\n', '\tuint private _shotgunCounter;\n', '\n', '\tevent NewShotgun(address indexed shotgun);\n', '\tevent ShardsClaimed(address indexed claimant, uint indexed shardAmount);\n', '\tevent NftRedeemed(address indexed redeemer);\n', '\tevent ShotgunEnacted(address indexed enactor);\n', '\tevent ShardsCollected(address indexed collector, uint indexed shardAmount, address indexed shotgun);\n', '\n', '\t/**\n', '\t\t* @dev Checks whether offerer indeed owns the relevant NFT.\n', '\t\t* @dev Offering deadline starts ticking on deployment, but offerer needs to transfer\n', '\t\t* NFT to this contract before anyone can contribute.\n', '\t\t*/\n', '  constructor(\n', '\t\taddress nftRegistryAddress,\n', '\t\taddress payable offererAddress,\n', '\t\tuint256 tokenId,\n', '\t\taddress payable niftexWalletAddress,\n', '\t\taddress payable artistWalletAddress,\n', '\t\tuint liqProviderCutInShards,\n', '\t\tuint artistCutInShards,\n', '\t\tuint pricePerShardInWei,\n', '\t\tuint shardAmountOffered,\n', '\t\tuint offeringDeadline,\n', '\t\tuint256 cap,\n', '\t\tstring memory name,\n', '\t\tstring memory symbol,\n', '\t\tbool shotgunDisabled\n', '\t) public {\n', '\t\trequire(\n', '\t\t\tIERC721(nftRegistryAddress).ownerOf(tokenId) == offererAddress,\n', '\t\t\t"Offerer is not owner of tokenId"\n', '\t\t);\n', '\t\t_nftRegistryAddress = nftRegistryAddress;\n', '\t\t_niftexWalletAddress = niftexWalletAddress;\n', '\t\t_artistWalletAddress = artistWalletAddress;\n', '\t\t_tokenId = tokenId;\n', '\t\t_offererAddress = offererAddress;\n', '\t\t_shardRegistry = new ShardRegistry(cap, name, symbol, shotgunDisabled);\n', '\t\t_shardOffering = new ShardOffering(\n', '\t\t\tpricePerShardInWei,\n', '\t\t\tshardAmountOffered,\n', '\t\t\tliqProviderCutInShards,\n', '\t\t\tartistCutInShards,\n', '\t\t\tofferingDeadline,\n', '\t\t\tcap\n', '\t\t);\n', '  }\n', '\n', '\t/**\n', '\t\t* @dev Used to receive ether from the pullLiquidity function.\n', '\t\t*/\n', '\tfunction() external payable { }\n', '\n', '\t/**\n', '\t\t* @notice Issues Shards upon completion of Offering.\n', '\t\t* @dev Cap should equal totalSupply when all Shards have been claimed.\n', '\t\t* @dev The Offerer may close an undersubscribed Offering once the deadline has\n', '\t\t* passed and claim the remaining Shards.\n', '\t\t*/\n', '\tfunction checkOfferingAndIssue() external {\n', '\t\trequire(\n', '\t\t\t_shardRegistry.totalSupply() != _shardRegistry.cap(),\n', '\t\t\t"[checkOfferingAndIssue] Shards have already been issued"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\t!_shardOffering.hasClaimedShards(msg.sender),\n', '\t\t\t"[checkOfferingAndIssue] You have already claimed your Shards"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\t_shardOffering.offeringCompleted() ||\n', '\t\t\t(now > _shardOffering.offeringDeadline() && !_shardOffering.offeringCompleted()),\n', '\t\t\t"Offering not completed or deadline not expired"\n', '\t\t);\n', '\t\tif (_shardOffering.offeringCompleted()) {\n', '\t\t\tif (_shardOffering.getSubEther(msg.sender) != 0) {\n', '\t\t\t\t_shardOffering.claimShards(msg.sender);\n', '\t\t\t\tuint subShards = _shardOffering.getSubShards(msg.sender);\n', '\t\t\t\tbool success = _shardRegistry.mint(msg.sender, subShards);\n', '\t\t\t\trequire(success, "[checkOfferingAndIssue] Mint failed");\n', '\t\t\t\temit ShardsClaimed(msg.sender, subShards);\n', '\t\t\t} else if (msg.sender == _offererAddress) {\n', '\t\t\t\t_shardOffering.claimShards(msg.sender);\n', '\t\t\t\tuint offShards = _shardOffering.offererShardAmount();\n', '\t\t\t\tbool success = _shardRegistry.mint(msg.sender, offShards);\n', '\t\t\t\trequire(success, "[checkOfferingAndIssue] Mint failed");\n', '\t\t\t\temit ShardsClaimed(msg.sender, offShards);\n', '\t\t\t}\n', '\t\t} else {\n', '\t\t\t_shardOffering.wrapUpOffering();\n', '\t\t\tuint remainingShards = _shardRegistry.cap().sub(_shardOffering.totalShardsClaimed());\n', '\t\t\tremainingShards = remainingShards\n', '\t\t\t\t.sub(_shardOffering.liqProviderCutInShards())\n', '\t\t\t\t.sub(_shardOffering.artistCutInShards());\n', '\t\t\tbool success = _shardRegistry.mint(_offererAddress, remainingShards);\n', '\t\t\trequire(success, "[checkOfferingAndIssue] Mint failed");\n', '\t\t\temit ShardsClaimed(msg.sender, remainingShards);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Used by NIFTEX to claim predetermined amount of shards in offering in order\n', '\t\t* to bootstrap liquidity on Uniswap-type exchange.\n', '\t\t*/\n', '\t/* function claimLiqProviderShards() external {\n', '\t\trequire(\n', '\t\t\tmsg.sender == _niftexWalletAddress,\n', '\t\t\t"[claimLiqProviderShards] Unauthorized caller"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\t!_shardOffering.hasClaimedShards(msg.sender),\n', '\t\t\t"[claimLiqProviderShards] You have already claimed your Shards"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\t_shardOffering.offeringCompleted(),\n', '\t\t\t"[claimLiqProviderShards] Offering not completed"\n', '\t\t);\n', '\t\t_shardOffering.claimShards(_niftexWalletAddress);\n', '\t\tuint cut = _shardOffering.liqProviderCutInShards();\n', '\t\tbool success = _shardRegistry.mint(_niftexWalletAddress, cut);\n', '\t\trequire(success, "[claimLiqProviderShards] Mint failed");\n', '\t\temit ShardsClaimed(msg.sender, cut);\n', '\t} */\n', '\n', '\tfunction mintReservedShards(address _beneficiary) external {\n', '\t\tbool niftex;\n', '\t\tif (_beneficiary == _niftexWalletAddress) niftex = true;\n', '\t\trequire(\n', '\t\t\tniftex ||\n', '\t\t\t_beneficiary == _artistWalletAddress,\n', '\t\t\t"[mintReservedShards] Unauthorized beneficiary"\n', '\t\t);\n', '\t\trequire(\n', '\t\t\t!_shardOffering.hasClaimedShards(_beneficiary),\n', '\t\t\t"[mintReservedShards] Shards already claimed"\n', '\t\t);\n', '\t\t_shardOffering.claimShards(_beneficiary);\n', '\t\tuint cut;\n', '\t\tif (niftex) {\n', '\t\t\tcut = _shardOffering.liqProviderCutInShards();\n', '\t\t} else {\n', '\t\t\tcut = _shardOffering.artistCutInShards();\n', '\t\t}\n', '\t\tbool success = _shardRegistry.mint(_beneficiary, cut);\n', '\t\trequire(success, "[mintReservedShards] Mint failed");\n', '\t\temit ShardsClaimed(_beneficiary, cut);\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice In the unlikely case that one account accumulates all Shards,\n', '\t\t* they can be redeemed directly for the underlying NFT.\n', '\t\t*/\n', '\tfunction redeem() external {\n', '\t\trequire(\n', '\t\t\t_shardRegistry.balanceOf(msg.sender) == _shardRegistry.cap(),\n', '\t\t\t"[redeem] Account does not own total amount of Shards outstanding"\n', '\t\t);\n', '\t\tIERC721(_nftRegistryAddress).safeTransferFrom(address(this), msg.sender, _tokenId);\n', '\t\temit NftRedeemed(msg.sender);\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Creates a new Shotgun claim.\n', "\t\t* @dev This Function is called from the Shard Registry because the claimant's\n", '\t\t* Shards must be frozen until the Shotgun is resolved: if they lose the claim,\n', '\t\t* their Shards are automatically distributed to the counterclaimants.\n', '\t\t* @dev The Registry is paused while an active Shotgun claim exists to\n', '\t\t* let the process work in an orderly manner.\n', '\t\t* @param initialClaimantAddress wallet address of the person who initiated Shotgun.\n', '\t\t* @param initialClaimantBalance Shard balance of the person who initiated Shotgun.\n', '\t\t*/\n', '\tfunction claimInitialShotgun(\n', '\t\taddress payable initialClaimantAddress,\n', '\t\tuint initialClaimantBalance\n', '\t) external payable returns (bool) {\n', '\t\trequire(\n', '\t\t\tmsg.sender == address(_shardRegistry),\n', '\t\t\t"[claimInitialShotgun] Caller not authorized"\n', '\t\t);\n', '\t\t_currentShotgunClause = (new ShotgunClause).value(msg.value)(\n', '\t\t\tinitialClaimantAddress,\n', '\t\t\tinitialClaimantBalance,\n', '\t\t\taddress(_shardRegistry)\n', '\t\t);\n', '\t\temit NewShotgun(address(_currentShotgunClause));\n', '\t\t_shardRegistry.pause();\n', '\t\t_shotgunAddressArray.push(address(_currentShotgunClause));\n', '\t\t_shotgunCounter++;\n', '\t\t_shotgunMapping[address(_currentShotgunClause)] = _shotgunCounter;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Effects the results of a (un)successful Shotgun claim.\n', '\t\t* @dev This Function can only be called by a Shotgun contract in two scenarios:\n', '\t\t* - Counterclaimants raise enough ether to buy claimant out\n', '\t\t* - Shotgun deadline passes without successful counter-raise, claimant wins\n', '\t\t*/\n', '\tfunction enactShotgun() external {\n', '\t\trequire(\n', '\t\t\t_shotgunMapping[msg.sender] != 0,\n', '\t\t\t"[enactShotgun] Invalid Shotgun Clause"\n', '\t\t);\n', '\t\tShotgunClause _shotgunClause = ShotgunClause(msg.sender);\n', '\t\taddress initialClaimantAddress = _shotgunClause.initialClaimantAddress();\n', '\t\tif (uint(_shotgunClause.claimWinner()) == uint(ClaimWinner.Claimant)) {\n', '\t\t\t_shardRegistry.burn(_shardRegistry.balanceOf(initialClaimantAddress));\n', '\t\t\tIERC721(_nftRegistryAddress).safeTransferFrom(address(this), initialClaimantAddress, _tokenId);\n', '\t\t\t_shardRegistry.unpause();\n', '\t\t\temit ShotgunEnacted(address(_shotgunClause));\n', '\t\t} else if (uint(_shotgunClause.claimWinner()) == uint(ClaimWinner.Counterclaimant)) {\n', '\t\t\t_shardRegistry.unpause();\n', '\t\t\temit ShotgunEnacted(address(_shotgunClause));\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Transfer Shards to counterclaimants after unsuccessful Shotgun claim.\n', "\t\t* @dev This contract custodies the claimant's Shards when they claim Shotgun -\n", '\t\t* if they lose the claim these Shards must be transferred to counterclaimants.\n', '\t\t* This process is initiated by the relevant Shotgun contract.\n', '\t\t* @param recipient wallet address of the person receiving the Shards.\n', '\t\t* @param amount the amount of Shards to receive.\n', '\t\t*/\n', '\tfunction transferShards(address recipient, uint amount) external {\n', '\t\trequire(\n', '\t\t\t_shotgunMapping[msg.sender] != 0,\n', '\t\t\t"[transferShards] Unauthorized caller"\n', '\t\t);\n', '\t\tbool success = _shardRegistry.transfer(recipient, amount);\n', '\t\trequire(success, "[transferShards] Transfer failed");\n', '\t\temit ShardsCollected(recipient, amount, msg.sender);\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Allows liquidity providers to pull funds during shotgun.\n', '\t\t* @dev Requires Unitokens to be sent to the contract so the contract can\n', '\t\t* remove liquidity.\n', '\t\t* @param exchangeAddress address of the Uniswap pool.\n', '\t\t* @param liqProvAddress address of the liquidity provider.\n', '\t\t* @param uniTokenAmount liquidity tokens to redeem.\n', '\t\t* @param minEth minimum ether to withdraw.\n', '\t\t* @param minTokens minimum tokens to withdraw.\n', '\t\t* @param deadline deadline for the withdrawal.\n', '\t\t*/\n', '\tfunction pullLiquidity(\n', '\t\taddress exchangeAddress,\n', '\t\taddress liqProvAddress,\n', '\t\tuint256 uniTokenAmount,\n', '\t\tuint256 minEth,\n', '\t\tuint256 minTokens,\n', '\t\tuint256 deadline\n', '\t) public {\n', '\t\trequire(msg.sender == _niftexWalletAddress, "[pullLiquidity] Unauthorized call");\n', '\t\tIUniswapExchange uniExchange = IUniswapExchange(exchangeAddress);\n', '\t\tuniExchange.transferFrom(liqProvAddress, address(this), uniTokenAmount);\n', '\t\t_shardRegistry.unpause();\n', '\t\t(uint ethAmount, uint tokenAmount) = uniExchange.removeLiquidity(uniTokenAmount, minEth, minTokens, deadline);\n', '\t\t(bool ethSuccess, ) = liqProvAddress.call.value(ethAmount)("");\n', '\t\trequire(ethSuccess, "[pullLiquidity] ETH transfer failed.");\n', '\t\tbool tokenSuccess = _shardRegistry.transfer(liqProvAddress, tokenAmount);\n', '\t\trequire(tokenSuccess, "[pullLiquidity] Token transfer failed");\n', '\t\t_shardRegistry.pause();\n', '\t}\n', '\n', '\t/**\n', '\t\t* @dev Utility function to check if a Shotgun is in progress.\n', '\t\t*/\n', '\tfunction checkShotgunState() external view returns (bool) {\n', '\t\tif (_shotgunCounter == 0) {\n', '\t\t\treturn true;\n', '\t\t} else {\n', '\t\t\tShotgunClause _shotgunClause = ShotgunClause(_shotgunAddressArray[_shotgunCounter - 1]);\n', '\t\t\tif (_shotgunClause.shotgunEnacted()) {\n', '\t\t\t\treturn true;\n', '\t\t\t} else {\n', '\t\t\t\treturn false;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\tfunction currentShotgunClause() external view returns (address) {\n', '\t\treturn address(_currentShotgunClause);\n', '\t}\n', '\n', '\tfunction shardRegistryAddress() external view returns (address) {\n', '\t\treturn address(_shardRegistry);\n', '\t}\n', '\n', '\tfunction shardOfferingAddress() external view returns (address) {\n', '\t\treturn address(_shardOffering);\n', '\t}\n', '\n', '\tfunction getContractBalance() external view returns (uint) {\n', '\t\treturn address(this).balance;\n', '\t}\n', '\n', '\tfunction offererAddress() external view returns (address payable) {\n', '\t\treturn _offererAddress;\n', '\t}\n', '\n', '\tfunction shotgunCounter() external view returns (uint) {\n', '\t\treturn _shotgunCounter;\n', '\t}\n', '\n', '\tfunction shotgunAddressArray() external view returns (address[] memory) {\n', '\t\treturn _shotgunAddressArray;\n', '\t}\n', '\n', '\t/**\n', '\t\t* @dev Utility function to check whether this contract owns the Sharded NFT.\n', '\t\t*/\n', '\tfunction checkLock() external view returns (bool) {\n', '\t\taddress owner = IERC721(_nftRegistryAddress).ownerOf(_tokenId);\n', '\t\treturn owner == address(this);\n', '\t}\n', '\n', '\t/**\n', '\t\t* @notice Handle the receipt of an NFT.\n', '\t\t* @dev The ERC721 smart contract calls this function on the recipient\n', '\t\t* after a `safetransfer`. This function MAY throw to revert and reject the\n', '\t\t* transfer. Return of other than the magic value MUST result in the\n', '\t\t* transaction being reverted.\n', '\t\t* Note: the contract address is always the message sender.\n', '\t\t* @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '\t\t*/\n', '\tfunction onERC721Received(address, address, uint256, bytes memory) public returns(bytes4) {\n', '\t\treturn _ERC721_RECEIVED;\n', '\t}\n', '}']