['/* \n', ' * Copyright (c) Capital Market and Technology Association, 2018-2019\n', ' * https://cmta.ch\n', ' *\n', ' * This Source Code Form is subject to the terms of the Mozilla Public\n', ' * License, v. 2.0. If a copy of the MPL was not distributed with this\n', ' * file, You can obtain one at https://mozilla.org/MPL/2.0/. \n', ' */\n', '\n', 'pragma solidity ^0.5.3;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./ERC20.sol";\n', 'import "./Pausable.sol";\n', 'import "./Ownable.sol";\n', 'import "./IIssuable.sol";\n', 'import "./IDestroyable.sol";\n', 'import "./IReassignable.sol";\n', 'import "./IIdentifiable.sol";\n', 'import "./IContactable.sol";\n', 'import "./IRuleEngine.sol";\n', '\n', '/**\n', ' * @title CMTA20\n', ' * @dev CMTA20 contract\n', ' *\n', ' * @author SÃ©bastien Krafft - <[email\xa0protected]>\n', ' *\n', ' * errors:\n', ' * CM01: Attempt to reassign from an original address which is 0x0\n', ' * CM02: Attempt to reassign to a replacement address is 0x0\n', ' * CM03: Attempt to reassign to replacement address which is the same as the original address\n', ' * CM04: Transfer rejected by Rule Engine \n', ' * CM05: Attempt to reassign from an original address which does not have any tokens\n', ' * CM06: Cannot call destroy with owner address contained in parameter\n', ' */\n', '\n', ' \n', 'contract CMTA20 is ERC20, Ownable, Pausable, IContactable, IIdentifiable, IIssuable, IDestroyable, IReassignable {\n', '  using SafeMath for uint256;\n', '\n', '  /* Constants */\n', '  uint8 constant TRANSFER_OK = 0;\n', '  uint8 constant TRANSFER_REJECTED_PAUSED = 1;\n', '\n', '  string constant TEXT_TRANSFER_OK = "No restriction";\n', '  string constant TEXT_TRANSFER_REJECTED_PAUSED = "All transfers paused";\n', '\n', '  string public name;\n', '  string public symbol;\n', '  string public contact;\n', '  mapping (address => bytes) internal identities;\n', '  IRuleEngine public ruleEngine;\n', '\n', '  // solium-disable-next-line uppercase\n', '  uint8 constant public decimals = 0;\n', '\n', '  constructor(string memory _name, string memory _symbol, string memory _contact) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    contact = _contact;\n', '  }\n', '\n', '  event LogRuleEngineSet(address indexed newRuleEngine);\n', '\n', '  /**\n', '  * Purpose\n', '  * Set optional rule engine by owner\n', '  * \n', '  * @param _ruleEngine - the rule engine that will approve/reject transfers\n', '  */\n', '  function setRuleEngine(IRuleEngine _ruleEngine) external onlyOwner {\n', '    ruleEngine = _ruleEngine;\n', '    emit LogRuleEngineSet(address(_ruleEngine));\n', '  }\n', '\n', '  /**\n', '  * Purpose\n', '  * Set contact point for shareholders\n', '  * \n', '  * @param _contact - the contact information for the shareholders\n', '  */\n', '  function setContact(string calldata _contact) external onlyOwner {\n', '    contact = _contact;\n', '    emit LogContactSet(_contact);\n', '  }\n', '\n', '  /**\n', '  * Purpose\n', '  * Retrieve identity of a potential/actual shareholder\n', '  */\n', '  function identity(address shareholder) external view returns (bytes memory) {\n', '    return identities[shareholder];\n', '  }\n', '\n', '  /**\n', '  * Purpose\n', '  * Set identity of a potential/actual shareholder. Can only be called by the potential/actual shareholder himself. Has to be encrypted data.\n', '  * \n', '  * @param _identity - the potential/actual shareholder identity\n', '  */\n', '  function setMyIdentity(bytes calldata _identity) external {\n', '    identities[msg.sender] = _identity;\n', '  }\n', '\n', '  /**\n', '  * Purpose:\n', '  * Issue tokens on the owner address\n', '  *\n', '  * @param _value - amount of newly issued tokens\n', '  */\n', '  function issue(uint256 _value) public onlyOwner {\n', '    _balances[owner] = _balances[owner].add(_value);\n', '    _totalSupply = _totalSupply.add(_value);\n', '\n', '    emit Transfer(address(0), owner, _value);\n', '    emit LogIssued(_value);\n', '  }\n', '\n', '  /**\n', '  * Purpose:\n', '  * Redeem tokens on the owner address\n', '  *\n', '  * @param _value - amount of redeemed tokens\n', '  */\n', '  function redeem(uint256 _value) public onlyOwner {\n', '    _balances[owner] = _balances[owner].sub(_value);\n', '    _totalSupply = _totalSupply.sub(_value);\n', '\n', '    emit Transfer(owner, address(0), _value);\n', '    emit LogRedeemed(_value);\n', '  }\n', '\n', '  /**\n', '  * @dev check if _value token can be transferred from _from to _to\n', '  * @param _from address The address which you want to send tokens from\n', '  * @param _to address The address which you want to transfer to\n', '  * @param _value uint256 the amount of tokens to be transferred\n', '  */\n', '  function canTransfer(address _from, address _to, uint256 _value) public view returns (bool) {\n', '    if (paused()) {\n', '      return false;\n', '    }\n', '    if (address(ruleEngine) != address(0)) {\n', '      return ruleEngine.validateTransfer(_from, _to, _value);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev check if _value token can be transferred from _from to _to\n', '  * @param _from address The address which you want to send tokens from\n', '  * @param _to address The address which you want to transfer to\n', '  * @param _value uint256 the amount of tokens to be transferred\n', '  * @return code of the rejection reason\n', '  */\n', '  function detectTransferRestriction (address _from, address _to, uint256 _value) public view returns (uint8) {\n', '    if (paused()) {\n', '      return TRANSFER_REJECTED_PAUSED;\n', '    }\n', '    if (address(ruleEngine) != address(0)) {\n', '      return ruleEngine.detectTransferRestriction(_from, _to, _value);\n', '    }\n', '    return TRANSFER_OK;\n', '  }\n', '\n', '  /**\n', '  * @dev returns the human readable explaination corresponding to the error code returned by detectTransferRestriction\n', '  * @param _restrictionCode The error code returned by detectTransferRestriction\n', '  * @return The human readable explaination corresponding to the error code returned by detectTransferRestriction\n', '  */\n', '  function messageForTransferRestriction (uint8 _restrictionCode) external view returns (string memory) {\n', '    if (_restrictionCode == TRANSFER_OK) {\n', '      return TEXT_TRANSFER_OK;\n', '    } else if (_restrictionCode == TRANSFER_REJECTED_PAUSED) {\n', '      return TEXT_TRANSFER_REJECTED_PAUSED;\n', '    } else if (address(ruleEngine) != address(0)) {\n', '      return ruleEngine.messageForTransferRestriction(_restrictionCode);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '    if (address(ruleEngine) != address(0)) {\n', '      require(ruleEngine.validateTransfer(msg.sender, _to, _value), "CM04");\n', '      return super.transfer(_to, _value);\n', '    } else {\n', '      return super.transfer(_to, _value);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amount of tokens to be transferred\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '    if (address(ruleEngine) != address(0)) {\n', '      require(ruleEngine.validateTransfer(_from, _to, _value), "CM04");\n', '      return super.transferFrom(_from, _to, _value);\n', '    } else {\n', '      return super.transferFrom(_from, _to, _value);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   *\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n', '    return super.approve(_spender, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _addedValue The amount of tokens to increase the allowance by.\n', '   */\n', '  function increaseAllowance(address _spender, uint256 _addedValue) public whenNotPaused returns (bool)\n', '  {\n', '    return super.increaseAllowance(_spender, _addedValue);\n', '  }\n', '\n', '  /**\n', '   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '   *\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '   */\n', '  function decreaseAllowance(address _spender, uint256 _subtractedValue) public whenNotPaused returns (bool)\n', '  {\n', '    return super.decreaseAllowance(_spender, _subtractedValue);\n', '  }\n', '\n', '  /**\n', '  * Purpose:\n', '  * To withdraw tokens from the original address and\n', '  * transfer those tokens to the replacement address.\n', '  * Use in cases when e.g. investor loses access to his account.\n', '  *\n', '  * Conditions:\n', '  * Throw error if the `original` address supplied is not a shareholder.\n', '  * Only issuer can execute this function.\n', '  *\n', '  * @param original - original address\n', '  * @param replacement - replacement address\n', '    */\n', '  function reassign(address original, address replacement) external onlyOwner whenNotPaused {\n', '    require(original != address(0), "CM01");\n', '    require(replacement != address(0), "CM02");\n', '    require(original != replacement, "CM03");\n', '    uint256 originalBalance = _balances[original];\n', '    require(originalBalance != 0, "CM05");\n', '    _balances[replacement] = _balances[replacement].add(originalBalance);\n', '    _balances[original] = 0;\n', '    emit Transfer(original, replacement, originalBalance);\n', '    emit LogReassigned(original, replacement, originalBalance);\n', '  }\n', '\n', '  /**\n', '  * Purpose;\n', '  * To destroy issued tokens.\n', '  *\n', '  * Conditions:\n', '  * Only issuer can execute this function.\n', '  *\n', '  * @param shareholders - list of shareholders\n', '  */\n', '  function destroy(address[] calldata shareholders) external onlyOwner {\n', '    for (uint256 i = 0; i<shareholders.length; i++) {\n', '      require(shareholders[i] != owner, "CM06");\n', '      uint256 shareholderBalance = _balances[shareholders[i]];\n', '      _balances[owner] = _balances[owner].add(shareholderBalance);\n', '      _balances[shareholders[i]] = 0;\n', '      emit Transfer(shareholders[i], owner, shareholderBalance);\n', '    }\n', '    emit LogDestroyed(shareholders);\n', '  }\n', '}']