['/**************************************************************************\n', ' *            ____        _                              \n', ' *           / ___|      | |     __ _  _   _   ___  _ __ \n', " *          | |    _____ | |    / _` || | | | / _ \\| '__|\n", ' *          | |___|_____|| |___| (_| || |_| ||  __/| |   \n', ' *           \\____|      |_____|\\__,_| \\__, | \\___||_|   \n', ' *                                     |___/             \n', ' * \n', ' **************************************************************************\n', ' *\n', ' *  The MIT License (MIT)\n', ' * SPDX-License-Identifier: MIT\n', ' *\n', ' * Copyright (c) 2016-2020 Cyril Lapinte\n', ' *\n', ' * Permission is hereby granted, free of charge, to any person obtaining\n', ' * a copy of this software and associated documentation files (the\n', ' * "Software"), to deal in the Software without restriction, including\n', ' * without limitation the rights to use, copy, modify, merge, publish,\n', ' * distribute, sublicense, and/or sell copies of the Software, and to\n', ' * permit persons to whom the Software is furnished to do so, subject to\n', ' * the following conditions:\n', ' *\n', ' * The above copyright notice and this permission notice shall be included\n', ' * in all copies or substantial portions of the Software.\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' *\n', ' **************************************************************************\n', ' *\n', ' * Flatten Contract: VotingSessionDelegate\n', ' *\n', ' * Git Commit:\n', ' * https://github.com/c-layer/contracts/commit/9993912325afde36151b04d0247ac9ea9ffa2a93\n', ' *\n', ' **************************************************************************/\n', '\n', '\n', '// File: contracts/interface/IVotingDefinitions.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IVotingDefinitions\n', ' * @dev IVotingDefinitions interface\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'abstract contract IVotingDefinitions {\n', '\n', '  address internal constant ANY_TARGET = address(bytes20("AnyTarget"));\n', '  bytes4 internal constant ANY_METHOD = bytes4(bytes32("AnyMethod"));\n', '\n', '  enum SessionState {\n', '    UNDEFINED,\n', '    PLANNED,\n', '    CAMPAIGN,\n', '    VOTING,\n', '    EXECUTION,\n', '    GRACE,\n', '    CLOSED,\n', '    ARCHIVED\n', '  }\n', '\n', '  enum ProposalState {\n', '    UNDEFINED,\n', '    DEFINED,\n', '    CANCELLED,\n', '    LOCKED,\n', '    APPROVED,\n', '    REJECTED,\n', '    RESOLVED,\n', '    CLOSED,\n', '    ARCHIVED\n', '  }\n', '\n', '  // 4 digits precisions on percentage values\n', '  uint256 internal constant PERCENT = 1000000;\n', '\n', '  uint64 internal constant MIN_PERIOD_LENGTH = 200;\n', '  // MAX_PERIOD_LENGTH (approx 10000 years) protects against period overflow\n', '  uint64 internal constant MAX_PERIOD_LENGTH = 3652500 days;\n', '  uint64 internal constant CAMPAIGN_PERIOD = 5 days;\n', '  uint64 internal constant VOTING_PERIOD = 2 days;\n', '  uint64 internal constant EXECUTION_PERIOD = 1 days;\n', '  uint64 internal constant GRACE_PERIOD = 6 days;\n', '  uint64 internal constant OFFSET_PERIOD = 2 days;\n', '\n', '  // Proposal requirements in percent\n', '  uint256 internal constant NEW_PROPOSAL_THRESHOLD = 1;\n', '  uint256 internal constant DEFAULT_EXECUTION_THRESHOLD = 1;\n', '  uint128 internal constant DEFAULT_MAJORITY = 500000; // 50%\n', '  uint128 internal constant DEFAULT_QUORUM = 200000; // 20%\n', '\n', '  uint8 internal constant OPEN_PROPOSALS = 5;\n', '  uint8 internal constant MAX_PROPOSALS = 20;\n', '  uint8 internal constant MAX_PROPOSALS_OPERATOR = 25;\n', '\n', '  uint256 internal constant SESSION_RETENTION_PERIOD = 365 days;\n', '  uint256 internal constant SESSION_RETENTION_COUNT = 10;\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' *\n', ' */\n', 'interface IERC20 {\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '\n', '  function name() external view returns (string memory);\n', '  function symbol() external view returns (string memory);\n', '  function decimals() external view returns (uint256);\n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address _owner) external view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '\n', '  function allowance(address _owner, address _spender)\n', '    external view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    external returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) external returns (bool);\n', '\n', '  function increaseApproval(address _spender, uint256 _addedValue)\n', '    external returns (bool);\n', '\n', '  function decreaseApproval(address _spender, uint256 _subtractedValue)\n', '    external returns (bool);\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IProxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @title IProxy\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' **/\n', 'interface IProxy {\n', '\n', '  function core() external view returns (address);\n', '\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/Proxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' *   PR01: Only accessible by core\n', ' *   PR02: Core request should be successful\n', ' **/\n', 'contract Proxy is IProxy {\n', '\n', '  address public override core;\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than a core\n', '   */\n', '  modifier onlyCore {\n', '    require(core == msg.sender, "PR01");\n', '    _;\n', '  }\n', '\n', '  constructor(address _core) public {\n', '    core = _core;\n', '  }\n', '\n', '  /**\n', '   * @dev update the core\n', '   */\n', '  function updateCore(address _core)\n', '    public onlyCore returns (bool)\n', '  {\n', '    core = _core;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev enforce static immutability (view)\n', '   * @dev in order to read core value through internal core delegateCall\n', '   */\n', '  function staticCallUint256() internal view returns (uint256 value) {\n', '    (bool status, bytes memory result) = core.staticcall(msg.data);\n', '    require(status, string(result));\n', '    value = abi.decode(result, (uint256));\n', '  }\n', '}\n', '\n', '// File: @c-layer/token/contracts/interface/ITokenProxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title IToken proxy\n', ' * @dev Token proxy interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'abstract contract ITokenProxy is IERC20, Proxy {\n', '\n', '  function canTransfer(address, address, uint256)\n', '    virtual public view returns (uint256);\n', '\n', '  function emitTransfer(address _from, address _to, uint256 _value)\n', '    virtual public returns (bool);\n', '\n', '  function emitApproval(address _owner, address _spender, uint256 _value)\n', '    virtual public returns (bool);\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IAccessDefinitions.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IAccessDefinitions\n', ' * @dev IAccessDefinitions\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'contract IAccessDefinitions {\n', '\n', '  // Hardcoded role granting all - non sysop - privileges\n', '  bytes32 internal constant ALL_PRIVILEGES = bytes32("AllPrivileges");\n', '  address internal constant ALL_PROXIES = address(0x416c6C50726F78696573); // "AllProxies"\n', '\n', '  // Roles\n', '  bytes32 internal constant FACTORY_CORE_ROLE = bytes32("FactoryCoreRole");\n', '  bytes32 internal constant FACTORY_PROXY_ROLE = bytes32("FactoryProxyRole");\n', '\n', '  // Sys Privileges\n', '  bytes4 internal constant DEFINE_ROLE_PRIV =\n', '    bytes4(keccak256("defineRole(bytes32,bytes4[])"));\n', '  bytes4 internal constant ASSIGN_OPERATORS_PRIV =\n', '    bytes4(keccak256("assignOperators(bytes32,address[])"));\n', '  bytes4 internal constant REVOKE_OPERATORS_PRIV =\n', '    bytes4(keccak256("revokeOperators(address[])"));\n', '  bytes4 internal constant ASSIGN_PROXY_OPERATORS_PRIV =\n', '    bytes4(keccak256("assignProxyOperators(address,bytes32,address[])"));\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IOperableStorage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title IOperableStorage\n', ' * @dev The Operable storage\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'abstract contract IOperableStorage is IAccessDefinitions {\n', '  function proxyDelegateId(address _proxy) virtual public view returns (uint256);\n', '  function delegate(uint256 _delegateId) virtual public view returns (address);\n', '\n', '  function coreRole(address _address) virtual public view returns (bytes32);\n', '  function proxyRole(address _proxy, address _address) virtual public view returns (bytes32);\n', '  function rolePrivilege(bytes32 _role, bytes4 _privilege) virtual public view returns (bool);\n', '  function roleHasPrivilege(bytes32 _role, bytes4 _privilege) virtual public view returns (bool);\n', '  function hasCorePrivilege(address _address, bytes4 _privilege) virtual public view returns (bool);\n', '  function hasProxyPrivilege(address _address, address _proxy, bytes4 _privilege) virtual public view returns (bool);\n', '\n', '  event RoleDefined(bytes32 role);\n', '  event OperatorAssigned(bytes32 role, address operator);\n', '  event ProxyOperatorAssigned(address proxy, bytes32 role, address operator);\n', '  event OperatorRevoked(address operator);\n', '  event ProxyOperatorRevoked(address proxy, address operator);\n', '\n', '  event ProxyDefined(address proxy, uint256 delegateId);\n', '  event ProxyMigrated(address proxy, address newCore);\n', '  event ProxyRemoved(address proxy);\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IOperableCore.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title IOperableCore\n', ' * @dev The Operable contract enable the restrictions of operations to a set of operators\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'abstract contract IOperableCore is IOperableStorage {\n', '  function defineRole(bytes32 _role, bytes4[] memory _privileges) virtual public returns (bool);\n', '  function assignOperators(bytes32 _role, address[] memory _operators) virtual public returns (bool);\n', '  function assignProxyOperators(\n', '    address _proxy, bytes32 _role, address[] memory _operators) virtual public returns (bool);\n', '  function revokeOperators(address[] memory _operators) virtual public returns (bool);\n', '  function revokeProxyOperators(address _proxy, address[] memory _operators) virtual public returns (bool);\n', '\n', '  function defineProxy(address _proxy, uint256 _delegateId) virtual public returns (bool);\n', '  function migrateProxy(address _proxy, address _newCore) virtual public returns (bool);\n', '  function removeProxy(address _proxy) virtual public returns (bool);\n', '}\n', '\n', '// File: @c-layer/oracle/contracts/interface/IUserRegistry.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IUserRegistry\n', ' * @dev IUserRegistry interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' **/\n', 'abstract contract IUserRegistry {\n', '\n', '  enum KeyCode {\n', '    KYC_LIMIT_KEY,\n', '    RECEPTION_LIMIT_KEY,\n', '    EMISSION_LIMIT_KEY\n', '  }\n', '\n', '  event UserRegistered(uint256 indexed userId, address address_, uint256 validUntilTime);\n', '  event AddressAttached(uint256 indexed userId, address address_);\n', '  event AddressDetached(uint256 indexed userId, address address_);\n', '  event UserSuspended(uint256 indexed userId);\n', '  event UserRestored(uint256 indexed userId);\n', '  event UserValidity(uint256 indexed userId, uint256 validUntilTime);\n', '  event UserExtendedKey(uint256 indexed userId, uint256 key, uint256 value);\n', '  event UserExtendedKeys(uint256 indexed userId, uint256[] values);\n', '  event ExtendedKeysDefinition(uint256[] keys);\n', '\n', '  function registerManyUsersExternal(address[] calldata _addresses, uint256 _validUntilTime)\n', '    virtual external returns (bool);\n', '  function registerManyUsersFullExternal(\n', '    address[] calldata _addresses,\n', '    uint256 _validUntilTime,\n', '    uint256[] calldata _values) virtual external returns (bool);\n', '  function attachManyAddressesExternal(uint256[] calldata _userIds, address[] calldata _addresses)\n', '    virtual external returns (bool);\n', '  function detachManyAddressesExternal(address[] calldata _addresses)\n', '    virtual external returns (bool);\n', '  function suspendManyUsersExternal(uint256[] calldata _userIds) virtual external returns (bool);\n', '  function restoreManyUsersExternal(uint256[] calldata _userIds) virtual external returns (bool);\n', '  function updateManyUsersExternal(\n', '    uint256[] calldata _userIds,\n', '    uint256 _validUntilTime,\n', '    bool _suspended) virtual external returns (bool);\n', '  function updateManyUsersExtendedExternal(\n', '    uint256[] calldata _userIds,\n', '    uint256 _key, uint256 _value) virtual external returns (bool);\n', '  function updateManyUsersAllExtendedExternal(\n', '    uint256[] calldata _userIds,\n', '    uint256[] calldata _values) virtual external returns (bool);\n', '  function updateManyUsersFullExternal(\n', '    uint256[] calldata _userIds,\n', '    uint256 _validUntilTime,\n', '    bool _suspended,\n', '    uint256[] calldata _values) virtual external returns (bool);\n', '\n', '  function name() virtual public view returns (string memory);\n', '  function currency() virtual public view returns (bytes32);\n', '\n', '  function userCount() virtual public view returns (uint256);\n', '  function userId(address _address) virtual public view returns (uint256);\n', '  function validUserId(address _address) virtual public view returns (uint256);\n', '  function validUser(address _address, uint256[] memory _keys)\n', '    virtual public view returns (uint256, uint256[] memory);\n', '  function validity(uint256 _userId) virtual public view returns (uint256, bool);\n', '\n', '  function extendedKeys() virtual public view returns (uint256[] memory);\n', '  function extended(uint256 _userId, uint256 _key)\n', '    virtual public view returns (uint256);\n', '  function manyExtended(uint256 _userId, uint256[] memory _key)\n', '    virtual public view returns (uint256[] memory);\n', '\n', '  function isAddressValid(address _address) virtual public view returns (bool);\n', '  function isValid(uint256 _userId) virtual public view returns (bool);\n', '\n', '  function defineExtendedKeys(uint256[] memory _extendedKeys) virtual public returns (bool);\n', '\n', '  function registerUser(address _address, uint256 _validUntilTime)\n', '    virtual public returns (bool);\n', '  function registerUserFull(\n', '    address _address,\n', '    uint256 _validUntilTime,\n', '    uint256[] memory _values) virtual public returns (bool);\n', '\n', '  function attachAddress(uint256 _userId, address _address) virtual public returns (bool);\n', '  function detachAddress(address _address) virtual public returns (bool);\n', '  function detachSelf() virtual public returns (bool);\n', '  function detachSelfAddress(address _address) virtual public returns (bool);\n', '  function suspendUser(uint256 _userId) virtual public returns (bool);\n', '  function restoreUser(uint256 _userId) virtual public returns (bool);\n', '  function updateUser(uint256 _userId, uint256 _validUntilTime, bool _suspended)\n', '    virtual public returns (bool);\n', '  function updateUserExtended(uint256 _userId, uint256 _key, uint256 _value)\n', '    virtual public returns (bool);\n', '  function updateUserAllExtended(uint256 _userId, uint256[] memory _values)\n', '    virtual public returns (bool);\n', '  function updateUserFull(\n', '    uint256 _userId,\n', '    uint256 _validUntilTime,\n', '    bool _suspended,\n', '    uint256[] memory _values) virtual public returns (bool);\n', '}\n', '\n', '// File: @c-layer/oracle/contracts/interface/IRatesProvider.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IRatesProvider\n', ' * @dev IRatesProvider interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'abstract contract IRatesProvider {\n', '\n', '  function defineRatesExternal(uint256[] calldata _rates) virtual external returns (bool);\n', '\n', '  function name() virtual public view returns (string memory);\n', '\n', '  function rate(bytes32 _currency) virtual public view returns (uint256);\n', '\n', '  function currencies() virtual public view\n', '    returns (bytes32[] memory, uint256[] memory, uint256);\n', '  function rates() virtual public view returns (uint256, uint256[] memory);\n', '\n', '  function convert(uint256 _amount, bytes32 _fromCurrency, bytes32 _toCurrency)\n', '    virtual public view returns (uint256);\n', '\n', '  function defineCurrencies(\n', '    bytes32[] memory _currencies,\n', '    uint256[] memory _decimals,\n', '    uint256 _rateOffset) virtual public returns (bool);\n', '  function defineRates(uint256[] memory _rates) virtual public returns (bool);\n', '\n', '  event RateOffset(uint256 rateOffset);\n', '  event Currencies(bytes32[] currencies, uint256[] decimals);\n', '  event Rate(bytes32 indexed currency, uint256 rate);\n', '}\n', '\n', '// File: @c-layer/token/contracts/interface/IRule.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IRule\n', ' * @dev IRule interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' **/\n', 'interface IRule {\n', '  function isAddressValid(address _address) external view returns (bool);\n', '  function isTransferValid(address _from, address _to, uint256 _amount)\n', '    external view returns (bool);\n', '}\n', '\n', '// File: @c-layer/token/contracts/interface/ITokenStorage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ITokenStorage\n', ' * @dev Token storage interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'abstract contract ITokenStorage {\n', '  enum TransferCode {\n', '    UNKNOWN,\n', '    OK,\n', '    INVALID_SENDER,\n', '    NO_RECIPIENT,\n', '    INSUFFICIENT_TOKENS,\n', '    LOCKED,\n', '    FROZEN,\n', '    RULE,\n', '    INVALID_RATE,\n', '    NON_REGISTRED_SENDER,\n', '    NON_REGISTRED_RECEIVER,\n', '    LIMITED_EMISSION,\n', '    LIMITED_RECEPTION\n', '  }\n', '\n', '  enum Scope {\n', '    DEFAULT\n', '  }\n', '\n', '  enum AuditStorageMode {\n', '    ADDRESS,\n', '    USER_ID,\n', '    SHARED\n', '  }\n', '\n', '  enum AuditTriggerMode {\n', '    UNDEFINED,\n', '    NONE,\n', '    SENDER_ONLY,\n', '    RECEIVER_ONLY,\n', '    BOTH\n', '  }\n', '\n', '  address internal constant ANY_ADDRESSES = address(0x416e79416464726573736573); // "AnyAddresses"\n', '\n', '  event OracleDefined(\n', '    IUserRegistry userRegistry,\n', '    IRatesProvider ratesProvider,\n', '    address currency);\n', '  event TokenDelegateDefined(uint256 indexed delegateId, address delegate, uint256[] configurations);\n', '  event TokenDelegateRemoved(uint256 indexed delegateId);\n', '  event AuditConfigurationDefined(\n', '    uint256 indexed configurationId,\n', '    uint256 scopeId,\n', '    AuditTriggerMode mode,\n', '    uint256[] senderKeys,\n', '    uint256[] receiverKeys,\n', '    IRatesProvider ratesProvider,\n', '    address currency);\n', '  event AuditTriggersDefined(\n', '    uint256 indexed configurationId,\n', '    address[] senders,\n', '    address[] receivers,\n', '    AuditTriggerMode[] modes);\n', '  event AuditsRemoved(address scope, uint256 scopeId);\n', '  event SelfManaged(address indexed holder, bool active);\n', '\n', '  event Minted(address indexed token, uint256 amount);\n', '  event MintFinished(address indexed token);\n', '  event Burned(address indexed token, uint256 amount);\n', '  event RulesDefined(address indexed token, IRule[] rules);\n', '  event LockDefined(\n', '    address indexed lock,\n', '    address sender,\n', '    address receiver,\n', '    uint256 startAt,\n', '    uint256 endAt\n', '  );\n', '  event Seize(address indexed token, address account, uint256 amount);\n', '  event Freeze(address address_, uint256 until);\n', '  event ClaimDefined(\n', '    address indexed token,\n', '    address indexed claim,\n', '    uint256 claimAt);\n', '  event TokenLocksDefined(\n', '    address indexed token,\n', '    address[] locks);\n', '  event TokenDefined(\n', '    address indexed token,\n', '    string name,\n', '    string symbol,\n', '    uint256 decimals);\n', '  event LogTransferData(\n', '    address token, address caller, address sender, address receiver,\n', '    uint256 senderId, uint256[] senderKeys, bool senderFetched,\n', '    uint256 receiverId, uint256[] receiverKeys, bool receiverFetched,\n', '    uint256 value, uint256 convertedValue);\n', '  event LogTransferAuditData(\n', '    uint256 auditConfigurationId, uint256 scopeId,\n', '    address currency, IRatesProvider ratesProvider,\n', '    bool senderAuditRequired, bool receiverAuditRequired);\n', '  event LogAuditData(\n', '    uint64 createdAt, uint64 lastTransactionAt,\n', '    uint256 cumulatedEmission, uint256 cumulatedReception\n', '  );\n', '}\n', '\n', '// File: @c-layer/token/contracts/interface/ITokenCore.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ITokenCore\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' **/\n', 'abstract contract ITokenCore is ITokenStorage, IOperableCore {\n', '\n', '  function name() virtual public view returns (string memory);\n', '  function oracle() virtual public view returns (\n', '    IUserRegistry userRegistry,\n', '    IRatesProvider ratesProvider,\n', '    address currency);\n', '\n', '  function auditConfiguration(uint256 _configurationId)\n', '    virtual public view returns (\n', '      uint256 scopeId,\n', '      AuditTriggerMode _mode,\n', '      uint256[] memory senderKeys,\n', '      uint256[] memory receiverKeys,\n', '      IRatesProvider ratesProvider,\n', '      address currency);\n', '  function auditTrigger(uint256 _configurationId, address _sender, address _receiver)\n', '    virtual public view returns (AuditTriggerMode);\n', '  function delegatesConfigurations(uint256 _delegateId)\n', '    virtual public view returns (uint256[] memory);\n', '\n', '  function auditCurrency(\n', '    address _scope,\n', '    uint256 _scopeId\n', '  ) virtual external view returns (address currency);\n', '  function audit(\n', '    address _scope,\n', '    uint256 _scopeId,\n', '    AuditStorageMode _storageMode,\n', '    bytes32 _storageId) virtual external view returns (\n', '    uint64 createdAt,\n', '    uint64 lastTransactionAt,\n', '    uint256 cumulatedEmission,\n', '    uint256 cumulatedReception);\n', '\n', '  /**************  ERC20  **************/\n', '  function tokenName() virtual external view returns (string memory);\n', '  function tokenSymbol() virtual external view returns (string memory);\n', '\n', '  function decimals() virtual external returns (uint256);\n', '  function totalSupply() virtual external returns (uint256);\n', '  function balanceOf(address) virtual external returns (uint256);\n', '  function allowance(address, address) virtual external returns (uint256);\n', '  function transfer(address, address, uint256)\n', '    virtual external returns (bool status);\n', '  function transferFrom(address, address, address, uint256)\n', '    virtual external returns (bool status);\n', '  function approve(address, address, uint256)\n', '    virtual external returns (bool status);\n', '  function increaseApproval(address, address, uint256)\n', '    virtual external returns (bool status);\n', '  function decreaseApproval(address, address, uint256)\n', '    virtual external returns (bool status);\n', '\n', '  /***********  TOKEN DATA   ***********/\n', '  function token(address _token) virtual external view returns (\n', '    bool mintingFinished,\n', '    uint256 allTimeMinted,\n', '    uint256 allTimeBurned,\n', '    uint256 allTimeSeized,\n', '    address[] memory locks,\n', '    uint256 freezedUntil,\n', '    IRule[] memory);\n', '  function lock(address _lock, address _sender, address _receiver) virtual external view returns (\n', '    uint64 startAt, uint64 endAt);\n', '  function canTransfer(address, address, uint256)\n', '    virtual external returns (uint256);\n', '\n', '  /***********  TOKEN ADMIN  ***********/\n', '  function mint(address, address[] calldata, uint256[] calldata)\n', '    virtual external returns (bool);\n', '  function finishMinting(address)\n', '    virtual external returns (bool);\n', '  function burn(address, uint256)\n', '    virtual external returns (bool);\n', '  function seize(address _token, address, uint256)\n', '    virtual external returns (bool);\n', '  function defineLock(address, address, address, uint64, uint64)\n', '    virtual external returns (bool);\n', '  function defineTokenLocks(address _token, address[] memory locks)\n', '    virtual external returns (bool);\n', '  function freezeManyAddresses(\n', '    address _token,\n', '    address[] calldata _addresses,\n', '    uint256 _until) virtual external returns (bool);\n', '  function defineRules(address, IRule[] calldata) virtual external returns (bool);\n', '\n', '  /************  CORE ADMIN  ************/\n', '  function defineToken(\n', '    address _token,\n', '    uint256 _delegateId,\n', '    string memory _name,\n', '    string memory _symbol,\n', '    uint256 _decimals) virtual external returns (bool);\n', '\n', '  function defineOracle(\n', '    IUserRegistry _userRegistry,\n', '    IRatesProvider _ratesProvider,\n', '    address _currency) virtual external returns (bool);\n', '  function defineTokenDelegate(\n', '    uint256 _delegateId,\n', '    address _delegate,\n', '    uint256[] calldata _configurations) virtual external returns (bool);\n', '  function defineAuditConfiguration(\n', '    uint256 _configurationId,\n', '    uint256 _scopeId,\n', '    AuditTriggerMode _mode,\n', '    uint256[] calldata _senderKeys,\n', '    uint256[] calldata _receiverKeys,\n', '    IRatesProvider _ratesProvider,\n', '    address _currency) virtual external returns (bool);\n', '  function removeAudits(address _scope, uint256 _scopeId)\n', '    virtual external returns (bool);\n', '  function defineAuditTriggers(\n', '    uint256 _configurationId,\n', '    address[] calldata _senders,\n', '    address[] calldata _receivers,\n', '    AuditTriggerMode[] calldata _modes) virtual external returns (bool);\n', '\n', '  function isSelfManaged(address _owner)\n', '    virtual external view returns (bool);\n', '  function manageSelf(bool _active)\n', '    virtual external returns (bool);\n', '}\n', '\n', '// File: contracts/interface/IVotingSessionStorage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title IVotingSessionStorage\n', ' * @dev IVotingSessionStorage interface\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'abstract contract IVotingSessionStorage is IVotingDefinitions {\n', '\n', '  event SessionRuleUpdated(\n', '    uint64 campaignPeriod,\n', '    uint64 votingPeriod,\n', '    uint64 executionPeriod,\n', '    uint64 gracePeriod,\n', '    uint64 periodOffset,\n', '    uint8 openProposals,\n', '    uint8 maxProposals,\n', '    uint8 maxProposalsOperator,\n', '    uint256 newProposalThreshold,\n', '    address[] nonVotingAddresses);\n', '  event ResolutionRequirementUpdated(\n', '    address target,\n', '    bytes4 methodSignature,\n', '    uint128 majority,\n', '    uint128 quorum,\n', '    uint256 executionThreshold\n', '  );\n', '\n', '  event TokenDefined(address token, address core);\n', '  event DelegateDefined(address delegate);\n', '\n', '  event SponsorDefined(address indexed voter, address address_, uint64 until);\n', '\n', '  event SessionScheduled(uint256 indexed sessionId, uint64 voteAt);\n', '  event SessionArchived(uint256 indexed sessionId);\n', '  event ProposalDefined(uint256 indexed sessionId, uint8 proposalId);\n', '  event ProposalUpdated(uint256 indexed sessionId, uint8 proposalId);\n', '  event ProposalCancelled(uint256 indexed sessionId, uint8 proposalId);\n', '  event ResolutionExecuted(uint256 indexed sessionId, uint8 proposalId);\n', '\n', '  event Vote(uint256 indexed sessionId, address voter, uint256 weight);\n', '}\n', '\n', '// File: contracts/interface/IVotingSessionDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title IVotingSessionDelegate\n', ' * @dev IVotingSessionDelegate interface\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'abstract contract IVotingSessionDelegate is IVotingSessionStorage {\n', '\n', '  function nextSessionAt(uint256 _time) virtual public view returns (uint256 at);\n', '\n', '  function sessionStateAt(uint256 _sessionId, uint256 _time) virtual public view returns (SessionState);\n', '\n', '  function newProposalThresholdAt(uint256 _sessionId, uint256 _proposalsCount)\n', '    virtual public view returns (uint256);\n', '\n', '  function proposalApproval(uint256 _sessionId, uint8 _proposalId)\n', '    virtual public view returns (bool);\n', '\n', '  function proposalStateAt(uint256 _sessionId, uint8 _proposalId, uint256 _time)\n', '    virtual public view returns (ProposalState);\n', '\n', '  function updateSessionRule(\n', '    uint64 _campaignPeriod,\n', '    uint64 _votingPeriod,\n', '    uint64 _executionPeriod,\n', '    uint64 _gracePeriod,\n', '    uint64 _periodOffset,\n', '    uint8 _openProposals,\n', '    uint8 _maxProposals,\n', '    uint8 _maxProposalsQuaestor,\n', '    uint256 _newProposalThreshold,\n', '    address[] memory _nonVotingAddresses\n', '  ) virtual public returns (bool);\n', '\n', '  function updateResolutionRequirements(\n', '    address[] memory _targets,\n', '    bytes4[] memory _methodSignatures,\n', '    uint128[] memory _majority,\n', '    uint128[] memory _quorum,\n', '    uint256[] memory _executionThreshold\n', '  ) virtual public returns (bool);\n', '\n', '  function defineProposal(\n', '    string memory _name,\n', '    string memory _url,\n', '    bytes32 _proposalHash,\n', '    address _resolutionTarget,\n', '    bytes memory _resolutionAction,\n', '    uint8 _dependsOn,\n', '    uint8 _alternativeOf\n', '  ) virtual public returns (bool);\n', '\n', '  function updateProposal(\n', '    uint8 _proposalId,\n', '    string memory _name,\n', '    string memory _url,\n', '    bytes32 _proposalHash,\n', '    address _resolutionTarget,\n', '    bytes memory _resolutionAction,\n', '    uint8 _dependsOn,\n', '    uint8 _alternativeOf\n', '  ) virtual public returns (bool);\n', '  function cancelProposal(uint8 _proposalId) virtual public returns (bool);\n', '\n', '  function submitVote(uint256 _votes) virtual public returns (bool);\n', '  function submitVotesOnBehalf(\n', '    address[] memory _voters,\n', '    uint256 _votes\n', '  ) virtual public returns (bool);\n', '\n', '  function executeResolutions(uint8[] memory _proposalIds) virtual public returns (bool);\n', '\n', '  function archiveSession() virtual public returns (bool);\n', '\n', '}\n', '\n', '// File: @c-layer/common/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/voting/VotingSessionStorage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title VotingSessionStorage\n', ' * @dev VotingSessionStorage contract\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'contract VotingSessionStorage is IVotingSessionStorage {\n', '  using SafeMath for uint256;\n', '\n', '  address internal constant ANY_ADDRESSES = address(0x416e79416464726573736573); // "AnyAddresses"\n', '\n', '  struct SessionRule {\n', '    uint64 campaignPeriod; // Before it starts, the vote will be locked\n', '    uint64 votingPeriod; // Time period for voters to submit their votes\n', '    uint64 executionPeriod; // Time period for executing resolutions\n', '    uint64 gracePeriod; // delay between two votes\n', '\n', '    uint64 periodOffset; // Offset before the first session period\n', '\n', '    uint8 openProposals;\n', '    uint8 maxProposals;\n', '    uint8 maxProposalsOperator;\n', '    uint256 newProposalThreshold;\n', '\n', '    address[] nonVotingAddresses;\n', '  }\n', '\n', '  struct ResolutionRequirement {\n', '    uint128 majority;\n', '    uint128 quorum;\n', '    uint256 executionThreshold;\n', '  }\n', '\n', '  struct Session {\n', '    uint64 campaignAt;\n', '    uint64 voteAt;\n', '    uint64 executionAt;\n', '    uint64 graceAt;\n', '    uint64 closedAt;\n', '    uint8 proposalsCount;\n', '    uint256 participation;\n', '    uint256 totalSupply;\n', '    uint256 votingSupply;\n', '\n', '    mapping(uint256 => Proposal) proposals;\n', '  }\n', '\n', '  // A proposal may be semanticaly in one of the following state:\n', '  // DEFINED, VOTED, RESOLVED(?), PROCESSED\n', '  struct Proposal {\n', '    string name;\n', '    string url;\n', '    bytes32 proposalHash;\n', '    address proposedBy;\n', '    address resolutionTarget;\n', '    bytes resolutionAction;\n', '\n', '    ResolutionRequirement requirement;\n', '    uint8 dependsOn; // The previous proposal must be either non approved or executed\n', '    bool resolutionExecuted;\n', '    bool cancelled;\n', '\n', '    uint8 alternativeOf;\n', '    uint256 approvals;\n', '    uint256 alternativesMask; // only used for the parent alternative proposal\n', '  }\n', '\n', '  struct Sponsor {\n', '    address address_;\n', '    uint64 until;\n', '  }\n', '\n', '  IVotingSessionDelegate internal delegate_;\n', '  ITokenProxy internal token_;\n', '  ITokenCore internal core_;\n', '\n', '  SessionRule internal sessionRule_ = SessionRule(\n', '    CAMPAIGN_PERIOD,\n', '    VOTING_PERIOD,\n', '    EXECUTION_PERIOD,\n', '    GRACE_PERIOD,\n', '    OFFSET_PERIOD,\n', '    OPEN_PROPOSALS,\n', '    MAX_PROPOSALS,\n', '    MAX_PROPOSALS_OPERATOR,\n', '    NEW_PROPOSAL_THRESHOLD,\n', '    new address[](0)\n', '  );\n', '\n', '  mapping(address => mapping(bytes4 => ResolutionRequirement)) internal resolutionRequirements;\n', '\n', "  uint256 internal oldestSessionId_ = 1; // '1' simplifies checks when no sessions exists\n", '  uint256 internal currentSessionId_ = 0;\n', '  mapping(uint256 => Session) internal sessions;\n', '  mapping(address => uint64) internal lastVotes;\n', '  mapping(address => Sponsor) internal sponsors;\n', '\n', '  /**\n', '   * @dev currentTime\n', '   */\n', '  function currentTime() internal view returns (uint256) {\n', '    // solhint-disable-next-line not-rely-on-time\n', '    return block.timestamp;\n', '  }\n', '}\n', '\n', '// File: contracts/voting/VotingSessionDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title VotingSessionDelegate\n', ' * @dev VotingSessionDelegate contract\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', " *   VD01: Session doesn't exist\n", " *   VD02: Proposal doesn't exist\n", ' *   VD03: Campaign period must be within valid range\n', ' *   VD04: Voting period must be within valid range\n', ' *   VD05: Execution period must be within valid range\n', ' *   VD06: Grace period must be within valid range\n', ' *   VD07: Period offset must be within valid range\n', ' *   VD08: Open proposals limit must be lower than the max proposals limit\n', ' *   VD09: Operator proposal limit must be greater than 0\n', ' *   VD10: New proposal threshold must be greater than 0\n', ' *   VD11: The current session is not in GRACE, CLOSED or ARCHIVED state\n', ' *   VD12: Duplicates entries are not allowed in non voting contracts\n', ' *   VD13: Inconsistent numbers of methods signatures\n', ' *   VD14: Inconsistent numbers of min participations\n', ' *   VD15: Inconsistent numbers of quorums\n', ' *   VD16: Inconsistent numbers of execution thresholds\n', ' *   VD17: Default majority cannot be null\n', ' *   VD18: Execute resolution threshold must be greater than 0\n', ' *   VD19: Operator proposal limit is reached\n', ' *   VD20: Too many proposals yet for this session\n', ' *   VD21: Not enough tokens for a new proposal\n', ' *   VD22: Current session is not in PLANNED state\n', ' *   VD23: Only the author can update a proposal\n', ' *   VD24: Proposal must not be already cancelled\n', ' *   VD25: The previous session can only be in GRACE state to allow rules change\n', ' *   VD26: Not enough tokens to execute\n', ' *   VD27: Voting Session resolutions are not allowed in EXECUTION\n', ' *   VD28: Only Voting Session operations are allowed in GRACE\n', ' *   VD29: The proposal is not in APPROVED state\n', ' *   VD30: Invalid resolution order\n', ' *   VD31: The resolution must be successfull\n', ' *   VD32: The session is too recent to be archived\n', ' *   VD33: Unable to set the lock\n', ' *   VD34: Cannot depends on itself or inexisting porposal\n', ' *   VD35: Reference proposal for alternates must have the lowest proposalId\n', ' *   VD36: Session is not in VOTING state\n', ' *   VD37: Voters must be provided\n', " *   VD38: Sender must be either the voter, the voter's sponsor or an operator\n", " *   VD39: The voter has been marked 'voted'. If the voter has not voted yet,\n", ' *         he is then part of the non voting addresses.\n', ' *   VD40: Cannot vote for a cancelled proposal\n', ' *   VD41: Cannot submit multiple votes for a proposal and its alternatives\n', ' *   VD42: The vote contains too many proposals\n', ' */\n', 'contract VotingSessionDelegate is IVotingSessionDelegate, VotingSessionStorage {\n', '\n', '  modifier onlyExistingSession(uint256 _sessionId) {\n', '    require(_sessionId >= oldestSessionId_ && _sessionId <= currentSessionId_, "VD01");\n', '    _;\n', '  }\n', '\n', '  modifier onlyExistingProposal(uint256 _sessionId, uint8 _proposalId) {\n', '    require(_sessionId >= oldestSessionId_ && _sessionId <= currentSessionId_, "VD01");\n', '    require(_proposalId > 0 && _proposalId <= sessions[_sessionId].proposalsCount, "VD02");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev nextSessionAt\n', '   */\n', '  function nextSessionAt(uint256 _time) public override view returns (uint256 voteAt) {\n', '    uint256 sessionPeriod =\n', '      sessionRule_.campaignPeriod\n', '      + sessionRule_.votingPeriod\n', '      + sessionRule_.executionPeriod\n', '      + sessionRule_.gracePeriod;\n', '\n', '    uint256 currentSessionClosedAt =\n', '      (currentSessionId_ != 0) ? uint256(sessions[currentSessionId_].closedAt) : 0;\n', '\n', '    voteAt = (_time + sessionRule_.campaignPeriod);\n', '    voteAt = (voteAt > currentSessionClosedAt) ? voteAt : currentSessionClosedAt;\n', '\n', '    uint256 closestPeriodAt = voteAt / sessionPeriod * sessionPeriod + sessionRule_.periodOffset;\n', '    voteAt = (voteAt != closestPeriodAt) ? closestPeriodAt + sessionPeriod : closestPeriodAt;\n', '  }\n', '\n', '  /**\n', '   * @dev sessionStateAt\n', '   */\n', '  function sessionStateAt(uint256 _sessionId, uint256 _time) public override\n', '    view returns (SessionState)\n', '  {\n', '    if (_sessionId == 0 || _sessionId > currentSessionId_) {\n', '      return SessionState.UNDEFINED;\n', '    }\n', '\n', '    if (_sessionId < oldestSessionId_) {\n', '      return SessionState.ARCHIVED;\n', '    }\n', '\n', '    Session storage session_ = sessions[_sessionId];\n', '\n', '    if (_time < uint256(session_.campaignAt)) {\n', '      return SessionState.PLANNED;\n', '    }\n', '\n', '    if (_time < uint256(session_.voteAt)) {\n', '      return SessionState.CAMPAIGN;\n', '    }\n', '\n', '    if (_time < uint256(session_.executionAt))\n', '    {\n', '      return SessionState.VOTING;\n', '    }\n', '\n', '    if (_time < uint256(session_.graceAt))\n', '    {\n', '      return SessionState.EXECUTION;\n', '    }\n', '\n', '    if (_time < uint256(session_.closedAt))\n', '    {\n', '      return SessionState.GRACE;\n', '    }\n', '\n', '    return SessionState.CLOSED;\n', '  }\n', '\n', '  /**\n', '   * @dev newProposalThresholdAt\n', '   */\n', '  function newProposalThresholdAt(uint256 _sessionId, uint256 _proposalsCount)\n', '    public override onlyExistingSession(_sessionId) view returns (uint256)\n', '  {\n', '    Session storage session_ = sessions[_sessionId];\n', '    bool baseThreshold = (\n', '      sessionRule_.maxProposals <= sessionRule_.openProposals\n', '      || _proposalsCount <= sessionRule_.openProposals\n', '      || session_.totalSupply <= sessionRule_.newProposalThreshold);\n', '\n', '    return (baseThreshold) ? sessionRule_.newProposalThreshold : sessionRule_.newProposalThreshold.add(\n', '      (session_.totalSupply.div(2)).sub(sessionRule_.newProposalThreshold).mul(\n', '        (_proposalsCount - sessionRule_.openProposals) ** 2).div((sessionRule_.maxProposals - sessionRule_.openProposals) ** 2));\n', '  }\n', '\n', '  /**\n', '   * @dev proposalApproval\n', '   */\n', '  function proposalApproval(uint256 _sessionId, uint8 _proposalId)\n', '    public override view onlyExistingProposal(_sessionId, _proposalId) returns (bool isApproved)\n', '  {\n', '    Session storage session_ = sessions[_sessionId];\n', '    Proposal storage proposal_ = session_.proposals[_proposalId];\n', '\n', '    uint256 participation = session_.participation;\n', '    uint256 participationPercent = 0;\n', '    if (participation != 0) {\n', '      participationPercent = participation.mul(PERCENT).div(session_.votingSupply);\n', '      isApproved = (\n', '        (proposal_.approvals.mul(PERCENT).div(participation) >= proposal_.requirement.majority) &&\n', '        (participationPercent >= proposal_.requirement.quorum)\n', '      );\n', '    }\n', '\n', '    /**\n', '     * @notice when the proposal has fulfiled its own requirements,\n', '     * @notice its approvals must be also compared to alternative proposals if they exist\n', '     * @notice if more than one proposal have the same approval, the first submitted wins\n', '     */\n', '    if (isApproved &&\n', '      (proposal_.alternativeOf != 0 || proposal_.alternativesMask != 0))\n', '    {\n', '      uint256 baseProposalId = (proposal_.alternativeOf == 0) ? _proposalId : proposal_.alternativeOf;\n', '      Proposal storage baseProposal = session_.proposals[baseProposalId];\n', '\n', '      uint256 remainingProposals = baseProposal.alternativesMask >> (baseProposalId - 1);\n', '\n', '      for (uint256 i = baseProposalId; remainingProposals != 0; i++) {\n', '        if (((remainingProposals & 1) == 1) && (i != _proposalId)) {\n', '          Proposal storage alternative = session_.proposals[i];\n', '          if ((alternative.approvals >= proposal_.approvals &&\n', '            (alternative.approvals != proposal_.approvals || i < _proposalId)) &&\n', '            (alternative.approvals.mul(PERCENT).div(participation) >= alternative.requirement.majority) &&\n', '            (participationPercent >= alternative.requirement.quorum))\n', '          {\n', '            isApproved = false;\n', '            break;\n', '          }\n', '        }\n', '        remainingProposals = remainingProposals >> 1;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev proposalStateAt\n', '   */\n', '  function proposalStateAt(uint256 _sessionId, uint8 _proposalId, uint256 _time)\n', '    public override view returns (ProposalState)\n', '  {\n', '    Session storage session_ = sessions[_sessionId];\n', '    SessionState sessionState = sessionStateAt(_sessionId, _time);\n', '\n', '    if (sessionState == SessionState.ARCHIVED) {\n', '      return ProposalState.ARCHIVED;\n', '    }\n', '\n', '    if (sessionState == SessionState.UNDEFINED\n', '      || _proposalId == 0 || _proposalId > session_.proposalsCount) {\n', '      return ProposalState.UNDEFINED;\n', '    }\n', '\n', '    Proposal storage proposal_ = session_.proposals[_proposalId];\n', '\n', '    if (proposal_.cancelled) {\n', '      return ProposalState.CANCELLED;\n', '    }\n', '\n', '    if (sessionState < SessionState.CAMPAIGN) {\n', '      return ProposalState.DEFINED;\n', '    }\n', '\n', '    if (sessionState < SessionState.EXECUTION) {\n', '      return ProposalState.LOCKED;\n', '    }\n', '\n', '    if (proposal_.resolutionExecuted) {\n', '      return ProposalState.RESOLVED;\n', '    }\n', '\n', '    if (sessionState == SessionState.CLOSED) {\n', '      return ProposalState.CLOSED;\n', '    }\n', '\n', '    return proposalApproval(_sessionId, _proposalId) ? ProposalState.APPROVED : ProposalState.REJECTED;\n', '  }\n', '\n', '  /**\n', '   * @dev updateSessionRule\n', '   * @notice the campaign period may be 0 and therefore not exists\n', '   * @notice the grace period must be greater than the campaign period and greater\n', '   *         than the minimal period.\n', '   */\n', '  function updateSessionRule(\n', '    uint64 _campaignPeriod,\n', '    uint64 _votingPeriod,\n', '    uint64 _executionPeriod,\n', '    uint64 _gracePeriod,\n', '    uint64 _periodOffset,\n', '    uint8 _openProposals,\n', '    uint8 _maxProposals,\n', '    uint8 _maxProposalsOperator,\n', '    uint256 _newProposalThreshold,\n', '    address[] memory _nonVotingAddresses\n', '  )  public override returns (bool) {\n', '    require(_campaignPeriod <= MAX_PERIOD_LENGTH, "VD03");\n', '    require(_votingPeriod >= MIN_PERIOD_LENGTH && _votingPeriod <= MAX_PERIOD_LENGTH, "VD04");\n', '    require(_executionPeriod >= MIN_PERIOD_LENGTH && _executionPeriod <= MAX_PERIOD_LENGTH, "VD05");\n', '    require(_gracePeriod >= MIN_PERIOD_LENGTH && _gracePeriod <= MAX_PERIOD_LENGTH, "VD06");\n', '    require(_periodOffset <= MAX_PERIOD_LENGTH, "VD07");\n', '\n', '    require(_openProposals <= _maxProposals, "VD08");\n', '    require(_maxProposalsOperator !=0, "VD09");\n', '    require(_newProposalThreshold != 0, "VD10");\n', '\n', '    if (currentSessionId_ != 0) {\n', '      SessionState state = sessionStateAt(currentSessionId_, currentTime());\n', '      require(state == SessionState.GRACE ||\n', '        state == SessionState.CLOSED || state == SessionState.ARCHIVED, "VD11");\n', '    }\n', '\n', '    uint256 currentTime_ = currentTime();\n', '    for (uint256 i=0; i < sessionRule_.nonVotingAddresses.length; i++) {\n', '      lastVotes[sessionRule_.nonVotingAddresses[i]] = uint64(currentTime_);\n', '    }\n', '\n', '    for (uint256 i=0; i < _nonVotingAddresses.length; i++) {\n', '      lastVotes[_nonVotingAddresses[i]] = ~uint64(0);\n', '\n', '      for (uint256 j=i+1; j < _nonVotingAddresses.length; j++) {\n', '        require(_nonVotingAddresses[i] != _nonVotingAddresses[j], "VD12");\n', '      }\n', '    }\n', '\n', '    sessionRule_ = SessionRule(\n', '      _campaignPeriod,\n', '      _votingPeriod,\n', '      _executionPeriod,\n', '      _gracePeriod,\n', '      _periodOffset,\n', '      _openProposals,\n', '      _maxProposals,\n', '      _maxProposalsOperator,\n', '      _newProposalThreshold,\n', '      _nonVotingAddresses);\n', '\n', '    emit SessionRuleUpdated(\n', '      _campaignPeriod,\n', '      _votingPeriod,\n', '      _executionPeriod,\n', '      _gracePeriod,\n', '      _periodOffset,\n', '      _openProposals,\n', '      _maxProposals,\n', '      _maxProposalsOperator,\n', '      _newProposalThreshold,\n', '      _nonVotingAddresses);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev updateResolutionRequirements\n', '   */\n', '  function updateResolutionRequirements(\n', '    address[] memory _targets,\n', '    bytes4[] memory _methodSignatures,\n', '    uint128[] memory _majorities,\n', '    uint128[] memory _quorums,\n', '    uint256[] memory _executionThresholds\n', '  ) public override returns (bool)\n', '  {\n', '    require(_targets.length == _methodSignatures.length, "VD13");\n', '    require(_methodSignatures.length == _majorities.length, "VD14");\n', '    require(_methodSignatures.length == _quorums.length, "VD15");\n', '    require(_methodSignatures.length == _executionThresholds.length, "VD16");\n', '\n', '    if (currentSessionId_ != 0) {\n', '      SessionState state = sessionStateAt(currentSessionId_, currentTime());\n', '      require(state == SessionState.GRACE ||\n', '        state == SessionState.CLOSED || state == SessionState.ARCHIVED, "VD11");\n', '    }\n', '\n', '    for (uint256 i=0; i < _methodSignatures.length; i++) {\n', '      // Majority can only be 0 if it is not the global default, allowing the deletion of the requirement\n', '      require(_majorities[i] != 0 || !(_targets[i] == ANY_TARGET && _methodSignatures[i] == ANY_METHOD), "VD17");\n', '      require(_executionThresholds[i] != 0 || _majorities[i] == 0, "VD18");\n', '\n', '      resolutionRequirements[_targets[i]][_methodSignatures[i]] =\n', '        ResolutionRequirement(_majorities[i], _quorums[i], _executionThresholds[i]);\n', '      emit ResolutionRequirementUpdated(\n', '         _targets[i], _methodSignatures[i], _majorities[i], _quorums[i], _executionThresholds[i]);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev defineProposal\n', '   */\n', '  function defineProposal(\n', '    string memory _name,\n', '    string memory _url,\n', '    bytes32 _proposalHash,\n', '    address _resolutionTarget,\n', '    bytes memory _resolutionAction,\n', '    uint8 _dependsOn,\n', '    uint8 _alternativeOf) public override returns (bool)\n', '  {\n', '    Session storage session_ = loadSessionInternal();\n', '\n', '    if (core_.hasProxyPrivilege(msg.sender, address(this), msg.sig)) {\n', '      require(session_.proposalsCount < sessionRule_.maxProposalsOperator, "VD19");\n', '    } else {\n', '      require(session_.proposalsCount < sessionRule_.maxProposals, "VD20");\n', '      require(token_.balanceOf(msg.sender) >=\n', '        newProposalThresholdAt(currentSessionId_, session_.proposalsCount), "VD21");\n', '    }\n', '\n', '    uint8 proposalId = ++session_.proposalsCount;\n', '    updateProposalInternal(proposalId,\n', '      _name, _url, _proposalHash, _resolutionTarget, _resolutionAction, _dependsOn, _alternativeOf);\n', '    session_.proposals[proposalId].proposedBy = msg.sender;\n', '\n', '    emit ProposalDefined(currentSessionId_, proposalId);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev updateProposal\n', '   */\n', '  function updateProposal(\n', '    uint8 _proposalId,\n', '    string memory _name,\n', '    string memory _url,\n', '    bytes32 _proposalHash,\n', '    address _resolutionTarget,\n', '    bytes memory _resolutionAction,\n', '    uint8 _dependsOn,\n', '    uint8 _alternativeOf\n', '  ) public override onlyExistingProposal(currentSessionId_, _proposalId) returns (bool)\n', '  {\n', '    uint256 sessionId = currentSessionId_;\n', '    require(sessionStateAt(sessionId, currentTime()) == SessionState.PLANNED, "VD22");\n', '    require(msg.sender == sessions[sessionId].proposals[_proposalId].proposedBy, "VD23");\n', '\n', '    updateProposalInternal(_proposalId,\n', '      _name, _url, _proposalHash, _resolutionTarget, _resolutionAction, _dependsOn, _alternativeOf);\n', '\n', '    emit ProposalUpdated(sessionId, _proposalId);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev cancelProposal\n', '   */\n', '  function cancelProposal(uint8 _proposalId)\n', '    public override onlyExistingProposal(currentSessionId_, _proposalId) returns (bool)\n', '  {\n', '    uint256 sessionId = currentSessionId_;\n', '    require(sessionStateAt(sessionId, currentTime()) == SessionState.PLANNED, "VD22");\n', '    Proposal storage proposal_ = sessions[sessionId].proposals[_proposalId];\n', '\n', '    require(msg.sender == proposal_.proposedBy, "VD23");\n', '    require(!proposal_.cancelled, "VD24");\n', '\n', '    proposal_.cancelled = true;\n', '    emit ProposalCancelled(sessionId, _proposalId);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev submitVote\n', '   */\n', '  function submitVote(uint256 _votes) public override returns (bool)\n', '  {\n', '    address[] memory voters = new address[](1);\n', '    voters[0] = msg.sender;\n', '    submitVoteInternal(voters, _votes);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev submitVotesOnBehalf\n', '   */\n', '  function submitVotesOnBehalf(\n', '    address[] memory _voters,\n', '    uint256 _votes\n', '  ) public override returns (bool)\n', '  {\n', '    submitVoteInternal(_voters, _votes);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev execute resolutions\n', '   */\n', '  function executeResolutions(uint8[] memory _proposalIds) public override returns (bool)\n', '  {\n', '    uint256 balance;\n', '    if (core_.hasProxyPrivilege(msg.sender, address(this), msg.sig)) {\n', '      balance = ~uint256(0);\n', '    } else {\n', '      balance = token_.balanceOf(msg.sender);\n', '    }\n', '\n', '    uint256 currentTime_ = currentTime();\n', '    uint256 sessionId = currentSessionId_;\n', '    SessionState sessionState = sessionStateAt(sessionId, currentTime_);\n', '\n', '    if (sessionState != SessionState.EXECUTION && sessionState != SessionState.GRACE) {\n', '      sessionState = sessionStateAt(--sessionId, currentTime_);\n', '      require(sessionState == SessionState.GRACE, "VD25");\n', '    }\n', '\n', '    Session storage session_ = sessions[sessionId];\n', '    for (uint256 i=0; i < _proposalIds.length; i++) {\n', '      uint8 proposalId = _proposalIds[i];\n', '      Proposal storage proposal_ = session_.proposals[proposalId];\n', '\n', '      require(balance >= proposal_.requirement.executionThreshold, "VD26");\n', '      if (sessionState == SessionState.EXECUTION) {\n', '        require(proposal_.resolutionTarget != address(this), "VD27");\n', '      } else {\n', '        require(proposal_.resolutionTarget == address(this), "VD28");\n', '      }\n', '\n', '      require(proposalStateAt(sessionId, proposalId, currentTime_) == ProposalState.APPROVED, "VD29");\n', '      if (proposal_.dependsOn != 0) {\n', '        ProposalState dependsOnState = proposalStateAt(sessionId, proposal_.dependsOn, currentTime_);\n', '        require(dependsOnState != ProposalState.APPROVED, "VD30");\n', '      }\n', '\n', '      proposal_.resolutionExecuted = true;\n', '      if (proposal_.resolutionTarget != ANY_TARGET) {\n', '        // solhint-disable-next-line avoid-call-value, avoid-low-level-calls\n', '        (bool success, ) = proposal_.resolutionTarget.call(proposal_.resolutionAction);\n', '        require(success, "VD31");\n', '      }\n', '\n', '      emit ResolutionExecuted(sessionId, proposalId);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev archiveSession\n', '   **/\n', '  function archiveSession() public override onlyExistingSession(oldestSessionId_) returns (bool) {\n', '    Session storage session_ = sessions[oldestSessionId_];\n', '    require((currentSessionId_ >= (oldestSessionId_ + SESSION_RETENTION_COUNT)) ||\n', '      (currentTime() > (SESSION_RETENTION_PERIOD + session_.voteAt)), "VD32");\n', '    for (uint256 i=0; i < session_.proposalsCount; i++) {\n', '      delete session_.proposals[i];\n', '    }\n', '    delete sessions[oldestSessionId_];\n', '    emit SessionArchived(oldestSessionId_++);\n', '  }\n', '\n', '  /**\n', '   * @dev read signature\n', '   * @param _data contains the selector\n', '   */\n', '  function readSignatureInternal(bytes memory _data) internal pure returns (bytes4 signature) {\n', '    // solhint-disable-next-line no-inline-assembly\n', '    assembly {\n', '      signature := mload(add(_data, 0x20))\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev load session internal\n', '   */\n', '  function loadSessionInternal() internal returns (Session storage session_) {\n', '    uint256 currentTime_ = currentTime();\n', '\n', '    SessionState state = SessionState.CLOSED;\n', '    if (currentSessionId_ != 0) {\n', '      state = sessionStateAt(currentSessionId_, currentTime_);\n', '    }\n', '\n', '    if (state != SessionState.PLANNED) {\n', '      // Creation of a new session\n', '      require(state == SessionState.GRACE ||\n', '        state == SessionState.CLOSED || state == SessionState.ARCHIVED, "VD11");\n', '      uint256 nextStartAt = nextSessionAt(currentTime_);\n', '      session_ = sessions[++currentSessionId_];\n', '      session_.campaignAt = uint64(nextStartAt.sub(sessionRule_.campaignPeriod));\n', '      session_.voteAt = uint64(nextStartAt);\n', '\n', '      uint256 at = nextStartAt.add(sessionRule_.votingPeriod);\n', '      session_.executionAt = uint64(at);\n', '      at = at.add(sessionRule_.executionPeriod);\n', '      session_.graceAt = uint64(at);\n', '      at = at.add(sessionRule_.gracePeriod);\n', '      session_.closedAt = uint64(at);\n', '      session_.totalSupply = token_.totalSupply();\n', '\n', '      require(core_.defineLock(\n', '        address(this),\n', '        ANY_ADDRESSES,\n', '        ANY_ADDRESSES,\n', '        session_.voteAt,\n', '        session_.executionAt), "VD33");\n', '\n', '      emit SessionScheduled(currentSessionId_, session_.voteAt);\n', '\n', '      if (currentSessionId_ >= (oldestSessionId_ + SESSION_RETENTION_COUNT)) {\n', '        // Archiving of the oldest session\n', '        archiveSession();\n', '      }\n', '    } else {\n', '      session_ = sessions[currentSessionId_];\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev updateProposalInternal\n', '   */\n', '  function updateProposalInternal(\n', '    uint8 _proposalId,\n', '    string memory _name,\n', '    string memory _url,\n', '    bytes32 _proposalHash,\n', '    address _resolutionTarget,\n', '    bytes memory _resolutionAction,\n', '    uint8 _dependsOn,\n', '    uint8 _alternativeOf) internal\n', '  {\n', '    Session storage session_ = sessions[currentSessionId_];\n', '\n', '    require(_dependsOn <= session_.proposalsCount && _dependsOn != _proposalId, "VD34");\n', '    require(_alternativeOf < _proposalId, "VD35");\n', '\n', '    Proposal storage proposal_ = session_.proposals[_proposalId];\n', '    proposal_.name = _name;\n', '    proposal_.url = _url;\n', '    proposal_.proposalHash = _proposalHash;\n', '    proposal_.resolutionTarget = _resolutionTarget;\n', '    proposal_.resolutionAction = _resolutionAction;\n', '    proposal_.dependsOn = _dependsOn;\n', '\n', '    if (proposal_.alternativeOf != _alternativeOf) {\n', '      uint256 proposalBit = 1 << uint256(_proposalId-1);\n', '\n', '      Proposal storage baseProposal;\n', '      if (proposal_.alternativeOf != 0) {\n', '        baseProposal = session_.proposals[proposal_.alternativeOf];\n', '        baseProposal.alternativesMask ^= proposalBit;\n', '      }\n', '      if (_alternativeOf != 0) {\n', '        baseProposal = session_.proposals[_alternativeOf];\n', '        baseProposal.alternativesMask |= (1 << uint256(_alternativeOf-1)) | proposalBit;\n', '      }\n', '      proposal_.alternativeOf = _alternativeOf;\n', '    }\n', '\n', '    bytes4 actionSignature = readSignatureInternal(proposal_.resolutionAction);\n', '    ResolutionRequirement storage requirement =\n', '      resolutionRequirements[proposal_.resolutionTarget][actionSignature];\n', '\n', '    if (requirement.majority == 0) {\n', '      requirement = resolutionRequirements[proposal_.resolutionTarget][bytes4(ANY_METHOD)];\n', '    }\n', '\n', '    if (requirement.majority == 0) {\n', '      requirement = resolutionRequirements[ANY_TARGET][actionSignature];\n', '    }\n', '\n', '    if (requirement.majority == 0) {\n', '      requirement = resolutionRequirements[ANY_TARGET][bytes4(ANY_METHOD)];\n', '    }\n', '    proposal_.requirement =\n', '      ResolutionRequirement(\n', '        requirement.majority,\n', '        requirement.quorum,\n', '        requirement.executionThreshold);\n', '  }\n', '\n', '  function updateVotingSupply() internal {\n', '    Session storage session_ = sessions[currentSessionId_];\n', '    session_.votingSupply = session_.totalSupply;\n', '    for (uint256 i=0; i < sessionRule_.nonVotingAddresses.length; i++) {\n', '      session_.votingSupply =\n', '        session_.votingSupply.sub(token_.balanceOf(sessionRule_.nonVotingAddresses[i]));\n', '    }\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev submit vote for proposals internal\n', '   */\n', '  function submitVoteInternal(\n', '    address[] memory _voters,\n', '    uint256 _votes) internal\n', '  {\n', '    require(sessionStateAt(currentSessionId_, currentTime()) == SessionState.VOTING, "VD36");\n', '    Session storage session_ = sessions[currentSessionId_];\n', '    require(_voters.length > 0, "VD37");\n', '\n', '    if(session_.participation == 0) {\n', '      // The token is now locked and supply should not change anymore\n', '      updateVotingSupply();\n', '    }\n', '\n', '    uint256 weight = 0;\n', '    uint64 currentTime_ = uint64(currentTime());\n', '\n', '    for (uint256 i=0; i < _voters.length; i++) {\n', '      address voter = _voters[i];\n', '\n', '      require(voter == msg.sender ||\n', '        (core_.hasProxyPrivilege(msg.sender, address(this), msg.sig) && !core_.isSelfManaged(voter)) ||\n', '        (sponsors[voter].address_ == msg.sender && sponsors[voter].until  >= currentTime_), "VD38");\n', '      require(lastVotes[voter] < session_.voteAt, "VD39");\n', '      uint256 balance = token_.balanceOf(voter);\n', '      weight += balance;\n', '      lastVotes[voter] = currentTime_;\n', '      emit Vote(currentSessionId_, voter, balance);\n', '    }\n', '\n', '    uint256 remainingVotes = _votes;\n', '    for (uint256 i=1; i <= session_.proposalsCount && remainingVotes != 0; i++) {\n', '      if ((remainingVotes & 1) == 1) {\n', '        Proposal storage proposal_ = session_.proposals[i];\n', '\n', '        require(!proposal_.cancelled, "VD40");\n', '        if (proposal_.alternativeOf != 0) {\n', '          Proposal storage baseProposal = session_.proposals[proposal_.alternativeOf];\n', '          require (baseProposal.alternativesMask & _votes == (1 << (i-1)), "VD41");\n', '        }\n', '\n', '        proposal_.approvals += weight;\n', '      }\n', '      remainingVotes = remainingVotes >> 1;\n', '    }\n', '    require(remainingVotes == 0, "VD42");\n', '    session_.participation += weight;\n', '  }\n', '}']