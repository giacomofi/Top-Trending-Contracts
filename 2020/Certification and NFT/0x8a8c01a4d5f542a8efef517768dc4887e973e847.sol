['// File: contracts/external/uniswap/solidity-interface.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Factory {\n', '  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '  function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '  function allPairs(uint) external view returns (address pair);\n', '  function allPairsLength() external view returns (uint);\n', '\n', '  function feeTo() external view returns (address);\n', '  function feeToSetter() external view returns (address);\n', '\n', '  function createPair(address tokenA, address tokenB) external returns (address pair);\n', '}\n', '\n', 'interface IUniswapV2Router02 {\n', '    function factory() external pure returns (address);\n', '\n', '    function WETH() external pure returns (address);\n', '\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'interface IUniswapV2ERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '}\n', '\n', '\n', 'interface IUniswapV2Callee {\n', '    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n', '}\n', '\n', '// File: contracts/external/uniswap/FixedPoint.sol\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', '// computes square roots using the babylonian method\n', '// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n', 'pragma solidity >=0.5.0;\n', 'library Babylonian {\n', '    function sqrt(uint y) internal pure returns (uint z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint x = y / 2 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '        // else z = 0\n', '    }\n', '}\n', '\n', 'library UQ112x112 {\n', '    uint224 constant Q112 = 2**112;\n', '\n', '    // encode a uint112 as a UQ112x112\n', '    function encode(uint112 y) internal pure returns (uint224 z) {\n', '        z = uint224(y) * Q112; // never overflows\n', '    }\n', '\n', '    // divide a UQ112x112 by a uint112, returning a UQ112x112\n', '    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n', '        z = x / uint224(y);\n', '    }\n', '}\n', '\n', '// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n', 'library FixedPoint {\n', '    // range: [0, 2**112 - 1]\n', '    // resolution: 1 / 2**112\n', '    struct uq112x112 {\n', '        uint224 _x;\n', '    }\n', '\n', '    // range: [0, 2**144 - 1]\n', '    // resolution: 1 / 2**112\n', '    struct uq144x112 {\n', '        uint _x;\n', '    }\n', '\n', '    uint8 private constant RESOLUTION = 112;\n', '    uint private constant Q112 = uint(1) << RESOLUTION;\n', '    uint private constant Q224 = Q112 << RESOLUTION;\n', '\n', '    // encode a uint112 as a UQ112x112\n', '    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n', '        return uq112x112(uint224(x) << RESOLUTION);\n', '    }\n', '\n', '    // encodes a uint144 as a UQ144x112\n', '    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n', '        return uq144x112(uint256(x) << RESOLUTION);\n', '    }\n', '\n', '    // divide a UQ112x112 by a uint112, returning a UQ112x112\n', '    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n', "        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n", '        return uq112x112(self._x / uint224(x));\n', '    }\n', '\n', '    // multiply a UQ112x112 by a uint, returning a UQ144x112\n', '    // reverts on overflow\n', '    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n', '        uint z;\n', '        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), "FixedPoint: MULTIPLICATION_OVERFLOW");\n', '        return uq144x112(z);\n', '    }\n', '\n', '    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n', '    // equivalent to encode(numerator).div(denominator)\n', '    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n', '        require(denominator > 0, "FixedPoint: DIV_BY_ZERO");\n', '        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n', '    }\n', '\n', '    // decode a UQ112x112 into a uint112 by truncating after the radix point\n', '    function decode(uq112x112 memory self) internal pure returns (uint112) {\n', '        return uint112(self._x >> RESOLUTION);\n', '    }\n', '\n', '    // decode a UQ144x112 into a uint144 by truncating after the radix point\n', '    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n', '        return uint144(self._x >> RESOLUTION);\n', '    }\n', '\n', '    // take the reciprocal of a UQ112x112\n', '    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n', "        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\n", '        return uq112x112(uint224(Q224 / self._x));\n', '    }\n', '\n', '    // square root of a UQ112x112\n', '    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n', '        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\n', '    }\n', '}\n', '\n', '// File: contracts/external/uniswap/oracleLibrary.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '\n', '\n', '// library with helper methods for oracles that are concerned with computing average prices\n', 'library UniswapV2OracleLibrary {\n', '    using FixedPoint for *;\n', '\n', '    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n', '    function currentBlockTimestamp() internal view returns (uint32) {\n', '        return uint32(block.timestamp % 2 ** 32);\n', '    }\n', '\n', '    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n', '    function currentCumulativePrices(\n', '        address pair\n', '    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n', '        blockTimestamp = currentBlockTimestamp();\n', '        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n', '        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n', '\n', '        // if time has elapsed since the last update on the pair, mock the accumulated price values\n', '        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n', '        if (blockTimestampLast != blockTimestamp) {\n', '            // subtraction overflow is desired\n', '            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n', '            // addition overflow is desired\n', '            // counterfactual\n', '            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n', '            // counterfactual\n', '            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/external/openzeppelin-solidity/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library SafeMath64 {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        uint64 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint64 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\n', '        require(b <= a, errorMessage);\n', '        uint64 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint64 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint64 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/external/proxy/Proxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Gives the possibility to delegate any call to a foreign implementation.\n', ' */\n', 'contract Proxy {\n', '    /**\n', '    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n', '    * This function will return whatever the implementation call returns\n', '    */\n', '    function () external payable {\n', '        address _impl = implementation();\n', '        require(_impl != address(0));\n', '\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            calldatacopy(ptr, 0, calldatasize)\n', '            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n', '            let size := returndatasize\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            switch result\n', '            case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '            }\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the implementation where every call will be delegated.\n', '    * @return address of the implementation to which it will be delegated\n', '    */\n', '    function implementation() public view returns (address);\n', '}\n', '\n', '// File: contracts/external/proxy/UpgradeabilityProxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n', ' */\n', 'contract UpgradeabilityProxy is Proxy {\n', '    /**\n', '    * @dev This event will be emitted every time the implementation gets upgraded\n', '    * @param implementation representing the address of the upgraded implementation\n', '    */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    // Storage position of the address of the current implementation\n', '    bytes32 private constant IMPLEMENTATION_POSITION = keccak256("org.govblocks.proxy.implementation");\n', '\n', '    /**\n', '    * @dev Constructor function\n', '    */\n', '    constructor() public {}\n', '\n', '    /**\n', '    * @dev Tells the address of the current implementation\n', '    * @return address of the current implementation\n', '    */\n', '    function implementation() public view returns (address impl) {\n', '        bytes32 position = IMPLEMENTATION_POSITION;\n', '        assembly {\n', '            impl := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Sets the address of the current implementation\n', '    * @param _newImplementation address representing the new implementation to be set\n', '    */\n', '    function _setImplementation(address _newImplementation) internal {\n', '        bytes32 position = IMPLEMENTATION_POSITION;\n', '        assembly {\n', '        sstore(position, _newImplementation)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Upgrades the implementation address\n', '    * @param _newImplementation representing the address of the new implementation to be set\n', '    */\n', '    function _upgradeTo(address _newImplementation) internal {\n', '        address currentImplementation = implementation();\n', '        require(currentImplementation != _newImplementation);\n', '        _setImplementation(_newImplementation);\n', '        emit Upgraded(_newImplementation);\n', '    }\n', '}\n', '\n', '// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title OwnedUpgradeabilityProxy\n', ' * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n', ' */\n', 'contract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n', '    /**\n', '    * @dev Event to show ownership has been transferred\n', '    * @param previousOwner representing the address of the previous owner\n', '    * @param newOwner representing the address of the new owner\n', '    */\n', '    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n', '\n', '    // Storage position of the owner of the contract\n', '    bytes32 private constant PROXY_OWNER_POSITION = keccak256("org.govblocks.proxy.owner");\n', '\n', '    /**\n', '    * @dev the constructor sets the original owner of the contract to the sender account.\n', '    */\n', '    constructor(address _implementation) public {\n', '        _setUpgradeabilityOwner(msg.sender);\n', '        _upgradeTo(_implementation);\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyProxyOwner() {\n', '        require(msg.sender == proxyOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the owner\n', '    * @return the address of the owner\n', '    */\n', '    function proxyOwner() public view returns (address owner) {\n', '        bytes32 position = PROXY_OWNER_POSITION;\n', '        assembly {\n', '            owner := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\n', '        require(_newOwner != address(0));\n', '        _setUpgradeabilityOwner(_newOwner);\n', '        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the proxy owner to upgrade the current version of the proxy.\n', '    * @param _implementation representing the address of the new implementation to be set.\n', '    */\n', '    function upgradeTo(address _implementation) public onlyProxyOwner {\n', '        _upgradeTo(_implementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the owner\n', '    */\n', '    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\n', '        bytes32 position = PROXY_OWNER_POSITION;\n', '        assembly {\n', '            sstore(position, _newProxyOwner)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/ITokenController.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract ITokenController {\n', '\taddress public token;\n', '    address public bLOTToken;\n', '\n', '    /**\n', '    * @dev Swap BLOT token.\n', '    * account.\n', '    * @param amount The amount that will be swapped.\n', '    */\n', '    function swapBLOT(address _of, address _to, uint256 amount) public;\n', '\n', '    function totalBalanceOf(address _of)\n', '        public\n', '        view\n', '        returns (uint256 amount);\n', '\n', '    function transferFrom(address _token, address _of, address _to, uint256 amount) public;\n', '\n', '    /**\n', '     * @dev Returns tokens locked for a specified address for a\n', '     *      specified reason at a specific time\n', '     * @param _of The address whose tokens are locked\n', '     * @param _reason The reason to query the lock tokens for\n', '     * @param _time The timestamp to query the lock tokens for\n', '     */\n', '    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\n', '        public\n', '        view\n', '        returns (uint256 amount);\n', '\n', '    /**\n', '    * @dev burns an amount of the tokens of the message sender\n', '    * account.\n', '    * @param amount The amount that will be burnt.\n', '    */\n', '    function burnCommissionTokens(uint256 amount) external returns(bool);\n', ' \n', '    function initiateVesting(address _vesting) external;\n', '\n', '    function lockForGovernanceVote(address _of, uint _days) public;\n', '\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    function mint(address _member, uint _amount) public;\n', '\n', '}\n', '\n', '// File: contracts/interfaces/IMarketRegistry.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract IMarketRegistry {\n', '\n', '    enum MarketType {\n', '      HourlyMarket,\n', '      DailyMarket,\n', '      WeeklyMarket\n', '    }\n', '    address public owner;\n', '    address public tokenController;\n', '    address public marketUtility;\n', '    bool public marketCreationPaused;\n', '\n', '    mapping(address => bool) public isMarket;\n', '    function() external payable{}\n', '\n', '    function marketDisputeStatus(address _marketAddress) public view returns(uint _status);\n', '\n', '    function burnDisputedProposalTokens(uint _proposaId) external;\n', '\n', '    function isWhitelistedSponsor(address _address) public view returns(bool);\n', '\n', '    function transferAssets(address _asset, address _to, uint _amount) external;\n', '\n', '    /**\n', '    * @dev Initialize the PlotX.\n', '    * @param _marketConfig The address of market config.\n', '    * @param _plotToken The address of PLOT token.\n', '    */\n', '    function initiate(address _defaultAddress, address _marketConfig, address _plotToken, address payable[] memory _configParams) public;\n', '\n', '    /**\n', '    * @dev Create proposal if user wants to raise the dispute.\n', '    * @param proposalTitle The title of proposal created by user.\n', '    * @param description The description of dispute.\n', '    * @param solutionHash The ipfs solution hash.\n', '    * @param actionHash The action hash for solution.\n', '    * @param stakeForDispute The token staked to raise the diospute.\n', '    * @param user The address who raises the dispute.\n', '    */\n', '    function createGovernanceProposal(string memory proposalTitle, string memory description, string memory solutionHash, bytes memory actionHash, uint256 stakeForDispute, address user, uint256 ethSentToPool, uint256 tokenSentToPool, uint256 proposedValue) public {\n', '    }\n', '\n', '    /**\n', '    * @dev Emits the PlacePrediction event and sets user data.\n', '    * @param _user The address who placed prediction.\n', '    * @param _value The amount of ether user staked.\n', '    * @param _predictionPoints The positions user will get.\n', '    * @param _predictionAsset The prediction assets user will get.\n', '    * @param _prediction The option range on which user placed prediction.\n', '    * @param _leverage The leverage selected by user at the time of place prediction.\n', '    */\n', '    function setUserGlobalPredictionData(address _user,uint _value, uint _predictionPoints, address _predictionAsset, uint _prediction,uint _leverage) public{\n', '    }\n', '\n', '    /**\n', '    * @dev Emits the claimed event.\n', '    * @param _user The address who claim their reward.\n', '    * @param _reward The reward which is claimed by user.\n', '    * @param incentives The incentives of user.\n', '    * @param incentiveToken The incentive tokens of user.\n', '    */\n', '    function callClaimedEvent(address _user , uint[] memory _reward, address[] memory predictionAssets, uint incentives, address incentiveToken) public {\n', '    }\n', '\n', '        /**\n', '    * @dev Emits the MarketResult event.\n', '    * @param _totalReward The amount of reward to be distribute.\n', '    * @param _winningOption The winning option of the market.\n', '    * @param _closeValue The closing value of the market currency.\n', '    */\n', '    function callMarketResultEvent(uint[] memory _totalReward, uint _winningOption, uint _closeValue, uint roundId) public {\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IChainLinkOracle.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'interface IChainLinkOracle\n', '{\n', '\t/**\n', '    * @dev Gets the latest answer of chainLink oracle.\n', '    * @return int256 representing the latest answer of chainLink oracle.\n', '    */\n', '\tfunction latestAnswer() external view returns (int256);\n', '\tfunction decimals() external view returns (uint8);\n', '\tfunction getRoundData(uint80 _roundId)\n', '    external\n', '    view\n', '    returns (\n', '      uint80 roundId,\n', '      int256 answer,\n', '      uint256 startedAt,\n', '      uint256 updatedAt,\n', '      uint80 answeredInRound\n', '    );\n', '\n', '  \tfunction latestRoundData()\n', '    external\n', '    view\n', '    returns (\n', '      uint80 roundId,\n', '      int256 answer,\n', '      uint256 startedAt,\n', '      uint256 updatedAt,\n', '      uint80 answeredInRound\n', '    ); \n', '}\n', '\n', '// File: contracts/interfaces/IToken.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract IToken {\n', '\n', '    function decimals() external view returns(uint8);\n', '\n', '    /**\n', '    * @dev Total number of tokens in existence\n', '    */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param account The address to query the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', '    * @dev Transfer token for a specified address\n', '    * @param recipient The address to transfer to.\n', '    * @param amount The amount to be transferred.\n', '    */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '    * @dev function that mints an amount of the token and assigns it to\n', '    * an account.\n', '    * @param account The account that will receive the created tokens.\n', '    * @param amount The amount that will be created.\n', '    */\n', '    function mint(address account, uint256 amount) external returns (bool);\n', '    \n', '     /**\n', '    * @dev burns an amount of the tokens of the message sender\n', '    * account.\n', '    * @param amount The amount that will be burnt.\n', '    */\n', '    function burn(uint256 amount) external;\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     * Returns a boolean value indicating whether the operation succeeded.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '    * @dev Transfer tokens from one address to another\n', '    * @param sender address The address which you want to send tokens from\n', '    * @param recipient address The address which you want to transfer to\n', '    * @param amount uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '}\n', '\n', '// File: contracts/MarketUtility.sol\n', '\n', '/* Copyright (C) 2020 PlotX.io\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract MarketUtility {\n', '    using SafeMath for uint256;\n', '    using FixedPoint for *;\n', '\n', '    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    uint256 constant updatePeriod = 1 hours;\n', '\n', '    uint256 internal STAKE_WEIGHTAGE;\n', '    uint256 internal STAKE_WEIGHTAGE_MIN_AMOUNT;\n', '    uint256 internal minTimeElapsedDivisor;\n', '    uint256 internal minPredictionAmount;\n', '    uint256 internal maxPredictionAmount;\n', '    uint256 internal positionDecimals;\n', '    uint256 internal minStakeForMultiplier;\n', '    uint256 internal riskPercentage;\n', '    uint256 internal tokenStakeForDispute;\n', '    address internal plotToken;\n', '    address internal plotETHpair;\n', '    address internal weth;\n', '    address internal initiater;\n', '    address public authorizedAddress;\n', '    bool public initialized;\n', '\n', '\n', '    struct UniswapPriceData {\n', '        FixedPoint.uq112x112 price0Average;\n', '        uint256 price0CumulativeLast;\n', '        FixedPoint.uq112x112 price1Average;\n', '        uint256 price1CumulativeLast;\n', '        uint32 blockTimestampLast;\n', '        bool initialized;\n', '    }\n', '\n', '    mapping(address => UniswapPriceData) internal uniswapPairData;\n', '    IUniswapV2Factory uniswapFactory;\n', '\n', '    ITokenController internal tokenController;\n', '    modifier onlyAuthorized() {\n', '        require(msg.sender == authorizedAddress, "Not authorized");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Initiates the config contact with initial values\n', '     **/\n', '    function initialize(address payable[] memory _addressParams, address _initiater) public {\n', '        OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(\n', '            address(uint160(address(this)))\n', '        );\n', '        require(msg.sender == proxy.proxyOwner(), "Sender is not proxy owner.");\n', '        require(!initialized, "Already initialized");\n', '        initialized = true;\n', '        _setInitialParameters();\n', '        authorizedAddress = msg.sender;\n', '        tokenController = ITokenController(IMarketRegistry(msg.sender).tokenController());\n', '        plotToken = _addressParams[1];\n', '        initiater = _initiater;\n', '        weth = IUniswapV2Router02(_addressParams[0]).WETH();\n', '        uniswapFactory = IUniswapV2Factory(_addressParams[2]);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to set initial value\n', '     **/\n', '    function _setInitialParameters() internal {\n', '        STAKE_WEIGHTAGE = 40; //\n', '        STAKE_WEIGHTAGE_MIN_AMOUNT = 20 ether;\n', '        minTimeElapsedDivisor = 6;\n', '        minPredictionAmount = 1e15;\n', '        maxPredictionAmount = 28 ether;\n', '        positionDecimals = 1e2;\n', '        minStakeForMultiplier = 5e17;\n', '        riskPercentage = 20;\n', '        tokenStakeForDispute = 500 ether;\n', '    }\n', '\n', '    /**\n', '    * @dev Check if user gets any multiplier on his positions\n', '    * @param _asset The assets uses by user during prediction.\n', '    * @param _predictionStake The amount staked by user at the time of prediction.\n', '    * @param predictionPoints The actual positions user got during prediction.\n', '    * @param _stakeValue The stake value of asset.\n', '    * @return uint256 representing multiplied positions\n', '    */\n', '    function checkMultiplier(address _asset, address _user, uint _predictionStake, uint predictionPoints, uint _stakeValue) public view returns(uint, bool) {\n', '      bool multiplierApplied;\n', '      uint _stakedBalance = tokenController.tokensLockedAtTime(_user, "SM", now);\n', '      uint _predictionValueInToken;\n', '      (, _predictionValueInToken) = getValueAndMultiplierParameters(_asset, _predictionStake);\n', '      if(_stakeValue < minStakeForMultiplier) {\n', '        return (predictionPoints,multiplierApplied);\n', '      }\n', '      uint _muliplier = 100;\n', '      if(_stakedBalance.div(_predictionValueInToken) > 0) {\n', '        _muliplier = _muliplier + _stakedBalance.mul(100).div(_predictionValueInToken.mul(10));\n', '        multiplierApplied = true;\n', '      }\n', '      return (predictionPoints.mul(_muliplier).div(100),multiplierApplied);\n', '    }\n', '\n', '    /**\n', '     * @dev Updates integer parameters of config\n', '     **/\n', '    function updateUintParameters(bytes8 code, uint256 value)\n', '        external\n', '        onlyAuthorized\n', '    {\n', '        if (code == "SW") { // Stake weightage\n', '            require(value <= 100, "Value must be less or equal to 100");\n', '            STAKE_WEIGHTAGE = value;\n', '        } else if (code == "SWMA") { // Minimum amount required for stake weightage\n', '            STAKE_WEIGHTAGE_MIN_AMOUNT = value;\n', '        } else if (code == "MTED") { // Minimum time elapsed divisor\n', '            minTimeElapsedDivisor = value;\n', '        } else if (code == "MINPRD") { // Minimum predictionamount\n', '            minPredictionAmount = value;\n', '        } else if (code == "MAXPRD") { // Minimum predictionamount\n', '            maxPredictionAmount = value;\n', '        } else if (code == "PDEC") { // Position\'s Decimals\n', '            positionDecimals = value;\n', '        } else if (code == "MINSTM") { // Min stake required for applying multiplier\n', '            minStakeForMultiplier = value;\n', '        } else if (code == "RPERC") { // Risk percentage\n', '            riskPercentage = value;\n', '        } else if (code == "TSDISP") { // Amount of tokens to be staked for raising a dispute\n', '            tokenStakeForDispute = value;\n', '        } else {\n', '            revert("Invalid code");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Updates address parameters of config\n', '     **/\n', '    function updateAddressParameters(bytes8 code, address payable value)\n', '        external\n', '        onlyAuthorized\n', '    {\n', '        require(value != address(0), "Value cannot be address(0)");\n', '        if (code == "UNIFAC") { // Uniswap factory address\n', '            uniswapFactory = IUniswapV2Factory(value);\n', '            plotETHpair = uniswapFactory.getPair(plotToken, weth);\n', '        } else {\n', '            revert("Invalid code");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Update cumulative price of token in uniswap\n', '     **/\n', '    function update() external onlyAuthorized {\n', '        require(plotETHpair != address(0), "Uniswap pair not set");\n', '        UniswapPriceData storage _priceData = uniswapPairData[plotETHpair];\n', '        (\n', '            uint256 price0Cumulative,\n', '            uint256 price1Cumulative,\n', '            uint32 blockTimestamp\n', '        ) = UniswapV2OracleLibrary.currentCumulativePrices(plotETHpair);\n', '        uint32 timeElapsed = blockTimestamp - _priceData.blockTimestampLast; // overflow is desired\n', '\n', '        if (timeElapsed >= updatePeriod || !_priceData.initialized) {\n', '            // overflow is desired, casting never truncates\n', '            // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\n', '            _priceData.price0Average = FixedPoint.uq112x112(\n', '                uint224(\n', '                    (price0Cumulative - _priceData.price0CumulativeLast) /\n', '                        timeElapsed\n', '                )\n', '            );\n', '            _priceData.price1Average = FixedPoint.uq112x112(\n', '                uint224(\n', '                    (price1Cumulative - _priceData.price1CumulativeLast) /\n', '                        timeElapsed\n', '                )\n', '            );\n', '\n', '            _priceData.price0CumulativeLast = price0Cumulative;\n', '            _priceData.price1CumulativeLast = price1Cumulative;\n', '            _priceData.blockTimestampLast = blockTimestamp;\n', '            if(!_priceData.initialized) {\n', '              _priceData.initialized = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Set initial PLOT/ETH pair cummulative price\n', '     **/\n', '    function setInitialCummulativePrice() public {\n', '      require(msg.sender == initiater);\n', '      require(plotETHpair == address(0),"Already initialised");\n', '      plotETHpair = uniswapFactory.getPair(plotToken, weth);\n', '      UniswapPriceData storage _priceData = uniswapPairData[plotETHpair];\n', '      (\n', '          uint256 price0Cumulative,\n', '          uint256 price1Cumulative,\n', '          uint32 blockTimestamp\n', '      ) = UniswapV2OracleLibrary.currentCumulativePrices(plotETHpair);\n', '      _priceData.price0CumulativeLast = price0Cumulative;\n', '      _priceData.price1CumulativeLast = price1Cumulative;\n', '      _priceData.blockTimestampLast = blockTimestamp;\n', '    }\n', '\n', '    /**\n', '    * @dev Get decimals of given price feed address \n', '    */\n', '    function getPriceFeedDecimals(address _priceFeed) public view returns(uint8) {\n', '      return IChainLinkOracle(_priceFeed).decimals();\n', '    }\n', '\n', '    /**\n', '     * @dev Get basic market details\n', '     * @return Minimum amount required to predict in market\n', '     * @return Percentage of users leveraged amount to deduct when placed in wrong prediction\n', '     * @return Decimal points for prediction positions\n', '     * @return Maximum prediction amount\n', '     **/\n', '    function getBasicMarketDetails()\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        return (minPredictionAmount, riskPercentage, positionDecimals, maxPredictionAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Get Parameter required for option price calculation\n', '     * @param _marketFeedAddress  Feed Address of currency on which market options are based on\n', '     * @return Stake weightage percentage for calculation option price\n', '     * @return minimum amount of stake required to consider stake weightage\n', '     * @return Current price of the market currency\n', '     * @return Divisor to calculate minimum time elapsed for a market type\n', '     **/\n', '    function getPriceCalculationParams(\n', '        address _marketFeedAddress\n', '    )\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        uint256 _currencyPrice = getAssetPriceUSD(\n', '            _marketFeedAddress\n', '        );\n', '        return (\n', '            STAKE_WEIGHTAGE,\n', '            STAKE_WEIGHTAGE_MIN_AMOUNT,\n', '            _currencyPrice,\n', '            minTimeElapsedDivisor\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Get price of provided feed address\n', '     * @param _currencyFeedAddress  Feed Address of currency on which market options are based on\n', '     * @return Current price of the market currency\n', '     **/\n', '    function getAssetPriceUSD(\n', '        address _currencyFeedAddress\n', '    ) public view returns (uint256 latestAnswer) {\n', '        return uint256(IChainLinkOracle(_currencyFeedAddress).latestAnswer());\n', '    }\n', '\n', '    /**\n', '     * @dev Get price of provided feed address\n', '     * @param _currencyFeedAddress  Feed Address of currency on which market options are based on\n', '     * @return Current price of the market currency\n', '     **/\n', '    function getSettlemetPrice(\n', '        address _currencyFeedAddress,\n', '        uint256 _settleTime\n', '    ) public view returns (uint256 latestAnswer, uint256 roundId) {\n', '        uint80 currentRoundId;\n', '        uint256 currentRoundTime;\n', '        int256 currentRoundAnswer;\n', '        (currentRoundId, currentRoundAnswer, , currentRoundTime, )= IChainLinkOracle(_currencyFeedAddress).latestRoundData();\n', '        while(currentRoundTime > _settleTime) {\n', '            currentRoundId--;\n', '            (currentRoundId, currentRoundAnswer, , currentRoundTime, )= IChainLinkOracle(_currencyFeedAddress).getRoundData(currentRoundId);\n', '            if(currentRoundTime <= _settleTime) {\n', '                break;\n', '            }\n', '        }\n', '        return\n', '            (uint256(currentRoundAnswer), currentRoundId);\n', '    }\n', '\n', '    /**\n', '     * @dev Get value of provided currency address in ETH\n', '     * @param _currencyAddress Address of currency\n', '     * @param _amount Amount of provided currency\n', '     * @return Value of provided amount in ETH\n', '     **/\n', '    function getAssetValueETH(address _currencyAddress, uint256 _amount)\n', '        public\n', '        view\n', '        returns (uint256 tokenEthValue)\n', '    {\n', '        tokenEthValue = _amount;\n', '        if (_currencyAddress != ETH_ADDRESS) {\n', '            tokenEthValue = getPrice(plotETHpair, _amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Get price of provided currency address in ETH\n', '     * @param _currencyAddress Address of currency\n', '     * @return Price of provided currency in ETH\n', '     * @return Decimals of the currency\n', '     **/\n', '    function getAssetPriceInETH(address _currencyAddress)\n', '        public\n', '        view\n', '        returns (uint256 tokenEthValue, uint256 decimals)\n', '    {\n', '        tokenEthValue = 1;\n', '        if (_currencyAddress != ETH_ADDRESS) {\n', '            decimals = IToken(_currencyAddress).decimals();\n', '            tokenEthValue = getPrice(plotETHpair, 10**decimals);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Get amount of stake required to raise a dispute\n', '     **/\n', '    function getDisputeResolutionParams() public view returns (uint256) {\n', '        return tokenStakeForDispute;\n', '    }\n', '\n', '    /**\n', '     * @dev Get value of _asset in PLOT token and multiplier parameters\n', '     * @param _asset Address of asset for which value is requested\n', '     * @param _amount Amount of _asset\n', '     * @return min prediction amount required for multiplier\n', '     * @return value of given asset in PLOT tokens\n', '     **/\n', '    function getValueAndMultiplierParameters(address _asset, uint256 _amount)\n', '        public\n', '        view\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 _value = _amount;\n', '        if (_asset == ETH_ADDRESS) {\n', '            _value = (uniswapPairData[plotETHpair].price1Average)\n', '                .mul(_amount)\n', '                .decode144();\n', '        }\n', '        return (minStakeForMultiplier, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Get Market feed address\n', '     * @return Uniswap factory address\n', '     **/\n', '    function getFeedAddresses() public view returns (address) {\n', '        return (address(uniswapFactory));\n', '    }\n', '\n', '    /**\n', '     * @dev Get value of token in pair\n', '     **/\n', '    function getPrice(address pair, uint256 amountIn)\n', '        public\n', '        view\n', '        returns (uint256 amountOut)\n', '    {\n', '        amountOut = (uniswapPairData[pair].price0Average)\n', '            .mul(amountIn)\n', '            .decode144();\n', '    }\n', '\n', '    /**\n', '    * @dev function to calculate square root of a number\n', '    */\n', '    function sqrt(uint x) internal pure returns (uint y) {\n', '      uint z = (x + 1) / 2;\n', '      y = x;\n', '      while (z < y) {\n', '          y = z;\n', '          z = (x / z + z) / 2;\n', '      }\n', '    }\n', '\n', '    /**\n', '    * @dev Calculate the prediction value, passing all the required params\n', '    * params index\n', '    * 0 _prediction\n', '    * 1 neutralMinValue\n', '    * 2 neutralMaxValue\n', '    * 3 startTime\n', '    * 4 expireTime\n', '    * 5 totalStakedETH\n', '    * 6 totalStakedToken\n', '    * 7 ethStakedOnOption\n', '    * 8 plotStakedOnOption\n', '    * 9 _stake\n', '    * 10 _leverage\n', '    */\n', '    function calculatePredictionValue(uint[] memory params, address asset, address user, address marketFeedAddress, bool _checkMultiplier) public view returns(uint _predictionValue, bool _multiplierApplied) {\n', '      uint _stakeValue = getAssetValueETH(asset, params[9]);\n', '      if(_stakeValue < minPredictionAmount || _stakeValue > maxPredictionAmount) {\n', '        return (_predictionValue, _multiplierApplied);\n', '      }\n', '      uint optionPrice;\n', '      \n', '      optionPrice = calculateOptionPrice(params, marketFeedAddress);\n', '      _predictionValue = _calculatePredictionPoints(_stakeValue.mul(positionDecimals), optionPrice, params[10]);\n', '      if(_checkMultiplier) {\n', '        return checkMultiplier(asset, user, params[9],  _predictionValue, _stakeValue);\n', '      }\n', '      return (_predictionValue, _multiplierApplied);\n', '    }\n', '\n', '    function _calculatePredictionPoints(uint value, uint optionPrice, uint _leverage) internal pure returns(uint) {\n', '      //leverageMultiplier = levergage + (leverage -1)*0.05; Raised by 3 decimals i.e 1000\n', '      uint leverageMultiplier = 1000 + (_leverage-1)*50;\n', '      value = value.mul(2500).div(1e18);\n', '      // (amount*sqrt(amount*100)*leverage*100/(price*10*125000/1000));\n', '      return value.mul(sqrt(value.mul(10000))).mul(_leverage*100*leverageMultiplier).div(optionPrice.mul(1250000000));\n', '    }\n', '\n', '    /**\n', '    * @dev Calculate the option price for given params\n', '    * params\n', '    * 0 _option\n', '    * 1 neutralMinValue\n', '    * 2 neutralMaxValue\n', '    * 3 startTime\n', '    * 4 expireTime\n', '    * 5 totalStakedETH\n', '    * 6 totalStakedToken\n', '    * 7 ethStakedOnOption\n', '    * 8 plotStakedOnOption\n', '    */\n', '    function calculateOptionPrice(uint[] memory params, address marketFeedAddress) public view returns(uint _optionPrice) {\n', '      uint _totalStaked = params[5].add(getAssetValueETH(plotToken, params[6]));\n', '      uint _assetStakedOnOption = params[7]\n', '                                .add(\n', '                                  (getAssetValueETH(plotToken, params[8])));\n', '      _optionPrice = 0;\n', '      uint currentPriceOption = 0;\n', '      uint256 currentPrice = getAssetPriceUSD(\n', '          marketFeedAddress\n', '      );\n', '      uint stakeWeightage = STAKE_WEIGHTAGE;\n', '      uint predictionWeightage = 100 - stakeWeightage;\n', '      uint predictionTime = params[4].sub(params[3]);\n', '      uint minTimeElapsed = (predictionTime).div(minTimeElapsedDivisor);\n', '      if(now > params[4]) {\n', '        return 0;\n', '      }\n', '      if(_totalStaked > STAKE_WEIGHTAGE_MIN_AMOUNT) {\n', '        _optionPrice = (_assetStakedOnOption).mul(1000000).div(_totalStaked.mul(stakeWeightage));\n', '      }\n', '\n', '      uint maxDistance;\n', '      if(currentPrice < params[1]) {\n', '        currentPriceOption = 1;\n', '        maxDistance = 2;\n', '      } else if(currentPrice > params[2]) {\n', '        currentPriceOption = 3;\n', '        maxDistance = 2;\n', '      } else {\n', '        currentPriceOption = 2;\n', '        maxDistance = 1;\n', '      }\n', '      uint distance = _getAbsoluteDifference(currentPriceOption, params[0]);\n', '      uint timeElapsed = now > params[3] ? now.sub(params[3]) : 0;\n', '      timeElapsed = timeElapsed > minTimeElapsed ? timeElapsed: minTimeElapsed;\n', '      _optionPrice = _optionPrice.add((((maxDistance+1).sub(distance)).mul(1000000).mul(timeElapsed)).div((maxDistance+1).mul(predictionWeightage).mul(predictionTime)));\n', '      _optionPrice = _optionPrice.div(100);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to get the absolute difference of two values\n', '    */\n', '    function _getAbsoluteDifference(uint value1, uint value2) internal pure returns(uint) {\n', '      return value1 > value2 ? value1.sub(value2) : value2.sub(value1);\n', '    }\n', '}']