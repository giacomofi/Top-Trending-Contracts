['pragma solidity ^0.5.17;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function transfer(address recipient, uint amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function approve(address spender, uint amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        require(b <= a, errorMessage);\n', '        uint c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface UniswapRouter {\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function factory() external view returns (address);\n', '}\n', '\n', 'interface UniswapFactory {\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '}\n', '\n', 'interface StableCreditProtocol {\n', '    function utilization(address token) external view returns (uint);\n', '    function BASE() external view returns (uint);\n', '    function MAX() external view returns (uint);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function balances(address owner, address token) external view returns (uint);\n', '    function credit(address owner, address token) external view returns (uint);\n', '}\n', '\n', 'contract StableCreditHelper {\n', '    using SafeMath for uint;\n', '    \n', '    UniswapRouter public constant UNI = UniswapRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '    StableCreditProtocol public constant STABLE = StableCreditProtocol(0x20D5BFBa0f5c726AAd09956FD7398Acdac048858);\n', '    \n', '    constructor () public {}\n', '    \n', '    // How much system liquidity is provided by this asset\n', '    function _utilization(address token, uint amount) internal view returns (uint) {\n', '        uint _max = STABLE.MAX();\n', '        uint _base = STABLE.BASE();\n', '        address _pair = UniswapFactory(UNI.factory()).getPair(token, address(STABLE));\n', '        uint _ratio = _base.sub(_base.mul(STABLE.balanceOf(_pair).add(amount)).div(STABLE.totalSupply()));\n', '        if (_ratio == 0) {\n', '            return _max;\n', '        }\n', '        return  _ratio > _max ? _max : _ratio;\n', '    }\n', '    function calculateCollateral(address token) external view returns (uint) {\n', '        return calculateWithdraw(token, uint(-1));\n', '    }\n', '    function calculateCollateralOf(address owner, address token) external view returns (uint) {\n', '        return calculateWithdrawOf(owner, token, uint(-1));\n', '    }\n', '    function calculateWithdrawMax(address token) external view returns (uint) {\n', '        return calculateWithdraw(token, STABLE.balanceOf(msg.sender));\n', '    }\n', '    function calculateWithdrawMaxOf(address owner, address token) external view returns (uint) {\n', '        return calculateWithdrawOf(owner, token, STABLE.balanceOf(msg.sender));\n', '    }\n', '    function calculateWithdraw(address token, uint amount) public view returns (uint) {\n', '        return calculateWithdrawOf(msg.sender, token, amount);\n', '    }\n', '    function credit(address owner, address token) external view returns (uint) {\n', '        return STABLE.credit(owner, token);\n', '    }\n', '    function calculateWithdrawOf(address owner, address token, uint amount) public view returns (uint output) {\n', '        address _pair = UniswapFactory(UNI.factory()).getPair(token, address(STABLE));\n', '        uint _supply = IERC20(_pair).totalSupply();\n', '        uint _balance = IERC20(token).balanceOf(_pair);\n', '        uint _share = STABLE.balances(owner, token);\n', '        output = _balance.mul(_share).div(_supply);\n', '        \n', '        uint _credit = STABLE.credit(owner, token);\n', '        if (_credit < amount) {\n', '            amount = _credit;\n', '        }\n', '        output = output.mul(amount).div(_credit);\n', '    }\n', '    // Calculate maxium amount of credit a depositer will get for their token\n', '    function calculateCreditMax(address token) external view returns (uint) {\n', '        return calculateCreditMaxOf(msg.sender, token);\n', '    }\n', '    function calculateCreditMaxOf(address owner, address token) public view returns (uint) {\n', '        return calculateCredit(token, IERC20(token).balanceOf(owner));\n', '    }\n', '    function calculateCredit(address token, uint amount) public view returns (uint) {\n', '        return amount.mul(_utilization(token, amount)).div(STABLE.BASE());\n', '    }\n', '    // Calculate how much USD required to borrow exact amount of output token\n', '    function calculateBorrowExactOut(address token, uint outExact) external view returns (uint) {\n', '        address[] memory _path = new address[](2);\n', '        _path[0] = address(STABLE);\n', '        _path[1] = token;\n', '        return UNI.getAmountsIn(outExact, _path)[0];\n', '    }\n', '    // Calculate maximum amount of output token given amount of USD owner by owner\n', '    function calculateBorrowMax(address token) external view returns (uint) {\n', '        return calculateBorrowMaxOf(msg.sender, token);\n', '    }\n', '    function calculateBorrowMaxOf(address owner, address token) public view returns (uint) {\n', '        return calculateBorrowExactIn(token, STABLE.balanceOf(owner));\n', '    }\n', '    // Calculate amount of token received given exact amount of USD input\n', '    function calculateBorrowExactIn(address token, uint inExact) public view returns (uint) {\n', '        address[] memory _path = new address[](2);\n', '        _path[0] = address(STABLE);\n', '        _path[1] = token;\n', '        return UNI.getAmountsOut(inExact, _path)[1];\n', '    }\n', '    // Calculate amount of USD required to repay exact amount of token\n', '    function calculateRepayExactOut(address token, uint outExact) external view returns (uint) {\n', '        address[] memory _path = new address[](2);\n', '        _path[0] = token;\n', '        _path[1] = address(STABLE);\n', '        return UNI.getAmountsIn(outExact, _path)[0];\n', '    }\n', '    // calculate maximum amount of token repaid given USD input\n', '    function calculateRepayMax(address token) external view returns (uint) {\n', '        return calculateRepayMaxOf(msg.sender, token);\n', '    }\n', '    \n', '    function calculateRepayMaxOf(address owner, address token) public view returns (uint) {\n', '        return calculateRepayExactIn(token, IERC20(token).balanceOf(owner));\n', '    }\n', '    \n', '    // Calculate amount of token repaid given exact amount of USD input\n', '    function calculateRepayExactIn(address token, uint inExact) public view returns (uint) {\n', '        address[] memory _path = new address[](2);\n', '        _path[0] = token;\n', '        _path[1] = address(STABLE);\n', '        return UNI.getAmountsOut(inExact, _path)[1];\n', '    }\n', '}']