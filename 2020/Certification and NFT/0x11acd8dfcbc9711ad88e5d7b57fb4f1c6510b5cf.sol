['/**\n', ' *Submitted for verification at Etherscan.io on 2020-04-14\n', '*/\n', '\n', '// File: contracts/LiteSig.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '/**\n', ' * LiteSig is a lighter weight multisig based on https://github.com/christianlundkvist/simple-multisig\n', ' * Owners aggregate signatures offline and then broadcast a transaction with the required number of signatures.\n', ' * Unlike other multisigs, this is meant to have minimal administration functions and other features in order\n', ' * to reduce the footprint and attack surface.\n', ' */\n', 'contract LiteSig {\n', '\n', '    //  Events triggered for incoming and outgoing transactions\n', '    event Deposit(address indexed source, uint value);\n', '    event Execution(uint indexed transactionId, address indexed destination, uint value, bytes data);\n', '    event ExecutionFailure(uint indexed transactionId, address indexed destination, uint value, bytes data);\n', '\n', '    // List of owner addresses - for external readers convenience only\n', '    address[] public owners;\n', '\n', '    // Mapping of owner address to keep track for lookups\n', '    mapping(address => bool) ownersMap;\n', '\n', '    // Nonce increments by one on each broadcast transaction to prevent replays\n', '    uint public nonce = 0;\n', '\n', '    // Number of required signatures from the list of owners\n', '    uint public requiredSignatures = 0;\n', '\n', '    // EIP712 Precomputed hashes:\n', '    // keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)")\n', '    bytes32 constant EIP712DOMAINTYPE_HASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\n', '\n', '    // keccak256("LiteSig")\n', '    bytes32 constant NAME_HASH = 0x3308695f49e3f28122810c848e1569a04488ca4f6a11835568450d7a38a86120;\n', '\n', '    // keccak256("1")\n', '    bytes32 constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n', '\n', '    // keccak256("MultiSigTransaction(address destination,uint256 value,bytes data,uint256 nonce,address txOrigin)")\n', '    bytes32 constant TXTYPE_HASH = 0x81336c6b66e18c614f29c0c96edcbcbc5f8e9221f35377412f0ea5d6f428918e;\n', '\n', '    // keccak256("TOKENSOFT")\n', '    bytes32 constant SALT = 0x9c360831104e550f13ec032699c5f1d7f17190a31cdaf5c83945a04dfd319eea;\n', '\n', "    // Hash for EIP712, computed from data and contract address - ensures it can't be replayed against\n", '    // other contracts or chains\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '\n', '    // Track init state\n', '    bool initialized = false;\n', '\n', '    // The init function inputs a list of owners and the number of signatures that\n', '    //   are required before a transaction is executed.\n', '    // Owners list must be in ascending address order.\n', '    // Required sigs must be greater than 0 and less than or equal to number of owners.\n', '    // Chain ID prevents replay across chains\n', '    // This function can only be run one time\n', '    function init(address[] memory _owners, uint _requiredSignatures, uint chainId) public {\n', "        // Verify it can't be initialized again\n", '        require(!initialized, "Init function can only be run once");\n', '        initialized = true;\n', '\n', '        // Verify the lengths of values being passed in\n', '        require(_owners.length > 0 && _owners.length <= 10, "Owners List min is 1 and max is 10");\n', '        require(\n', '            _requiredSignatures > 0 && _requiredSignatures <= _owners.length,\n', '            "Required signatures must be in the proper range"\n', '        );\n', '\n', '        // Verify the owners list is valid and in order\n', '        // No 0 addresses or duplicates\n', '        address lastAdd = address(0);\n', '        for (uint i = 0; i < _owners.length; i++) {\n', '            require(_owners[i] > lastAdd, "Owner addresses must be unique and in order");\n', '            ownersMap[_owners[i]] = true;\n', '            lastAdd = _owners[i];\n', '        }\n', '\n', '        // Save off owner list and required sig.\n', '        owners = _owners;\n', '        requiredSignatures = _requiredSignatures;\n', '\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(EIP712DOMAINTYPE_HASH,\n', '            NAME_HASH,\n', '            VERSION_HASH,\n', '            chainId,\n', '            address(this),\n', '            SALT)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * This function is adapted from the OpenZeppelin libarary but instead of passing in bytes\n', '     * array, it already has the sig fields broken down.\n', '     *\n', '     * @dev Returns the address that signed a hashed message (`hash`) with\n', '     * `signature`. This address can then be used for verification purposes.\n', '     *\n', '     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n', '     * this function rejects them by requiring the `s` value to be in the lower\n', '     * half order, and the `v` value to be either 27 or 28.\n', '     *\n', '     * (.note) This call _does not revert_ if the signature is invalid, or\n', '     * if the signer is otherwise unable to be retrieved. In those scenarios,\n', '     * the zero address is returned.\n', '     *\n', '     * (.warning) `hash` _must_ be the result of a hash operation for the\n', '     * verification to be secure: it is possible to craft signatures that\n', '     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n', '     * this is by receiving a hash of the original message (which may otherwise)\n', '     * be too long), and then calling `toEthSignedMessageHash` on it.\n', '     */\n', '    function safeRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n', '\n', '        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n', '        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n', '        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n', '        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n', '        //\n', '        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n', '        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n', '        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n', '        // these malleable signatures as well.\n', '        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n', '            return address(0);\n', '        }\n', '\n', '        if (v != 27 && v != 28) {\n', '            return address(0);\n', '        }\n', '\n', '        // If the signature is valid (and not malleable), return the signer address\n', '        return ecrecover(hash, v, r, s);\n', '    }\n', '\n', '    /**\n', '     * Once the owners of the multisig have signed across the payload, they can submit it to this function.\n', '     * This will verify enough signatures were aggregated and then broadcast the transaction.\n', '     * It can be used to send ETH or trigger a function call against another address (or both).\n', '     *\n', '     * Signatures must be in the correct ascending order (according to associated addresses)\n', '     */\n', '    function submit(\n', '        uint8[] memory sigV,\n', '        bytes32[] memory sigR,\n', '        bytes32[] memory sigS,\n', '        address destination,\n', '        uint value,\n', '        bytes memory data\n', '    ) public returns (bool)\n', '    {\n', '        // Verify initialized\n', '        require(initialized, "Initialization must be complete");\n', '\n', '        // Verify signature lengths\n', '        require(sigR.length == sigS.length && sigR.length == sigV.length, "Sig arrays not the same lengths");\n', '        require(sigR.length == requiredSignatures, "Signatures list is not the expected length");\n', '\n', '        // EIP712 scheme: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\n', '        // Note that the nonce is always included from the contract state to prevent replay attacks\n', '        // Note that tx.origin is included to ensure only a predetermined account can broadcast\n', '        bytes32 txInputHash = keccak256(abi.encode(TXTYPE_HASH, destination, value, keccak256(data), nonce, tx.origin));\n', '        bytes32 totalHash = keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, txInputHash));\n', '\n', '        // Add in the ETH specific prefix\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, totalHash));\n', '\n', '        // Iterate and verify signatures are from owners\n', '        address lastAdd = address(0); // cannot have address(0) as an owner\n', '        for (uint i = 0; i < requiredSignatures; i++) {\n', '\n', '            // Recover the address from the signature - if anything is wrong, this will return 0\n', '            address recovered = safeRecover(prefixedHash, sigV[i], sigR[i], sigS[i]);\n', '\n', '            // Ensure the signature is from an owner address and there are no duplicates\n', '            // Also verifies error of 0 returned\n', '            require(ownersMap[recovered], "Signature must be from an owner");\n', '            require(recovered > lastAdd, "Signature must be unique");\n', '            lastAdd = recovered;\n', '        }\n', '\n', '        // Increment the nonce before making external call\n', '        nonce = nonce + 1;\n', '        (bool success, ) = address(destination).call.value(value)(data);\n', '        if(success) {\n', '            emit Execution(nonce, destination, value, data);\n', '        } else {\n', '            emit ExecutionFailure(nonce, destination, value, data);\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '    // Allow ETH to be sent to this contract\n', '    function () external payable {\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be aplied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/Administratable.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '\n', '/**\n', 'This contract allows a list of administrators to be tracked.  This list can then be enforced\n', 'on functions with administrative permissions.  Only the owner of the contract should be allowed\n', 'to modify the administrator list.\n', ' */\n', 'contract Administratable is Ownable {\n', '\n', '    // The mapping to track administrator accounts - true is reserved for admin addresses.\n', '    mapping (address => bool) public administrators;\n', '\n', '    // Events to allow tracking add/remove.\n', '    event AdminAdded(address indexed addedAdmin, address indexed addedBy);\n', '    event AdminRemoved(address indexed removedAdmin, address indexed removedBy);\n', '\n', '    /**\n', '    Function modifier to enforce administrative permissions.\n', '     */\n', '    modifier onlyAdministrator() {\n', '        require(isAdministrator(msg.sender), "Calling account is not an administrator.");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    Determine if the message sender is in the administrators list.\n', '     */\n', '    function isAdministrator(address addressToTest) public view returns (bool) {\n', '        return administrators[addressToTest];\n', '    }\n', '\n', '    /**\n', '    Add an admin to the list.  This should only be callable by the owner of the contract.\n', '     */\n', '    function addAdmin(address adminToAdd) public onlyOwner {\n', '        // Verify the account is not already an admin\n', '        require(administrators[adminToAdd] == false, "Account to be added to admin list is already an admin");\n', '\n', '        // Set the address mapping to true to indicate it is an administrator account.\n', '        administrators[adminToAdd] = true;\n', '\n', '        // Emit the event for any watchers.\n', '        emit AdminAdded(adminToAdd, msg.sender);\n', '    }\n', '\n', '    /**\n', '    Remove an admin from the list.  This should only be callable by the owner of the contract.\n', '     */\n', '    function removeAdmin(address adminToRemove) public onlyOwner {\n', '        // Verify the account is an admin\n', '        require(administrators[adminToRemove] == true, "Account to be removed from admin list is not already an admin");\n', '\n', '        // Set the address mapping to false to indicate it is NOT an administrator account.\n', '        administrators[adminToRemove] = false;\n', '\n', '        // Emit the event for any watchers.\n', '        emit AdminRemoved(adminToRemove, msg.sender);\n', '    }\n', '}\n', '\n', '// File: contracts/LiteSigFactory.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '\n', '\n', '/**\n', ' * LiteSig Factory creates new instances of the multisig contract and triggers an event\n', ' * for listeners to see the new contract.\n', ' */\n', 'contract LiteSigFactory is Administratable {\n', '\n', '  // Event to track deployments\n', '  event Deployed(address indexed deployedAddress);\n', '\n', '  // Constructor for the factory\n', '  constructor() public {\n', '    // Add the deployer as an admin by default\n', '    Administratable.addAdmin(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * Function called by external addresses to create a new multisig contract\n', '   * Caller must be whitelisted as an admin - this is to prevent someone from sniping the address\n', '   * (the standard approach to locking in the sender addr into the salt was not chosen in case a long time\n', '   * passes before the contract is created and a new deployment account is required for some unknown reason)\n', '   */\n', '  function createLiteSig(bytes32 salt, address[] memory _owners, uint _requiredSignatures, uint chainId)\n', '    public onlyAdministrator returns (address) {\n', '    // Track the address for the new contract\n', '    address payable deployedAddress;\n', '\n', '    // Get the creation code from the payment handler\n', '    bytes memory code = type(LiteSig).creationCode;\n', '\n', '    // Drop into assembly to deploy with create2\n', '    assembly {\n', '      deployedAddress := create2(0, add(code, 0x20), mload(code), salt)\n', '      if iszero(extcodesize(deployedAddress)) { revert(0, 0) }\n', '    }\n', '\n', "    // Initialize the contract with this master's address\n", '    LiteSig(deployedAddress).init(_owners, _requiredSignatures, chainId);\n', '\n', '    // Trigger the event for any listeners\n', '    emit Deployed(deployedAddress);\n', '\n', '    // Return address back to caller if applicable\n', '    return deployedAddress;\n', '  }\n', '}']