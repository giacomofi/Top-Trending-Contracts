['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "MApprovalChain.sol";\n', 'import "LibConstants.sol";\n', 'import "MainStorage.sol";\n', '\n', '/**\n', '  A :sol:mod:`Committee` contract is a contract that the exchange service sends committee member\n', '  signatures to attesting that they have a copy of the data over which a new Merkel root is to be\n', '  accepted as the new state root. In addition, the exchange contract can call an availability\n', '  verifier to check if such signatures were indeed provided by a sufficient number of committee\n', '  members as hard coded in the :sol:mod:`Committee` contract for a given state transition\n', '  (as reflected by the old and new vault and order roots).\n', '\n', '  The exchange contract will normally query only one :sol:mod:`Committee` contract for data\n', '  availability checks. However, in the event that the committee needs to be updated, additional\n', '  availability verifiers may be registered with the exchange contract by the\n', '  contract :sol:mod:`MainGovernance`. Such new availability verifiers are then also be required to\n', '  attest to the data availability for state transitions and only if all the availability verifiers\n', '  attest to it, the state transition is accepted.\n', '\n', '  Removal of availability verifiers is also the responsibility of the :sol:mod:`MainGovernance`.\n', '  The removal process is more sensitive than availability verifier registration as it may affect the\n', '  soundness of the system. Hence, this is performed in two steps:\n', '\n', '  1. The :sol:mod:`MainGovernance` first announces the intent to remove an availability verifier by calling :sol:func:`announceAvailabilityVerifierRemovalIntent`\n', '  2. After the expiration of a `VERIFIER_REMOVAL_DELAY` time lock, actual removal may be performed by calling :sol:func:`removeAvailabilityVerifier`\n', '\n', '  The removal delay ensures that a user concerned about the soundness of the system has ample time\n', '  to leave the exchange.\n', '*/\n', 'contract AvailabilityVerifiers is MainStorage, LibConstants, MApprovalChain {\n', '    function getRegisteredAvailabilityVerifiers()\n', '        external view\n', '        returns (address[] memory _verifers)\n', '    {\n', '        return availabilityVerifiersChain.list;\n', '    }\n', '\n', '    function isAvailabilityVerifier(address verifierAddress)\n', '        external view\n', '        returns (bool)\n', '    {\n', '        return findEntry(availabilityVerifiersChain.list, verifierAddress) != ENTRY_NOT_FOUND;\n', '    }\n', '\n', '    function registerAvailabilityVerifier(address verifier, string calldata identifier)\n', '        external\n', '    {\n', '        addEntry(availabilityVerifiersChain, verifier, MAX_VERIFIER_COUNT, identifier);\n', '    }\n', '\n', '    function announceAvailabilityVerifierRemovalIntent(address verifier)\n', '        external\n', '    {\n', '        announceRemovalIntent(availabilityVerifiersChain, verifier, VERIFIER_REMOVAL_DELAY);\n', '    }\n', '\n', '    function removeAvailabilityVerifier(address verifier)\n', '        external\n', '    {\n', '        removeEntry(availabilityVerifiersChain, verifier);\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "Freezable.sol";\n', 'import "KeyGetters.sol";\n', 'import "MainGovernance.sol";\n', 'import "Operator.sol";\n', 'import "AcceptModifications.sol";\n', 'import "Escapes.sol";\n', 'import "StateRoot.sol";\n', 'import "TokenQuantization.sol";\n', 'import "UpdateState.sol";\n', 'import "IFactRegistry.sol";\n', 'import "SubContractor.sol";\n', '\n', 'contract StarkExState is\n', '    MainGovernance,\n', '    SubContractor,\n', '    Operator,\n', '    Freezable,\n', '    AcceptModifications,\n', '    TokenQuantization,\n', '    StateRoot,\n', '    Escapes,\n', '    UpdateState,\n', '    KeyGetters\n', '{\n', '    uint256 constant INITIALIZER_SIZE = 192;  // 1 x address + 5 * uint256 = 192 bytes.\n', '\n', '    /*\n', '      Initialization flow:\n', '      1. Extract initialization parameters from data.\n', '      2. Call internalInitializer with those parameters.\n', '    */\n', '    function initialize(bytes calldata data) external {\n', '\n', '        // This initializer sets roots etc. It must not be applied twice.\n', '        // I.e. it can run only when the state is still empty.\n', '        require(vaultRoot == 0, "STATE_ALREADY_INITIALIZED");\n', '        require(vaultTreeHeight == 0, "STATE_ALREADY_INITIALIZED");\n', '        require(orderRoot == 0, "STATE_ALREADY_INITIALIZED");\n', '        require(orderTreeHeight == 0, "STATE_ALREADY_INITIALIZED");\n', '\n', '        require(data.length == INITIALIZER_SIZE, "INCORRECT_INIT_DATA_SIZE_192");\n', '        IFactRegistry escapeVerifier;\n', '        uint256 initialSequenceNumber;\n', '        uint256 initialVaultRoot;\n', '        uint256 initialOrderRoot;\n', '        uint256 initialVaultTreeHeight;\n', '        uint256 initialOrderTreeHeight;\n', '        (\n', '            escapeVerifier,\n', '            initialSequenceNumber,\n', '            initialVaultRoot,\n', '            initialOrderRoot,\n', '            initialVaultTreeHeight,\n', '            initialOrderTreeHeight\n', '        ) = abi.decode(data, (IFactRegistry, uint256, uint256, uint256, uint256, uint256));\n', '\n', '        initGovernance();\n', '        Operator.initialize();\n', '        StateRoot.initialize(\n', '            initialSequenceNumber,\n', '            initialVaultRoot,\n', '            initialOrderRoot,\n', '            initialVaultTreeHeight,\n', '            initialOrderTreeHeight\n', '        );\n', '        Escapes.initialize(escapeVerifier);\n', '    }\n', '\n', '    /*\n', '      The call to initializerSize is done from MainDispatcher using delegatecall,\n', '      thus the existing state is already accessible.\n', '    */\n', '    function initializerSize() external view returns (uint256) {\n', '        return INITIALIZER_SIZE;\n', '    }\n', '\n', '    function identify() external pure returns (string memory) {\n', '        return "StarkWare_StarkExState_2020_1";\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract MGovernance {\n', '    /*\n', '      Allows calling the function only by a Governor.\n', '    */\n', '    modifier onlyGovernance()\n', '    {\n', '        // Pure modifier declarations are not supported. Instead we provide\n', '        // a dummy definition.\n', '        revert("UNIMPLEMENTED");\n', '        _;\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "GovernanceStorage.sol";\n', 'import "MGovernance.sol";\n', '\n', '/*\n', '  Implements Generic Governance, applicable for both proxy and main contract, and possibly others.\n', '  Notes:\n', '  1. This class is virtual (getGovernanceTag is not implemented).\n', '  2. The use of the same function names by both the Proxy and a delegated implementation\n', '     is not possible since calling the implementation functions is done via the default function\n', '     of the Proxy. For this reason, for example, the implementation of MainContract (MainGovernance)\n', '     exposes mainIsGovernor, which calls the internal isGovernor method.\n', '*/\n', 'contract Governance is GovernanceStorage, MGovernance {\n', '    event LogNominatedGovernor(address nominatedGovernor);\n', '    event LogNewGovernorAccepted(address acceptedGovernor);\n', '    event LogRemovedGovernor(address removedGovernor);\n', '    event LogNominationCancelled();\n', '\n', '    address internal constant ZERO_ADDRESS = address(0x0);\n', '\n', '    /*\n', '      Returns a string which uniquely identifies the type of the governance mechanism.\n', '    */\n', '    function getGovernanceTag()\n', '        internal\n', '        view\n', '        returns (string memory);\n', '\n', '    /*\n', '      Returns the GovernanceInfoStruct associated with the governance tag.\n', '    */\n', '    function contractGovernanceInfo()\n', '        internal\n', '        view\n', '        returns (GovernanceInfoStruct storage) {\n', '        string memory tag = getGovernanceTag();\n', '        GovernanceInfoStruct storage gub = governanceInfo[tag];\n', '        require(gub.initialized, "NOT_INITIALIZED");\n', '        return gub;\n', '    }\n', '\n', '    /*\n', '      Current code intentionally prevents governance re-initialization.\n', '      This may be a problem in an upgrade situation, in a case that the upgrade-to implementation\n', '      performs an initialization (for real) and within that calls initGovernance().\n', '\n', '      Possible workarounds:\n', '      1. Clearing the governance info altogether by changing the MAIN_GOVERNANCE_INFO_TAG.\n', '         This will remove existing main governance information.\n', '      2. Modify the require part in this function, so that it will exit quietly\n', '         when trying to re-initialize (uncomment the lines below).\n', '    */\n', '    function initGovernance()\n', '        internal\n', '    {\n', '        string memory tag = getGovernanceTag();\n', '        GovernanceInfoStruct storage gub = governanceInfo[tag];\n', '        require(!gub.initialized, "ALREADY_INITIALIZED");\n', "        gub.initialized = true;  // to ensure addGovernor() won't fail.\n", '        // Add the initial governer.\n', '        addGovernor(msg.sender);\n', '    }\n', '\n', '    modifier onlyGovernance()\n', '    {\n', '        require(isGovernor(msg.sender), "ONLY_GOVERNANCE");\n', '        _;\n', '    }\n', '\n', '    function isGovernor(address testGovernor)\n', '        internal view\n', '        returns (bool addressIsGovernor){\n', '        GovernanceInfoStruct storage gub = contractGovernanceInfo();\n', '        addressIsGovernor = gub.effectiveGovernors[testGovernor];\n', '    }\n', '\n', '    /*\n', '      Cancels the nomination of a governor candidate.\n', '    */\n', '    function cancelNomination() internal onlyGovernance() {\n', '        GovernanceInfoStruct storage gub = contractGovernanceInfo();\n', '        gub.candidateGovernor = ZERO_ADDRESS;\n', '        emit LogNominationCancelled();\n', '    }\n', '\n', '    function nominateNewGovernor(address newGovernor) internal onlyGovernance() {\n', '        GovernanceInfoStruct storage gub = contractGovernanceInfo();\n', '        require(!isGovernor(newGovernor), "ALREADY_GOVERNOR");\n', '        gub.candidateGovernor = newGovernor;\n', '        emit LogNominatedGovernor(newGovernor);\n', '    }\n', '\n', '    /*\n', '      The addGovernor is called in two cases:\n', '      1. by acceptGovernance when a new governor accepts its role.\n', '      2. by initGovernance to add the initial governor.\n', '      The difference is that the init path skips the nominate step\n', '      that would fail because of the onlyGovernance modifier.\n', '    */\n', '    function addGovernor(address newGovernor) private {\n', '        require(!isGovernor(newGovernor), "ALREADY_GOVERNOR");\n', '        GovernanceInfoStruct storage gub = contractGovernanceInfo();\n', '        gub.effectiveGovernors[newGovernor] = true;\n', '    }\n', '\n', '    function acceptGovernance()\n', '        internal\n', '    {\n', '        // The new governor was proposed as a candidate by the current governor.\n', '        GovernanceInfoStruct storage gub = contractGovernanceInfo();\n', '        require(msg.sender == gub.candidateGovernor, "ONLY_CANDIDATE_GOVERNOR");\n', '\n', '        // Update state.\n', '        addGovernor(gub.candidateGovernor);\n', '        gub.candidateGovernor = ZERO_ADDRESS;\n', '\n', '        // Send a notification about the change of governor.\n', '        emit LogNewGovernorAccepted(msg.sender);\n', '    }\n', '\n', '    /*\n', '      Remove a governor from office.\n', '    */\n', '    function removeGovernor(address governorForRemoval) internal onlyGovernance() {\n', '        require(msg.sender != governorForRemoval, "GOVERNOR_SELF_REMOVE");\n', '        GovernanceInfoStruct storage gub = contractGovernanceInfo();\n', '        require (isGovernor(governorForRemoval), "NOT_GOVERNOR");\n', '        gub.effectiveGovernors[governorForRemoval] = false;\n', '        emit LogRemovedGovernor(governorForRemoval);\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract PublicInputOffsets {\n', '    // The following constants are offsets of data expected in the public input.\n', '    uint256 internal constant PUB_IN_INITIAL_VAULT_ROOT_OFFSET = 0;\n', '    uint256 internal constant PUB_IN_FINAL_VAULT_ROOT_OFFSET = 1;\n', '    uint256 internal constant PUB_IN_INITIAL_ORDER_ROOT_OFFSET = 2;\n', '    uint256 internal constant PUB_IN_FINAL_ORDER_ROOT_OFFSET = 3;\n', '    uint256 internal constant PUB_IN_GLOBAL_EXPIRATION_TIMESTAMP_OFFSET = 4;\n', '    uint256 internal constant PUB_IN_VAULT_TREE_HEIGHT_OFFSET = 5;\n', '    uint256 internal constant PUB_IN_ORDER_TREE_HEIGHT_OFFSET = 6;\n', '    uint256 internal constant PUB_IN_N_MODIFICATIONS_OFFSET = 7;\n', '    uint256 internal constant PUB_IN_N_CONDITIONAL_TRANSFERS_OFFSET = 8;\n', '    uint256 internal constant PUB_IN_TRANSACTIONS_DATA_OFFSET = 9;\n', '\n', '    uint256 internal constant PUB_IN_N_WORDS_PER_MODIFICATION = 3;\n', '    uint256 internal constant PUB_IN_N_WORDS_PER_CONDITIONAL_TRANSFER = 1;\n', '\n', '    // The following constants are offsets of data expected in the application data.\n', '    uint256 internal constant APP_DATA_BATCH_ID_OFFSET = 0;\n', '    uint256 internal constant APP_DATA_PREVIOUS_BATCH_ID_OFFSET = 1;\n', '    uint256 internal constant APP_DATA_TRANSACTIONS_DATA_OFFSET = 2;\n', '\n', '    uint256 internal constant APP_DATA_N_WORDS_PER_CONDITIONAL_TRANSFER = 2;\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "MainStorage.sol";\n', 'import "IFactRegistry.sol";\n', 'import "IQueryableFactRegistry.sol";\n', 'import "Identity.sol";\n', 'import "MApprovalChain.sol";\n', 'import "MFreezable.sol";\n', 'import "MGovernance.sol";\n', 'import "Common.sol";\n', '\n', '/*\n', '  Implements a data structure that supports instant registration\n', '  and slow time-locked removal of entries.\n', '*/\n', 'contract ApprovalChain is MainStorage, MApprovalChain, MGovernance, MFreezable {\n', '\n', '    using Addresses for address;\n', '\n', '    function addEntry(\n', '        StarkExTypes.ApprovalChainData storage chain,\n', '        address entry, uint256 maxLength, string memory identifier)\n', '        internal\n', '        onlyGovernance()\n', '        notFrozen()\n', '    {\n', '        address[] storage list = chain.list;\n', '        require(entry.isContract(), "ADDRESS_NOT_CONTRACT");\n', '        bytes32 hash_real = keccak256(abi.encodePacked(Identity(entry).identify()));\n', '        bytes32 hash_identifier = keccak256(abi.encodePacked(identifier));\n', '        require(hash_real == hash_identifier, "UNEXPECTED_CONTRACT_IDENTIFIER");\n', '        require(list.length < maxLength, "CHAIN_AT_MAX_CAPACITY");\n', '        require(findEntry(list, entry) == ENTRY_NOT_FOUND, "ENTRY_ALREADY_EXISTS");\n', '\n', '        // Verifier must have at least one fact registered before adding to chain,\n', "        // unless it's the first verifier in the chain.\n", '        require(\n', '            list.length == 0 || IQueryableFactRegistry(entry).hasRegisteredFact(),\n', '            "ENTRY_NOT_ENABLED");\n', '        chain.list.push(entry);\n', '        chain.unlockedForRemovalTime[entry] = 0;\n', '    }\n', '\n', '    function findEntry(address[] storage list, address entry)\n', '        internal view returns (uint256)\n', '    {\n', '        uint256 n_entries = list.length;\n', '        for (uint256 i = 0; i < n_entries; i++) {\n', '            if (list[i] == entry) {\n', '                return i;\n', '            }\n', '        }\n', '\n', '        return ENTRY_NOT_FOUND;\n', '    }\n', '\n', '    function safeFindEntry(address[] storage list, address entry)\n', '        internal view returns (uint256 idx)\n', '    {\n', '        idx = findEntry(list, entry);\n', '\n', '        require(idx != ENTRY_NOT_FOUND, "ENTRY_DOES_NOT_EXIST");\n', '    }\n', '\n', '    function announceRemovalIntent(\n', '        StarkExTypes.ApprovalChainData storage chain, address entry, uint256 removalDelay)\n', '        internal\n', '        onlyGovernance()\n', '        notFrozen()\n', '    {\n', '        safeFindEntry(chain.list, entry);\n', '        require(now + removalDelay > now, "INVALID_REMOVAL_DELAY"); // NOLINT: timestamp.\n', '        // solium-disable-next-line security/no-block-members\n', '        chain.unlockedForRemovalTime[entry] = now + removalDelay;\n', '    }\n', '\n', '    function removeEntry(StarkExTypes.ApprovalChainData storage chain, address entry)\n', '        internal\n', '        onlyGovernance()\n', '        notFrozen()\n', '    {\n', '        address[] storage list = chain.list;\n', '        // Make sure entry exists.\n', '        uint256 idx = safeFindEntry(list, entry);\n', '        uint256 unlockedForRemovalTime = chain.unlockedForRemovalTime[entry];\n', '\n', '        // solium-disable-next-line security/no-block-members\n', '        require(unlockedForRemovalTime > 0, "REMOVAL_NOT_ANNOUNCED");\n', '        // solium-disable-next-line security/no-block-members\n', '        require(now >= unlockedForRemovalTime, "REMOVAL_NOT_ENABLED_YET"); // NOLINT: timestamp.\n', '\n', '        uint256 n_entries = list.length;\n', '\n', '        // Removal of last entry is forbidden.\n', '        require(n_entries > 1, "LAST_ENTRY_MAY_NOT_BE_REMOVED");\n', '\n', '        if (idx != n_entries - 1) {\n', '            list[idx] = list[n_entries - 1];\n', '        }\n', '        list.pop();\n', '        delete chain.unlockedForRemovalTime[entry];\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "LibConstants.sol";\n', 'import "MFreezable.sol";\n', 'import "MGovernance.sol";\n', 'import "MainStorage.sol";\n', '\n', '/*\n', '  Implements MFreezable.\n', '*/\n', 'contract Freezable is MainStorage, LibConstants, MGovernance, MFreezable {\n', '    event LogFrozen();\n', '    event LogUnFrozen();\n', '\n', '    modifier notFrozen()\n', '    {\n', '        require(!stateFrozen, "STATE_IS_FROZEN");\n', '        _;\n', '    }\n', '\n', '    modifier onlyFrozen()\n', '    {\n', '        require(stateFrozen, "STATE_NOT_FROZEN");\n', '        _;\n', '    }\n', '\n', '    function isFrozen()\n', '        external view\n', '        returns (bool frozen) {\n', '        frozen = stateFrozen;\n', '    }\n', '\n', '    function freeze()\n', '        internal\n', '        notFrozen()\n', '    {\n', '        // solium-disable-next-line security/no-block-members\n', '        unFreezeTime = now + UNFREEZE_DELAY;\n', '\n', '        // Update state.\n', '        stateFrozen = true;\n', '\n', '        // Log event.\n', '        emit LogFrozen();\n', '    }\n', '\n', '    function unFreeze()\n', '        external\n', '        onlyFrozen()\n', '        onlyGovernance()\n', '    {\n', '        // solium-disable-next-line security/no-block-members\n', '        require(now >= unFreezeTime, "UNFREEZE_NOT_ALLOWED_YET");  // NOLINT: timestamp.\n', '\n', '        // Update state.\n', '        stateFrozen = false;\n', '\n', '        // Increment roots to invalidate them, w/o losing information.\n', '        vaultRoot += 1;\n', '        orderRoot += 1;\n', '\n', '        // Log event.\n', '        emit LogUnFrozen();\n', '    }\n', '\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract LibConstants {\n', '    // Durations for time locked mechanisms (in seconds).\n', '    // Note that it is known that miners can manipulate block timestamps\n', '    // up to a deviation of a few seconds.\n', '    // This mechanism should not be used for fine grained timing.\n', '\n', '    // The time required to cancel a deposit, in the case the operator does not move the funds\n', '    // to the off-chain storage.\n', '    uint256 public constant DEPOSIT_CANCEL_DELAY = 1 days;\n', '\n', '    // The time required to freeze the exchange, in the case the operator does not execute a\n', '    // requested full withdrawal.\n', '    uint256 public constant FREEZE_GRACE_PERIOD = 7 days;\n', '\n', '    // The time after which the exchange may be unfrozen after it froze. This should be enough time\n', '    // for users to perform escape hatches to get back their funds.\n', '    uint256 public constant UNFREEZE_DELAY = 365 days;\n', '\n', '    // Maximal number of verifiers which may co-exist.\n', '    uint256 public constant MAX_VERIFIER_COUNT = uint256(64);\n', '\n', '    // The time required to remove a verifier in case of a verifier upgrade.\n', '    uint256 public constant VERIFIER_REMOVAL_DELAY = FREEZE_GRACE_PERIOD + (21 days);\n', '\n', '    uint256 constant MAX_VAULT_ID = 2**31 - 1;\n', '    uint256 constant MAX_QUANTUM = 2**128 - 1;\n', '\n', '    address constant ZERO_ADDRESS = address(0x0);\n', '\n', '    uint256 constant K_MODULUS =\n', '    0x800000000000011000000000000000000000000000000000000000000000001;\n', '    uint256 constant K_BETA =\n', '    0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;\n', '\n', '    uint256 constant EXPIRATION_TIMESTAMP_BITS = 22;\n', '\n', '    uint256 internal constant MASK_250 =\n', '    0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '    uint256 internal constant MASK_240 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '    uint256 internal constant MINTABLE_ASSET_ID_FLAG = 1<<250;\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "MStateRoot.sol";\n', 'import "MainStorage.sol";\n', '\n', 'contract StateRoot is MainStorage, MStateRoot\n', '{\n', '\n', '    function initialize (\n', '        uint256 initialSequenceNumber,\n', '        uint256 initialVaultRoot,\n', '        uint256 initialOrderRoot,\n', '        uint256 initialVaultTreeHeight,\n', '        uint256 initialOrderTreeHeight\n', '    )\n', '        internal\n', '    {\n', '        sequenceNumber = initialSequenceNumber;\n', '        vaultRoot = initialVaultRoot;\n', '        orderRoot = initialOrderRoot;\n', '        vaultTreeHeight = initialVaultTreeHeight;\n', '        orderTreeHeight = initialOrderTreeHeight;\n', '    }\n', '\n', '    function getVaultRoot()\n', '        public view\n', '        returns (uint256 root)\n', '    {\n', '        root = vaultRoot;\n', '    }\n', '\n', '    function getVaultTreeHeight()\n', '        public view\n', '        returns (uint256 height) {\n', '        height = vaultTreeHeight;\n', '    }\n', '\n', '    function getOrderRoot()\n', '        external view\n', '        returns (uint256 root)\n', '    {\n', '        root = orderRoot;\n', '    }\n', '\n', '    function getOrderTreeHeight()\n', '        external view\n', '        returns (uint256 height) {\n', '        height = orderTreeHeight;\n', '    }\n', '\n', '    function getSequenceNumber()\n', '        external view\n', '        returns (uint256 seq)\n', '    {\n', '        seq = sequenceNumber;\n', '    }\n', '\n', '    function getLastBatchId()\n', '        external view\n', '        returns (uint256 batchId)\n', '    {\n', '        batchId = lastBatchId;\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract MTokenQuantization {\n', '    function fromQuantized(uint256 presumedAssetType, uint256 quantizedAmount)\n', '        internal\n', '        view\n', '        returns (uint256 amount);\n', '\n', '    // NOLINTNEXTLINE: external-function.\n', '    function getQuantum(uint256 presumedAssetType)\n', '        public\n', '        view\n', '        returns (uint256 quantum);\n', '\n', '    function toQuantized(uint256 presumedAssetType, uint256 amount)\n', '        internal\n', '        view\n', '        returns (uint256 quantizedAmount);\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "Governance.sol";\n', '\n', '/**\n', '  The StarkEx contract is governed by one or more Governors of which the initial one is the\n', '  deployer of the contract.\n', '\n', '  A governor has the sole authority to perform the following operations:\n', '\n', '  1. Nominate additional governors (:sol:func:`mainNominateNewGovernor`)\n', '  2. Remove other governors (:sol:func:`mainRemoveGovernor`)\n', '  3. Add new :sol:mod:`Verifiers` and :sol:mod:`AvailabilityVerifiers`\n', '  4. Remove :sol:mod:`Verifiers` and :sol:mod:`AvailabilityVerifiers` after a timelock allows it\n', '  5. Nominate Operators (see :sol:mod:`Operator`) and Token Administrators (see :sol:mod:`Tokens`)\n', '\n', '  Adding governors is performed in a two step procedure:\n', '\n', '  1. First, an existing governor nominates a new governor (:sol:func:`mainNominateNewGovernor`)\n', '  2. Then, the new governor must accept governance to become a governor (:sol:func:`mainAcceptGovernance`)\n', '\n', '  This two step procedure ensures that a governor public key cannot be nominated unless there is an\n', '  entity that has the corresponding private key. This is intended to prevent errors in the addition\n', '  process.\n', '\n', '  The governor private key should typically be held in a secure cold wallet.\n', '*/\n', '/*\n', '  Implements Governance for the StarkDex main contract.\n', '  The wrapper methods (e.g. mainIsGovernor wrapping isGovernor) are needed to give\n', '  the method unique names.\n', '  Both Proxy and StarkExchange inherit from Governance. Thus, the logical contract method names\n', '  must have unique names in order for the proxy to successfully delegate to them.\n', '*/\n', 'contract MainGovernance is Governance {\n', '\n', '    // The tag is the sting key that is used in the Governance storage mapping.\n', '    string public constant MAIN_GOVERNANCE_INFO_TAG = "StarkEx.Main.2019.GovernorsInformation";\n', '\n', '    function getGovernanceTag()\n', '        internal\n', '        view\n', '        returns (string memory tag) {\n', '        tag = MAIN_GOVERNANCE_INFO_TAG;\n', '    }\n', '\n', '    function mainIsGovernor(address testGovernor) external view returns (bool) {\n', '        return isGovernor(testGovernor);\n', '    }\n', '\n', '    function mainNominateNewGovernor(address newGovernor) external {\n', '        nominateNewGovernor(newGovernor);\n', '    }\n', '\n', '    function mainRemoveGovernor(address governorForRemoval) external {\n', '        removeGovernor(governorForRemoval);\n', '    }\n', '\n', '    function mainAcceptGovernance()\n', '        external\n', '    {\n', '        acceptGovernance();\n', '    }\n', '\n', '    function mainCancelNomination() external {\n', '        cancelNomination();\n', '    }\n', '\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract MStateRoot {\n', '    function getVaultRoot() // NOLINT: external-function.\n', '        public view\n', '        returns (uint256 root);\n', '\n', '    function getVaultTreeHeight() // NOLINT: external-function.\n', '        public view\n', '        returns (uint256 height);\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "GovernanceStorage.sol";\n', '\n', '/*\n', '  Holds the Proxy-specific state variables.\n', '  This contract is inherited by the GovernanceStorage (and indirectly by MainStorage)\n', '  to prevent collision hazard.\n', '*/\n', 'contract ProxyStorage is GovernanceStorage {\n', '\n', '    // Stores the hash of the initialization vector of the added implementation.\n', '    // Upon upgradeTo the implementation, the initialization vector is verified\n', '    // to be identical to the one submitted when adding the implementation.\n', '    mapping (address => bytes32) internal initializationHash;\n', '\n', '    // The time after which we can switch to the implementation.\n', '    mapping (address => uint256) internal enabledTime;\n', '\n', '    // A central storage of the flags whether implementation has been initialized.\n', '    // Note - it can be used flexibly enough to accommodate multiple levels of initialization\n', '    // (i.e. using different key salting schemes for different initialization levels).\n', '    mapping (bytes32 => bool) internal initialized;\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "MainStorage.sol";\n', 'import "MKeyGetters.sol";\n', '\n', '/*\n', '  Implements MKeyGetters.\n', '*/\n', 'contract KeyGetters is MainStorage, MKeyGetters {\n', '    function getEthKey(uint256 starkKey) public view returns (address ethKey) {\n', "        // Fetch the user's Ethereum key.\n", '        ethKey = ethKeys[starkKey];\n', '        require(ethKey != address(0x0), "USER_UNREGISTERED");\n', '    }\n', '\n', '    function isMsgSenderStarkKeyOwner(uint256 starkKey) internal view returns (bool) {\n', '        return msg.sender == getEthKey(starkKey);\n', '    }\n', '\n', '    modifier isSenderStarkKey(uint256 starkKey) {\n', '        // Require the calling user to own the stark key.\n', '        require(isMsgSenderStarkKeyOwner(starkKey), "MISMATCHING_STARK_ETH_KEYS");\n', '        _;\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', '/*\n', '  Interface containing actions a verifier can invoke on the state.\n', '  The contract containing the state should implement these and verify correctness.\n', '*/\n', 'contract MAcceptModifications {\n', '\n', '    function acceptDeposit(\n', '        uint256 starkKey,\n', '        uint256 vaultId,\n', '        uint256 assetId,\n', '        uint256 quantizedAmount\n', '    )\n', '        internal;\n', '\n', '    function allowWithdrawal(\n', '        uint256 starkKey,\n', '        uint256 assetId,\n', '        uint256 quantizedAmount\n', '    )\n', '        internal;\n', '\n', '    function acceptWithdrawal(\n', '        uint256 starkKey,\n', '        uint256 assetId,\n', '        uint256 quantizedAmount\n', '    )\n', '        internal;\n', '\n', '    function clearFullWithdrawalRequest(\n', '        uint256 starkKey,\n', '        uint256 vaultId\n', '    )\n', '        internal;\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract MKeyGetters {\n', '    // NOLINTNEXTLINE: external-function.\n', '    function getEthKey(uint256 starkKey) public view returns (address ethKey);\n', '\n', '    function isMsgSenderStarkKeyOwner(uint256 starkKey) internal view returns (bool);\n', '\n', '    /*\n', '      Allows calling the function only if starkKey is registered to msg.sender.\n', '    */\n', '    modifier isSenderStarkKey(uint256 starkKey)\n', '    {\n', '        // Pure modifier declarations are not supported. Instead we provide\n', '        // a dummy definition.\n', '        revert("UNIMPLEMENTED");\n', '        _;\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract MFreezable {\n', '    /*\n', '      Forbids calling the function if the exchange is frozen.\n', '    */\n', '    modifier notFrozen()\n', '    {\n', '        // Pure modifier declarations are not supported. Instead we provide\n', '        // a dummy definition.\n', '        revert("UNIMPLEMENTED");\n', '        _;\n', '    }\n', '\n', '    /*\n', '      Allows calling the function only if the exchange is frozen.\n', '    */\n', '    modifier onlyFrozen()\n', '    {\n', '        // Pure modifier declarations are not supported. Instead we provide\n', '        // a dummy definition.\n', '        revert("UNIMPLEMENTED");\n', '        _;\n', '    }\n', '\n', '    /*\n', '      Freezes the exchange.\n', '    */\n', '    function freeze()\n', '        internal;\n', '\n', '    /*\n', '      Returns true if the exchange is frozen.\n', '    */\n', '    function isFrozen()\n', '        external view\n', '        returns (bool);\n', '\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "ApprovalChain.sol";\n', 'import "AvailabilityVerifiers.sol";\n', 'import "Freezable.sol";\n', 'import "MainGovernance.sol";\n', 'import "Verifiers.sol";\n', 'import "SubContractor.sol";\n', '\n', 'contract AllVerifiers is\n', '    SubContractor,\n', '    MainGovernance,\n', '    Freezable,\n', '    ApprovalChain,\n', '    AvailabilityVerifiers,\n', '    Verifiers\n', '{\n', '    function initialize(bytes calldata /* data */)\n', '        external {\n', '        revert("NOT_IMPLEMENTED");\n', '    }\n', '\n', '    function initializerSize()\n', '        external view\n', '        returns(uint256){\n', '        return 0;\n', '    }\n', '\n', '    function identify()\n', '        external pure\n', '        returns(string memory){\n', '        return "StarkWare_AllVerifiers_2020_1";\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "IFactRegistry.sol";\n', '\n', '/*\n', '  Extends the IFactRegistry interface with a query method that indicates\n', '  whether the fact registry has successfully registered any fact or is still empty of such facts.\n', '*/\n', 'contract IQueryableFactRegistry is IFactRegistry {\n', '\n', '    /*\n', '      Returns true if at least one fact has been registered.\n', '    */\n', '    function hasRegisteredFact()\n', '        external view\n', '        returns(bool);\n', '\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract MOperator {\n', '\n', '    modifier onlyOperator()\n', '    {\n', '        // Pure modifier declarations are not supported. Instead we provide\n', '        // a dummy definition.\n', '        revert("UNIMPLEMENTED");\n', '        _;\n', '    }\n', '\n', '    function registerOperator(address newOperator)\n', '        external;\n', '\n', '    function unregisterOperator(address removedOperator)\n', '        external;\n', '\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "LibConstants.sol";\n', 'import "MAcceptModifications.sol";\n', 'import "MTokenQuantization.sol";\n', 'import "MainStorage.sol";\n', '\n', '/*\n', '  Interface containing actions a verifier can invoke on the state.\n', '  The contract containing the state should implement these and verify correctness.\n', '*/\n', 'contract AcceptModifications is\n', '    MainStorage,\n', '    LibConstants,\n', '    MAcceptModifications,\n', '    MTokenQuantization\n', '{\n', '    event LogWithdrawalAllowed(\n', '        uint256 starkKey,\n', '        uint256 assetType,\n', '        uint256 nonQuantizedAmount,\n', '        uint256 quantizedAmount\n', '    );\n', '\n', '    event LogNftWithdrawalAllowed(uint256 starkKey, uint256 assetId);\n', '\n', '    event LogMintableWithdrawalAllowed(\n', '        uint256 starkKey,\n', '        uint256 assetId,\n', '        uint256 quantizedAmount\n', '    );\n', '\n', '    /*\n', '      Transfers funds from the on-chain deposit area to the off-chain area.\n', '      Implemented in the Deposits contracts.\n', '    */\n', '    function acceptDeposit(\n', '        uint256 starkKey,\n', '        uint256 vaultId,\n', '        uint256 assetId,\n', '        uint256 quantizedAmount\n', '    ) internal {\n', '        // Fetch deposit.\n', '        require(\n', '            pendingDeposits[starkKey][assetId][vaultId] >= quantizedAmount,\n', '            "DEPOSIT_INSUFFICIENT"\n', '        );\n', '\n', '        // Subtract accepted quantized amount.\n', '        pendingDeposits[starkKey][assetId][vaultId] -= quantizedAmount;\n', '    }\n', '\n', '    /*\n', '      Transfers funds from the off-chain area to the on-chain withdrawal area.\n', '    */\n', '    function allowWithdrawal(\n', '        uint256 starkKey,\n', '        uint256 assetId,\n', '        uint256 quantizedAmount\n', '    )\n', '        internal\n', '    {\n', '        // Fetch withdrawal.\n', '        uint256 withdrawal = pendingWithdrawals[starkKey][assetId];\n', '\n', '        // Add accepted quantized amount.\n', '        withdrawal += quantizedAmount;\n', '        require(withdrawal >= quantizedAmount, "WITHDRAWAL_OVERFLOW");\n', '\n', '        // Store withdrawal.\n', '        pendingWithdrawals[starkKey][assetId] = withdrawal;\n', '\n', '        // Log event.\n', '        uint256 presumedAssetType = assetId;\n', '        if (registeredAssetType[presumedAssetType]) {\n', '            emit LogWithdrawalAllowed(\n', '                starkKey,\n', '                presumedAssetType,\n', '                fromQuantized(presumedAssetType, quantizedAmount),\n', '                quantizedAmount\n', '            );\n', '        } else if(assetId == ((assetId & MASK_240) | MINTABLE_ASSET_ID_FLAG)) {\n', '            emit LogMintableWithdrawalAllowed(\n', '                starkKey,\n', '                assetId,\n', '                quantizedAmount\n', '            );\n', '        }\n', '        else {\n', '            // In ERC721 case, assetId is not the assetType.\n', '            require(withdrawal <= 1, "INVALID_NFT_AMOUNT");\n', '            emit LogNftWithdrawalAllowed(starkKey, assetId);\n', '        }\n', '    }\n', '\n', '\n', '    // Verifier authorizes withdrawal.\n', '    function acceptWithdrawal(\n', '        uint256 starkKey,\n', '        uint256 assetId,\n', '        uint256 quantizedAmount\n', '    ) internal {\n', '        allowWithdrawal(starkKey, assetId, quantizedAmount);\n', '    }\n', '\n', '    /*\n', '      Implemented in the FullWithdrawal contracts.\n', '    */\n', '    function clearFullWithdrawalRequest(\n', '        uint256 starkKey,\n', '        uint256 vaultId\n', '    )\n', '        internal\n', '    {\n', '        // Reset escape request.\n', '        fullWithdrawalRequests[starkKey][vaultId] = 0;  // NOLINT: reentrancy-benign.\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "MAcceptModifications.sol";\n', 'import "VerifyFactChain.sol";\n', 'import "IFactRegistry.sol";\n', 'import "MFreezable.sol";\n', 'import "MOperator.sol";\n', 'import "LibConstants.sol";\n', 'import "PublicInputOffsets.sol";\n', 'import "AllVerifiers.sol";\n', '\n', '/**\n', '  The StarkEx contract tracks the state of the off-chain exchange service by storing Merkle roots\n', '  of the vault state (off-chain account state) and the order state (including fully executed and\n', '  partially fulfilled orders).\n', '\n', '  The :sol:mod:`Operator` is the only entity entitled to submit state updates for a batch of\n', '  exchange transactions by calling :sol:func:`updateState` and this is only allowed if the contract\n', '  is not in the `frozen` state (see :sol:mod:`FullWithdrawals`). The call includes the `publicInput`\n', '  of a STARK proof, and additional data (`applicationData`) that includes information not attested\n', '  to by the proof.\n', '\n', '  The `publicInput` includes the current (initial) and next (final) Merkle roots as mentioned above,\n', '  the heights of the Merkle trees, a list of vault operations and a list of conditional transfers.\n', '\n', '  A vault operation can be a ramping operation (deposit/withdrawal) or an indication to clear\n', '  a full withdrawal request. Each vault operation is encoded in 3 words as follows:\n', '  | 1. Word 0: Stark Key of the vault owner (or the requestor Stark Key for false full\n', '  |    withdrawal).\n', '  | 2. Word 1: Asset ID of the vault representing either the currency (for fungible tokens) or\n', '  |    a unique token ID and its on-chain contract association (for non-fungible tokens).\n', '  | 3. Word 2:\n', '  |    a. ID of the vault (off-chain account)\n', '  |    b. Vault balance change in biased representation (excess-2**63).\n', '  |       A negative balance change implies a withdrawal while a positive amount implies a deposit.\n', '  |       A zero balance change may be used for operations implying neither\n', '  |       (e.g. a false full withdrawal request).\n', '  |    c. A bit indicating whether the operation requires clearing a full withdrawal request.\n', '\n', '  The above information is used by the exchange contract in order to update the pending accounts\n', '  used for deposits (see :sol:mod:`Deposits`) and withdrawals (see :sol:mod:`Withdrawals`).\n', '\n', '  The next section in the publicInput is a list of encoded conditions corresponding to the\n', '  conditional transfers in the batch. A condition is encoded as a hash of the conditional transfer\n', '  `applicationData`, described below, masked to 250 bits.\n', '\n', '  The `applicationData` holds the following information:\n', '  | 1. The ID of the current batch for which the operator is submitting the update. \n', '  | 2. The expected ID of the last batch accepted on chain. This allows the operator submitting\n', '  |    state updates to ensure the same batch order is accepted on-chain as was intended by the\n', '  |    operator in the event that more than one valid update may have been generated based on\n', '  |    different previous batches - an unlikely but possible event.\n', '  | 3. For each conditional transfer in the batch two words are provided:\n', '  |    a. Word 0: The address of a fact registry contract\n', '  |    b. Word 1: A fact to be verified on the above contract attesting that the\n', '  |       condition has been met on-chain.\n', '\n', '  The STARK proof attesting to the validity of the state update is submitted separately by the\n', '  exchange service to (one or more) STARK integrity verifier contract(s).\n', '  Likewise, the signatures of committee members attesting to\n', '  the availability of the vault and order data is submitted separately by the exchange service to\n', '  (one or more) availability verifier contract(s) (see :sol:mod:`Committee`).\n', '\n', '  The state update is only accepted by the exchange contract if the integrity verifier and\n', '  availability verifier contracts have indeed received such proof of soundness and data\n', '  availability.\n', '*/\n', 'contract UpdateState is\n', '    MainStorage,\n', '    LibConstants,\n', '    VerifyFactChain,\n', '    MAcceptModifications,\n', '    MFreezable,\n', '    MOperator,\n', '    PublicInputOffsets\n', '{\n', '\n', '    event LogRootUpdate(\n', '        uint256 sequenceNumber,\n', '        uint256 batchId,\n', '        uint256 vaultRoot,\n', '        uint256 orderRoot\n', '    );\n', '\n', '    function updateState(\n', '        uint256[] calldata publicInput,\n', '        uint256[] calldata applicationData\n', '    )\n', '        external\n', '        notFrozen()\n', '        onlyOperator()\n', '    {\n', '        require(\n', '            publicInput.length >= PUB_IN_TRANSACTIONS_DATA_OFFSET,\n', '            "publicInput does not contain all required fields.");\n', '        require(\n', '            publicInput[PUB_IN_FINAL_VAULT_ROOT_OFFSET] < K_MODULUS,\n', '            "New vault root >= PRIME.");\n', '        require(\n', '            publicInput[PUB_IN_FINAL_ORDER_ROOT_OFFSET] < K_MODULUS,\n', '            "New order root >= PRIME.");\n', '        require(\n', '            lastBatchId == 0 ||\n', '            applicationData[APP_DATA_PREVIOUS_BATCH_ID_OFFSET] == lastBatchId,\n', '            "WRONG_PREVIOUS_BATCH_ID");\n', '\n', '        // Ensure global timestamp has not expired.\n', '        require(\n', '            publicInput[PUB_IN_GLOBAL_EXPIRATION_TIMESTAMP_OFFSET] < 2**EXPIRATION_TIMESTAMP_BITS,\n', '            "Global expiration timestamp is out of range.");\n', '\n', '        require( // NOLINT: block-timestamp.\n', '            // solium-disable-next-line security/no-block-members\n', '            publicInput[PUB_IN_GLOBAL_EXPIRATION_TIMESTAMP_OFFSET] > now / 3600,\n', '            "Timestamp of the current block passed the threshold for the transaction batch.");\n', '\n', '        bytes32 publicInputFact = keccak256(abi.encodePacked(publicInput));\n', '\n', '        verifyFact(\n', '            verifiersChain,\n', '            publicInputFact,\n', '            "NO_STATE_TRANSITION_VERIFIERS",\n', '            "NO_STATE_TRANSITION_PROOF");\n', '\n', '        bytes32 availabilityFact = keccak256(\n', '            abi.encodePacked(\n', '            publicInput[PUB_IN_FINAL_VAULT_ROOT_OFFSET],\n', '            publicInput[PUB_IN_VAULT_TREE_HEIGHT_OFFSET],\n', '            publicInput[PUB_IN_FINAL_ORDER_ROOT_OFFSET],\n', '            publicInput[PUB_IN_ORDER_TREE_HEIGHT_OFFSET],\n', '            sequenceNumber + 1));\n', '\n', '        verifyFact(\n', '            availabilityVerifiersChain,\n', '            availabilityFact,\n', '            "NO_AVAILABILITY_VERIFIERS",\n', '            "NO_AVAILABILITY_PROOF");\n', '\n', '        performUpdateState(publicInput, applicationData);\n', '    }\n', '\n', '    function performUpdateState(\n', '        uint256[] memory publicInput,\n', '        uint256[] memory applicationData\n', '    )\n', '        internal\n', '    {\n', '        rootUpdate(\n', '            publicInput[PUB_IN_INITIAL_VAULT_ROOT_OFFSET],\n', '            publicInput[PUB_IN_FINAL_VAULT_ROOT_OFFSET],\n', '            publicInput[PUB_IN_INITIAL_ORDER_ROOT_OFFSET],\n', '            publicInput[PUB_IN_FINAL_ORDER_ROOT_OFFSET],\n', '            publicInput[PUB_IN_VAULT_TREE_HEIGHT_OFFSET],\n', '            publicInput[PUB_IN_ORDER_TREE_HEIGHT_OFFSET],\n', '            applicationData[APP_DATA_BATCH_ID_OFFSET]\n', '        );\n', '        sendModifications(publicInput, applicationData);\n', '    }\n', '\n', '    function rootUpdate(\n', '        uint256 oldVaultRoot,\n', '        uint256 newVaultRoot,\n', '        uint256 oldOrderRoot,\n', '        uint256 newOrderRoot,\n', '        uint256 vaultTreeHeightSent,\n', '        uint256 orderTreeHeightSent,\n', '        uint256 batchId\n', '    )\n', '        internal\n', '        notFrozen()\n', '    {\n', '        // Assert that the old state is correct.\n', '        require(oldVaultRoot == vaultRoot, "VAULT_ROOT_INCORRECT");\n', '        require(oldOrderRoot == orderRoot, "ORDER_ROOT_INCORRECT");\n', '\n', '        // Assert that heights are correct.\n', '        require(vaultTreeHeight == vaultTreeHeightSent, "VAULT_HEIGHT_INCORRECT");\n', '        require(orderTreeHeight == orderTreeHeightSent, "ORDER_HEIGHT_INCORRECT");\n', '\n', '        // Update state.\n', '        vaultRoot = newVaultRoot;\n', '        orderRoot = newOrderRoot;\n', '        sequenceNumber = sequenceNumber + 1;\n', '        lastBatchId = batchId;\n', '\n', '        // Log update.\n', '        emit LogRootUpdate(sequenceNumber, batchId, vaultRoot, orderRoot);\n', '    }\n', '\n', '    function sendModifications(\n', '        uint256[] memory publicInput,\n', '        uint256[] memory applicationData\n', '    ) private {\n', '        uint256 nModifications = publicInput[PUB_IN_N_MODIFICATIONS_OFFSET];\n', '        uint256 nCondTransfers = publicInput[PUB_IN_N_CONDITIONAL_TRANSFERS_OFFSET];\n', '\n', '        // Sanity value that also protects from theoretical overflow in multiplication.\n', '        require(nModifications < 2**64, "Invalid number of modifications.");\n', '        require(nCondTransfers < 2**64, "Invalid number of conditional transfers.");\n', '        require(\n', '            publicInput.length == PUB_IN_TRANSACTIONS_DATA_OFFSET +\n', '                                  PUB_IN_N_WORDS_PER_MODIFICATION * nModifications +\n', '                                  PUB_IN_N_WORDS_PER_CONDITIONAL_TRANSFER * nCondTransfers,\n', '            "publicInput size is inconsistent with expected transactions.");\n', '        require(\n', '            applicationData.length == APP_DATA_TRANSACTIONS_DATA_OFFSET +\n', '                                      APP_DATA_N_WORDS_PER_CONDITIONAL_TRANSFER * nCondTransfers,\n', '            "applicationData size is inconsistent with expected transactions.");\n', '\n', '        uint256 offsetPubInput = PUB_IN_TRANSACTIONS_DATA_OFFSET;\n', '        uint256 offsetAppData = APP_DATA_TRANSACTIONS_DATA_OFFSET;\n', '\n', '        for (uint256 i = 0; i < nModifications; i++) {\n', '            uint256 starkKey = publicInput[offsetPubInput];\n', '            uint256 assetId = publicInput[offsetPubInput + 1];\n', '\n', '            require(starkKey < K_MODULUS, "Stark key >= PRIME");\n', '            require(assetId < K_MODULUS, "Asset id >= PRIME");\n', '\n', '            uint256 actionParams = publicInput[offsetPubInput + 2];\n', '            require ((actionParams >> 96) == 0, "Unsupported modification action field.");\n', '\n', '            // Extract and unbias the balance_diff.\n', '            int256 balance_diff = int256((actionParams & ((1 << 64) - 1)) - (1 << 63));\n', '            uint256 vaultId = (actionParams >> 64) & ((1 << 31) - 1);\n', '\n', '            if (balance_diff > 0) {\n', '                // This is a deposit.\n', '                acceptDeposit(starkKey, vaultId, assetId, uint256(balance_diff));\n', '            } else if (balance_diff < 0) {\n', '                // This is a withdrawal.\n', '                acceptWithdrawal(starkKey, assetId, uint256(-balance_diff));\n', '            }\n', '\n', '            if ((actionParams & (1 << 95)) != 0) {\n', '                clearFullWithdrawalRequest(starkKey, vaultId);\n', '            }\n', '\n', '            offsetPubInput += PUB_IN_N_WORDS_PER_MODIFICATION;\n', '        }\n', '\n', '        // Conditional Transfers appear after all other modifications.\n', '        for (uint256 i = 0; i < nCondTransfers; i++) {\n', '            address factRegistryAddress = address(applicationData[offsetAppData]);\n', '            bytes32 condTransferFact = bytes32(applicationData[offsetAppData + 1]);\n', '            uint256 condition = publicInput[offsetPubInput];\n', '\n', '            // The condition is the 250 LS bits of keccak256 of the fact registry & fact.\n', '            require(\n', '                condition ==\n', '                    uint256(keccak256(abi.encodePacked(factRegistryAddress, condTransferFact))) &\n', '                    MASK_250,\n', '                "Condition mismatch.");\n', '            (bool success, bytes memory returndata) = // NOLINT: low-level-calls-loop.\n', '            factRegistryAddress.staticcall(\n', '                abi.encodeWithSignature("isValid(bytes32)",condTransferFact));\n', '            require(success && returndata.length == 32, "BAD_FACT_REGISTRY_CONTRACT");\n', '            require(\n', '                abi.decode(returndata, (bool)),\n', '                "Condition for the conditional transfer was not met.");\n', '\n', '            offsetPubInput += PUB_IN_N_WORDS_PER_CONDITIONAL_TRANSFER;\n', '            offsetAppData += APP_DATA_N_WORDS_PER_CONDITIONAL_TRANSFER;\n', '        }\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "MApprovalChain.sol";\n', 'import "LibConstants.sol";\n', 'import "MainStorage.sol";\n', '\n', '/**\n', '  A Verifier contract is an implementation of a STARK verifier that the exchange service sends\n', '  STARK proofs to. In addition, the exchange contract can call a verifier to check if a valid proof\n', '  has been accepted for a given state transition (typically described as a hash on the public input\n', '  of the assumed proof).\n', '\n', '  The exchange contract will normally query only one verifier contract for proof validity checks.\n', '  However, in the event that the verifier algorithm needs to updated, additional verifiers may be\n', '  registered with the exchange contract by the contract :sol:mod:`MainGovernance`. Such new\n', '  verifiers are then also be required to attest to the validity of state transitions and only if all\n', '  the verifiers attest to the validity the state transition is accepted.\n', '\n', '  Removal of verifiers is also the responsibility of the :sol:mod:`MainGovernance`. The removal\n', '  process is more sensitive than verifier registration as it may affect the soundness of the system.\n', '  Hence, this is performed in two steps:\n', '\n', '  1. The :sol:mod:`MainGovernance` first announces the intent to remove a verifier by calling :sol:func:`announceVerifierRemovalIntent`\n', '  2. After the expiration of a `VERIFIER_REMOVAL_DELAY` time lock, actual removal may be performed by calling :sol:func:`removeVerifier`\n', '\n', '  The removal delay ensures that a user concerned about the soundness of the system has ample time\n', '  to leave the exchange.\n', '*/\n', 'contract Verifiers is MainStorage, LibConstants, MApprovalChain {\n', '    function getRegisteredVerifiers()\n', '        external view\n', '        returns (address[] memory _verifers)\n', '    {\n', '        return verifiersChain.list;\n', '    }\n', '\n', '    function isVerifier(address verifierAddress)\n', '        external view\n', '        returns (bool)\n', '    {\n', '        return findEntry(verifiersChain.list, verifierAddress) != ENTRY_NOT_FOUND;\n', '    }\n', '\n', '    function registerVerifier(address verifier, string calldata identifier)\n', '        external\n', '    {\n', '        addEntry(verifiersChain, verifier, MAX_VERIFIER_COUNT, identifier);\n', '    }\n', '\n', '    function announceVerifierRemovalIntent(address verifier)\n', '        external\n', '    {\n', '        announceRemovalIntent(verifiersChain, verifier, VERIFIER_REMOVAL_DELAY);\n', '    }\n', '\n', '    function removeVerifier(address verifier)\n', '        external\n', '    {\n', '        removeEntry(verifiersChain, verifier);\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', '/*\n', '  Common Utility librarries.\n', '  I. Addresses (extending address).\n', '*/\n', 'library Addresses {\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            size := extcodesize(account)\n', '        }\n', '        return size > 0;\n', '    }\n', '\n', '    function performEthTransfer(address recipient, uint256 amount) internal {\n', '        // solium-disable-next-line security/no-call-value\n', '        (bool success, ) = recipient.call.value(amount)(""); // NOLINT: low-level-calls.\n', '        require(success, "ETH_TRANSFER_FAILED");\n', '    }\n', '\n', '    /*\n', '      Safe wrapper around ERC20/ERC721 calls.\n', "      This is required because many deployed ERC20 contracts don't return a value.\n", '      See https://github.com/ethereum/solidity/issues/4116.\n', '    */\n', '    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\n', '        require(isContract(tokenAddress), "BAD_TOKEN_ADDRESS");\n', '        // solium-disable-next-line security/no-low-level-calls\n', '        // NOLINTNEXTLINE: low-level-calls.\n', '        (bool success, bytes memory returndata) = address(tokenAddress).call(callData);\n', '        require(success, string(returndata));\n', '\n', '        if (returndata.length > 0) {\n', '            require(abi.decode(returndata, (bool)), "TOKEN_OPERATION_FAILED");\n', '        }\n', '    }\n', '}\n', '\n', '/*\n', '  II. StarkExTypes - Common data types.\n', '*/\n', 'library StarkExTypes {\n', '\n', '    // Structure representing a list of verifiers (validity/availability).\n', '    // A statement is valid only if all the verifiers in the list agree on it.\n', '    // Adding a verifier to the list is immediate - this is used for fast resolution of\n', '    // any soundness issues.\n', '    // Removing from the list is time-locked, to ensure that any user of the system\n', '    // not content with the announced removal has ample time to leave the system before it is\n', '    // removed.\n', '    struct ApprovalChainData {\n', '        address[] list;\n', '        // Represents the time after which the verifier with the given address can be removed.\n', '        // Removal of the verifier with address A is allowed only in the case the value\n', '        // of unlockedForRemovalTime[A] != 0 and unlockedForRemovalTime[A] < (current time).\n', '        mapping (address => uint256) unlockedForRemovalTime;\n', '    }\n', '\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', '/*\n', '  The Fact Registry design pattern is a way to separate cryptographic verification from the\n', '  business logic of the contract flow.\n', '\n', '  A fact registry holds a hash table of verified "facts" which are represented by a hash of claims\n', '  that the registry hash check and found valid. This table may be queried by accessing the\n', '  isValid() function of the registry with a given hash.\n', '\n', '  In addition, each fact registry exposes a registry specific function for submitting new claims\n', '  together with their proofs. The information submitted varies from one registry to the other\n', '  depending of the type of fact requiring verification.\n', '\n', '  For further reading on the Fact Registry design pattern see this\n', '  `StarkWare blog post <https://medium.com/starkware/the-fact-registry-a64aafb598b6>`_.\n', '*/\n', 'contract IFactRegistry {\n', '    /*\n', '      Returns true if the given fact was previously registered in the contract.\n', '    */\n', '    function isValid(bytes32 fact)\n', '        external view\n', '        returns(bool);\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract Identity {\n', '\n', '    /*\n', '      Allows a caller, typically another contract,\n', '      to ensure that the provided address is of the expected type and version.\n', '    */\n', '    function identify()\n', '        external pure\n', '        returns(string memory);\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "MainStorage.sol";\n', 'import "MTokenQuantization.sol";\n', '\n', '\n', 'contract TokenQuantization is MainStorage, MTokenQuantization {\n', '\n', '    function fromQuantized(uint256 presumedAssetType, uint256 quantizedAmount)\n', '        internal view returns (uint256 amount) {\n', '        uint256 quantum = getQuantum(presumedAssetType);\n', '        amount = quantizedAmount * quantum;\n', '        require(amount / quantum == quantizedAmount, "DEQUANTIZATION_OVERFLOW");\n', '    }\n', '\n', '    function getQuantum(uint256 presumedAssetType) public view returns (uint256 quantum) {\n', '        if (!registeredAssetType[presumedAssetType]) {\n', '            // Default quantization, for NFTs etc.\n', '            quantum = 1;\n', '        } else {\n', '            // Retrieve registration.\n', '            quantum = assetTypeToQuantum[presumedAssetType];\n', '        }\n', '    }\n', '\n', '    function toQuantized(uint256 presumedAssetType, uint256 amount)\n', '        internal view returns (uint256 quantizedAmount) {\n', '        uint256 quantum = getQuantum(presumedAssetType);\n', '        require(amount % quantum == 0, "INVALID_AMOUNT");\n', '        quantizedAmount = amount / quantum;\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "Common.sol";\n', '\n', '/*\n', '  Implements a data structure that supports instant registration\n', '  and slow time-locked removal of entries.\n', '*/\n', 'contract MApprovalChain {\n', '    uint256 constant ENTRY_NOT_FOUND = uint256(~0);\n', '\n', '    /*\n', '      Adds the given verifier (entry) to the chain.\n', '      Fails if the size of the chain is already >= maxLength.\n', '      Fails if identifier is not identical to the value returned from entry.identify().\n', '    */\n', '    function addEntry(\n', '        StarkExTypes.ApprovalChainData storage chain,\n', '        address entry, uint256 maxLength, string memory identifier)\n', '        internal;\n', '\n', '    /*\n', '      Returns the index of the verifier in the list if it exists and returns ENTRY_NOT_FOUND\n', '      otherwise.\n', '    */\n', '    function findEntry(address[] storage list, address entry)\n', '        internal view returns (uint256);\n', '\n', '    /*\n', '      Same as findEntry(), except that it reverts if the verifier is not found.\n', '    */\n', '    function safeFindEntry(address[] storage list, address entry)\n', '        internal view returns (uint256 idx);\n', '\n', '    /*\n', '      Updates the unlockedForRemovalTime field of the given verifier to\n', '        current time + removalDelay.\n', '      Reverts if the verifier is not found.\n', '    */\n', '    function announceRemovalIntent(\n', '        StarkExTypes.ApprovalChainData storage chain, address entry, uint256 removalDelay)\n', '        internal;\n', '\n', '    /*\n', '      Removes a verifier assuming the expected time has passed.\n', '    */\n', '    function removeEntry(StarkExTypes.ApprovalChainData storage chain, address entry)\n', '        internal;\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', '/*\n', '  Holds the governance slots for ALL entities, including proxy and the main contract.\n', '*/\n', 'contract GovernanceStorage {\n', '\n', '    struct GovernanceInfoStruct {\n', '        mapping (address => bool) effectiveGovernors;\n', '        address candidateGovernor;\n', '        bool initialized;\n', '    }\n', '\n', '    // A map from a Governor tag to its own GovernanceInfoStruct.\n', '    mapping (string => GovernanceInfoStruct) internal governanceInfo;\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "MOperator.sol";\n', 'import "MGovernance.sol";\n', 'import "MainStorage.sol";\n', '\n', '/**\n', '  The Operator of the contract is the entity entitled to submit state update requests\n', '  by calling :sol:func:`updateState`.\n', '\n', '  An Operator may be instantly appointed or removed by the contract Governor\n', '  (see :sol:mod:`MainGovernance`). Typically, the Operator is the hot wallet of the StarkEx service\n', '  submitting proofs for state updates.\n', '*/\n', 'contract Operator is MainStorage, MGovernance, MOperator {\n', '    event LogOperatorAdded(address operator);\n', '    event LogOperatorRemoved(address operator);\n', '\n', '    function initialize()\n', '        internal\n', '    {\n', '        operators[msg.sender] = true;\n', '        emit LogOperatorAdded(msg.sender);\n', '    }\n', '\n', '    modifier onlyOperator()\n', '    {\n', '        require(operators[msg.sender], "ONLY_OPERATOR");\n', '        _;\n', '    }\n', '\n', '    function registerOperator(address newOperator)\n', '        external\n', '        onlyGovernance\n', '    {\n', '        operators[newOperator] = true;\n', '        emit LogOperatorAdded(newOperator);\n', '    }\n', '\n', '    function unregisterOperator(address removedOperator)\n', '        external\n', '        onlyGovernance\n', '    {\n', '        operators[removedOperator] = false;\n', '        emit LogOperatorRemoved(removedOperator);\n', '    }\n', '\n', '    function isOperator(address testedOperator) external view returns (bool) {\n', '        return operators[testedOperator];\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "MainStorage.sol";\n', 'import "IFactRegistry.sol";\n', 'import "Common.sol";\n', '\n', 'contract VerifyFactChain is MainStorage {\n', '\n', '    function verifyFact(\n', '        StarkExTypes.ApprovalChainData storage chain, bytes32 fact, string memory noVerifiersErrorMessage,\n', '        string memory invalidFactErrorMessage)\n', '        internal view\n', '    {\n', '        address[] storage list = chain.list;\n', '        uint256 n_entries = list.length;\n', '        require(n_entries > 0, noVerifiersErrorMessage);\n', '        for (uint256 i = 0; i < n_entries; i++) {\n', '            // NOLINTNEXTLINE: calls-loop.\n', '            require(IFactRegistry(list[i]).isValid(fact), invalidFactErrorMessage);\n', '        }\n', '    }\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "IFactRegistry.sol";\n', 'import "ProxyStorage.sol";\n', 'import "Common.sol";\n', '/*\n', '  Holds ALL the main contract state (storage) variables.\n', '*/\n', 'contract MainStorage is ProxyStorage {\n', '\n', '    IFactRegistry escapeVerifier_;\n', '\n', '    // Global dex-frozen flag.\n', '    bool stateFrozen;                               // NOLINT: constable-states.\n', '\n', '    // Time when unFreeze can be successfully called (UNFREEZE_DELAY after freeze).\n', '    uint256 unFreezeTime;                           // NOLINT: constable-states.\n', '\n', '    // Pending deposits.\n', '    // A map STARK key => asset id => vault id => quantized amount.\n', '    mapping (uint256 => mapping (uint256 => mapping (uint256 => uint256))) pendingDeposits;\n', '\n', '    // Cancellation requests.\n', '    // A map STARK key => asset id => vault id => request timestamp.\n', '    mapping (uint256 => mapping (uint256 => mapping (uint256 => uint256))) cancellationRequests;\n', '\n', '    // Pending withdrawals.\n', '    // A map STARK key => asset id => quantized amount.\n', '    mapping (uint256 => mapping (uint256 => uint256)) pendingWithdrawals;\n', '\n', '    // vault_id => escape used boolean.\n', '    mapping (uint256 => bool) escapesUsed;\n', '\n', '    // Number of escapes that were performed when frozen.\n', '    uint256 escapesUsedCount;                       // NOLINT: constable-states.\n', '\n', '    // Full withdrawal requests: stark key => vaultId => requestTime.\n', '    // stark key => vaultId => requestTime.\n', '    mapping (uint256 => mapping (uint256 => uint256)) fullWithdrawalRequests;\n', '\n', '    // State sequence number.\n', '    uint256 sequenceNumber;                         // NOLINT: constable-states uninitialized-state.\n', '\n', '    // Vaults Tree Root & Height.\n', '    uint256 vaultRoot;                              // NOLINT: constable-states uninitialized-state.\n', '    uint256 vaultTreeHeight;                        // NOLINT: constable-states uninitialized-state.\n', '\n', '    // Order Tree Root & Height.\n', '    uint256 orderRoot;                              // NOLINT: constable-states uninitialized-state.\n', '    uint256 orderTreeHeight;                        // NOLINT: constable-states uninitialized-state.\n', '\n', '    // True if and only if the address is allowed to add tokens.\n', '    mapping (address => bool) tokenAdmins;\n', '\n', '    // True if and only if the address is allowed to register users.\n', '    mapping (address => bool) userAdmins;\n', '\n', '    // True if and only if the address is an operator (allowed to update state).\n', '    mapping (address => bool) operators;\n', '\n', '    // Mapping of contract ID to asset data.\n', '    mapping (uint256 => bytes) assetTypeToAssetInfo;    // NOLINT: uninitialized-state.\n', '\n', '    // Mapping of registered contract IDs.\n', '    mapping (uint256 => bool) registeredAssetType;      // NOLINT: uninitialized-state.\n', '\n', '    // Mapping from contract ID to quantum.\n', '    mapping (uint256 => uint256) assetTypeToQuantum;    // NOLINT: uninitialized-state.\n', '\n', '    // This mapping is no longer in use, remains for backwards compatibility.\n', '    mapping (address => uint256) starkKeys_DEPRECATED;  // NOLINT: naming-convention.\n', '\n', '    // Mapping from STARK public key to the Ethereum public key of its owner.\n', '    mapping (uint256 => address) ethKeys;               // NOLINT: uninitialized-state.\n', '\n', '    // Timelocked state transition and availability verification chain.\n', '    StarkExTypes.ApprovalChainData verifiersChain;\n', '    StarkExTypes.ApprovalChainData availabilityVerifiersChain;\n', '\n', '    // Batch id of last accepted proof.\n', '    uint256 lastBatchId;                            // NOLINT: constable-states uninitialized-state.\n', '\n', '    // Mapping between sub-contract index to sub-contract address.\n', '    mapping(uint256 => address) subContracts;       // NOLINT: uninitialized-state.\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "Identity.sol";\n', '\n', 'contract SubContractor is Identity {\n', '\n', '    function initialize(bytes calldata data)\n', '        external;\n', '\n', '    function initializerSize()\n', '        external view\n', '        returns(uint256);\n', '\n', '}\n']
['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', 'pragma solidity ^0.5.2;\n', '\n', 'import "LibConstants.sol";\n', 'import "MAcceptModifications.sol";\n', 'import "MFreezable.sol";\n', 'import "IFactRegistry.sol";\n', 'import "MStateRoot.sol";\n', 'import "MainStorage.sol";\n', '\n', '/**\n', '  Escaping the exchange is the last resort for users that wish to withdraw their funds without\n', '  relying on off-chain exchange services. The Escape functionality may only be invoked once the\n', '  contract has become frozen. This will be as the result of an unserviced full withdraw request\n', '  (see :sol:mod:`FullWithdrawals`). At that point, any escaper entity may perform an escape\n', '  operation as follows:\n', '\n', '  1. Escapers must obtain a Merkle path of a vault to be evicted with respect to the frozen vault tree root. Typically, once the exchange is frozen, such data will be made public or would be obtainable from an exchange API, depending on the data availability approach used by the exchange.\n', '  2. Escapers call the :sol:mod:`EscapeVerifier` contract with the Merkle proof for the vault to be evicted. If the proof is valid, this results in the registration of such proof.\n', '  3. Escapers call :sol:func:`escape` function with the same parameters as submitted to the :sol:mod:`EscapeVerifier` (i.e. the vault ID, Stark Key of the vault owner, the asset ID and the vault balance), sans the Merkle proof. If a proof was accepted for the same parameters by the :sol:mod:`EscapeVerifier`, and no prior escape call was made for the vault, the contract adds the vault balance to an on-chain pending withdrawals account under the Stark Key of the vault owner and the appropriate asset ID.\n', '  4. The owner of the vault may then withdraw this amount from the pending withdrawals account by calling the normal withdraw function (see :sol:mod:`Withdrawals`) to transfer the funds to the users Eth or ERC20 account (depending on the token type).\n', '\n', '  Note that while anyone can perform the initial steps of the escape operation (including the\n', '  exchange operator, for example), only the owner of the vault may perform the final step of\n', '  transferring the funds.\n', '*/\n', 'contract Escapes is MainStorage, MAcceptModifications, MFreezable, MStateRoot {\n', '    function initialize (\n', '        IFactRegistry escapeVerifier\n', '    ) internal\n', '    {\n', '        escapeVerifier_ = escapeVerifier;\n', '    }\n', '    /*\n', '      Escape when the contract is frozen.\n', '    */\n', '    function escape(\n', '        uint256 starkKey,\n', '        uint256 vaultId,\n', '        uint256 assetId,\n', '        uint256 quantizedAmount\n', '    )\n', '        external\n', '        onlyFrozen()\n', '    {\n', '        require(!escapesUsed[vaultId], "ESCAPE_ALREADY_USED");\n', '\n', '        // Escape can be used only once.\n', '        escapesUsed[vaultId] = true;\n', '        escapesUsedCount += 1;\n', '\n', '        bytes32 claimHash = keccak256(\n', '            abi.encode(\n', '        starkKey, assetId, quantizedAmount, getVaultRoot(), getVaultTreeHeight(), vaultId));\n', '        require(escapeVerifier_.isValid(claimHash), "ESCAPE_LACKS_PROOF");\n', '\n', '        allowWithdrawal(starkKey, assetId, quantizedAmount);\n', '    }\n', '}\n']
