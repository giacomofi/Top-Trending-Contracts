['pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'interface TradeBotCommanderV2Interface {\n', '    // events\n', '    event AddedAccount(address account);\n', '    event RemovedAccount(address account);\n', '    event Call(address target, uint256 amount, bytes data, bool ok, bytes returnData);\n', '    \n', '    // callable by accounts\n', '    function processLimitOrder(\n', '        DharmaTradeBotV1Interface.LimitOrderArguments calldata args,\n', '        DharmaTradeBotV1Interface.LimitOrderExecutionArguments calldata executionArgs\n', '    ) external returns (bool ok, uint256 amountReceived);\n', '\n', '    function deployAndProcessLimitOrder(\n', '        address initialSigningKey, // the initial key on the keyring\n', '        address keyRing,\n', '        DharmaTradeBotV1Interface.LimitOrderArguments calldata args,\n', '        DharmaTradeBotV1Interface.LimitOrderExecutionArguments calldata executionArgs\n', '    ) external returns (bool ok, bytes memory returnData);\n', '\n', '    // only callable by owner\n', '    function addAccount(address account) external;\n', '    function removeAccount(address account) external;\n', '    function callAny(\n', '        address payable target, uint256 amount, bytes calldata data\n', '    ) external returns (bool ok, bytes memory returnData);\n', '\n', '    // view functions\n', '    function getAccounts() external view returns (address[] memory);\n', '    function getTradeBot() external view returns (address tradeBot);\n', '}\n', '\n', '\n', 'interface DharmaTradeBotV1Interface {\n', '  struct LimitOrderArguments {\n', '    address account;\n', '    address assetToSupply;        // Ether = address(0)\n', '    address assetToReceive;       // Ether = address(0)\n', '    uint256 maximumAmountToSupply;\n', '    uint256 maximumPriceToAccept; // represented as a mantissa (n * 10^18)\n', '    uint256 expiration;\n', '    bytes32 salt;\n', '  }\n', '\n', '  struct LimitOrderExecutionArguments {\n', '    uint256 amountToSupply; // will be lower than maximum for partial fills\n', '    bytes signatures;\n', '    address tradeTarget;\n', '    bytes tradeData;\n', '  }\n', '\n', '  function processLimitOrder(\n', '    LimitOrderArguments calldata args,\n', '    LimitOrderExecutionArguments calldata executionArgs\n', '  ) external returns (uint256 amountReceived);\n', '}\n', '\n', '\n', 'interface DharmaSmartWalletFactoryV1Interface {\n', '  function newSmartWallet(\n', '    address userSigningKey\n', '  ) external returns (address wallet);\n', '  \n', '  function getNextSmartWallet(\n', '    address userSigningKey\n', '  ) external view returns (address wallet);\n', '}\n', '\n', 'interface DharmaKeyRingFactoryV2Interface {\n', '  function newKeyRing(\n', '    address userSigningKey, address targetKeyRing\n', '  ) external returns (address keyRing);\n', '\n', '  function getNextKeyRing(\n', '    address userSigningKey\n', '  ) external view returns (address targetKeyRing);\n', '}\n', '\n', '\n', 'contract TwoStepOwnable {\n', '  address private _owner;\n', '\n', '  address private _newPotentialOwner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev Initialize contract by setting transaction submitter as initial owner.\n', '   */\n', '  constructor() internal {\n', '    _owner = tx.origin;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the current owner.\n', '   */\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner(), "TwoStepOwnable: caller is not the owner.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns true if the caller is the current owner.\n', '   */\n', '  function isOwner() public view returns (bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows a new account (`newOwner`) to accept ownership.\n', '   * Can only be called by the current owner.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(\n', '      newOwner != address(0),\n', '      "TwoStepOwnable: new potential owner is the zero address."\n', '    );\n', '\n', '    _newPotentialOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Cancel a transfer of ownership to a new account.\n', '   * Can only be called by the current owner.\n', '   */\n', '  function cancelOwnershipTransfer() public onlyOwner {\n', '    delete _newPotentialOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers ownership of the contract to the caller.\n', '   * Can only be called by a new potential owner set by the current owner.\n', '   */\n', '  function acceptOwnership() public {\n', '    require(\n', '      msg.sender == _newPotentialOwner,\n', '      "TwoStepOwnable: current owner must set caller as new potential owner."\n', '    );\n', '\n', '    delete _newPotentialOwner;\n', '\n', '    emit OwnershipTransferred(_owner, msg.sender);\n', '\n', '    _owner = msg.sender;\n', '  }\n', '}\n', '\n', '\n', 'contract TradeBotCommanderV2Staging is TradeBotCommanderV2Interface, TwoStepOwnable {\n', '    // Track all authorized accounts.\n', '    address[] private _accounts;\n', '\n', '    // Indexes start at 1, as 0 signifies non-inclusion\n', '    mapping (address => uint256) private _accountIndexes;\n', '    \n', '    DharmaTradeBotV1Interface private immutable _TRADE_BOT;\n', '\n', '    DharmaSmartWalletFactoryV1Interface private immutable _WALLET_FACTORY;\n', '  \n', '  DharmaKeyRingFactoryV2Interface private immutable _KEYRING_FACTORY;\n', '    \n', '    bool public constant isStaging = true;\n', '\n', '    constructor(address walletFactory, address keyRingFactory, address tradeBot, address[] memory initialAccounts) public {\n', '        require(\n', '            walletFactory != address(0) &&\n', '            keyRingFactory != address(0) &&\n', '            tradeBot != address(0),\n', '            "Missing required constructor arguments."\n', '        );\n', '        _WALLET_FACTORY = DharmaSmartWalletFactoryV1Interface(walletFactory);\n', '        _KEYRING_FACTORY = DharmaKeyRingFactoryV2Interface(keyRingFactory);\n', '        _TRADE_BOT = DharmaTradeBotV1Interface(tradeBot);\n', '        for (uint256 i; i < initialAccounts.length; i++) {\n', '            address account = initialAccounts[i];\n', '            _addAccount(account);\n', '        }\n', '    }\n', '    \n', '    function processLimitOrder(\n', '        DharmaTradeBotV1Interface.LimitOrderArguments calldata args,\n', '        DharmaTradeBotV1Interface.LimitOrderExecutionArguments calldata executionArgs\n', '    ) external override returns (bool ok, uint256 amountReceived) {\n', '        require(\n', '            _accountIndexes[msg.sender] != 0,\n', '            "Only authorized accounts may trigger limit orders."\n', '        );\n', '        \n', '        amountReceived = _TRADE_BOT.processLimitOrder(\n', '            args, executionArgs\n', '        );\n', '\n', '        ok = true;\n', '    }\n', '\n', '    // Deploy a key ring and a smart wallet, then process the limit order.\n', '    function deployAndProcessLimitOrder(\n', '        address initialSigningKey, // the initial key on the keyring\n', '        address keyRing,\n', '        DharmaTradeBotV1Interface.LimitOrderArguments calldata args,\n', '        DharmaTradeBotV1Interface.LimitOrderExecutionArguments calldata executionArgs\n', '    ) external override returns (bool ok, bytes memory returnData) {\n', '        require(\n', '            _accountIndexes[msg.sender] != 0,\n', '            "Only authorized accounts may trigger limit orders."\n', '        );\n', '        \n', '        _deployNewKeyRingIfNeeded(initialSigningKey, keyRing);\n', '        _deployNewSmartWalletIfNeeded(keyRing, args.account);\n', '        \n', '        try _TRADE_BOT.processLimitOrder(args, executionArgs) returns (uint256 amountReceived) {\n', '            return (true, abi.encode(amountReceived));\n', '        } catch (bytes memory revertData) {\n', '            return (false, revertData);\n', '        }\n', '  }\n', '\n', '    function addAccount(address account) external override onlyOwner {\n', '        _addAccount(account);\n', '    }\n', '\n', '    function removeAccount(address account) external override onlyOwner {\n', '        _removeAccount(account);\n', '    }\n', '\n', '    function callAny(\n', '        address payable target, uint256 amount, bytes calldata data\n', '    ) external override onlyOwner returns (bool ok, bytes memory returnData) {\n', '        // Call the specified target and supply the specified amount and data.\n', '        (ok, returnData) = target.call{value: amount}(data);\n', '\n', '        emit Call(target, amount, data, ok, returnData);\n', '    }\n', '\n', '    function getAccounts() external view override returns (address[] memory) {\n', '        return _accounts;\n', '    }\n', '\n', '    function getTradeBot() external view override returns (address tradeBot) {\n', '        return address(_TRADE_BOT);\n', '    }\n', '\n', '  function _deployNewKeyRingIfNeeded(\n', '    address initialSigningKey, address expectedKeyRing\n', '  ) internal returns (address keyRing) {\n', "    // Only deploy if a contract doesn't already exist at expected address.\n", '    bytes32 size;\n', '    assembly { size := extcodesize(expectedKeyRing) }\n', '    if (size == 0) {\n', '      require(\n', '        _KEYRING_FACTORY.getNextKeyRing(initialSigningKey) == expectedKeyRing,\n', '        "Key ring to be deployed does not match expected key ring."\n', '      );\n', '      keyRing = _KEYRING_FACTORY.newKeyRing(initialSigningKey, expectedKeyRing);\n', '    } else {\n', '      // Note: the key ring at the expected address may have been modified so that\n', '      // the supplied user signing key is no longer a valid key - therefore, treat\n', '      // this helper as a way to protect against race conditions, not as a primary\n', '      // mechanism for interacting with key ring contracts.\n', '      keyRing = expectedKeyRing;\n', '    }\n', '  }\n', '  \n', '  function _deployNewSmartWalletIfNeeded(\n', '    address userSigningKey, // the key ring\n', '    address expectedSmartWallet\n', '  ) internal returns (address smartWallet) {\n', "    // Only deploy if a contract doesn't already exist at expected address.\n", '    bytes32 size;\n', '    assembly { size := extcodesize(expectedSmartWallet) }\n', '    if (size == 0) {\n', '      require(\n', '        _WALLET_FACTORY.getNextSmartWallet(userSigningKey) == expectedSmartWallet,\n', '        "Smart wallet to be deployed does not match expected smart wallet."\n', '      );\n', '      smartWallet = _WALLET_FACTORY.newSmartWallet(userSigningKey);\n', '    } else {\n', '      // Note: the smart wallet at the expected address may have been modified\n', '      // so that the supplied user signing key is no longer a valid key.\n', '      // Therefore, treat this helper as a way to protect against race\n', '      // conditions, not as a primary mechanism for interacting with smart\n', '      // wallet contracts.\n', '      smartWallet = expectedSmartWallet;\n', '    }\n', '  }\n', '\n', '    function _addAccount(address account) internal {\n', '        require(\n', '            _accountIndexes[account] == 0,\n', '            "Account matching the provided account already exists."\n', '        );\n', '        _accounts.push(account);\n', '        _accountIndexes[account] = _accounts.length;\n', '\n', '        emit AddedAccount(account);\n', '    }\n', '    \n', '    function _removeAccount(address account) internal {\n', '        uint256 removedAccountIndex = _accountIndexes[account];\n', '        require(\n', '            removedAccountIndex != 0,\n', '            "No account found matching the provided account."\n', '        );\n', '\n', '        // swap account to remove with the last one then pop from the array.\n', '        address lastAccount = _accounts[_accounts.length - 1];\n', '        _accounts[removedAccountIndex - 1] = lastAccount;\n', '        _accountIndexes[lastAccount] = removedAccountIndex;\n', '        _accounts.pop();\n', '        delete _accountIndexes[account];\n', '\n', '        emit RemovedAccount(account); \n', '    }\n', '}']