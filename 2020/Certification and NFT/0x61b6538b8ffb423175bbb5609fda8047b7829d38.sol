['pragma solidity 0.6.12; // optimization runs: 200, evm version: istanbul\n', '\n', '\n', 'interface IDharmaUNIDelegator {\n', '    function getDefaultDelegationPayload() external pure returns (bytes32);\n', '    function validateDefaultPayload(address delegator, bytes calldata signature) external view returns (bool valid);\n', '    function delegateToDharmaViaDefault(bytes calldata signature) external returns (bool ok);\n', '    \n', '    function getCustomDelegationPayload(address delegator, uint256 expiry) external view returns (bytes32);\n', '    function validateCustomPayload(address delegator, uint256 expiry, bytes calldata signature) external view returns (bool valid);\n', '    function delegateToDharmaViaCustom(address delegator, uint256 expiry, bytes calldata signature) external returns (bool ok);\n', '}\n', '\n', '\n', 'interface IUNI {\n', '    function nonces(address account) external view returns (uint256);\n', '    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\n', '}\n', '\n', '\n', '/// @title DharmaUNIDelegator\n', '/// @author 0age\n', '/// @notice This contract facilitates UNI delegation to Dharma via meta-transaction,\n', '/// using the `delegateBySig` pattern first established by Compound on their COMP\n', '/// token. Two methods are available — a "default" method, which assumes that the\n', '/// delegator is making their first meta-transaction on UNI and does not desire the\n', '/// deletation meta-transaction to expire, and a "custom" method that utilizes the\n', '/// current nonce for the delegator in question and allows for specification of any\n', '/// expiration. First, call `getDefaultDelegationPayload` to retrieve the payload\n', '/// that needs to be signed. Next, the delegator signs the payload via `eth_sign`.\n', '/// Finally, validate the signature via `validateDefaultPayload` and relay the\n', '/// delegation via `delegateToDharmaViaDefault`. (The same sequence applies for\n', '/// custom delegation, using the corresponding custom methods.) Finally, note that\n', '/// delegation can be modified at any point, but that any proposals that are made\n', '/// will "lock in" delegation as of the proposal time in the context of the vote\n', '/// in question.\n', 'contract DharmaUNIDelegator is IDharmaUNIDelegator {\n', "    /// @notice The EIP-712 typehash for UNI's domain\n", '    bytes32 internal constant DOMAIN_TYPEHASH = keccak256(\n', '        "EIP712Domain(string name,uint256 chainId,address verifyingContract)"\n', '    );\n', '\n', "    /// @notice UNI's EIP-712 domain separator, computed from parameters in typehash\n", '    bytes32 internal constant DOMAIN_SEPARATOR = bytes32(\n', '        0x28e9a6a663fbec82798f959fbf7b0805000a2aa21154d62a24be5f2a8716bf81\n', '    );\n', '\n', '    /// @notice The EIP-712 typehash for the delegation struct used by UNI\n', '    bytes32 internal constant DELEGATION_TYPEHASH = keccak256(\n', '        "Delegation(address delegatee,uint256 nonce,uint256 expiry)"\n', '    );\n', '\n', '    /// @notice The EIP-712 typehash for the initial delegation struct to Dharma\n', '    bytes32 internal constant STRUCT_HASH_FOR_ZERO_NONCE_AND_DISTANT_EXPIRY = bytes32(\n', '        0x8e3dad336fbf63723cdd6a970ccff74331f69d237e030433c4fb2d299d44fdd6\n', '    );\n', '    \n', '    /// @notice The EIP-712 payload to sign for delegation to Dharma with default parameters\n', '    bytes32 internal constant DEFAULT_DELEGATION_PAYLOAD = bytes32(\n', '        0x96b14b7fefb98540ed60068884902ad2b61901691cd14a23fdd0e24bc7515f24\n', '    );\n', '\n', '    /// @notice The address and relevant interface of UNI\n', '    IUNI public constant UNI = IUNI(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984);\n', '    \n', '    /// @notice The Dharma Delegatee address\n', '    address public constant DHARMA_DELEGATEE = address(\n', '        0x7e4A8391C728fEd9069B2962699AB416628B19Fa\n', '    );\n', '    \n', '    /// @notice The default nonce (zero)\n', '    uint256 internal constant ZERO_NONCE = uint256(0);\n', '    \n', '    /// @notice The default expiration (a long, long time from now)\n', '    uint256 internal constant DISTANT_EXPIRY = uint256(999999999999999999);\n', '    \n', '    /// @notice Validate the computation of defined constants during deployment\n', '    constructor() public {\n', '        require(\n', '            DOMAIN_SEPARATOR == keccak256(\n', '                abi.encode(\n', '                    DOMAIN_TYPEHASH, keccak256(bytes("Uniswap")), uint256(1), address(UNI)\n', '                )\n', '            ),\n', '            "Domain Separator does not match computed domain separator."\n', '        );\n', '        \n', '        require(\n', '            STRUCT_HASH_FOR_ZERO_NONCE_AND_DISTANT_EXPIRY == keccak256(\n', '                abi.encode(\n', '                    DELEGATION_TYPEHASH, DHARMA_DELEGATEE, ZERO_NONCE, DISTANT_EXPIRY\n', '                )\n', '            ),\n', '            "Default struct hash does not match computed default struct hash."\n', '        );\n', '        \n', '        require(\n', '            DEFAULT_DELEGATION_PAYLOAD == keccak256(\n', '                abi.encodePacked(\n', '                    "\\x19\\x01", DOMAIN_SEPARATOR, STRUCT_HASH_FOR_ZERO_NONCE_AND_DISTANT_EXPIRY\n', '                )\n', '            ),\n', '            "Default initial delegation payload does not match computed default payload."\n', '        );\n', '    }\n', '    \n', '    /// @notice Get default payload to sign for delegating to Dharma — note that it must be the\n', '    /// first UNI meta-transaction from the delegator.\n', '    function getDefaultDelegationPayload() external pure override returns (bytes32) {\n', '        return DEFAULT_DELEGATION_PAYLOAD;\n', '    }\n', '\n', '    /// @notice Confirm that a given signature for default delegation resolves to a specific delegator\n', '    /// and is currently valid.\n', '    function validateDefaultPayload(\n', '        address delegator, bytes calldata signature\n', '    ) external view override returns (bool valid) {\n', '        uint256 delegatorNonce = UNI.nonces(delegator);\n', '        (uint8 v, bytes32 r, bytes32 s) = _unpackSignature(signature);\n', '        valid = (delegatorNonce == 0 && ecrecover(DEFAULT_DELEGATION_PAYLOAD, v, r, s) == delegator);\n', '    }\n', '\n', '    /// @notice Provide a valid signature to delegate to Dharma — delegation can be reassigned to\n', '    /// another account at any time, but any votes that have already occurred will persist.\n', '    function delegateToDharmaViaDefault(bytes calldata signature) external override returns (bool ok) {\n', '        (uint8 v, bytes32 r, bytes32 s) = _unpackSignature(signature);\n', '        UNI.delegateBySig(DHARMA_DELEGATEE, ZERO_NONCE, DISTANT_EXPIRY, v, r, s);\n', '        ok = true;\n', '    }\n', '    \n', '    /// @notice Get a custom payload to sign for delegating to Dharma — this supports non-zero nonces,\n', '    /// and any expiration can be specified.\n', '    function getCustomDelegationPayload(\n', '        address delegator, uint256 expiry\n', '    ) public view override returns (bytes32) {\n', '        uint256 nonce = UNI.nonces(delegator);\n', '        bytes32 structHash = keccak256(\n', '            abi.encode(\n', '                DELEGATION_TYPEHASH, DHARMA_DELEGATEE, nonce, expiry\n', '            )\n', '        );\n', '        return keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, structHash));\n', '    }\n', '\n', '    /// @notice Confirm that a given signature for custom delegation resolves to a specific delegator\n', '    /// and is currently valid.\n', '    function validateCustomPayload(\n', '        address delegator, uint256 expiry, bytes calldata signature\n', '    ) external view override returns (bool valid) {\n', '        bytes32 customPayload = getCustomDelegationPayload(delegator, expiry);\n', '        (uint8 v, bytes32 r, bytes32 s) = _unpackSignature(signature);\n', '        valid = (block.timestamp <= expiry && ecrecover(customPayload, v, r, s) == delegator);\n', '    }\n', '\n', '    /// @notice Provide a valid signature and custom arguments to delegate to Dharma — delegation\n', '    /// can be reassigned to another account at any time, but any votes that have already occurred\n', '    /// will persist.\n', '    function delegateToDharmaViaCustom(\n', '        address delegator, uint256 expiry, bytes calldata signature\n', '    ) external override returns (bool ok) {\n', '        uint256 delegatorNonce = UNI.nonces(delegator);\n', '        (uint8 v, bytes32 r, bytes32 s) = _unpackSignature(signature);\n', '        UNI.delegateBySig(DHARMA_DELEGATEE, delegatorNonce, expiry, v, r, s);\n', '        ok = true;\n', '    }\n', '    \n', '    /// @notice Internal function to deconstruct an aggregated signature into r, s, and v values.\n', '    function _unpackSignature(\n', '        bytes memory signature\n', '    ) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\n', '        require(signature.length == 65, "Signature length is incorrect.");\n', '\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '    }\n', '}']