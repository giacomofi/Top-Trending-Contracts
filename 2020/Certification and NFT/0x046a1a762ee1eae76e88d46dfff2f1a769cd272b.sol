['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private initializing;\n', '\n', '    /**\n', '     * @dev Modifier to use in the initializer function of a contract.\n', '     */\n', '    modifier initializer() {\n', '        require(\n', '            initializing || isConstructor() || !initialized,\n', '            "Contract instance has already been initialized"\n', '        );\n', '\n', '        bool isTopLevelCall = !initializing;\n', '        if (isTopLevelCall) {\n', '            initializing = true;\n', '            initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            initializing = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function isConstructor() private view returns (bool) {\n', '        // extcodesize checks the size of the code stored in an address, and\n', '        // address returns the current address. Since the code is still not\n', '        // deployed when running a constructor, any checks on its code size will\n', '        // yield zero, making it an effective way to detect if a contract is\n', '        // under construction or not.\n', '        address self = address(this);\n', '        uint256 cs;\n', '        assembly {\n', '            cs := extcodesize(self)\n', '        }\n', '        return cs == 0;\n', '    }\n', '\n', '    // Reserved storage space to allow for layout changes in the future.\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context is Initializable {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor() internal {}\n', '\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20Mintable}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Initializable, Context, IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) private _balances;\n', '\n', '    mapping(address => mapping(address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for `sender`'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(\n', '            sender,\n', '            _msgSender(),\n', '            _allowances[sender][_msgSender()].sub(\n', '                amount,\n', '                "ERC20: transfer amount exceeds allowance"\n', '            )\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue)\n', '        public\n', '        returns (bool)\n', '    {\n', '        _approve(\n', '            _msgSender(),\n', '            spender,\n', '            _allowances[_msgSender()][spender].add(addedValue)\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue)\n', '        public\n', '        returns (bool)\n', '    {\n', '        _approve(\n', '            _msgSender(),\n', '            spender,\n', '            _allowances[_msgSender()][spender].sub(\n', '                subtractedValue,\n', '                "ERC20: decreased allowance below zero"\n', '            )\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _balances[sender] = _balances[sender].sub(\n', '            amount,\n', '            "ERC20: transfer amount exceeds balance"\n', '        );\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _balances[account] = _balances[account].sub(\n', '            amount,\n', '            "ERC20: burn amount exceeds balance"\n', '        );\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount\n', '    ) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n', "     * from the caller's allowance.\n", '     *\n', '     * See {_burn} and {_approve}.\n', '     */\n', '    function _burnFrom(address account, uint256 amount) internal {\n', '        _burn(account, amount);\n', '        _approve(\n', '            account,\n', '            _msgSender(),\n', '            _allowances[account][_msgSender()].sub(\n', '                amount,\n', '                "ERC20: burn amount exceeds allowance"\n', '            )\n', '        );\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/**\n', ' * @dev Extension of {ERC20} that allows token holders to destroy both their own\n', ' * tokens and those that they have an allowance for, in a way that can be\n', ' * recognized off-chain (via event analysis).\n', ' */\n', 'contract ERC20Burnable is Initializable, Context, ERC20 {\n', '    /**\n', '     * @dev Destroys `amount` tokens from the caller.\n', '     *\n', '     * See {ERC20-_burn}.\n', '     */\n', '    function burn(uint256 amount) public {\n', '        _burn(_msgSender(), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {ERC20-_burnFrom}.\n', '     */\n', '    function burnFrom(address account, uint256 amount) public {\n', '        _burnFrom(account, amount);\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/**\n', ' * @dev Optional functions from the ERC20 standard.\n', ' */\n', 'contract ERC20Detailed is Initializable, IERC20 {\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    /**\n', '     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n', '     * these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    function initialize(\n', '        string memory name,\n', '        string memory symbol,\n', '        uint8 decimals\n', '    ) public initializer {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping(address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev Give an account access to this role.\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(!has(role, account), "Roles: account already has role");\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev Remove an account's access to this role.\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(has(role, account), "Roles: account does not have role");\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if an account has this role.\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        require(account != address(0), "Roles: account is the zero address");\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', 'contract MinterRole is Initializable, Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event MinterAdded(address indexed account);\n', '    event MinterRemoved(address indexed account);\n', '\n', '    Roles.Role private _minters;\n', '\n', '    function initialize(address sender) public initializer {\n', '        if (!isMinter(sender)) {\n', '            _addMinter(sender);\n', '        }\n', '    }\n', '\n', '    modifier onlyMinter() {\n', '        require(\n', '            isMinter(_msgSender()),\n', '            "MinterRole: caller does not have the Minter role"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function isMinter(address account) public view returns (bool) {\n', '        return _minters.has(account);\n', '    }\n', '\n', '    function addMinter(address account) public onlyMinter {\n', '        _addMinter(account);\n', '    }\n', '\n', '    function renounceMinter() public {\n', '        _removeMinter(_msgSender());\n', '    }\n', '\n', '    function _addMinter(address account) internal {\n', '        _minters.add(account);\n', '        emit MinterAdded(account);\n', '    }\n', '\n', '    function _removeMinter(address account) internal {\n', '        _minters.remove(account);\n', '        emit MinterRemoved(account);\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/**\n', ' * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\n', ' * which have permission to mint (create) new tokens as they see fit.\n', ' *\n', ' * At construction, the deployer of the contract is the only minter.\n', ' */\n', 'contract ERC20Mintable is Initializable, ERC20, MinterRole {\n', '    function initialize(address sender) public initializer {\n', '        MinterRole.initialize(sender);\n', '    }\n', '\n', '    /**\n', '     * @dev See {ERC20-_mint}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the {MinterRole}.\n', '     */\n', '    function mint(address account, uint256 amount)\n', '        public\n', '        onlyMinter\n', '        returns (bool)\n', '    {\n', '        _mint(account, amount);\n', '        return true;\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', 'contract PauserRole is Initializable, Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event PauserAdded(address indexed account);\n', '    event PauserRemoved(address indexed account);\n', '\n', '    Roles.Role private _pausers;\n', '\n', '    function initialize(address sender) public initializer {\n', '        if (!isPauser(sender)) {\n', '            _addPauser(sender);\n', '        }\n', '    }\n', '\n', '    modifier onlyPauser() {\n', '        require(\n', '            isPauser(_msgSender()),\n', '            "PauserRole: caller does not have the Pauser role"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function isPauser(address account) public view returns (bool) {\n', '        return _pausers.has(account);\n', '    }\n', '\n', '    function addPauser(address account) public onlyPauser {\n', '        _addPauser(account);\n', '    }\n', '\n', '    function renouncePauser() public {\n', '        _removePauser(_msgSender());\n', '    }\n', '\n', '    function _addPauser(address account) internal {\n', '        _pausers.add(account);\n', '        emit PauserAdded(account);\n', '    }\n', '\n', '    function _removePauser(address account) internal {\n', '        _pausers.remove(account);\n', '        emit PauserRemoved(account);\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' * This module is used through inheritance. It will make available the\n', ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n', ' * the functions of your contract. Note that they will not be pausable by\n', ' * simply including this module, only once the modifiers are put in place.\n', ' */\n', 'contract Pausable is Initializable, Context, PauserRole {\n', '    /**\n', '     * @dev Emitted when the pause is triggered by a pauser (`account`).\n', '     */\n', '    event Paused(address account);\n', '\n', '    /**\n', '     * @dev Emitted when the pause is lifted by a pauser (`account`).\n', '     */\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    /**\n', '     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n', '     * to the deployer.\n', '     */\n', '    function initialize(address sender) public initializer {\n', '        PauserRole.initialize(sender);\n', '\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the contract is paused, and false otherwise.\n', '     */\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused, "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused, "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Called by a pauser to pause, triggers stopped state.\n', '     */\n', '    function pause() public onlyPauser whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(_msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Called by a pauser to unpause, returns to normal state.\n', '     */\n', '    function unpause() public onlyPauser whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(_msgSender());\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/**\n', ' * @title Pausable token\n', ' * @dev ERC20 with pausable transfers and allowances.\n', ' *\n', ' * Useful if you want to stop trades until the end of a crowdsale, or have\n', ' * an emergency switch for freezing all token transfers in the event of a large\n', ' * bug.\n', ' */\n', 'contract ERC20Pausable is Initializable, ERC20, Pausable {\n', '    function initialize(address sender) public initializer {\n', '        Pausable.initialize(sender);\n', '    }\n', '\n', '    function transfer(address to, uint256 value)\n', '        public\n', '        whenNotPaused\n', '        returns (bool)\n', '    {\n', '        return super.transfer(to, value);\n', '    }\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) public whenNotPaused returns (bool) {\n', '        return super.transferFrom(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint256 value)\n', '        public\n', '        whenNotPaused\n', '        returns (bool)\n', '    {\n', '        return super.approve(spender, value);\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue)\n', '        public\n', '        whenNotPaused\n', '        returns (bool)\n', '    {\n', '        return super.increaseAllowance(spender, addedValue);\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue)\n', '        public\n', '        whenNotPaused\n', '        returns (bool)\n', '    {\n', '        return super.decreaseAllowance(spender, subtractedValue);\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be aplied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Initializable, Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    function initialize(address sender) public initializer {\n', '        _owner = sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(\n', '            newOwner != address(0),\n', '            "Ownable: new owner is the zero address"\n', '        );\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', 'library BasisPoints {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 private constant BASIS_POINTS = 10000;\n', '\n', '    function mulBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n', '        if (amt == 0) return 0;\n', '        return amt.mul(bp).div(BASIS_POINTS);\n', '    }\n', '\n', '    function divBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n', '        require(bp > 0, "Cannot divide by zero.");\n', '        if (amt == 0) return 0;\n', '        return amt.mul(BASIS_POINTS).div(bp);\n', '    }\n', '\n', '    function addBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n', '        if (amt == 0) return 0;\n', '        if (bp == 0) return amt;\n', '        return amt.add(mulBP(amt, bp));\n', '    }\n', '\n', '    function subBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n', '        if (amt == 0) return 0;\n', '        if (bp == 0) return amt;\n', '        return amt.sub(mulBP(amt, bp));\n', '    }\n', '}\n', '\n', 'interface ILidCertifiableToken {\n', '    function activateTransfers() external;\n', '\n', '    function activateTax() external;\n', '\n', '    function mint(address account, uint256 amount) external returns (bool);\n', '\n', '    function addMinter(address account) external;\n', '\n', '    function renounceMinter() external;\n', '\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function isMinter(address account) external view returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'interface IStakeHandler {\n', '    function handleStake(\n', '        address staker,\n', '        uint256 stakerDeltaValue,\n', '        uint256 stakerFinalValue\n', '    ) external;\n', '\n', '    function handleUnstake(\n', '        address staker,\n', '        uint256 stakerDeltaValue,\n', '        uint256 stakerFinalValue\n', '    ) external;\n', '}\n', '\n', 'contract LidStaking is Initializable, Ownable {\n', '    using BasisPoints for uint256;\n', '    using SafeMath for uint256;\n', '\n', '    uint256 internal constant DISTRIBUTION_MULTIPLIER = 2**64;\n', '\n', '    uint256 public stakingTaxBP;\n', '    uint256 public unstakingTaxBP;\n', '    ILidCertifiableToken private lidToken;\n', '\n', '    mapping(address => uint256) public stakeValue;\n', '    mapping(address => int256) public stakerPayouts;\n', '\n', '    uint256 public totalDistributions;\n', '    uint256 public totalStaked;\n', '    uint256 public totalStakers;\n', '    uint256 public profitPerShare;\n', '    uint256 private emptyStakeTokens; //These are tokens given to the contract when there are no stakers.\n', '\n', '    IStakeHandler[] public stakeHandlers;\n', '    uint256 public startTime;\n', '\n', '    uint256 public registrationFeeWithReferrer;\n', '    uint256 public registrationFeeWithoutReferrer;\n', '    mapping(address => uint256) public accountReferrals;\n', '    mapping(address => bool) public stakerIsRegistered;\n', '\n', '    event OnDistribute(address sender, uint256 amountSent);\n', '    event OnStake(address sender, uint256 amount, uint256 tax);\n', '    event OnUnstake(address sender, uint256 amount, uint256 tax);\n', '    event OnReinvest(address sender, uint256 amount, uint256 tax);\n', '    event OnWithdraw(address sender, uint256 amount);\n', '\n', '    bool private initialized;\n', '\n', '    struct Checkpoint {\n', '        uint128 fromBlock;\n', '        uint128 value;\n', '    }\n', '\n', '    mapping(address => Checkpoint[]) internal stakeValueHistory;\n', '\n', '    Checkpoint[] internal totalStakedHistory;\n', '\n', '    modifier v2Initializer() {\n', '        require(\n', '            !initialized,\n', '            "V2 Contract instance has already been initialized"\n', '        );\n', '        initialized = true;\n', '        _;\n', '    }\n', '\n', '    modifier onlyLidToken {\n', '        require(\n', '            msg.sender == address(lidToken),\n', '            "Can only be called by LidToken contract."\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier whenStakingActive {\n', '        require(startTime != 0 && now > startTime, "Staking not yet started.");\n', '        _;\n', '    }\n', '\n', '    function initialize(\n', '        uint256 _stakingTaxBP,\n', '        uint256 _ustakingTaxBP,\n', '        uint256 _registrationFeeWithReferrer,\n', '        uint256 _registrationFeeWithoutReferrer,\n', '        address owner,\n', '        ILidCertifiableToken _lidToken\n', '    ) external initializer {\n', '        Ownable.initialize(msg.sender);\n', '        stakingTaxBP = _stakingTaxBP;\n', '        unstakingTaxBP = _ustakingTaxBP;\n', '        lidToken = _lidToken;\n', '        registrationFeeWithReferrer = _registrationFeeWithReferrer;\n', '        registrationFeeWithoutReferrer = _registrationFeeWithoutReferrer;\n', '        //Due to issue in oz testing suite, the msg.sender might not be owner\n', '        _transferOwnership(owner);\n', '    }\n', '\n', '    function v2Initialize(ILidCertifiableToken _lidToken)\n', '        external\n', '        v2Initializer\n', '        onlyOwner\n', '    {\n', '        lidToken = _lidToken;\n', '    }\n', '\n', '    function registerAndStake(uint256 amount) public {\n', '        registerAndStake(amount, address(0x0));\n', '    }\n', '\n', '    function registerAndStake(uint256 amount, address referrer)\n', '        public\n', '        whenStakingActive\n', '    {\n', '        require(\n', '            !stakerIsRegistered[msg.sender],\n', '            "Staker must not be registered"\n', '        );\n', '        require(\n', '            lidToken.balanceOf(msg.sender) >= amount,\n', '            "Must have enough balance to stake amount"\n', '        );\n', '        uint256 finalAmount;\n', '        if (address(0x0) == referrer) {\n', '            //No referrer\n', '            require(\n', '                amount >= registrationFeeWithoutReferrer,\n', '                "Must send at least enough LID to pay registration fee."\n', '            );\n', '            distribute(registrationFeeWithoutReferrer);\n', '            finalAmount = amount.sub(registrationFeeWithoutReferrer);\n', '        } else {\n', '            //has referrer\n', '            require(\n', '                amount >= registrationFeeWithReferrer,\n', '                "Must send at least enough LID to pay registration fee."\n', '            );\n', '            require(\n', '                lidToken.transferFrom(\n', '                    msg.sender,\n', '                    referrer,\n', '                    registrationFeeWithReferrer\n', '                ),\n', '                "Stake failed due to failed referral transfer."\n', '            );\n', '            accountReferrals[referrer] = accountReferrals[referrer].add(1);\n', '            finalAmount = amount.sub(registrationFeeWithReferrer);\n', '        }\n', '        stakerIsRegistered[msg.sender] = true;\n', '        stake(finalAmount);\n', '    }\n', '\n', '    function stake(uint256 amount) public whenStakingActive {\n', '        require(\n', '            stakerIsRegistered[msg.sender] == true,\n', '            "Must be registered to stake."\n', '        );\n', '        require(amount >= 1e18, "Must stake at least one LID.");\n', '        require(\n', '            lidToken.balanceOf(msg.sender) >= amount,\n', '            "Cannot stake more LID than you hold unstaked."\n', '        );\n', '        if (stakeValue[msg.sender] == 0) totalStakers = totalStakers.add(1);\n', '        uint256 tax = _addStake(amount);\n', '        require(\n', '            lidToken.transferFrom(msg.sender, address(this), amount),\n', '            "Stake failed due to failed transfer."\n', '        );\n', '        emit OnStake(msg.sender, amount, tax);\n', '    }\n', '\n', '    function unstake(uint256 amount) external whenStakingActive {\n', '        require(amount >= 1e18, "Must unstake at least one LID.");\n', '        require(\n', '            stakeValue[msg.sender] >= amount,\n', '            "Cannot unstake more LID than you have staked."\n', '        );\n', "        // Update staker's history\n", '        _updateCheckpointValueAtNow(\n', '            stakeValueHistory[msg.sender],\n', '            stakeValue[msg.sender],\n', '            stakeValue[msg.sender].sub(amount)\n', '        );\n', '\n', '        // Update total staked history\n', '        _updateCheckpointValueAtNow(\n', '            totalStakedHistory,\n', '            totalStaked,\n', '            totalStaked.sub(amount)\n', '        );\n', '\n', '        //must withdraw all dividends, to prevent overflows\n', '        withdraw(dividendsOf(msg.sender));\n', '        if (stakeValue[msg.sender] == amount)\n', '            totalStakers = totalStakers.sub(1);\n', '        totalStaked = totalStaked.sub(amount);\n', '        stakeValue[msg.sender] = stakeValue[msg.sender].sub(amount);\n', '\n', '        uint256 tax = findTaxAmount(amount, unstakingTaxBP);\n', '        uint256 earnings = amount.sub(tax);\n', '        _increaseProfitPerShare(tax);\n', '        stakerPayouts[msg.sender] = uintToInt(\n', '            profitPerShare.mul(stakeValue[msg.sender])\n', '        );\n', '\n', '        for (uint256 i = 0; i < stakeHandlers.length; i++) {\n', '            stakeHandlers[i].handleUnstake(\n', '                msg.sender,\n', '                amount,\n', '                stakeValue[msg.sender]\n', '            );\n', '        }\n', '\n', '        require(\n', '            lidToken.transferFrom(address(this), msg.sender, earnings),\n', '            "Unstake failed due to failed transfer."\n', '        );\n', '        emit OnUnstake(msg.sender, amount, tax);\n', '    }\n', '\n', '    function withdraw(uint256 amount) public whenStakingActive {\n', '        require(\n', '            dividendsOf(msg.sender) >= amount,\n', '            "Cannot withdraw more dividends than you have earned."\n', '        );\n', '        stakerPayouts[msg.sender] =\n', '            stakerPayouts[msg.sender] +\n', '            uintToInt(amount.mul(DISTRIBUTION_MULTIPLIER));\n', '        lidToken.transfer(msg.sender, amount);\n', '        emit OnWithdraw(msg.sender, amount);\n', '    }\n', '\n', '    function reinvest(uint256 amount) external whenStakingActive {\n', '        require(\n', '            dividendsOf(msg.sender) >= amount,\n', '            "Cannot reinvest more dividends than you have earned."\n', '        );\n', '        uint256 payout = amount.mul(DISTRIBUTION_MULTIPLIER);\n', '        stakerPayouts[msg.sender] =\n', '            stakerPayouts[msg.sender] +\n', '            uintToInt(payout);\n', '        uint256 tax = _addStake(amount);\n', '        emit OnReinvest(msg.sender, amount, tax);\n', '    }\n', '\n', '    function distribute(uint256 amount) public {\n', '        require(\n', '            lidToken.balanceOf(msg.sender) >= amount,\n', '            "Cannot distribute more LID than you hold unstaked."\n', '        );\n', '        totalDistributions = totalDistributions.add(amount);\n', '        _increaseProfitPerShare(amount);\n', '        require(\n', '            lidToken.transferFrom(msg.sender, address(this), amount),\n', '            "Distribution failed due to failed transfer."\n', '        );\n', '        emit OnDistribute(msg.sender, amount);\n', '    }\n', '\n', '    function handleTaxDistribution(uint256 amount) external onlyLidToken {\n', '        totalDistributions = totalDistributions.add(amount);\n', '        _increaseProfitPerShare(amount);\n', '        emit OnDistribute(msg.sender, amount);\n', '    }\n', '\n', '    function dividendsOf(address staker) public view returns (uint256) {\n', '        int256 divPayout = uintToInt(profitPerShare.mul(stakeValue[staker]));\n', '        require(divPayout >= stakerPayouts[staker], "dividend calc overflow");\n', '        return\n', '            uint256(divPayout - stakerPayouts[staker]).div(\n', '                DISTRIBUTION_MULTIPLIER\n', '            );\n', '    }\n', '\n', '    function findTaxAmount(uint256 value, uint256 taxBP)\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return value.mulBP(taxBP);\n', '    }\n', '\n', '    function numberStakeHandlersRegistered() external view returns (uint256) {\n', '        return stakeHandlers.length;\n', '    }\n', '\n', '    function registerStakeHandler(IStakeHandler sc) external onlyOwner {\n', '        stakeHandlers.push(sc);\n', '    }\n', '\n', '    function unregisterStakeHandler(uint256 index) external onlyOwner {\n', '        IStakeHandler sc = stakeHandlers[stakeHandlers.length - 1];\n', '        stakeHandlers.pop();\n', '        stakeHandlers[index] = sc;\n', '    }\n', '\n', '    function setStakingBP(uint256 valueBP) external onlyOwner {\n', '        require(valueBP < 10000, "Tax connot be over 100% (10000 BP)");\n', '        stakingTaxBP = valueBP;\n', '    }\n', '\n', '    function setUnstakingBP(uint256 valueBP) external onlyOwner {\n', '        require(valueBP < 10000, "Tax connot be over 100% (10000 BP)");\n', '        unstakingTaxBP = valueBP;\n', '    }\n', '\n', '    function setStartTime(uint256 _startTime) external onlyOwner {\n', '        startTime = _startTime;\n', '    }\n', '\n', '    function totalStakedAt(uint256 _blockNumber) public view returns (uint256) {\n', "        // If we haven't initialized history yet\n", '        if (totalStakedHistory.length == 0) {\n', '            // Use the existing value\n', '            return totalStaked;\n', '        } else {\n', '            // Binary search history for the proper staked amount\n', '            return _getCheckpointValueAt(totalStakedHistory, _blockNumber);\n', '        }\n', '    }\n', '\n', '    function stakeValueAt(address _owner, uint256 _blockNumber)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', "        // If we haven't initialized history yet\n", '        if (stakeValueHistory[_owner].length == 0) {\n', '            // Use the existing latest value\n', '            return stakeValue[_owner];\n', '        } else {\n', '            // Binary search history for the proper staked amount\n', '            return\n', '                _getCheckpointValueAt(stakeValueHistory[_owner], _blockNumber);\n', '        }\n', '    }\n', '\n', '    function setRegistrationFees(\n', '        uint256 valueWithReferrer,\n', '        uint256 valueWithoutReferrer\n', '    ) external onlyOwner {\n', '        registrationFeeWithReferrer = valueWithReferrer;\n', '        registrationFeeWithoutReferrer = valueWithoutReferrer;\n', '    }\n', '\n', '    function uintToInt(uint256 val) internal pure returns (int256) {\n', '        if (val >= uint256(-1).div(2)) {\n', '            require(false, "Overflow. Cannot convert uint to int.");\n', '        } else {\n', '            return int256(val);\n', '        }\n', '    }\n', '\n', '    function _addStake(uint256 _amount) internal returns (uint256 tax) {\n', '        tax = findTaxAmount(_amount, stakingTaxBP);\n', '        uint256 stakeAmount = _amount.sub(tax);\n', '\n', "        // Update staker's history\n", '        _updateCheckpointValueAtNow(\n', '            stakeValueHistory[msg.sender],\n', '            stakeValue[msg.sender],\n', '            stakeValue[msg.sender].add(stakeAmount)\n', '        );\n', '\n', '        // Update total staked history\n', '        _updateCheckpointValueAtNow(\n', '            totalStakedHistory,\n', '            totalStaked,\n', '            totalStaked.add(stakeAmount)\n', '        );\n', '\n', '        totalStaked = totalStaked.add(stakeAmount);\n', '        stakeValue[msg.sender] = stakeValue[msg.sender].add(stakeAmount);\n', '        for (uint256 i = 0; i < stakeHandlers.length; i++) {\n', '            stakeHandlers[i].handleStake(\n', '                msg.sender,\n', '                stakeAmount,\n', '                stakeValue[msg.sender]\n', '            );\n', '        }\n', '        uint256 payout = profitPerShare.mul(stakeAmount);\n', '        stakerPayouts[msg.sender] =\n', '            stakerPayouts[msg.sender] +\n', '            uintToInt(payout);\n', '        _increaseProfitPerShare(tax);\n', '    }\n', '\n', '    function _increaseProfitPerShare(uint256 amount) internal {\n', '        if (totalStaked != 0) {\n', '            if (emptyStakeTokens != 0) {\n', '                amount = amount.add(emptyStakeTokens);\n', '                emptyStakeTokens = 0;\n', '            }\n', '            profitPerShare = profitPerShare.add(\n', '                amount.mul(DISTRIBUTION_MULTIPLIER).div(totalStaked)\n', '            );\n', '        } else {\n', '            emptyStakeTokens = emptyStakeTokens.add(amount);\n', '        }\n', '    }\n', '\n', '    function _getCheckpointValueAt(\n', '        Checkpoint[] storage checkpoints,\n', '        uint256 _block\n', '    ) internal view returns (uint256) {\n', '        // This case should be handled by caller\n', '        if (checkpoints.length == 0) return 0;\n', '\n', '        // Use the latest checkpoint\n', '        if (_block >= checkpoints[checkpoints.length - 1].fromBlock)\n', '            return checkpoints[checkpoints.length - 1].value;\n', '\n', '        // Use the oldest checkpoint\n', '        if (_block < checkpoints[0].fromBlock) return checkpoints[0].value;\n', '\n', '        // Binary search of the value in the array\n', '        uint256 min = 0;\n', '        uint256 max = checkpoints.length - 1;\n', '        while (max > min) {\n', '            uint256 mid = (max + min + 1) / 2;\n', '            if (checkpoints[mid].fromBlock <= _block) {\n', '                min = mid;\n', '            } else {\n', '                max = mid - 1;\n', '            }\n', '        }\n', '        return checkpoints[min].value;\n', '    }\n', '\n', '    function _updateCheckpointValueAtNow(\n', '        Checkpoint[] storage checkpoints,\n', '        uint256 _oldValue,\n', '        uint256 _value\n', '    ) internal {\n', '        require(_value <= uint128(-1));\n', '        require(_oldValue <= uint128(-1));\n', '\n', '        if (checkpoints.length == 0) {\n', '            Checkpoint storage genesis = checkpoints[checkpoints.length++];\n', '            genesis.fromBlock = uint128(block.number - 1);\n', '            genesis.value = uint128(_oldValue);\n', '        }\n', '\n', '        if (checkpoints[checkpoints.length - 1].fromBlock < block.number) {\n', '            Checkpoint storage newCheckPoint =\n', '                checkpoints[checkpoints.length++];\n', '            newCheckPoint.fromBlock = uint128(block.number);\n', '            newCheckPoint.value = uint128(_value);\n', '        } else {\n', '            Checkpoint storage oldCheckPoint =\n', '                checkpoints[checkpoints.length - 1];\n', '            oldCheckPoint.value = uint128(_value);\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' */\n', 'contract ReentrancyGuard is Initializable {\n', '    // counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    function initialize() public initializer {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(\n', '            localCounter == _guardCounter,\n', '            "ReentrancyGuard: reentrant call"\n', '        );\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: contracts\\uniswapV2Periphery\\interfaces\\IUniswapV2Router01.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '\n', '    function quote(\n', '        uint256 amountA,\n', '        uint256 reserveA,\n', '        uint256 reserveB\n', '    ) external pure returns (uint256 amountB);\n', '\n', '    function getAmountOut(\n', '        uint256 amountIn,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountOut);\n', '\n', '    function getAmountIn(\n', '        uint256 amountOut,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountIn);\n', '\n', '    function getAmountsOut(uint256 amountIn, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '\n', '    function getAmountsIn(uint256 amountOut, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '\n', '    function WETH() external view returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function swapExactTokensForTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactTokens(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactETHForTokens(\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactETH(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactTokensForETH(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapETHForExactTokens(\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (uint256[] memory amounts);\n', '}\n', '\n', 'contract LidCertifiedPresaleTimer is Initializable, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public startTime;\n', '    uint256 public baseTimer;\n', '    uint256 public deltaTimer;\n', '\n', '    function initialize(\n', '        uint256 _startTime,\n', '        uint256 _baseTimer,\n', '        uint256 _deltaTimer,\n', '        address owner\n', '    ) external initializer {\n', '        Ownable.initialize(msg.sender);\n', '        startTime = _startTime;\n', '        baseTimer = _baseTimer;\n', '        deltaTimer = _deltaTimer;\n', '        //Due to issue in oz testing suite, the msg.sender might not be owner\n', '        _transferOwnership(owner);\n', '    }\n', '\n', '    function setStartTime(uint256 time) external onlyOwner {\n', '        startTime = time;\n', '    }\n', '\n', '    function isStarted() external view returns (bool) {\n', '        return (startTime != 0 && now > startTime);\n', '    }\n', '\n', '    function getEndTime(uint256 bal) external view returns (uint256) {\n', '        uint256 multiplier = 0;\n', '        if (bal <= 1000 ether) {\n', '            multiplier = bal.div(100 ether);\n', '        } else if (bal <= 10000 ether) {\n', '            multiplier = bal.div(1000 ether).add(9);\n', '        } else if (bal <= 100000 ether) {\n', '            multiplier = bal.div(10000 ether).add(19);\n', '        } else if (bal <= 1000000 ether) {\n', '            multiplier = bal.div(100000 ether).add(29);\n', '        } else if (bal <= 10000000 ether) {\n', '            multiplier = bal.div(1000000 ether).add(39);\n', '        } else if (bal <= 100000000 ether) {\n', '            multiplier = bal.div(10000000 ether).add(49);\n', '        }\n', '        return startTime.add(baseTimer).add(deltaTimer.mul(multiplier));\n', '    }\n', '}\n', '\n', 'contract LidCertifiedPresale is Initializable, Ownable, ReentrancyGuard {\n', '    using BasisPoints for uint256;\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public maxBuyPerAddressBase;\n', '    uint256 public maxBuyPerAddressBP;\n', '    uint256 public maxBuyWithoutWhitelisting;\n', '\n', '    uint256 public redeemBP;\n', '    uint256 public redeemInterval;\n', '\n', '    uint256 public referralBP;\n', '\n', '    uint256 public uniswapEthBP;\n', '    address payable[] public etherPools;\n', '    uint256[] public etherPoolBPs;\n', '\n', '    uint256 public uniswapTokenBP;\n', '    uint256 public presaleTokenBP;\n', '    address[] public tokenPools;\n', '    uint256[] public tokenPoolBPs;\n', '\n', '    uint256 public startingPrice;\n', '    uint256 public multiplierPrice;\n', '\n', '    bool public hasSentToUniswap;\n', '    bool public hasIssuedTokens;\n', '    bool public hasSentEther;\n', '\n', '    uint256 public totalTokens;\n', '    uint256 private totalEth;\n', '    uint256 public finalEndTime;\n', '\n', '    ILidCertifiableToken private token;\n', '    IUniswapV2Router01 private uniswapRouter;\n', '    LidCertifiedPresaleTimer private timer;\n', '\n', '    mapping(address => uint256) public depositAccounts;\n', '    mapping(address => uint256) public accountEarnedLid;\n', '    mapping(address => uint256) public accountClaimedLid;\n', '    mapping(address => bool) public whitelist;\n', '    mapping(address => uint256) public earnedReferrals;\n', '\n', '    uint256 public totalDepositors;\n', '    mapping(address => uint256) public referralCounts;\n', '\n', '    uint256 lidRepaired;\n', '    bool pauseDeposit;\n', '\n', '    mapping(address => bool) public isRepaired;\n', '\n', '    modifier whenPresaleActive {\n', '        require(timer.isStarted(), "Presale not yet started.");\n', '        require(!_isPresaleEnded(), "Presale has ended.");\n', '        _;\n', '    }\n', '\n', '    modifier whenPresaleFinished {\n', '        require(timer.isStarted(), "Presale not yet started.");\n', '        require(_isPresaleEnded(), "Presale has not yet ended.");\n', '        _;\n', '    }\n', '\n', '    function initialize(\n', '        uint256 _maxBuyPerAddressBase,\n', '        uint256 _maxBuyPerAddressBP,\n', '        uint256 _maxBuyWithoutWhitelisting,\n', '        uint256 _redeemBP,\n', '        uint256 _redeemInterval,\n', '        uint256 _referralBP,\n', '        uint256 _startingPrice,\n', '        uint256 _multiplierPrice,\n', '        address owner,\n', '        LidCertifiedPresaleTimer _timer,\n', '        ILidCertifiableToken _token\n', '    ) external initializer {\n', '        require(_token.isMinter(address(this)), "Presale SC must be minter.");\n', '        Ownable.initialize(msg.sender);\n', '        ReentrancyGuard.initialize();\n', '\n', '        token = _token;\n', '        timer = _timer;\n', '\n', '        maxBuyPerAddressBase = _maxBuyPerAddressBase;\n', '        maxBuyPerAddressBP = _maxBuyPerAddressBP;\n', '        maxBuyWithoutWhitelisting = _maxBuyWithoutWhitelisting;\n', '\n', '        redeemBP = _redeemBP;\n', '\n', '        referralBP = _referralBP;\n', '        redeemInterval = _redeemInterval;\n', '\n', '        startingPrice = _startingPrice;\n', '        multiplierPrice = _multiplierPrice;\n', '\n', '        uniswapRouter = IUniswapV2Router01(\n', '            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n', '        );\n', '\n', '        //Due to issue in oz testing suite, the msg.sender might not be owner\n', '        _transferOwnership(owner);\n', '    }\n', '\n', '    function deposit() external payable {\n', '        deposit(address(0x0));\n', '    }\n', '\n', '    function setEtherPools(\n', '        address payable[] calldata _etherPools,\n', '        uint256[] calldata _etherPoolBPs\n', '    ) external onlyOwner {\n', '        require(\n', '            _etherPools.length == _etherPoolBPs.length,\n', '            "Must have exactly one etherPool addresses for each BP."\n', '        );\n', '        delete etherPools;\n', '        delete etherPoolBPs;\n', '        uniswapEthBP = 7500; //75%\n', '        for (uint256 i = 0; i < _etherPools.length; ++i) {\n', '            etherPools.push(_etherPools[i]);\n', '        }\n', '        uint256 totalEtherPoolsBP = uniswapEthBP;\n', '        for (uint256 i = 0; i < _etherPoolBPs.length; ++i) {\n', '            etherPoolBPs.push(_etherPoolBPs[i]);\n', '            totalEtherPoolsBP = totalEtherPoolsBP.add(_etherPoolBPs[i]);\n', '        }\n', '        require(\n', '            totalEtherPoolsBP == 10000,\n', '            "Must allocate exactly 100% (10000 BP) of ether to pools"\n', '        );\n', '    }\n', '\n', '    function setTokenPools(\n', '        address[] calldata _tokenPools,\n', '        uint256[] calldata _tokenPoolBPs\n', '    ) external onlyOwner {\n', '        require(\n', '            _tokenPools.length == _tokenPoolBPs.length,\n', '            "Must have exactly one tokenPool addresses for each BP."\n', '        );\n', '        delete tokenPools;\n', '        delete tokenPoolBPs;\n', '        uniswapTokenBP = 1600;\n', '        presaleTokenBP = 4000;\n', '        for (uint256 i = 0; i < _tokenPools.length; ++i) {\n', '            tokenPools.push(_tokenPools[i]);\n', '        }\n', '        uint256 totalTokenPoolBPs = uniswapTokenBP.add(presaleTokenBP);\n', '        for (uint256 i = 0; i < _tokenPoolBPs.length; ++i) {\n', '            tokenPoolBPs.push(_tokenPoolBPs[i]);\n', '            totalTokenPoolBPs = totalTokenPoolBPs.add(_tokenPoolBPs[i]);\n', '        }\n', '        require(\n', '            totalTokenPoolBPs == 10000,\n', '            "Must allocate exactly 100% (10000 BP) of tokens to pools"\n', '        );\n', '    }\n', '\n', '    function sendToUniswap() external whenPresaleFinished nonReentrant {\n', '        require(etherPools.length > 0, "Must have set ether pools");\n', '        require(tokenPools.length > 0, "Must have set token pools");\n', '        require(!hasSentToUniswap, "Has already sent to Uniswap.");\n', '        finalEndTime = now;\n', '        hasSentToUniswap = true;\n', '        totalTokens = totalTokens.divBP(presaleTokenBP);\n', '        uint256 uniswapTokens = totalTokens.mulBP(uniswapTokenBP);\n', '        totalEth = address(this).balance;\n', '        uint256 uniswapEth = totalEth.mulBP(uniswapEthBP);\n', '        token.mint(address(this), uniswapTokens);\n', '        token.activateTransfers();\n', '        token.approve(address(uniswapRouter), uniswapTokens);\n', '        uniswapRouter.addLiquidityETH.value(uniswapEth)(\n', '            address(token),\n', '            uniswapTokens,\n', '            uniswapTokens,\n', '            uniswapEth,\n', '            address(0x000000000000000000000000000000000000dEaD),\n', '            now\n', '        );\n', '    }\n', '\n', '    function issueTokens() external whenPresaleFinished {\n', '        require(hasSentToUniswap, "Has not yet sent to Uniswap.");\n', '        require(!hasIssuedTokens, "Has already issued tokens.");\n', '        hasIssuedTokens = true;\n', '        for (uint256 i = 0; i < tokenPools.length; ++i) {\n', '            token.mint(tokenPools[i], totalTokens.mulBP(tokenPoolBPs[i]));\n', '        }\n', '    }\n', '\n', '    function sendEther() external whenPresaleFinished nonReentrant {\n', '        require(hasSentToUniswap, "Has not yet sent to Uniswap.");\n', '        require(!hasSentEther, "Has already sent ether.");\n', '        hasSentEther = true;\n', '        for (uint256 i = 0; i < etherPools.length; ++i) {\n', '            etherPools[i].transfer(totalEth.mulBP(etherPoolBPs[i]));\n', '        }\n', '        //remove dust\n', '        if (address(this).balance > 0) {\n', '            etherPools[0].transfer(address(this).balance);\n', '        }\n', '    }\n', '\n', '    function emergencyEthWithdrawl()\n', '        external\n', '        whenPresaleFinished\n', '        nonReentrant\n', '        onlyOwner\n', '    {\n', '        require(hasSentToUniswap, "Has not yet sent to Uniswap.");\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    function setDepositPause(bool val) external onlyOwner {\n', '        pauseDeposit = val;\n', '    }\n', '\n', '    function setWhitelist(address account, bool value) external onlyOwner {\n', '        whitelist[account] = value;\n', '    }\n', '\n', '    function setWhitelistForAll(address[] calldata account, bool value)\n', '        external\n', '        onlyOwner\n', '    {\n', '        for (uint256 i = 0; i < account.length; i++) {\n', '            whitelist[account[i]] = value;\n', '        }\n', '    }\n', '\n', '    function redeem() external whenPresaleFinished {\n', '        require(\n', '            hasSentToUniswap,\n', '            "Must have sent to Uniswap before any redeems."\n', '        );\n', '        uint256 claimable = calculateReedemable(msg.sender);\n', '        accountClaimedLid[msg.sender] = accountClaimedLid[msg.sender].add(\n', '            claimable\n', '        );\n', '        token.mint(msg.sender, claimable);\n', '    }\n', '\n', '    function deposit(address payable referrer)\n', '        public\n', '        payable\n', '        whenPresaleActive\n', '        nonReentrant\n', '    {\n', '        require(!pauseDeposit, "Deposits are paused.");\n', '        if (whitelist[msg.sender]) {\n', '            require(\n', '                depositAccounts[msg.sender].add(msg.value) <=\n', '                    getMaxWhitelistedDeposit(\n', '                        address(this).balance.sub(msg.value)\n', '                    ),\n', '                "Deposit exceeds max buy per address for whitelisted addresses."\n', '            );\n', '        } else {\n', '            require(\n', '                depositAccounts[msg.sender].add(msg.value) <=\n', '                    maxBuyWithoutWhitelisting,\n', '                "Deposit exceeds max buy per address for non-whitelisted addresses."\n', '            );\n', '        }\n', '\n', '        require(msg.value > 0.01 ether, "Must purchase at least 0.01 ether.");\n', '\n', '        if (depositAccounts[msg.sender] == 0)\n', '            totalDepositors = totalDepositors.add(1);\n', '\n', '        uint256 depositVal = msg.value.subBP(referralBP);\n', '        uint256 tokensToIssue =\n', '            depositVal.mul(10**18).div(calculateRatePerEth());\n', '        depositAccounts[msg.sender] = depositAccounts[msg.sender].add(\n', '            depositVal\n', '        );\n', '\n', '        totalTokens = totalTokens.add(tokensToIssue);\n', '\n', '        accountEarnedLid[msg.sender] = accountEarnedLid[msg.sender].add(\n', '            tokensToIssue\n', '        );\n', '\n', '        if (referrer != address(0x0) && referrer != msg.sender) {\n', '            uint256 referralValue = msg.value.sub(depositVal);\n', '            earnedReferrals[referrer] = earnedReferrals[referrer].add(\n', '                referralValue\n', '            );\n', '            referralCounts[referrer] = referralCounts[referrer].add(1);\n', '            referrer.transfer(referralValue);\n', '        }\n', '    }\n', '\n', '    function calculateReedemable(address account)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (finalEndTime == 0) return 0;\n', '        uint256 earnedLid = accountEarnedLid[account];\n', '        uint256 claimedLid = accountClaimedLid[account];\n', '        uint256 cycles = now.sub(finalEndTime).div(redeemInterval).add(1);\n', '        uint256 totalRedeemable = earnedLid.mulBP(redeemBP).mul(cycles);\n', '        uint256 claimable;\n', '        if (totalRedeemable >= earnedLid) {\n', '            claimable = earnedLid.sub(claimedLid);\n', '        } else {\n', '            claimable = totalRedeemable.sub(claimedLid);\n', '        }\n', '        return claimable;\n', '    }\n', '\n', '    function calculateRatePerEth() public view returns (uint256) {\n', '        return totalTokens.div(10**18).mul(multiplierPrice).add(startingPrice);\n', '    }\n', '\n', '    function getMaxWhitelistedDeposit(uint256 atTotalDeposited)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return\n', '            atTotalDeposited.mulBP(maxBuyPerAddressBP).add(\n', '                maxBuyPerAddressBase\n', '            );\n', '    }\n', '\n', '    function _isPresaleEnded() internal view returns (bool) {\n', '        return (\n', '            (timer.isStarted() &&\n', '                (now > timer.getEndTime(address(this).balance)))\n', '        );\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity =0.5.16;\n', '\n', '// Copyright (C) udev 2020\n', '\n', 'interface IXEth {\n', '    function deposit() external payable;\n', '\n', '    function xlockerMint(uint256 wad, address dst) external;\n', '\n', '    function withdraw(uint256 wad) external;\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '}\n', '\n', '// File: contracts\\LidToken.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract LidToken is\n', '    Initializable,\n', '    ERC20Burnable,\n', '    ERC20Mintable,\n', '    ERC20Pausable,\n', '    ERC20Detailed,\n', '    Ownable\n', '{\n', '    using BasisPoints for uint256;\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public taxBP;\n', '    uint256 public daoTaxBP;\n', '    address private daoFund;\n', '    LidStaking private lidStaking;\n', '    LidCertifiedPresale private lidPresale;\n', '\n', '    bool public isTaxActive;\n', '    bool public isTransfersActive;\n', '\n', '    mapping(address => bool) private trustedContracts;\n', '    mapping(address => bool) public taxExempt;\n', '    mapping(address => bool) public fromOnlyTaxExempt;\n', '    mapping(address => bool) public toOnlyTaxExempt;\n', '\n', '    string private _name;\n', '\n', '    modifier onlyPresaleContract() {\n', '        require(\n', '            msg.sender == address(lidPresale),\n', '            "Can only be called by presale sc."\n', '        );\n', '        _;\n', '    }\n', '\n', '    function() external payable {}\n', '\n', '    function initialize(\n', '        string calldata name,\n', '        string calldata symbol,\n', '        uint8 decimals,\n', '        address owner,\n', '        uint256 _taxBP,\n', '        uint256 _daoTaxBP,\n', '        address _daoFund,\n', '        LidStaking _lidStaking,\n', '        LidCertifiedPresale _lidPresale\n', '    ) external initializer {\n', '        taxBP = _taxBP;\n', '        daoTaxBP = _daoTaxBP;\n', '\n', '        Ownable.initialize(msg.sender);\n', '\n', '        ERC20Detailed.initialize(name, symbol, decimals);\n', '\n', '        ERC20Mintable.initialize(address(this));\n', '        _removeMinter(address(this));\n', '        _addMinter(owner);\n', '\n', '        ERC20Pausable.initialize(address(this));\n', '        _removePauser(address(this));\n', '        _addPauser(owner);\n', '\n', '        daoFund = _daoFund;\n', '        lidStaking = _lidStaking;\n', '        addTrustedContract(address(_lidStaking));\n', '        addTrustedContract(address(_lidPresale));\n', '        setTaxExemptStatus(address(_lidStaking), true);\n', '        setTaxExemptStatus(address(_lidPresale), true);\n', '        //Due to issue in oz testing suite, the msg.sender might not be owner\n', '        _transferOwnership(owner);\n', '    }\n', '\n', '    function xethLiqTransfer(\n', '        IUniswapV2Router01 router,\n', '        address pair,\n', '        IXEth xeth,\n', '        uint256 minWadExpected\n', '    ) external onlyOwner {\n', '        isTaxActive = false;\n', '        uint256 lidLiqWad = balanceOf(pair).sub(1 ether);\n', '        _transfer(pair, address(lidStaking), lidLiqWad);\n', '        approve(address(router), lidLiqWad);\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(this);\n', '        path[1] = router.WETH();\n', '        router.swapExactTokensForETH(\n', '            lidLiqWad,\n', '            minWadExpected,\n', '            path,\n', '            address(this),\n', '            now\n', '        );\n', '        _transfer(pair, address(lidStaking), lidLiqWad);\n', '        xeth.deposit.value(address(this).balance)();\n', '        require(\n', '            xeth.balanceOf(address(this)) >= minWadExpected,\n', '            "Less xeth than expected."\n', '        );\n', '\n', '        router.addLiquidity(\n', '            address(this),\n', '            address(xeth),\n', '            lidLiqWad,\n', '            xeth.balanceOf(address(this)),\n', '            lidLiqWad,\n', '            xeth.balanceOf(address(this)),\n', '            address(0x0),\n', '            now\n', '        );\n', '\n', '        isTaxActive = true;\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        require(isTransfersActive, "Transfers are currently locked.");\n', '        (isTaxActive &&\n', '            !taxExempt[msg.sender] &&\n', '            !taxExempt[recipient] &&\n', '            !toOnlyTaxExempt[recipient] &&\n', '            !fromOnlyTaxExempt[msg.sender])\n', '            ? _transferWithTax(msg.sender, recipient, amount)\n', '            : _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) public returns (bool) {\n', '        require(isTransfersActive, "Transfers are currently locked.");\n', '        (isTaxActive &&\n', '            !taxExempt[sender] &&\n', '            !taxExempt[recipient] &&\n', '            !toOnlyTaxExempt[recipient] &&\n', '            !fromOnlyTaxExempt[sender])\n', '            ? _transferWithTax(sender, recipient, amount)\n', '            : _transfer(sender, recipient, amount);\n', '        if (trustedContracts[msg.sender]) return true;\n', '        approve(\n', '            msg.sender,\n', '            allowance(sender, msg.sender).sub(\n', '                amount,\n', '                "Transfer amount exceeds allowance"\n', '            )\n', '        );\n', '        return true;\n', '    }\n', '\n', '    function addTrustedContract(address contractAddress) public onlyOwner {\n', '        trustedContracts[contractAddress] = true;\n', '    }\n', '\n', '    function setTaxExemptStatus(address account, bool status) public onlyOwner {\n', '        taxExempt[account] = status;\n', '    }\n', '\n', '    function findTaxAmount(uint256 value)\n', '        public\n', '        view\n', '        returns (uint256 tax, uint256 daoTax)\n', '    {\n', '        tax = value.mulBP(taxBP);\n', '        daoTax = value.mulBP(daoTaxBP);\n', '    }\n', '\n', '    function _transferWithTax(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        (uint256 tax, uint256 daoTax) = findTaxAmount(amount);\n', '        uint256 tokensToTransfer = amount.sub(tax).sub(daoTax);\n', '\n', '        _transfer(sender, address(lidStaking), tax);\n', '        _transfer(sender, address(daoFund), daoTax);\n', '        _transfer(sender, recipient, tokensToTransfer);\n', '        lidStaking.handleTaxDistribution(tax);\n', '    }\n', '}\n', '\n', 'contract LidVotingRights is Initializable {\n', '    LidStaking public lidStaking;\n', '    LidToken public lidToken;\n', '\n', '    function initialize(LidStaking _lidStaking, LidToken _lidToken)\n', '        external\n', '        initializer\n', '    {\n', '        lidStaking = _lidStaking;\n', '        lidToken = _lidToken;\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return "LID Voting Rights";\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return "LID-VR";\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return lidToken.decimals();\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return lidStaking.stakeValue(_owner);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return lidStaking.totalStaked();\n', '    }\n', '\n', '    function balanceOfAt(address _owner, uint256 _blockNumber)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return lidStaking.stakeValueAt(_owner, _blockNumber);\n', '    }\n', '\n', '    function totalSupplyAt(uint256 _blockNumber) public view returns (uint256) {\n', '        return lidStaking.totalStakedAt(_blockNumber);\n', '    }\n', '}']