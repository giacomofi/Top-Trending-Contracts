['// SPDX-License-Identifier: Apache-2.0\n', 'pragma solidity ^0.7.0;\n', '// File: contracts/iface/ModuleRegistry.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title ModuleRegistry\n', '/// @dev A registry for modules.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'interface ModuleRegistry\n', '{\n', '\t/// @dev Registers and enables a new module.\n', '    function registerModule(address module) external;\n', '\n', '    /// @dev Disables a module\n', '    function disableModule(address module) external;\n', '\n', '    /// @dev Returns true if the module is registered and enabled.\n', '    function isModuleEnabled(address module) external view returns (bool);\n', '\n', '    /// @dev Returns the list of enabled modules.\n', '    function enabledModules() external view returns (address[] memory _modules);\n', '\n', '    /// @dev Returns the number of enbaled modules.\n', '    function numOfEnabledModules() external view returns (uint);\n', '\n', '    /// @dev Returns true if the module is ever registered.\n', '    function isModuleRegistered(address module) external view returns (bool);\n', '}\n', '\n', '// File: contracts/lib/AddressSet.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title AddressSet\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract AddressSet\n', '{\n', '    struct Set\n', '    {\n', '        address[] addresses;\n', '        mapping (address => uint) positions;\n', '        uint count;\n', '    }\n', '    mapping (bytes32 => Set) private sets;\n', '\n', '    function addAddressToSet(\n', '        bytes32 key,\n', '        address addr,\n', '        bool    maintainList\n', '        ) internal\n', '    {\n', '        Set storage set = sets[key];\n', '        require(set.positions[addr] == 0, "ALREADY_IN_SET");\n', '\n', '        if (maintainList) {\n', '            require(set.addresses.length == set.count, "PREVIOUSLY_NOT_MAINTAILED");\n', '            set.addresses.push(addr);\n', '        } else {\n', '            require(set.addresses.length == 0, "MUST_MAINTAIN");\n', '        }\n', '\n', '        set.count += 1;\n', '        set.positions[addr] = set.count;\n', '    }\n', '\n', '    function removeAddressFromSet(\n', '        bytes32 key,\n', '        address addr\n', '        )\n', '        internal\n', '    {\n', '        Set storage set = sets[key];\n', '        uint pos = set.positions[addr];\n', '        require(pos != 0, "NOT_IN_SET");\n', '\n', '        delete set.positions[addr];\n', '        set.count -= 1;\n', '\n', '        if (set.addresses.length > 0) {\n', '            address lastAddr = set.addresses[set.count];\n', '            if (lastAddr != addr) {\n', '                set.addresses[pos - 1] = lastAddr;\n', '                set.positions[lastAddr] = pos;\n', '            }\n', '            set.addresses.pop();\n', '        }\n', '    }\n', '\n', '    function removeSet(bytes32 key)\n', '        internal\n', '    {\n', '        delete sets[key];\n', '    }\n', '\n', '    function isAddressInSet(\n', '        bytes32 key,\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return sets[key].positions[addr] != 0;\n', '    }\n', '\n', '    function numAddressesInSet(bytes32 key)\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        Set storage set = sets[key];\n', '        return set.count;\n', '    }\n', '\n', '    function addressesInSet(bytes32 key)\n', '        internal\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        Set storage set = sets[key];\n', '        require(set.count == set.addresses.length, "NOT_MAINTAINED");\n', '        return sets[key].addresses;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Ownable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Ownable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable\n', '{\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      new owner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership()\n', '        public\n', '        onlyOwner\n', '    {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Claimable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Claimable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable\n', '{\n', '    address public pendingOwner;\n', '\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0) && newOwner != owner, "INVALID_ADDRESS");\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        public\n', '        onlyPendingOwner\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/base/ModuleRegistryImpl.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title ModuleRegistryImpl\n', '/// @dev Basic implementation of a ModuleRegistry.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract ModuleRegistryImpl is Claimable, AddressSet, ModuleRegistry\n', '{\n', '    bytes32 internal constant ENABLED_MODULE = keccak256("__ENABLED_MODULE__");\n', '    bytes32 internal constant ALL_MODULE     = keccak256("__ALL_MODULE__");\n', '\n', '    event ModuleRegistered      (address module);\n', '    event ModuleDeregistered    (address module);\n', '\n', '    constructor() Claimable() {}\n', '\n', '    function registerModule(address module)\n', '        external\n', '        override\n', '        onlyOwner\n', '    {\n', '        addAddressToSet(ENABLED_MODULE, module, true);\n', '\n', '        if (!isAddressInSet(ALL_MODULE, module)) {\n', '            addAddressToSet(ALL_MODULE, module, false);\n', '        }\n', '        emit ModuleRegistered(module);\n', '    }\n', '\n', '    function disableModule(address module)\n', '        external\n', '        override\n', '        onlyOwner\n', '    {\n', '        removeAddressFromSet(ENABLED_MODULE, module);\n', '        emit ModuleDeregistered(module);\n', '    }\n', '\n', '    function isModuleEnabled(address module)\n', '        external\n', '        view\n', '        override\n', '        returns (bool)\n', '    {\n', '        return isAddressInSet(ENABLED_MODULE, module);\n', '    }\n', '\n', '    function isModuleRegistered(address module)\n', '        external\n', '        view\n', '        override\n', '        returns (bool)\n', '    {\n', '        return isAddressInSet(ALL_MODULE, module);\n', '    }\n', '\n', '    function enabledModules()\n', '        external\n', '        view\n', '        override\n', '        returns (address[] memory)\n', '    {\n', '        return addressesInSet(ENABLED_MODULE);\n', '    }\n', '\n', '    function numOfEnabledModules()\n', '        external\n', '        view\n', '        override\n', '        returns (uint)\n', '    {\n', '        return numAddressesInSet(ENABLED_MODULE);\n', '    }\n', '}']