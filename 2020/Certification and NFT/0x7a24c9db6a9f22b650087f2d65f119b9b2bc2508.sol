['// File: contracts\\SafeMath.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts\\EgorasMicrofinanceInterface.sol\n', '\n', 'pragma solidity >=0.4.0 <0.7.0;\n', '// SPDX-License-Identifier: MIT\n', 'interface EgorasMicrofinanceInterface {\n', '    struct Loan{\n', '        uint amount;\n', '        string title;\n', '        uint length;\n', '        uint min_weekly_returns;\n', '        uint total_returns;\n', '        string image_url;\n', '        string companyName;\n', '        uint totalWeeks;\n', '        uint numWeekspaid;\n', '        uint totalPayment;\n', '        bool isApproved;\n', '        uint loanFee;\n', '        address creator;\n', '    }\n', 'event LoanCreated(uint newLoanID, uint _amount, string _title, uint _length, uint _min_weekly_returns, uint _total_returns,  \n', 'string _image_url, string _companyName, uint getTotalWeeks, uint _loanFee, uint countDown, address _creator);\n', ' \n', '    struct Company{\n', '        bool isApproved;\n', '        uint positiveVote;\n', '        uint negativeVote;\n', '        uint votingPeriod;\n', '        bool stale;\n', '        string companyName;\n', '        uint registeredDate;\n', '    }\n', '\n', '    event Rewarded(\n', '        address voter, \n', '        uint share, \n', '        uint currentVotingPeriod, \n', '        uint time\n', '        );\n', '        \n', '      \n', '    event CompanyCreated(\n', '        address owner,\n', '        string companyName,\n', '        uint votingPeriod\n', '    );\n', '    event VotedForRequest(\n', '        address _voter,\n', '        uint _requestID,\n', '        uint _positiveVote,\n', '        uint _negativeVote,\n', '        bool _accept\n', '    );\n', '    event RequestCreated(\n', '      address _creator,\n', '      uint _requestType,\n', '      uint _changeTo,\n', '      string _reason,\n', '      uint _positiveVote,\n', '      uint _negativeVote,\n', '      uint _powerUsed,\n', '      bool _stale,\n', '      uint _votingPeriod,\n', '      uint _requestID\n', '      );\n', '    event CompanyApproved(\n', '    address companyAddress,\n', '    uint now,\n', '    bool state,\n', '    address _initiator\n', '    );\n', '    event VoteInCompany(\n', '    address _company,\n', '    address voter,\n', '    bool _accept,\n', '    uint _negativeVote,\n', '    uint _positiveVote);\n', '  \n', '    event ApproveLoan(uint _loanID, bool state, address initiator, uint time);\n', '    event ApproveRequest(uint _requestID, bool _state, address _initiator);    \n', '    event LoanRepayment(\n', '        uint loanID,\n', '        uint amount,\n', '        address remitter,\n', '        uint time\n', '    );\n', '    \n', '    event Refunded(uint amount, address voterAddress, uint _loanID, uint time);\n', '\n', '    event Voted(address voter,  uint loanID, uint _positiveVote, uint _negativeVote, bool _accept);\n', '    event Repay(uint _amount, uint _time, uint _week, uint _loanID);\n', '\n', '    function applyForLoan(\n', '        uint _amount,\n', '        string calldata _title,\n', '        uint _length,\n', '        string calldata _image_url\n', '        ) external;\n', '\n', '    function approveLoanCompany(address companyAddress) external;\n', '    function registerLoanCompany(string calldata companyName) external;\n', '    function getLoanByID(uint _loanID) external view returns(uint _amount, uint _min_weekly_returns, uint _totalWeeks, \n', '    uint _length, string memory _title, uint _total_returns, string memory _image_url, string memory _companyName,  uint _numWeekspaid, uint _totalPayment, bool _isApproved, address _creator);\n', '    function claimable() external view returns (bool);\n', '    function isDue(uint _loanID) external view returns (bool);\n', '    function getVotesByLoanID(uint _loanID) external view returns(uint _accepted, uint _declined);\n', '    function repayLoan(uint _loanID) external;\n', '    function approveLoan(uint _loanID) external;\n', '    function rewardHoldersByVotePower() external;\n', '    function distributeFee() external;\n', '    function vote(uint _loanID, uint _votePower, bool _accept) external;\n', '    function voteinCompany(address _company, uint _votePower, bool _accept) external;\n', '    function createRequest(uint _requestType, uint _changeTo, string calldata _reason, bool _withdrawEGR) external;\n', '    function governanceVote(uint _requestType, uint _requestID, uint _votePower, bool _accept) external;\n', '    function validateRequest(uint _requestID) external;\n', '    \n', '}\n', '\n', '// File: contracts\\EgorasLending.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.4.0 <0.7.0;\n', '\n', '\n', '\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view  returns (uint256);\n', '    function balanceOf(address account) external view  returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external  returns (bool);\n', '    function allowance(address owner, address spender) external  view returns (uint256);\n', '    function approve(address spender, uint256 amount) external  returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount)  external  returns (bool);\n', '    function mint(address account, uint256 amount) external  returns (bool);\n', '    function burnFrom(address account, uint256 amount) external;\n', '}\n', '\n', 'contract EgorasMicrofinance is EgorasMicrofinanceInterface {\n', '    mapping(uint => bool) activeRequest;\n', '    mapping(uint => mapping(address => uint)) requestPower;\n', '    mapping(address => mapping(address => uint)) VoteInCompanyPower;\n', '    uint private totalLoans;\n', '    uint private loanInterestRate;\n', '    mapping(address => Company) company;\n', '    mapping (address => bool) companyExist;\n', '    struct Votters{\n', '      address payable voter;\n', '    }\n', '    \n', '     struct Requests{\n', '      address creator;\n', '      uint requestType;\n', '      uint changeTo;\n', '      string reason;\n', '      uint positiveVote;\n', '      uint negativeVote;\n', '      uint powerUsed;\n', '      bool  withdrawEGR;\n', '      bool stale;\n', '      uint votingPeriod;\n', '    }\n', '    \n', '    Requests[] requests;\n', '    mapping(uint => Requests[]) listOfrequests;\n', '    mapping(uint => Votters[]) listOfvoters;\n', '    mapping(uint => Votters[]) etherActiveVotters;\n', '    mapping(uint => Votters[]) activeVoters;\n', '    mapping(uint => Votters[]) activeRequestVoters;\n', '    mapping(address => Votters[]) activeLoanCompanyVoters;\n', '    mapping(uint => mapping(address => bool)) hasVoted;\n', '    mapping(uint => mapping(address => bool)) manageRequestVoters;\n', '    mapping(address => mapping(address => bool)) manageLoanCompanyVoters;\n', '    mapping(address => mapping(uint => bool)) isCurrentVotter;\n', '    mapping(address => mapping(uint => bool)) isCurrentEtherVotter;\n', '    mapping(uint => bool) stale;\n', '    mapping(uint => mapping(address => uint)) votePower;\n', '    mapping(address => uint) totalVotePower;\n', '    mapping(uint => uint) positiveVote;\n', '    mapping(uint => uint) voteCountDown;\n', '    mapping(uint => uint) negativeVote;\n', '    mapping (uint => bool) isLoanApproved;\n', '    mapping(uint => uint) currentTotalVotePower;\n', '    mapping(uint => uint) currentTotalVotePower2;\n', '    uint public nextClaimDate;\n', '    mapping(address => mapping(uint => uint)) userCurrentVotePower;\n', '    mapping(address => mapping(uint => uint)) userCurrentVotePower2;\n', '    Loan[] loans;\n', '    Votters[] voters;\n', '    using SafeMath for uint256;\n', '    address private NGNC;\n', '    address private egorasEGR;\n', '    uint private loanFee;\n', '    uint private systemFeeBalance;\n', '     \n', '    uint private currentVotingPeriod;\n', '    uint private requestCreationPower;\n', '    uint private currentEtherVotingPeriod;\n', '    uint public totalIncentive;\n', '    uint public weeklyIncentive;\n', '    uint public treasuryCut;\n', '    constructor(address _NGNC, address _egorasEgr, uint _initialLoanFee, uint _totalIncentive, uint _weeklyIncentive, uint _initialRequestPower\n', '    , uint _treasuryCut)  public {\n', '        egorasEGR = _egorasEgr;\n', '        NGNC = _NGNC;\n', '        loanFee = _initialLoanFee;\n', '        currentVotingPeriod = currentVotingPeriod.add(1);\n', '        currentEtherVotingPeriod = currentEtherVotingPeriod.add(1);\n', '        totalIncentive = _totalIncentive;\n', '        weeklyIncentive = _weeklyIncentive;\n', '        nextClaimDate = block.timestamp.add(8 days);\n', '        requestCreationPower = _initialRequestPower;\n', '        treasuryCut = _treasuryCut;\n', '    }\n', '\n', '/// Request\n', 'function createRequest(uint _requestType, uint _changeTo, string memory _reason, bool _withdrawEGR) public override{\n', '    require(_requestType == 0 || _requestType == 1 || _requestType == 2,  "Invalid request type!");\n', '    require(!activeRequest[_requestType], "Another request is still active");\n', '    IERC20 iERC20 = IERC20(egorasEGR);\n', '    require(iERC20.allowance(msg.sender, address(this)) >= requestCreationPower, "Insufficient EGR allowance for vote!");\n', '    iERC20.transferFrom(msg.sender, address(this), requestCreationPower);\n', '    Requests memory _request = Requests({\n', '      creator: msg.sender,\n', '      requestType: _requestType,\n', '      changeTo: _changeTo,\n', '      reason: _reason,\n', '      positiveVote: 0,\n', '      negativeVote: 0,\n', '      powerUsed: requestCreationPower,\n', '      withdrawEGR: _withdrawEGR,\n', '      stale: false,\n', '      votingPeriod: block.timestamp.add(3 days)\n', '    });\n', '    \n', '    requests.push(_request);\n', '    uint256 newRequestID = requests.length - 1;\n', '     Requests memory request = requests[newRequestID];\n', '    emit RequestCreated(\n', '      request.creator,\n', '      request.requestType,\n', '      request.changeTo,\n', '      request.reason,\n', '      request.positiveVote,\n', '      request.negativeVote,\n', '      request.powerUsed,\n', '      request.stale,\n', '      request.votingPeriod,\n', '      newRequestID\n', '      );\n', '}\n', '\n', 'function governanceVote(uint _requestType, uint _requestID, uint _votePower, bool _accept) public override{\n', '    Requests storage request = requests[_requestID];\n', '    require(request.votingPeriod >= block.timestamp, "Voting period ended");\n', '    require(_votePower > 0, "Power must be greater than zero!");\n', '    require(_requestType == 0 || _requestType == 1 || _requestType == 2,  "Invalid request type!");\n', '    IERC20 iERC20 = IERC20(egorasEGR);\n', '    require(iERC20.allowance(msg.sender, address(this)) >= _votePower, "Insufficient EGR allowance for vote!");\n', '    iERC20.transferFrom(msg.sender, address(this), _votePower);\n', '    requestPower[_requestType][msg.sender] = requestPower[_requestType][msg.sender].add(_votePower);\n', '     \n', '     \n', '       if(_accept){\n', '            request.positiveVote = request.positiveVote.add(_votePower);\n', '        }else{\n', '            request.negativeVote = request.negativeVote.add(_votePower);  \n', '        }\n', '      \n', '           \n', '            if(manageRequestVoters[_requestID][msg.sender] == false){\n', '                manageRequestVoters[_requestID][msg.sender] = true;\n', '                activeRequestVoters[_requestID].push(Votters(msg.sender));\n', '            }\n', '       \n', '           updateVotingStats(_votePower, msg.sender);\n', '    \n', '    emit VotedForRequest(msg.sender, _requestID, request.positiveVote, request.negativeVote, _accept);\n', '    \n', '}\n', '\n', 'function validateRequest(uint _requestID) public override{\n', '    Requests storage request = requests[_requestID];\n', '    require(block.timestamp >= request.votingPeriod, "Voting period still active");\n', '    require(!request.stale, "This has already been validated");\n', '    IERC20 ngnc = IERC20(NGNC);\n', '    IERC20 egr = IERC20(egorasEGR);\n', '    if(request.requestType == 0){\n', '        if(request.positiveVote >= request.negativeVote){\n', '            loanFee = request.changeTo;\n', '            request.stale = true;\n', '            \n', '        }\n', '        \n', '    }else if(request.requestType == 1){\n', '        if(request.positiveVote >= request.negativeVote){\n', '            requestCreationPower = request.changeTo;\n', '            request.stale = true;\n', '            \n', '            \n', '        }\n', '        \n', '    }else if(request.requestType == 2){\n', '        if(request.positiveVote >= request.negativeVote){\n', '            if(request.withdrawEGR){\n', '               require(egr.transfer(request.creator, request.changeTo), "Fail to transfer fund");\n', '               }else{\n', '                require(ngnc.transfer(request.creator, request.changeTo), "Fail to transfer fund");\n', '               }\n', '            \n', '            request.stale = true;\n', '            \n', '        }\n', '    }\n', '    \n', '   \n', '    \n', '   \n', '    \n', '    for (uint256 i = 0; i < activeRequestVoters[_requestID].length; i++) {\n', '           address voterAddress = activeRequestVoters[_requestID][i].voter;\n', '           uint amount = requestPower[request.requestType][voterAddress];\n', '           require(egr.transfer(voterAddress, amount), "Fail to refund voter");\n', '           requestPower[request.requestType][voterAddress] = 0;\n', '           emit Refunded(amount, voterAddress, _requestID, now);\n', '    }\n', '    \n', '     require(egr.transfer(request.creator, request.powerUsed), "Fail to transfer fund");\n', '    emit ApproveRequest(_requestID, request.positiveVote >= request.negativeVote, msg.sender);\n', '}\n', '  // Loan\n', '\n', '    function applyForLoan(\n', '        uint _amount,\n', '        string memory _title,\n', '        uint _length,\n', '        string memory _image_url\n', '        ) public override {\n', '            require(_amount > 0, "Loan amount should be greater than zero");\n', '            require(_length > 0, "Loan duration should be greater than zero");\n', '            require(bytes(_title).length > 3, "Loan title should more than three characters long");\n', '            require(companyExist[msg.sender], "Company does not exist");\n', '            Company memory comp = company[msg.sender];\n', '            require(comp.isApproved, "This company is not eligible to create loan!");\n', '            string memory name_of_loan_company = company[msg.sender].companyName;\n', '            uint getTotalWeeks = _length.div(6);\n', '            uint amount = _amount.div(getTotalWeeks);\n', '            uint fee = uint(int256(amount) / int256(10000) * int256(loanFee));\n', '            uint  weekly_payment = fee.add(amount);\n', '         Loan memory _loan = Loan({\n', '         amount: _amount,\n', '         title: _title,\n', '         length: _length,\n', '         min_weekly_returns: weekly_payment,\n', '         total_returns: weekly_payment.mul(getTotalWeeks),\n', '         image_url: _image_url,\n', '         companyName: name_of_loan_company,\n', '         totalWeeks: getTotalWeeks,\n', '         numWeekspaid: 0,\n', '         totalPayment: 0,\n', '         isApproved: false,\n', '         loanFee: loanFee,\n', '         creator: msg.sender\n', '        });\n', '             loans.push(_loan);\n', '             uint256 newLoanID = loans.length - 1;\n', '             voteCountDown[newLoanID] = block.timestamp.add(3 days);\n', '             emit LoanCreated(newLoanID, _amount, _title, _length, weekly_payment, weekly_payment.mul(getTotalWeeks),_image_url,  name_of_loan_company, getTotalWeeks, loanFee, block.timestamp.add(3 days), msg.sender);\n', '        }\n', '\n', '    function getLoanByID(uint _loanID) external override view returns(uint _amount, uint _min_weekly_returns, uint _totalWeeks, \n', '    uint _length, string memory _title, uint _total_returns, string memory _image_url, string memory _companyName, uint _numWeekspaid, uint _totalPayment, bool _isApproved, address _creator){\n', '         Loan memory loan = loans[_loanID];\n', '         return (loan.amount, loan.min_weekly_returns,loan.totalWeeks, loan.length, \n', '         loan.title, loan.total_returns, loan.image_url, loan.companyName, loan.numWeekspaid, loan.totalPayment, loan.isApproved,\n', '          loan.creator);\n', '     }\n', '     \n', '     function getVotesByLoanID(uint _loanID) external override view returns(uint _accepted, uint _declined){\n', '            return (positiveVote[_loanID], negativeVote[_loanID]);\n', '        }\n', '\n', 'function vote(uint _loanID, uint _votePower, bool _accept) external override{\n', '            require(_votePower > 0, "Power must be greater than zero!");\n', '            IERC20 iERC20 = IERC20(egorasEGR);\n', '            require(iERC20.allowance(msg.sender, address(this)) >= _votePower, "Insufficient EGR allowance for vote!");\n', '            iERC20.transferFrom(msg.sender, address(this), _votePower);\n', '            if(_accept){\n', '                positiveVote[_loanID] = positiveVote[_loanID].add(_votePower);\n', '            }else{\n', '              negativeVote[_loanID] = negativeVote[_loanID].add(_votePower);  \n', '            }\n', '            \n', '             \n', '             votePower[_loanID][msg.sender] = votePower[_loanID][msg.sender].add(_votePower);\n', '           \n', '           \n', '            if(hasVoted[_loanID][msg.sender] == false){\n', '                hasVoted[_loanID][msg.sender] = true;\n', '                listOfvoters[_loanID].push(Votters(msg.sender));\n', '            }\n', '          updateVotingStats(_votePower, msg.sender);\n', '     \n', '            \n', '            emit Voted(msg.sender, _loanID,  positiveVote[_loanID],negativeVote[_loanID], _accept);\n', '    } \n', '       \n', 'function repayLoan(uint _loanID) external override{\n', '   Loan storage loan = loans[_loanID];\n', '   require(loan.isApproved, "This loan is not approved yet.");\n', '   require(loan.creator == msg.sender, "Unauthorized.");\n', '   IERC20 iERC20 = IERC20(NGNC);\n', '   require(loan.totalWeeks > loan.numWeekspaid, "The loan fully paid!");\n', '   uint fee = uint(int256(loan.min_weekly_returns) / int256(10000) * int256(loan.loanFee));\n', '   require(iERC20.allowance(msg.sender, address(this)) >= loan.min_weekly_returns, "Insufficient EUSD allowance for repayment!");\n', '   require(iERC20.transferFrom(msg.sender, address(this), fee), "Fail to transfer");\n', '   iERC20.burnFrom(msg.sender, loan.min_weekly_returns.sub(fee));\n', '   loan.totalPayment = loan.totalPayment.add(loan.min_weekly_returns);\n', '  \n', '   systemFeeBalance = systemFeeBalance.add(fee);\n', '   loan.numWeekspaid = loan.numWeekspaid.add(1);\n', '   emit Repay(loan.min_weekly_returns, now, loan.numWeekspaid, _loanID);\n', '}\n', '\n', 'function approveLoan(uint _loanID) external override{\n', '     require(isDue(_loanID), "Voting is not over yet!");\n', '     require(!stale[_loanID], "The loan is either approve/declined");\n', '     bool state = false;\n', '     Loan storage loan = loans[_loanID];\n', '     IERC20 ngnc = IERC20(NGNC);\n', '     IERC20 egr = IERC20(egorasEGR);\n', '     if(positiveVote[_loanID] > negativeVote[_loanID]){\n', '     require(ngnc.mint(loan.creator, loan.amount), "Fail to transfer fund");\n', '     loan.isApproved = true;\n', '     state = true;\n', '     }\n', '    \n', '    for (uint256 i = 0; i < listOfvoters[_loanID].length; i++) {\n', '           address voterAddress = listOfvoters[_loanID][i].voter;\n', '           uint amount = votePower[_loanID][voterAddress];\n', '           require(egr.transfer(voterAddress, amount), "Fail to refund voter");\n', '           emit Refunded(amount, voterAddress, _loanID, now);\n', '    }\n', '    \n', '    stale[_loanID] = true;\n', '    ApproveLoan(_loanID, state, msg.sender, now);\n', '}\n', '\n', '\n', '// Company\n', '\n', '        function registerLoanCompany(string calldata _companyName) external override{\n', '            require(!companyExist[msg.sender], "Company already exist!");\n', '            Company storage comp = company[msg.sender];\n', '            uint countDown = block.timestamp.add(3 days);\n', '            comp.isApproved = false;\n', '            comp.companyName = _companyName;\n', '            comp.registeredDate = now;\n', '            comp.votingPeriod = countDown;\n', '            companyExist[msg.sender] = true;\n', '            emit CompanyCreated(msg.sender, _companyName, countDown);\n', '        }\n', '\n', '        function approveLoanCompany(address companyAddress) external override{\n', '            require(companyExist[companyAddress], "Company does not exist!");\n', '            bool state = false;\n', '            Company storage comp = company[companyAddress];\n', '            IERC20 egr = IERC20(egorasEGR);\n', '           require( block.timestamp >= comp.votingPeriod, "Voting period still active");\n', '            require(!comp.stale, "This has already been validated");\n', '            if(comp.positiveVote >= comp.negativeVote){\n', '                comp.isApproved = true;\n', '                state = true;\n', '            }\n', '            \n', '            for (uint256 i = 0; i < activeLoanCompanyVoters[companyAddress].length; i++) {\n', '                address voterAddress = activeLoanCompanyVoters[companyAddress][i].voter;\n', '                uint amount = VoteInCompanyPower[companyAddress][voterAddress];\n', '                require(egr.transfer(voterAddress, amount), "Fail to refund voter");\n', '            }\n', '            comp.stale = true;\n', '            emit CompanyApproved(companyAddress, now, state, msg.sender);\n', '              \n', '\n', '        }\n', '\n', '\n', '\n', '\n', '        \n', '   \n', '        \n', '        \n', '    function voteinCompany(address _company, uint _votePower, bool _accept) external override{\n', '           require(_votePower > 0, "Power must be greater than zero!");   \n', '            IERC20 iERC20 = IERC20(egorasEGR);\n', '            require(iERC20.allowance(msg.sender, address(this)) >= _votePower, "Insufficient EGR allowance for vote!");\n', '             iERC20.transferFrom(msg.sender, address(this), _votePower);\n', '             Company storage comp = company[_company];\n', '              if(_accept){\n', '                comp.positiveVote = comp.positiveVote.add(_votePower);\n', '            }else{\n', '              comp.negativeVote = comp.negativeVote.add(_votePower);  \n', '            }\n', '            \n', '               VoteInCompanyPower[_company][msg.sender] = VoteInCompanyPower[_company][msg.sender].add(_votePower);\n', '               if(manageLoanCompanyVoters[_company][msg.sender] == false){\n', '                manageLoanCompanyVoters[_company][msg.sender] = true;\n', '                activeLoanCompanyVoters[_company].push(Votters(msg.sender));\n', '            }\n', '            \n', '           updateVotingStats(_votePower, msg.sender);\n', '           \n', '           emit VoteInCompany(_company,msg.sender, _accept, comp.negativeVote, comp.positiveVote);\n', '            \n', '    }\n', '    \n', '     \n', '\n', '\n', '\n', ' function updateVotingStats(uint _power, address payable _voter) private {\n', '      currentTotalVotePower[currentVotingPeriod] = currentTotalVotePower[currentVotingPeriod].add(_power);\n', '      userCurrentVotePower[_voter][currentVotingPeriod] = userCurrentVotePower[_voter][currentVotingPeriod].add(_power);\n', '      currentTotalVotePower2[currentEtherVotingPeriod] = currentTotalVotePower2[currentEtherVotingPeriod].add(_power);\n', '      userCurrentVotePower2[_voter][currentEtherVotingPeriod] = userCurrentVotePower2[_voter][currentEtherVotingPeriod].add(_power);\n', '             if(isCurrentEtherVotter[_voter][currentEtherVotingPeriod] == false){\n', '                etherActiveVotters[currentEtherVotingPeriod].push(Votters(_voter));\n', '            }\n', '       \n', '        if(isCurrentVotter[_voter][currentVotingPeriod] == false){\n', '                activeVoters[currentVotingPeriod].push(Votters(_voter));\n', '            }\n', '            \n', '         totalVotePower[_voter] = totalVotePower[_voter].add(_power);\n', '          \n', ' }     \n', '\n', '\n', 'function claimable() public override view returns (bool) {\n', '        if (block.timestamp >= nextClaimDate)\n', '            return true;\n', '        else\n', '            return false;\n', '    }\n', '\n', 'function isDue(uint _loanID) public override view returns (bool) {\n', '        if (block.timestamp >= voteCountDown[_loanID])\n', '            return true;\n', '        else\n', '            return false;\n', '    }\n', '\n', 'function rewardHoldersByVotePower() external override{\n', '      IERC20 iERC20 = IERC20(egorasEGR);\n', '       require(claimable(), "Not yet time for reward");\n', '       uint treasuryShare = uint(int256(weeklyIncentive) / int256(10000) * int256(treasuryCut));\n', '       uint votersShare = weeklyIncentive.sub(treasuryShare);\n', '       require(totalIncentive >= treasuryShare, "No incentive left for distribution");\n', '       \n', '      for (uint256 i = 0; i < activeVoters[currentVotingPeriod].length; i++) {\n', '            address _voter = activeVoters[currentVotingPeriod][i].voter;\n', '            uint totalUserVotePower = userCurrentVotePower[_voter][currentVotingPeriod].mul(1000);\n', '            uint currentTotalPower = currentTotalVotePower[currentVotingPeriod];\n', '            uint percentage = totalUserVotePower.div(currentTotalPower);\n', '            uint share = percentage.mul(votersShare).div(1000);\n', '            require(totalIncentive >= share, "No incentive left for distribution");\n', '            require(iERC20.mint(_voter, share), "Unable to mint token");\n', '            totalIncentive = totalIncentive.sub(share);\n', '            emit Rewarded(_voter, share, currentVotingPeriod, now);\n', '            \n', '        }\n', '        require(iERC20.mint(address(this), treasuryShare), "Unable to mint token");\n', '        \n', '         currentVotingPeriod = currentVotingPeriod.add(1);\n', '         nextClaimDate = block.timestamp.add(8 days);\n', '}\n', '\n', 'function distributeFee() external override{ \n', '    uint minEther =  1 ether;\n', '    uint balance = address(this).balance;\n', '    require(balance >= minEther, "Not enough balance");\n', '\n', '        for (uint256 i = 0; i < etherActiveVotters[currentEtherVotingPeriod].length; i++) {\n', '            address payable _voter = etherActiveVotters[currentVotingPeriod][i].voter;\n', '            uint totalUserVotePower = userCurrentVotePower2[_voter][currentEtherVotingPeriod].mul(1000);\n', '            uint currentTotalPower = currentTotalVotePower[currentEtherVotingPeriod];\n', '            uint percentage = totalUserVotePower.div(currentTotalPower);\n', '            uint share = percentage.mul(balance).div(1000);\n', '            require(balance >= share, "Non-sufficient funds");\n', '           _voter.transfer(share);\n', '            \n', '            emit Rewarded(_voter, share, currentVotingPeriod, now);\n', '            \n', '        }\n', '        \n', '         currentEtherVotingPeriod = currentEtherVotingPeriod.add(1);\n', '         \n', '}\n', 'function depositEther() public payable {\n', '}\n', '\n', 'function systemInfo() public view  returns(uint _requestpower, uint _loanFee, uint _totalIncentive, uint _weeklyIncentive ,  uint _treasuryCut, uint _nextClaimDate){\n', '    return(requestCreationPower, loanFee, totalIncentive, weeklyIncentive, treasuryCut, nextClaimDate);\n', '}\n', '\n', '}']