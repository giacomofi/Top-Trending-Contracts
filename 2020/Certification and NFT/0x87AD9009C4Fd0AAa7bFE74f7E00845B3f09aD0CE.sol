['// File: util\\IERC165.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.4;\n', '\n', 'interface IERC165 {\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: util\\IERC1155Receiver.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.4;\n', '\n', '\n', 'interface IERC1155Receiver is IERC165 {\n', '\n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '\n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '}\n', '\n', '// File: IWhereIsMyDragon.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.4;\n', '\n', '\n', 'interface IWhereIsMyDragon is IERC1155Receiver {\n', '    function opt() external view returns(address);\n', '\n', '    function get() external;\n', '}\n', '\n', '// File: util\\ERC165.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.4;\n', '\n', '\n', 'abstract contract ERC165 is IERC165 {\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor () {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    function _registerInterface(bytes4 interfaceId) internal virtual {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '// File: util\\IEthItem.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.4;\n', '\n', 'interface IEthItem {\n', '\n', '    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n', '\n', '    function burnBatch(\n', '        uint256[] calldata objectIds,\n', '        uint256[] calldata amounts\n', '    ) external;\n', '}\n', '\n', '// File: WhereIsMyDragon.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.4;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Where Is My Dragon\n', ' * In this Contract yoy can find all the ruleHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAH!!!!\n', ' */\n', 'contract WhereIsMyDragon is IWhereIsMyDragon, ERC165 {\n', '\n', '    uint256 private constant RAG = 0x172 - 0x16f;\n', '\n', '    address private _san;\n', '    address private _frid;\n', '\n', '    mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256)))))) private _bor;\n', '    mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256)))))) private _lid;\n', '\n', '    uint256 private _baskin;\n', '    uint256 private _dolbur;\n', '    uint256[] private _sagar;\n', '    bool[] private _franco;\n', '\n', '    uint256 private _gel;\n', '    uint256 private _sic;\n', '\n', '    constructor(address mon, uint256 tue, uint256 wed, uint256[] memory thru, uint256 fri) ERC165() {\n', '        _san = msg.sender;\n', '        _frid = mon;\n', '        _baskin = tue;\n', '        _dolbur = wed;\n', '        _sagar = thru;\n', '        _gel = fri;\n', '        for(uint256 i = 0; i < _sagar.length; i++) {\n', '            _franco.push(false);\n', '        }\n', '        _parabara();\n', '    }\n', '\n', '    function _parabara() private {\n', '        _registerInterface(this.onERC1155BatchReceived.selector);\n', '    }\n', '\n', '    function opt() public view override returns(address) {\n', '        return _san;\n', '    }\n', '\n', '    function get() public override {\n', '        require(msg.sender == _san);\n', '        _san = address(0);\n', '    }\n', '\n', '    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns(bytes4) {\n', '        revert();\n', '    }\n', '\n', '    function onERC1155BatchReceived(\n', '        address,\n', '        address fal,\n', '        uint256[] memory cik,\n', '        uint256[] memory hse,\n', '        bytes memory cas\n', '    ) public virtual override returns (bytes4) {\n', '        require(msg.sender == _frid);\n', '        if(_san != address(0)) {\n', '            (uint256[] memory zik, uint256[] memory bol) = abi.decode(cas, (uint256[], uint256[]));\n', '            _doz(fal, cik, zik, bol);\n', '        } else {\n', '            _dabor(fal, cik, hse, block.number);\n', '        }\n', '        return this.onERC1155BatchReceived.selector;\n', '    }\n', '\n', '    function _doz(address fal, uint256[] memory cik, uint256[] memory zik, uint256[] memory bol) private {\n', '        require(fal == _san);\n', '        require(zik.length >= RAG && ((zik.length % RAG) == 0));\n', '        require((zik.length / RAG) == cik.length);\n', '        require(zik.length == bol.length);\n', '        for(uint256 i = 0 ; i < zik.length; i+= RAG) {\n', '            uint256 mat = i / RAG;\n', '            (uint256 bil, uint256 cul, uint256 mar) = _moler(zik, i);\n', '            _bor\n', '                [zik[bil]][bol[bil]]\n', '                [zik[cul]][bol[cul]]\n', '                [zik[mar]][bol[mar]] = cik[mat];\n', '\n', '            if(cik[mat] == _gel) {\n', '                _lid\n', '                    [zik[bil]][bol[bil]]\n', '                    [zik[cul]][bol[cul]]\n', '                    [zik[mar]][bol[mar]] = _sic++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function _dabor(address fal, uint256[] memory cik, uint256[] memory hse, uint256 sog) private {\n', '        require(_san == address(0));\n', '        require(cik.length >= RAG && ((cik.length % RAG) == 0));\n', '        for(uint256 i = 0; i < cik.length; i+= RAG) {\n', '            (uint256 bil, uint256 cul, uint256 mar) = _moler(cik, i);\n', '\n', '            uint256 ter = _bor\n', '                                [cik[bil]][hse[bil]]\n', '                                [cik[cul]][hse[cul]]\n', '                                [cik[mar]][hse[mar]];\n', '            _sop(cik, hse, bil, cul, mar, ter, sog);\n', '            _irn(cik, hse, bil, cul, mar);\n', '            IEthItem(_frid).safeTransferFrom(address(this), fal, ter, 1, "");\n', '        }\n', '    }\n', '\n', '    function _sop(uint256[] memory cik, uint256[] memory hse, uint256 bil, uint256 cul, uint256 mar, uint256 ter, uint256 gis) private {\n', '        if(ter != _gel) {\n', '            return;\n', '        }\n', '        uint256 postadel = _lid\n', '            [cik[bil]][hse[bil]]\n', '            [cik[cul]][hse[cul]]\n', '            [cik[mar]][hse[mar]];\n', '        require(!_franco[postadel]);\n', '        uint256 lav = _sagar[postadel];\n', '        require(gis >= lav);\n', '        uint256 sch = gis - lav;\n', '        uint256 acq = sch / _baskin;\n', '        uint256 lov = lav + (_baskin * acq);\n', '        uint256 gel = lov + _dolbur;\n', '        require(gis >= lov && gis <= gel);\n', '        _franco[postadel] = true;\n', '    }\n', '\n', '    function _irn(uint256[] memory cik, uint256[] memory hse, uint256 bil, uint256 cul, uint256 mar) private {\n', '        uint256[] memory ids = new uint256[](RAG);\n', '        ids[0] = cik[bil];\n', '        ids[1] = cik[cul];\n', '        ids[2] = cik[mar];\n', '        uint256[] memory amts = new uint256[](RAG);\n', '        amts[0] = hse[bil];\n', '        amts[1] = hse[cul];\n', '        amts[2] = hse[mar];\n', '        IEthItem(_frid).burnBatch(ids, amts);\n', '    }\n', '\n', '    function _moler(uint256[] memory sus, uint256 tfo) private pure returns(uint256 bil, uint256 cul, uint256 mar) {\n', '        bil = tfo;\n', '        mar = tfo;\n', '        for(uint256 i = tfo; i < tfo + RAG; i++) {\n', '            if(sus[i] < sus[bil]) {\n', '                bil = i;\n', '            } else if(sus[i] > sus[mar]) {\n', '                mar = i;\n', '            }\n', '        }\n', '        for(uint256 i = tfo; i < tfo + RAG; i++) {\n', '            if(i != mar && i != bil) {\n', '                cul = i;\n', '                break;\n', '            }\n', '        }\n', '    }\n', '}']