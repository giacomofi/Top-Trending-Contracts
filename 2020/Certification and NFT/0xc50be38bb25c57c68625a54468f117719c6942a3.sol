['pragma solidity 0.5.16;\n', '\n', 'interface ERC20Interface {\n', '  function transfer(address to, uint value) external returns(bool success);\n', '  function transferFrom(address _from, address _to, uint256 value)  external returns(bool success);\n', '  function Exchange_Price() external view returns(uint256 actual_Price);\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '}\n', '\n', 'contract WealthBuilder_M1 {\n', '  struct User {\n', '    bool isExist;\n', '    uint ID;\n', '    uint ReferrerID;\n', '    uint SponsorID;\n', '    uint SubscriptionTime;\n', '    uint64 ReferralCount;\n', '    uint64 LvL1Count;\n', '    uint64 LvL2Count;\n', '    uint64 LvL3Count;\n', '    uint64 LvL4Count;\n', '    address[] Referrals;\n', '    address[] Line1Referrals;\n', '    address[] Line2Referrals;\n', '    address[] Line3Referrals;\n', '    address[] Line4Referrals;\n', '    mapping (uint8 => uint) LevelExpiresAt;\n', '  }\n', '  struct Token_Reward {\n', '    uint Total;\n', '    uint8[]   Rewardtype;\n', '    address[] ReferralAddr;\n', '    uint256[] Amount;\n', '    uint256[] RewardedAt;\n', '  }\n', '  struct ETH_Reward {\n', '    uint Total;\n', '    uint8[]   Rewardtype;\n', '    address[] ReferralAddr;\n', '    uint256[] Amount;\n', '    uint256[] RewardedAt;\n', '  }\n', '  struct Purchased_Upgrade {\n', '    uint Total;\n', '    uint[]    pDate;\n', '    uint8[]   LvL;\n', '    uint32[]  EduPkg;\n', '  }\n', '\n', '  address public WBC_Wallet;\n', '  uint256 public adminCount;\n', '  uint  public MAX_LEVEL = 9;\n', '  uint public REFERRALS_LIMIT = 2;\n', '  uint public LEVEL_EXPIRE_TIME = 30 days;\n', '  uint256 public TOKEN_PRICE = 0.001 ether;\n', '  uint64 public currUserID = 0;\n', '  uint8 public Loyalty_TokenReward;\n', '  address public TOKEN_SC;\n', '  address public TOKEN_ATM;\n', '  address public TOKEN_EXCHNG;\n', '  address[] public adminListed;\n', '  mapping(address => User) public USERS;\n', '  mapping(uint256 => address) public USER_ADDRESS;\n', '  mapping(uint8 => uint256) public UPGRADE_PRICE;\n', '  mapping(uint8 => uint8) public SPONSOR_REWARD;\n', '  mapping(address => Purchased_Upgrade) public UPGRADE_PURCHASED;\n', '  mapping(address => Token_Reward) public LOYALTY_BONUS;\n', '  mapping(address => ETH_Reward) public SPONSOR_BONUS;\n', '  mapping(address => uint256) public TOKEN_DEPOSITS;\n', '\n', '  modifier validLevelAmount(uint8 _level) {\n', "    require(msg.value == UPGRADE_PRICE[_level], 'Invalid level amount sent');\n", '    _;\n', '  }\n', '\n', '  modifier userRegistered() {\n', "    require(USERS[msg.sender].ID != 0, 'User does not exist');\n", "    require(USERS[msg.sender].isExist, 'User does not exist');\n", '    _;\n', '  }\n', '  modifier validReferrerID(uint _referrerID) {\n', "    require(_referrerID > 0 && _referrerID <= currUserID, 'Invalid referrer ID');\n", '    _;\n', '  }\n', '\n', '  modifier userNotRegistered() {\n', "    require(USERS[msg.sender].ID == 0, 'User is already registered');\n", "    require(!USERS[msg.sender].isExist, 'User does not exist');\n", '    _;\n', '  }\n', '\n', '  modifier validLevel(uint _level) {\n', "    require(_level > 0 && _level <= MAX_LEVEL, 'Invalid level entered');\n", '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    TOKEN_SC = 0x79C90021A36250BcE01f11CFd847Ba30E05488B1;\n', '    TOKEN_ATM = 0x12e26F7eEfF0602232b03a086343e9eF20825ec3;\n', '    TOKEN_EXCHNG = 0x12e26F7eEfF0602232b03a086343e9eF20825ec3;\n', '    WBC_Wallet = msg.sender;\n', '    adminListed.push(msg.sender);\n', '    adminCount = 1;\n', '    UPGRADE_PRICE[1] = 0.05 ether;\n', '    UPGRADE_PRICE[2] = 0.1 ether;\n', '    UPGRADE_PRICE[3] = 0.5 ether;\n', '    UPGRADE_PRICE[4] = 1 ether;\n', '    UPGRADE_PRICE[5] = 1.5 ether;\n', '    UPGRADE_PRICE[6] = 3 ether;\n', '    UPGRADE_PRICE[7] = 7 ether;\n', '    UPGRADE_PRICE[8] = 16 ether;\n', '    UPGRADE_PRICE[9] = 34 ether;\n', '\n', '    Loyalty_TokenReward = 23;\n', '\n', '    SPONSOR_REWARD[1] = 20;\n', '    SPONSOR_REWARD[2] = 10;\n', '    SPONSOR_REWARD[3] = 5;\n', '    SPONSOR_REWARD[4] = 2;\n', '\n', '    addUser(msg.sender,1,1);\n', '    for (uint8 i = 1; i <= MAX_LEVEL; i++) {\n', '    USERS[msg.sender].LevelExpiresAt[i] = 88888888888;\n', '    }\n', '   }\n', '\n', '  function () external payable {\n', '    uint8 level;\n', '    if(msg.value == UPGRADE_PRICE[1]) level = 1;\n', '    else if(msg.value == UPGRADE_PRICE[2]) level = 2;\n', '    else if(msg.value == UPGRADE_PRICE[3]) level = 3;\n', '    else if(msg.value == UPGRADE_PRICE[4]) level = 4;\n', '    else if(msg.value == UPGRADE_PRICE[5]) level = 5;\n', '    else if(msg.value == UPGRADE_PRICE[6]) level = 6;\n', '    else if(msg.value == UPGRADE_PRICE[7]) level = 7;\n', '    else if(msg.value == UPGRADE_PRICE[8]) level = 8;\n', '    else if(msg.value == UPGRADE_PRICE[9]) level = 9;\n', "    else revert('Incorrect Value send');\n", '    if(USERS[msg.sender].isExist) buyLevel(level,level);\n', '      else if(level == 1) {\n', '        uint refId = 1;\n', '        address referrer = bytesToAddress(msg.data);\n', '        if(USERS[referrer].isExist) refId = USERS[referrer].ID;\n', "            else revert('Incorrect referrer');\n", '        regUser(refId,1);\n', '        }\n', "        else revert('Please buy first level for 0.05 ETH');\n", '  }\n', '\n', '  function regUser(uint _referrerID, uint32 EduPkg) public payable userNotRegistered() validReferrerID(_referrerID) validLevelAmount(1){\n', '    uint sponsorUP1_ID = _referrerID;\n', '    address sponsorUP1 = USER_ADDRESS[sponsorUP1_ID];\n', '    address sponsorUP2 = USER_ADDRESS[USERS[sponsorUP1].SponsorID];\n', '    address sponsorUP3 = USER_ADDRESS[USERS[sponsorUP2].SponsorID];\n', '    address sponsorUP4 = USER_ADDRESS[USERS[sponsorUP3].SponsorID];\n', '\n', '    if(USERS[sponsorUP1].Referrals.length >= REFERRALS_LIMIT) {\n', '        _referrerID = USERS[findFreeReferrer(sponsorUP1)].ID;\n', '    }\n', '    addUser(msg.sender, sponsorUP1_ID, _referrerID);\n', '    USERS[msg.sender].LevelExpiresAt[1] = block.timestamp+LEVEL_EXPIRE_TIME;\n', '    USERS[USER_ADDRESS[_referrerID]].Referrals.push(msg.sender);\n', '\n', '    USERS[sponsorUP1].Line1Referrals.push(msg.sender);\n', '    USERS[sponsorUP2].Line2Referrals.push(msg.sender);\n', '    USERS[sponsorUP3].Line3Referrals.push(msg.sender);\n', '    USERS[sponsorUP4].Line4Referrals.push(msg.sender);\n', '\n', '    USERS[sponsorUP1].LvL1Count = USERS[sponsorUP1].LvL1Count+1;\n', '    USERS[sponsorUP2].LvL2Count = USERS[sponsorUP2].LvL2Count+1;\n', '    USERS[sponsorUP3].LvL3Count = USERS[sponsorUP3].LvL3Count+1;\n', '    USERS[sponsorUP4].LvL4Count = USERS[sponsorUP4].LvL4Count+1;\n', '\n', '    payMembers(msg.sender,sponsorUP1,sponsorUP2,sponsorUP3,sponsorUP4,1,EduPkg);\n', '    addReferrerCount(USER_ADDRESS[_referrerID]);\n', '  }\n', '\n', '  function addUser(address New_Member, uint256 SponsorID, uint256 ReferrerID ) internal {\n', '    currUserID++;\n', '    USERS[New_Member] = User({\n', '      isExist: true,\n', '      ID: currUserID,\n', '      ReferrerID: ReferrerID,\n', '      SponsorID: SponsorID,\n', '      ReferralCount: 0,\n', '      LvL1Count:0,\n', '      LvL2Count:0,\n', '      LvL3Count:0,\n', '      LvL4Count:0,\n', '      SubscriptionTime: block.timestamp,\n', '      Referrals: new address[](0),\n', '      Line1Referrals: new address[](0),\n', '      Line2Referrals: new address[](0),\n', '      Line3Referrals: new address[](0),\n', '      Line4Referrals: new address[](0)\n', '    });\n', '    USER_ADDRESS[currUserID] = New_Member;\n', '  }\n', '\n', '  function addReferrerCount(address Referrer) internal {\n', '    bool isFinished = false;\n', '    uint ID;\n', '    for(uint8 i = 1;i<=13;i++){\n', '        if(!isFinished){\n', '            USERS[Referrer].ReferralCount = USERS[Referrer].ReferralCount+1;\n', '            ID = USERS[Referrer].ID;\n', '            if(ID==1) {isFinished = true;}\n', '                else {Referrer = USER_ADDRESS[USERS[Referrer].ReferrerID];}\n', '            }\n', '        }\n', '    }\n', '\n', '  function buyLevel(uint8 _level, uint32 EduPkg) public payable validLevelAmount(_level) {\n', "    require(USERS[msg.sender].isExist, 'User not exist');\n", "    require(_level > 0 && _level <= 10, 'Incorrect level');\n", "    for(uint8 l = 1; l < _level ; l++) require(USERS[msg.sender].LevelExpiresAt[l] >= block.timestamp,'Buy the previous level');\n", '\n', '    address sponsorUP1 = USER_ADDRESS[USERS[msg.sender].SponsorID];\n', '    address sponsorUP2 = USER_ADDRESS[USERS[sponsorUP1].SponsorID];\n', '    address sponsorUP3 = USER_ADDRESS[USERS[sponsorUP2].SponsorID];\n', '    address sponsorUP4 = USER_ADDRESS[USERS[sponsorUP3].SponsorID];\n', '\n', '    USERS[msg.sender].LevelExpiresAt[_level] = block.timestamp+LEVEL_EXPIRE_TIME;\n', '    payMembers(msg.sender,sponsorUP1,sponsorUP2,sponsorUP3,sponsorUP4,_level,EduPkg);\n', '  }\n', '\n', '  function findFreeReferrer(address _user) public view returns (address) {\n', "    require(USERS[_user].isExist, 'User not exist');\n", '    if (USERS[_user].Referrals.length < REFERRALS_LIMIT) {\n', '      return _user;\n', '    }\n', '    address[16382] memory referrals;\n', '    referrals[0] = USERS[_user].Referrals[0];\n', '    referrals[1] = USERS[_user].Referrals[1];\n', '    address referrer;\n', '    for (uint16 i = 0; i < 16382; i++) {\n', '      if (USERS[referrals[i]].Referrals.length < REFERRALS_LIMIT) {\n', '        referrer = referrals[i];\n', '        break;\n', '      }\n', '      if (i >= 8190) {continue;}\n', '      referrals[(i+1)*2] = USERS[referrals[i]].Referrals[0];\n', '      referrals[(i+1)*2+1] = USERS[referrals[i]].Referrals[1];\n', '    }\n', "    require(referrer != address(0), 'Referrer not found');\n", '    return referrer;\n', '  }\n', '\n', '  function Reward_Loyality_Bonus(uint8 _level, address _user) internal returns(uint256 RewardedLoyalityBonus){\n', "    require(USERS[_user].isExist, 'User not exist');\n", '    uint _referrerID;\n', '    address _referrerAddr;\n', '    uint8 _referrerLevel;\n', '    address user = _user;\n', '    uint _uplines = _level+4;\n', '    uint _LevelReward = (UPGRADE_PRICE[_level]*Loyalty_TokenReward/100)/_uplines;\n', '    uint256 _amountToken = _LevelReward*(10**18)/TOKEN_PRICE;\n', '    uint256 rewardedUplines = 0;\n', '    for (uint8 i = 1; i <= _uplines; i++) {\n', '      _referrerID = USERS[user].ReferrerID;\n', '      _referrerAddr = USER_ADDRESS[_referrerID];\n', '      _referrerLevel = getUserLevel(_referrerAddr);\n', '      if( _referrerLevel < _level ) {\n', '        Write_Loyalty_Bonus(0, _referrerAddr, _user, _amountToken);\n', '      } else {\n', '        TOKEN_DEPOSITS[TOKEN_SC] = TOKEN_DEPOSITS[TOKEN_SC] - (_amountToken);\n', '        ERC20Interface ERC20Token = ERC20Interface(TOKEN_SC);\n', '        ERC20Token.transfer(_referrerAddr, _amountToken);\n', '        Write_Loyalty_Bonus(i, _referrerAddr, _user, _amountToken);\n', '        rewardedUplines += 1;\n', '      }\n', '    user = _referrerAddr;\n', '    }\n', '    RewardedLoyalityBonus = _LevelReward*rewardedUplines;\n', '    if (rewardedUplines>0){\n', '      bool send = false;\n', '      (send, ) = address(uint160(TOKEN_ATM)).call.value(RewardedLoyalityBonus)("");\n', '    }\n', '    return RewardedLoyalityBonus;\n', '  }\n', '\n', '  function Write_Loyalty_Bonus(uint8 _type, address _user, address _referralAddr, uint256 _reward ) internal {\n', '\t  LOYALTY_BONUS[_user].Rewardtype.push(_type);\n', '\t  LOYALTY_BONUS[_user].ReferralAddr.push(_referralAddr);\n', '\t  LOYALTY_BONUS[_user].Amount.push(_reward);\n', '\t  LOYALTY_BONUS[_user].RewardedAt.push(block.timestamp);\n', '  }\n', '\n', '  function Write_Sponsor_Bonus(uint8 _type, address _user, address _referralAddr, uint256 _reward ) internal {\n', '\t  SPONSOR_BONUS[_user].Rewardtype.push(_type);\n', '\t  SPONSOR_BONUS[_user].ReferralAddr.push(_referralAddr);\n', '\t  SPONSOR_BONUS[_user].Amount.push(_reward);\n', '\t  SPONSOR_BONUS[_user].RewardedAt.push(block.timestamp);\n', '  }\n', '\n', '  function paySponsor(address _user, address Sponsor,uint8 _level, uint8 _line, uint256 _remValue) internal returns(uint256 RemValue) {\n', '    uint256 _Price = UPGRADE_PRICE[_level];\n', '    uint256 _UPLevelReward = _Price*SPONSOR_REWARD[_line]/100;\n', '    bool send = false;\n', '    RemValue = _remValue;\n', '    if ( getUserLevel(Sponsor) >= _level ){\n', '      (send, ) = address(uint160(Sponsor)).call.value(_UPLevelReward)("");\n', '      Write_Sponsor_Bonus(_line,Sponsor,_user,_UPLevelReward);\n', '      RemValue = _remValue-_UPLevelReward;\n', '    } else {\n', '      Write_Sponsor_Bonus(0, Sponsor,_user,_UPLevelReward);\n', '\t  }\n', '  }\n', '\n', '  function payMembers(address _user,address spUP1,address spUP2,address spUP3,address spUP4,uint8 _level,uint32 EduPkg) internal {\n', '    uint256 _remValue = UPGRADE_PRICE[_level];\n', '    _remValue = paySponsor(_user,spUP1,_level,1,_remValue);\n', '    _remValue = paySponsor(_user,spUP2,_level,2,_remValue);\n', '    _remValue = paySponsor(_user,spUP3,_level,3,_remValue);\n', '    _remValue = paySponsor(_user,spUP4,_level,4,_remValue);\n', '    _remValue = _remValue - Reward_Loyality_Bonus(_level, _user);\n', '    UPGRADE_PURCHASED[_user].pDate.push(block.timestamp);\n', '    UPGRADE_PURCHASED[_user].LvL.push(_level);\n', '    UPGRADE_PURCHASED[_user].EduPkg.push(EduPkg);\n', '    bool send = false;\n', '    (send, ) = address(uint160(WBC_Wallet)).call.value(_remValue)("");\n', '  }\n', '\n', '    function isAdminListed(address _maker) public view returns (bool) {\n', '        require(_maker != address(0));\n', '        bool status = false;\n', '        for(uint256 i=0;i<adminCount;i++){\n', '            if(adminListed[i] == _maker) { status = true; }\n', '        }\n', '        return status;\n', '    }\n', '\n', '  function listAdmins() public view returns (address[] memory) {\n', "    require(isAdminListed(msg.sender),'Only Admins');\n", '    address[] memory _adminList = new address[](adminCount);\n', '    for(uint i = 0; i<adminCount ; i++){\n', '      _adminList[i] = adminListed[i];\n', '    }\n', '    return _adminList;\n', '  }\n', '\n', '      function addAdminList (address _adminUser) public {\n', '        require(_adminUser != address(0));\n', '        require(!isAdminListed(_adminUser));\n', '        adminListed.push(_adminUser);\n', '        adminCount++;\n', '    }\n', '\n', '    function removeAdminList (address _clearedAdmin) public {\n', "        require(isAdminListed(msg.sender),'Only Admins');\n", '        require(isAdminListed(_clearedAdmin) && _clearedAdmin != msg.sender);\n', '        for(uint256 i = 0 ;i<adminCount;i++){\n', '            if(adminListed[i] == _clearedAdmin) {\n', '                adminListed[i] = adminListed[adminListed.length-1];\n', '                delete adminListed[adminListed.length-1];\n', '                adminCount--;\n', '            }\n', '        }\n', '    }\n', '\n', '  function getUserReferrals(address _User,uint _Pos) public view returns (address referral)\n', '    { return(USERS[_User].Referrals[_Pos]); }\n', '\n', '  function getLine1Ref(address _User, uint _Pos) public view returns (address referral)\n', '    { return USERS[_User].Line1Referrals[_Pos]; }\n', '\n', '  function getLine2Ref(address _User, uint _Pos) public view returns (address referral)\n', '    { return USERS[_User].Line2Referrals[_Pos]; }\n', '\n', '  function getLine3Ref(address _User, uint _Pos) public view returns (address referral)\n', '    { return USERS[_User].Line3Referrals[_Pos]; }\n', '\n', '  function getLine4Ref(address _User, uint _Pos) public view returns (address referral)\n', '    { return USERS[_User].Line4Referrals[_Pos]; }\n', '\n', '  function getUserLevelExpiresAt(address _user, uint8 _level) public view returns (uint)\n', '    { return USERS[_user].LevelExpiresAt[_level];}\n', '\n', '  function getUserLevel (address _user) public view returns (uint8) {\n', '    if (getUserLevelExpiresAt(_user, 1) < block.timestamp) {return (0);}\n', '    else if (getUserLevelExpiresAt(_user, 2) < block.timestamp) {return (1);}\n', '    else if (getUserLevelExpiresAt(_user, 3) < block.timestamp) {return (2);}\n', '    else if (getUserLevelExpiresAt(_user, 4) < block.timestamp) {return (3);}\n', '    else if (getUserLevelExpiresAt(_user, 5) < block.timestamp) {return (4);}\n', '    else if (getUserLevelExpiresAt(_user, 6) < block.timestamp) {return (5);}\n', '    else if (getUserLevelExpiresAt(_user, 7) < block.timestamp) {return (6);}\n', '    else if (getUserLevelExpiresAt(_user, 8) < block.timestamp) {return (7);}\n', '    else if (getUserLevelExpiresAt(_user, 9) < block.timestamp) {return (8);}\n', '    else  {return (9);}\n', '    }\n', '\n', '  function getPkgPurchased(address _User, uint _Pos)\n', '    public view returns (uint8 LvL,uint pDate,uint32 EduPkg) {\n', '    return (\n', '      UPGRADE_PURCHASED[_User].LvL[_Pos],\n', '      UPGRADE_PURCHASED[_User].pDate[_Pos],\n', '      UPGRADE_PURCHASED[_User].EduPkg[_Pos]\n', '  );}\n', '\n', '  function getLOYALTY_BONUS(address _User, uint _Pos)\n', '  public view returns(uint8 Rewardtype,uint256 Amount,uint256 RewardedAt,address ReferralAddr){\n', '    return (\n', '      LOYALTY_BONUS[_User].Rewardtype[_Pos],\n', '      LOYALTY_BONUS[_User].Amount[_Pos],\n', '      LOYALTY_BONUS[_User].RewardedAt[_Pos],\n', '      LOYALTY_BONUS[_User].ReferralAddr[_Pos]\n', '  );}\n', '\n', '  function getSPONSOR_BONUS(address _User, uint _Pos)\n', '  public view returns(uint8 Rewardtype,uint256 Amount,uint256 RewardedAt,address ReferralAddr){\n', '    return (\n', '      SPONSOR_BONUS[_User].Rewardtype[_Pos],\n', '      SPONSOR_BONUS[_User].Amount[_Pos],\n', '      SPONSOR_BONUS[_User].RewardedAt[_Pos],\n', '      SPONSOR_BONUS[_User].ReferralAddr[_Pos]\n', '  );}\n', '\n', '  function set_TOKEN_SC_Address (address _tokenSCAddress) public {\n', "      require(isAdminListed(msg.sender),'Only Admins');\n", '      TOKEN_SC = _tokenSCAddress;}\n', '\n', '  function set_TOKEN_ATM_Address (address _tokenATM_Address) public {\n', "      require(isAdminListed(msg.sender),'Only Admins');\n", '      TOKEN_ATM = _tokenATM_Address;}\n', '      \n', '  function set_TOKEN_EXCHNG_Address (address _exchngSCAddress) public { \n', "      require(isAdminListed(msg.sender),'Only Admins');\n", '      TOKEN_EXCHNG  = _exchngSCAddress;}\n', '\n', '  function set_Owner_Address (address _WBC_Address) public {\n', "      require(isAdminListed(msg.sender),'Only Admins');\n", '      WBC_Wallet = _WBC_Address;}\n', '\n', '  function bytesToAddress(bytes memory bys) private pure returns (address addr) {assembly {addr := mload(add(bys,20))}}\n', '\n', '  function set_Exchange_Price() public {\n', '    ERC20Interface ERC20Exchng = ERC20Interface(TOKEN_EXCHNG);\n', '    TOKEN_PRICE = ERC20Exchng.Exchange_Price();}\n', '\n', '  function depositToken(uint256 _amount) public {\n', '    ERC20Interface ERC20Token = ERC20Interface(TOKEN_SC);\n', "    require(ERC20Token.transferFrom(msg.sender, address(this),_amount),'Token Transfer failed !');\n", '    TOKEN_DEPOSITS[TOKEN_SC] = TOKEN_DEPOSITS[TOKEN_SC]+_amount;}\n', '\n', '  function getUserID(address _user) public view returns(uint256 userID) {return userID = USERS[_user].ID;}\n', '  function viewUserReferral(address _user) public view returns(address[] memory) {return USERS[_user].Referrals;}\n', '  function getETHBalance() public view returns (uint256 _ETHBalance) {\n', "      require(isAdminListed(msg.sender),'Only Admins');\n", '      return address(this).balance;}\n', '}']