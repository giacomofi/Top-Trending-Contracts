['// SPDX-License-Identifier: AGPL-3.0-or-later\n', '\n', '/// join.sol -- Basic token adapters\n', '\n', '// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n', '//\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity >=0.5.12;\n', '\n', 'contract LibNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  usr,\n', '        bytes32  indexed  arg1,\n', '        bytes32  indexed  arg2,\n', '        bytes             data\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        _;\n', '        assembly {\n', "            // log an 'anonymous' event with a constant 6 words of calldata\n", '            // and four indexed topics: selector, caller, arg1 and arg2\n', '            let mark := msize()                       // end of memory ensures zero\n', '            mstore(0x40, add(mark, 288))              // update free memory pointer\n', '            mstore(mark, 0x20)                        // bytes type data offset\n', '            mstore(add(mark, 0x20), 224)              // bytes size (padded)\n', '            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\n', '            log4(mark, 288,                           // calldata\n', '                 shl(224, shr(224, calldataload(0))), // msg.sig\n', '                 caller(),                            // msg.sender\n', '                 calldataload(4),                     // arg1\n', '                 calldataload(36)                     // arg2\n', '                )\n', '        }\n', '    }\n', '}\n', '\n', 'interface GemLike {\n', '    function decimals() external view returns (uint);\n', '    function transfer(address,uint) external returns (bool);\n', '    function transferFrom(address,address,uint) external returns (bool);\n', '}\n', '\n', 'interface VatLike {\n', '    function slip(bytes32,address,int) external;\n', '}\n', '\n', '/*\n', '    Here we provide *adapters* to connect the Vat to arbitrary external\n', '    token implementations, creating a bounded context for the Vat. The\n', '    adapters here are provided as working examples:\n', '\n', '      - `GemJoin`: For well behaved ERC20 tokens, with simple transfer\n', '                   semantics.\n', '\n', '      - `ETHJoin`: For native Ether.\n', '\n', '      - `DaiJoin`: For connecting internal Dai balances to an external\n', '                   `DSToken` implementation.\n', '\n', '    In practice, adapter implementations will be varied and specific to\n', '    individual collateral types, accounting for different transfer\n', '    semantics and token standards.\n', '\n', '    Adapters need to implement two basic methods:\n', '\n', '      - `join`: enter collateral into the system\n', '      - `exit`: remove collateral from the system\n', '\n', '*/\n', '\n', 'contract GemJoin is LibNote {\n', '    // --- Auth ---\n', '    mapping (address => uint) public wards;\n', '    function rely(address usr) external note auth { wards[usr] = 1; }\n', '    function deny(address usr) external note auth { wards[usr] = 0; }\n', '    modifier auth {\n', '        require(wards[msg.sender] == 1, "GemJoin/not-authorized");\n', '        _;\n', '    }\n', '\n', '    VatLike public vat;   // CDP Engine\n', '    bytes32 public ilk;   // Collateral Type\n', '    GemLike public gem;\n', '    uint    public dec;\n', '    uint    public live;  // Active Flag\n', '\n', '    constructor(address vat_, bytes32 ilk_, address gem_) public {\n', '        wards[msg.sender] = 1;\n', '        live = 1;\n', '        vat = VatLike(vat_);\n', '        ilk = ilk_;\n', '        gem = GemLike(gem_);\n', '        dec = gem.decimals();\n', '    }\n', '    function cage() external note auth {\n', '        live = 0;\n', '    }\n', '    function join(address usr, uint wad) external note {\n', '        require(live == 1, "GemJoin/not-live");\n', '        require(int(wad) >= 0, "GemJoin/overflow");\n', '        vat.slip(ilk, usr, int(wad));\n', '        require(gem.transferFrom(msg.sender, address(this), wad), "GemJoin/failed-transfer");\n', '    }\n', '    function exit(address usr, uint wad) external note {\n', '        require(wad <= 2 ** 255, "GemJoin/overflow");\n', '        vat.slip(ilk, msg.sender, -int(wad));\n', '        require(gem.transfer(usr, wad), "GemJoin/failed-transfer");\n', '    }\n', '}']