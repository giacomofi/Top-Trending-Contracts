['// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.6.8;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface iERC20 {\n', '    function balanceOf(address account) external view returns (uint);\n', '    function transfer(address, uint) external returns (bool);\n', '    function transferFrom(address, address, uint) external returns (bool);\n', '}\n', 'interface iROUTER {\n', '    function isPool(address) external view returns(bool);\n', '}\n', 'interface iPOOL {\n', '    function TOKEN() external view returns(address);\n', '    function transferTo(address, uint) external returns (bool);\n', '}\n', 'interface iUTILS {\n', '    function calcShare(uint part, uint total, uint amount) external pure returns (uint share);\n', '    function getPoolShare(address token, uint units) external view returns(uint baseAmt);\n', '}\n', 'interface iBASE {\n', '    function changeIncentiveAddress(address) external returns(bool);\n', '    function changeDAO(address) external returns(bool);\n', '}\n', '\n', '// SafeMath\n', 'library SafeMath {\n', '\n', '    function add(uint a, uint b) internal pure returns (uint)   {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        require(c / a == b, "SafeMath");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract Dao_Vether {\n', '\n', '    using SafeMath for uint;\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '    uint256 private _status;\n', '    address public DEPLOYER;\n', '\n', '    address public BASE;\n', '\n', '    uint256 public totalWeight;\n', '    uint public one = 10**18;\n', '    uint public coolOffPeriod = 1 * 2;\n', '    uint public blocksPerDay = 5760;\n', '    uint public daysToEarnFactor = 10;\n', '    uint public FUNDS_CAP = one * 50000;\n', '\n', '    address public proposedDao;\n', '    bool public proposedDaoChange;\n', '    uint public daoChangeStart;\n', '    bool public daoHasMoved;\n', '    address public DAO;\n', '\n', '    address public proposedRouter;\n', '    bool public proposedRouterChange;\n', '    uint public routerChangeStart;\n', '    bool public routerHasMoved;\n', '    iROUTER private _ROUTER;\n', '\n', '    address public proposedUtils;\n', '    bool public proposedUtilsChange;\n', '    uint public utilsChangeStart;\n', '    bool public utilsHasMoved;\n', '    iUTILS private _UTILS;\n', '\n', '    address[] public arrayMembers;\n', '    mapping(address => bool) public isMember; // Is Member\n', "    mapping(address => mapping(address => uint256)) public mapMemberPool_Balance; // Member's balance in pool\n", '    mapping(address => uint256) public mapMember_Weight; // Value of weight\n', '    mapping(address => mapping(address => uint256)) public mapMemberPool_Weight; // Value of weight for pool\n', '    mapping(address => uint256) public mapMember_Block;\n', '\n', '    mapping(address => uint256) public mapAddress_Votes; \n', '    mapping(address => mapping(address => uint256)) public mapAddressMember_Votes; \n', '\n', '    uint public ID;\n', '    mapping(uint256 => string) public mapID_Type;\n', '    mapping(uint256 => uint256) public mapID_Value;\n', '    mapping(uint256 => uint256) public mapID_Votes; \n', '    mapping(uint256 => uint256) public mapID_Start; \n', '    mapping(uint256 => mapping(address => uint256)) public mapIDMember_Votes; \n', '\n', '    event MemberLocks(address indexed member,address indexed pool,uint256 amount);\n', '    event MemberUnlocks(address indexed member,address indexed pool,uint256 balance);\n', '    event MemberRegisters(address indexed member,address indexed pool,uint256 amount);\n', '\n', '    event NewVote(address indexed member,address indexed proposedAddress, uint voteWeight, uint totalVotes, string proposalType);\n', '    event ProposalFinalising(address indexed member,address indexed proposedAddress, uint timeFinalised, string proposalType);\n', '    event NewAddress(address indexed member,address indexed newAddress, uint votesCast, uint totalWeight, string proposalType);\n', '\n', '    event NewVoteParam(address indexed member,uint indexed ID, uint voteWeight, uint totalVotes, string proposalType);\n', '    event ParamProposalFinalising(address indexed member,uint indexed ID, uint timeFinalised, string proposalType);\n', '    event NewParam(address indexed member,uint indexed ID, uint votesCast, uint totalWeight, string proposalType);\n', '\n', '    modifier nonReentrant() {\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '        _status = _ENTERED;\n', '        _;\n', '        _status = _NOT_ENTERED;\n', '    }\n', '    // Only Deployer can execute\n', '    modifier onlyDeployer() {\n', '        require(msg.sender == DEPLOYER, "DeployerErr");\n', '        _;\n', '    }\n', '\n', '    constructor () public payable {\n', '        BASE = 0x4Ba6dDd7b89ed838FEd25d208D4f644106E34279;\n', '        DEPLOYER = msg.sender;\n', '        _status = _NOT_ENTERED;\n', '    }\n', '    function setGenesisAddresses(address _router, address _utils) public onlyDeployer {\n', '        _ROUTER = iROUTER(_router);\n', '        _UTILS = iUTILS(_utils);\n', '    }\n', '    function setGenesisFactors(uint _coolOff, uint _blocksPerDay, uint _daysToEarn) public onlyDeployer {\n', '        coolOffPeriod = _coolOff;\n', '        blocksPerDay = _blocksPerDay;\n', '        daysToEarnFactor = _daysToEarn;\n', '    }\n', '    function setCap(uint _fundsCap) public onlyDeployer {\n', '        FUNDS_CAP = _fundsCap;\n', '    }\n', '\n', '    function purgeDeployer() public onlyDeployer {\n', '        DEPLOYER = address(0);\n', '    }\n', '\n', '    //============================== USER - LOCK/UNLOCK ================================//\n', '    // Member locks some LP tokens\n', '    function lock(address pool, uint256 amount) public nonReentrant {\n', '        require(_ROUTER.isPool(pool) == true, "Must be listed");\n', '        require(amount > 0, "Must get some");\n', '        if (!isMember[msg.sender]) {\n', '            mapMember_Block[msg.sender] = block.number;\n', '            arrayMembers.push(msg.sender);\n', '            isMember[msg.sender] = true;\n', '        }\n', '        require(iPOOL(pool).transferTo(address(this), amount),"Must transfer"); // Uni/Bal LP tokens return bool\n', '        mapMemberPool_Balance[msg.sender][pool] = mapMemberPool_Balance[msg.sender][pool].add(amount); // Record total pool balance for member\n', '        registerWeight(msg.sender, pool); // Register weight\n', '        emit MemberLocks(msg.sender, pool, amount);\n', '    }\n', '\n', '    // Member unlocks all from a pool\n', '    function unlock(address pool) public nonReentrant {\n', '        uint256 balance = mapMemberPool_Balance[msg.sender][pool];\n', '        require(balance > 0, "Must have a balance to weight");\n', '        reduceWeight(pool, msg.sender);\n', '        if(mapMember_Weight[msg.sender] == 0 && iERC20(BASE).balanceOf(address(this)) > 0){\n', '            harvest();\n', '        }\n', '        require(iERC20(pool).transfer(msg.sender, balance), "Must transfer"); // Then transfer\n', '        emit MemberUnlocks(msg.sender, pool, balance);\n', '    }\n', '\n', '    // Member registers weight in a single pool\n', '    function registerWeight(address member, address pool) internal {\n', '        uint weight = updateWeight(pool, member);\n', '        emit MemberRegisters(member, pool, weight);\n', '    }\n', '\n', '    function updateWeight(address pool, address member) public returns(uint){\n', '        if(mapMemberPool_Weight[member][pool] > 0){\n', '            totalWeight = totalWeight.sub(mapMemberPool_Weight[member][pool]); // Remove previous weights\n', '            mapMember_Weight[member] = mapMember_Weight[member].sub(mapMemberPool_Weight[member][pool]);\n', '            mapMemberPool_Weight[member][pool] = 0;\n', '        }\n', '        uint weight = _UTILS.getPoolShare(iPOOL(pool).TOKEN(), mapMemberPool_Balance[msg.sender][pool] );\n', '        mapMemberPool_Weight[member][pool] = weight;\n', '        mapMember_Weight[member] += weight;\n', '        totalWeight += weight;\n', '        return weight;\n', '    }\n', '    function reduceWeight(address pool, address member) internal {\n', '        uint weight = mapMemberPool_Weight[member][pool];\n', '        mapMemberPool_Balance[member][pool] = 0; // Zero out balance\n', '        mapMemberPool_Weight[member][pool] = 0; // Zero out weight\n', '        totalWeight = totalWeight.sub(weight); // Remove that weight\n', '        mapMember_Weight[member] = mapMember_Weight[member].sub(weight); // Reduce weight\n', '    }\n', '\n', '    //============================== GOVERNANCE ================================//\n', '\n', '\n', '    // Member votes new Router\n', '    function voteAddressChange(address newAddress, string memory typeStr) public nonReentrant returns (uint voteWeight) {\n', '        bytes memory _type = bytes(typeStr);\n', "        require(sha256(_type) == sha256('DAO') || sha256(_type) == sha256('ROUTER') || sha256(_type) == sha256('UTILS'));\n", '        voteWeight = countVotes(newAddress);\n', '        updateAddressChange(newAddress, _type);\n', '        emit NewVote(msg.sender, newAddress, voteWeight, mapAddress_Votes[newAddress], string(_type));\n', '    }\n', '\n', '    function updateAddressChange(address _newAddress, bytes memory _type) internal {\n', '        if(hasQuorum(_newAddress)){\n', "            if(sha256(_type) == sha256('DAO')){\n", '                updateDao(_newAddress);\n', "            } else if (sha256(_type) == sha256('ROUTER')) {\n", '                updateRouter(_newAddress);\n', "            } else if (sha256(_type) == sha256('UTILS')){\n", '                updateUtils(_newAddress);\n', '            }\n', '            emit ProposalFinalising(msg.sender, _newAddress, now+coolOffPeriod, string(_type));\n', '        }\n', '    }\n', '\n', '    function moveAddress(string memory _typeStr) public nonReentrant {\n', '        bytes memory _type = bytes(_typeStr);\n', "        if(sha256(_type) == sha256('DAO')){\n", '            moveDao();\n', "        } else if (sha256(_type) == sha256('ROUTER')) {\n", '            moveRouter();\n', "        } else if (sha256(_type) == sha256('UTILS')){\n", '            moveUtils();\n', '        }\n', '    }\n', '\n', '    function updateDao(address _address) internal {\n', '        proposedDao = _address;\n', '        proposedDaoChange = true;\n', '        daoChangeStart = now;\n', '    }\n', '    function moveDao() internal {\n', '        require(proposedDao != address(0), "No DAO proposed");\n', '        require((now - daoChangeStart) > coolOffPeriod, "Must be pass cool off");\n', '        if(!hasQuorum(proposedDao)){\n', '            proposedDaoChange = false;\n', '        }\n', '        if(proposedDaoChange){\n', '            uint reserve = iERC20(BASE).balanceOf(address(this));\n', '            iERC20(BASE).transfer(proposedDao, reserve);\n', '            daoHasMoved = true;\n', '            DAO = proposedDao;\n', "            emit NewAddress(msg.sender, proposedDao, mapAddress_Votes[proposedDao], totalWeight, 'DAO');\n", '            mapAddress_Votes[proposedDao] = 0;\n', '            proposedDao = address(0);\n', '            proposedDaoChange = false;\n', '        }\n', '    }\n', '\n', '    function updateRouter(address _address) internal {\n', '        proposedRouter = _address;\n', '        proposedRouterChange = true;\n', '        routerChangeStart = now;\n', '        routerHasMoved = false;\n', '    }\n', '    function moveRouter() internal {\n', '        require(proposedRouter != address(0), "No router proposed");\n', '        require((now - routerChangeStart) > coolOffPeriod, "Must be pass cool off");\n', '        if(!hasQuorum(proposedRouter)){\n', '            proposedRouterChange = false;\n', '        }\n', '        if(proposedRouterChange){\n', '            _ROUTER = iROUTER(proposedRouter);\n', '            routerHasMoved = true;\n', "            emit NewAddress(msg.sender, proposedRouter, mapAddress_Votes[proposedRouter], totalWeight, 'ROUTER');\n", '            mapAddress_Votes[proposedRouter] = 0;\n', '            proposedRouter = address(0);\n', '            proposedRouterChange = false;\n', '        }\n', '    }\n', '\n', '    function updateUtils(address _address) internal {\n', '        proposedUtils = _address;\n', '        proposedUtilsChange = true;\n', '        utilsChangeStart = now;\n', '        utilsHasMoved = false;\n', '    }\n', '    function moveUtils() internal {\n', '        require(proposedUtils != address(0), "No utils proposed");\n', '        require((now - routerChangeStart) > coolOffPeriod, "Must be pass cool off");\n', '        if(!hasQuorum(proposedUtils)){\n', '            proposedUtilsChange = false;\n', '        }\n', '        if(proposedUtilsChange){\n', '            _UTILS = iUTILS(proposedUtils);\n', '            utilsHasMoved = true;\n', "            emit NewAddress(msg.sender, proposedUtils, mapAddress_Votes[proposedUtils], totalWeight, 'UTILS');\n", '            mapAddress_Votes[proposedUtils] = 0;\n', '            proposedUtils = address(0);\n', '            proposedUtilsChange = false;\n', '        }\n', '    }\n', '\n', '    //============================== GOVERNANCE ================================//\n', '\n', '    function newProposal(uint value, string memory typeStr) public {\n', '        bytes memory _type = bytes(typeStr);\n', "        require(sha256(_type) == sha256('FUNDS') || sha256(_type) == sha256('DAYS') || sha256(_type) == sha256('COOL'));\n", '        mapID_Type[ID] = typeStr;\n', '        mapID_Value[ID] = value;\n', '        voteIDChange(ID);\n', '        ID +=1;\n', '    }\n', '\n', '    function voteIDChange(uint _ID) public nonReentrant returns (uint voteWeight) {\n', '        voteWeight = countVotesID(_ID);\n', '        updateIDChange(_ID);\n', '        emit NewVoteParam(msg.sender, _ID, voteWeight, mapID_Votes[_ID], mapID_Type[_ID]);\n', '    }\n', '\n', '    function updateIDChange(uint _ID) internal {\n', '        if(hasQuorumID(_ID)){\n', '            mapID_Start[_ID] = now;\n', '            emit ParamProposalFinalising(msg.sender, ID, now+coolOffPeriod, mapID_Type[ID]);\n', '        }\n', '    }\n', '\n', '    function executeID(uint _ID) public nonReentrant {\n', '        bytes memory _type = bytes(mapID_Type[_ID]);\n', "        if(sha256(_type) == sha256('FUNDS')){\n", '            FUNDS_CAP = mapID_Value[_ID];\n', "        } else if (sha256(_type) == sha256('DAYS')) {\n", '            daysToEarnFactor = mapID_Value[_ID];\n', "        } else if (sha256(_type) == sha256('COOL')){\n", '            coolOffPeriod = mapID_Value[_ID];\n', '        }\n', '        emit NewParam(msg.sender, ID, mapID_Votes[_ID], totalWeight, mapID_Type[_ID]);\n', '    }\n', '\n', '    //============================== CONSENSUS ================================//\n', '\n', '    function countVotes(address _address) internal returns (uint voteWeight){\n', '        mapAddress_Votes[_address] = mapAddress_Votes[_address].sub(mapAddressMember_Votes[_address][msg.sender]);\n', '        voteWeight = mapMember_Weight[msg.sender];\n', '        mapAddress_Votes[_address] += voteWeight;\n', '        mapAddressMember_Votes[_address][msg.sender] = voteWeight;\n', '        return voteWeight;\n', '    }\n', '\n', '    function hasQuorum(address _address) public view returns(bool){\n', '        uint votes = mapAddress_Votes[_address];\n', '        uint consensus = totalWeight.div(2);\n', '        if(votes > consensus){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function countVotesID(uint _ID) internal returns (uint voteWeight){\n', '        mapID_Votes[_ID] = mapID_Votes[_ID].sub(mapIDMember_Votes[_ID][msg.sender]);\n', '        voteWeight = mapMember_Weight[msg.sender];\n', '        mapID_Votes[_ID] += voteWeight;\n', '        mapIDMember_Votes[_ID][msg.sender] = voteWeight;\n', '        return voteWeight;\n', '    }\n', '\n', '    function hasQuorumID(uint _ID) public view returns(bool){\n', '        uint votes = mapID_Votes[_ID];\n', '        uint consensus = totalWeight.div(2);\n', '        if(votes > consensus){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // //============================== _ROUTER ================================//\n', '\n', '    function ROUTER() public view returns(iROUTER){\n', '        if(daoHasMoved){\n', '            return Dao_Vether(DAO).ROUTER();\n', '        } else {\n', '            return _ROUTER;\n', '        }\n', '    }\n', '\n', '    function UTILS() public view returns(iUTILS){\n', '        if(daoHasMoved){\n', '            return Dao_Vether(DAO).UTILS();\n', '        } else {\n', '            return _UTILS;\n', '        }\n', '    }\n', '\n', '    //============================== REWARDS ================================//\n', '    // Rewards\n', '    function harvest() public nonReentrant {\n', '        uint reward = calcCurrentReward(msg.sender);\n', '        mapMember_Block[msg.sender] = block.number;\n', '        iERC20(BASE).transfer(msg.sender, reward);\n', '    }\n', '\n', '    function calcCurrentReward(address member) public view returns(uint){\n', '        uint blocksSinceClaim = block.number.sub(mapMember_Block[member]);\n', '        uint share = calcReward(member);\n', '        uint reward = share.mul(blocksSinceClaim).div(blocksPerDay);\n', '        uint reserve = iERC20(BASE).balanceOf(address(this));\n', '        if(reward >= reserve) {\n', '            reward = reserve;\n', '        }\n', '        return reward;\n', '    }\n', '\n', '    function calcReward(address member) public view returns(uint){\n', '        uint weight = mapMember_Weight[member];\n', '        uint reserve = iERC20(BASE).balanceOf(address(this)).div(daysToEarnFactor);\n', '        return _UTILS.calcShare(weight, totalWeight, reserve);\n', '    }\n', '\n', '}']