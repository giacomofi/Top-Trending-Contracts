['// File: contracts/interfaces/IERC20.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IOneSwapToken.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'interface IOneSwapBlackList {\n', '    event OwnerChanged(address);\n', '    event AddedBlackLists(address[]);\n', '    event RemovedBlackLists(address[]);\n', '\n', '    function owner()external view returns (address);\n', '    function newOwner()external view returns (address);\n', '    function isBlackListed(address)external view returns (bool);\n', '\n', '    function changeOwner(address ownerToSet) external;\n', '    function updateOwner() external;\n', '    function addBlackLists(address[] calldata  accounts)external;\n', '    function removeBlackLists(address[] calldata  accounts)external;\n', '}\n', '\n', 'interface IOneSwapToken is IERC20, IOneSwapBlackList{\n', '    function burn(uint256 amount) external;\n', '    function burnFrom(address account, uint256 amount) external;\n', '    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n', '    function multiTransfer(uint256[] calldata mixedAddrVal) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IOneSwapFactory.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IOneSwapFactory {\n', '    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\n', '\n', '    function createPair(address stock, address money, bool isOnlySwap) external returns (address pair);\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '    function setFeeBPS(uint32 bps) external;\n', '    function setPairLogic(address implLogic) external;\n', '\n', '    function allPairsLength() external view returns (uint);\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '    function feeBPS() external view returns (uint32);\n', '    function pairLogic() external returns (address);\n', '    function getTokensFromPair(address pair) external view returns (address stock, address money);\n', '    function tokensToPair(address stock, address money, bool isOnlySwap) external view returns (address pair);\n', '}\n', '\n', '// File: contracts/interfaces/IOneSwapRouter.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IOneSwapRouter {\n', '    event AddLiquidity(uint stockAmount, uint moneyAmount, uint liquidity);\n', '    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\n', '\n', '    function factory() external pure returns (address);\n', '\n', '    // liquidity\n', '    function addLiquidity(\n', '        address stock,\n', '        address money,\n', '        bool isOnlySwap,\n', '        uint amountStockDesired,\n', '        uint amountMoneyDesired,\n', '        uint amountStockMin,\n', '        uint amountMoneyMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountStock, uint amountMoney, uint liquidity);\n', '    function removeLiquidity(\n', '        address pair,\n', '        uint liquidity,\n', '        uint amountStockMin,\n', '        uint amountMoneyMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountStock, uint amountMoney);\n', '\n', '    // swap token\n', '    function swapToken(\n', '        address token,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint[] memory amounts);\n', '\n', '    // limit order\n', '    function limitOrder(\n', '        bool isBuy,\n', '        address pair,\n', '        uint prevKey,\n', '        uint price,\n', '        uint32 id,\n', '        uint stockAmount,\n', '        uint deadline\n', '    ) external payable;\n', '}\n', '\n', '// File: contracts/interfaces/IOneSwapBuyback.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IOneSwapBuyback {\n', '    event BurnOnes(uint256 burntAmt);\n', '\n', '    function ones() external pure returns (address);\n', '    function router() external pure returns (address);\n', '    function factory() external pure returns (address);\n', '\n', '    function addMainToken(address token) external;\n', '    function removeMainToken(address token) external;\n', '    function isMainToken(address token) external view returns (bool);\n', '    function mainTokens() external view returns (address[] memory list);\n', '\n', '    function removeLiquidity(address[] calldata pairs) external;\n', '    function swapForMainToken(address[] calldata pairs) external;\n', '    function swapForOnesAndBurn(address[] calldata pairs) external;\n', '}\n', '\n', '// File: contracts/OneSwapBuyback.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', 'contract OneSwapBuyback is IOneSwapBuyback {\n', '\n', '    uint256 private constant _MAX_UINT256 = uint256(-1); \n', '    address private constant _ETH = address(0);\n', '\n', '    address public immutable override ones;\n', '    address public immutable override router;\n', '    address public immutable override factory;\n', '\n', '    mapping (address => bool) private _mainTokens;\n', '    address[] private _mainTokenArr;\n', '\n', '    constructor(address _ones, address _router, address _factory) public {\n', '        ones = _ones;\n', '        router = _router;\n', '        factory = _factory;\n', '\n', '        // add ETH & ONES to main token list\n', '        _mainTokens[_ETH] = true;\n', '        _mainTokenArr.push(_ETH);\n', '        _mainTokens[_ones] = true;\n', '        _mainTokenArr.push(_ones);\n', '    }\n', '\n', '    receive() external payable { }\n', '\n', '    // add token into main token list\n', '    function addMainToken(address token) external override {\n', '        require(msg.sender == IOneSwapToken(ones).owner(), "OneSwapBuyback: NOT_ONES_OWNER");\n', '        if (!_mainTokens[token]) {\n', '            _mainTokens[token] = true;\n', '            _mainTokenArr.push(token);\n', '        }\n', '    }\n', '    // remove token from main token list\n', '    function removeMainToken(address token) external override {\n', '        require(msg.sender == IOneSwapToken(ones).owner(), "OneSwapBuyback: NOT_ONES_OWNER");\n', '        require(token != _ETH, "OneSwapBuyback: REMOVE_ETH_FROM_MAIN");\n', '        require(token != ones, "OneSwapBuyback: REMOVE_ONES_FROM_MAIN");\n', '        if (_mainTokens[token]) {\n', '            _mainTokens[token] = false;\n', '            uint256 lastIdx = _mainTokenArr.length - 1;\n', '            for (uint256 i = 2; i < lastIdx; i++) { // skip ETH & ONES\n', '                if (_mainTokenArr[i] == token) {\n', '                    _mainTokenArr[i] = _mainTokenArr[lastIdx];\n', '                    break;\n', '                }\n', '            }\n', '            _mainTokenArr.pop();\n', '        }\n', '    }\n', '    // check if token is in main token list\n', '    function isMainToken(address token) external view override returns (bool) {\n', '        return _mainTokens[token];\n', '    }\n', '    // query main token list\n', '    function mainTokens() external view override returns (address[] memory list) {\n', '        list = _mainTokenArr;\n', '    }\n', '\n', "    // remove Buyback's liquidity from all pairs\n", '    // swap got minor tokens for main tokens if possible\n', '    function removeLiquidity(address[] calldata pairs) external override {\n', '        for (uint256 i = 0; i < pairs.length; i++) {\n', '            _removeLiquidity(pairs[i]);\n', '        }\n', '    }\n', '    function _removeLiquidity(address pair) private {\n', '        (address a, address b) = IOneSwapFactory(factory).getTokensFromPair(pair);\n', '        require(a != address(0) || b != address(0), "OneSwapBuyback: INVALID_PAIR");\n', '\n', '        uint256 amt = IERC20(pair).balanceOf(address(this));\n', '        // require(amt > 0, "OneSwapBuyback: NO_LIQUIDITY");\n', '        if (amt == 0) { return; }\n', '\n', '        IERC20(pair).approve(router, 0);\n', '        IERC20(pair).approve(router, amt);\n', '        IOneSwapRouter(router).removeLiquidity(\n', '            pair, amt, 0, 0, address(this), _MAX_UINT256);\n', '\n', '        // minor -> main\n', '        bool aIsMain = _mainTokens[a];\n', '        bool bIsMain = _mainTokens[b];\n', '        if ((aIsMain && !bIsMain) || (!aIsMain && bIsMain)) {\n', '            _swapForMainToken(pair);\n', '        }\n', '    }\n', '\n', '    // swap minor tokens for main tokens\n', '    function swapForMainToken(address[] calldata pairs) external override {\n', '        for (uint256 i = 0; i < pairs.length; i++) {\n', '            _swapForMainToken(pairs[i]);\n', '        }\n', '    }\n', '    function _swapForMainToken(address pair) private {\n', '        (address a, address b) = IOneSwapFactory(factory).getTokensFromPair(pair);\n', '        require(a != address(0) || b != address(0), "OneSwapBuyback: INVALID_PAIR");\n', '\n', '        address mainToken;\n', '        address minorToken;\n', '        if (_mainTokens[a]) {\n', '            require(!_mainTokens[b], "OneSwapBuyback: SWAP_TWO_MAIN_TOKENS");\n', '            (mainToken, minorToken) = (a, b);\n', '        } else {\n', '            require(_mainTokens[b], "OneSwapBuyback: SWAP_TWO_MINOR_TOKENS");\n', '            (mainToken, minorToken) = (b, a);\n', '        }\n', '\n', '        uint256 minorTokenAmt = IERC20(minorToken).balanceOf(address(this));\n', '        // require(minorTokenAmt > 0, "OneSwapBuyback: NO_MINOR_TOKENS");\n', '        if (minorTokenAmt == 0) { return; }\n', '\n', '        address[] memory path = new address[](1);\n', '        path[0] = pair;\n', '\n', '        // minor -> main\n', '        IERC20(minorToken).approve(router, 0);\n', '        IERC20(minorToken).approve(router, minorTokenAmt);\n', '        IOneSwapRouter(router).swapToken(\n', '            minorToken, minorTokenAmt, 0, path, address(this), _MAX_UINT256);\n', '    }\n', '\n', '    // swap main tokens for ones, then burn all ones\n', '    function swapForOnesAndBurn(address[] calldata pairs) external override {\n', '        for (uint256 i = 0; i < pairs.length; i++) {\n', '            _swapForOnes(pairs[i]);\n', '        }\n', '\n', '        // burn all ones\n', '        uint256 allOnes = IERC20(ones).balanceOf(address(this));\n', '        if (allOnes == 0) { return; }\n', '        IOneSwapToken(ones).burn(allOnes);\n', '        emit BurnOnes(allOnes);\n', '    }\n', '    function _swapForOnes(address pair) private {\n', '        (address a, address b) = IOneSwapFactory(factory).getTokensFromPair(pair);\n', '        require(a != address(0) || b != address(0), "OneSwapBuyback: INVALID_PAIR");\n', '        require(a == ones || b == ones, "OneSwapBuyback: ONES_NOT_IN_PAIR");\n', '\n', '        address token = (a == ones) ? b : a;\n', '        require(_mainTokens[token], "OneSwapBuyback: MAIN_TOKEN_NOT_IN_PAIR");\n', '\n', '        address[] memory path = new address[](1);\n', '        path[0] = pair;\n', '\n', '        if (token == _ETH) { // eth -> ones\n', '            uint256 ethAmt = address(this).balance;\n', '            // require(ethAmt > 0, "OneSwapBuyback: NO_ETH");\n', '            if (ethAmt == 0) { return; }\n', '\n', '            IOneSwapRouter(router).swapToken{value: ethAmt}(\n', '                _ETH, ethAmt, 0, path, address(this), _MAX_UINT256);\n', '        } else { // main token -> ones\n', '            uint256 tokenAmt = IERC20(token).balanceOf(address(this));\n', '            // require(tokenAmt > 0, "OneSwapBuyback: NO_MAIN_TOKENS");\n', '            if (tokenAmt == 0) { return; }\n', '\n', '            IERC20(token).approve(router, 0);\n', '            IERC20(token).approve(router, tokenAmt);\n', '            IOneSwapRouter(router).swapToken(\n', '                token, tokenAmt, 0, path, address(this), _MAX_UINT256);\n', '        }\n', '    }\n', '\n', '}']