['pragma solidity ^0.6.0;\n', '\n', 'interface CTokenInterface {\n', '    function mint(uint mintAmount) external returns (uint);\n', '    function redeem(uint redeemTokens) external returns (uint);\n', '    function borrow(uint borrowAmount) external returns (uint);\n', '    function repayBorrow(uint repayAmount) external returns (uint);\n', '\n', '    function borrowBalanceCurrent(address account) external returns (uint);\n', '    function redeemUnderlying(uint redeemAmount) external returns (uint);\n', '    function exchangeRateCurrent() external returns (uint);\n', '\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '}\n', '\n', 'interface CETHInterface {\n', '    function mint() external payable;\n', '    function repayBorrow() external payable;\n', '}\n', '\n', 'interface TokenInterface {\n', '    function allowance(address, address) external view returns (uint);\n', '    function balanceOf(address) external view returns (uint);\n', '    function approve(address, uint) external;\n', '    function transfer(address, uint) external returns (bool);\n', '    function transferFrom(address, address, uint) external returns (bool);\n', '}\n', '\n', 'interface ComptrollerInterface {\n', '    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);\n', '    function exitMarket(address cTokenAddress) external returns (uint);\n', '}\n', '\n', 'interface InstaMapping {\n', '    function cTokenMapping(address) external view returns (address);\n', '}\n', '\n', 'contract DSMath {\n', '\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x, "math-not-safe");\n', '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "math-not-safe");\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Helpers is DSMath {\n', '    /**\n', '     * @dev Return ethereum address\n', '     */\n', '    function getAddressETH() internal pure returns (address) {\n', '        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; // ETH Address\n', '    }\n', '\n', '    function getAddressWETH() internal pure returns (address) {\n', '        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\n', '        // return 0xd0A1E359811322d97991E03f863a0C30C2cF029C; // kovan\n', '    }\n', '\n', '    function isETH(address token) internal pure returns(bool) {\n', '        return token == getAddressETH() || token == getAddressWETH();\n', '    }\n', '}\n', '\n', '\n', 'contract CompoundHelpers is Helpers {\n', '    /**\n', '     * @dev Return Compound Comptroller Address\n', '     */\n', '    function getComptrollerAddress() internal pure returns (address) {\n', '        return 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B; // main\n', '        // return 0x1f5D7F3CaAC149fE41b8bd62A3673FE6eC0AB73b; // kovan\n', '    }\n', '\n', '    /**\n', '     * @dev Return InstaDApp Mapping Addresses\n', '     */\n', '    function getMappingAddr() internal pure returns (address) {\n', '        return 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88; // InstaMapping Address\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev enter compound market\n', '     */\n', '    function enterMarket(address cToken) internal {\n', '        address[] memory cTokens = new address[](1);\n', '        cTokens[0] = cToken;\n', '        ComptrollerInterface troller = ComptrollerInterface(getComptrollerAddress());\n', '        troller.enterMarkets(cTokens);\n', '    }\n', '}\n', '\n', '\n', 'contract BasicResolver is CompoundHelpers {\n', '    event LogDeposit(address indexed token, uint256 tokenAmt);\n', '    event LogWithdraw(address indexed token);\n', '    event LogBorrow(address indexed token, uint256 tokenAmt);\n', '    event LogPayback(address indexed token);\n', '\n', '    /**\n', '     * @dev Deposit ETH/ERC20_Token.\n', '     * @param token token address to deposit.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n', '     * @param amt token amount to deposit.\n', '    */\n', '    function deposit(address token, uint amt) external payable{\n', '        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\n', '        uint _amt = amt;\n', '        enterMarket(cToken);\n', '        if (isETH(token)) {\n', '            _amt = _amt == uint(-1) ? address(this).balance : _amt;\n', '            CETHInterface(cToken).mint.value(_amt)();\n', '        } else {\n', '            TokenInterface tokenContract = TokenInterface(token);\n', '            _amt = _amt == uint(-1) ? tokenContract.balanceOf(address(this)) : _amt;\n', '            tokenContract.approve(cToken, _amt);\n', '            require(CTokenInterface(cToken).mint(_amt) == 0, "minting-failed");\n', '        }\n', '\n', '        emit LogDeposit(token, _amt);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw ETH/ERC20_Token.\n', '     * @param token token address to withdraw.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n', '     * @param amt token amount to withdraw.\n', '    */\n', '    function withdraw(address token, uint amt) external {\n', '        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\n', '        CTokenInterface cTokenContract = CTokenInterface(cToken);\n', '        if (amt == uint(-1)) {\n', '            require(cTokenContract.redeem(cTokenContract.balanceOf(address(this))) == 0, "full-withdraw-failed");\n', '        } else {\n', '            require(cTokenContract.redeemUnderlying(amt) == 0, "withdraw-failed");\n', '        }\n', '\n', '        emit LogWithdraw(token);\n', '    }\n', '\n', '    /**\n', '     * @dev Borrow ETH/ERC20_Token.\n', '     * @param token token address to borrow.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n', '     * @param amt token amount to borrow.\n', '    */\n', '    function borrow(address token, uint amt) external {\n', '        uint _amt = amt;\n', '        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\n', '        enterMarket(cToken);\n', '        require(CTokenInterface(cToken).borrow(_amt) == 0, "borrow-failed");\n', '\n', '        emit LogBorrow(token, _amt);\n', '    }\n', '\n', '    /**\n', '     * @dev Payback borrowed ETH/ERC20_Token.\n', '     * @param token token address to payback.(For ETH: 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)\n', '     * @param amt token amount to payback.\n', '    */\n', '    function payback(address token, uint amt) external {\n', '        address cToken = InstaMapping(getMappingAddr()).cTokenMapping(token);\n', '        CTokenInterface cTokenContract = CTokenInterface(cToken);\n', '        uint _amt = amt == uint(-1) ? cTokenContract.borrowBalanceCurrent(address(this)) : amt;\n', '\n', '        if (isETH(token)) {\n', '            require(address(this).balance >= _amt, "not-enough-eth");\n', '            CETHInterface(cToken).repayBorrow.value(_amt)();\n', '        } else {\n', '            TokenInterface tokenContract = TokenInterface(token);\n', '            require(tokenContract.balanceOf(address(this)) >= _amt, "not-enough-token");\n', '            tokenContract.approve(cToken, _amt);\n', '            require(cTokenContract.repayBorrow(_amt) == 0, "repay-failed.");\n', '        }\n', '\n', '        emit LogPayback(token);\n', '    }\n', '}\n', '\n', 'contract ConnectCompound is BasicResolver {\n', '    string public name = "flashloan-Compound-v1.0";\n', '}']