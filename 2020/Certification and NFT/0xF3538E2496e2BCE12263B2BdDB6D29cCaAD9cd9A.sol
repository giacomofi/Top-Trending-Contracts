['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-13\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '/**\n', ' * @title Careful Math\n', ' * @author Compound\n', " * @notice Derived from OpenZeppelin's SafeMath library\n", ' *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', ' */\n', 'contract CarefulMath {\n', '    /**\n', '     * @dev Possible error codes that we can return\n', '     */\n', '    enum MathError {\n', '        NO_ERROR,\n', '        DIVISION_BY_ZERO,\n', '        INTEGER_OVERFLOW,\n', '        INTEGER_UNDERFLOW\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies two numbers, returns an error on overflow.\n', '     */\n', '    function mulUInt(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (MathError, uint256)\n', '    {\n', '        if (a == 0) {\n', '            return (MathError.NO_ERROR, 0);\n', '        }\n', '\n', '        uint256 c = a * b;\n', '\n', '        if (c / a != b) {\n', '            return (MathError.INTEGER_OVERFLOW, 0);\n', '        } else {\n', '            return (MathError.NO_ERROR, c);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function divUInt(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (MathError, uint256)\n', '    {\n', '        if (b == 0) {\n', '            return (MathError.DIVISION_BY_ZERO, 0);\n', '        }\n', '\n', '        return (MathError.NO_ERROR, a / b);\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function subUInt(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (MathError, uint256)\n', '    {\n', '        if (b <= a) {\n', '            return (MathError.NO_ERROR, a - b);\n', '        } else {\n', '            return (MathError.INTEGER_UNDERFLOW, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, returns an error on overflow.\n', '     */\n', '    function addUInt(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (MathError, uint256)\n', '    {\n', '        uint256 c = a + b;\n', '\n', '        if (c >= a) {\n', '            return (MathError.NO_ERROR, c);\n', '        } else {\n', '            return (MathError.INTEGER_OVERFLOW, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev add a and b and then subtract c\n', '     */\n', '    function addThenSubUInt(\n', '        uint256 a,\n', '        uint256 b,\n', '        uint256 c\n', '    ) internal pure returns (MathError, uint256) {\n', '        (MathError err0, uint256 sum) = addUInt(a, b);\n', '\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, 0);\n', '        }\n', '\n', '        return subUInt(sum, c);\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', 'contract ComptrollerErrorReporter {\n', '    enum Error {\n', '        NO_ERROR,\n', '        UNAUTHORIZED,\n', '        COMPTROLLER_MISMATCH,\n', '        INSUFFICIENT_SHORTFALL,\n', '        INSUFFICIENT_LIQUIDITY,\n', '        INVALID_CLOSE_FACTOR,\n', '        INVALID_COLLATERAL_FACTOR,\n', '        INVALID_LIQUIDATION_INCENTIVE,\n', '        MARKET_NOT_ENTERED, // no longer possible\n', '        MARKET_NOT_LISTED,\n', '        MARKET_ALREADY_LISTED,\n', '        MATH_ERROR,\n', '        NONZERO_BORROW_BALANCE,\n', '        PRICE_ERROR,\n', '        REJECTION,\n', '        SNAPSHOT_ERROR,\n', '        TOO_MANY_ASSETS,\n', '        TOO_MUCH_REPAY\n', '    }\n', '\n', '    enum FailureInfo {\n', '        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n', '        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n', '        EXIT_MARKET_BALANCE_OWED,\n', '        EXIT_MARKET_REJECTION,\n', '        SET_CLOSE_FACTOR_OWNER_CHECK,\n', '        SET_CLOSE_FACTOR_VALIDATION,\n', '        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n', '        SET_COLLATERAL_FACTOR_NO_EXISTS,\n', '        SET_COLLATERAL_FACTOR_VALIDATION,\n', '        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n', '        SET_IMPLEMENTATION_OWNER_CHECK,\n', '        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n', '        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n', '        SET_MAX_ASSETS_OWNER_CHECK,\n', '        SET_PENDING_ADMIN_OWNER_CHECK,\n', '        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n', '        SET_PRICE_ORACLE_OWNER_CHECK,\n', '        SUPPORT_MARKET_EXISTS,\n', '        SUPPORT_MARKET_OWNER_CHECK,\n', '        SET_PAUSE_GUARDIAN_OWNER_CHECK\n', '    }\n', '\n', '    /**\n', '     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n', '     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n', '     **/\n', '    event Failure(uint256 error, uint256 info, uint256 detail);\n', '\n', '    /**\n', '     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n', '     */\n', '    function fail(Error err, FailureInfo info) internal returns (uint256) {\n', '        emit Failure(uint256(err), uint256(info), 0);\n', '\n', '        return uint256(err);\n', '    }\n', '\n', '    /**\n', '     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n', '     */\n', '    function failOpaque(\n', '        Error err,\n', '        FailureInfo info,\n', '        uint256 opaqueError\n', '    ) internal returns (uint256) {\n', '        emit Failure(uint256(err), uint256(info), opaqueError);\n', '\n', '        return uint256(err);\n', '    }\n', '}\n', '\n', 'contract TokenErrorReporter {\n', '    enum Error {\n', '        NO_ERROR,\n', '        UNAUTHORIZED,\n', '        BAD_INPUT,\n', '        COMPTROLLER_REJECTION,\n', '        COMPTROLLER_CALCULATION_ERROR,\n', '        INTEREST_RATE_MODEL_ERROR,\n', '        INVALID_ACCOUNT_PAIR,\n', '        INVALID_CLOSE_AMOUNT_REQUESTED,\n', '        INVALID_COLLATERAL_FACTOR,\n', '        MATH_ERROR,\n', '        MARKET_NOT_FRESH,\n', '        MARKET_NOT_LISTED,\n', '        TOKEN_INSUFFICIENT_ALLOWANCE,\n', '        TOKEN_INSUFFICIENT_BALANCE,\n', '        TOKEN_INSUFFICIENT_CASH,\n', '        TOKEN_TRANSFER_IN_FAILED,\n', '        TOKEN_TRANSFER_OUT_FAILED\n', '    }\n', '\n', '    /*\n', '     * Note: FailureInfo (but not Error) is kept in alphabetical order\n', '     *       This is because FailureInfo grows significantly faster, and\n', '     *       the order of Error has some meaning, while the order of FailureInfo\n', '     *       is entirely arbitrary.\n', '     */\n', '    enum FailureInfo {\n', '        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n', '        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n', '        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n', '        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n', '        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n', '        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n', '        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        BORROW_ACCRUE_INTEREST_FAILED,\n', '        BORROW_CASH_NOT_AVAILABLE,\n', '        BORROW_FRESHNESS_CHECK,\n', '        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n', '        BORROW_MARKET_NOT_LISTED,\n', '        BORROW_COMPTROLLER_REJECTION,\n', '        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n', '        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n', '        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n', '        LIQUIDATE_COMPTROLLER_REJECTION,\n', '        LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n', '        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n', '        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n', '        LIQUIDATE_FRESHNESS_CHECK,\n', '        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n', '        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n', '        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n', '        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n', '        LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n', '        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n', '        LIQUIDATE_SEIZE_TOO_MUCH,\n', '        MINT_ACCRUE_INTEREST_FAILED,\n', '        MINT_COMPTROLLER_REJECTION,\n', '        MINT_EXCHANGE_CALCULATION_FAILED,\n', '        MINT_EXCHANGE_RATE_READ_FAILED,\n', '        MINT_FRESHNESS_CHECK,\n', '        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n', '        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n', '        MINT_TRANSFER_IN_FAILED,\n', '        MINT_TRANSFER_IN_NOT_POSSIBLE,\n', '        REDEEM_ACCRUE_INTEREST_FAILED,\n', '        REDEEM_COMPTROLLER_REJECTION,\n', '        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n', '        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n', '        REDEEM_EXCHANGE_RATE_READ_FAILED,\n', '        REDEEM_FRESHNESS_CHECK,\n', '        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n', '        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n', '        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n', '        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n', '        REDUCE_RESERVES_ADMIN_CHECK,\n', '        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n', '        REDUCE_RESERVES_FRESH_CHECK,\n', '        REDUCE_RESERVES_VALIDATION,\n', '        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n', '        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n', '        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_COMPTROLLER_REJECTION,\n', '        REPAY_BORROW_FRESHNESS_CHECK,\n', '        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n', '        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n', '        SET_COLLATERAL_FACTOR_VALIDATION,\n', '        SET_COMPTROLLER_OWNER_CHECK,\n', '        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n', '        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n', '        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n', '        SET_MAX_ASSETS_OWNER_CHECK,\n', '        SET_ORACLE_MARKET_NOT_LISTED,\n', '        SET_PENDING_ADMIN_OWNER_CHECK,\n', '        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n', '        SET_RESERVE_FACTOR_ADMIN_CHECK,\n', '        SET_RESERVE_FACTOR_FRESH_CHECK,\n', '        SET_RESERVE_FACTOR_BOUNDS_CHECK,\n', '        TRANSFER_COMPTROLLER_REJECTION,\n', '        TRANSFER_NOT_ALLOWED,\n', '        TRANSFER_NOT_ENOUGH,\n', '        TRANSFER_TOO_MUCH,\n', '        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n', '        ADD_RESERVES_FRESH_CHECK,\n', '        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\n', '    }\n', '\n', '    /**\n', '     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n', '     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n', '     **/\n', '    event Failure(uint256 error, uint256 info, uint256 detail);\n', '\n', '    /**\n', '     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n', '     */\n', '    function fail(Error err, FailureInfo info) internal returns (uint256) {\n', '        emit Failure(uint256(err), uint256(info), 0);\n', '\n', '        return uint256(err);\n', '    }\n', '\n', '    /**\n', '     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n', '     */\n', '    function failOpaque(\n', '        Error err,\n', '        FailureInfo info,\n', '        uint256 opaqueError\n', '    ) internal returns (uint256) {\n', '        emit Failure(uint256(err), uint256(info), opaqueError);\n', '\n', '        return uint256(err);\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '//import "./CarefulMath.sol";\n', '\n', '/**\n', ' * @title Exponential module for storing fixed-precision decimals\n', ' * @author Compound\n', ' * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n', ' *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n', ' *         `Exp({mantissa: 5100000000000000000})`.\n', ' */\n', 'contract Exponential is CarefulMath {\n', '    uint256 constant expScale = 1e18;\n', '    uint256 constant doubleScale = 1e36;\n', '    uint256 constant halfExpScale = expScale / 2;\n', '    uint256 constant mantissaOne = expScale;\n', '\n', '    struct Exp {\n', '        uint256 mantissa;\n', '    }\n', '\n', '    struct Double {\n', '        uint256 mantissa;\n', '    }\n', '\n', '    /**\n', '     * @dev Creates an exponential from numerator and denominator values.\n', '     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n', '     *            or if `denom` is zero.\n', '     */\n', '    function getExp(uint256 num, uint256 denom)\n', '        internal\n', '        pure\n', '        returns (MathError, Exp memory)\n', '    {\n', '        (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);\n', '        if (err1 != MathError.NO_ERROR) {\n', '            return (err1, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two exponentials, returning a new exponential.\n', '     */\n', '    function addExp(Exp memory a, Exp memory b)\n', '        internal\n', '        pure\n', '        returns (MathError, Exp memory)\n', '    {\n', '        (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\n', '\n', '        return (error, Exp({mantissa: result}));\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two exponentials, returning a new exponential.\n', '     */\n', '    function subExp(Exp memory a, Exp memory b)\n', '        internal\n', '        pure\n', '        returns (MathError, Exp memory)\n', '    {\n', '        (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\n', '\n', '        return (error, Exp({mantissa: result}));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiply an Exp by a scalar, returning a new Exp.\n', '     */\n', '    function mulScalar(Exp memory a, uint256 scalar)\n', '        internal\n', '        pure\n', '        returns (MathError, Exp memory)\n', '    {\n', '        (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n', '     */\n', '    function mulScalarTruncate(Exp memory a, uint256 scalar)\n', '        internal\n', '        pure\n', '        returns (MathError, uint256)\n', '    {\n', '        (MathError err, Exp memory product) = mulScalar(a, scalar);\n', '        if (err != MathError.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return (MathError.NO_ERROR, truncate(product));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n', '     */\n', '    function mulScalarTruncateAddUInt(\n', '        Exp memory a,\n', '        uint256 scalar,\n', '        uint256 addend\n', '    ) internal pure returns (MathError, uint256) {\n', '        (MathError err, Exp memory product) = mulScalar(a, scalar);\n', '        if (err != MathError.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return addUInt(truncate(product), addend);\n', '    }\n', '\n', '    /**\n', '     * @dev Divide an Exp by a scalar, returning a new Exp.\n', '     */\n', '    function divScalar(Exp memory a, uint256 scalar)\n', '        internal\n', '        pure\n', '        returns (MathError, Exp memory)\n', '    {\n', '        (MathError err0, uint256 descaledMantissa) = divUInt(\n', '            a.mantissa,\n', '            scalar\n', '        );\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n', '    }\n', '\n', '    /**\n', '     * @dev Divide a scalar by an Exp, returning a new Exp.\n', '     */\n', '    function divScalarByExp(uint256 scalar, Exp memory divisor)\n', '        internal\n', '        pure\n', '        returns (MathError, Exp memory)\n', '    {\n', '        /*\n', '          We are doing this as:\n', '          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n', '\n', '          How it works:\n', '          Exp = a / b;\n', '          Scalar = s;\n', '          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n', '        */\n', '        (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '        return getExp(numerator, divisor.mantissa);\n', '    }\n', '\n', '    /**\n', '     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n', '     */\n', '    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor)\n', '        internal\n', '        pure\n', '        returns (MathError, uint256)\n', '    {\n', '        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n', '        if (err != MathError.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return (MathError.NO_ERROR, truncate(fraction));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies two exponentials, returning a new exponential.\n', '     */\n', '    function mulExp(Exp memory a, Exp memory b)\n', '        internal\n', '        pure\n', '        returns (MathError, Exp memory)\n', '    {\n', '        (MathError err0, uint256 doubleScaledProduct) = mulUInt(\n', '            a.mantissa,\n', '            b.mantissa\n', '        );\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        // We add half the scale before dividing so that we get rounding instead of truncation.\n', '        //  See "Listing 6" and text above it at https://accu.org/index.php/journals/1717\n', '        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n', '        (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(\n', '            halfExpScale,\n', '            doubleScaledProduct\n', '        );\n', '        if (err1 != MathError.NO_ERROR) {\n', '            return (err1, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (MathError err2, uint256 product) = divUInt(\n', '            doubleScaledProductWithHalfScale,\n', '            expScale\n', '        );\n', '        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n', '        assert(err2 == MathError.NO_ERROR);\n', '\n', '        return (MathError.NO_ERROR, Exp({mantissa: product}));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n', '     */\n', '    function mulExp(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (MathError, Exp memory)\n', '    {\n', '        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies three exponentials, returning a new exponential.\n', '     */\n', '    function mulExp3(\n', '        Exp memory a,\n', '        Exp memory b,\n', '        Exp memory c\n', '    ) internal pure returns (MathError, Exp memory) {\n', '        (MathError err, Exp memory ab) = mulExp(a, b);\n', '        if (err != MathError.NO_ERROR) {\n', '            return (err, ab);\n', '        }\n', '        return mulExp(ab, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two exponentials, returning a new exponential.\n', '     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n', '     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n', '     */\n', '    function divExp(Exp memory a, Exp memory b)\n', '        internal\n', '        pure\n', '        returns (MathError, Exp memory)\n', '    {\n', '        return getExp(a.mantissa, b.mantissa);\n', '    }\n', '\n', '    /**\n', '     * @dev Truncates the given exp to a whole number value.\n', '     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n', '     */\n', '    function truncate(Exp memory exp) internal pure returns (uint256) {\n', "        // Note: We are not using careful math here as we're performing a division that cannot fail\n", '        return exp.mantissa / expScale;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if first Exp is less than second Exp.\n', '     */\n', '    function lessThanExp(Exp memory left, Exp memory right)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return left.mantissa < right.mantissa;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if left Exp <= right Exp.\n', '     */\n', '    function lessThanOrEqualExp(Exp memory left, Exp memory right)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return left.mantissa <= right.mantissa;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if left Exp > right Exp.\n', '     */\n', '    function greaterThanExp(Exp memory left, Exp memory right)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return left.mantissa > right.mantissa;\n', '    }\n', '\n', '    /**\n', '     * @dev returns true if Exp is exactly zero\n', '     */\n', '    function isZeroExp(Exp memory value) internal pure returns (bool) {\n', '        return value.mantissa == 0;\n', '    }\n', '\n', '    function safe224(uint256 n, string memory errorMessage)\n', '        internal\n', '        pure\n', '        returns (uint224)\n', '    {\n', '        require(n < 2**224, errorMessage);\n', '        return uint224(n);\n', '    }\n', '\n', '    function safe32(uint256 n, string memory errorMessage)\n', '        internal\n', '        pure\n', '        returns (uint32)\n', '    {\n', '        require(n < 2**32, errorMessage);\n', '        return uint32(n);\n', '    }\n', '\n', '    function add_(Exp memory a, Exp memory b)\n', '        internal\n', '        pure\n', '        returns (Exp memory)\n', '    {\n', '        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n', '    }\n', '\n', '    function add_(Double memory a, Double memory b)\n', '        internal\n', '        pure\n', '        returns (Double memory)\n', '    {\n', '        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n', '    }\n', '\n', '    function add_(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return add_(a, b, "addition overflow");\n', '    }\n', '\n', '    function add_(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, errorMessage);\n', '        return c;\n', '    }\n', '\n', '    function sub_(Exp memory a, Exp memory b)\n', '        internal\n', '        pure\n', '        returns (Exp memory)\n', '    {\n', '        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n', '    }\n', '\n', '    function sub_(Double memory a, Double memory b)\n', '        internal\n', '        pure\n', '        returns (Double memory)\n', '    {\n', '        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n', '    }\n', '\n', '    function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub_(a, b, "subtraction underflow");\n', '    }\n', '\n', '    function sub_(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    function mul_(Exp memory a, Exp memory b)\n', '        internal\n', '        pure\n', '        returns (Exp memory)\n', '    {\n', '        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n', '    }\n', '\n', '    function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n', '        return Exp({mantissa: mul_(a.mantissa, b)});\n', '    }\n', '\n', '    function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\n', '        return mul_(a, b.mantissa) / expScale;\n', '    }\n', '\n', '    function mul_(Double memory a, Double memory b)\n', '        internal\n', '        pure\n', '        returns (Double memory)\n', '    {\n', '        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n', '    }\n', '\n', '    function mul_(Double memory a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (Double memory)\n', '    {\n', '        return Double({mantissa: mul_(a.mantissa, b)});\n', '    }\n', '\n', '    function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\n', '        return mul_(a, b.mantissa) / doubleScale;\n', '    }\n', '\n', '    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mul_(a, b, "multiplication overflow");\n', '    }\n', '\n', '    function mul_(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        if (a == 0 || b == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, errorMessage);\n', '        return c;\n', '    }\n', '\n', '    function div_(Exp memory a, Exp memory b)\n', '        internal\n', '        pure\n', '        returns (Exp memory)\n', '    {\n', '        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n', '    }\n', '\n', '    function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n', '        return Exp({mantissa: div_(a.mantissa, b)});\n', '    }\n', '\n', '    function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\n', '        return div_(mul_(a, expScale), b.mantissa);\n', '    }\n', '\n', '    function div_(Double memory a, Double memory b)\n', '        internal\n', '        pure\n', '        returns (Double memory)\n', '    {\n', '        return\n', '            Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n', '    }\n', '\n', '    function div_(Double memory a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (Double memory)\n', '    {\n', '        return Double({mantissa: div_(a.mantissa, b)});\n', '    }\n', '\n', '    function div_(uint256 a, Double memory b) internal pure returns (uint256) {\n', '        return div_(mul_(a, doubleScale), b.mantissa);\n', '    }\n', '\n', '    function div_(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div_(a, b, "divide by zero");\n', '    }\n', '\n', '    function div_(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    function fraction(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (Double memory)\n', '    {\n', '        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n', '    }\n', '}\n', '\n', 'contract CToken {\n', '    /*** User Interface ***/\n', '\n', '    function transfer(address dst, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address src,\n', '        address dst,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function balanceOfUnderlying(address owner) external returns (uint256);\n', '\n', '    function getAccountSnapshot(address account)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function borrowRatePerBlock() external view returns (uint256);\n', '\n', '    function supplyRatePerBlock() external view returns (uint256);\n', '\n', '    function totalBorrowsCurrent() external returns (uint256);\n', '\n', '    function borrowBalanceCurrent(address account) external returns (uint256);\n', '\n', '    function borrowBalanceStored(address account)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function exchangeRateCurrent() external returns (uint256);\n', '\n', '    function exchangeRateStored() external view returns (uint256);\n', '\n', '    function getCash() external view returns (uint256);\n', '\n', '    function accrueInterest() external returns (uint256);\n', '\n', '    function seize(\n', '        address liquidator,\n', '        address borrower,\n', '        uint256 seizeTokens\n', '    ) external returns (uint256);\n', '}\n', '\n', '\n', '\n', 'contract getAccountLiquidity is Exponential, ComptrollerErrorReporter {\n', '\n', '    struct AccountLiquidityLocalVars {\n', '        uint256 sumCollateral;\n', '        uint256 sumBorrowPlusEffects;\n', '        uint256 cTokenBalance;\n', '        uint256 borrowBalance;\n', '        uint256 exchangeRateMantissa;\n', '        uint256 oraclePriceMantissa;\n', '        Exp collateralFactor;\n', '        Exp exchangeRate;\n', '        Exp oraclePrice;\n', '        Exp tokensToDenom;\n', '    }\n', '\n', '    function getHypotheticalAccountLiquidity(\n', '        address account,\n', '        CToken[] memory assets,\n', '        uint256[] memory collateralFactorMantissa,\n', '        uint256[] memory underlyingPrice\n', '    )\n', '        public\n', '        view\n', '        returns (\n', '            Error,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n', '        uint256 oErr;\n', '        MathError mErr;\n', '\n', '        // For each asset the account is in\n', '        //CToken[] memory assets = accountAssets[account];\n', '        for (uint256 i = 0; i < assets.length; i++) {\n', '            CToken asset = assets[i];\n', '\n', '            // Read the balances and exchange rate from the cToken\n', '            (\n', '                oErr,\n', '                vars.cTokenBalance,\n', '                vars.borrowBalance,\n', '                vars.exchangeRateMantissa\n', '            ) = asset.getAccountSnapshot(account);\n', '            if (oErr != 0) {\n', '                // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n', '                return (Error.SNAPSHOT_ERROR, 0, 0, 0, 0);\n', '            }\n', '            //vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n', '            vars.collateralFactor = Exp({mantissa: collateralFactorMantissa[i]});\n', '            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n', '\n', '            // Get the normalized price of the asset\n', '            //vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n', '            vars.oraclePriceMantissa = underlyingPrice[i];\n', '            if (vars.oraclePriceMantissa == 0) {\n', '                return (Error.PRICE_ERROR, 0, 0, 0, 0);\n', '            }\n', '            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n', '\n', '            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n', '            (mErr, vars.tokensToDenom) = mulExp3(\n', '                vars.collateralFactor,\n', '                vars.exchangeRate,\n', '                vars.oraclePrice\n', '            );\n', '            if (mErr != MathError.NO_ERROR) {\n', '                return (Error.MATH_ERROR, 0, 0, 0, 0);\n', '            }\n', '\n', '            // sumCollateral += tokensToDenom * cTokenBalance\n', '            (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(\n', '                vars.tokensToDenom,\n', '                vars.cTokenBalance,\n', '                vars.sumCollateral\n', '            );\n', '            if (mErr != MathError.NO_ERROR) {\n', '                return (Error.MATH_ERROR, 0, 0, 0, 0);\n', '            }\n', '\n', '            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n', '            (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(\n', '                vars.oraclePrice,\n', '                vars.borrowBalance,\n', '                vars.sumBorrowPlusEffects\n', '            );\n', '            if (mErr != MathError.NO_ERROR) {\n', '                return (Error.MATH_ERROR, 0, 0, 0, 0);\n', '            }\n', '        }\n', '\n', '        // These are safe, as the underflow condition is checked first\n', '        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n', '            return (\n', '                Error.NO_ERROR,\n', '                vars.sumCollateral - vars.sumBorrowPlusEffects,\n', '                0,\n', '                vars.sumCollateral,\n', '                vars.sumBorrowPlusEffects\n', '            );\n', '        } else {\n', '            return (\n', '                Error.NO_ERROR,\n', '                0,\n', '                vars.sumBorrowPlusEffects - vars.sumCollateral,\n', '                vars.sumCollateral,\n', '                vars.sumBorrowPlusEffects\n', '            );\n', '        }\n', '    }\n', '}']