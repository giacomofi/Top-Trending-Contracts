['// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        require(token.transfer(to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        require(token.transferFrom(from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        require((value == 0) || (token.allowance(address(this), spender) == 0));\n', '        require(token.approve(spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        require(token.approve(spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        require(token.approve(spender, newAllowance));\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Elliptic curve signature operations\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' */\n', '\n', 'library ECDSA {\n', '    /**\n', '     * @dev Recover signer address from a message by using their signature\n', '     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '     * @param signature bytes signature, the signature is generated using web3.eth.sign()\n', '     */\n', '    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // Check the signature length\n', '        if (signature.length != 65) {\n', '            return (address(0));\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '\n', '        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        // If the version is correct return the signer address\n', '        if (v != 27 && v != 28) {\n', '            return (address(0));\n', '        } else {\n', '            return ecrecover(hash, v, r, s);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * toEthSignedMessageHash\n', '     * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '     * and hash the result\n', '     */\n', '    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n', '        // 32 is the length in bytes of hash,\n', '        // enforced by the type signature above\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/Roles.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an account access to this role\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(!has(role, account));\n', '\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev remove an account's access to this role\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(has(role, account));\n', '\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an account has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0));\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/roles/WhitelistAdminRole.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title WhitelistAdminRole\n', ' * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\n', ' */\n', 'contract WhitelistAdminRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistAdminAdded(address indexed account);\n', '    event WhitelistAdminRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelistAdmins;\n', '\n', '    constructor () internal {\n', '        _addWhitelistAdmin(msg.sender);\n', '    }\n', '\n', '    modifier onlyWhitelistAdmin() {\n', '        require(isWhitelistAdmin(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isWhitelistAdmin(address account) public view returns (bool) {\n', '        return _whitelistAdmins.has(account);\n', '    }\n', '\n', '    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\n', '        _addWhitelistAdmin(account);\n', '    }\n', '\n', '    function renounceWhitelistAdmin() public {\n', '        _removeWhitelistAdmin(msg.sender);\n', '    }\n', '\n', '    function _addWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.add(account);\n', '        emit WhitelistAdminAdded(account);\n', '    }\n', '\n', '    function _removeWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.remove(account);\n', '        emit WhitelistAdminRemoved(account);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/roles/WhitelistedRole.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/**\n', ' * @title WhitelistedRole\n', ' * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\n', ' * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\n', ' * it), and not Whitelisteds themselves.\n', ' */\n', 'contract WhitelistedRole is WhitelistAdminRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistedAdded(address indexed account);\n', '    event WhitelistedRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelisteds;\n', '\n', '    modifier onlyWhitelisted() {\n', '        require(isWhitelisted(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isWhitelisted(address account) public view returns (bool) {\n', '        return _whitelisteds.has(account);\n', '    }\n', '\n', '    function addWhitelisted(address account) public onlyWhitelistAdmin {\n', '        _addWhitelisted(account);\n', '    }\n', '\n', '    function removeWhitelisted(address account) public onlyWhitelistAdmin {\n', '        _removeWhitelisted(account);\n', '    }\n', '\n', '    function renounceWhitelisted() public {\n', '        _removeWhitelisted(msg.sender);\n', '    }\n', '\n', '    function _addWhitelisted(address account) internal {\n', '        _whitelisteds.add(account);\n', '        emit WhitelistedAdded(account);\n', '    }\n', '\n', '    function _removeWhitelisted(address account) internal {\n', '        _whitelisteds.remove(account);\n', '        emit WhitelistedRemoved(account);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', 'contract PauserRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event PauserAdded(address indexed account);\n', '    event PauserRemoved(address indexed account);\n', '\n', '    Roles.Role private _pausers;\n', '\n', '    constructor () internal {\n', '        _addPauser(msg.sender);\n', '    }\n', '\n', '    modifier onlyPauser() {\n', '        require(isPauser(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function isPauser(address account) public view returns (bool) {\n', '        return _pausers.has(account);\n', '    }\n', '\n', '    function addPauser(address account) public onlyPauser {\n', '        _addPauser(account);\n', '    }\n', '\n', '    function renouncePauser() public {\n', '        _removePauser(msg.sender);\n', '    }\n', '\n', '    function _addPauser(address account) internal {\n', '        _pausers.add(account);\n', '        emit PauserAdded(account);\n', '    }\n', '\n', '    function _removePauser(address account) internal {\n', '        _pausers.remove(account);\n', '        emit PauserRemoved(account);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is PauserRole {\n', '    event Paused(address account);\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @return true if the contract is paused, false otherwise.\n', '     */\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to pause, triggers stopped state\n', '     */\n', '    function pause() public onlyPauser whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev called by the owner to unpause, returns to normal state\n', '     */\n', '    function unpause() public onlyPauser whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(msg.sender);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/interface/IDPoS.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '/**\n', ' * @title DPoS interface\n', ' */\n', 'interface IDPoS {\n', '    enum ValidatorChangeType { Add, Removal }\n', '\n', '    // functions\n', '    function contributeToMiningPool(uint _amount) external;\n', '\n', '    function redeemMiningReward(address _receiver, uint _cumulativeReward) external;\n', '\n', '    function registerSidechain(address _addr) external;\n', '\n', '    function initializeCandidate(uint _minSelfStake, uint _commissionRate, uint _rateLockEndTime) external;\n', '\n', '    function announceIncreaseCommissionRate(uint _newRate, uint _newLockEndTime) external;\n', '\n', '    function confirmIncreaseCommissionRate() external;\n', '\n', '    function nonIncreaseCommissionRate(uint _newRate, uint _newLockEndTime) external;\n', '\n', '    function updateMinSelfStake(uint256 _minSelfStake) external;\n', '\n', '    function delegate(address _candidateAddr, uint _amount) external;\n', '\n', '    function withdrawFromUnbondedCandidate(address _candidateAddr, uint _amount) external;\n', '\n', '    function intendWithdraw(address _candidateAddr, uint _amount) external;\n', '\n', '    function confirmWithdraw(address _candidateAddr) external;\n', '\n', '    function claimValidator() external;\n', '\n', '    function confirmUnbondedCandidate(address _candidateAddr) external;\n', '\n', '    function slash(bytes calldata _penaltyRequest) external;\n', '\n', '    function validateMultiSigMessage(bytes calldata _request) external returns(bool);\n', '\n', '    function isValidDPoS() external view returns (bool);\n', '\n', '    function isValidator(address _addr) external view returns (bool);\n', '\n', '    function getValidatorNum() external view returns (uint);\n', '\n', '    function getMinStakingPool() external view returns (uint);\n', '\n', '    function getCandidateInfo(address _candidateAddr) external view returns (bool, uint, uint, uint, uint, uint, uint);\n', '\n', '    function getDelegatorInfo(address _candidateAddr, address _delegatorAddr) external view returns (uint, uint, uint[] memory, uint[] memory);\n', '\n', '    function getMinQuorumStakingPool() external view returns(uint);\n', '\n', '    function getTotalValidatorStakingPool() external view returns(uint);\n', '\n', "    // TODO: interface can't be inherited, so VoteType is not declared here\n", '    // function voteParam(uint _proposalId, VoteType _vote) external;\n', '\n', '    // function confirmParamProposal(uint _proposalId) external;\n', '\n', '    // function voteSidechain(uint _proposalId, VoteType _vote) external;\n', '\n', '    // function confirmSidechainProposal(uint _proposalId) external;\n', '\n', '    // events\n', '    event InitializeCandidate(address indexed candidate, uint minSelfStake, uint commissionRate, uint rateLockEndTime);\n', '\n', '    event CommissionRateAnnouncement(address indexed candidate, uint announcedRate, uint announcedLockEndTime);\n', '\n', '    event UpdateCommissionRate(address indexed candidate, uint newRate, uint newLockEndTime);\n', '\n', '    event UpdateMinSelfStake(address indexed candidate, uint minSelfStake);\n', '\n', '    event Delegate(address indexed delegator, address indexed candidate, uint newStake, uint stakingPool);\n', '\n', '    event ValidatorChange(address indexed ethAddr, ValidatorChangeType indexed changeType);\n', '\n', '    event WithdrawFromUnbondedCandidate(address indexed delegator, address indexed candidate, uint amount);\n', '\n', '    event IntendWithdraw(address indexed delegator, address indexed candidate, uint withdrawAmount, uint proposedTime);\n', '\n', '    event ConfirmWithdraw(address indexed delegator, address indexed candidate, uint amount);\n', '\n', '    event Slash(address indexed validator, address indexed delegator, uint amount);\n', '\n', '    event UpdateDelegatedStake(address indexed delegator, address indexed candidate, uint delegatorStake, uint candidatePool);\n', '\n', '    event Compensate(address indexed indemnitee, uint amount);\n', '\n', '    event CandidateUnbonded(address indexed candidate);\n', '\n', '    event RedeemMiningReward(address indexed receiver, uint reward, uint miningPool);\n', '\n', '    event MiningPoolContribution(address indexed contributor, uint contribution, uint miningPoolSize);\n', '}\n', '\n', '// File: contracts/lib/data/Pb.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '// runtime proto sol library\n', 'library Pb {\n', '    enum WireType { Varint, Fixed64, LengthDelim, StartGroup, EndGroup, Fixed32 }\n', '\n', '    struct Buffer {\n', "        uint idx;  // the start index of next read. when idx=b.length, we're done\n", '        bytes b;   // hold serialized proto msg, readonly\n', '    }\n', '\n', '    // create a new in-memory Buffer object from raw msg bytes\n', '    function fromBytes(bytes memory raw) internal pure returns (Buffer memory buf) {\n', '        buf.b = raw;\n', '        buf.idx = 0;\n', '    }\n', '\n', '    // whether there are unread bytes\n', '    function hasMore(Buffer memory buf) internal pure returns (bool) {\n', '        return buf.idx < buf.b.length;\n', '    }\n', '\n', '    // decode current field number and wiretype\n', '    function decKey(Buffer memory buf) internal pure returns (uint tag, WireType wiretype) {\n', '        uint v = decVarint(buf);\n', '        tag = v / 8;\n', '        wiretype = WireType(v & 7);\n', '    }\n', '\n', '    // count tag occurrences, return an array due to no memory map support\n', '\t// have to create array for (maxtag+1) size. cnts[tag] = occurrences\n', '\t// should keep buf.idx unchanged because this is only a count function\n', '    function cntTags(Buffer memory buf, uint maxtag) internal pure returns (uint[] memory cnts) {\n', '        uint originalIdx = buf.idx;\n', "        cnts = new uint[](maxtag+1);  // protobuf's tags are from 1 rather than 0\n", '        uint tag;\n', '        WireType wire;\n', '        while (hasMore(buf)) {\n', '            (tag, wire) = decKey(buf);\n', '            cnts[tag] += 1;\n', '            skipValue(buf, wire);\n', '        }\n', '        buf.idx = originalIdx;\n', '    }\n', '\n', '    // read varint from current buf idx, move buf.idx to next read, return the int value\n', '    function decVarint(Buffer memory buf) internal pure returns (uint v) {\n', '        bytes10 tmp;  // proto int is at most 10 bytes (7 bits can be used per byte)\n', '        bytes memory bb = buf.b;  // get buf.b mem addr to use in assembly\n', '        v = buf.idx;  // use v to save one additional uint variable\n', '        assembly {\n', '            tmp := mload(add(add(bb, 32), v)) // load 10 bytes from buf.b[buf.idx] to tmp\n', '        }\n', '        uint b; // store current byte content\n', '        v = 0; // reset to 0 for return value\n', '        for (uint i=0; i<10; i++) {\n', '            assembly {\n', "                b := byte(i, tmp)  // don't use tmp[i] because it does bound check and costs extra\n", '            }\n', '            v |= (b & 0x7F) << (i * 7);\n', '            if (b & 0x80 == 0) {\n', '                buf.idx += i + 1;\n', '                return v;\n', '            }\n', '        }\n', '        revert(); // i=10, invalid varint stream\n', '    }\n', '\n', '    // read length delimited field and return bytes\n', '    function decBytes(Buffer memory buf) internal pure returns (bytes memory b) {\n', '        uint len = decVarint(buf);\n', '        uint end = buf.idx + len;\n', '        require(end <= buf.b.length);  // avoid overflow\n', '        b = new bytes(len);\n', '        bytes memory bufB = buf.b;  // get buf.b mem addr to use in assembly\n', '        uint bStart;\n', '        uint bufBStart = buf.idx;\n', '        assembly {\n', '            bStart := add(b, 32)\n', '            bufBStart := add(add(bufB, 32), bufBStart)\n', '        }\n', '        for (uint i=0; i<len; i+=32) {\n', '            assembly{\n', '                mstore(add(bStart, i), mload(add(bufBStart, i)))\n', '            }\n', '        }\n', '        buf.idx = end;\n', '    }\n', '\n', '    // return packed ints\n', '    function decPacked(Buffer memory buf) internal pure returns (uint[] memory t) {\n', '        uint len = decVarint(buf);\n', '        uint end = buf.idx + len;\n', '        require(end <= buf.b.length);  // avoid overflow\n', '        // array in memory must be init w/ known length\n', '        // so we have to create a tmp array w/ max possible len first\n', '        uint[] memory tmp = new uint[](len);\n', '        uint i; // count how many ints are there\n', '        while (buf.idx < end) {\n', '            tmp[i] = decVarint(buf);\n', '            i++;\n', '        }\n', '        t = new uint[](i); // init t with correct length\n', '        for (uint j=0; j<i; j++) {\n', '            t[j] = tmp[j];\n', '        }\n', '        return t;\n', '    }\n', '\n', '    // move idx pass current value field, to beginning of next tag or msg end\n', '    function skipValue(Buffer memory buf, WireType wire) internal pure {\n', '        if (wire == WireType.Varint) { decVarint(buf); }\n', '        else if (wire == WireType.LengthDelim) {\n', '            uint len = decVarint(buf);\n', '            buf.idx += len; // skip len bytes value data\n', '            require(buf.idx <= buf.b.length);  // avoid overflow\n', '        } else { revert(); }  // unsupported wiretype\n', '    }\n', '\n', '    // type conversion help utils\n', '    function _bool(uint x) internal pure returns (bool v) {\n', '        return x != 0;\n', '    }\n', '\n', '    function _uint256(bytes memory b) internal pure returns (uint256 v) {\n', "        require(b.length <= 32);  // b's length must be smaller than or equal to 32\n", '        assembly { v := mload(add(b, 32)) }  // load all 32bytes to v\n', '        v = v >> (8 * (32 - b.length));  // only first b.length is valid\n', '    }\n', '\n', '    function _address(bytes memory b) internal pure returns (address v) {\n', '        v = _addressPayable(b);\n', '    }\n', '\n', '    function _addressPayable(bytes memory b) internal pure returns (address payable v) {\n', '        require(b.length == 20);\n', '        //load 32bytes then shift right 12 bytes\n', '        assembly { v := div(mload(add(b, 32)), 0x1000000000000000000000000) }\n', '    }\n', '\n', '    function _bytes32(bytes memory b) internal pure returns (bytes32 v) {\n', '        require(b.length == 32);\n', '        assembly { v := mload(add(b, 32)) }\n', '    }\n', '\n', '    // uint[] to uint8[]\n', '    function uint8s(uint[] memory arr) internal pure returns (uint8[] memory t) {\n', '        t = new uint8[](arr.length);\n', '        for (uint i = 0; i < t.length; i++) { t[i] = uint8(arr[i]); }\n', '    }\n', '\n', '    function uint32s(uint[] memory arr) internal pure returns (uint32[] memory t) {\n', '        t = new uint32[](arr.length);\n', '        for (uint i = 0; i < t.length; i++) { t[i] = uint32(arr[i]); }\n', '    }\n', '\n', '    function uint64s(uint[] memory arr) internal pure returns (uint64[] memory t) {\n', '        t = new uint64[](arr.length);\n', '        for (uint i = 0; i < t.length; i++) { t[i] = uint64(arr[i]); }\n', '    }\n', '\n', '    function bools(uint[] memory arr) internal pure returns (bool[] memory t) {\n', '        t = new bool[](arr.length);\n', '        for (uint i = 0; i < t.length; i++) { t[i] = arr[i]!=0; }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/data/PbSgn.sol\n', '\n', '// Code generated by protoc-gen-sol. DO NOT EDIT.\n', '// source: sgn.proto\n', 'pragma solidity 0.5.17;\n', '\n', '\n', 'library PbSgn {\n', '    using Pb for Pb.Buffer;  // so we can call Pb funcs on Buffer obj\n', '\n', '    struct MultiSigMessage {\n', '        bytes msg;   // tag: 1\n', '        bytes[] sigs;   // tag: 2\n', '    } // end struct MultiSigMessage\n', '\n', '    function decMultiSigMessage(bytes memory raw) internal pure returns (MultiSigMessage memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint[] memory cnts = buf.cntTags(2);\n', '        m.sigs = new bytes[](cnts[2]);\n', '        cnts[2] = 0;  // reset counter for later use\n', '        \n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.msg = bytes(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.sigs[cnts[2]] = bytes(buf.decBytes());\n', '                cnts[2]++;\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder MultiSigMessage\n', '\n', '    struct PenaltyRequest {\n', '        bytes penalty;   // tag: 1\n', '        bytes[] sigs;   // tag: 2\n', '    } // end struct PenaltyRequest\n', '\n', '    function decPenaltyRequest(bytes memory raw) internal pure returns (PenaltyRequest memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint[] memory cnts = buf.cntTags(2);\n', '        m.sigs = new bytes[](cnts[2]);\n', '        cnts[2] = 0;  // reset counter for later use\n', '        \n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.penalty = bytes(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.sigs[cnts[2]] = bytes(buf.decBytes());\n', '                cnts[2]++;\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder PenaltyRequest\n', '\n', '    struct RewardRequest {\n', '        bytes reward;   // tag: 1\n', '        bytes[] sigs;   // tag: 2\n', '    } // end struct RewardRequest\n', '\n', '    function decRewardRequest(bytes memory raw) internal pure returns (RewardRequest memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint[] memory cnts = buf.cntTags(2);\n', '        m.sigs = new bytes[](cnts[2]);\n', '        cnts[2] = 0;  // reset counter for later use\n', '        \n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.reward = bytes(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.sigs[cnts[2]] = bytes(buf.decBytes());\n', '                cnts[2]++;\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder RewardRequest\n', '\n', '    struct Penalty {\n', '        uint64 nonce;   // tag: 1\n', '        uint64 expireTime;   // tag: 2\n', '        address validatorAddress;   // tag: 3\n', '        AccountAmtPair[] penalizedDelegators;   // tag: 4\n', '        AccountAmtPair[] beneficiaries;   // tag: 5\n', '    } // end struct Penalty\n', '\n', '    function decPenalty(bytes memory raw) internal pure returns (Penalty memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint[] memory cnts = buf.cntTags(5);\n', '        m.penalizedDelegators = new AccountAmtPair[](cnts[4]);\n', '        cnts[4] = 0;  // reset counter for later use\n', '        m.beneficiaries = new AccountAmtPair[](cnts[5]);\n', '        cnts[5] = 0;  // reset counter for later use\n', '        \n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.nonce = uint64(buf.decVarint());\n', '            }\n', '            else if (tag == 2) {\n', '                m.expireTime = uint64(buf.decVarint());\n', '            }\n', '            else if (tag == 3) {\n', '                m.validatorAddress = Pb._address(buf.decBytes());\n', '            }\n', '            else if (tag == 4) {\n', '                m.penalizedDelegators[cnts[4]] = decAccountAmtPair(buf.decBytes());\n', '                cnts[4]++;\n', '            }\n', '            else if (tag == 5) {\n', '                m.beneficiaries[cnts[5]] = decAccountAmtPair(buf.decBytes());\n', '                cnts[5]++;\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder Penalty\n', '\n', '    struct AccountAmtPair {\n', '        address account;   // tag: 1\n', '        uint256 amt;   // tag: 2\n', '    } // end struct AccountAmtPair\n', '\n', '    function decAccountAmtPair(bytes memory raw) internal pure returns (AccountAmtPair memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.account = Pb._address(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.amt = Pb._uint256(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder AccountAmtPair\n', '\n', '    struct Reward {\n', '        address receiver;   // tag: 1\n', '        uint256 cumulativeMiningReward;   // tag: 2\n', '        uint256 cumulativeServiceReward;   // tag: 3\n', '    } // end struct Reward\n', '\n', '    function decReward(bytes memory raw) internal pure returns (Reward memory m) {\n', '        Pb.Buffer memory buf = Pb.fromBytes(raw);\n', '\n', '        uint tag;\n', '        Pb.WireType wire;\n', '        while (buf.hasMore()) {\n', '            (tag, wire) = buf.decKey();\n', '            if (false) {} // solidity has no switch/case\n', '            else if (tag == 1) {\n', '                m.receiver = Pb._address(buf.decBytes());\n', '            }\n', '            else if (tag == 2) {\n', '                m.cumulativeMiningReward = Pb._uint256(buf.decBytes());\n', '            }\n', '            else if (tag == 3) {\n', '                m.cumulativeServiceReward = Pb._uint256(buf.decBytes());\n', '            }\n', '            else { buf.skipValue(wire); } // skip value of unknown tag\n', '        }\n', '    } // end decoder Reward\n', '\n', '}\n', '\n', '// File: contracts/lib/DPoSCommon.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '/**\n', ' * @title DPoS contract common Library\n', ' * @notice Common items used in DPoS contract\n', ' */\n', 'library DPoSCommon {\n', '    // Unbonded: not a validator and not responsible for previous validator behaviors if any.\n', '    //   Delegators now are free to withdraw stakes (directly).\n', '    // Bonded: active validator. Delegators have to wait for slashTimeout to withdraw stakes.\n', '    // Unbonding: transitional status from Bonded to Unbonded. Candidate has lost the right of\n', '    //   validator but is still responsible for any misbehaviour done during being validator.\n', "    //   Delegators should wait until candidate's unbondTime to freely withdraw stakes.\n", '    enum CandidateStatus { Unbonded, Bonded, Unbonding }\n', '}\n', '\n', '// File: contracts/lib/interface/IGovern.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '/**\n', ' * @title Govern interface\n', ' */\n', 'interface IGovern {\n', '    enum ParamNames { ProposalDeposit, GovernVoteTimeout, SlashTimeout, MinValidatorNum, MaxValidatorNum, MinStakeInPool, AdvanceNoticePeriod, MigrationTime }\n', '\n', '    enum ProposalStatus { Uninitiated, Voting, Closed }\n', '\n', '    enum VoteType { Unvoted, Yes, No, Abstain }\n', '\n', '    // functions\n', '    function getUIntValue(uint _record) external view returns (uint);\n', '\n', '    function getParamProposalVote(uint _proposalId, address _voter) external view returns (VoteType);\n', '\n', '    function isSidechainRegistered(address _sidechainAddr) external view returns (bool);\n', '\n', '    function getSidechainProposalVote(uint _proposalId, address _voter) external view returns (VoteType);\n', '\n', '    function createParamProposal(uint _record, uint _value) external;\n', '\n', '    function registerSidechain(address _addr) external;\n', '\n', '    function createSidechainProposal(address _sidechainAddr, bool _registered) external;\n', '\n', '    // events\n', '    event CreateParamProposal(uint proposalId, address proposer, uint deposit, uint voteDeadline, uint record, uint newValue);\n', '\n', '    event VoteParam(uint proposalId, address voter, VoteType voteType);\n', '\n', '    event ConfirmParamProposal(uint proposalId, bool passed, uint record, uint newValue);\n', '\n', '    event CreateSidechainProposal(uint proposalId, address proposer, uint deposit, uint voteDeadline, address sidechainAddr, bool registered);\n', '\n', '    event VoteSidechain(uint proposalId, address voter, VoteType voteType);\n', '\n', '    event ConfirmSidechainProposal(uint proposalId, bool passed, address sidechainAddr, bool registered);\n', '}\n', '\n', '// File: contracts/lib/Govern.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Governance module for DPoS contract\n', ' * @notice Govern contract implements the basic governance logic\n', ' * @dev DPoS contract should inherit this contract\n', ' * @dev Some specific functions of governance are defined in DPoS contract\n', ' */\n', 'contract Govern is IGovern, Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    struct ParamProposal {\n', '        address proposer;\n', '        uint256 deposit;\n', '        uint256 voteDeadline;\n', '        uint256 record;\n', '        uint256 newValue;\n', '        ProposalStatus status;\n', '        mapping(address => VoteType) votes;\n', '    }\n', '\n', '    struct SidechainProposal {\n', '        address proposer;\n', '        uint256 deposit;\n', '        uint256 voteDeadline;\n', '        address sidechainAddr;\n', '        bool registered;\n', '        ProposalStatus status;\n', '        mapping(address => VoteType) votes;\n', '    }\n', '\n', '    IERC20 public celerToken;\n', '    // parameters\n', '    mapping(uint256 => uint256) public UIntStorage;\n', '    mapping(uint256 => ParamProposal) public paramProposals;\n', '    uint256 public nextParamProposalId;\n', '    // registered sidechain addresses\n', '    mapping(address => bool) public registeredSidechains;\n', '    mapping(uint256 => SidechainProposal) public sidechainProposals;\n', '    uint256 public nextSidechainProposalId;\n', '\n', '    /**\n', '     * @notice Govern constructor\n', '     * @dev set celerToken and initialize all parameters\n', '     * @param _celerTokenAddress address of the governance token\n', '     * @param _governProposalDeposit required deposit amount for a governance proposal\n', '     * @param _governVoteTimeout voting timeout for a governance proposal\n', '     * @param _slashTimeout the locking time for funds to be potentially slashed\n', '     * @param _minValidatorNum the minimum number of validators\n', '     * @param _maxValidatorNum the maximum number of validators\n', '     * @param _minStakeInPool the global minimum requirement of staking pool for each validator\n', '     * @param _advanceNoticePeriod the time after the announcement and prior to the effective time of an update\n', '     */\n', '    constructor(\n', '        address _celerTokenAddress,\n', '        uint256 _governProposalDeposit,\n', '        uint256 _governVoteTimeout,\n', '        uint256 _slashTimeout,\n', '        uint256 _minValidatorNum,\n', '        uint256 _maxValidatorNum,\n', '        uint256 _minStakeInPool,\n', '        uint256 _advanceNoticePeriod\n', '    ) public {\n', '        celerToken = IERC20(_celerTokenAddress);\n', '\n', '        UIntStorage[uint256(ParamNames.ProposalDeposit)] = _governProposalDeposit;\n', '        UIntStorage[uint256(ParamNames.GovernVoteTimeout)] = _governVoteTimeout;\n', '        UIntStorage[uint256(ParamNames.SlashTimeout)] = _slashTimeout;\n', '        UIntStorage[uint256(ParamNames.MinValidatorNum)] = _minValidatorNum;\n', '        UIntStorage[uint256(ParamNames.MaxValidatorNum)] = _maxValidatorNum;\n', '        UIntStorage[uint256(ParamNames.MinStakeInPool)] = _minStakeInPool;\n', '        UIntStorage[uint256(ParamNames.AdvanceNoticePeriod)] = _advanceNoticePeriod;\n', '    }\n', '\n', '    /********** Get functions **********/\n', '    /**\n', '     * @notice Get the value of a specific uint parameter\n', '     * @param _record the key of this parameter\n', '     * @return the value of this parameter\n', '     */\n', '    function getUIntValue(uint256 _record) public view returns (uint256) {\n', '        return UIntStorage[_record];\n', '    }\n', '\n', '    /**\n', '     * @notice Get the vote type of a voter on a parameter proposal\n', '     * @param _proposalId the proposal id\n', '     * @param _voter the voter address\n', '     * @return the vote type of the given voter on the given parameter proposal\n', '     */\n', '    function getParamProposalVote(uint256 _proposalId, address _voter)\n', '        public\n', '        view\n', '        returns (VoteType)\n', '    {\n', '        return paramProposals[_proposalId].votes[_voter];\n', '    }\n', '\n', '    /**\n', '     * @notice Get whether a sidechain is registered or not\n', '     * @param _sidechainAddr the sidechain contract address\n', '     * @return whether the given sidechain is registered or not\n', '     */\n', '    function isSidechainRegistered(address _sidechainAddr) public view returns (bool) {\n', '        return registeredSidechains[_sidechainAddr];\n', '    }\n', '\n', '    /**\n', '     * @notice Get the vote type of a voter on a sidechain proposal\n', '     * @param _proposalId the proposal id\n', '     * @param _voter the voter address\n', '     * @return the vote type of the given voter on the given sidechain proposal\n', '     */\n', '    function getSidechainProposalVote(uint256 _proposalId, address _voter)\n', '        public\n', '        view\n', '        returns (VoteType)\n', '    {\n', '        return sidechainProposals[_proposalId].votes[_voter];\n', '    }\n', '\n', '    /********** Governance functions **********/\n', '    /**\n', '     * @notice Create a parameter proposal\n', '     * @param _record the key of this parameter\n', '     * @param _value the new proposed value of this parameter\n', '     */\n', '    function createParamProposal(uint256 _record, uint256 _value) external {\n', '        ParamProposal storage p = paramProposals[nextParamProposalId];\n', '        nextParamProposalId = nextParamProposalId + 1;\n', '        address msgSender = msg.sender;\n', '        uint256 deposit = UIntStorage[uint256(ParamNames.ProposalDeposit)];\n', '\n', '        p.proposer = msgSender;\n', '        p.deposit = deposit;\n', '        p.voteDeadline = block.number.add(UIntStorage[uint256(ParamNames.GovernVoteTimeout)]);\n', '        p.record = _record;\n', '        p.newValue = _value;\n', '        p.status = ProposalStatus.Voting;\n', '\n', '        celerToken.safeTransferFrom(msgSender, address(this), deposit);\n', '\n', '        emit CreateParamProposal(\n', '            nextParamProposalId - 1,\n', '            msgSender,\n', '            deposit,\n', '            p.voteDeadline,\n', '            _record,\n', '            _value\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Internal function to vote for a parameter proposal\n', '     * @dev Must be used in DPoS contract\n', '     * @param _proposalId the proposal id\n', '     * @param _voter the voter address\n', '     * @param _vote the vote type\n', '     */\n', '    function internalVoteParam(\n', '        uint256 _proposalId,\n', '        address _voter,\n', '        VoteType _vote\n', '    ) internal {\n', '        ParamProposal storage p = paramProposals[_proposalId];\n', "        require(p.status == ProposalStatus.Voting, 'Invalid proposal status');\n", "        require(block.number < p.voteDeadline, 'Vote deadline reached');\n", "        require(p.votes[_voter] == VoteType.Unvoted, 'Voter has voted');\n", '\n', '        p.votes[_voter] = _vote;\n', '\n', '        emit VoteParam(_proposalId, _voter, _vote);\n', '    }\n', '\n', '    /**\n', '     * @notice Internal function to confirm a parameter proposal\n', '     * @dev Must be used in DPoS contract\n', '     * @param _proposalId the proposal id\n', '     * @param _passed proposal passed or not\n', '     */\n', '    function internalConfirmParamProposal(uint256 _proposalId, bool _passed) internal {\n', '        ParamProposal storage p = paramProposals[_proposalId];\n', "        require(p.status == ProposalStatus.Voting, 'Invalid proposal status');\n", "        require(block.number >= p.voteDeadline, 'Vote deadline not reached');\n", '\n', '        p.status = ProposalStatus.Closed;\n', '        if (_passed) {\n', '            celerToken.safeTransfer(p.proposer, p.deposit);\n', '            UIntStorage[p.record] = p.newValue;\n', '        }\n', '\n', '        emit ConfirmParamProposal(_proposalId, _passed, p.record, p.newValue);\n', '    }\n', '\n', '    //\n', '    /**\n', '     * @notice Register a sidechain by contract owner\n', '     * @dev Owner can renounce Ownership if needed for this function\n', '     * @param _addr the sidechain contract address\n', '     */\n', '    function registerSidechain(address _addr) external onlyOwner {\n', '        registeredSidechains[_addr] = true;\n', '    }\n', '\n', '    /**\n', '     * @notice Create a sidechain proposal\n', '     * @param _sidechainAddr the sidechain contract address\n', '     * @param _registered the new proposed registration status\n', '     */\n', '    function createSidechainProposal(address _sidechainAddr, bool _registered) external {\n', '        SidechainProposal storage p = sidechainProposals[nextSidechainProposalId];\n', '        nextSidechainProposalId = nextSidechainProposalId + 1;\n', '        address msgSender = msg.sender;\n', '        uint256 deposit = UIntStorage[uint256(ParamNames.ProposalDeposit)];\n', '\n', '        p.proposer = msgSender;\n', '        p.deposit = deposit;\n', '        p.voteDeadline = block.number.add(UIntStorage[uint256(ParamNames.GovernVoteTimeout)]);\n', '        p.sidechainAddr = _sidechainAddr;\n', '        p.registered = _registered;\n', '        p.status = ProposalStatus.Voting;\n', '\n', '        celerToken.safeTransferFrom(msgSender, address(this), deposit);\n', '\n', '        emit CreateSidechainProposal(\n', '            nextSidechainProposalId - 1,\n', '            msgSender,\n', '            deposit,\n', '            p.voteDeadline,\n', '            _sidechainAddr,\n', '            _registered\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Internal function to vote for a sidechain proposal\n', '     * @dev Must be used in DPoS contract\n', '     * @param _proposalId the proposal id\n', '     * @param _voter the voter address\n', '     * @param _vote the vote type\n', '     */\n', '    function internalVoteSidechain(\n', '        uint256 _proposalId,\n', '        address _voter,\n', '        VoteType _vote\n', '    ) internal {\n', '        SidechainProposal storage p = sidechainProposals[_proposalId];\n', "        require(p.status == ProposalStatus.Voting, 'Invalid proposal status');\n", "        require(block.number < p.voteDeadline, 'Vote deadline reached');\n", "        require(p.votes[_voter] == VoteType.Unvoted, 'Voter has voted');\n", '\n', '        p.votes[_voter] = _vote;\n', '\n', '        emit VoteSidechain(_proposalId, _voter, _vote);\n', '    }\n', '\n', '    /**\n', '     * @notice Internal function to confirm a sidechain proposal\n', '     * @dev Must be used in DPoS contract\n', '     * @param _proposalId the proposal id\n', '     * @param _passed proposal passed or not\n', '     */\n', '    function internalConfirmSidechainProposal(uint256 _proposalId, bool _passed) internal {\n', '        SidechainProposal storage p = sidechainProposals[_proposalId];\n', "        require(p.status == ProposalStatus.Voting, 'Invalid proposal status');\n", "        require(block.number >= p.voteDeadline, 'Vote deadline not reached');\n", '\n', '        p.status = ProposalStatus.Closed;\n', '        if (_passed) {\n', '            celerToken.safeTransfer(p.proposer, p.deposit);\n', '            registeredSidechains[p.sidechainAddr] = p.registered;\n', '        }\n', '\n', '        emit ConfirmSidechainProposal(_proposalId, _passed, p.sidechainAddr, p.registered);\n', '    }\n', '}\n', '\n', '// File: contracts/DPoS.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title A DPoS contract shared by every sidechain\n', " * @notice This contract holds the basic logic of DPoS in Celer's coherent sidechain system\n", ' */\n', 'contract DPoS is IDPoS, Ownable, Pausable, WhitelistedRole, Govern {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '    using ECDSA for bytes32;\n', '\n', '    enum MathOperation { Add, Sub }\n', '\n', '    struct WithdrawIntent {\n', '        uint256 amount;\n', '        uint256 proposedTime;\n', '    }\n', '\n', '    struct Delegator {\n', '        uint256 delegatedStake;\n', '        uint256 undelegatingStake;\n', '        mapping(uint256 => WithdrawIntent) withdrawIntents;\n', '        // valid intent range is [intentStartIndex, intentEndIndex)\n', '        uint256 intentStartIndex;\n', '        uint256 intentEndIndex;\n', '    }\n', '\n', '    struct ValidatorCandidate {\n', '        bool initialized;\n', '        uint256 minSelfStake;\n', '        uint256 stakingPool; // sum of all delegations to this candidate\n', '        mapping(address => Delegator) delegatorProfiles;\n', '        DPoSCommon.CandidateStatus status;\n', '        uint256 unbondTime;\n', '        uint256 commissionRate; // equal to real commission rate * COMMISSION_RATE_BASE\n', '        uint256 rateLockEndTime; // must be monotonic increasing. Use block number\n', '        // for the announcement of increasing commission rate\n', '        uint256 announcedRate;\n', '        uint256 announcedLockEndTime;\n', '        uint256 announcementTime;\n', '        // for decreasing minSelfStake\n', '        uint256 earliestBondTime;\n', '    }\n', '\n', '    mapping(uint256 => address) public validatorSet;\n', '    mapping(uint256 => bool) public usedPenaltyNonce;\n', '    // used in checkValidatorSigs(). mapping has to be storage type.\n', '    mapping(address => bool) public checkedValidators;\n', "    // struct ValidatorCandidate includes a mapping and therefore candidateProfiles can't be public\n", '    mapping(address => ValidatorCandidate) private candidateProfiles;\n', '    mapping(address => uint256) public redeemedMiningReward;\n', '\n', '    /********** Constants **********/\n', '    uint256 constant DECIMALS_MULTIPLIER = 10**18;\n', '    uint256 public constant COMMISSION_RATE_BASE = 10000; // 1 commissionRate means 0.01%\n', '\n', '    uint256 public dposGoLiveTime; // used when bootstrapping initial validators\n', '    uint256 public miningPool;\n', '    bool public enableWhitelist;\n', '    bool public enableSlash;\n', '\n', '    /**\n', '     * @notice Throws if given address is zero address\n', '     * @param _addr address to be checked\n', '     */\n', '    modifier onlyNonZeroAddr(address _addr) {\n', "        require(_addr != address(0), '0 address');\n", '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Throws if DPoS is not valid\n', "     * @dev Need to be checked before DPoS's operations\n", '     */\n', '    modifier onlyValidDPoS() {\n', "        require(isValidDPoS(), 'DPoS is not valid');\n", '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Throws if msg.sender is not a registered sidechain\n', '     */\n', '    modifier onlyRegisteredSidechains() {\n', "        require(isSidechainRegistered(msg.sender), 'Sidechain not registered');\n", '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Check if the sender is in the whitelist\n', '     */\n', '    modifier onlyWhitelist() {\n', '        if (enableWhitelist) {\n', '            require(\n', '                isWhitelisted(msg.sender),\n', "                'WhitelistedRole: caller does not have the Whitelisted role'\n", '            );\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Throws if contract in migrating state\n', '     */\n', '    modifier onlyNotMigrating() {\n', "        require(!isMigrating(), 'contract migrating');\n", '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Throws if amount is smaller than minimum\n', '     */\n', '    modifier minAmount(uint256 _amount, uint256 _min) {\n', "        require(_amount >= _min, 'Amount is smaller than minimum requirement');\n", '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Throws if sender is not validator\n', '     */\n', '    modifier onlyValidator() {\n', "        require(isValidator(msg.sender), 'msg sender is not a validator');\n", '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Throws if candidate is not initialized\n', '     */\n', '    modifier isCandidateInitialized() {\n', "        require(candidateProfiles[msg.sender].initialized, 'Candidate is not initialized');\n", '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice DPoS constructor\n', '     * @dev will initialize parent contract Govern first\n', '     * @param _celerTokenAddress address of Celer Token Contract\n', '     * @param _governProposalDeposit required deposit amount for a governance proposal\n', '     * @param _governVoteTimeout voting timeout for a governance proposal\n', '     * @param _slashTimeout the locking time for funds to be potentially slashed\n', '     * @param _minValidatorNum the minimum number of validators\n', '     * @param _maxValidatorNum the maximum number of validators\n', '     * @param _minStakeInPool the global minimum requirement of staking pool for each validator\n', '     * @param _advanceNoticePeriod the wait time after the announcement and prior to the effective date of an update\n', '     * @param _dposGoLiveTimeout the timeout for DPoS to go live after contract creation\n', '     */\n', '    constructor(\n', '        address _celerTokenAddress,\n', '        uint256 _governProposalDeposit,\n', '        uint256 _governVoteTimeout,\n', '        uint256 _slashTimeout,\n', '        uint256 _minValidatorNum,\n', '        uint256 _maxValidatorNum,\n', '        uint256 _minStakeInPool,\n', '        uint256 _advanceNoticePeriod,\n', '        uint256 _dposGoLiveTimeout\n', '    )\n', '        public\n', '        Govern(\n', '            _celerTokenAddress,\n', '            _governProposalDeposit,\n', '            _governVoteTimeout,\n', '            _slashTimeout,\n', '            _minValidatorNum,\n', '            _maxValidatorNum,\n', '            _minStakeInPool,\n', '            _advanceNoticePeriod\n', '        )\n', '    {\n', '        dposGoLiveTime = block.number.add(_dposGoLiveTimeout);\n', '        enableSlash = true;\n', '    }\n', '\n', '    /**\n', '     * @notice Update enableWhitelist\n', '     * @param _enable enable whitelist flag\n', '     */\n', '    function updateEnableWhitelist(bool _enable) external onlyOwner {\n', '        enableWhitelist = _enable;\n', '    }\n', '\n', '    /**\n', '     * @notice Update enableSlash\n', '     * @param _enable enable slash flag\n', '     */\n', '    function updateEnableSlash(bool _enable) external onlyOwner {\n', '        enableSlash = _enable;\n', '    }\n', '\n', '    /**\n', '     * @notice Owner drains one type of tokens when the contract is paused\n', '     * @dev This is for emergency situations.\n', '     * @param _amount drained token amount\n', '     */\n', '    function drainToken(uint256 _amount) external whenPaused onlyOwner {\n', '        celerToken.safeTransfer(msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '     * @notice Vote for a parameter proposal with a specific type of vote\n', '     * @param _proposalId the id of the parameter proposal\n', '     * @param _vote the type of vote\n', '     */\n', '    function voteParam(uint256 _proposalId, VoteType _vote) external onlyValidator {\n', '        internalVoteParam(_proposalId, msg.sender, _vote);\n', '    }\n', '\n', '    /**\n', '     * @notice Confirm a parameter proposal\n', '     * @param _proposalId the id of the parameter proposal\n', '     */\n', '    function confirmParamProposal(uint256 _proposalId) external {\n', '        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\n', '\n', '        // check Yes votes only now\n', '        uint256 yesVoteStakes;\n', '        for (uint256 i = 0; i < maxValidatorNum; i++) {\n', '            if (getParamProposalVote(_proposalId, validatorSet[i]) == VoteType.Yes) {\n', '                yesVoteStakes = yesVoteStakes.add(candidateProfiles[validatorSet[i]].stakingPool);\n', '            }\n', '        }\n', '\n', '        bool passed = yesVoteStakes >= getMinQuorumStakingPool();\n', '        if (!passed) {\n', '            miningPool = miningPool.add(paramProposals[_proposalId].deposit);\n', '        }\n', '        internalConfirmParamProposal(_proposalId, passed);\n', '    }\n', '\n', '    /**\n', '     * @notice Vote for a sidechain proposal with a specific type of vote\n', '     * @param _proposalId the id of the sidechain proposal\n', '     * @param _vote the type of vote\n', '     */\n', '    function voteSidechain(uint256 _proposalId, VoteType _vote) external onlyValidator {\n', '        internalVoteSidechain(_proposalId, msg.sender, _vote);\n', '    }\n', '\n', '    /**\n', '     * @notice Confirm a sidechain proposal\n', '     * @param _proposalId the id of the sidechain proposal\n', '     */\n', '    function confirmSidechainProposal(uint256 _proposalId) external {\n', '        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\n', '\n', '        // check Yes votes only now\n', '        uint256 yesVoteStakes;\n', '        for (uint256 i = 0; i < maxValidatorNum; i++) {\n', '            if (getSidechainProposalVote(_proposalId, validatorSet[i]) == VoteType.Yes) {\n', '                yesVoteStakes = yesVoteStakes.add(candidateProfiles[validatorSet[i]].stakingPool);\n', '            }\n', '        }\n', '\n', '        bool passed = yesVoteStakes >= getMinQuorumStakingPool();\n', '        if (!passed) {\n', '            miningPool = miningPool.add(sidechainProposals[_proposalId].deposit);\n', '        }\n', '        internalConfirmSidechainProposal(_proposalId, passed);\n', '    }\n', '\n', '    /**\n', '     * @notice Contribute CELR tokens to the mining pool\n', '     * @param _amount the amount of CELR tokens to contribute\n', '     */\n', '    function contributeToMiningPool(uint256 _amount) external whenNotPaused {\n', '        address msgSender = msg.sender;\n', '        miningPool = miningPool.add(_amount);\n', '        celerToken.safeTransferFrom(msgSender, address(this), _amount);\n', '\n', '        emit MiningPoolContribution(msgSender, _amount, miningPool);\n', '    }\n', '\n', '    /**\n', '     * @notice Redeem mining reward\n', '     * @dev The validation of this redeeming operation should be done by the caller, a registered sidechain contract\n', '     * @dev Here we use cumulative mining reward to simplify the logic in sidechain code\n', '     * @param _receiver the receiver of the redeemed mining reward\n', '     * @param _cumulativeReward the latest cumulative mining reward\n', '     */\n', '    function redeemMiningReward(address _receiver, uint256 _cumulativeReward)\n', '        external\n', '        whenNotPaused\n', '        onlyRegisteredSidechains\n', '    {\n', '        uint256 newReward = _cumulativeReward.sub(redeemedMiningReward[_receiver]);\n', "        require(miningPool >= newReward, 'Mining pool is smaller than new reward');\n", '\n', '        redeemedMiningReward[_receiver] = _cumulativeReward;\n', '        miningPool = miningPool.sub(newReward);\n', '        celerToken.safeTransfer(_receiver, newReward);\n', '\n', '        emit RedeemMiningReward(_receiver, newReward, miningPool);\n', '    }\n', '\n', '    /**\n', '     * @notice Initialize a candidate profile for validator\n', '     * @dev every validator must become a candidate first\n', '     * @param _minSelfStake minimal amount of tokens staked by the validator itself\n', '     * @param _commissionRate the self-declaimed commission rate\n', '     * @param _rateLockEndTime the lock end time of initial commission rate\n', '     */\n', '    function initializeCandidate(\n', '        uint256 _minSelfStake,\n', '        uint256 _commissionRate,\n', '        uint256 _rateLockEndTime\n', '    ) external whenNotPaused onlyWhitelist {\n', '        ValidatorCandidate storage candidate = candidateProfiles[msg.sender];\n', "        require(!candidate.initialized, 'Candidate is initialized');\n", "        require(_commissionRate <= COMMISSION_RATE_BASE, 'Invalid commission rate');\n", '\n', '        candidate.initialized = true;\n', '        candidate.minSelfStake = _minSelfStake;\n', '        candidate.commissionRate = _commissionRate;\n', '        candidate.rateLockEndTime = _rateLockEndTime;\n', '\n', '        emit InitializeCandidate(msg.sender, _minSelfStake, _commissionRate, _rateLockEndTime);\n', '    }\n', '\n', '    /**\n', '     * @notice Apply non-increase-commission-rate changes to commission rate or lock end time,\n', '     *   including decreasing commission rate and/or changing lock end time\n', '     * @dev It can increase lock end time immediately without waiting\n', '     * @param _newRate new commission rate\n', '     * @param _newLockEndTime new lock end time\n', '     */\n', '    function nonIncreaseCommissionRate(uint256 _newRate, uint256 _newLockEndTime)\n', '        external\n', '        isCandidateInitialized\n', '    {\n', '        ValidatorCandidate storage candidate = candidateProfiles[msg.sender];\n', "        require(_newRate <= candidate.commissionRate, 'Invalid new rate');\n", '\n', '        _updateCommissionRate(candidate, _newRate, _newLockEndTime);\n', '    }\n', '\n', '    /**\n', '     * @notice Announce the intent of increasing the commission rate\n', '     * @param _newRate new commission rate\n', '     * @param _newLockEndTime new lock end time\n', '     */\n', '    function announceIncreaseCommissionRate(uint256 _newRate, uint256 _newLockEndTime)\n', '        external\n', '        isCandidateInitialized\n', '    {\n', '        ValidatorCandidate storage candidate = candidateProfiles[msg.sender];\n', "        require(candidate.commissionRate < _newRate, 'Invalid new rate');\n", '\n', '        candidate.announcedRate = _newRate;\n', '        candidate.announcedLockEndTime = _newLockEndTime;\n', '        candidate.announcementTime = block.number;\n', '\n', '        emit CommissionRateAnnouncement(msg.sender, _newRate, _newLockEndTime);\n', '    }\n', '\n', '    /**\n', '     * @notice Confirm the intent of increasing the commission rate\n', '     */\n', '    function confirmIncreaseCommissionRate() external isCandidateInitialized {\n', '        ValidatorCandidate storage candidate = candidateProfiles[msg.sender];\n', '        require(\n', '            block.number >\n', '                candidate.announcementTime.add(\n', '                    getUIntValue(uint256(ParamNames.AdvanceNoticePeriod))\n', '                ),\n', "            'Still in notice period'\n", '        );\n', '\n', '        _updateCommissionRate(candidate, candidate.announcedRate, candidate.announcedLockEndTime);\n', '\n', '        delete candidate.announcedRate;\n', '        delete candidate.announcedLockEndTime;\n', '        delete candidate.announcementTime;\n', '    }\n', '\n', '    /**\n', '     * @notice update minimal self stake value\n', '     * @param _minSelfStake minimal amount of tokens staked by the validator itself\n', '     */\n', '    function updateMinSelfStake(uint256 _minSelfStake) external isCandidateInitialized {\n', '        ValidatorCandidate storage candidate = candidateProfiles[msg.sender];\n', '        if (_minSelfStake < candidate.minSelfStake) {\n', "            require(candidate.status != DPoSCommon.CandidateStatus.Bonded, 'Candidate is bonded');\n", '            candidate.earliestBondTime = block.number.add(\n', '                getUIntValue(uint256(ParamNames.AdvanceNoticePeriod))\n', '            );\n', '        }\n', '        candidate.minSelfStake = _minSelfStake;\n', '        emit UpdateMinSelfStake(msg.sender, _minSelfStake);\n', '    }\n', '\n', '    /**\n', '     * @notice Delegate CELR tokens to a candidate\n', '     * @param _candidateAddr candidate to delegate\n', '     * @param _amount the amount of delegated CELR tokens\n', '     */\n', '    function delegate(address _candidateAddr, uint256 _amount)\n', '        external\n', '        whenNotPaused\n', '        onlyNonZeroAddr(_candidateAddr)\n', '        minAmount(_amount, 1 * DECIMALS_MULTIPLIER) // minimal amount per delegate operation is 1 CELR\n', '    {\n', '        ValidatorCandidate storage candidate = candidateProfiles[_candidateAddr];\n', "        require(candidate.initialized, 'Candidate is not initialized');\n", '\n', '        address msgSender = msg.sender;\n', '        _updateDelegatedStake(candidate, _candidateAddr, msgSender, _amount, MathOperation.Add);\n', '\n', '        celerToken.safeTransferFrom(msgSender, address(this), _amount);\n', '\n', '        emit Delegate(msgSender, _candidateAddr, _amount, candidate.stakingPool);\n', '    }\n', '\n', '    /**\n', '     * @notice Candidate claims to become a validator\n', '     */\n', '    function claimValidator() external isCandidateInitialized {\n', '        address msgSender = msg.sender;\n', '        ValidatorCandidate storage candidate = candidateProfiles[msgSender];\n', '        require(\n', '            candidate.status == DPoSCommon.CandidateStatus.Unbonded ||\n', '                candidate.status == DPoSCommon.CandidateStatus.Unbonding,\n', "            'Invalid candidate status'\n", '        );\n', "        require(block.number >= candidate.earliestBondTime, 'Not earliest bond time yet');\n", '        require(\n', '            candidate.stakingPool >= getUIntValue(uint256(ParamNames.MinStakeInPool)),\n', "            'Insufficient staking pool'\n", '        );\n', '        require(\n', '            candidate.delegatorProfiles[msgSender].delegatedStake >= candidate.minSelfStake,\n', "            'Not enough self stake'\n", '        );\n', '\n', '        uint256 minStakingPoolIndex;\n', '        uint256 minStakingPool = candidateProfiles[validatorSet[0]].stakingPool;\n', "        require(validatorSet[0] != msgSender, 'Already in validator set');\n", '        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\n', '        for (uint256 i = 1; i < maxValidatorNum; i++) {\n', "            require(validatorSet[i] != msgSender, 'Already in validator set');\n", '            if (candidateProfiles[validatorSet[i]].stakingPool < minStakingPool) {\n', '                minStakingPoolIndex = i;\n', '                minStakingPool = candidateProfiles[validatorSet[i]].stakingPool;\n', '            }\n', '        }\n', "        require(candidate.stakingPool > minStakingPool, 'Not larger than smallest pool');\n", '\n', '        address removedValidator = validatorSet[minStakingPoolIndex];\n', '        if (removedValidator != address(0)) {\n', '            _removeValidator(minStakingPoolIndex);\n', '        }\n', '        _addValidator(msgSender, minStakingPoolIndex);\n', '    }\n', '\n', '    /**\n', '     * @notice Confirm candidate status from Unbonding to Unbonded\n', '     * @param _candidateAddr the address of the candidate\n', '     */\n', '    function confirmUnbondedCandidate(address _candidateAddr) external {\n', '        ValidatorCandidate storage candidate = candidateProfiles[_candidateAddr];\n', '        require(\n', '            candidate.status == DPoSCommon.CandidateStatus.Unbonding,\n', "            'Candidate not unbonding'\n", '        );\n', "        require(block.number >= candidate.unbondTime, 'Unbonding time not reached');\n", '\n', '        candidate.status = DPoSCommon.CandidateStatus.Unbonded;\n', '        delete candidate.unbondTime;\n', '        emit CandidateUnbonded(_candidateAddr);\n', '    }\n', '\n', '    /**\n', '     * @notice Withdraw delegated stakes from an unbonded candidate\n', '     * @dev note that the stakes are delegated by the msgSender to the candidate\n', '     * @param _candidateAddr the address of the candidate\n', '     * @param _amount withdrawn amount\n', '     */\n', '    function withdrawFromUnbondedCandidate(address _candidateAddr, uint256 _amount)\n', '        external\n', '        onlyNonZeroAddr(_candidateAddr)\n', '        minAmount(_amount, 1 * DECIMALS_MULTIPLIER)\n', '    {\n', '        ValidatorCandidate storage candidate = candidateProfiles[_candidateAddr];\n', '        require(\n', '            candidate.status == DPoSCommon.CandidateStatus.Unbonded || isMigrating(),\n', "            'invalid status'\n", '        );\n', '\n', '        address msgSender = msg.sender;\n', '        _updateDelegatedStake(candidate, _candidateAddr, msgSender, _amount, MathOperation.Sub);\n', '        celerToken.safeTransfer(msgSender, _amount);\n', '\n', '        emit WithdrawFromUnbondedCandidate(msgSender, _candidateAddr, _amount);\n', '    }\n', '\n', '    /**\n', '     * @notice Intend to withdraw delegated stakes from a candidate\n', '     * @dev note that the stakes are delegated by the msgSender to the candidate\n', '     * @param _candidateAddr the address of the candidate\n', '     * @param _amount withdrawn amount\n', '     */\n', '    function intendWithdraw(address _candidateAddr, uint256 _amount)\n', '        external\n', '        onlyNonZeroAddr(_candidateAddr)\n', '        minAmount(_amount, 1 * DECIMALS_MULTIPLIER)\n', '    {\n', '        address msgSender = msg.sender;\n', '\n', '        ValidatorCandidate storage candidate = candidateProfiles[_candidateAddr];\n', '        Delegator storage delegator = candidate.delegatorProfiles[msgSender];\n', '\n', '        _updateDelegatedStake(candidate, _candidateAddr, msgSender, _amount, MathOperation.Sub);\n', '        delegator.undelegatingStake = delegator.undelegatingStake.add(_amount);\n', '        _validateValidator(_candidateAddr);\n', '\n', '        WithdrawIntent storage withdrawIntent = delegator.withdrawIntents[delegator.intentEndIndex];\n', '        withdrawIntent.amount = _amount;\n', '        withdrawIntent.proposedTime = block.number;\n', '        delegator.intentEndIndex++;\n', '\n', '        emit IntendWithdraw(msgSender, _candidateAddr, _amount, withdrawIntent.proposedTime);\n', '    }\n', '\n', '    /**\n', '     * @notice Confirm an intent of withdrawing delegated stakes from a candidate\n', '     * @dev note that the stakes are delegated by the msgSender to the candidate\n', '     * @param _candidateAddr the address of the candidate\n', '     */\n', '    function confirmWithdraw(address _candidateAddr) external onlyNonZeroAddr(_candidateAddr) {\n', '        address msgSender = msg.sender;\n', '        Delegator storage delegator = candidateProfiles[_candidateAddr]\n', '            .delegatorProfiles[msgSender];\n', '\n', '        uint256 slashTimeout = getUIntValue(uint256(ParamNames.SlashTimeout));\n', '        bool isUnbonded = candidateProfiles[_candidateAddr].status ==\n', '            DPoSCommon.CandidateStatus.Unbonded;\n', '        // for all undelegated withdraw intents\n', '        uint256 i;\n', '        for (i = delegator.intentStartIndex; i < delegator.intentEndIndex; i++) {\n', '            if (\n', '                isUnbonded ||\n', '                delegator.withdrawIntents[i].proposedTime.add(slashTimeout) <= block.number\n', '            ) {\n', '                // withdraw intent is undelegated when the validator becomes unbonded or\n', '                // the slashTimeout for the withdraw intent is up.\n', '                delete delegator.withdrawIntents[i];\n', '                continue;\n', '            }\n', '            break;\n', '        }\n', '        delegator.intentStartIndex = i;\n', '        // for all undelegating withdraw intents\n', '        uint256 undelegatingStakeWithoutSlash;\n', '        for (; i < delegator.intentEndIndex; i++) {\n', '            undelegatingStakeWithoutSlash = undelegatingStakeWithoutSlash.add(\n', '                delegator.withdrawIntents[i].amount\n', '            );\n', '        }\n', '\n', '        uint256 withdrawAmt;\n', '        if (delegator.undelegatingStake > undelegatingStakeWithoutSlash) {\n', '            withdrawAmt = delegator.undelegatingStake.sub(undelegatingStakeWithoutSlash);\n', '            delegator.undelegatingStake = undelegatingStakeWithoutSlash;\n', '\n', '            celerToken.safeTransfer(msgSender, withdrawAmt);\n', '        }\n', '\n', '        emit ConfirmWithdraw(msgSender, _candidateAddr, withdrawAmt);\n', '    }\n', '\n', '    /**\n', '     * @notice Slash a validator and its delegators\n', '     * @param _penaltyRequest penalty request bytes coded in protobuf\n', '     */\n', '    function slash(bytes calldata _penaltyRequest)\n', '        external\n', '        whenNotPaused\n', '        onlyValidDPoS\n', '        onlyNotMigrating\n', '    {\n', "        require(enableSlash, 'Slash is disabled');\n", '        PbSgn.PenaltyRequest memory penaltyRequest = PbSgn.decPenaltyRequest(_penaltyRequest);\n', '        PbSgn.Penalty memory penalty = PbSgn.decPenalty(penaltyRequest.penalty);\n', '\n', '        ValidatorCandidate storage validator = candidateProfiles[penalty.validatorAddress];\n', "        require(validator.status != DPoSCommon.CandidateStatus.Unbonded, 'Validator unbounded');\n", '\n', '        bytes32 h = keccak256(penaltyRequest.penalty);\n', "        require(_checkValidatorSigs(h, penaltyRequest.sigs), 'Validator sigs verification failed');\n", "        require(block.number < penalty.expireTime, 'Penalty expired');\n", "        require(!usedPenaltyNonce[penalty.nonce], 'Used penalty nonce');\n", '        usedPenaltyNonce[penalty.nonce] = true;\n', '\n', '        uint256 totalSubAmt;\n', '        for (uint256 i = 0; i < penalty.penalizedDelegators.length; i++) {\n', '            PbSgn.AccountAmtPair memory penalizedDelegator = penalty.penalizedDelegators[i];\n', '            totalSubAmt = totalSubAmt.add(penalizedDelegator.amt);\n', '            emit Slash(\n', '                penalty.validatorAddress,\n', '                penalizedDelegator.account,\n', '                penalizedDelegator.amt\n', '            );\n', '\n', '            Delegator storage delegator = validator.delegatorProfiles[penalizedDelegator.account];\n', '            uint256 _amt;\n', '            if (delegator.delegatedStake >= penalizedDelegator.amt) {\n', '                _amt = penalizedDelegator.amt;\n', '            } else {\n', '                uint256 remainingAmt = penalizedDelegator.amt.sub(delegator.delegatedStake);\n', '                delegator.undelegatingStake = delegator.undelegatingStake.sub(remainingAmt);\n', '                _amt = delegator.delegatedStake;\n', '            }\n', '            _updateDelegatedStake(\n', '                validator,\n', '                penalty.validatorAddress,\n', '                penalizedDelegator.account,\n', '                _amt,\n', '                MathOperation.Sub\n', '            );\n', '        }\n', '        _validateValidator(penalty.validatorAddress);\n', '\n', '        uint256 totalAddAmt;\n', '        for (uint256 i = 0; i < penalty.beneficiaries.length; i++) {\n', '            PbSgn.AccountAmtPair memory beneficiary = penalty.beneficiaries[i];\n', '            totalAddAmt = totalAddAmt.add(beneficiary.amt);\n', '\n', '            if (beneficiary.account == address(0)) {\n', '                // address(0) stands for miningPool\n', '                miningPool = miningPool.add(beneficiary.amt);\n', '            } else if (beneficiary.account == address(1)) {\n', '                // address(1) means beneficiary is msg sender\n', '                celerToken.safeTransfer(msg.sender, beneficiary.amt);\n', '                emit Compensate(msg.sender, beneficiary.amt);\n', '            } else {\n', '                celerToken.safeTransfer(beneficiary.account, beneficiary.amt);\n', '                emit Compensate(beneficiary.account, beneficiary.amt);\n', '            }\n', '        }\n', '\n', "        require(totalSubAmt == totalAddAmt, 'Amount not match');\n", '    }\n', '\n', '    /**\n', '     * @notice Validate multi-signed message\n', "     * @dev Can't use view here because _checkValidatorSigs is not a view function\n", '     * @param _request a multi-signed message bytes coded in protobuf\n', '     * @return passed the validation or not\n', '     */\n', '    function validateMultiSigMessage(bytes calldata _request)\n', '        external\n', '        onlyRegisteredSidechains\n', '        returns (bool)\n', '    {\n', '        PbSgn.MultiSigMessage memory request = PbSgn.decMultiSigMessage(_request);\n', '        bytes32 h = keccak256(request.msg);\n', '\n', '        return _checkValidatorSigs(h, request.sigs);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the minimum staking pool of all validators\n', '     * @return the minimum staking pool of all validators\n', '     */\n', '    function getMinStakingPool() external view returns (uint256) {\n', '        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\n', '\n', '        uint256 minStakingPool = candidateProfiles[validatorSet[0]].stakingPool;\n', '        for (uint256 i = 0; i < maxValidatorNum; i++) {\n', '            if (validatorSet[i] == address(0)) {\n', '                return 0;\n', '            }\n', '            if (candidateProfiles[validatorSet[i]].stakingPool < minStakingPool) {\n', '                minStakingPool = candidateProfiles[validatorSet[i]].stakingPool;\n', '            }\n', '        }\n', '\n', '        return minStakingPool;\n', '    }\n', '\n', '    /**\n', '     * @notice Get candidate info\n', '     * @param _candidateAddr the address of the candidate\n', '     * @return initialized whether initialized or not\n', '     * @return minSelfStake minimum self stakes\n', '     * @return stakingPool staking pool\n', '     * @return status candidate status\n', '     * @return unbondTime unbond time\n', '     * @return commissionRate commission rate\n', '     * @return rateLockEndTime commission rate lock end time\n', '     */\n', '    function getCandidateInfo(address _candidateAddr)\n', '        external\n', '        view\n', '        returns (\n', '            bool initialized,\n', '            uint256 minSelfStake,\n', '            uint256 stakingPool,\n', '            uint256 status,\n', '            uint256 unbondTime,\n', '            uint256 commissionRate,\n', '            uint256 rateLockEndTime\n', '        )\n', '    {\n', '        ValidatorCandidate memory c = candidateProfiles[_candidateAddr];\n', '\n', '        initialized = c.initialized;\n', '        minSelfStake = c.minSelfStake;\n', '        stakingPool = c.stakingPool;\n', '        status = uint256(c.status);\n', '        unbondTime = c.unbondTime;\n', '        commissionRate = c.commissionRate;\n', '        rateLockEndTime = c.rateLockEndTime;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the delegator info of a specific candidate\n', '     * @param _candidateAddr the address of the candidate\n', '     * @param _delegatorAddr the address of the delegator\n', '     * @return delegatedStake delegated stake to this candidate\n', '     * @return undelegatingStake undelegating stakes\n', '     * @return intentAmounts the amounts of withdraw intents\n', '     * @return intentProposedTimes the proposed times of withdraw intents\n', '     */\n', '    function getDelegatorInfo(address _candidateAddr, address _delegatorAddr)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 delegatedStake,\n', '            uint256 undelegatingStake,\n', '            uint256[] memory intentAmounts,\n', '            uint256[] memory intentProposedTimes\n', '        )\n', '    {\n', '        Delegator storage d = candidateProfiles[_candidateAddr].delegatorProfiles[_delegatorAddr];\n', '\n', '        uint256 len = d.intentEndIndex.sub(d.intentStartIndex);\n', '        intentAmounts = new uint256[](len);\n', '        intentProposedTimes = new uint256[](len);\n', '        for (uint256 i = 0; i < len; i++) {\n', '            intentAmounts[i] = d.withdrawIntents[i + d.intentStartIndex].amount;\n', '            intentProposedTimes[i] = d.withdrawIntents[i + d.intentStartIndex].proposedTime;\n', '        }\n', '\n', '        delegatedStake = d.delegatedStake;\n', '        undelegatingStake = d.undelegatingStake;\n', '    }\n', '\n', '    /**\n', '     * @notice Check this DPoS contract is valid or not now\n', '     * @return DPoS is valid or not\n', '     */\n', '    function isValidDPoS() public view returns (bool) {\n', '        return\n', '            block.number >= dposGoLiveTime &&\n', '            getValidatorNum() >= getUIntValue(uint256(ParamNames.MinValidatorNum));\n', '    }\n', '\n', '    /**\n', '     * @notice Check the given address is a validator or not\n', '     * @param _addr the address to check\n', '     * @return the given address is a validator or not\n', '     */\n', '    function isValidator(address _addr) public view returns (bool) {\n', '        return candidateProfiles[_addr].status == DPoSCommon.CandidateStatus.Bonded;\n', '    }\n', '\n', '    /**\n', '     * @notice Check if the contract is in migrating state\n', '     * @return contract in migrating state or not\n', '     */\n', '    function isMigrating() public view returns (bool) {\n', '        uint256 migrationTime = getUIntValue(uint256(ParamNames.MigrationTime));\n', '        return migrationTime != 0 && block.number >= migrationTime;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the number of validators\n', '     * @return the number of validators\n', '     */\n', '    function getValidatorNum() public view returns (uint256) {\n', '        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\n', '\n', '        uint256 num;\n', '        for (uint256 i = 0; i < maxValidatorNum; i++) {\n', '            if (validatorSet[i] != address(0)) {\n', '                num++;\n', '            }\n', '        }\n', '        return num;\n', '    }\n', '\n', '    /**\n', '     * @notice Get minimum amount of stakes for a quorum\n', '     * @return the minimum amount\n', '     */\n', '    function getMinQuorumStakingPool() public view returns (uint256) {\n', '        return getTotalValidatorStakingPool().mul(2).div(3).add(1);\n', '    }\n', '\n', '    /**\n', "     * @notice Get the total amount of stakes in validators' staking pools\n", '     * @return the total amount\n', '     */\n', '    function getTotalValidatorStakingPool() public view returns (uint256) {\n', '        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\n', '\n', '        uint256 totalValidatorStakingPool;\n', '        for (uint256 i = 0; i < maxValidatorNum; i++) {\n', '            totalValidatorStakingPool = totalValidatorStakingPool.add(\n', '                candidateProfiles[validatorSet[i]].stakingPool\n', '            );\n', '        }\n', '\n', '        return totalValidatorStakingPool;\n', '    }\n', '\n', '    /**\n', '     * @notice Update the commission rate of a candidate\n', '     * @param _candidate the candidate to update\n', '     * @param _newRate new commission rate\n', '     * @param _newLockEndTime new lock end time\n', '     */\n', '    function _updateCommissionRate(\n', '        ValidatorCandidate storage _candidate,\n', '        uint256 _newRate,\n', '        uint256 _newLockEndTime\n', '    ) private {\n', "        require(_newRate <= COMMISSION_RATE_BASE, 'Invalid new rate');\n", "        require(_newLockEndTime >= block.number, 'Outdated new lock end time');\n", '\n', '        if (_newRate <= _candidate.commissionRate) {\n', "            require(_newLockEndTime >= _candidate.rateLockEndTime, 'Invalid new lock end time');\n", '        } else {\n', "            require(block.number > _candidate.rateLockEndTime, 'Commission rate is locked');\n", '        }\n', '\n', '        _candidate.commissionRate = _newRate;\n', '        _candidate.rateLockEndTime = _newLockEndTime;\n', '\n', '        emit UpdateCommissionRate(msg.sender, _newRate, _newLockEndTime);\n', '    }\n', '\n', '    /**\n', '     * @notice Update the delegated stake of a delegator to an candidate\n', '     * @param _candidate the candidate\n', '     * @param _delegatorAddr the delegator address\n', '     * @param _amount update amount\n', '     * @param _op update operation\n', '     */\n', '    function _updateDelegatedStake(\n', '        ValidatorCandidate storage _candidate,\n', '        address _candidateAddr,\n', '        address _delegatorAddr,\n', '        uint256 _amount,\n', '        MathOperation _op\n', '    ) private {\n', '        Delegator storage delegator = _candidate.delegatorProfiles[_delegatorAddr];\n', '\n', '        if (_op == MathOperation.Add) {\n', '            _candidate.stakingPool = _candidate.stakingPool.add(_amount);\n', '            delegator.delegatedStake = delegator.delegatedStake.add(_amount);\n', '        } else if (_op == MathOperation.Sub) {\n', '            _candidate.stakingPool = _candidate.stakingPool.sub(_amount);\n', '            delegator.delegatedStake = delegator.delegatedStake.sub(_amount);\n', '        } else {\n', '            assert(false);\n', '        }\n', '        emit UpdateDelegatedStake(\n', '            _delegatorAddr,\n', '            _candidateAddr,\n', '            delegator.delegatedStake,\n', '            _candidate.stakingPool\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Add a validator\n', '     * @param _validatorAddr the address of the validator\n', '     * @param _setIndex the index to put the validator\n', '     */\n', '    function _addValidator(address _validatorAddr, uint256 _setIndex) private {\n', "        require(validatorSet[_setIndex] == address(0), 'Validator slot occupied');\n", '\n', '        validatorSet[_setIndex] = _validatorAddr;\n', '        candidateProfiles[_validatorAddr].status = DPoSCommon.CandidateStatus.Bonded;\n', '        delete candidateProfiles[_validatorAddr].unbondTime;\n', '        emit ValidatorChange(_validatorAddr, ValidatorChangeType.Add);\n', '    }\n', '\n', '    /**\n', '     * @notice Remove a validator\n', '     * @param _setIndex the index of the validator to be removed\n', '     */\n', '    function _removeValidator(uint256 _setIndex) private {\n', '        address removedValidator = validatorSet[_setIndex];\n', '        if (removedValidator == address(0)) {\n', '            return;\n', '        }\n', '\n', '        delete validatorSet[_setIndex];\n', '        candidateProfiles[removedValidator].status = DPoSCommon.CandidateStatus.Unbonding;\n', '        candidateProfiles[removedValidator].unbondTime = block.number.add(\n', '            getUIntValue(uint256(ParamNames.SlashTimeout))\n', '        );\n', '        emit ValidatorChange(removedValidator, ValidatorChangeType.Removal);\n', '    }\n', '\n', '    /**\n', '     * @notice Validate a validator status after stakes change\n', "     * @dev remove this validator if it doesn't meet the requirement of being a validator\n", '     * @param _validatorAddr the validator address\n', '     */\n', '    function _validateValidator(address _validatorAddr) private {\n', '        ValidatorCandidate storage v = candidateProfiles[_validatorAddr];\n', '        if (v.status != DPoSCommon.CandidateStatus.Bonded) {\n', '            // no need to validate the stake of a non-validator\n', '            return;\n', '        }\n', '\n', '        bool lowSelfStake = v.delegatorProfiles[_validatorAddr].delegatedStake < v.minSelfStake;\n', '        bool lowStakingPool = v.stakingPool < getUIntValue(uint256(ParamNames.MinStakeInPool));\n', '\n', '        if (lowSelfStake || lowStakingPool) {\n', '            _removeValidator(_getValidatorIdx(_validatorAddr));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Check whether validators with more than 2/3 total stakes have signed this hash\n', '     * @param _h signed hash\n', '     * @param _sigs signatures\n', '     * @return whether the signatures are valid or not\n', '     */\n', '    function _checkValidatorSigs(bytes32 _h, bytes[] memory _sigs) private returns (bool) {\n', '        uint256 minQuorumStakingPool = getMinQuorumStakingPool();\n', '\n', '        bytes32 hash = _h.toEthSignedMessageHash();\n', '        address[] memory addrs = new address[](_sigs.length);\n', '        uint256 quorumStakingPool;\n', '        bool hasDuplicatedSig;\n', '        for (uint256 i = 0; i < _sigs.length; i++) {\n', '            addrs[i] = hash.recover(_sigs[i]);\n', '            if (checkedValidators[addrs[i]]) {\n', '                hasDuplicatedSig = true;\n', '                break;\n', '            }\n', '            if (candidateProfiles[addrs[i]].status != DPoSCommon.CandidateStatus.Bonded) {\n', '                continue;\n', '            }\n', '\n', '            quorumStakingPool = quorumStakingPool.add(candidateProfiles[addrs[i]].stakingPool);\n', '            checkedValidators[addrs[i]] = true;\n', '        }\n', '\n', '        for (uint256 i = 0; i < _sigs.length; i++) {\n', '            checkedValidators[addrs[i]] = false;\n', '        }\n', '\n', '        return !hasDuplicatedSig && quorumStakingPool >= minQuorumStakingPool;\n', '    }\n', '\n', '    /**\n', '     * @notice Get validator index\n', '     * @param _addr the validator address\n', '     * @return the index of the validator\n', '     */\n', '    function _getValidatorIdx(address _addr) private view returns (uint256) {\n', '        uint256 maxValidatorNum = getUIntValue(uint256(ParamNames.MaxValidatorNum));\n', '\n', '        for (uint256 i = 0; i < maxValidatorNum; i++) {\n', '            if (validatorSet[i] == _addr) {\n', '                return i;\n', '            }\n', '        }\n', '\n', "        revert('No such a validator');\n", '    }\n', '}']