['// File: contracts/interfaces/IOneSwapRouter.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IOneSwapRouter {\n', '    event AddLiquidity(uint stockAmount, uint moneyAmount, uint liquidity);\n', '    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\n', '\n', '    function factory() external pure returns (address);\n', '\n', '    // liquidity\n', '    function addLiquidity(\n', '        address stock,\n', '        address money,\n', '        bool isOnlySwap,\n', '        uint amountStockDesired,\n', '        uint amountMoneyDesired,\n', '        uint amountStockMin,\n', '        uint amountMoneyMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountStock, uint amountMoney, uint liquidity);\n', '    function removeLiquidity(\n', '        address pair,\n', '        uint liquidity,\n', '        uint amountStockMin,\n', '        uint amountMoneyMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountStock, uint amountMoney);\n', '\n', '    // swap token\n', '    function swapToken(\n', '        address token,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint[] memory amounts);\n', '\n', '    // limit order\n', '    function limitOrder(\n', '        bool isBuy,\n', '        address pair,\n', '        uint prevKey,\n', '        uint price,\n', '        uint32 id,\n', '        uint stockAmount,\n', '        uint deadline\n', '    ) external payable;\n', '}\n', '\n', '// File: contracts/interfaces/IOneSwapFactory.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IOneSwapFactory {\n', '    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\n', '\n', '    function createPair(address stock, address money, bool isOnlySwap) external returns (address pair);\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '    function setFeeBPS(uint32 bps) external;\n', '    function setPairLogic(address implLogic) external;\n', '\n', '    function allPairsLength() external view returns (uint);\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '    function feeBPS() external view returns (uint32);\n', '    function pairLogic() external returns (address);\n', '    function getTokensFromPair(address pair) external view returns (address stock, address money);\n', '    function tokensToPair(address stock, address money, bool isOnlySwap) external view returns (address pair);\n', '}\n', '\n', '// File: contracts/interfaces/IOneSwapPair.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IOneSwapERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', 'interface IOneSwapPool {\n', '    // more liquidity was minted\n', '    event Mint(address indexed sender, uint stockAndMoneyAmount, address indexed to);\n', '    // liquidity was burned\n', '    event Burn(address indexed sender, uint stockAndMoneyAmount, address indexed to);\n', '    // amounts of reserved stock and money in this pair changed\n', '    event Sync(uint reserveStockAndMoney);\n', '\n', '    function internalStatus() external view returns(uint[3] memory res);\n', '    function getReserves() external view returns (uint112 reserveStock, uint112 reserveMoney, uint32 firstSellID);\n', '    function getBooked() external view returns (uint112 bookedStock, uint112 bookedMoney, uint32 firstBuyID);\n', '    function stock() external returns (address);\n', '    function money() external returns (address);\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint stockAmount, uint moneyAmount);\n', '    function skim(address to) external;\n', '    function sync() external;\n', '}\n', '\n', 'interface IOneSwapPair {\n', '    event NewLimitOrder(uint data); // new limit order was sent by an account\n', '    event NewMarketOrder(uint data); // new market order was sent by an account\n', '    event OrderChanged(uint data); // old orders in orderbook changed\n', '    event DealWithPool(uint data); // new order deal with the AMM pool\n', '    event RemoveOrder(uint data); // an order was removed from the orderbook\n', '    \n', '    // Return three prices in rational number form, i.e., numerator/denominator.\n', "    // They are: the first sell order's price; the first buy order's price; the current price of the AMM pool.\n", '    function getPrices() external returns (\n', '        uint firstSellPriceNumerator,\n', '        uint firstSellPriceDenominator,\n', '        uint firstBuyPriceNumerator,\n', '        uint firstBuyPriceDenominator,\n', '        uint poolPriceNumerator,\n', '        uint poolPriceDenominator);\n', '\n', "    // This function queries a list of orders in orderbook. It starts from 'id' and iterates the single-linked list, util it reaches the end, \n", "    // or until it has found 'maxCount' orders. If 'id' is 0, it starts from the beginning of the single-linked list.\n", "    // It may cost a lot of gas. So you'd not to call in on chain. It is mainly for off-chain query.\n", "    // The first uint256 returned by this function is special: the lowest 24 bits is the first order's id and the the higher bits is block height.\n", '    // THe other uint256s are all corresponding to an order record of the single-linked list.\n', '    function getOrderList(bool isBuy, uint32 id, uint32 maxCount) external view returns (uint[] memory);\n', '\n', '    // remove an order from orderbook and return its booked (i.e. frozen) money to maker\n', "    // 'id' points to the order to be removed\n", '    // prevKey points to 3 previous orders in the single-linked list\n', '    function removeOrder(bool isBuy, uint32 id, uint72 positionID) external;\n', '\n', '    function removeOrders(uint[] calldata rmList) external;\n', '\n', '    // Try to deal a new limit order or insert it into orderbook\n', "    // its suggested order id is 'id' and suggested positions are in 'prevKey'\n", '    // prevKey points to 3 existing orders in the single-linked list\n', "    // the order's sender is 'sender'. the order's amount is amount*stockUnit, which is the stock amount to be sold or bought.\n", "    // the order's price is 'price32', which is decimal floating point value.\n", '    function addLimitOrder(bool isBuy, address sender, uint64 amount, uint32 price32, uint32 id, uint72 prevKey) external payable;\n', '\n', "    // Try to deal a new market order. 'sender' pays 'inAmount' of 'inputToken', in exchange of the other token kept by this pair\n", '    function addMarketOrder(address inputToken, address sender, uint112 inAmount) external payable returns (uint);\n', '\n', "    // Given the 'amount' of stock and decimal floating point price 'price32', calculate the 'stockAmount' and 'moneyAmount' to be traded\n", '    function calcStockAndMoney(uint64 amount, uint32 price32) external pure returns (uint stockAmount, uint moneyAmount);\n', '}\n', '\n', '// File: contracts/interfaces/IERC20.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', '// File: contracts/libraries/SafeMath256.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeMath256 {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/DecFloat32.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', 'This library defines a decimal floating point number. It has 8 decimal significant digits. Its maximum value is 9.9999999e+15.\n', 'And its minimum value is 1.0e-16. The following golang code explains its detail implementation.\n', '\n', 'func buildPrice(significant int, exponent int) uint32 {\n', '\tif !(10000000 <= significant && significant <= 99999999) {\n', '\t\tpanic("Invalid significant")\n', '\t}\n', '\tif !(-16 <= exponent && exponent <= 15) {\n', '\t\tpanic("Invalid exponent")\n', '\t}\n', '\treturn uint32(((exponent+16)<<27)|significant);\n', '}\n', '\n', 'func priceToFloat(price uint32) float64 {\n', '\texponent := int(price>>27)\n', '\tsignificant := float64(price&((1<<27)-1))\n', '\treturn significant * math.Pow10(exponent-23)\n', '}\n', '\n', '*/\n', '\n', '// A price presented as a rational number\n', 'struct RatPrice {\n', '    uint numerator;   // at most 54bits\n', '    uint denominator; // at most 76bits\n', '}\n', '\n', 'library DecFloat32 {\n', '    uint32 public constant MANTISSA_MASK = (1<<27) - 1;\n', '    uint32 public constant MAX_MANTISSA = 9999_9999;\n', '    uint32 public constant MIN_MANTISSA = 1000_0000;\n', '    uint32 public constant MIN_PRICE = MIN_MANTISSA;\n', '    uint32 public constant MAX_PRICE = (31<<27)|MAX_MANTISSA;\n', '\n', '    // 10 ** (i + 1)\n', '    function powSmall(uint32 i) internal pure returns (uint) {\n', '        uint x = 2695994666777834996822029817977685892750687677375768584125520488993233305610;\n', '        return (x >> (32*i)) & ((1<<32)-1);\n', '    }\n', '\n', '    // 10 ** (i * 8)\n', '    function powBig(uint32 i) internal pure returns (uint) {\n', '        uint y = 3402823669209384634633746076162356521930955161600000001;\n', '        return (y >> (64*i)) & ((1<<64)-1);\n', '    }\n', '\n', '    // if price32=( 0<<27)|12345678 then numerator=12345678 denominator=100000000000000000000000\n', '    // if price32=( 1<<27)|12345678 then numerator=12345678 denominator=10000000000000000000000\n', '    // if price32=( 2<<27)|12345678 then numerator=12345678 denominator=1000000000000000000000\n', '    // if price32=( 3<<27)|12345678 then numerator=12345678 denominator=100000000000000000000\n', '    // if price32=( 4<<27)|12345678 then numerator=12345678 denominator=10000000000000000000\n', '    // if price32=( 5<<27)|12345678 then numerator=12345678 denominator=1000000000000000000\n', '    // if price32=( 6<<27)|12345678 then numerator=12345678 denominator=100000000000000000\n', '    // if price32=( 7<<27)|12345678 then numerator=12345678 denominator=10000000000000000\n', '    // if price32=( 8<<27)|12345678 then numerator=12345678 denominator=1000000000000000\n', '    // if price32=( 9<<27)|12345678 then numerator=12345678 denominator=100000000000000\n', '    // if price32=(10<<27)|12345678 then numerator=12345678 denominator=10000000000000\n', '    // if price32=(11<<27)|12345678 then numerator=12345678 denominator=1000000000000\n', '    // if price32=(12<<27)|12345678 then numerator=12345678 denominator=100000000000\n', '    // if price32=(13<<27)|12345678 then numerator=12345678 denominator=10000000000\n', '    // if price32=(14<<27)|12345678 then numerator=12345678 denominator=1000000000\n', '    // if price32=(15<<27)|12345678 then numerator=12345678 denominator=100000000\n', '    // if price32=(16<<27)|12345678 then numerator=12345678 denominator=10000000\n', '    // if price32=(17<<27)|12345678 then numerator=12345678 denominator=1000000\n', '    // if price32=(18<<27)|12345678 then numerator=12345678 denominator=100000\n', '    // if price32=(19<<27)|12345678 then numerator=12345678 denominator=10000\n', '    // if price32=(20<<27)|12345678 then numerator=12345678 denominator=1000\n', '    // if price32=(21<<27)|12345678 then numerator=12345678 denominator=100\n', '    // if price32=(22<<27)|12345678 then numerator=12345678 denominator=10\n', '    // if price32=(23<<27)|12345678 then numerator=12345678 denominator=1\n', '    // if price32=(24<<27)|12345678 then numerator=123456780 denominator=1\n', '    // if price32=(25<<27)|12345678 then numerator=1234567800 denominator=1\n', '    // if price32=(26<<27)|12345678 then numerator=12345678000 denominator=1\n', '    // if price32=(27<<27)|12345678 then numerator=123456780000 denominator=1\n', '    // if price32=(28<<27)|12345678 then numerator=1234567800000 denominator=1\n', '    // if price32=(29<<27)|12345678 then numerator=12345678000000 denominator=1\n', '    // if price32=(30<<27)|12345678 then numerator=123456780000000 denominator=1\n', '    // if price32=(31<<27)|12345678 then numerator=1234567800000000 denominator=1\n', '    function expandPrice(uint32 price32) internal pure returns (RatPrice memory) {\n', '        uint s = price32&((1<<27)-1);\n', '        uint32 a = price32 >> 27;\n', '        RatPrice memory price;\n', '        if(a >= 24) {\n', '            uint32 b = a - 24;\n', '            price.numerator = s * powSmall(b);\n', '            price.denominator = 1;\n', '        } else if(a == 23) {\n', '            price.numerator = s;\n', '            price.denominator = 1;\n', '        } else {\n', '            uint32 b = 22 - a;\n', '            price.numerator = s;\n', '            price.denominator = powSmall(b&0x7) * powBig(b>>3);\n', '        }\n', '        return price;\n', '    }\n', '\n', '    function getExpandPrice(uint price) internal pure returns(uint numerator, uint denominator) {\n', '        uint32 m = uint32(price) & MANTISSA_MASK;\n', '        require(MIN_MANTISSA <= m && m <= MAX_MANTISSA, "Invalid Price");\n', '        RatPrice memory actualPrice = expandPrice(uint32(price));\n', '        return (actualPrice.numerator, actualPrice.denominator);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/OneSwapRouter.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract OneSwapRouter is IOneSwapRouter {\n', '    using SafeMath256 for uint;\n', '    address public immutable override factory;\n', '\n', '    modifier ensure(uint deadline) {\n', '        // solhint-disable-next-line not-rely-on-time,\n', '        require(deadline >= block.timestamp, "OneSwapRouter: EXPIRED");\n', '        _;\n', '    }\n', '\n', '    constructor(address _factory) public {\n', '        factory = _factory;\n', '    }\n', '\n', '    function _addLiquidity(address pair, uint amountStockDesired, uint amountMoneyDesired,\n', '        uint amountStockMin, uint amountMoneyMin) private view returns (uint amountStock, uint amountMoney) {\n', '\n', '        (uint reserveStock, uint reserveMoney, ) = IOneSwapPool(pair).getReserves();\n', '        if (reserveStock == 0 && reserveMoney == 0) {\n', '            (amountStock, amountMoney) = (amountStockDesired, amountMoneyDesired);\n', '        } else {\n', '            uint amountMoneyOptimal = _quote(amountStockDesired, reserveStock, reserveMoney);\n', '            if (amountMoneyOptimal <= amountMoneyDesired) {\n', '                require(amountMoneyOptimal >= amountMoneyMin, "OneSwapRouter: INSUFFICIENT_MONEY_AMOUNT");\n', '                (amountStock, amountMoney) = (amountStockDesired, amountMoneyOptimal);\n', '            } else {\n', '                uint amountStockOptimal = _quote(amountMoneyDesired, reserveMoney, reserveStock);\n', '                assert(amountStockOptimal <= amountStockDesired);\n', '                require(amountStockOptimal >= amountStockMin, "OneSwapRouter: INSUFFICIENT_STOCK_AMOUNT");\n', '                (amountStock, amountMoney) = (amountStockOptimal, amountMoneyDesired);\n', '            }\n', '        }\n', '    }\n', '\n', '    function addLiquidity(address stock, address money, bool isOnlySwap, uint amountStockDesired,\n', '        uint amountMoneyDesired, uint amountStockMin, uint amountMoneyMin, address to, uint deadline) external\n', '        payable override ensure(deadline) returns (uint amountStock, uint amountMoney, uint liquidity) {\n', '\n', '        if (stock != address(0) && money != address(0)) {\n', "            require(msg.value == 0, 'OneSwapRouter: NOT_ENTER_ETH_VALUE');\n", '        }\n', '        address pair = IOneSwapFactory(factory).tokensToPair(stock, money, isOnlySwap);\n', '        if (pair == address(0)) {\n', '            pair = IOneSwapFactory(factory).createPair(stock, money, isOnlySwap);\n', '        }\n', '        (amountStock, amountMoney) = _addLiquidity(pair, amountStockDesired,\n', '            amountMoneyDesired, amountStockMin, amountMoneyMin);\n', '        _safeTransferFrom(stock, msg.sender, pair, amountStock);\n', '        _safeTransferFrom(money, msg.sender, pair, amountMoney);\n', '        liquidity = IOneSwapPool(pair).mint(to);\n', '        emit AddLiquidity(amountStock, amountMoney, liquidity);\n', '    }\n', '\n', '    function _removeLiquidity(address pair, uint liquidity, uint amountStockMin,\n', '        uint amountMoneyMin, address to) private returns (uint amountStock, uint amountMoney) {\n', '        IERC20(pair).transferFrom(msg.sender, pair, liquidity);\n', '        (amountStock, amountMoney) = IOneSwapPool(pair).burn(to);\n', '        require(amountStock >= amountStockMin, "OneSwapRouter: INSUFFICIENT_STOCK_AMOUNT");\n', '        require(amountMoney >= amountMoneyMin, "OneSwapRouter: INSUFFICIENT_MONEY_AMOUNT");\n', '    }\n', '\n', '    function removeLiquidity(address pair, uint liquidity, uint amountStockMin, uint amountMoneyMin,\n', '        address to, uint deadline) external override ensure(deadline) returns (uint amountStock, uint amountMoney) {\n', '        // ensure pair exist\n', '        _getTokensFromPair(pair);\n', '        (amountStock, amountMoney) = _removeLiquidity(pair, liquidity, amountStockMin, amountMoneyMin, to);\n', '    }\n', '\n', '    function _swap(address input, uint amountIn, address[] memory path, address _to) internal virtual returns (uint[] memory amounts) {\n', '        amounts = new uint[](path.length + 1);\n', '        amounts[0] = amountIn;\n', '\n', '        for (uint i = 0; i < path.length; i++) {\n', '            (address to, bool isLastSwap) = i < path.length - 1 ? (path[i+1], false) : (_to, true);\n', '            amounts[i + 1] = IOneSwapPair(path[i]).addMarketOrder(input, to, uint112(amounts[i]));\n', '            if (!isLastSwap) {\n', '                (address stock, address money) = _getTokensFromPair(path[i]);\n', '                input = (stock != input) ? stock : money;\n', '            }\n', '        }\n', '    }\n', '\n', '    function swapToken(address token, uint amountIn, uint amountOutMin, address[] calldata path,\n', '        address to, uint deadline) external payable override ensure(deadline) returns (uint[] memory amounts) {\n', '\n', "        if (token != address(0)) { require(msg.value == 0, 'OneSwapRouter: NOT_ENTER_ETH_VALUE'); }\n", '        require(path.length >= 1, "OneSwapRouter: INVALID_PATH");\n', '        // ensure pair exist\n', '        _getTokensFromPair(path[0]);\n', '        _safeTransferFrom(token, msg.sender, path[0], amountIn);\n', '        amounts = _swap(token, amountIn, path, to);\n', '        require(amounts[path.length] >= amountOutMin, "OneSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT");\n', '    }\n', '\n', '    function limitOrder(bool isBuy, address pair, uint prevKey, uint price, uint32 id,\n', '        uint stockAmount, uint deadline) external payable override ensure(deadline) {\n', '\n', '        (address stock, address money) = _getTokensFromPair(pair);\n', '        {\n', '            (uint _stockAmount, uint _moneyAmount) = IOneSwapPair(pair).calcStockAndMoney(uint64(stockAmount), uint32(price));\n', '            if (isBuy) {\n', "                if (money != address(0)) { require(msg.value == 0, 'OneSwapRouter: NOT_ENTER_ETH_VALUE'); }\n", '                _safeTransferFrom(money, msg.sender, pair, _moneyAmount);\n', '            } else {\n', "                if (stock != address(0)) { require(msg.value == 0, 'OneSwapRouter: NOT_ENTER_ETH_VALUE'); }\n", '                _safeTransferFrom(stock, msg.sender, pair, _stockAmount);\n', '            }\n', '        }\n', '        IOneSwapPair(pair).addLimitOrder(isBuy, msg.sender, uint64(stockAmount), uint32(price), id, uint72(prevKey));\n', '    }\n', '\n', '    // todo. add encoded bytes interface for limitOrder.\n', '\n', '    function _safeTransferFrom(address token, address from, address to, uint value) internal {\n', '        if (token == address(0)) {\n', '            _safeTransferETH(to, value);\n', '            uint inputValue = msg.value;\n', '            if (inputValue > value) { _safeTransferETH(msg.sender, inputValue - value); }\n', '            return;\n', '        }\n', '\n', '        uint beforeAmount = IERC20(token).balanceOf(to);\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "OneSwapRouter: TRANSFER_FROM_FAILED");\n', '        uint afterAmount = IERC20(token).balanceOf(to);\n', '        require(afterAmount == beforeAmount + value, "OneSwapRouter: TRANSFER_FAILED");\n', '    }\n', '\n', '    function _safeTransferETH(address to, uint value) internal {\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', '        require(success, "TransferHelper: ETH_TRANSFER_FAILED");\n', '    }\n', '\n', '    function _quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n', '        require(amountA > 0, "OneSwapRouter: INSUFFICIENT_AMOUNT");\n', '        require(reserveA > 0 && reserveB > 0, "OneSwapRouter: INSUFFICIENT_LIQUIDITY");\n', '        amountB = amountA.mul(reserveB) / reserveA;\n', '    }\n', '\n', '    function _getTokensFromPair(address pair) internal view returns(address stock, address money) {\n', '        (stock, money) = IOneSwapFactory(factory).getTokensFromPair(pair);\n', '        require(stock != address(0) || money != address(0), "OneSwapRouter: PAIR_NOT_EXIST");\n', '    }\n', '}']