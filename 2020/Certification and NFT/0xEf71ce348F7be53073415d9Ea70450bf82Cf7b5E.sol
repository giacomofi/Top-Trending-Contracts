['pragma solidity ^0.4.24;\n', '\n', '// submited by @dev-xu\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '// @title SafeMath: overflow/underflow checks\n', '// @notice Math operations with safety checks that throw on error\n', 'library SafeMath {\n', '\n', '  // @notice Multiplies two numbers, throws on overflow.\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  // @notice Integer division of two numbers, truncating the quotient.\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  // @notice Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  // @notice Adds two numbers, throws on overflow.\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  // @notice Returns fractional amount\n', '  function getFractionalAmount(uint256 _amount, uint256 _percentage)\n', '  internal\n', '  pure\n', '  returns (uint256) {\n', '    return div(mul(_amount, _percentage), 100);\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface ERC20 {\n', '  function decimals() external view returns (uint8);\n', '\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  function balanceOf(address _who) external view returns (uint256);\n', '\n', '  function allowance(address _owner, address _spender) external view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) external returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface MinterInterface {\n', '  function cloneToken(string _uri, address _erc20Address) external returns (address asset);\n', '\n', '  function mintAssetTokens(address _assetAddress, address _receiver, uint256 _amount) external returns (bool);\n', '\n', '  function changeTokenController(address _assetAddress, address _newController) external returns (bool);\n', '}\n', '\n', 'interface CrowdsaleReserveInterface {\n', '  function issueETH(address _receiver, uint256 _amount) external returns (bool);\n', '  function receiveETH(address _payer) external payable returns (bool);\n', '  function refundETHAsset(address _asset, uint256 _amount) external returns (bool);\n', '  function issueERC20(address _receiver, uint256 _amount, address _tokenAddress) external returns (bool);\n', '  function requestERC20(address _payer, uint256 _amount, address _tokenAddress) external returns (bool);\n', '  function approveERC20(address _receiver, uint256 _amount, address _tokenAddress) external returns (bool);\n', '  function refundERC20Asset(address _asset, uint256 _amount, address _tokenAddress) external returns (bool);\n', '}\n', '\n', 'interface Events {  function transaction(string _message, address _from, address _to, uint _amount, address _token)  external; }\n', '\n', 'interface DB {\n', '  function addressStorage(bytes32 _key) external view returns (address);\n', '  function uintStorage(bytes32 _key) external view returns (uint);\n', '  function setUint(bytes32 _key, uint _value) external;\n', '  function deleteUint(bytes32 _key) external;\n', '  function setBool(bytes32 _key, bool _value) external;\n', '  function boolStorage(bytes32 _key) external view returns (bool);\n', '}\n', '\n', '// @title An asset crowdsale contract, which accepts Ether for funding.\n', '// @author Kyle Dewhurst & Peter Phillips, MyBit Foundation\n', '// @notice Starts a new crowdsale and returns asset dividend tokens for Wei received.\n', '// @dev The AssetManager\n', 'contract CrowdsaleETH {\n', '    using SafeMath for uint256;\n', '\n', '    DB private database;\n', '    Events private events;\n', '    MinterInterface private minter;\n', '    CrowdsaleReserveInterface private reserve;\n', '\n', '    // @notice Constructor: Initiates the database\n', '    // @param: The address for the database contract\n', '    constructor(address _database, address _events)\n', '    public {\n', '      database = DB(_database);\n', '      events = Events(_events);\n', '      minter = MinterInterface(database.addressStorage(keccak256(abi.encodePacked("contract", "Minter"))));\n', '      reserve = CrowdsaleReserveInterface(database.addressStorage(keccak256(abi.encodePacked("contract", "CrowdsaleReserve"))));\n', '    }\n', '\n', '\n', '    // @notice Investors can send Ether here to fund asset, receiving an equivalent number of asset-tokens.\n', '    // @param (bytes32) _assetAddress = The address of the asset which completed the crowdsale\n', '    function buyAssetOrderETH(address _assetAddress)\n', '    external\n', '    payable\n', '    requiresEther\n', '    validAsset(_assetAddress)\n', '    beforeDeadline(_assetAddress)\n', '    notFinalized(_assetAddress)\n', '    returns (bool) {\n', '      uint fundingRemaining = database.uintStorage(keccak256(abi.encodePacked("crowdsale.remaining", _assetAddress)));\n', '      uint amount; //The number of tokens that will be minted\n', '      if (msg.value < fundingRemaining) {\n', '        amount = msg.value.mul(100).div(uint(100).add(database.uintStorage(keccak256(abi.encodePacked("platform.fee")))));\n', '        database.setUint(keccak256(abi.encodePacked("crowdsale.remaining", _assetAddress)), fundingRemaining.sub(msg.value));\n', '        //Mint tokens equal to the msg.value\n', '        require(minter.mintAssetTokens(_assetAddress, msg.sender, amount), "Investor minting failed");\n', '        reserve.receiveETH.value(msg.value)(msg.sender);\n', '      } else {\n', '        amount = fundingRemaining.mul(100).div(uint(100).add(database.uintStorage(keccak256(abi.encodePacked("platform.fee")))));\n', '        //Funding complete, finalize crowdsale\n', '        database.setBool(keccak256(abi.encodePacked("crowdsale.finalized", _assetAddress)), true);\n', '        database.deleteUint(keccak256(abi.encodePacked("crowdsale.remaining", _assetAddress)));\n', '        //Since investor paid equal to or over the funding remaining, just mint for tokensRemaining\n', '        require(minter.mintAssetTokens(_assetAddress, msg.sender, amount), "Investor minting failed");\n', '        reserve.receiveETH.value(fundingRemaining)(msg.sender);\n', '        //Return leftover WEI after cost of tokens calculated and subtracted from msg.value to msg.sender\n', '        msg.sender.transfer(msg.value.sub(fundingRemaining));\n', '      }\n', "      events.transaction('Asset purchased', address(this), msg.sender, amount, _assetAddress);\n", '\n', '      return true;\n', '    }\n', '\n', '    // @notice This is called once funding has succeeded. Sends Ether to a distribution contract where receiver & assetManager can withdraw\n', '    // @dev The contract manager needs to know  the address PlatformDistribution contract\n', '    // @param (bytes32) _assetAddress = The address of the asset which completed the crowdsale\n', '    function payoutETH(address _assetAddress)\n', '    external\n', '    whenNotPaused\n', '    finalized(_assetAddress)\n', '    notPaid(_assetAddress)\n', '    returns (bool) {\n', '      //Set paid to true\n', '      database.setBool(keccak256(abi.encodePacked("crowdsale.paid", _assetAddress)), true);\n', '      //Setup token\n', '      //Mint tokens for the asset manager and platform + finish minting\n', '      address platformAssetsWallet = database.addressStorage(keccak256(abi.encodePacked("platform.wallet.assets")));\n', '      require(platformAssetsWallet != address(0), "Platform assets wallet not set");\n', '      require(minter.mintAssetTokens(_assetAddress, database.addressStorage(keccak256(abi.encodePacked("contract", "AssetManagerFunds"))), database.uintStorage(keccak256(abi.encodePacked("asset.managerTokens", _assetAddress)))), "Manager minting failed");\n', '      require(minter.mintAssetTokens(_assetAddress, platformAssetsWallet, database.uintStorage(keccak256(abi.encodePacked("asset.platformTokens", _assetAddress)))), "Platform minting failed");\n', '      //Get the addresses for the receiver and platform\n', '      address receiver = database.addressStorage(keccak256(abi.encodePacked("asset.manager", _assetAddress)));\n', '      address platformFundsWallet = database.addressStorage(keccak256(abi.encodePacked("platform.wallet.funds")));\n', '      require(receiver != address(0) && platformFundsWallet != address(0), "Receiver or platform wallet not set");\n', '      //Calculate amounts for platform and receiver\n', '      uint amount = database.uintStorage(keccak256(abi.encodePacked("crowdsale.goal", _assetAddress)));\n', '      uint platformFee = amount.getFractionalAmount(database.uintStorage(keccak256(abi.encodePacked("platform.fee"))));\n', '      //Transfer funds to receiver and platform\n', "      require(reserve.issueETH(platformFundsWallet, platformFee), 'Platform funds not paid');\n", "      require(reserve.issueETH(receiver, amount), 'Asset manager funds not paid');\n", '      //Delete crowdsale start time\n', '      database.deleteUint(keccak256(abi.encodePacked("crowdsale.start", _assetAddress)));\n', '      //Increase asset count for manager\n', '      address manager = database.addressStorage(keccak256(abi.encodePacked("asset.manager", _assetAddress)));\n', '      database.setUint(keccak256(abi.encodePacked("manager.assets", manager)), database.uintStorage(keccak256(abi.encodePacked("manager.assets", manager))).add(1));\n', '      //Emit event\n', "      events.transaction('Asset payout', _assetAddress, receiver, amount, address(0));\n", '      return true;\n', '    }\n', '\n', '    function cancel(address _assetAddress)\n', '    external\n', '    whenNotPaused\n', '    validAsset(_assetAddress)\n', '    beforeDeadline(_assetAddress)\n', '    notFinalized(_assetAddress)\n', '    returns (bool){\n', '      require(msg.sender == database.addressStorage(keccak256(abi.encodePacked("asset.manager", _assetAddress))));\n', '      database.setUint(keccak256(abi.encodePacked("crowdsale.deadline", _assetAddress)), 1);\n', '      refund(_assetAddress);\n', '    }\n', '\n', '    // @notice Contributors can retrieve their funds here if crowdsale has paased deadline and not reached its goal\n', '    // @param (bytes32) _assetAddress = The address of the asset which completed the crowdsale\n', '    function refund(address _assetAddress)\n', '    public\n', '    whenNotPaused\n', '    validAsset(_assetAddress)\n', '    afterDeadline(_assetAddress)\n', '    notFinalized(_assetAddress)\n', '    returns (bool) {\n', '      require(database.uintStorage(keccak256(abi.encodePacked("crowdsale.deadline", _assetAddress))) != 0);\n', '      database.deleteUint(keccak256(abi.encodePacked("crowdsale.deadline", _assetAddress)));\n', '      ERC20 assetToken = ERC20(_assetAddress);\n', '      uint refundValue = assetToken.totalSupply().mul(uint(100).add(database.uintStorage(keccak256(abi.encodePacked("platform.fee"))))).div(100); //total supply plus platform fees\n', '      reserve.refundETHAsset(_assetAddress, refundValue);\n', '      return true;\n', '    }\n', '\n', '    // @notice platform owners can recover tokens here\n', '    function recoverTokens(address _erc20Token)\n', '    onlyOwner\n', '    external {\n', '      ERC20 thisToken = ERC20(_erc20Token);\n', '      uint contractBalance = thisToken.balanceOf(address(this));\n', '      thisToken.transfer(msg.sender, contractBalance);\n', '    }\n', '\n', '    // @notice platform owners can destroy contract here\n', '    function destroy()\n', '    onlyOwner\n', '    external {\n', "      events.transaction('CrowdsaleETH destroyed', address(this), msg.sender, address(this).balance, address(0));\n", '      selfdestruct(msg.sender);\n', '    }\n', '\n', '    //------------------------------------------------------------------------------------------------------------------\n', '    //                                            Modifiers\n', '    //------------------------------------------------------------------------------------------------------------------\n', '\n', '\n', '    // @notice Requires that Ether is sent with the transaction\n', '    modifier requiresEther() {\n', '      require(msg.value > 0);\n', '      _;\n', '    }\n', '\n', '    // @notice Sender must be a registered owner\n', '    modifier onlyOwner {\n', '      require(database.boolStorage(keccak256(abi.encodePacked("owner", msg.sender))), "Not owner");\n', '      _;\n', '    }\n', '\n', "    // @notice function won't run if owners have paused this contract\n", '    modifier whenNotPaused {\n', '      require(!database.boolStorage(keccak256(abi.encodePacked("paused", address(this)))), "Contract paused");\n', '      _;\n', '    }\n', '\n', '    // @notice reverts if the asset does not have a token address set in the database\n', '    modifier validAsset(address _assetAddress) {\n', '      require(database.addressStorage(keccak256(abi.encodePacked("asset.manager", _assetAddress))) != address(0), "Invalid asset");\n', '      _;\n', '    }\n', '\n', '    // @notice reverts if the funding deadline has not passed\n', '    modifier beforeDeadline(address _assetAddress) {\n', '      require(now < database.uintStorage(keccak256(abi.encodePacked("crowdsale.deadline", _assetAddress))), "Before deadline");\n', '      _;\n', '    }\n', '\n', '    // @notice reverts if the funding deadline has already past or crowsale has not started\n', '    modifier betweenDeadlines(address _assetAddress) {\n', '      require(now <= database.uintStorage(keccak256(abi.encodePacked("crowdsale.deadline", _assetAddress))), "Past deadline");\n', '      require(now >= database.uintStorage(keccak256(abi.encodePacked("crowdsale.start", _assetAddress))), "Before start time");\n', '      _;\n', '    }\n', '\n', '    // @notice reverts if the funding deadline has already past\n', '    modifier afterDeadline(address _assetAddress) {\n', '      require(now > database.uintStorage(keccak256(abi.encodePacked("crowdsale.deadline", _assetAddress))), "Before deadline");\n', '      _;\n', '    }\n', '\n', '    // @notice returns true if crowdsale is finshed\n', '    modifier finalized(address _assetAddress) {\n', '      require( database.boolStorage(keccak256(abi.encodePacked("crowdsale.finalized", _assetAddress))), "Crowdsale not finalized");\n', '      _;\n', '    }\n', '\n', '    // @notice returns true if crowdsale is not finshed\n', '    modifier notFinalized(address _assetAddress) {\n', '      require( !database.boolStorage(keccak256(abi.encodePacked("crowdsale.finalized", _assetAddress))), "Crowdsale finalized");\n', '      _;\n', '    }\n', '\n', '    // @notice returns true if crowdsale has not paid out\n', '    modifier notPaid(address _assetAddress) {\n', '      require( !database.boolStorage(keccak256(abi.encodePacked("crowdsale.paid", _assetAddress))), "Crowdsale had paid out");\n', '      _;\n', '    }\n', '\n', '  }']