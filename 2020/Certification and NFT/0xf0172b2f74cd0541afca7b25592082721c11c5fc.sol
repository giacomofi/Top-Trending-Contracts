['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-14\n', '*/\n', '\n', 'pragma solidity ^0.6.10;\n', '\n', '//Contract deployed on ropsten: 0xb4b333123caf6b29da37e7973aceed4e82d8206b\n', '//Test Cash contract: 0x0f54093364b396461AAdf85C015Db597AAb56203\n', '\n', '//Mainnet: 0x73aa31Cd548AC14713F778f454348d90564e2dE1\n', '//Devcash: 0x0fca8Fdb0FB115A33BAadEc6e7A141FFC1bC7d5a\n', '\n', '\n', 'abstract contract ERC20{\n', '    function balanceOf(address who) public virtual view returns (uint256);\n', '    function transfer(address to, uint256 value) public virtual returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\n', '}\n', '\n', 'abstract contract ERC20Approve {\n', ' function approve(address spender, uint256 value) public virtual returns (bool);\n', '}\n', '\n', 'contract bountyChest{\n', '    address payable creator;\n', '    constructor () public {\n', '        ERC20Approve(0x0fca8Fdb0FB115A33BAadEc6e7A141FFC1bC7d5a).approve(msg.sender,2**256-1);\n', '        creator = msg.sender;\n', '    }\n', '    receive() external payable{\n', '\n', '    }\n', '    function transfer(address payable to, uint amount) public payable{\n', '        require(msg.sender==creator);\n', '        to.transfer(amount);\n', '    }\n', '}\n', '\n', 'contract ubountyCreator{\n', '\n', '    string public version = "ubounties-v0.8b";\n', '\n', '    event created(uint uBountyIndex,uint bountiesAvailable, uint tokenAmount, uint weiAmount);        //add a\n', '\n', '    event submitted(uint uBountyIndex, uint submissionIndex);\n', '    event revised(uint uBountyIndex,uint submissionIndex, uint revisionIndex);\n', '\n', '    event approved(uint uBountyIndex, uint submissionIndex, string feedback);\n', '    event rejected(uint uBountyIndex, uint submissionIndex, string feedback);\n', '    event revisionRequested(uint uBountyIndex, uint submissionIndex, string feedback);\n', '\n', '    event rewarded(uint uBountyIndex, uint submissionIndex, address Hunter, uint tokenAmount,uint weiAmount);\n', '\n', '    event reclaimed(uint uBountyIndex, uint tokenAmount, uint weiAmount);\n', '\n', '    event completed(uint uBountyIndex);\n', '\n', '    event feeChange(uint oldFee, uint newFee);\n', '    event waiverChange(uint oldWaiver, uint newWaiver);\n', '\n', '    address public devcash = 0x0fca8Fdb0FB115A33BAadEc6e7A141FFC1bC7d5a;\n', '    address public admin;\n', '    address payable public collector = 0xB1F445F64CDDe81d58c26ab1C340FE2a82F55A4C;\n', '\n', '    uint public fee;\n', '    uint public waiver;\n', '\n', '    struct submission{\n', '        uint32 submitterIndex;\n', '        string submissionString;\n', '        bool approved;\n', '        mapping(uint=>string) revisions;\n', '        uint8 numRevisions;\n', '    }\n', '\n', '    struct ubounty{\n', '        uint8 available;          //rename to avaiable\n', '        uint8 numSubmissions;\n', '        uint32 hunterIndex;\n', '        uint32 creatorIndex;\n', '        uint32 bountyChestIndex;\n', '        uint48 deadline;\n', '        string name;\n', '        string description;\n', '        mapping(uint => submission) submissions;\n', '    }\n', '\n', '    mapping(uint => ubounty) public ubounties;\n', '    uint public numUbounties;\n', '\n', '    function getSubmission(uint ubountyIndex, uint submissionIndex) public view returns(string memory,address, bool,uint) {\n', '        return (\n', '            ubounties[ubountyIndex].submissions[submissionIndex].submissionString,\n', '            userList[ubounties[ubountyIndex].submissions[submissionIndex].submitterIndex],\n', '            ubounties[ubountyIndex].submissions[submissionIndex].approved,\n', '            ubounties[ubountyIndex].submissions[submissionIndex].numRevisions);\n', '    }\n', '\n', '    function getRevision(uint ubountyIndex,uint submissionIndex, uint revisionIndex) public view returns (string memory){\n', '        return ubounties[ubountyIndex].submissions[submissionIndex].revisions[revisionIndex];\n', '    }\n', '\n', '    mapping(address=>uint32) bountyChests; //mapping bounty chest address to bounty chest index\n', '    address payable[] public bCList; //list of bounty chest addresses\n', '    uint[] public freeBC; // list of unused bounty chests\n', '\n', '    function numBC() public view returns(uint){\n', '        return bCList.length;\n', '    }\n', '\n', '    mapping(address => uint32) public users;\n', '    address payable[] public userList;\n', '\n', '    function numUsers() public view returns(uint){\n', '        return userList.length;\n', '    }\n', '\n', '    constructor() public {\n', '        admin = msg.sender;\n', '        userList.push(address(0));\n', '        bCList.push(address(0));\n', '    }\n', '\n', '        //rename numleft to numavailable\n', '    function postOpenBounty(\n', '        string memory name,\n', '        string memory description,\n', '        uint8 available,\n', '        uint amount,\n', '        uint48 deadline\n', '        ) public payable{\n', '            require(msg.value>=fee||satisfiesWaiver(msg.sender), "both insufficient ETH for fee and DEV waiver not met");\n', '\n', '            uint _fee = getFee(msg.sender);\n', '\n', '            addUser(msg.sender);\n', '\n', '            address payable bCAddress = getBountyChest();\n', '\n', '            uint weiAmount = msg.value-_fee;\n', '\n', '            if(deadline==0){\n', '                deadline = 2**48-1;\n', '            }\n', '\n', '            setUbounty(users[msg.sender], 0, available, name, description, bountyChests[bCAddress], deadline);\n', '\n', '            collector.transfer(_fee);\n', '            transferFrom(msg.sender,bCAddress,amount);\n', '            bCAddress.transfer(weiAmount);\n', '\n', '            emit created(numUbounties++,available,amount,weiAmount);\n', '    }\n', '\n', '    function postPersonalBounty(\n', '        string memory name,\n', '        string memory description,\n', '        address payable hunter,\n', '        uint8 available,\n', '        uint amount,\n', '        uint48 deadline\n', '        ) public payable{\n', '            require(msg.value>=fee||satisfiesWaiver(msg.sender), "both insufficient ETH for fee and DEV waiver not met");\n', '\n', '            uint _fee = getFee(msg.sender);\n', '\n', '            addUser(msg.sender);\n', '            addUser(hunter);\n', '\n', '            address payable bCAddress = getBountyChest();\n', '\n', '            uint weiAmount = msg.value-_fee;\n', '\n', '            if(deadline==0){\n', '                deadline = 2**48-1;\n', '            }\n', '\n', '            setUbounty(users[msg.sender], users[hunter], available, name, description, bountyChests[bCAddress], deadline);\n', '\n', '            collector.transfer(_fee);\n', '            transferFrom(msg.sender,bCAddress,amount);\n', '            bCAddress.transfer(weiAmount);\n', '\n', '            emit created(numUbounties++,available,amount,weiAmount);\n', '    }\n', '\n', '    function awardOpenBounty(uint ubountyIndex, address payable hunter) public{\n', '        require(users[msg.sender]==ubounties[ubountyIndex].creatorIndex,"You are not the bounty publisher");\n', '        require(ubounties[ubountyIndex].available>0,"This bounty is inactive");\n', '        require(ubounties[ubountyIndex].hunterIndex==0,"Only works for Open Bounties");\n', '\n', '        uint rewardAmount = bountyAmount(ubountyIndex)/ubounties[ubountyIndex].available;\n', '        uint weiAmount = weiBountyAmount(ubountyIndex)/ubounties[ubountyIndex].available;\n', '        ubounties[ubountyIndex].available--;\n', '\n', '        ERC20(devcash).transferFrom(bCList[ubounties[ubountyIndex].bountyChestIndex],hunter,rewardAmount);\n', '        transferEth(ubountyIndex,hunter,weiAmount);\n', '\n', '        if(ubounties[ubountyIndex].available==0){\n', '            freeBC.push(ubounties[ubountyIndex].bountyChestIndex);\n', '            emit completed(ubountyIndex);\n', '        }\n', '        emit rewarded(ubountyIndex,0,hunter,rewardAmount,weiAmount);\n', '    }\n', '\n', '    function awardPersonalBounty(string memory name, string memory description, address payable hunter, uint tokenAmount) public payable {\n', '        require(msg.value>=fee||satisfiesWaiver(msg.sender), "both insufficient ETH for fee and DEV waiver not met");\n', '\n', '        uint _fee = getFee(msg.sender);\n', '\n', '        addUser(msg.sender);\n', '        addUser(hunter);\n', '\n', '        setUbounty(users[msg.sender], users[hunter], 0, name, description, 0, 0);\n', '\n', '        uint weiAmount = msg.value-_fee;\n', '\n', '        hunter.transfer(weiAmount);\n', '        transferFrom(msg.sender,hunter,tokenAmount);\n', '\n', '        collector.transfer(_fee);\n', '        emit rewarded(numUbounties,0,hunter,tokenAmount,weiAmount);\n', '        emit completed(numUbounties++);\n', '    }\n', '\n', '    function getFee(address Poster) public view returns(uint _fee) {\n', '            if(satisfiesWaiver(Poster)){\n', '                _fee=0;\n', '            } else{\n', '                _fee = fee;\n', '            }\n', '            return(_fee);\n', '    }\n', '\n', '    function addUser(address payable user) public {\n', '        if (users[user]==0){\n', '            users[user] = uint32(userList.length);\n', '            userList.push(user);\n', '        }\n', '    }\n', '\n', '    function getBountyChest() internal returns(address payable bCAddress){\n', '        if (freeBC.length>0){\n', '                bCAddress = bCList[freeBC[freeBC.length-1]];\n', '                freeBC.pop();\n', '            } else{\n', '                bountyChest C = new bountyChest();\n', '                bCAddress = address(C);\n', '                bountyChests[bCAddress] = uint32(bCList.length);\n', '                bCList.push(bCAddress);\n', '            }\n', '        return(bCAddress);\n', '    }\n', '\n', '    function setUbounty(\n', '        uint32 creatorIndex,\n', '        uint32 hunterIndex,\n', '        uint8 available,\n', '        string memory name,\n', '        string memory description,\n', '        uint32 bountyChestIndex,\n', '        uint48 deadline\n', '        ) internal {\n', '            ubounties[numUbounties].creatorIndex = creatorIndex;\n', '            ubounties[numUbounties].hunterIndex = hunterIndex;\n', '            ubounties[numUbounties].available = available;\n', '            ubounties[numUbounties].name = name;\n', '            ubounties[numUbounties].description = description;\n', '            ubounties[numUbounties].bountyChestIndex = bountyChestIndex;\n', '            ubounties[numUbounties].deadline = deadline;\n', '    }\n', '\n', '    function submit(uint ubountyIndex, string memory submissionString) public {\n', '        require(ubounties[ubountyIndex].hunterIndex==0 || msg.sender==userList[ubounties[ubountyIndex].hunterIndex],"You are not the bounty hunter");\n', '        require(now<=ubounties[ubountyIndex].deadline,"The bounty deadline has passed");\n', '        require(ubounties[ubountyIndex].available>0,"This bounty is inactive");  //make sure available is more than 0\n', '\n', '        if(users[msg.sender]==0){\n', '            users[msg.sender] = uint32(userList.length);\n', '            userList.push(msg.sender);\n', '        }\n', '\n', '        ubounties[ubountyIndex].submissions[ubounties[ubountyIndex].numSubmissions].submissionString = submissionString;\n', '        ubounties[ubountyIndex].submissions[ubounties[ubountyIndex].numSubmissions].submitterIndex = users[msg.sender];\n', '\n', '        emit submitted(ubountyIndex,ubounties[ubountyIndex].numSubmissions++);\n', '    }\n', '\n', '    function revise(uint ubountyIndex, uint32 submissionIndex, string memory revisionString) public {\n', '        require(msg.sender==userList[ubounties[ubountyIndex].submissions[submissionIndex].submitterIndex],"You are not the submitter");\n', '        require(ubounties[ubountyIndex].available>0,"This bounty is inactive");  //make sure available is more than 0\n', '        require(ubounties[ubountyIndex].submissions[submissionIndex].approved==false,"This submission has already been approved");\n', '\n', '        uint8 numRevisions = ubounties[ubountyIndex].submissions[submissionIndex].numRevisions;\n', '        ubounties[ubountyIndex].submissions[submissionIndex].revisions[numRevisions] = revisionString;\n', '        emit revised(ubountyIndex,submissionIndex,numRevisions);\n', '        ubounties[ubountyIndex].submissions[submissionIndex].numRevisions++;\n', '    }\n', '\n', '    function approve(uint ubountyIndex,uint submissionIndex,string memory feedback) public{\n', '        require(users[msg.sender]==ubounties[ubountyIndex].creatorIndex,"You are not the bounty publisher");\n', '        require(ubounties[ubountyIndex].available>0,"This bounty is inactive");\n', '        require(submissionIndex<ubounties[ubountyIndex].numSubmissions,"Submission does not exist");\n', '        require(ubounties[ubountyIndex].submissions[submissionIndex].approved==false,"This submission has already been approved");\n', '\n', '        emit approved(ubountyIndex, submissionIndex, feedback);\n', '        ubounties[ubountyIndex].submissions[submissionIndex].approved=true;\n', '        address payable hunter = userList[ubounties[ubountyIndex].submissions[submissionIndex].submitterIndex];\n', '        reward(ubountyIndex,submissionIndex,hunter);\n', '    }\n', '\n', '    function reject(uint ubountyIndex,uint submissionIndex,string memory feedback) public{\n', '        require(users[msg.sender]==ubounties[ubountyIndex].creatorIndex,"You are not the bounty publisher");\n', '        require(ubounties[ubountyIndex].available>0,"This bounty is inactive");\n', '        require(submissionIndex<ubounties[ubountyIndex].numSubmissions,"Submission does not exist");\n', '        require(ubounties[ubountyIndex].submissions[submissionIndex].approved==false,"This bounty has already been approved");\n', '\n', '        emit rejected(ubountyIndex, submissionIndex, feedback);\n', '    }\n', '\n', '    function requestRevision(uint ubountyIndex,uint submissionIndex,string memory feedback) public {\n', '        require(users[msg.sender]==ubounties[ubountyIndex].creatorIndex,"You are not the bounty publisher");\n', '        require(ubounties[ubountyIndex].available>0,"This bounty is inactive");\n', '        require(submissionIndex<ubounties[ubountyIndex].numSubmissions,"Submission does not exist");\n', '        require(ubounties[ubountyIndex].submissions[submissionIndex].approved==false,"This bounty has already been approved");\n', '\n', '        emit revisionRequested(ubountyIndex,submissionIndex,feedback);\n', '    }\n', '\n', '    function reward(uint ubountyIndex, uint submissionIndex, address payable hunter) internal {\n', '\n', '        uint rewardAmount = bountyAmount(ubountyIndex)/ubounties[ubountyIndex].available;\n', '        uint weiRewardAmount = weiBountyAmount(ubountyIndex)/ubounties[ubountyIndex].available;\n', '        ubounties[ubountyIndex].available--;\n', '\n', '        transferEth(ubountyIndex,hunter,weiRewardAmount);\n', '        transferFrom(bCList[ubounties[ubountyIndex].bountyChestIndex],hunter,rewardAmount);\n', '\n', '        emit rewarded(ubountyIndex,submissionIndex,hunter,rewardAmount,weiRewardAmount);\n', '\n', '        if(ubounties[ubountyIndex].available==0){\n', '            freeBC.push(ubounties[ubountyIndex].bountyChestIndex);\n', '            emit completed(ubountyIndex);\n', '        }\n', '    }\n', '\n', '    function contribute(uint ubountyIndex, uint amount) public{\n', '        require(ubounties[ubountyIndex].available>0,"This bounty is inactive");\n', '        address bCAddress = bCList[ubounties[ubountyIndex].bountyChestIndex];\n', '        ERC20(devcash).transferFrom(msg.sender,bCAddress,amount);\n', '    }\n', '\n', '    function contributeWei(uint ubountyIndex) public payable{\n', '        require(ubounties[ubountyIndex].available>0,"This bounty is inactive");\n', '        bCList[ubounties[ubountyIndex].bountyChestIndex].transfer(msg.value);\n', '    }\n', '\n', '    function reclaim(uint ubountyIndex) public {\n', '        require(users[msg.sender]==ubounties[ubountyIndex].creatorIndex,"You are not the bounty creator");\n', '        require(ubounties[ubountyIndex].deadline!=2**48-1,"This bounty was created without a deadline, and is not reclaimable");\n', '        require(now>ubounties[ubountyIndex].deadline,"The bounty deadline has not yet elapsed");\n', '        require(ubounties[ubountyIndex].available>0,"This bounty is inactive");\n', '\n', '        uint weiAmount = weiBountyAmount(ubountyIndex);\n', '\n', '        emit reclaimed(ubountyIndex,bountyAmount(ubountyIndex),weiAmount);\n', '\n', '        transferFrom(bCList[ubounties[ubountyIndex].bountyChestIndex],msg.sender,bountyAmount(ubountyIndex));\n', '        transferEth(ubountyIndex,msg.sender,weiAmount);\n', '\n', '        freeBC.push(ubounties[ubountyIndex].bountyChestIndex);\n', '\n', '        ubounties[ubountyIndex].available = 0;\n', '\n', '        for(uint i=0;i<ubounties[ubountyIndex].numSubmissions&&i<1800;i++){\n', '            if(ubounties[ubountyIndex].submissions[i].approved==false){\n', '                emit rejected(ubountyIndex,i,"bounty has been reclaimed");\n', '            }\n', '        }\n', '    }\n', '\n', '    function reclaimable(uint ubountyIndex) public view returns(bool){\n', '        if(ubounties[ubountyIndex].deadline!=2**48-1){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function reclaimableNow(uint ubountyIndex) public view returns(bool){\n', '        if(now>ubounties[ubountyIndex].deadline){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint amount) internal {\n', '        ERC20(devcash).transferFrom(from,to,amount);\n', '    }\n', '\n', '    function transferEth(uint ubountyIndex, address payable to, uint amount) internal {\n', '        address payable bCAddress = bCList[ubounties[ubountyIndex].bountyChestIndex];\n', '        bountyChest(bCAddress).transfer(to,amount);\n', '    }\n', '\n', '    function bountyAmount(uint ubountyIndex) public view returns(uint){\n', '        return(ERC20(devcash).balanceOf(bCList[ubounties[ubountyIndex].bountyChestIndex]));\n', '    }\n', '\n', '    function weiBountyAmount(uint ubountyIndex) public view returns(uint){\n', '        return(bCList[ubounties[ubountyIndex].bountyChestIndex].balance);\n', '    }\n', '\n', '    function createBountyChest() public {\n', '        bountyChest C = new bountyChest();\n', '        address payable bCAddress = address(C);\n', '        bountyChests[bCAddress] = uint32(bCList.length);\n', '        freeBC.push(bCList.length);\n', '        bCList.push(bCAddress);\n', '    }\n', '\n', '    function setFee(uint _fee) public {\n', '        require(admin==msg.sender);\n', '        emit feeChange(fee,_fee);\n', '        fee = _fee;\n', '    }\n', '\n', '      function setWaiver(uint _waiver) public {\n', '        require(admin==msg.sender);\n', '        emit waiverChange(waiver,_waiver);\n', '        waiver = _waiver;\n', '    }\n', '\n', '    function satisfiesWaiver(address poster) public view returns(bool){\n', '        if(ERC20(devcash).balanceOf(poster)>=waiver){\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '}']