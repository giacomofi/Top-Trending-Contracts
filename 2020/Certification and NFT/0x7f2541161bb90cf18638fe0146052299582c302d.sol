['pragma solidity 0.4.25;\n', '\n', '// File: contracts/contract_address_locator/interfaces/IContractAddressLocator.sol\n', '\n', '/**\n', ' * @title Contract Address Locator Interface.\n', ' */\n', 'interface IContractAddressLocator {\n', '    /**\n', '     * @dev Get the contract address mapped to a given identifier.\n', '     * @param _identifier The identifier.\n', '     * @return The contract address.\n', '     */\n', '    function getContractAddress(bytes32 _identifier) external view returns (address);\n', '\n', '    /**\n', '     * @dev Determine whether or not a contract address relates to one of the identifiers.\n', '     * @param _contractAddress The contract address to look for.\n', '     * @param _identifiers The identifiers.\n', '     * @return A boolean indicating if the contract address relates to one of the identifiers.\n', '     */\n', '    function isContractAddressRelates(address _contractAddress, bytes32[] _identifiers) external view returns (bool);\n', '}\n', '\n', '// File: contracts/contract_address_locator/ContractAddressLocator.sol\n', '\n', '/**\n', ' * Details of usage of licenced software see here: https://www.sogur.com/software/readme_v1\n', ' */\n', '\n', '/**\n', ' * @title Contract Address Locator.\n', ' * @dev Map a unique identifier to every contract address in the system.\n', ' * @dev On-chain, this contract is used for retrieving the address of any contract in the system.\n', ' * @dev Off-chain, this contract is used for initializing the mapping between identifiers and contract addresses.\n', ' */\n', 'contract ContractAddressLocator is IContractAddressLocator {\n', '    string public constant VERSION = "1.0.0";\n', '\n', '    uint256 identifiersCount;\n', '\n', '    mapping(bytes32 => address) private contractAddresses;\n', '\n', '    event Mapped(bytes32 indexed _identifier, address indexed _contractAddress);\n', '\n', '    /**\n', '     * @dev Create the contract.\n', '     * @param _identifiers A list of identifiers.\n', '     * @param _contractAddresses A list of contract addresses.\n', '     * @notice This contract is designated to be deployed every time the system is upgraded.\n', '     * @notice Deployment will fail if the length of the lists yields gas requirement larger than the block gas-limit.\n', '     * @notice However, there is no point in setting a restriction on the length of the lists in order to prevent this scenario.\n', '     * @notice Instead, if such scenario is ever encountered, this function will need to be adjusted in order to allow its execution.\n', '     */\n', '    constructor(bytes32[] memory _identifiers, address[] _contractAddresses) public {\n', '        identifiersCount = _identifiers.length;\n', '        require(identifiersCount == _contractAddresses.length, "list lengths are not equal");\n', '        for (uint256 i = 0; i < identifiersCount; i++) {\n', '            require(uint256(contractAddresses[_identifiers[i]]) == 0, "identifiers are not unique");\n', '            contractAddresses[_identifiers[i]] = _contractAddresses[i];\n', '            emit Mapped(_identifiers[i], _contractAddresses[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Get the contract address mapped to a given identifier.\n', '     * @param _identifier The identifier.\n', '     * @return The contract address.\n', '     */\n', '    function getContractAddress(bytes32 _identifier) external view returns (address) {\n', '        return contractAddresses[_identifier];\n', '    }\n', '\n', '    /**\n', '     * @dev Determine whether or not a contract address relates to one of the identifiers.\n', '     * @param _contractAddress The contract address to look for.\n', '     * @param _identifiers The identifiers.\n', '     * @return A boolean indicating if the contract address relates to one of the identifiers.\n', '     */\n', '    function isContractAddressRelates(address _contractAddress, bytes32[] _identifiers) external view returns (bool){\n', '        assert(_contractAddress != address(0));\n', '        uint256 _identifiersCount = _identifiers.length;\n', '        require(_identifiersCount <= identifiersCount, "cannot be more than actual identifiers count");\n', '        bool isRelate = false;\n', '        for (uint256 i = 0; i < _identifiersCount; i++) {\n', '            if (_contractAddress == contractAddresses[_identifiers[i]]) {\n', '                isRelate = true;\n', '                break;\n', '            }\n', '        }\n', '        return isRelate;\n', '    }\n', '\n', '}']