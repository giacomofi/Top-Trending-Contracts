['pragma solidity ^0.4.24;\n', '\n', '// submitted by dev-xu\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '// @title SafeMath: overflow/underflow checks\n', '// @notice Math operations with safety checks that throw on error\n', 'library SafeMath {\n', '\n', '  // @notice Multiplies two numbers, throws on overflow.\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  // @notice Integer division of two numbers, truncating the quotient.\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  // @notice Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  // @notice Adds two numbers, throws on overflow.\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  // @notice Returns fractional amount\n', '  function getFractionalAmount(uint256 _amount, uint256 _percentage)\n', '  internal\n', '  pure\n', '  returns (uint256) {\n', '    return div(mul(_amount, _percentage), 100);\n', '  }\n', '\n', '}\n', '\n', '// Database interface\n', 'interface DBInterface {\n', '\n', '  function setContractManager(address _contractManager)\n', '  external;\n', '\n', '    // --------------------Set Functions------------------------\n', '\n', '    function setAddress(bytes32 _key, address _value)\n', '    external;\n', '\n', '    function setUint(bytes32 _key, uint _value)\n', '    external;\n', '\n', '    function setString(bytes32 _key, string _value)\n', '    external;\n', '\n', '    function setBytes(bytes32 _key, bytes _value)\n', '    external;\n', '\n', '    function setBytes32(bytes32 _key, bytes32 _value)\n', '    external;\n', '\n', '    function setBool(bytes32 _key, bool _value)\n', '    external;\n', '\n', '    function setInt(bytes32 _key, int _value)\n', '    external;\n', '\n', '\n', '     // -------------- Deletion Functions ------------------\n', '\n', '    function deleteAddress(bytes32 _key)\n', '    external;\n', '\n', '    function deleteUint(bytes32 _key)\n', '    external;\n', '\n', '    function deleteString(bytes32 _key)\n', '    external;\n', '\n', '    function deleteBytes(bytes32 _key)\n', '    external;\n', '\n', '    function deleteBytes32(bytes32 _key)\n', '    external;\n', '\n', '    function deleteBool(bytes32 _key)\n', '    external;\n', '\n', '    function deleteInt(bytes32 _key)\n', '    external;\n', '\n', '    // ----------------Variable Getters---------------------\n', '\n', '    function uintStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (uint);\n', '\n', '    function stringStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (string);\n', '\n', '    function addressStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '    function bytesStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (bytes);\n', '\n', '    function bytes32Storage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (bytes32);\n', '\n', '    function boolStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (bool);\n', '\n', '    function intStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (bool);\n', '}\n', '\n', 'contract Events {\n', '  DBInterface public database;\n', '\n', '  constructor(address _database) public{\n', '    database = DBInterface(_database);\n', '  }\n', '\n', '  function message(string _message)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogEvent(_message, keccak256(abi.encodePacked(_message)), tx.origin);\n', '  }\n', '\n', '  function transaction(string _message, address _from, address _to, uint _amount, address _token)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogTransaction(_message, keccak256(abi.encodePacked(_message)), _from, _to, _amount, _token, tx.origin);\n', '  }\n', '\n', '  function registration(string _message, address _account)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogAddress(_message, keccak256(abi.encodePacked(_message)), _account, tx.origin);\n', '  }\n', '\n', '  function contractChange(string _message, address _account, string _name)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogContractChange(_message, keccak256(abi.encodePacked(_message)), _account, _name, tx.origin);\n', '  }\n', '\n', '  function asset(string _message, string _uri, address _assetAddress, address _manager)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogAsset(_message, keccak256(abi.encodePacked(_message)), _uri, keccak256(abi.encodePacked(_uri)), _assetAddress, _manager, tx.origin);\n', '  }\n', '\n', '  function escrow(string _message, address _assetAddress, bytes32 _escrowID, address _manager, uint _amount)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogEscrow(_message, keccak256(abi.encodePacked(_message)), _assetAddress, _escrowID, _manager, _amount, tx.origin);\n', '  }\n', '\n', '  function order(string _message, bytes32 _orderID, uint _amount, uint _price)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogOrder(_message, keccak256(abi.encodePacked(_message)), _orderID, _amount, _price, tx.origin);\n', '  }\n', '\n', '  function exchange(string _message, bytes32 _orderID, address _assetAddress, address _account)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogExchange(_message, keccak256(abi.encodePacked(_message)), _orderID, _assetAddress, _account, tx.origin);\n', '  }\n', '\n', '  function operator(string _message, bytes32 _id, string _name, string _ipfs, address _account)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogOperator(_message, keccak256(abi.encodePacked(_message)), _id, _name, _ipfs, _account, tx.origin);\n', '  }\n', '\n', '  function consensus(string _message, bytes32 _executionID, bytes32 _votesID, uint _votes, uint _tokens, uint _quorum)\n', '  external\n', '  onlyApprovedContract {\n', '    emit LogConsensus(_message, keccak256(abi.encodePacked(_message)), _executionID, _votesID, _votes, _tokens, _quorum, tx.origin);\n', '  }\n', '\n', '  //Generalized events\n', '  event LogEvent(string message, bytes32 indexed messageID, address indexed origin);\n', '  event LogTransaction(string message, bytes32 indexed messageID, address indexed from, address indexed to, uint amount, address token, address origin); //amount and token will be empty on some events\n', '  event LogAddress(string message, bytes32 indexed messageID, address indexed account, address indexed origin);\n', '  event LogContractChange(string message, bytes32 indexed messageID, address indexed account, string name, address indexed origin);\n', '  event LogAsset(string message, bytes32 indexed messageID, string uri, bytes32 indexed assetID, address asset, address manager, address indexed origin);\n', '  event LogEscrow(string message, bytes32 indexed messageID, address asset, bytes32  escrowID, address indexed manager, uint amount, address indexed origin);\n', '  event LogOrder(string message, bytes32 indexed messageID, bytes32 indexed orderID, uint amount, uint price, address indexed origin);\n', '  event LogExchange(string message, bytes32 indexed messageID, bytes32 orderID, address indexed asset, address account, address indexed origin);\n', '  event LogOperator(string message, bytes32 indexed messageID, bytes32 id, string name, string ipfs, address indexed account, address indexed origin);\n', '  event LogConsensus(string message, bytes32 indexed messageID, bytes32 executionID, bytes32 votesID, uint votes, uint tokens, uint quorum, address indexed origin);\n', '\n', '\n', '  // --------------------------------------------------------------------------------------\n', '  // Caller must be registered as a contract through ContractManager.sol\n', '  // --------------------------------------------------------------------------------------\n', '  modifier onlyApprovedContract() {\n', '      require(database.boolStorage(keccak256(abi.encodePacked("contract", msg.sender))));\n', '      _;\n', '  }\n', '\n', '}\n', '\n', '// @notice Trade via the Kyber Proxy Contract\n', 'interface KyberInterface {\n', '  function getExpectedRate(address src, address dest, uint srcQty) external view returns (uint expectedRate, uint slippageRate);\n', '  function trade(address src, uint srcAmount, address dest, address destAddress, uint maxDestAmount,uint minConversionRate, address walletId) external payable returns(uint);\n', '}\n', '\n', 'interface MinterInterface {\n', '  function cloneToken(string _uri, address _erc20Address) external returns (address asset);\n', '\n', '  function mintAssetTokens(address _assetAddress, address _receiver, uint256 _amount) external returns (bool);\n', '\n', '  function changeTokenController(address _assetAddress, address _newController) external returns (bool);\n', '}\n', '\n', 'interface CrowdsaleGeneratorERC20_ERC20 {\n', '  function balanceOf(address _who) external view returns (uint256);\n', '  function allowance(address _owner, address _spender) external view returns (uint256);\n', '  function approve(address _spender, uint256 _value) external returns (bool);\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '}\n', '\n', '// @title A crowdsale generator contract\n', '// @author Kyle Dewhurst & Peter Phillips, Roy Xu, MyBit Foundation\n', '// @notice AssetManagers can initiate a crowdsale that accepts ERC20 tokens as payment here\n', 'contract CrowdsaleGeneratorERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  DBInterface private database;\n', '  Events private events;\n', '  KyberInterface private kyber;\n', '  MinterInterface private minter;\n', '  //CrowdsaleGeneratorERC20_ERC20Burner private burner;\n', '\n', '  //uint constant scalingFactor = 10**32;\n', '\n', '  // @notice This contract\n', '  // @param: The address for the database contract used by this platform\n', '  constructor(address _database, address _events, address _kyber)\n', '  public{\n', '      database = DBInterface(_database);\n', '      events = Events(_events);\n', '      kyber = KyberInterface(_kyber);\n', '      minter = MinterInterface(database.addressStorage(keccak256(abi.encodePacked("contract", "Minter"))));\n', '  }\n', '  \n', '  // @notice Do not send ether to this contract, this is for kyber exchange to get return\n', '  // @dev After collecting listing fee in token, remaining ether gets refunded from kyber\n', '  function() public payable {\n', '    \n', '  }\n', '\n', '  // @notice AssetManagers can initiate a crowdfund for a new asset here\n', '  // @dev the crowdsaleERC20 contract is granted rights to mint asset-tokens as it receives funding\n', '  // @param (string) _assetURI = The location where information about the asset can be found\n', '  // @param (uint) _fundingLength = The number of seconds this crowdsale is to go on for until it fails\n', '  // @param (uint) _amountToRaise = The amount of tokens required to raise for the crowdsale to be a success\n', '  // @param (uint) _assetManagerPerc = The percentage of the total revenue which is to go to the AssetManager if asset is a success\n', '  // @param (address) _fundingToken = The ERC20 token to be used to fund the crowdsale (Operator must accept this token as payment)\n', '  function createAssetOrderERC20(string _assetURI, string _ipfs, uint _fundingLength, uint _amountToRaise, uint _assetManagerPerc, uint _escrowAndFee, address _fundingToken, address _paymentToken)\n', '  payable\n', '  external\n', '  {\n', '    if(_paymentToken == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)){\n', '      require(msg.value == _escrowAndFee, "ETH amount is not matching with escrow needed.");\n', '    } else {\n', '      require(msg.value == 0, "ETH is not required when paying with token");\n', '      CrowdsaleGeneratorERC20_ERC20(_paymentToken).transferFrom(msg.sender, address(this), _escrowAndFee);\n', '    }\n', '\n', '    require(_amountToRaise >= 100, "Crowdsale goal is too small");\n', '    require((_assetManagerPerc + database.uintStorage(keccak256(abi.encodePacked("platform.percentage")))) < 100, "Manager percent need to be less than 100");\n', '    require(!database.boolStorage(keccak256(abi.encodePacked("asset.uri", _assetURI))), "Asset URI is not unique"); //Check that asset URI is unique\n', '    uint escrow = processListingFee(_paymentToken, _escrowAndFee);\n', '    address assetAddress = minter.cloneToken(_assetURI, _fundingToken);\n', '    require(setCrowdsaleValues(assetAddress, _fundingLength, _amountToRaise), "Failed to set crowdsale values");\n', '    require(setAssetValues(assetAddress, _assetURI, _ipfs, msg.sender, _assetManagerPerc, _amountToRaise, _fundingToken), "Failed to set asset values");\n', '\n', '    //Lock escrow\n', '    if (escrow > 0) {\n', '      require(lockEscrowERC20(msg.sender, assetAddress, _paymentToken, _fundingToken, escrow), "Failed to lock ERC20 escrow");\n', '    }\n', "    events.asset('Asset funding started', _assetURI, assetAddress, msg.sender);\n", "    events.asset('New asset ipfs', _ipfs, assetAddress, msg.sender);\n", '  }\n', '\n', '  function updateIPFS(address _assetAddress, string _ipfs)\n', '  external {\n', '    require(msg.sender == database.addressStorage(keccak256(abi.encodePacked("asset.manager", _assetAddress))));\n', '    database.setString(keccak256(abi.encodePacked("asset.ipfs", _assetAddress)), _ipfs);\n', "    events.asset('New asset ipfs', _ipfs, _assetAddress, msg.sender);\n", '  }\n', '\n', '  // @notice platform owners can destroy contract here\n', '  function destroy()\n', '  onlyOwner\n', '  external {\n', "    events.transaction('CrowdsaleGeneratorERC20 destroyed', address(this), msg.sender, address(this).balance, address(0));\n", '    selfdestruct(msg.sender);\n', '  }\n', '\n', '  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '  //                                            Internal/ Private Functions\n', '  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '  function setCrowdsaleValues(address _assetAddress, uint _fundingLength, uint _amountToRaise)\n', '  private\n', '  returns (bool){\n', '    database.setUint(keccak256(abi.encodePacked("crowdsale.start", _assetAddress)), now);\n', '    database.setUint(keccak256(abi.encodePacked("crowdsale.deadline", _assetAddress)), now.add(_fundingLength));\n', '    database.setUint(keccak256(abi.encodePacked("crowdsale.goal", _assetAddress)), _amountToRaise);\n', '    database.setUint(keccak256(abi.encodePacked("crowdsale.remaining", _assetAddress)), _amountToRaise.mul(uint(100).add(database.uintStorage(keccak256(abi.encodePacked("platform.fee"))))).div(100));\n', '    return true;\n', '  }\n', '\n', '  function setAssetValues(address _assetAddress, string _assetURI, string _ipfs, address _assetManager, uint _assetManagerPerc, uint _amountToRaise, address _fundingToken)\n', '  private\n', '  returns (bool){\n', '    uint totalTokens = _amountToRaise.mul(100).div(uint(100).sub(_assetManagerPerc).sub(database.uintStorage(keccak256(abi.encodePacked("platform.percentage")))));\n', '    //database.setUint(keccak256(abi.encodePacked("asset.managerTokens", assetAddress)), _amountToRaise.mul(uint(100).mul(scalingFactor).div(uint(100).sub(_assetManagerPerc)).sub(scalingFactor)).div(scalingFactor));\n', '    database.setUint(keccak256(abi.encodePacked("asset.managerTokens", _assetAddress)), totalTokens.getFractionalAmount(_assetManagerPerc));\n', '    database.setUint(keccak256(abi.encodePacked("asset.platformTokens", _assetAddress)), totalTokens.getFractionalAmount(database.uintStorage(keccak256(abi.encodePacked("platform.percentage")))));\n', '    database.setAddress(keccak256(abi.encodePacked("asset.manager", _assetAddress)), _assetManager);\n', '    database.setString(keccak256(abi.encodePacked("asset.ipfs", _assetAddress)), _ipfs);\n', '\n', '    database.setBool(keccak256(abi.encodePacked("asset.uri", _assetURI)), true); //Set to ensure a unique asset URI\n', '    return true;\n', '  }\n', '\n', '  function processListingFee(address _paymentTokenAddress, uint _fromAmount)\n', '  private\n', '  returns (uint) { // returns left amount\n', '    uint listingFee = database.uintStorage(keccak256(abi.encodePacked("platform.listingFee")));\n', '    address listingFeeTokenAddress = database.addressStorage(keccak256(abi.encodePacked("platform.listingFeeToken")));\n', '    address platformFundsWallet = database.addressStorage(keccak256(abi.encodePacked("platform.wallet.funds")));\n', '    uint usedAmount;\n', '    uint balanceBefore;\n', '    uint listingFeePaid;\n', '    uint expectedRate;\n', '    uint estimation;\n', '    CrowdsaleGeneratorERC20_ERC20 paymentToken;\n', '\n', '    if (_paymentTokenAddress != listingFeeTokenAddress) {\n', '      //Convert the payment token into the listing fee token\n', '      ( expectedRate, ) = kyber.getExpectedRate(listingFeeTokenAddress, _paymentTokenAddress, listingFee);\n', '      estimation = expectedRate * listingFee / 0.8 ether; // giving slippage rate of 0.8\n', '\n', '      if(_paymentTokenAddress == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)){\n', '        balanceBefore = address(this).balance;\n', '        listingFeePaid = kyber.trade.value(estimation)(_paymentTokenAddress, estimation, listingFeeTokenAddress, platformFundsWallet, listingFee, 0, 0);\n', '\n', '        usedAmount = balanceBefore - address(this).balance; // used eth by kyber for swapping with token\n', '      } else {\n', '        paymentToken = CrowdsaleGeneratorERC20_ERC20(_paymentTokenAddress);\n', '        balanceBefore = paymentToken.balanceOf(address(this));\n', '\n', '        require(paymentToken.approve(address(kyber), estimation));\n', '        listingFeePaid = kyber.trade(_paymentTokenAddress, estimation, listingFeeTokenAddress, platformFundsWallet, listingFee, 0, 0); //Currently no minimum rate is set, so watch out for slippage!\n', '        paymentToken.approve(address(kyber), 0);\n', '        usedAmount = balanceBefore - paymentToken.balanceOf(address(this));\n', '      }\n', '    } else {\n', '      paymentToken = CrowdsaleGeneratorERC20_ERC20(_paymentTokenAddress);\n', '      require(paymentToken.transfer(platformFundsWallet, listingFee), "Listing fee not paid");\n', '      usedAmount = listingFee;\n', '      listingFeePaid = listingFee;\n', '    }\n', '\n', '    require(_fromAmount >= usedAmount && listingFeePaid >= listingFee, "Listing fee not paid");\n', '    return _fromAmount - usedAmount;\n', '  }\n', '\n', '  function lockEscrowERC20(address _assetManager, address _assetAddress, address _paymentTokenAddress, address _fundingTokenAddress, uint _amount)\n', '  private\n', '  returns (bool) {\n', '    uint amount;\n', '    bytes32 assetManagerEscrowID = keccak256(abi.encodePacked(_assetAddress, _assetManager));\n', '    address platformTokenAddress = database.addressStorage(keccak256(abi.encodePacked("platform.token")));\n', '    if(_paymentTokenAddress != platformTokenAddress){\n', '      //Convert the payment token into the platform token\n', '      if(_paymentTokenAddress == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)){\n', '        amount = kyber.trade.value(_amount)(_paymentTokenAddress, _amount, platformTokenAddress, address(this), 2**255, 0, 0); //Currently no minimum rate is set, so watch out for slippage!\n', '      } else {\n', '        CrowdsaleGeneratorERC20_ERC20 paymentToken = CrowdsaleGeneratorERC20_ERC20(_paymentTokenAddress);\n', '        require(paymentToken.approve(address(kyber), _amount));\n', '        amount = kyber.trade(_paymentTokenAddress, _amount, platformTokenAddress, address(this), 2**255, 0, 0); //Currently no minimum rate is set, so watch out for slippage!\n', '      }\n', '    } else {\n', '      amount = _amount;\n', '    }\n', '    require(CrowdsaleGeneratorERC20_ERC20(platformTokenAddress).transfer(database.addressStorage(keccak256(abi.encodePacked("contract", "EscrowReserve"))), amount));\n', '    database.setUint(keccak256(abi.encodePacked("asset.escrow", assetManagerEscrowID)), amount);\n', "    events.escrow('Escrow locked', _assetAddress, assetManagerEscrowID, _assetManager, amount);\n", '    return true;\n', '  }\n', '\n', '\n', '  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '  //                                            Modifiers\n', '  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '  // @notice Sender must be a registered owner\n', '  modifier onlyOwner {\n', '    require(database.boolStorage(keccak256(abi.encodePacked("owner", msg.sender))), "Not owner");\n', '    _;\n', '  }\n', '\n', '  modifier checkRequirements {\n', '    _;\n', '  }\n', '}']