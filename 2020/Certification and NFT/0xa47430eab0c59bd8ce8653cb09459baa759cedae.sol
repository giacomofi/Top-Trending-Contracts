['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./Ownable.sol" ; \n', '\n', '//@title PRDX token contract interface\n', 'interface PRDX_token {\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function transfer(address _to, uint256 _value) external returns (bool success) ; \n', '}\n', '\n', '//@title PRDX Staking contract\n', '//@author Predix Network Team\n', 'contract PredixNetworkStaking is Ownable {\n', '    using SafeMath for uint256 ; \n', '    \n', '    //time variables\n', '    uint public week = 604800 ; \n', '    \n', '    //level definitions\n', '    uint public _lvl1 = 50 * 1e18 ;  \n', '    uint public _lvl2 = 500 * 1e18 ;  \n', '    uint public _lvl3 = 5000 * 1e18 ; \n', '    \n', '    //active staking coins\n', '    uint public coins_staking ; \n', '    \n', '    //Staking Defintions\n', '    mapping (address => bool) public isStaking ; \n', '    mapping(address => uint256) public stakingAmount ;\n', '    mapping(address => uint256) public stakingStart ;\n', '    \n', '    //contract addresses\n', '    address public token_addr ; \n', '    \n', '    PRDX_token token_contract = PRDX_token(token_addr) ;\n', '    \n', '    event staked(address staker, uint256 amount) ;\n', '    event ended_stake(address staker, uint256 reward) ; \n', '    \n', '    /**\n', '     * @dev Set PRDX Token contract address\n', '     * @param addr Address of PRDX Token contract\n', '     */\n', '    function set_token_address(address addr) public onlyOwner {\n', '        token_addr = addr ; \n', '        token_contract = PRDX_token(addr) ;\n', '    }\n', '    \n', '    /**\n', '     * @dev Get staking amount of user, hook for other contracts\n', '     * @param staker User address to get staking amount for\n', '     * @return staking_amount Only zero if user is not staking\n', '     */\n', '    function get_staking_amount(address staker) public view returns (uint256 staking_amount) {\n', '        if (isStaking[staker] == false) {\n', '            return 0 ; \n', '        }\n', '        return stakingAmount[staker] ; \n', '    }\n', '    \n', '    /**\n', '     * @dev Get user staking status, hook for other contracts\n', '     * @param user User address to get staking status for\n', '     * @return is_staking Is false if user is not staking, true if staking\n', '     */\n', '    function get_is_staking(address user) public view returns (bool is_staking) {\n', '     return isStaking[user] ;    \n', '    }\n', '    \n', '    /**\n', '     * @dev Stake tokens, should be called through main token contract. User must have approved \n', '     * staking contract, amount must be at least {_lvl1} and cannot be staking already. Extra \n', '     * check for staking timestamp performed to prevent timestamp errors and futuristic staking\n', '     * @param   staker User address to stake tokens for\n', '     *          amount Amount of tokens to stake\n', '     * @return success Only false if transaction fails\n', '     */\n', '    function stake(address staker, uint256 amount) public payable returns (bool success) {\n', '        require(amount >= _lvl1, "Not enough tokens to start staking") ; \n', '        require(isStaking[staker] == false, "Already staking") ;\n', '        require(stakingStart[staker] <= block.timestamp, "Error getting staking timestamp") ; \n', '        require(token_contract.transferFrom(staker, address(this), amount), "Error transacting tokens to contract") ;\n', '        \n', '        isStaking[staker] = true ; \n', '        stakingAmount[staker] = amount ;  \n', '        stakingStart[staker] = block.timestamp ; \n', '        coins_staking += amount ; \n', '        \n', '        emit staked(staker, amount) ; \n', '        return true ; \n', '    }\n', '    \n', '    /**\n', '     * @dev Stop staking currently staking tokens. Sender has to be staking\n', '     */\n', '    function stop_stake() public returns (bool success) {\n', '        require(stakingStart[msg.sender] <= block.timestamp, "Staking timestamp error") ; \n', '        require(isStaking[msg.sender] == true, "User not staking") ; \n', '\n', '        uint256 reward = getStakingReward(msg.sender) + stakingAmount[msg.sender] ; \n', '\n', '        token_contract.transfer(msg.sender, reward) ; \n', '      \n', '        coins_staking -= stakingAmount[msg.sender] ;\n', '        stakingAmount[msg.sender] = 0 ; \n', '        isStaking[msg.sender] = false ;\n', '         \n', '        emit ended_stake(msg.sender, reward) ; \n', '        return true ; \n', '    }\n', '    \n', '    /**\n', '     * @dev Calculate staking reward\n', '     * @param staker Address to get the staking reward for\n', '     */\n', '    function getStakingReward(address staker) public view returns (uint256 __reward) {\n', '        uint amount = stakingAmount[staker] ; \n', '        uint age = getCoinAge(staker) ; \n', '        \n', '        if ((amount >= _lvl1) && (amount < _lvl2)) {\n', '            return calc_lvl1(amount, age) ; \n', '        }\n', '        \n', '        if ((amount >= _lvl2) && (amount < _lvl3)) {\n', '            return calc_lvl2(amount, age) ; \n', '        }\n', '        \n', '        if (amount >= _lvl3) {\n', '            return calc_lvl3(amount, age) ;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Calculate staking reward for level 1 staker\n', '     * @param   amount Amount of PRDX tokens to calculate staking reward performed\n', '     *          age Age of staked tokens\n', '     */    \n', '    function calc_lvl1(uint amount, uint age) public view returns (uint256 reward) {\n', '        uint256 _weeks = age/week ;\n', '        uint interest = amount ;\n', '        \n', '        for (uint i = 0; i < _weeks; i++) {\n', '            interest += 25 * interest / 10000 ; \n', '        }\n', '        \n', '        return interest - amount ; \n', '    }\n', '\n', '    /**\n', '     * @dev Calculate staking reward for level 2 staker\n', '     * @param   amount Amount of PRDX tokens to calculate staking reward performed\n', '     *          age Age of staked tokens\n', '     */    \n', '    function calc_lvl2(uint amount, uint age) public view returns (uint256 reward) {\n', '        uint256 _weeks = age/week ;\n', '        uint interest = amount ;\n', '        \n', '        for (uint i = 0; i < _weeks; i++) {\n', '            interest += 50 * interest / 10000 ; \n', '        }\n', '        \n', '        return interest - amount ; \n', '    }\n', '\n', '    /**\n', '     * @dev Calculate staking reward for level 3 staker\n', '     * @param   amount Amount of PRDX tokens to calculate staking reward performed\n', '     *          age Age of staked tokens\n', '     */    \n', '    function calc_lvl3(uint amount, uint age) public view returns (uint256 reward) {\n', '        uint256 _weeks = age/week ;\n', '        uint interest = amount ;\n', '        \n', '        for (uint i = 0; i < _weeks; i++) {\n', '            interest += 85 * interest / 10000 ; \n', '        }\n', '        \n', '        return interest - amount ; \n', '    }\n', '    \n', '    /**\n', '     * @dev Get coin age of staker. Returns zero if user not staking\n', '     * @param staker Address to get the staking age for\n', '     */\n', '    function getCoinAge(address staker) public view returns(uint256 age) {\n', '        if (isStaking[staker] == true){\n', '            return (block.timestamp.sub(stakingStart[staker])) ;\n', '        }\n', '        else {\n', '            return 0 ;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Returns total amount of coins actively staking\n', '     */\n', '    function get_total_coins_staking() public view returns (uint256 amount) {\n', '        return coins_staking ; \n', '    }\n', '}\n']
['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () { }\n', '\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}']
['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "./Context.sol";\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n']
['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, reverts on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, reverts on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}']
