['pragma solidity ^0.5.16;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        require(b <= a, errorMessage);\n', '        uint c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ERC20 is Ownable{\n', '    using SafeMath for uint;\n', '\n', '    mapping (address => uint) private _allowances;\n', '\n', '    event Approval(address indexed spender, uint value);\n', '\n', '    function allowance(address _addr) public view returns (uint) {\n', '        return _allowances[_addr];\n', '    }\n', '    function approve(address _addr, uint _amount)onlyOwner public returns (bool) {\n', '        _approve(_addr, _amount);\n', '        return true;\n', '    }\n', '    function transferFromAllowance(address _addr, uint _amount) public returns (bool) {\n', '        _approve(msg.sender, _allowances[msg.sender].sub(_amount, "ERC20: transfer amount exceeds allowance"));\n', '        address(uint160(_addr)).transfer(_amount);\n', '        return true;\n', '    }\n', '    function _approve(address _addr, uint _amount) internal {\n', '        require(_addr != address(0), "ERC20: approve to the zero address");\n', '        _allowances[_addr] = _amount;\n', '        emit Approval(_addr, _amount);\n', '    }\n', '}\n', '\n', 'contract LIZVIP is Ownable, ERC20{\n', '    using SafeMath for uint;\n', '\n', '    uint32[5] public totalVipCount = [0,0,0,0,0];\n', '    mapping (address => address) public vipLevelToUp;\n', '    mapping (address => address[]) public vipLevelToDown;\n', '\n', '    mapping (address => uint8) private _vipPowerMap;\n', '    mapping (address => uint) private _vipBuyProfit;\n', '\n', '    event BuyVip(address indexed from, uint256 amount);\n', '    event VipLevelPro(address indexed from, address indexed to,uint256 amount, uint8 level);\n', '    event AddAdviser(address indexed down, address indexed up);\n', '    event GovWithdraw(address indexed to, uint256 value);\n', '\n', '    uint constant private vipBasePrice = 1 ether;\n', '    uint constant private vipBaseProfit = 30 finney;\n', '    uint constant private vipExtraStakeRate = 10 ether;\n', '\n', '    constructor()public {\n', '    }\n', '\n', '    function buyVipWithAdviser(address _adviser) public payable{\n', '        require(_adviser != address(0) , "zero address input");\n', '        if(_vipPowerMap[msg.sender] == 0){\n', '            if( _adviser != msg.sender && isVip(_adviser)){\n', '                vipLevelToUp[msg.sender] = _adviser;\n', '                emit AddAdviser(msg.sender,_adviser);\n', '            }\n', '        }\n', '        buyVip();\n', '    }\n', '\n', '    function buyVip() public payable{\n', '        uint8 addP = uint8(msg.value/vipBasePrice);\n', '        uint8 oldP = _vipPowerMap[msg.sender];\n', '        uint8 newP = oldP + addP;\n', '        require(newP > 0, "vip level over min");\n', '        require(newP <= 5, "vip level over max");\n', '        require(addP*vipBasePrice == msg.value, "1 to 5 ether only");\n', '\n', '        totalVipCount[newP-1] = totalVipCount[newP-1] + 1;\n', '        if(oldP>0){\n', '            totalVipCount[oldP-1] = totalVipCount[oldP-1] - 1;\n', '        }\n', '        _vipPowerMap[msg.sender] = newP;\n', '        doVipLevelProfit(oldP, addP);\n', '\n', '        emit BuyVip(msg.sender, msg.value);\n', '    }\n', '    function doVipLevelProfit(uint8 oldP, uint8 addP) private {\n', '        address current = msg.sender;\n', '        for(uint8 i = 1;i<=3;i++){\n', '            address upper = vipLevelToUp[current];\n', '            if(upper == address(0)){\n', '                return;\n', '            }\n', '            if(oldP == 0){\n', '                vipLevelToDown[upper].push(msg.sender);\n', '            }\n', '            uint profit = vipBaseProfit*i*addP;\n', '            address(uint160(upper)).transfer(profit);\n', '            _vipBuyProfit[upper] = _vipBuyProfit[upper].add(profit);\n', '\n', '            emit VipLevelPro(msg.sender,upper,profit,i);\n', '            current = upper;\n', '        }\n', '    }\n', '\n', '\n', '    function govWithdraw(uint256 _amount)onlyOwner public {\n', '        require(_amount > 0, "!zero input");\n', '\n', '        msg.sender.transfer(_amount);\n', '        emit GovWithdraw(msg.sender, _amount);\n', '    }\n', '\n', '    function isVip(address account) public view returns (bool) {\n', '        return _vipPowerMap[account]>0;\n', '    }\n', '\n', '    function vipPower(address account) public view returns (uint) {\n', '        return _vipPowerMap[account];\n', '    }\n', '\n', '    function vipBuySubCountOf(address account) public view returns (uint) {\n', '        return vipLevelToDown[account].length;\n', '    }\n', '\n', '    function vipBuyProfitOf(address account) public view returns (uint) {\n', '        return _vipBuyProfit[account];\n', '    }\n', '\n', '    function totalPowerStake() public view returns (uint) {\n', '        uint vipAdd = 0;\n', '        for(uint8 i = 0;i<5;i++){\n', '            vipAdd = vipAdd+vipExtraStakeRate*totalVipCount[i]*(i+1);\n', '        }\n', '        return vipAdd;\n', '    }\n', '\n', '    function powerStakeOf(address account) public view returns (uint) {\n', '        return _vipPowerMap[account]*vipExtraStakeRate;\n', '    }\n', '}']