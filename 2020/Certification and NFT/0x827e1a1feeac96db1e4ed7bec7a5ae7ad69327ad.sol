['// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'abstract contract Ownable {\n', '  address s_owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    s_owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == s_owner, "Ownable: not owner");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner virtual {\n', '    require(newOwner != address(0), "Ownable: 0 cannot be owner");\n', '    emit OwnershipTransferred(s_owner, newOwner);\n', '    s_owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'abstract contract Claimable is Ownable {\n', '  address s_pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == s_pendingOwner, "Claimable: not pending owner");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner override {\n', '    s_pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() public onlyPendingOwner {\n', '    emit OwnershipTransferred(s_owner, s_pendingOwner);\n', '    s_owner = s_pendingOwner;\n', '    s_pendingOwner = address(0);\n', '  }\n', '}\n', '\n', 'struct Account {\n', '    uint256 nonce;  \n', '    uint256 balance;\n', '    uint256 issueBlock;\n', '    uint256 pending;\n', '    uint256 withdrawal;\n', '    uint256 releaseBlock;\n', '    bytes32 secretHash;\n', '}\n', '\n', 'library AccountUtils {\n', '    using SafeMath for uint256;\n', '\n', '    function initNonce(Account storage self) internal {\n', '        if (self.nonce == 0) {\n', '            self.nonce =\n', '                uint256(1) << 240 |\n', '                uint256(blockhash(block.number-1)) << 80 >> 32 |\n', '                now;\n', '        }\n', '    }\n', '\n', '    function updateNonce(Account storage self) internal {\n', '        uint256 count = self.nonce >> 240;\n', '        uint256 nonce = \n', '            ++count << 240 |\n', '            uint256(blockhash(block.number-1)) << 80 >> 32 |\n', '            now;\n', '        require(uint16(self.nonce) != uint16(nonce), "Pool: too soon");\n', '        self.nonce = nonce;\n', '    }\n', '    \n', '    function acceptPending(Account storage self, uint256 value) internal {\n', '        uint256 pending = self.pending;\n', '        require(pending > 0, "Pool: no pending tokens");\n', '        require(pending == value, "Pool: value must equal issued tokens");\n', '        self.secretHash = 0;\n', '        self.pending = 0;\n', '        self.balance = self.balance.add(pending);\n', '    }\n', '\n', '    function take(Account storage self, uint256 value) internal {\n', '        self.balance = self.balance.add(value);\n', '    }\n', '\n', '    function payment(Account storage self, uint256 value) internal {\n', '        self.balance = self.balance.sub(value);\n', '    }\n', '\n', '    function deposit(Account storage self, uint256 value) internal {\n', '        self.balance = self.balance.add(value);\n', '    }\n', '\n', '    function withdraw(Account storage self, uint256 value) internal {\n', '        self.withdrawal = 0;\n', '        self.releaseBlock = 0;\n', '        self.balance = self.balance.sub(value);\n', '    }\n', '}\n', '\n', 'struct Supply {\n', '    uint256 total;\n', '    uint256 minimum;\n', '    uint256 pending;\n', '}\n', '\n', 'library SupplyUtils {\n', '    using SafeMath for uint256;\n', '\n', '    // event MinimumReached(uint256 before, uint256 delta);\n', '\n', '    modifier checkAvailability(Supply storage self) {\n', '        _;\n', '        require(self.total >= self.minimum.add(self.pending), "Pool: not enough available tokens");\n', '    }\n', '\n', '    // modifier safeReduceMinimum(Supply storage self, uint256 value) {\n', '    //     self.minimum > value ? self.minimum -= value : self.minimum = 0; \n', '    //     if (self.minimum == 0) {\n', '    //       emit MinimumReached(self.minimum, value);\n', '    //     }\n', '    //     _;\n', '    // }\n', '\n', '    function updatePending(Supply storage self, uint256 from, uint256 to) internal checkAvailability(self) { \n', '        self.pending = self.pending.add(to).sub(from, "Pool: not enough available tokens");       \n', '    }\n', '\n', '    function acceptPending(Supply storage self, uint256 value) internal {\n', '        self.pending = self.pending.sub(value, "Pool: not enough pending");\n', '        self.minimum = self.minimum.add(value);\n', '    }\n', '\n', '    function give(Supply storage self, uint256 value) internal checkAvailability(self) {\n', '        self.minimum = self.minimum.add(value);\n', '    }\n', '\n', '    function payment(Supply storage self, uint256 value) internal /*safeReduceMinimum(self, value)*/ {\n', '        self.minimum = self.minimum.sub(value); // this line should be remove if using safeReduceMinimum modifier\n', '    }\n', '\n', '    function deposit(Supply storage self, uint256 value) internal {\n', '        self.minimum = self.minimum.add(value);\n', '        self.total = self.total.add(value);\n', '    }\n', '\n', '    function widthdraw(Supply storage self, uint256 value) internal /*safeReduceMinimum(self, value)*/ checkAvailability(self) {\n', '        self.minimum = self.minimum.sub(value); // this line should be remove if using safeReduceMinimum modifier\n', '        self.total = self.total.sub(value);\n', '    }\n', '\n', '    function decrease(Supply storage self, uint256 value) internal checkAvailability(self) {\n', '        self.total = self.total.sub(value, "Pool: value larger than total");\n', '    }\n', '\n', '    function update(Supply storage self, uint256 value) internal checkAvailability(self) {\n', '        self.total = value;\n', '    }\n', '\n', '    function available(Supply storage self) internal view returns (uint256) {\n', '        return self.total.sub(self.minimum.add(self.pending));\n', '    }\n', '}\n', '\n', 'struct Limits {\n', '    uint256 releaseDelay;\n', '    uint256 maxTokensPerIssue;\n', '    uint256 maxTokensPerBlock;\n', '}\n', '\n', 'struct Entities {\n', '    address manager;\n', '    address token;\n', '    address wallet;\n', '}\n', '\n', 'contract Pool is Claimable {\n', '    using AccountUtils for Account;\n', '    using SupplyUtils for Supply;\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    bytes32 private s_uid;\n', '    Supply private s_supply;\n', '    Limits private s_limits;\n', '    Entities private s_entities;\n', '    uint256 private s_lastIssuedBlock;\n', '    uint256 private s_totalIssuedInBlock;\n', '\n', '    mapping(address => Account) private s_accounts;\n', '\n', '    uint8 public constant VERSION_NUMBER = 0x1;\n', '    uint256 public constant MAX_RELEASE_DELAY = 11_520; // about 48h\n', '    string public constant NAME = "Kirobo Pool";\n', '    string public constant VERSION = "1";\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '    bytes public DOMAIN_SEPARATOR_ASCII;\n', '    uint256 public CHAIN_ID;\n', '\n', '    // keccak256("acceptTokens(address recipient,uint256 value,bytes32 secretHash)");\n', '    bytes32 public constant ACCEPT_TYPEHASH = 0xf728cfc064674dacd2ced2a03acd588dfd299d5e4716726c6d5ec364d16406eb;\n', '\n', '    // keccak256("payment(address from,uint256 value,uint256 nonce)");\n', '    bytes32 public constant PAYMENT_TYPEHASH = 0x841d82f71fa4558203bb763733f6b3326ecaf324143e12fb9b6a9ed958fc4ee0;\n', '\n', '    // keccak256("buyTokens(address recipient,uint256 eth,uint256 kiro,uint256 expires)");\n', '    bytes32 public constant BUY_TYPEHASH = 0x866880cdfbc2380b3f4581d70707601f3d190bc04c3ee9cfcdac070a5f87b758;\n', '\n', '    event TokensIssued(address indexed account, uint256 value, bytes32 secretHash);\n', '    event TokensAccepted(address indexed account, bool directCall);\n', '    event TokensDistributed(address indexed account, uint256 value);\n', '    event Payment(address indexed account, uint256 value);\n', '    event Deposit(address indexed account, uint256 value);\n', '    event WithdrawalRequested(address indexed account, uint256 value);\n', '    event WithdrawalCanceled(address indexed account);\n', '    event Withdrawal(address indexed account, uint256 value);\n', '    event EtherTransfered(address indexed to, uint256 value);\n', '    event TokensTransfered(address indexed to, uint256 value);\n', '    event ManagerChanged(address from, address to);\n', '    event WalletChanged(address from, address to);\n', '    event ReleaseDelayChanged(uint256 from, uint256 to);\n', '    event MaxTokensPerIssueChanged(uint256 from, uint256 to);\n', '    event MaxTokensPerBlockChanged(uint256 from, uint256 to);\n', '\n', '    modifier onlyAdmins() {\n', '        require(msg.sender == s_owner || msg.sender == s_entities.manager, "Pool: not owner or manager");\n', '        _;\n', '    }\n', '\n', '    constructor(address tokenContract) public {\n', '        uint256 chainId;\n', '        assembly {\n', '            chainId := chainid()\n', '        }\n', '     \n', '        s_entities.token = tokenContract;\n', '        s_limits = Limits({releaseDelay: 240, maxTokensPerIssue: 10*1000*(10**18), maxTokensPerBlock: 50*1000*(10**18)});\n', '        s_uid = bytes32(\n', '          uint256(VERSION_NUMBER) << 248 |\n', '          uint256(blockhash(block.number-1)) << 192 >> 16 |\n', '          uint256(address(this))\n', '        );\n', '\n', '        CHAIN_ID = chainId;\n', '\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', '                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)"),\n', '                keccak256(bytes(NAME)),\n', '                keccak256(bytes(VERSION)),\n', '                chainId,\n', '                address(this),\n', '                s_uid\n', '            )\n', '        );\n', '        DOMAIN_SEPARATOR_ASCII = _hashToAscii(\n', '            DOMAIN_SEPARATOR\n', '        );\n', '    }\n', '\n', '    receive () external payable {\n', '        require(false, "Pool: not accepting ether");\n', '    }\n', '\n', '\n', '    // ----------- Owner Functions ------------\n', '\n', '\n', '    function setManager(address manager) external onlyOwner() {\n', '        require(manager != address(this), "Pool: self cannot be mananger");\n', '        require(manager != s_entities.token, "Pool: token cannot be manager");\n', '        emit ManagerChanged(s_entities.manager, manager);\n', '        s_entities.manager = manager;\n', '    }\n', '\n', '    function setWallet(address wallet) external onlyOwner() {\n', '        require(wallet != address(this), "Pool: self cannot be wallet");\n', '        require(wallet != s_entities.token, "Pool: token cannot be wallt");\n', '        emit WalletChanged(s_entities.wallet, wallet);\n', '        s_entities.wallet = wallet;\n', '    }\n', '\n', '    function setReleaseDelay(uint256 blocks) external onlyOwner() {\n', '        require(blocks <= MAX_RELEASE_DELAY, "Pool: exeeds max release delay");\n', '        emit ReleaseDelayChanged(s_limits.releaseDelay, blocks);\n', '        s_limits.releaseDelay = blocks;\n', '    }\n', '\n', '    function setMaxTokensPerIssue(uint256 tokens) external onlyOwner() {\n', '        emit MaxTokensPerIssueChanged(s_limits.maxTokensPerIssue, tokens);\n', '        s_limits.maxTokensPerIssue = tokens;\n', '    }\n', '\n', '    function setMaxTokensPerBlock(uint256 tokens) external onlyOwner() {\n', '        emit MaxTokensPerBlockChanged(s_limits.maxTokensPerBlock, tokens);\n', '        s_limits.maxTokensPerBlock = tokens;\n', '    }\n', '\n', '    function resyncTotalSupply(uint256 value) external onlyAdmins() returns (uint256) {\n', '        uint256 tokens = ownedTokens();\n', '        require(tokens >= s_supply.total, "Pool: internal error, check contract logic"); \n', '        require(value >= s_supply.total, "Pool: only transferTokens can decrease total supply");\n', '        require(value <= tokens, "Pool: not enough tokens");\n', '        s_supply.update(value);\n', '    }\n', '\n', '\n', '    // ----------- Admins Functions ------------\n', '\n', '\n', '    function transferEther(uint256 value) external onlyAdmins() {\n', '        require(s_entities.wallet != address(0), "Pool: wallet not set");\n', '        payable(s_entities.wallet).transfer(value);\n', '        emit EtherTransfered(s_entities.wallet, value);\n', '    }\n', '\n', '    function transferTokens(uint256 value) external onlyAdmins() {\n', '        require(s_entities.wallet != address(0), "Pool: wallet not set");\n', '        s_supply.decrease(value);\n', '        IERC20(s_entities.token).safeTransfer(s_entities.wallet, value);\n', '        emit TokensTransfered(s_entities.wallet, value);\n', '    }\n', '\n', '    function distributeTokens(address to, uint256 value) external onlyAdmins() {\n', '        _distributeTokens(to, value);\n', '    }\n', '    \n', '    function _distributeTokens(address to, uint256 value) private {\n', '        require(value <= s_limits.maxTokensPerIssue, "Pool: exeeds max tokens per call");\n', '        require(s_accounts[to].issueBlock < block.number, "Pool: too soon");\n', '        _validateTokensPerBlock(value);\n', '        Account storage sp_account = s_accounts[to];\n', '        sp_account.issueBlock = block.number;\n', '        sp_account.initNonce();\n', '        s_supply.give(value);\n', '        sp_account.take(value);\n', '        emit TokensDistributed(to, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Issueing tokens for an address to be used for payments.\n', '     * The owner of the receiving address must accept via a signed message or a direct call.\n', '     * @param to The tokens recipient. \n', '     * @param value The number of tokens to issue.\n', '     * @param secretHash The keccak256 of the confirmation secret.\n', '    */\n', '    function issueTokens(address to, uint256 value, bytes32 secretHash) external onlyAdmins() {\n', '        require(value <= s_limits.maxTokensPerIssue, "Pool: exeeds max tokens per call");\n', '        _validateTokensPerBlock(value);\n', '        Account storage sp_account = s_accounts[to];\n', '        uint256 prevPending = sp_account.pending;\n', '        sp_account.initNonce();\n', '        sp_account.secretHash = secretHash;\n', '        sp_account.pending = value;\n', '        sp_account.issueBlock = block.number;\n', '        s_supply.updatePending(prevPending, value);\n', '        emit TokensIssued(to, value, secretHash);\n', '    }\n', '\n', '    function executeAcceptTokens(\n', '        address recipient,\n', '        uint256 value,\n', '        bytes calldata c_secret,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        bool eip712\n', '    )\n', '        external \n', '        onlyAdmins()\n', '    {\n', '        require(s_accounts[recipient].secretHash == keccak256(c_secret), "Pool: wrong secret");\n', '        require(\n', '            validateAcceptTokens(recipient, value, keccak256(c_secret), v, r ,s, eip712),\n', '            "Pool: wrong signature or data"\n', '        );\n', '        _acceptTokens(recipient, value);\n', '        emit TokensAccepted(recipient, false);\n', '    }\n', '\n', '    function executePayment(address from, uint256 value, uint8 v, bytes32 r, bytes32 s, bool eip712)\n', '        external\n', '        onlyAdmins()\n', '    {\n', '        require(validatePayment(from, value, v, r, s, eip712), "Pool: wrong signature or data");\n', '        Account storage sp_account = s_accounts[from];\n', '        sp_account.updateNonce();\n', '        sp_account.payment(value);\n', '        s_supply.payment(value);\n', '        emit Payment(from, value);\n', '    }\n', '  \n', '\n', '    // ----------- External Functions ------------\n', '\n', '\n', '    function executeBuyTokens(uint256 kiro, uint256 expires, uint8 v, bytes32 r, bytes32 s, bool eip712) \n', '        external\n', '        payable\n', '    {\n', '        require(validateBuyTokens(msg.sender, msg.value, kiro, expires, v, r, s, eip712), "Pool: wrong signature or data");\n', '        require(now <= expires, "Pool: too late");\n', '        _distributeTokens(msg.sender, kiro);\n', '    }\n', '\n', '    function acceptTokens(uint256 value, bytes calldata c_secret) external {\n', '        require(s_accounts[msg.sender].secretHash == keccak256(c_secret), "Pool: wrong secret");\n', '        _acceptTokens(msg.sender, value);\n', '        emit TokensAccepted(msg.sender, true);\n', '    }\n', '\n', '    function depositTokens(uint256 value) external {\n', '        // require(\n', '        //     IERC20(s_entities.token).allowance(msg.sender, address(this)) >= value,\n', '        //    "IERC20 allowance too low"\n', '        // );\n', '        Account storage sp_account = s_accounts[msg.sender]; \n', '        sp_account.initNonce();\n', '        sp_account.deposit(value);\n', '        s_supply.deposit(value);\n', '        IERC20(s_entities.token).safeTransferFrom(msg.sender, address(this), value);\n', '        emit Deposit(msg.sender, value);\n', '    }\n', '\n', '    function requestWithdrawal(uint256 value) external {\n', '        require(s_accounts[msg.sender].balance >= value, "Pool: not enough tokens");\n', '        require(value > 0, "Pool: withdrawal value must be larger then 0");\n', '        s_accounts[msg.sender].withdrawal = value;\n', '        s_accounts[msg.sender].releaseBlock = block.number + s_limits.releaseDelay;\n', '        emit WithdrawalRequested(msg.sender, value);\n', '    }\n', '\n', '    function cancelWithdrawal() external {\n', '        s_accounts[msg.sender].withdrawal = 0;\n', '        s_accounts[msg.sender].releaseBlock = 0;\n', '        emit WithdrawalCanceled(msg.sender);\n', '    }\n', '\n', '    function withdrawTokens() external {\n', '        Account storage sp_account = s_accounts[msg.sender];   \n', '        require(sp_account.withdrawal > 0, "Pool: no withdraw request");\n', '        require(sp_account.releaseBlock <= block.number, "Pool: too soon");\n', '        uint256 value = sp_account.withdrawal > sp_account.balance ? sp_account.balance : sp_account.withdrawal;\n', '        sp_account.withdraw(value);\n', '        s_supply.widthdraw(value);\n', '        IERC20(s_entities.token).safeTransfer(msg.sender, value);\n', '        emit Withdrawal(msg.sender, value);\n', '    }\n', '\n', '    function account(address addr) external view\n', '        returns (\n', '            uint256 nonce,  \n', '            uint256 balance,\n', '            uint256 issueBlock,\n', '            uint256 pending,\n', '            uint256 withdrawal,\n', '            uint256 releaseBlock,\n', '            bytes32 secretHash,\n', '            uint256 externalBalance\n', '        ) \n', '    {\n', '        Account storage sp_account = s_accounts[addr];\n', '        uint256 extBalance = IERC20(s_entities.token).balanceOf(addr);\n', '        return (\n', '            sp_account.nonce,\n', '            sp_account.balance,\n', '            sp_account.issueBlock,\n', '            sp_account.pending,\n', '            sp_account.withdrawal,\n', '            sp_account.releaseBlock,\n', '            sp_account.secretHash,\n', '            extBalance\n', '        );\n', '    }\n', '\n', '    function entities() view external\n', '        returns (\n', '            address manager,\n', '            address token,\n', '            address wallet\n', '        )\n', '    {\n', '        return (\n', '            s_entities.manager,\n', '            s_entities.token,\n', '            s_entities.wallet\n', '        );\n', '    }\n', '\n', '    function limits() external view\n', '        returns (\n', '            uint256 releaseDelay, \n', '            uint256 maxTokensPerIssue,\n', '            uint256 maxTokensPerBlock\n', '        )\n', '    {\n', '        return (\n', '            s_limits.releaseDelay,\n', '            s_limits.maxTokensPerIssue,\n', '            s_limits.maxTokensPerBlock\n', '        );\n', '    }\n', '\n', '    function supply() view external \n', '        returns (\n', '            uint256 total,\n', '            uint256 minimum,\n', '            uint256 pending,\n', '            uint256 available\n', '        ) \n', '    {\n', '        return (\n', '            s_supply.total,\n', '            s_supply.minimum,\n', '            s_supply.pending,\n', '            s_supply.available()\n', '        );\n', '    }\n', '\n', '    function uid() view external returns (bytes32) {\n', '        return s_uid;\n', '    }\n', '\n', '    function totalSupply() view external returns (uint256) {\n', '        return s_supply.total;\n', '    }\n', '\n', '    function availableSupply() view external returns (uint256) {\n', '        return s_supply.available();\n', '    }\n', '\n', '\n', '    // ----------- Public Functions ------------\n', '\n', '\n', '    function generateBuyTokensMessage(address recipient, uint256 eth, uint256 kiro, uint256 expires)\n', '        public view\n', '        returns (bytes memory)\n', '    {\n', '        Account storage sp_account = s_accounts[recipient]; \n', '    \n', '        return abi.encode(\n', '            BUY_TYPEHASH,\n', '            recipient,\n', '            eth,\n', '            kiro,\n', '            expires,\n', '            sp_account.issueBlock\n', '        );\n', '    }\n', '\n', '    function generateAcceptTokensMessage(address recipient, uint256 value, bytes32 secretHash)\n', '        public view \n', '        returns (bytes memory)\n', '    {\n', '        require(s_accounts[recipient].secretHash == secretHash, "Pool: wrong secret hash");\n', '        require(s_accounts[recipient].pending == value, "Pool: value must equal pending(issued tokens)");\n', '            \n', '        return abi.encode(\n', '            ACCEPT_TYPEHASH,\n', '            recipient,\n', '            value,\n', '            secretHash\n', '        );\n', '    }\n', '\n', '    function generatePaymentMessage(address from, uint256 value)\n', '        public view\n', '        returns (bytes memory)\n', '    {\n', '        Account storage sp_account = s_accounts[from]; \n', '        require(sp_account.balance >= value, "Pool: account balnace too low");\n', '        \n', '        return abi.encode(\n', '            PAYMENT_TYPEHASH,\n', '            from,\n', '            value,\n', '            sp_account.nonce\n', '        );\n', '    }\n', '\n', '    function validateBuyTokens(\n', '        address from,\n', '        uint256 eth,\n', '        uint256 kiro,\n', '        uint256 expires,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        bool eip712\n', '    )\n', '        public view \n', '        returns (bool)\n', '    {\n', '        bytes32 message = _messageToRecover(\n', '            keccak256(generateBuyTokensMessage(from, eth, kiro, expires)),\n', '            eip712\n', '        );\n', '        address addr = ecrecover(message, v, r, s);\n', '        return addr == s_entities.manager;      \n', '    }\n', '\n', '    function validateAcceptTokens(\n', '        address recipient,\n', '        uint256 value,\n', '        bytes32 secretHash,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        bool eip712\n', '    )\n', '        public view \n', '        returns (bool)\n', '    {\n', '        bytes32 message = _messageToRecover(\n', '            keccak256(generateAcceptTokensMessage(recipient, value, secretHash)),\n', '            eip712\n', '        );\n', '        address addr = ecrecover(message, v, r, s);\n', '        return addr == recipient;\n', '    }\n', '\n', '    function validatePayment(address from, uint256 value, uint8 v, bytes32 r, bytes32 s, bool eip712)\n', '        public view \n', '        returns (bool)\n', '    {\n', '        bytes32 message = _messageToRecover(\n', '            keccak256(generatePaymentMessage(from, value)),\n', '            eip712\n', '        );\n', '        address addr = ecrecover(message, v, r, s);\n', '        return addr == from;      \n', '    }\n', '\n', '    function ownedTokens() view public returns (uint256) {\n', '        return IERC20(s_entities.token).balanceOf(address(this));\n', '    }\n', '\n', '\n', '    // ----------- Private Functions ------------\n', '\n', '\n', '    function _validateTokensPerBlock(uint256 value) private {\n', '        if (s_lastIssuedBlock < block.number) {\n', '            s_lastIssuedBlock = block.number;\n', '            s_totalIssuedInBlock = value;\n', '        } else {\n', '            s_totalIssuedInBlock.add(value);\n', '        }\n', '        require(s_totalIssuedInBlock <= s_limits.maxTokensPerBlock, "Pool: exeeds max tokens per block");\n', '    }\n', '\n', '    function _acceptTokens(address recipient, uint256 value) private {\n', '        require(s_accounts[recipient].issueBlock < block.number, "Pool: too soon");\n', '        s_accounts[recipient].acceptPending(value);\n', '        s_supply.acceptPending(value);\n', '    }\n', '\n', '    function _messageToRecover(bytes32 hashedUnsignedMessage, bool eip712)\n', '        private view \n', '        returns (bytes32)\n', '    {\n', '        if (eip712) {\n', '            return keccak256(abi.encodePacked\n', '            (\n', '                "\\x19\\x01",\n', '                DOMAIN_SEPARATOR,\n', '                hashedUnsignedMessage\n', '            ));\n', '        }\n', '        return keccak256(abi.encodePacked\n', '        (\n', '            "\\x19Ethereum Signed Message:\\n128",\n', '            DOMAIN_SEPARATOR_ASCII,\n', '            _hashToAscii(hashedUnsignedMessage)\n', '        ));\n', '    }\n', '\n', '    function _hashToAscii(bytes32 hash) private pure returns (bytes memory) {\n', '        bytes memory s = new bytes(64);\n', '        for (uint i = 0; i < 32; i++) {\n', '            byte  b = hash[i];\n', '            byte hi = byte(uint8(b) / 16);\n', '            byte lo = byte(uint8(b) - 16 * uint8(hi));\n', '            s[2*i] = _char(hi);\n', '            s[2*i+1] = _char(lo);\n', '        }\n', '        return s;\n', '    }\n', '\n', '    function _char(byte b) private pure returns (byte c) {\n', '        if (b < byte(uint8(10))) {\n', '            return byte(uint8(b) + 0x30);\n', '        } else {\n', '            return byte(uint8(b) + 0x57);\n', '        }\n', '    }\n', '\n', '}']