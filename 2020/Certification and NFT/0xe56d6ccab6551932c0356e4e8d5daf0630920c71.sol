['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2017 Loopring Technology Limited.\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/// @title Ownable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable\n', '{\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      new owner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership()\n', '        public\n', '        onlyOwner\n', '    {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title Claimable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable\n', '{\n', '    address public pendingOwner;\n', '\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0) && newOwner != owner, "INVALID_ADDRESS");\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        public\n', '        onlyPendingOwner\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library MathUint\n', '{\n', '    using MathUint for uint;\n', '\n', '    function mul(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b, "MUL_OVERFLOW");\n', '    }\n', '\n', '    function sub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        require(b <= a, "SUB_UNDERFLOW");\n', '        return a - b;\n', '    }\n', '\n', '    function add(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '\n', '    function add64(\n', '        uint64 a,\n', '        uint64 b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint64 c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Utility Functions for addresses\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library AddressUtil\n', '{\n', '    using AddressUtil for *;\n', '\n', '    function isContract(\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(addr) }\n', '        return (codehash != 0x0 &&\n', '                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n', '    }\n', '\n', '    function toPayable(\n', '        address addr\n', '        )\n', '        internal\n', '        pure\n', '        returns (address payable)\n', '    {\n', '        return payable(addr);\n', '    }\n', '\n', '    // Works like address.send but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETH(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        if (amount == 0) {\n', '            return true;\n', '        }\n', '        address payable recipient = to.toPayable();\n', '        /* solium-disable-next-line */\n', '        (success, ) = recipient.call{value: amount, gas: gasLimit}("");\n', '    }\n', '\n', '    // Works like address.transfer but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETHAndVerify(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        success = to.sendETH(amount, gasLimit);\n', '        require(success, "TRANSFER_FAILURE");\n', '    }\n', '\n', '    // Works like call but is slightly more efficient when data\n', '    // needs to be copied from memory to do the call.\n', '    function fastCall(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bool success, bytes memory returnData)\n', '    {\n', '        if (to != address(0)) {\n', '            assembly {\n', '                // Do the call\n', '                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\n', '                // Copy the return data\n', '                let size := returndatasize()\n', '                returnData := mload(0x40)\n', '                mstore(returnData, size)\n', '                returndatacopy(add(returnData, 32), 0, size)\n', '                // Update free memory pointer\n', '                mstore(0x40, add(returnData, add(32, size)))\n', '            }\n', '        }\n', '    }\n', '\n', '    // Like fastCall, but throws when the call is unsuccessful.\n', '    function fastCallAndVerify(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bytes memory returnData)\n', '    {\n', '        bool success;\n', '        (success, returnData) = fastCall(to, gasLimit, value, data);\n', '        if (!success) {\n', '            assembly {\n', '                revert(add(returnData, 32), mload(returnData))\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ERC20 safe transfer\n', '/// @dev see https://github.com/sec-bit/badERC20Fix\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library ERC20SafeTransfer\n', '{\n', '    function safeTransferAndVerify(\n', '        address token,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '    {\n', '        safeTransferWithGasLimitAndVerify(\n', '            token,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return safeTransferWithGasLimit(\n', '            token,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferWithGasLimitAndVerify(\n', '        address token,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '    {\n', '        require(\n', '            safeTransferWithGasLimit(token, to, value, gasLimit),\n', '            "TRANSFER_FAILURE"\n', '        );\n', '    }\n', '\n', '    function safeTransferWithGasLimit(\n', '        address token,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', "        // A transfer is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transfer(address,uint256)")) = 0xa9059cbb\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            bytes4(0xa9059cbb),\n', '            to,\n', '            value\n', '        );\n', '        (bool success, ) = token.call{gas: gasLimit}(callData);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function safeTransferFromAndVerify(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '    {\n', '        safeTransferFromWithGasLimitAndVerify(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return safeTransferFromWithGasLimit(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferFromWithGasLimitAndVerify(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '    {\n', '        bool result = safeTransferFromWithGasLimit(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasLimit\n', '        );\n', '        require(result, "TRANSFER_FAILURE");\n', '    }\n', '\n', '    function safeTransferFromWithGasLimit(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', "        // A transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transferFrom(address,address,uint256)")) = 0x23b872dd\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            bytes4(0x23b872dd),\n', '            from,\n', '            to,\n', '            value\n', '        );\n', '        (bool success, ) = token.call{gas: gasLimit}(callData);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function checkReturnValue(\n', '        bool success\n', '        )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', "        // A transfer/transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '        if (success) {\n', '            assembly {\n', '                switch returndatasize()\n', "                // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded\n", '                case 0 {\n', '                    success := 1\n', '                }\n', '                // Standard ERC20: a single boolean value is returned which needs to be true\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    success := mload(0)\n', '                }\n', '                // None of the above: not successful\n', '                default {\n', '                    success := 0\n', '                }\n', '            }\n', '        }\n', '        return success;\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ReentrancyGuard\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Exposes a modifier that guards a function against reentrancy\n', '///      Changing the value of the same storage value multiple times in a transaction\n', '///      is cheap (starting from Istanbul) so there is no need to minimize\n', '///      the number of times the value is changed\n', 'contract ReentrancyGuard\n', '{\n', '    //The default value must be 0 in order to work behind a proxy.\n', '    uint private _guardValue;\n', '\n', '    // Use this modifier on a function to prevent reentrancy\n', '    modifier nonReentrant()\n', '    {\n', '        // Check if the guard value has its original value\n', '        require(_guardValue == 0, "REENTRANCY");\n', '\n', '        // Set the value to something else\n', '        _guardValue = 1;\n', '\n', '        // Function body\n', '        _;\n', '\n', '        // Set the value back\n', '        _guardValue = 0;\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', 'interface IAgent{}\n', '\n', 'interface IAgentRegistry\n', '{\n', '    /// @dev Returns whether an agent address is an agent of an account owner\n', '    /// @param owner The account owner.\n', '    /// @param agent The agent address\n', '    /// @return True if the agent address is an agent for the account owner, else false\n', '    function isAgent(\n', '        address owner,\n', '        address agent\n', '        )\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Returns whether an agent address is an agent of all account owners\n', '    /// @param owners The account owners.\n', '    /// @param agent The agent address\n', '    /// @return True if the agent address is an agent for the account owner, else false\n', '    function isAgent(\n', '        address[] calldata owners,\n', '        address            agent\n', '        )\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title IBlockVerifier\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'abstract contract IBlockVerifier is Claimable\n', '{\n', '    // -- Events --\n', '\n', '    event CircuitRegistered(\n', '        uint8  indexed blockType,\n', '        uint16         blockSize,\n', '        uint8          blockVersion\n', '    );\n', '\n', '    event CircuitDisabled(\n', '        uint8  indexed blockType,\n', '        uint16         blockSize,\n', '        uint8          blockVersion\n', '    );\n', '\n', '    // -- Public functions --\n', '\n', '    /// @dev Sets the verifying key for the specified circuit.\n', '    ///      Every block permutation needs its own circuit and thus its own set of\n', '    ///      verification keys. Only a limited number of block sizes per block\n', '    ///      type are supported.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @param vk The verification key\n', '    function registerCircuit(\n', '        uint8    blockType,\n', '        uint16   blockSize,\n', '        uint8    blockVersion,\n', '        uint[18] calldata vk\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Disables the use of the specified circuit.\n', '    ///      This will stop NEW blocks from using the given circuit, blocks that were already committed\n', '    ///      can still be verified.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    function disableCircuit(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Verifies blocks with the given public data and proofs.\n', '    ///      Verifying a block makes sure all requests handled in the block\n', '    ///      are correctly handled by the operator.\n', '    /// @param blockType The type of block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @param publicInputs The hash of all the public data of the blocks\n', '    /// @param proofs The ZK proofs proving that the blocks are correct\n', '    /// @return True if the block is valid, false otherwise\n', '    function verifyProofs(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion,\n', '        uint[] calldata publicInputs,\n', '        uint[] calldata proofs\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Checks if a circuit with the specified parameters is registered.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @return True if the circuit is registered, false otherwise\n', '    function isCircuitRegistered(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Checks if a circuit can still be used to commit new blocks.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @return True if the circuit is enabled, false otherwise\n', '    function isCircuitEnabled(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title IDepositContract.\n', '/// @dev   Contract storing and transferring funds for an exchange.\n', '///\n', '///        ERC1155 tokens can be supported by registering pseudo token addresses calculated\n', '///        as `address(keccak256(real_token_address, token_params))`. Then the custom\n', '///        deposit contract can look up the real token address and paramsters with the\n', '///        pseudo token address before doing the transfers.\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'interface IDepositContract\n', '{\n', '    /// @dev Returns if a token is suppoprted by this contract.\n', '    function isTokenSupported(address token)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Transfers tokens from a user to the exchange. This function will\n', '    ///      be called when a user deposits funds to the exchange.\n', '    ///      In a simple implementation the funds are simply stored inside the\n', '    ///      deposit contract directly. More advanced implementations may store the funds\n', '    ///      in some DeFi application to earn interest, so this function could directly\n', '    ///      call the necessary functions to store the funds there.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', '    /// @param token The address of the token to transfer (`0x0` for ETH).\n', '    /// @param amount The amount of tokens to transfer.\n', '    /// @param extraData Opaque data that can be used by the contract to handle the deposit\n', "    /// @return amountReceived The amount to deposit to the user's account in the Merkle tree\n", '    function deposit(\n', '        address from,\n', '        address token,\n', '        uint96  amount,\n', '        bytes   calldata extraData\n', '        )\n', '        external\n', '        payable\n', '        returns (uint96 amountReceived);\n', '\n', '    /// @dev Transfers tokens from the exchange to a user. This function will\n', '    ///      be called when a withdrawal is done for a user on the exchange.\n', '    ///      In the simplest implementation the funds are simply stored inside the\n', '    ///      deposit contract directly so this simply transfers the requested tokens back\n', '    ///      to the user. More advanced implementations may store the funds\n', '    ///      in some DeFi application to earn interest so the function would\n', '    ///      need to get those tokens back from the DeFi application first before they\n', '    ///      can be transferred to the user.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', "    /// @param from The address from which 'amount' tokens are transferred.\n", "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (`0x0` for ETH).\n', '    /// @param amount The amount of tokens transferred.\n', '    /// @param extraData Opaque data that can be used by the contract to handle the withdrawal\n', '    function withdraw(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount,\n', '        bytes   calldata extraData\n', '        )\n', '        external\n', '        payable;\n', '\n', '    /// @dev Transfers tokens (ETH not supported) for a user using the allowance set\n', '    ///      for the exchange. This way the approval can be used for all functionality (and\n', '    ///      extended functionality) of the exchange.\n', '    ///      Should NOT be used to deposit/withdraw user funds, `deposit`/`withdraw`\n', '    ///      should be used for that as they will contain specialised logic for those operations.\n', '    ///      This function can be called by the exchange to transfer onchain funds of users\n', '    ///      necessary for Agent functionality.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (ETH is and cannot be suppported).\n', '    /// @param amount The amount of tokens transferred.\n', '    function transfer(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '        )\n', '        external\n', '        payable;\n', '\n', '    /// @dev Checks if the given address is used for depositing ETH or not.\n', '    ///      Is used while depositing to send the correct ETH amount to the deposit contract.\n', '    ///\n', '    ///      Note that 0x0 is always registered for deposting ETH when the exchange is created!\n', '    ///      This function allows additional addresses to be used for depositing ETH, the deposit\n', '    ///      contract can implement different behaviour based on the address value.\n', '    ///\n', '    /// @param addr The address to check\n', '    /// @return True if the address is used for depositing ETH, else false.\n', '    function isETH(address addr)\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '\n', '\n', '/// @title ExchangeData\n', '/// @dev All methods in this lib are internal, therefore, there is no need\n', '///      to deploy this library independently.\n', '/// @author Daniel Wang  - <daniel@loopring.org>\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library ExchangeData\n', '{\n', '    // -- Enums --\n', '    enum TransactionType\n', '    {\n', '        NOOP,\n', '        DEPOSIT,\n', '        WITHDRAWAL,\n', '        TRANSFER,\n', '        SPOT_TRADE,\n', '        ACCOUNT_UPDATE,\n', '        AMM_UPDATE\n', '    }\n', '\n', '    // -- Structs --\n', '    struct Token\n', '    {\n', '        address token;\n', '    }\n', '\n', '    struct ProtocolFeeData\n', '    {\n', '        uint32 syncedAt; // only valid before 2105 (85 years to go)\n', '        uint8  takerFeeBips;\n', '        uint8  makerFeeBips;\n', '        uint8  previousTakerFeeBips;\n', '        uint8  previousMakerFeeBips;\n', '    }\n', '\n', '    // General auxiliary data for each conditional transaction\n', '    struct AuxiliaryData\n', '    {\n', '        uint  txIndex;\n', '        bytes data;\n', '    }\n', '\n', '    // This is the (virtual) block the owner  needs to submit onchain to maintain the\n', '    // per-exchange (virtual) blockchain.\n', '    struct Block\n', '    {\n', '        uint8      blockType;\n', '        uint16     blockSize;\n', '        uint8      blockVersion;\n', '        bytes      data;\n', '        uint256[8] proof;\n', '\n', '        // Whether we should store the @BlockInfo for this block on-chain.\n', '        bool storeBlockInfoOnchain;\n', '\n', '        // Block specific data that is only used to help process the block on-chain.\n', '        // It is not used as input for the circuits and it is not necessary for data-availability.\n', '        AuxiliaryData[] auxiliaryData;\n', '\n', '        // Arbitrary data, mainly for off-chain data-availability, i.e.,\n', '        // the multihash of the IPFS file that contains the block data.\n', '        bytes offchainData;\n', '    }\n', '\n', '    struct BlockInfo\n', '    {\n', '        // The time the block was submitted on-chain.\n', '        uint32  timestamp;\n', '        // The public data hash of the block (the 28 most significant bytes).\n', '        bytes28 blockDataHash;\n', '    }\n', '\n', '    // Represents an onchain deposit request.\n', '    struct Deposit\n', '    {\n', '        uint96 amount;\n', '        uint64 timestamp;\n', '    }\n', '\n', '    // A forced withdrawal request.\n', "    // If the actual owner of the account initiated the request (we don't know who the owner is\n", '    // at the time the request is being made) the full balance will be withdrawn.\n', '    struct ForcedWithdrawal\n', '    {\n', '        address owner;\n', '        uint64  timestamp;\n', '    }\n', '\n', '    struct Constants\n', '    {\n', '        uint SNARK_SCALAR_FIELD;\n', '        uint MAX_OPEN_FORCED_REQUESTS;\n', '        uint MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE;\n', '        uint TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS;\n', '        uint MAX_NUM_ACCOUNTS;\n', '        uint MAX_NUM_TOKENS;\n', '        uint MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED;\n', '        uint MIN_TIME_IN_SHUTDOWN;\n', '        uint TX_DATA_AVAILABILITY_SIZE;\n', '        uint MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND;\n', '    }\n', '\n', '    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\n', '        // This is the prime number that is used for the alt_bn128 elliptic curve, see EIP-196.\n', '        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n', '    }\n', '    function MAX_OPEN_FORCED_REQUESTS() internal pure returns (uint16) { return 4096; }\n', '    function MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 15 days; }\n', '    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 7 days; }\n', '    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 32; }\n', '    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 16; }\n', '    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 7 days; }\n', '    function MIN_TIME_IN_SHUTDOWN() internal pure returns (uint32) { return 30 days; }\n', '    // The amount of bytes each rollup transaction uses in the block data for data-availability.\n', '    // This is the maximum amount of bytes of all different transaction types.\n', '    function TX_DATA_AVAILABILITY_SIZE() internal pure returns (uint32) { return 68; }\n', '    function MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND() internal pure returns (uint32) { return 15 days; }\n', '    function ACCOUNTID_PROTOCOLFEE() internal pure returns (uint32) { return 0; }\n', '\n', '    function TX_DATA_AVAILABILITY_SIZE_PART_1() internal pure returns (uint32) { return 29; }\n', '    function TX_DATA_AVAILABILITY_SIZE_PART_2() internal pure returns (uint32) { return 39; }\n', '\n', '    struct AccountLeaf\n', '    {\n', '        uint32   accountID;\n', '        address  owner;\n', '        uint     pubKeyX;\n', '        uint     pubKeyY;\n', '        uint32   nonce;\n', '        uint     feeBipsAMM;\n', '    }\n', '\n', '    struct BalanceLeaf\n', '    {\n', '        uint16   tokenID;\n', '        uint96   balance;\n', '        uint96   weightAMM;\n', '        uint     storageRoot;\n', '    }\n', '\n', '    struct MerkleProof\n', '    {\n', '        ExchangeData.AccountLeaf accountLeaf;\n', '        ExchangeData.BalanceLeaf balanceLeaf;\n', '        uint[48]                 accountMerkleProof;\n', '        uint[24]                 balanceMerkleProof;\n', '    }\n', '\n', '    struct BlockContext\n', '    {\n', '        bytes32 DOMAIN_SEPARATOR;\n', '        uint32  timestamp;\n', '    }\n', '\n', '    // Represents the entire exchange state except the owner of the exchange.\n', '    struct State\n', '    {\n', '        uint32  maxAgeDepositUntilWithdrawable;\n', '        bytes32 DOMAIN_SEPARATOR;\n', '\n', '        ILoopringV3      loopring;\n', '        IBlockVerifier   blockVerifier;\n', '        IAgentRegistry   agentRegistry;\n', '        IDepositContract depositContract;\n', '\n', '\n', '        // The merkle root of the offchain data stored in a Merkle tree. The Merkle tree\n', '        // stores balances for users using an account model.\n', '        bytes32 merkleRoot;\n', '\n', '        // List of all blocks\n', '        mapping(uint => BlockInfo) blocks;\n', '        uint  numBlocks;\n', '\n', '        // List of all tokens\n', '        Token[] tokens;\n', '\n', '        // A map from a token to its tokenID + 1\n', '        mapping (address => uint16) tokenToTokenId;\n', '\n', '        // A map from an accountID to a tokenID to if the balance is withdrawn\n', '        mapping (uint32 => mapping (uint16 => bool)) withdrawnInWithdrawMode;\n', '\n', '        // A map from an account to a token to the amount withdrawable for that account.\n', '        // This is only used when the automatic distribution of the withdrawal failed.\n', '        mapping (address => mapping (uint16 => uint)) amountWithdrawable;\n', '\n', '        // A map from an account to a token to the forced withdrawal (always full balance)\n', '        mapping (uint32 => mapping (uint16 => ForcedWithdrawal)) pendingForcedWithdrawals;\n', '\n', '        // A map from an address to a token to a deposit\n', '        mapping (address => mapping (uint16 => Deposit)) pendingDeposits;\n', '\n', '        // A map from an account owner to an approved transaction hash to if the transaction is approved or not\n', '        mapping (address => mapping (bytes32 => bool)) approvedTx;\n', '\n', '        // A map from an account owner to a destination address to a tokenID to an amount to a storageID to a new recipient address\n', '        mapping (address => mapping (address => mapping (uint16 => mapping (uint => mapping (uint32 => address))))) withdrawalRecipient;\n', '\n', '\n', '        // Counter to keep track of how many of forced requests are open so we can limit the work that needs to be done by the owner\n', '        uint32 numPendingForcedTransactions;\n', '\n', '        // Cached data for the protocol fee\n', '        ProtocolFeeData protocolFeeData;\n', '\n', '        // Time when the exchange was shutdown\n', '        uint shutdownModeStartTime;\n', '\n', '        // Time when the exchange has entered withdrawal mode\n', '        uint withdrawalModeStartTime;\n', '\n', '        // Last time the protocol fee was withdrawn for a specific token\n', '        mapping (address => uint) protocolFeeLastWithdrawnTime;\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title IExchangeV3\n', '/// @dev Note that Claimable and RentrancyGuard are inherited here to\n', '///      ensure all data members are declared on IExchangeV3 to make it\n', '///      easy to support upgradability through proxies.\n', '///\n', '///      Subclasses of this contract must NOT define constructor to\n', '///      initialize data.\n', '///\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @author Daniel Wang  - <daniel@loopring.org>\n', 'abstract contract IExchangeV3 is Claimable\n', '{\n', '    // -- Events --\n', '\n', '    event ExchangeCloned(\n', '        address exchangeAddress,\n', '        address owner,\n', '        bytes32 genesisMerkleRoot\n', '    );\n', '\n', '    event TokenRegistered(\n', '        address token,\n', '        uint16  tokenId\n', '    );\n', '\n', '    event Shutdown(\n', '        uint timestamp\n', '    );\n', '\n', '    event WithdrawalModeActivated(\n', '        uint timestamp\n', '    );\n', '\n', '    event BlockSubmitted(\n', '        uint    indexed blockIdx,\n', '        bytes32         merkleRoot,\n', '        bytes32         publicDataHash\n', '    );\n', '\n', '    event DepositRequested(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint16  tokenId,\n', '        uint96  amount\n', '    );\n', '\n', '    event ForcedWithdrawalRequested(\n', '        address owner,\n', '        address token,\n', '        uint32  accountID\n', '    );\n', '\n', '    event WithdrawalCompleted(\n', '        uint8   category,\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '    );\n', '\n', '    event WithdrawalFailed(\n', '        uint8   category,\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '    );\n', '\n', '    event ProtocolFeesUpdated(\n', '        uint8 takerFeeBips,\n', '        uint8 makerFeeBips,\n', '        uint8 previousTakerFeeBips,\n', '        uint8 previousMakerFeeBips\n', '    );\n', '\n', '    event TransactionApproved(\n', '        address owner,\n', '        bytes32 transactionHash\n', '    );\n', '\n', '    // events from libraries\n', '    /*event DepositProcessed(\n', '        address to,\n', '        uint32  toAccountId,\n', '        uint16  token,\n', '        uint    amount\n', '    );*/\n', '\n', '    /*event ForcedWithdrawalProcessed(\n', '        uint32 fromAccountID,\n', '        uint16 tokenID,\n', '        uint   amount\n', '    );*/\n', '\n', '    /*event ConditionalTransferProcessed(\n', '        address from,\n', '        address to,\n', '        uint16  token,\n', '        uint    amount\n', '    );*/\n', '\n', '    /*event AccountUpdated(\n', '        uint32 owner,\n', '        uint   publicKey\n', '    );*/\n', '\n', '\n', '    // -- Initialization --\n', '    /// @dev Initializes this exchange. This method can only be called once.\n', '    /// @param  loopring The LoopringV3 contract address.\n', '    /// @param  owner The owner of this exchange.\n', '    /// @param  genesisMerkleRoot The initial Merkle tree state.\n', '    function initialize(\n', '        address loopring,\n', '        address owner,\n', '        bytes32 genesisMerkleRoot\n', '        )\n', '        virtual\n', '        external;\n', '\n', '    /// @dev Initialized the agent registry contract used by the exchange.\n', '    ///      Can only be called by the exchange owner once.\n', '    /// @param agentRegistry The agent registry contract to be used\n', '    function setAgentRegistry(address agentRegistry)\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the agent registry contract used by the exchange.\n', '    /// @return the agent registry contract\n', '    function getAgentRegistry()\n', '        external\n', '        virtual\n', '        view\n', '        returns (IAgentRegistry);\n', '\n', '    ///      Can only be called by the exchange owner once.\n', '    /// @param depositContract The deposit contract to be used\n', '    function setDepositContract(address depositContract)\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the deposit contract used by the exchange.\n', '    /// @return the deposit contract\n', '    function getDepositContract()\n', '        external\n', '        virtual\n', '        view\n', '        returns (IDepositContract);\n', '\n', '    // @dev Exchange owner withdraws fees from the exchange.\n', '    // @param token Fee token address\n', '    // @param feeRecipient Fee recipient address\n', '    function withdrawExchangeFees(\n', '        address token,\n', '        address feeRecipient\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    // -- Constants --\n', '    /// @dev Returns a list of constants used by the exchange.\n', '    /// @return constants The list of constants.\n', '    function getConstants()\n', '        external\n', '        virtual\n', '        pure\n', '        returns(ExchangeData.Constants memory);\n', '\n', '    // -- Mode --\n', '    /// @dev Returns hether the exchange is in withdrawal mode.\n', '    /// @return Returns true if the exchange is in withdrawal mode, else false.\n', '    function isInWithdrawalMode()\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Returns whether the exchange is shutdown.\n', '    /// @return Returns true if the exchange is shutdown, else false.\n', '    function isShutdown()\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    // -- Tokens --\n', '    /// @dev Registers an ERC20 token for a token id. Note that different exchanges may have\n', '    ///      different ids for the same ERC20 token.\n', '    ///\n', '    ///      Please note that 1 is reserved for Ether (ETH), 2 is reserved for Wrapped Ether (ETH),\n', '    ///      and 3 is reserved for Loopring Token (LRC).\n', '    ///\n', '    ///      This function is only callable by the exchange owner.\n', '    ///\n', "    /// @param  tokenAddress The token's address\n", "    /// @return tokenID The token's ID in this exchanges.\n", '    function registerToken(\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint16 tokenID);\n', '\n', '    /// @dev Returns the id of a registered token.\n', "    /// @param  tokenAddress The token's address\n", "    /// @return tokenID The token's ID in this exchanges.\n", '    function getTokenID(\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint16 tokenID);\n', '\n', '    /// @dev Returns the address of a registered token.\n', "    /// @param  tokenID The token's ID in this exchanges.\n", "    /// @return tokenAddress The token's address\n", '    function getTokenAddress(\n', '        uint16 tokenID\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (address tokenAddress);\n', '\n', '    // -- Stakes --\n', '    /// @dev Gets the amount of LRC the owner has staked onchain for this exchange.\n', '    ///      The stake will be burned if the exchange does not fulfill its duty by\n', '    ///      processing user requests in time. Please note that order matching may potentially\n', "    ///      performed by another party and is not part of the exchange's duty.\n", '    ///\n', '    /// @return The amount of LRC staked\n', '    function getExchangeStake()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    /// @dev Withdraws the amount staked for this exchange.\n', '    ///      This can only be done if the exchange has been correctly shutdown:\n', '    ///      - The exchange owner has shutdown the exchange\n', '    ///      - All deposit requests are processed\n', '    ///      - All funds are returned to the users (merkle root is reset to initial state)\n', '    ///\n', '    ///      Can only be called by the exchange owner.\n', '    ///\n', '    /// @return amountLRC The amount of LRC withdrawn\n', '    function withdrawExchangeStake(\n', '        address recipient\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint amountLRC);\n', '\n', '    /// @dev Can by called by anyone to burn the stake of the exchange when certain\n', '    ///      conditions are fulfilled.\n', '    ///\n', '    ///      Currently this will only burn the stake of the exchange if\n', '    ///      the exchange is in withdrawal mode.\n', '    function burnExchangeStake()\n', '        external\n', '        virtual;\n', '\n', '    // -- Blocks --\n', '\n', "    /// @dev Gets the current Merkle root of this exchange's virtual blockchain.\n", '    /// @return The current Merkle root.\n', '    function getMerkleRoot()\n', '        external\n', '        virtual\n', '        view\n', '        returns (bytes32);\n', '\n', "    /// @dev Gets the height of this exchange's virtual blockchain. The block height for a\n", '    ///      new exchange is 1.\n', '    /// @return The virtual blockchain height which is the index of the last block.\n', '    function getBlockHeight()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', "    /// @dev Gets some minimal info of a previously submitted block that's kept onchain.\n", '    ///      A DEX can use this function to implement a payment receipt verification\n', '    ///      contract with a challange-response scheme.\n', '    /// @param blockIdx The block index.\n', '    function getBlockInfo(uint blockIdx)\n', '        external\n', '        virtual\n', '        view\n', '        returns (ExchangeData.BlockInfo memory);\n', '\n', '    /// @dev Sumbits new blocks to the rollup blockchain.\n', '    ///\n', '    ///      This function can only be called by the exchange operator.\n', '    ///\n', '    /// @param blocks The blocks being submitted\n', '    ///      - blockType: The type of the new block\n', '    ///      - blockSize: The number of onchain or offchain requests/settlements\n', '    ///        that have been processed in this block\n', '    ///      - blockVersion: The circuit version to use for verifying the block\n', '    ///      - storeBlockInfoOnchain: If the block info for this block needs to be stored on-chain\n', '    ///      - data: The data for this block\n', '    ///      - offchainData: Arbitrary data, mainly for off-chain data-availability, i.e.,\n', '    ///        the multihash of the IPFS file that contains the block data.\n', '    function submitBlocks(ExchangeData.Block[] calldata blocks)\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the number of available forced request slots.\n', '    /// @return The number of available slots.\n', '    function getNumAvailableForcedSlots()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    // -- Deposits --\n', '\n', '    /// @dev Deposits Ether or ERC20 tokens to the specified account.\n', '    ///\n', "    ///      This function is only callable by an agent of 'from'.\n", '    ///\n', '    ///      A fee to the owner is paid in ETH to process the deposit.\n', '    ///      The operator is not forced to do the deposit and the user can send\n', '    ///      any fee amount.\n', '    ///\n', '    /// @param from The address that deposits the funds to the exchange\n', "    /// @param to The account owner's address receiving the funds\n", '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    /// @param amount The amount of tokens to deposit\n', '    /// @param auxiliaryData Optional extra data used by the deposit contract\n', '    function deposit(\n', '        address from,\n', '        address to,\n', '        address tokenAddress,\n', '        uint96  amount,\n', '        bytes   calldata auxiliaryData\n', '        )\n', '        external\n', '        virtual\n', '        payable;\n', '\n', "    /// @dev Gets the amount of tokens that may be added to the owner's account.\n", '    /// @param owner The destination address for the amount deposited.\n', '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    /// @return The amount of tokens pending.\n', '    function getPendingDepositAmount(\n', '        address owner,\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint96);\n', '\n', '    // -- Withdrawals --\n', '    /// @dev Submits an onchain request to force withdraw Ether or ERC20 tokens.\n', '    ///      This request always withdraws the full balance.\n', '    ///\n', '    ///      This function is only callable by an agent of the account.\n', '    ///\n', "    ///      The total fee in ETH that the user needs to pay is 'withdrawalFee'.\n", '    ///      If the user sends too much ETH the surplus is sent back immediately.\n', '    ///\n', '    ///      Note that after such an operation, it will take the owner some\n', '    ///      time (no more than MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE) to process the request\n', '    ///      and create the deposit to the offchain account.\n', '    ///\n', '    /// @param owner The expected owner of the account\n', '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    /// @param accountID The address the account in the Merkle tree.\n', '    function forceWithdraw(\n', '        address owner,\n', '        address tokenAddress,\n', '        uint32  accountID\n', '        )\n', '        external\n', '        virtual\n', '        payable;\n', '\n', '    /// @dev Checks if a forced withdrawal is pending for an account balance.\n', '    /// @param  accountID The accountID of the account to check.\n', '    /// @param  token The token address\n', '    /// @return True if a request is pending, false otherwise\n', '    function isForcedWithdrawalPending(\n', '        uint32  accountID,\n', '        address token\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Submits an onchain request to withdraw Ether or ERC20 tokens from the\n', '    ///      protocol fees account. The complete balance is always withdrawn.\n', '    ///\n', '    ///      Anyone can request a withdrawal of the protocol fees.\n', '    ///\n', '    ///      Note that after such an operation, it will take the owner some\n', '    ///      time (no more than MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE) to process the request\n', '    ///      and create the deposit to the offchain account.\n', '    ///\n', '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    function withdrawProtocolFees(\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        payable;\n', '\n', '    /// @dev Gets the time the protocol fee for a token was last withdrawn.\n', '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    /// @return The time the protocol fee was last withdrawn.\n', '    function getProtocolFeeLastWithdrawnTime(\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    /// @dev Allows anyone to withdraw funds for a specified user using the balances stored\n', '    ///      in the Merkle tree. The funds will be sent to the owner of the acount.\n', '    ///\n', '    ///      Can only be used in withdrawal mode (i.e. when the owner has stopped\n', '    ///      committing blocks and is not able to commit any more blocks).\n', '    ///\n', '    ///      This will NOT modify the onchain merkle root! The merkle root stored\n', '    ///      onchain will remain the same after the withdrawal. We store if the user\n', '    ///      has withdrawn the balance in State.withdrawnInWithdrawMode.\n', '    ///\n', '    /// @param  merkleProof The Merkle inclusion proof\n', '    function withdrawFromMerkleTree(\n', '        ExchangeData.MerkleProof calldata merkleProof\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Checks if the balance for the account was withdrawn with `withdrawFromMerkleTree`.\n', '    /// @param  accountID The accountID of the balance to check.\n', '    /// @param  token The token address\n', '    /// @return True if it was already withdrawn, false otherwise\n', '    function isWithdrawnInWithdrawalMode(\n', '        uint32  accountID,\n', '        address token\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Allows withdrawing funds deposited to the contract in a deposit request when\n', '    ///      it was never processed by the owner within the maximum time allowed.\n', '    ///\n', '    ///      Can be called by anyone. The deposited tokens will be sent back to\n', '    ///      the owner of the account they were deposited in.\n', '    ///\n', '    /// @param  owner The address of the account the withdrawal was done for.\n', '    /// @param  token The token address\n', '    function withdrawFromDepositRequest(\n', '        address owner,\n', '        address token\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Allows withdrawing funds after a withdrawal request (either onchain\n', '    ///      or offchain) was submitted in a block by the operator.\n', '    ///\n', '    ///      Can be called by anyone. The withdrawn tokens will be sent to\n', '    ///      the owner of the account they were withdrawn out.\n', '    ///\n', '    ///      Normally it is should not be needed for users to call this manually.\n', '    ///      Funds from withdrawal requests will be sent to the account owner\n', '    ///      immediately by the owner when the block is submitted.\n', '    ///      The user will however need to call this manually if the transfer failed.\n', '    ///\n', '    ///      Tokens and owners must have the same size.\n', '    ///\n', '    /// @param  owners The addresses of the account the withdrawal was done for.\n', '    /// @param  tokens The token addresses\n', '    function withdrawFromApprovedWithdrawals(\n', '        address[] calldata owners,\n', '        address[] calldata tokens\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the amount that can be withdrawn immediately with `withdrawFromApprovedWithdrawals`.\n', '    /// @param  owner The address of the account the withdrawal was done for.\n', '    /// @param  token The token address\n', '    /// @return The amount withdrawable\n', '    function getAmountWithdrawable(\n', '        address owner,\n', '        address token\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    /// @dev Notifies the exchange that the owner did not process a forced request.\n', '    ///      If this is indeed the case, the exchange will enter withdrawal mode.\n', '    ///\n', '    ///      Can be called by anyone.\n', '    ///\n', '    /// @param  accountID The accountID the forced request was made for\n', '    /// @param  token The token address of the the forced request\n', '    function notifyForcedRequestTooOld(\n', '        uint32  accountID,\n', '        address token\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Allows a withdrawal to be done to an adddresss that is different\n', '    ///      than initialy specified in the withdrawal request. This can be used to\n', '    ///      implement functionality like fast withdrawals.\n', '    ///\n', '    ///      This function can only be called by an agent.\n', '    ///\n', '    /// @param from The address of the account that does the withdrawal.\n', "    /// @param to The address to which 'amount' tokens were going to be withdrawn.\n", "    /// @param token The address of the token that is withdrawn ('0x0' for ETH).\n", '    /// @param amount The amount of tokens that are going to be withdrawn.\n', '    /// @param storageID The storageID of the withdrawal request.\n', '    /// @param newRecipient The new recipient address of the withdrawal.\n', '    function setWithdrawalRecipient(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint96  amount,\n', '        uint32  storageID,\n', '        address newRecipient\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the withdrawal recipient.\n', '    ///\n', '    /// @param from The address of the account that does the withdrawal.\n', "    /// @param to The address to which 'amount' tokens were going to be withdrawn.\n", "    /// @param token The address of the token that is withdrawn ('0x0' for ETH).\n", '    /// @param amount The amount of tokens that are going to be withdrawn.\n', '    /// @param storageID The storageID of the withdrawal request.\n', '    function getWithdrawalRecipient(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint96  amount,\n', '        uint32  storageID\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (address);\n', '\n', '    /// @dev Allows an agent to transfer ERC-20 tokens for a user using the allowance\n', '    ///      the user has set for the exchange. This way the user only needs to approve a single exchange contract\n', '    ///      for all exchange/agent features, which allows for a more seamless user experience.\n', '    ///\n', '    ///      This function can only be called by an agent.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (ETH is and cannot be suppported).\n', '    /// @param amount The amount of tokens transferred.\n', '    function onchainTransferFrom(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Allows an agent to approve a rollup tx.\n', '    ///\n', '    ///      This function can only be called by an agent.\n', '    ///\n', '    /// @param owner The owner of the account\n', '    /// @param txHash The hash of the transaction\n', '    function approveTransaction(\n', '        address owner,\n', '        bytes32 txHash\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Allows an agent to approve multiple rollup txs.\n', '    ///\n', '    ///      This function can only be called by an agent.\n', '    ///\n', '    /// @param owners The account owners\n', '    /// @param txHashes The hashes of the transactions\n', '    function approveTransactions(\n', '        address[] calldata owners,\n', '        bytes32[] calldata txHashes\n', '        )\n', '        external\n', '        virtual;\n', '\n', "    /// @dev Checks if a rollup tx is approved using the tx's hash.\n", '    ///\n', '    /// @param owner The owner of the account that needs to authorize the tx\n', '    /// @param txHash The hash of the transaction\n', '    /// @return True if the tx is approved, else false\n', '    function isTransactionApproved(\n', '        address owner,\n', '        bytes32 txHash\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    // -- Admins --\n', '    /// @dev Sets the max time deposits have to wait before becoming withdrawable.\n', '    /// @param newValue The new value.\n', '    /// @return  The old value.\n', '    function setMaxAgeDepositUntilWithdrawable(\n', '        uint32 newValue\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint32);\n', '\n', '    /// @dev Returns the max time deposits have to wait before becoming withdrawable.\n', '    /// @return The value.\n', '    function getMaxAgeDepositUntilWithdrawable()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint32);\n', '\n', '    /// @dev Shuts down the exchange.\n', '    ///      Once the exchange is shutdown all onchain requests are permanently disabled.\n', '    ///      When all requirements are fulfilled the exchange owner can withdraw\n', '    ///      the exchange stake with withdrawStake.\n', '    ///\n', '    ///      Note that the exchange can still enter the withdrawal mode after this function\n', '    ///      has been invoked successfully. To prevent entering the withdrawal mode before the\n', '    ///      the echange stake can be withdrawn, all withdrawal requests still need to be handled\n', '    ///      for at least MIN_TIME_IN_SHUTDOWN seconds.\n', '    ///\n', '    ///      Can only be called by the exchange owner.\n', '    ///\n', '    /// @return success True if the exchange is shutdown, else False\n', '    function shutdown()\n', '        external\n', '        virtual\n', '        returns (bool success);\n', '\n', '    /// @dev Gets the protocol fees for this exchange.\n', '    /// @return syncedAt The timestamp the protocol fees were last updated\n', '    /// @return takerFeeBips The protocol taker fee\n', '    /// @return makerFeeBips The protocol maker fee\n', '    /// @return previousTakerFeeBips The previous protocol taker fee\n', '    /// @return previousMakerFeeBips The previous protocol maker fee\n', '    function getProtocolFeeValues()\n', '        external\n', '        virtual\n', '        view\n', '        returns (\n', '            uint32 syncedAt,\n', '            uint8 takerFeeBips,\n', '            uint8 makerFeeBips,\n', '            uint8 previousTakerFeeBips,\n', '            uint8 previousMakerFeeBips\n', '        );\n', '\n', '    /// @dev Gets the domain separator used in this exchange.\n', '    function getDomainSeparator()\n', '        external\n', '        virtual\n', '        view\n', '        returns (bytes32);\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title ILoopringV3\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @author Daniel Wang  - <daniel@loopring.org>\n', 'abstract contract ILoopringV3 is Claimable\n', '{\n', '    // == Events ==\n', '    event ExchangeStakeDeposited(address exchangeAddr, uint amount);\n', '    event ExchangeStakeWithdrawn(address exchangeAddr, uint amount);\n', '    event ExchangeStakeBurned(address exchangeAddr, uint amount);\n', '    event SettingsUpdated(uint time);\n', '\n', '    // == Public Variables ==\n', '    mapping (address => uint) internal exchangeStake;\n', '\n', '    address public lrcAddress;\n', '    uint    public totalStake;\n', '    address public blockVerifierAddress;\n', '    uint    public forcedWithdrawalFee;\n', '    uint    public tokenRegistrationFeeLRCBase;\n', '    uint    public tokenRegistrationFeeLRCDelta;\n', '    uint8   public protocolTakerFeeBips;\n', '    uint8   public protocolMakerFeeBips;\n', '\n', '    address payable public protocolFeeVault;\n', '\n', '    // == Public Functions ==\n', '    /// @dev Updates the global exchange settings.\n', '    ///      This function can only be called by the owner of this contract.\n', '    ///\n', '    ///      Warning: these new values will be used by existing and\n', '    ///      new Loopring exchanges.\n', '    function updateSettings(\n', '        address payable _protocolFeeVault,   // address(0) not allowed\n', '        address _blockVerifierAddress,       // address(0) not allowed\n', '        uint    _forcedWithdrawalFee\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Updates the global protocol fee settings.\n', '    ///      This function can only be called by the owner of this contract.\n', '    ///\n', '    ///      Warning: these new values will be used by existing and\n', '    ///      new Loopring exchanges.\n', '    function updateProtocolFeeSettings(\n', '        uint8 _protocolTakerFeeBips,\n', '        uint8 _protocolMakerFeeBips\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the amount of staked LRC for an exchange.\n', '    /// @param exchangeAddr The address of the exchange\n', '    /// @return stakedLRC The amount of LRC\n', '    function getExchangeStake(\n', '        address exchangeAddr\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint stakedLRC);\n', '\n', '    /// @dev Burns a certain amount of staked LRC for a specific exchange.\n', '    ///      This function is meant to be called only from exchange contracts.\n', '    /// @return burnedLRC The amount of LRC burned. If the amount is greater than\n', '    ///         the staked amount, all staked LRC will be burned.\n', '    function burnExchangeStake(\n', '        uint amount\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint burnedLRC);\n', '\n', '    /// @dev Stakes more LRC for an exchange.\n', '    /// @param  exchangeAddr The address of the exchange\n', '    /// @param  amountLRC The amount of LRC to stake\n', '    /// @return stakedLRC The total amount of LRC staked for the exchange\n', '    function depositExchangeStake(\n', '        address exchangeAddr,\n', '        uint    amountLRC\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint stakedLRC);\n', '\n', '    /// @dev Withdraws a certain amount of staked LRC for an exchange to the given address.\n', '    ///      This function is meant to be called only from within exchange contracts.\n', '    /// @param  recipient The address to receive LRC\n', '    /// @param  requestedAmount The amount of LRC to withdraw\n', '    /// @return amountLRC The amount of LRC withdrawn\n', '    function withdrawExchangeStake(\n', '        address recipient,\n', '        uint    requestedAmount\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint amountLRC);\n', '\n', '    /// @dev Gets the protocol fee values for an exchange.\n', '    /// @return takerFeeBips The protocol taker fee\n', '    /// @return makerFeeBips The protocol maker fee\n', '    function getProtocolFeeValues(\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (\n', '            uint8 takerFeeBips,\n', '            uint8 makerFeeBips\n', '        );\n', '}\n', '\n', '\n', '\n', '/// @title LoopringV3\n', '/// @dev This contract does NOT support proxy.\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @author Daniel Wang  - <daniel@loopring.org>\n', 'contract LoopringV3 is ILoopringV3, ReentrancyGuard\n', '{\n', '    using AddressUtil       for address payable;\n', '    using MathUint          for uint;\n', '    using ERC20SafeTransfer for address;\n', '\n', '    // -- Constructor --\n', '    constructor(\n', '        address _lrcAddress,\n', '        address payable _protocolFeeVault,\n', '        address _blockVerifierAddress\n', '        )\n', '        Claimable()\n', '    {\n', '        require(address(0) != _lrcAddress, "ZERO_ADDRESS");\n', '\n', '        lrcAddress = _lrcAddress;\n', '\n', '        updateSettingsInternal(_protocolFeeVault, _blockVerifierAddress, 0);\n', '    }\n', '\n', '    // == Public Functions ==\n', '    function updateSettings(\n', '        address payable _protocolFeeVault,\n', '        address _blockVerifierAddress,\n', '        uint    _forcedWithdrawalFee\n', '        )\n', '        external\n', '        override\n', '        nonReentrant\n', '        onlyOwner\n', '    {\n', '        updateSettingsInternal(\n', '            _protocolFeeVault,\n', '            _blockVerifierAddress,\n', '            _forcedWithdrawalFee\n', '        );\n', '    }\n', '\n', '    function updateProtocolFeeSettings(\n', '        uint8 _protocolTakerFeeBips,\n', '        uint8 _protocolMakerFeeBips\n', '        )\n', '        external\n', '        override\n', '        nonReentrant\n', '        onlyOwner\n', '    {\n', '        protocolTakerFeeBips = _protocolTakerFeeBips;\n', '        protocolMakerFeeBips = _protocolMakerFeeBips;\n', '\n', '        emit SettingsUpdated(block.timestamp);\n', '    }\n', '\n', '    function getExchangeStake(\n', '        address exchangeAddr\n', '        )\n', '        public\n', '        override\n', '        view\n', '        returns (uint)\n', '    {\n', '        return exchangeStake[exchangeAddr];\n', '    }\n', '\n', '    function burnExchangeStake(\n', '        uint amount\n', '        )\n', '        external\n', '        override\n', '        nonReentrant\n', '        returns (uint burnedLRC)\n', '    {\n', '        burnedLRC = exchangeStake[msg.sender];\n', '\n', '        if (amount < burnedLRC) {\n', '            burnedLRC = amount;\n', '        }\n', '        if (burnedLRC > 0) {\n', '            lrcAddress.safeTransferAndVerify(protocolFeeVault, burnedLRC);\n', '            exchangeStake[msg.sender] = exchangeStake[msg.sender].sub(burnedLRC);\n', '            totalStake = totalStake.sub(burnedLRC);\n', '        }\n', '        emit ExchangeStakeBurned(msg.sender, burnedLRC);\n', '    }\n', '\n', '    function depositExchangeStake(\n', '        address exchangeAddr,\n', '        uint    amountLRC\n', '        )\n', '        external\n', '        override\n', '        nonReentrant\n', '        returns (uint stakedLRC)\n', '    {\n', '        require(amountLRC > 0, "ZERO_VALUE");\n', '\n', '        lrcAddress.safeTransferFromAndVerify(msg.sender, address(this), amountLRC);\n', '\n', '        stakedLRC = exchangeStake[exchangeAddr].add(amountLRC);\n', '        exchangeStake[exchangeAddr] = stakedLRC;\n', '        totalStake = totalStake.add(amountLRC);\n', '\n', '        emit ExchangeStakeDeposited(exchangeAddr, amountLRC);\n', '    }\n', '\n', '    function withdrawExchangeStake(\n', '        address recipient,\n', '        uint    requestedAmount\n', '        )\n', '        external\n', '        override\n', '        nonReentrant\n', '        returns (uint amountLRC)\n', '    {\n', '        uint stake = exchangeStake[msg.sender];\n', '        amountLRC = (stake > requestedAmount) ? requestedAmount : stake;\n', '\n', '        if (amountLRC > 0) {\n', '            lrcAddress.safeTransferAndVerify(recipient, amountLRC);\n', '            exchangeStake[msg.sender] = exchangeStake[msg.sender].sub(amountLRC);\n', '            totalStake = totalStake.sub(amountLRC);\n', '        }\n', '\n', '        emit ExchangeStakeWithdrawn(msg.sender, amountLRC);\n', '    }\n', '\n', '    function getProtocolFeeValues()\n', '        public\n', '        override\n', '        view\n', '        returns (\n', '            uint8 takerFeeBips,\n', '            uint8 makerFeeBips\n', '        )\n', '    {\n', '        return (protocolTakerFeeBips, protocolMakerFeeBips);\n', '    }\n', '\n', '    // == Internal Functions ==\n', '    function updateSettingsInternal(\n', '        address payable  _protocolFeeVault,\n', '        address _blockVerifierAddress,\n', '        uint    _forcedWithdrawalFee\n', '        )\n', '        private\n', '    {\n', '        require(address(0) != _protocolFeeVault, "ZERO_ADDRESS");\n', '        require(address(0) != _blockVerifierAddress, "ZERO_ADDRESS");\n', '\n', '        protocolFeeVault = _protocolFeeVault;\n', '        blockVerifierAddress = _blockVerifierAddress;\n', '        forcedWithdrawalFee = _forcedWithdrawalFee;\n', '\n', '        emit SettingsUpdated(block.timestamp);\n', '    }\n', '}']