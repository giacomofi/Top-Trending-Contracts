['/**\n', ' *Submitted for verification at Etherscan.io on 2020-09-23\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2020-08-03\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', 'pragma solidity ^0.6.10;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title The Open Oracle Data Base Contract\n', ' * @author Compound Labs, Inc.\n', ' */\n', 'contract OpenOracleData {\n', '    /**\n', '     * @notice The event emitted when a source writes to its storage\n', '     */\n', '    //event Write(address indexed source, <Key> indexed key, string kind, uint64 timestamp, <Value> value);\n', '\n', '    /**\n', '     * @notice Write a bunch of signed datum to the authenticated storage mapping\n', '     * @param message The payload containing the timestamp, and (key, value) pairs\n', '     * @param signature The cryptographic signature of the message payload, authorizing the source to write\n', '     * @return The keys that were written\n', '     */\n', '    //function put(bytes calldata message, bytes calldata signature) external returns (<Key> memory);\n', '\n', '    /**\n', '     * @notice Read a single key with a pre-defined type signature from an authenticated source\n', '     * @param source The verifiable author of the data\n', '     * @param key The selector for the value to return\n', '     * @return The claimed Unix timestamp for the data and the encoded value (defaults to (0, 0x))\n', '     */\n', '    //function get(address source, <Key> key) external view returns (uint, <Value>);\n', '\n', '    /**\n', '     * @notice Recovers the source address which signed a message\n', '     * @dev Comparing to a claimed address would add nothing,\n', '     *  as the caller could simply perform the recover and claim that address.\n', '     * @param message The data that was presumably signed\n', '     * @param signature The fingerprint of the data + private key\n', '     * @return The source address which signed the message, presumably\n', '     */\n', '    function source(bytes memory message, bytes memory signature) public pure returns (address) {\n', '        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\n', '        bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(message)));\n', '        return ecrecover(hash, v, r, s);\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title The Open Oracle Price Data Contract\n', ' * @notice Values stored in this contract should represent a USD price with 6 decimals precision\n', ' * @author Compound Labs, Inc.\n', ' */\n', 'contract OpenOraclePriceData is OpenOracleData {\n', '    ///@notice The event emitted when a source writes to its storage\n', '    event Write(address indexed source, string key, uint64 timestamp, uint64 value);\n', '    ///@notice The event emitted when the timestamp on a price is invalid and it is not written to storage\n', '    event NotWritten(uint64 priorTimestamp, uint256 messageTimestamp, uint256 blockTimestamp);\n', '\n', '    ///@notice The fundamental unit of storage for a reporter source\n', '    struct Datum {\n', '        uint64 timestamp;\n', '        uint64 value;\n', '    }\n', '\n', '    /**\n', '     * @dev The most recent authenticated data from all sources.\n', '     *  This is private because dynamic mapping keys preclude auto-generated getters.\n', '     */\n', '    mapping(address => mapping(string => Datum)) private data;\n', '\n', '    /**\n', '     * @notice Write a bunch of signed datum to the authenticated storage mapping\n', '     * @param message The payload containing the timestamp, and (key, value) pairs\n', '     * @param signature The cryptographic signature of the message payload, authorizing the source to write\n', '     * @return The keys that were written\n', '     */\n', '    function put(bytes calldata message, bytes calldata signature) external returns (string memory) {\n', '        (address source, uint64 timestamp, string memory key, uint64 value) = decodeMessage(message, signature);\n', '        return putInternal(source, timestamp, key, value);\n', '    }\n', '\n', '    function putInternal(address source, uint64 timestamp, string memory key, uint64 value) internal returns (string memory) {\n', '        // Only update if newer than stored, according to source\n', '        Datum storage prior = data[source][key];\n', '        if (timestamp > prior.timestamp && timestamp < block.timestamp + 60 minutes && source != address(0)) {\n', '            data[source][key] = Datum(timestamp, value);\n', '            emit Write(source, key, timestamp, value);\n', '        } else {\n', '            emit NotWritten(prior.timestamp, timestamp, block.timestamp);\n', '        }\n', '        return key;\n', '    }\n', '\n', '    function decodeMessage(bytes calldata message, bytes calldata signature) internal pure returns (address, uint64, string memory, uint64) {\n', '        // Recover the source address\n', '        address source = source(message, signature);\n', '\n', '        // Decode the message and check the kind\n', '        (string memory kind, uint64 timestamp, string memory key, uint64 value) = abi.decode(message, (string, uint64, string, uint64));\n', '        require(keccak256(abi.encodePacked(kind)) == keccak256(abi.encodePacked("prices")), "Kind of data must be \'prices\'");\n', '        return (source, timestamp, key, value);\n', '    }\n', '\n', '    /**\n', '     * @notice Read a single key from an authenticated source\n', '     * @param source The verifiable author of the data\n', '     * @param key The selector for the value to return\n', '     * @return The claimed Unix timestamp for the data and the price value (defaults to (0, 0))\n', '     */\n', '    function get(address source, string calldata key) external view returns (uint64, uint64) {\n', '        Datum storage datum = data[source][key];\n', '        return (datum.timestamp, datum.value);\n', '    }\n', '\n', '    /**\n', '     * @notice Read only the value for a single key from an authenticated source\n', '     * @param source The verifiable author of the data\n', '     * @param key The selector for the value to return\n', '     * @return The price value (defaults to 0)\n', '     */\n', '    function getPrice(address source, string calldata key) external view returns (uint64) {\n', '        return data[source][key].value;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'interface CErc20 {\n', '    function underlying() external view returns (address);\n', '}\n', '\n', 'contract UniswapConfig {\n', '    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\n', '    enum PriceSource {\n', '        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\n', '        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\n', '        REPORTER   /// implies the price is set by the reporter\n', '    }\n', '\n', '    /// @dev Describe how the USD price should be determined for an asset.\n', '    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\n', '    struct TokenConfig {\n', '        address cToken;\n', '        address underlying;\n', '        bytes32 symbolHash;\n', '        uint256 baseUnit;\n', '        PriceSource priceSource;\n', '        uint256 fixedPrice;\n', '        address uniswapMarket;\n', '        bool isUniswapReversed;\n', '    }\n', '\n', '    /// @notice The max number of tokens this contract is hardcoded to support\n', '    /// @dev Do not change this variable without updating all the fields throughout the contract.\n', '    uint public constant maxTokens = 30;\n', '\n', '    /// @notice The number of tokens this contract actually supports\n', '    uint public immutable numTokens;\n', '\n', '    address internal immutable cToken00;\n', '    address internal immutable cToken01;\n', '    address internal immutable cToken02;\n', '    address internal immutable cToken03;\n', '    address internal immutable cToken04;\n', '    address internal immutable cToken05;\n', '    address internal immutable cToken06;\n', '    address internal immutable cToken07;\n', '    address internal immutable cToken08;\n', '    address internal immutable cToken09;\n', '    address internal immutable cToken10;\n', '    address internal immutable cToken11;\n', '    address internal immutable cToken12;\n', '    address internal immutable cToken13;\n', '    address internal immutable cToken14;\n', '    address internal immutable cToken15;\n', '    address internal immutable cToken16;\n', '    address internal immutable cToken17;\n', '    address internal immutable cToken18;\n', '    address internal immutable cToken19;\n', '    address internal immutable cToken20;\n', '    address internal immutable cToken21;\n', '    address internal immutable cToken22;\n', '    address internal immutable cToken23;\n', '    address internal immutable cToken24;\n', '    address internal immutable cToken25;\n', '    address internal immutable cToken26;\n', '    address internal immutable cToken27;\n', '    address internal immutable cToken28;\n', '    address internal immutable cToken29;\n', '\n', '    address internal immutable underlying00;\n', '    address internal immutable underlying01;\n', '    address internal immutable underlying02;\n', '    address internal immutable underlying03;\n', '    address internal immutable underlying04;\n', '    address internal immutable underlying05;\n', '    address internal immutable underlying06;\n', '    address internal immutable underlying07;\n', '    address internal immutable underlying08;\n', '    address internal immutable underlying09;\n', '    address internal immutable underlying10;\n', '    address internal immutable underlying11;\n', '    address internal immutable underlying12;\n', '    address internal immutable underlying13;\n', '    address internal immutable underlying14;\n', '    address internal immutable underlying15;\n', '    address internal immutable underlying16;\n', '    address internal immutable underlying17;\n', '    address internal immutable underlying18;\n', '    address internal immutable underlying19;\n', '    address internal immutable underlying20;\n', '    address internal immutable underlying21;\n', '    address internal immutable underlying22;\n', '    address internal immutable underlying23;\n', '    address internal immutable underlying24;\n', '    address internal immutable underlying25;\n', '    address internal immutable underlying26;\n', '    address internal immutable underlying27;\n', '    address internal immutable underlying28;\n', '    address internal immutable underlying29;\n', '\n', '    bytes32 internal immutable symbolHash00;\n', '    bytes32 internal immutable symbolHash01;\n', '    bytes32 internal immutable symbolHash02;\n', '    bytes32 internal immutable symbolHash03;\n', '    bytes32 internal immutable symbolHash04;\n', '    bytes32 internal immutable symbolHash05;\n', '    bytes32 internal immutable symbolHash06;\n', '    bytes32 internal immutable symbolHash07;\n', '    bytes32 internal immutable symbolHash08;\n', '    bytes32 internal immutable symbolHash09;\n', '    bytes32 internal immutable symbolHash10;\n', '    bytes32 internal immutable symbolHash11;\n', '    bytes32 internal immutable symbolHash12;\n', '    bytes32 internal immutable symbolHash13;\n', '    bytes32 internal immutable symbolHash14;\n', '    bytes32 internal immutable symbolHash15;\n', '    bytes32 internal immutable symbolHash16;\n', '    bytes32 internal immutable symbolHash17;\n', '    bytes32 internal immutable symbolHash18;\n', '    bytes32 internal immutable symbolHash19;\n', '    bytes32 internal immutable symbolHash20;\n', '    bytes32 internal immutable symbolHash21;\n', '    bytes32 internal immutable symbolHash22;\n', '    bytes32 internal immutable symbolHash23;\n', '    bytes32 internal immutable symbolHash24;\n', '    bytes32 internal immutable symbolHash25;\n', '    bytes32 internal immutable symbolHash26;\n', '    bytes32 internal immutable symbolHash27;\n', '    bytes32 internal immutable symbolHash28;\n', '    bytes32 internal immutable symbolHash29;\n', '\n', '    uint256 internal immutable baseUnit00;\n', '    uint256 internal immutable baseUnit01;\n', '    uint256 internal immutable baseUnit02;\n', '    uint256 internal immutable baseUnit03;\n', '    uint256 internal immutable baseUnit04;\n', '    uint256 internal immutable baseUnit05;\n', '    uint256 internal immutable baseUnit06;\n', '    uint256 internal immutable baseUnit07;\n', '    uint256 internal immutable baseUnit08;\n', '    uint256 internal immutable baseUnit09;\n', '    uint256 internal immutable baseUnit10;\n', '    uint256 internal immutable baseUnit11;\n', '    uint256 internal immutable baseUnit12;\n', '    uint256 internal immutable baseUnit13;\n', '    uint256 internal immutable baseUnit14;\n', '    uint256 internal immutable baseUnit15;\n', '    uint256 internal immutable baseUnit16;\n', '    uint256 internal immutable baseUnit17;\n', '    uint256 internal immutable baseUnit18;\n', '    uint256 internal immutable baseUnit19;\n', '    uint256 internal immutable baseUnit20;\n', '    uint256 internal immutable baseUnit21;\n', '    uint256 internal immutable baseUnit22;\n', '    uint256 internal immutable baseUnit23;\n', '    uint256 internal immutable baseUnit24;\n', '    uint256 internal immutable baseUnit25;\n', '    uint256 internal immutable baseUnit26;\n', '    uint256 internal immutable baseUnit27;\n', '    uint256 internal immutable baseUnit28;\n', '    uint256 internal immutable baseUnit29;\n', '\n', '    PriceSource internal immutable priceSource00;\n', '    PriceSource internal immutable priceSource01;\n', '    PriceSource internal immutable priceSource02;\n', '    PriceSource internal immutable priceSource03;\n', '    PriceSource internal immutable priceSource04;\n', '    PriceSource internal immutable priceSource05;\n', '    PriceSource internal immutable priceSource06;\n', '    PriceSource internal immutable priceSource07;\n', '    PriceSource internal immutable priceSource08;\n', '    PriceSource internal immutable priceSource09;\n', '    PriceSource internal immutable priceSource10;\n', '    PriceSource internal immutable priceSource11;\n', '    PriceSource internal immutable priceSource12;\n', '    PriceSource internal immutable priceSource13;\n', '    PriceSource internal immutable priceSource14;\n', '    PriceSource internal immutable priceSource15;\n', '    PriceSource internal immutable priceSource16;\n', '    PriceSource internal immutable priceSource17;\n', '    PriceSource internal immutable priceSource18;\n', '    PriceSource internal immutable priceSource19;\n', '    PriceSource internal immutable priceSource20;\n', '    PriceSource internal immutable priceSource21;\n', '    PriceSource internal immutable priceSource22;\n', '    PriceSource internal immutable priceSource23;\n', '    PriceSource internal immutable priceSource24;\n', '    PriceSource internal immutable priceSource25;\n', '    PriceSource internal immutable priceSource26;\n', '    PriceSource internal immutable priceSource27;\n', '    PriceSource internal immutable priceSource28;\n', '    PriceSource internal immutable priceSource29;\n', '\n', '    uint256 internal immutable fixedPrice00;\n', '    uint256 internal immutable fixedPrice01;\n', '    uint256 internal immutable fixedPrice02;\n', '    uint256 internal immutable fixedPrice03;\n', '    uint256 internal immutable fixedPrice04;\n', '    uint256 internal immutable fixedPrice05;\n', '    uint256 internal immutable fixedPrice06;\n', '    uint256 internal immutable fixedPrice07;\n', '    uint256 internal immutable fixedPrice08;\n', '    uint256 internal immutable fixedPrice09;\n', '    uint256 internal immutable fixedPrice10;\n', '    uint256 internal immutable fixedPrice11;\n', '    uint256 internal immutable fixedPrice12;\n', '    uint256 internal immutable fixedPrice13;\n', '    uint256 internal immutable fixedPrice14;\n', '    uint256 internal immutable fixedPrice15;\n', '    uint256 internal immutable fixedPrice16;\n', '    uint256 internal immutable fixedPrice17;\n', '    uint256 internal immutable fixedPrice18;\n', '    uint256 internal immutable fixedPrice19;\n', '    uint256 internal immutable fixedPrice20;\n', '    uint256 internal immutable fixedPrice21;\n', '    uint256 internal immutable fixedPrice22;\n', '    uint256 internal immutable fixedPrice23;\n', '    uint256 internal immutable fixedPrice24;\n', '    uint256 internal immutable fixedPrice25;\n', '    uint256 internal immutable fixedPrice26;\n', '    uint256 internal immutable fixedPrice27;\n', '    uint256 internal immutable fixedPrice28;\n', '    uint256 internal immutable fixedPrice29;\n', '\n', '    address internal immutable uniswapMarket00;\n', '    address internal immutable uniswapMarket01;\n', '    address internal immutable uniswapMarket02;\n', '    address internal immutable uniswapMarket03;\n', '    address internal immutable uniswapMarket04;\n', '    address internal immutable uniswapMarket05;\n', '    address internal immutable uniswapMarket06;\n', '    address internal immutable uniswapMarket07;\n', '    address internal immutable uniswapMarket08;\n', '    address internal immutable uniswapMarket09;\n', '    address internal immutable uniswapMarket10;\n', '    address internal immutable uniswapMarket11;\n', '    address internal immutable uniswapMarket12;\n', '    address internal immutable uniswapMarket13;\n', '    address internal immutable uniswapMarket14;\n', '    address internal immutable uniswapMarket15;\n', '    address internal immutable uniswapMarket16;\n', '    address internal immutable uniswapMarket17;\n', '    address internal immutable uniswapMarket18;\n', '    address internal immutable uniswapMarket19;\n', '    address internal immutable uniswapMarket20;\n', '    address internal immutable uniswapMarket21;\n', '    address internal immutable uniswapMarket22;\n', '    address internal immutable uniswapMarket23;\n', '    address internal immutable uniswapMarket24;\n', '    address internal immutable uniswapMarket25;\n', '    address internal immutable uniswapMarket26;\n', '    address internal immutable uniswapMarket27;\n', '    address internal immutable uniswapMarket28;\n', '    address internal immutable uniswapMarket29;\n', '\n', '    bool internal immutable isUniswapReversed00;\n', '    bool internal immutable isUniswapReversed01;\n', '    bool internal immutable isUniswapReversed02;\n', '    bool internal immutable isUniswapReversed03;\n', '    bool internal immutable isUniswapReversed04;\n', '    bool internal immutable isUniswapReversed05;\n', '    bool internal immutable isUniswapReversed06;\n', '    bool internal immutable isUniswapReversed07;\n', '    bool internal immutable isUniswapReversed08;\n', '    bool internal immutable isUniswapReversed09;\n', '    bool internal immutable isUniswapReversed10;\n', '    bool internal immutable isUniswapReversed11;\n', '    bool internal immutable isUniswapReversed12;\n', '    bool internal immutable isUniswapReversed13;\n', '    bool internal immutable isUniswapReversed14;\n', '    bool internal immutable isUniswapReversed15;\n', '    bool internal immutable isUniswapReversed16;\n', '    bool internal immutable isUniswapReversed17;\n', '    bool internal immutable isUniswapReversed18;\n', '    bool internal immutable isUniswapReversed19;\n', '    bool internal immutable isUniswapReversed20;\n', '    bool internal immutable isUniswapReversed21;\n', '    bool internal immutable isUniswapReversed22;\n', '    bool internal immutable isUniswapReversed23;\n', '    bool internal immutable isUniswapReversed24;\n', '    bool internal immutable isUniswapReversed25;\n', '    bool internal immutable isUniswapReversed26;\n', '    bool internal immutable isUniswapReversed27;\n', '    bool internal immutable isUniswapReversed28;\n', '    bool internal immutable isUniswapReversed29;\n', '\n', '    /**\n', '     * @notice Construct an immutable store of configs into the contract data\n', '     * @param configs The configs for the supported assets\n', '     */\n', '    constructor(TokenConfig[] memory configs) public {\n', '        require(configs.length <= maxTokens, "too many configs");\n', '        numTokens = configs.length;\n', '\n', '        cToken00 = get(configs, 0).cToken;\n', '        cToken01 = get(configs, 1).cToken;\n', '        cToken02 = get(configs, 2).cToken;\n', '        cToken03 = get(configs, 3).cToken;\n', '        cToken04 = get(configs, 4).cToken;\n', '        cToken05 = get(configs, 5).cToken;\n', '        cToken06 = get(configs, 6).cToken;\n', '        cToken07 = get(configs, 7).cToken;\n', '        cToken08 = get(configs, 8).cToken;\n', '        cToken09 = get(configs, 9).cToken;\n', '        cToken10 = get(configs, 10).cToken;\n', '        cToken11 = get(configs, 11).cToken;\n', '        cToken12 = get(configs, 12).cToken;\n', '        cToken13 = get(configs, 13).cToken;\n', '        cToken14 = get(configs, 14).cToken;\n', '        cToken15 = get(configs, 15).cToken;\n', '        cToken16 = get(configs, 16).cToken;\n', '        cToken17 = get(configs, 17).cToken;\n', '        cToken18 = get(configs, 18).cToken;\n', '        cToken19 = get(configs, 19).cToken;\n', '        cToken20 = get(configs, 20).cToken;\n', '        cToken21 = get(configs, 21).cToken;\n', '        cToken22 = get(configs, 22).cToken;\n', '        cToken23 = get(configs, 23).cToken;\n', '        cToken24 = get(configs, 24).cToken;\n', '        cToken25 = get(configs, 25).cToken;\n', '        cToken26 = get(configs, 26).cToken;\n', '        cToken27 = get(configs, 27).cToken;\n', '        cToken28 = get(configs, 28).cToken;\n', '        cToken29 = get(configs, 29).cToken;\n', '\n', '        underlying00 = get(configs, 0).underlying;\n', '        underlying01 = get(configs, 1).underlying;\n', '        underlying02 = get(configs, 2).underlying;\n', '        underlying03 = get(configs, 3).underlying;\n', '        underlying04 = get(configs, 4).underlying;\n', '        underlying05 = get(configs, 5).underlying;\n', '        underlying06 = get(configs, 6).underlying;\n', '        underlying07 = get(configs, 7).underlying;\n', '        underlying08 = get(configs, 8).underlying;\n', '        underlying09 = get(configs, 9).underlying;\n', '        underlying10 = get(configs, 10).underlying;\n', '        underlying11 = get(configs, 11).underlying;\n', '        underlying12 = get(configs, 12).underlying;\n', '        underlying13 = get(configs, 13).underlying;\n', '        underlying14 = get(configs, 14).underlying;\n', '        underlying15 = get(configs, 15).underlying;\n', '        underlying16 = get(configs, 16).underlying;\n', '        underlying17 = get(configs, 17).underlying;\n', '        underlying18 = get(configs, 18).underlying;\n', '        underlying19 = get(configs, 19).underlying;\n', '        underlying20 = get(configs, 20).underlying;\n', '        underlying21 = get(configs, 21).underlying;\n', '        underlying22 = get(configs, 22).underlying;\n', '        underlying23 = get(configs, 23).underlying;\n', '        underlying24 = get(configs, 24).underlying;\n', '        underlying25 = get(configs, 25).underlying;\n', '        underlying26 = get(configs, 26).underlying;\n', '        underlying27 = get(configs, 27).underlying;\n', '        underlying28 = get(configs, 28).underlying;\n', '        underlying29 = get(configs, 29).underlying;\n', '\n', '        symbolHash00 = get(configs, 0).symbolHash;\n', '        symbolHash01 = get(configs, 1).symbolHash;\n', '        symbolHash02 = get(configs, 2).symbolHash;\n', '        symbolHash03 = get(configs, 3).symbolHash;\n', '        symbolHash04 = get(configs, 4).symbolHash;\n', '        symbolHash05 = get(configs, 5).symbolHash;\n', '        symbolHash06 = get(configs, 6).symbolHash;\n', '        symbolHash07 = get(configs, 7).symbolHash;\n', '        symbolHash08 = get(configs, 8).symbolHash;\n', '        symbolHash09 = get(configs, 9).symbolHash;\n', '        symbolHash10 = get(configs, 10).symbolHash;\n', '        symbolHash11 = get(configs, 11).symbolHash;\n', '        symbolHash12 = get(configs, 12).symbolHash;\n', '        symbolHash13 = get(configs, 13).symbolHash;\n', '        symbolHash14 = get(configs, 14).symbolHash;\n', '        symbolHash15 = get(configs, 15).symbolHash;\n', '        symbolHash16 = get(configs, 16).symbolHash;\n', '        symbolHash17 = get(configs, 17).symbolHash;\n', '        symbolHash18 = get(configs, 18).symbolHash;\n', '        symbolHash19 = get(configs, 19).symbolHash;\n', '        symbolHash20 = get(configs, 20).symbolHash;\n', '        symbolHash21 = get(configs, 21).symbolHash;\n', '        symbolHash22 = get(configs, 22).symbolHash;\n', '        symbolHash23 = get(configs, 23).symbolHash;\n', '        symbolHash24 = get(configs, 24).symbolHash;\n', '        symbolHash25 = get(configs, 25).symbolHash;\n', '        symbolHash26 = get(configs, 26).symbolHash;\n', '        symbolHash27 = get(configs, 27).symbolHash;\n', '        symbolHash28 = get(configs, 28).symbolHash;\n', '        symbolHash29 = get(configs, 29).symbolHash;\n', '\n', '        baseUnit00 = get(configs, 0).baseUnit;\n', '        baseUnit01 = get(configs, 1).baseUnit;\n', '        baseUnit02 = get(configs, 2).baseUnit;\n', '        baseUnit03 = get(configs, 3).baseUnit;\n', '        baseUnit04 = get(configs, 4).baseUnit;\n', '        baseUnit05 = get(configs, 5).baseUnit;\n', '        baseUnit06 = get(configs, 6).baseUnit;\n', '        baseUnit07 = get(configs, 7).baseUnit;\n', '        baseUnit08 = get(configs, 8).baseUnit;\n', '        baseUnit09 = get(configs, 9).baseUnit;\n', '        baseUnit10 = get(configs, 10).baseUnit;\n', '        baseUnit11 = get(configs, 11).baseUnit;\n', '        baseUnit12 = get(configs, 12).baseUnit;\n', '        baseUnit13 = get(configs, 13).baseUnit;\n', '        baseUnit14 = get(configs, 14).baseUnit;\n', '        baseUnit15 = get(configs, 15).baseUnit;\n', '        baseUnit16 = get(configs, 16).baseUnit;\n', '        baseUnit17 = get(configs, 17).baseUnit;\n', '        baseUnit18 = get(configs, 18).baseUnit;\n', '        baseUnit19 = get(configs, 19).baseUnit;\n', '        baseUnit20 = get(configs, 20).baseUnit;\n', '        baseUnit21 = get(configs, 21).baseUnit;\n', '        baseUnit22 = get(configs, 22).baseUnit;\n', '        baseUnit23 = get(configs, 23).baseUnit;\n', '        baseUnit24 = get(configs, 24).baseUnit;\n', '        baseUnit25 = get(configs, 25).baseUnit;\n', '        baseUnit26 = get(configs, 26).baseUnit;\n', '        baseUnit27 = get(configs, 27).baseUnit;\n', '        baseUnit28 = get(configs, 28).baseUnit;\n', '        baseUnit29 = get(configs, 29).baseUnit;\n', '\n', '        priceSource00 = get(configs, 0).priceSource;\n', '        priceSource01 = get(configs, 1).priceSource;\n', '        priceSource02 = get(configs, 2).priceSource;\n', '        priceSource03 = get(configs, 3).priceSource;\n', '        priceSource04 = get(configs, 4).priceSource;\n', '        priceSource05 = get(configs, 5).priceSource;\n', '        priceSource06 = get(configs, 6).priceSource;\n', '        priceSource07 = get(configs, 7).priceSource;\n', '        priceSource08 = get(configs, 8).priceSource;\n', '        priceSource09 = get(configs, 9).priceSource;\n', '        priceSource10 = get(configs, 10).priceSource;\n', '        priceSource11 = get(configs, 11).priceSource;\n', '        priceSource12 = get(configs, 12).priceSource;\n', '        priceSource13 = get(configs, 13).priceSource;\n', '        priceSource14 = get(configs, 14).priceSource;\n', '        priceSource15 = get(configs, 15).priceSource;\n', '        priceSource16 = get(configs, 16).priceSource;\n', '        priceSource17 = get(configs, 17).priceSource;\n', '        priceSource18 = get(configs, 18).priceSource;\n', '        priceSource19 = get(configs, 19).priceSource;\n', '        priceSource20 = get(configs, 20).priceSource;\n', '        priceSource21 = get(configs, 21).priceSource;\n', '        priceSource22 = get(configs, 22).priceSource;\n', '        priceSource23 = get(configs, 23).priceSource;\n', '        priceSource24 = get(configs, 24).priceSource;\n', '        priceSource25 = get(configs, 25).priceSource;\n', '        priceSource26 = get(configs, 26).priceSource;\n', '        priceSource27 = get(configs, 27).priceSource;\n', '        priceSource28 = get(configs, 28).priceSource;\n', '        priceSource29 = get(configs, 29).priceSource;\n', '\n', '        fixedPrice00 = get(configs, 0).fixedPrice;\n', '        fixedPrice01 = get(configs, 1).fixedPrice;\n', '        fixedPrice02 = get(configs, 2).fixedPrice;\n', '        fixedPrice03 = get(configs, 3).fixedPrice;\n', '        fixedPrice04 = get(configs, 4).fixedPrice;\n', '        fixedPrice05 = get(configs, 5).fixedPrice;\n', '        fixedPrice06 = get(configs, 6).fixedPrice;\n', '        fixedPrice07 = get(configs, 7).fixedPrice;\n', '        fixedPrice08 = get(configs, 8).fixedPrice;\n', '        fixedPrice09 = get(configs, 9).fixedPrice;\n', '        fixedPrice10 = get(configs, 10).fixedPrice;\n', '        fixedPrice11 = get(configs, 11).fixedPrice;\n', '        fixedPrice12 = get(configs, 12).fixedPrice;\n', '        fixedPrice13 = get(configs, 13).fixedPrice;\n', '        fixedPrice14 = get(configs, 14).fixedPrice;\n', '        fixedPrice15 = get(configs, 15).fixedPrice;\n', '        fixedPrice16 = get(configs, 16).fixedPrice;\n', '        fixedPrice17 = get(configs, 17).fixedPrice;\n', '        fixedPrice18 = get(configs, 18).fixedPrice;\n', '        fixedPrice19 = get(configs, 19).fixedPrice;\n', '        fixedPrice20 = get(configs, 20).fixedPrice;\n', '        fixedPrice21 = get(configs, 21).fixedPrice;\n', '        fixedPrice22 = get(configs, 22).fixedPrice;\n', '        fixedPrice23 = get(configs, 23).fixedPrice;\n', '        fixedPrice24 = get(configs, 24).fixedPrice;\n', '        fixedPrice25 = get(configs, 25).fixedPrice;\n', '        fixedPrice26 = get(configs, 26).fixedPrice;\n', '        fixedPrice27 = get(configs, 27).fixedPrice;\n', '        fixedPrice28 = get(configs, 28).fixedPrice;\n', '        fixedPrice29 = get(configs, 29).fixedPrice;\n', '\n', '        uniswapMarket00 = get(configs, 0).uniswapMarket;\n', '        uniswapMarket01 = get(configs, 1).uniswapMarket;\n', '        uniswapMarket02 = get(configs, 2).uniswapMarket;\n', '        uniswapMarket03 = get(configs, 3).uniswapMarket;\n', '        uniswapMarket04 = get(configs, 4).uniswapMarket;\n', '        uniswapMarket05 = get(configs, 5).uniswapMarket;\n', '        uniswapMarket06 = get(configs, 6).uniswapMarket;\n', '        uniswapMarket07 = get(configs, 7).uniswapMarket;\n', '        uniswapMarket08 = get(configs, 8).uniswapMarket;\n', '        uniswapMarket09 = get(configs, 9).uniswapMarket;\n', '        uniswapMarket10 = get(configs, 10).uniswapMarket;\n', '        uniswapMarket11 = get(configs, 11).uniswapMarket;\n', '        uniswapMarket12 = get(configs, 12).uniswapMarket;\n', '        uniswapMarket13 = get(configs, 13).uniswapMarket;\n', '        uniswapMarket14 = get(configs, 14).uniswapMarket;\n', '        uniswapMarket15 = get(configs, 15).uniswapMarket;\n', '        uniswapMarket16 = get(configs, 16).uniswapMarket;\n', '        uniswapMarket17 = get(configs, 17).uniswapMarket;\n', '        uniswapMarket18 = get(configs, 18).uniswapMarket;\n', '        uniswapMarket19 = get(configs, 19).uniswapMarket;\n', '        uniswapMarket20 = get(configs, 20).uniswapMarket;\n', '        uniswapMarket21 = get(configs, 21).uniswapMarket;\n', '        uniswapMarket22 = get(configs, 22).uniswapMarket;\n', '        uniswapMarket23 = get(configs, 23).uniswapMarket;\n', '        uniswapMarket24 = get(configs, 24).uniswapMarket;\n', '        uniswapMarket25 = get(configs, 25).uniswapMarket;\n', '        uniswapMarket26 = get(configs, 26).uniswapMarket;\n', '        uniswapMarket27 = get(configs, 27).uniswapMarket;\n', '        uniswapMarket28 = get(configs, 28).uniswapMarket;\n', '        uniswapMarket29 = get(configs, 29).uniswapMarket;\n', '\n', '        isUniswapReversed00 = get(configs, 0).isUniswapReversed;\n', '        isUniswapReversed01 = get(configs, 1).isUniswapReversed;\n', '        isUniswapReversed02 = get(configs, 2).isUniswapReversed;\n', '        isUniswapReversed03 = get(configs, 3).isUniswapReversed;\n', '        isUniswapReversed04 = get(configs, 4).isUniswapReversed;\n', '        isUniswapReversed05 = get(configs, 5).isUniswapReversed;\n', '        isUniswapReversed06 = get(configs, 6).isUniswapReversed;\n', '        isUniswapReversed07 = get(configs, 7).isUniswapReversed;\n', '        isUniswapReversed08 = get(configs, 8).isUniswapReversed;\n', '        isUniswapReversed09 = get(configs, 9).isUniswapReversed;\n', '        isUniswapReversed10 = get(configs, 10).isUniswapReversed;\n', '        isUniswapReversed11 = get(configs, 11).isUniswapReversed;\n', '        isUniswapReversed12 = get(configs, 12).isUniswapReversed;\n', '        isUniswapReversed13 = get(configs, 13).isUniswapReversed;\n', '        isUniswapReversed14 = get(configs, 14).isUniswapReversed;\n', '        isUniswapReversed15 = get(configs, 15).isUniswapReversed;\n', '        isUniswapReversed16 = get(configs, 16).isUniswapReversed;\n', '        isUniswapReversed17 = get(configs, 17).isUniswapReversed;\n', '        isUniswapReversed18 = get(configs, 18).isUniswapReversed;\n', '        isUniswapReversed19 = get(configs, 19).isUniswapReversed;\n', '        isUniswapReversed20 = get(configs, 20).isUniswapReversed;\n', '        isUniswapReversed21 = get(configs, 21).isUniswapReversed;\n', '        isUniswapReversed22 = get(configs, 22).isUniswapReversed;\n', '        isUniswapReversed23 = get(configs, 23).isUniswapReversed;\n', '        isUniswapReversed24 = get(configs, 24).isUniswapReversed;\n', '        isUniswapReversed25 = get(configs, 25).isUniswapReversed;\n', '        isUniswapReversed26 = get(configs, 26).isUniswapReversed;\n', '        isUniswapReversed27 = get(configs, 27).isUniswapReversed;\n', '        isUniswapReversed28 = get(configs, 28).isUniswapReversed;\n', '        isUniswapReversed29 = get(configs, 29).isUniswapReversed;\n', '    }\n', '\n', '    function get(TokenConfig[] memory configs, uint i) internal pure returns (TokenConfig memory) {\n', '        if (i < configs.length)\n', '            return configs[i];\n', '        return TokenConfig({\n', '            cToken: address(0),\n', '            underlying: address(0),\n', '            symbolHash: bytes32(0),\n', '            baseUnit: uint256(0),\n', '            priceSource: PriceSource(0),\n', '            fixedPrice: uint256(0),\n', '            uniswapMarket: address(0),\n', '            isUniswapReversed: false\n', '        });\n', '    }\n', '\n', '    function getCTokenIndex(address cToken) internal view returns (uint) {\n', '        if (cToken == cToken00) return 0;\n', '        if (cToken == cToken01) return 1;\n', '        if (cToken == cToken02) return 2;\n', '        if (cToken == cToken03) return 3;\n', '        if (cToken == cToken04) return 4;\n', '        if (cToken == cToken05) return 5;\n', '        if (cToken == cToken06) return 6;\n', '        if (cToken == cToken07) return 7;\n', '        if (cToken == cToken08) return 8;\n', '        if (cToken == cToken09) return 9;\n', '        if (cToken == cToken10) return 10;\n', '        if (cToken == cToken11) return 11;\n', '        if (cToken == cToken12) return 12;\n', '        if (cToken == cToken13) return 13;\n', '        if (cToken == cToken14) return 14;\n', '        if (cToken == cToken15) return 15;\n', '        if (cToken == cToken16) return 16;\n', '        if (cToken == cToken17) return 17;\n', '        if (cToken == cToken18) return 18;\n', '        if (cToken == cToken19) return 19;\n', '        if (cToken == cToken20) return 20;\n', '        if (cToken == cToken21) return 21;\n', '        if (cToken == cToken22) return 22;\n', '        if (cToken == cToken23) return 23;\n', '        if (cToken == cToken24) return 24;\n', '        if (cToken == cToken25) return 25;\n', '        if (cToken == cToken26) return 26;\n', '        if (cToken == cToken27) return 27;\n', '        if (cToken == cToken28) return 28;\n', '        if (cToken == cToken29) return 29;\n', '\n', '        return uint(-1);\n', '    }\n', '\n', '    function getUnderlyingIndex(address underlying) internal view returns (uint) {\n', '        if (underlying == underlying00) return 0;\n', '        if (underlying == underlying01) return 1;\n', '        if (underlying == underlying02) return 2;\n', '        if (underlying == underlying03) return 3;\n', '        if (underlying == underlying04) return 4;\n', '        if (underlying == underlying05) return 5;\n', '        if (underlying == underlying06) return 6;\n', '        if (underlying == underlying07) return 7;\n', '        if (underlying == underlying08) return 8;\n', '        if (underlying == underlying09) return 9;\n', '        if (underlying == underlying10) return 10;\n', '        if (underlying == underlying11) return 11;\n', '        if (underlying == underlying12) return 12;\n', '        if (underlying == underlying13) return 13;\n', '        if (underlying == underlying14) return 14;\n', '        if (underlying == underlying15) return 15;\n', '        if (underlying == underlying16) return 16;\n', '        if (underlying == underlying17) return 17;\n', '        if (underlying == underlying18) return 18;\n', '        if (underlying == underlying19) return 19;\n', '        if (underlying == underlying20) return 20;\n', '        if (underlying == underlying21) return 21;\n', '        if (underlying == underlying22) return 22;\n', '        if (underlying == underlying23) return 23;\n', '        if (underlying == underlying24) return 24;\n', '        if (underlying == underlying25) return 25;\n', '        if (underlying == underlying26) return 26;\n', '        if (underlying == underlying27) return 27;\n', '        if (underlying == underlying28) return 28;\n', '        if (underlying == underlying29) return 29;\n', '\n', '        return uint(-1);\n', '    }\n', '\n', '    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\n', '        if (symbolHash == symbolHash00) return 0;\n', '        if (symbolHash == symbolHash01) return 1;\n', '        if (symbolHash == symbolHash02) return 2;\n', '        if (symbolHash == symbolHash03) return 3;\n', '        if (symbolHash == symbolHash04) return 4;\n', '        if (symbolHash == symbolHash05) return 5;\n', '        if (symbolHash == symbolHash06) return 6;\n', '        if (symbolHash == symbolHash07) return 7;\n', '        if (symbolHash == symbolHash08) return 8;\n', '        if (symbolHash == symbolHash09) return 9;\n', '        if (symbolHash == symbolHash10) return 10;\n', '        if (symbolHash == symbolHash11) return 11;\n', '        if (symbolHash == symbolHash12) return 12;\n', '        if (symbolHash == symbolHash13) return 13;\n', '        if (symbolHash == symbolHash14) return 14;\n', '        if (symbolHash == symbolHash15) return 15;\n', '        if (symbolHash == symbolHash16) return 16;\n', '        if (symbolHash == symbolHash17) return 17;\n', '        if (symbolHash == symbolHash18) return 18;\n', '        if (symbolHash == symbolHash19) return 19;\n', '        if (symbolHash == symbolHash20) return 20;\n', '        if (symbolHash == symbolHash21) return 21;\n', '        if (symbolHash == symbolHash22) return 22;\n', '        if (symbolHash == symbolHash23) return 23;\n', '        if (symbolHash == symbolHash24) return 24;\n', '        if (symbolHash == symbolHash25) return 25;\n', '        if (symbolHash == symbolHash26) return 26;\n', '        if (symbolHash == symbolHash27) return 27;\n', '        if (symbolHash == symbolHash28) return 28;\n', '        if (symbolHash == symbolHash29) return 29;\n', '\n', '        return uint(-1);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the i-th config, according to the order they were passed in originally\n', '     * @param i The index of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\n', '        require(i < numTokens, "token config not found");\n', '\n', '        if (i == 0) return TokenConfig({cToken: cToken00, underlying: underlying00, symbolHash: symbolHash00, baseUnit: baseUnit00, priceSource: priceSource00, fixedPrice: fixedPrice00, uniswapMarket: uniswapMarket00, isUniswapReversed: isUniswapReversed00});\n', '        if (i == 1) return TokenConfig({cToken: cToken01, underlying: underlying01, symbolHash: symbolHash01, baseUnit: baseUnit01, priceSource: priceSource01, fixedPrice: fixedPrice01, uniswapMarket: uniswapMarket01, isUniswapReversed: isUniswapReversed01});\n', '        if (i == 2) return TokenConfig({cToken: cToken02, underlying: underlying02, symbolHash: symbolHash02, baseUnit: baseUnit02, priceSource: priceSource02, fixedPrice: fixedPrice02, uniswapMarket: uniswapMarket02, isUniswapReversed: isUniswapReversed02});\n', '        if (i == 3) return TokenConfig({cToken: cToken03, underlying: underlying03, symbolHash: symbolHash03, baseUnit: baseUnit03, priceSource: priceSource03, fixedPrice: fixedPrice03, uniswapMarket: uniswapMarket03, isUniswapReversed: isUniswapReversed03});\n', '        if (i == 4) return TokenConfig({cToken: cToken04, underlying: underlying04, symbolHash: symbolHash04, baseUnit: baseUnit04, priceSource: priceSource04, fixedPrice: fixedPrice04, uniswapMarket: uniswapMarket04, isUniswapReversed: isUniswapReversed04});\n', '        if (i == 5) return TokenConfig({cToken: cToken05, underlying: underlying05, symbolHash: symbolHash05, baseUnit: baseUnit05, priceSource: priceSource05, fixedPrice: fixedPrice05, uniswapMarket: uniswapMarket05, isUniswapReversed: isUniswapReversed05});\n', '        if (i == 6) return TokenConfig({cToken: cToken06, underlying: underlying06, symbolHash: symbolHash06, baseUnit: baseUnit06, priceSource: priceSource06, fixedPrice: fixedPrice06, uniswapMarket: uniswapMarket06, isUniswapReversed: isUniswapReversed06});\n', '        if (i == 7) return TokenConfig({cToken: cToken07, underlying: underlying07, symbolHash: symbolHash07, baseUnit: baseUnit07, priceSource: priceSource07, fixedPrice: fixedPrice07, uniswapMarket: uniswapMarket07, isUniswapReversed: isUniswapReversed07});\n', '        if (i == 8) return TokenConfig({cToken: cToken08, underlying: underlying08, symbolHash: symbolHash08, baseUnit: baseUnit08, priceSource: priceSource08, fixedPrice: fixedPrice08, uniswapMarket: uniswapMarket08, isUniswapReversed: isUniswapReversed08});\n', '        if (i == 9) return TokenConfig({cToken: cToken09, underlying: underlying09, symbolHash: symbolHash09, baseUnit: baseUnit09, priceSource: priceSource09, fixedPrice: fixedPrice09, uniswapMarket: uniswapMarket09, isUniswapReversed: isUniswapReversed09});\n', '\n', '        if (i == 10) return TokenConfig({cToken: cToken10, underlying: underlying10, symbolHash: symbolHash10, baseUnit: baseUnit10, priceSource: priceSource10, fixedPrice: fixedPrice10, uniswapMarket: uniswapMarket10, isUniswapReversed: isUniswapReversed10});\n', '        if (i == 11) return TokenConfig({cToken: cToken11, underlying: underlying11, symbolHash: symbolHash11, baseUnit: baseUnit11, priceSource: priceSource11, fixedPrice: fixedPrice11, uniswapMarket: uniswapMarket11, isUniswapReversed: isUniswapReversed11});\n', '        if (i == 12) return TokenConfig({cToken: cToken12, underlying: underlying12, symbolHash: symbolHash12, baseUnit: baseUnit12, priceSource: priceSource12, fixedPrice: fixedPrice12, uniswapMarket: uniswapMarket12, isUniswapReversed: isUniswapReversed12});\n', '        if (i == 13) return TokenConfig({cToken: cToken13, underlying: underlying13, symbolHash: symbolHash13, baseUnit: baseUnit13, priceSource: priceSource13, fixedPrice: fixedPrice13, uniswapMarket: uniswapMarket13, isUniswapReversed: isUniswapReversed13});\n', '        if (i == 14) return TokenConfig({cToken: cToken14, underlying: underlying14, symbolHash: symbolHash14, baseUnit: baseUnit14, priceSource: priceSource14, fixedPrice: fixedPrice14, uniswapMarket: uniswapMarket14, isUniswapReversed: isUniswapReversed14});\n', '        if (i == 15) return TokenConfig({cToken: cToken15, underlying: underlying15, symbolHash: symbolHash15, baseUnit: baseUnit15, priceSource: priceSource15, fixedPrice: fixedPrice15, uniswapMarket: uniswapMarket15, isUniswapReversed: isUniswapReversed15});\n', '        if (i == 16) return TokenConfig({cToken: cToken16, underlying: underlying16, symbolHash: symbolHash16, baseUnit: baseUnit16, priceSource: priceSource16, fixedPrice: fixedPrice16, uniswapMarket: uniswapMarket16, isUniswapReversed: isUniswapReversed16});\n', '        if (i == 17) return TokenConfig({cToken: cToken17, underlying: underlying17, symbolHash: symbolHash17, baseUnit: baseUnit17, priceSource: priceSource17, fixedPrice: fixedPrice17, uniswapMarket: uniswapMarket17, isUniswapReversed: isUniswapReversed17});\n', '        if (i == 18) return TokenConfig({cToken: cToken18, underlying: underlying18, symbolHash: symbolHash18, baseUnit: baseUnit18, priceSource: priceSource18, fixedPrice: fixedPrice18, uniswapMarket: uniswapMarket18, isUniswapReversed: isUniswapReversed18});\n', '        if (i == 19) return TokenConfig({cToken: cToken19, underlying: underlying19, symbolHash: symbolHash19, baseUnit: baseUnit19, priceSource: priceSource19, fixedPrice: fixedPrice19, uniswapMarket: uniswapMarket19, isUniswapReversed: isUniswapReversed19});\n', '\n', '        if (i == 20) return TokenConfig({cToken: cToken20, underlying: underlying20, symbolHash: symbolHash20, baseUnit: baseUnit20, priceSource: priceSource20, fixedPrice: fixedPrice20, uniswapMarket: uniswapMarket20, isUniswapReversed: isUniswapReversed20});\n', '        if (i == 21) return TokenConfig({cToken: cToken21, underlying: underlying21, symbolHash: symbolHash21, baseUnit: baseUnit21, priceSource: priceSource21, fixedPrice: fixedPrice21, uniswapMarket: uniswapMarket21, isUniswapReversed: isUniswapReversed21});\n', '        if (i == 22) return TokenConfig({cToken: cToken22, underlying: underlying22, symbolHash: symbolHash22, baseUnit: baseUnit22, priceSource: priceSource22, fixedPrice: fixedPrice22, uniswapMarket: uniswapMarket22, isUniswapReversed: isUniswapReversed22});\n', '        if (i == 23) return TokenConfig({cToken: cToken23, underlying: underlying23, symbolHash: symbolHash23, baseUnit: baseUnit23, priceSource: priceSource23, fixedPrice: fixedPrice23, uniswapMarket: uniswapMarket23, isUniswapReversed: isUniswapReversed23});\n', '        if (i == 24) return TokenConfig({cToken: cToken24, underlying: underlying24, symbolHash: symbolHash24, baseUnit: baseUnit24, priceSource: priceSource24, fixedPrice: fixedPrice24, uniswapMarket: uniswapMarket24, isUniswapReversed: isUniswapReversed24});\n', '        if (i == 25) return TokenConfig({cToken: cToken25, underlying: underlying25, symbolHash: symbolHash25, baseUnit: baseUnit25, priceSource: priceSource25, fixedPrice: fixedPrice25, uniswapMarket: uniswapMarket25, isUniswapReversed: isUniswapReversed25});\n', '        if (i == 26) return TokenConfig({cToken: cToken26, underlying: underlying26, symbolHash: symbolHash26, baseUnit: baseUnit26, priceSource: priceSource26, fixedPrice: fixedPrice26, uniswapMarket: uniswapMarket26, isUniswapReversed: isUniswapReversed26});\n', '        if (i == 27) return TokenConfig({cToken: cToken27, underlying: underlying27, symbolHash: symbolHash27, baseUnit: baseUnit27, priceSource: priceSource27, fixedPrice: fixedPrice27, uniswapMarket: uniswapMarket27, isUniswapReversed: isUniswapReversed27});\n', '        if (i == 28) return TokenConfig({cToken: cToken28, underlying: underlying28, symbolHash: symbolHash28, baseUnit: baseUnit28, priceSource: priceSource28, fixedPrice: fixedPrice28, uniswapMarket: uniswapMarket28, isUniswapReversed: isUniswapReversed28});\n', '        if (i == 29) return TokenConfig({cToken: cToken29, underlying: underlying29, symbolHash: symbolHash29, baseUnit: baseUnit29, priceSource: priceSource29, fixedPrice: fixedPrice29, uniswapMarket: uniswapMarket29, isUniswapReversed: isUniswapReversed29});\n', '    }\n', '\n', '    /**\n', '     * @notice Get the config for symbol\n', '     * @param symbol The symbol of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\n', '        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\n', '    }\n', '\n', '    /**\n', '     * @notice Get the config for the symbolHash\n', '     * @param symbolHash The keccack256 of the symbol of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\n', '        uint index = getSymbolHashIndex(symbolHash);\n', '        if (index != uint(-1)) {\n', '            return getTokenConfig(index);\n', '        }\n', '\n', '        revert("token config not found");\n', '    }\n', '\n', '    /**\n', '     * @notice Get the config for the cToken\n', '     * @dev If a config for the cToken is not found, falls back to searching for the underlying.\n', '     * @param cToken The address of the cToken of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfigByCToken(address cToken) public view returns (TokenConfig memory) {\n', '        uint index = getCTokenIndex(cToken);\n', '        if (index != uint(-1)) {\n', '            return getTokenConfig(index);\n', '        }\n', '\n', '        return getTokenConfigByUnderlying(CErc20(cToken).underlying());\n', '    }\n', '\n', '    /**\n', '     * @notice Get the config for an underlying asset\n', '     * @param underlying The address of the underlying asset of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\n', '        uint index = getUnderlyingIndex(underlying);\n', '        if (index != uint(-1)) {\n', '            return getTokenConfig(index);\n', '        }\n', '\n', '        revert("token config not found");\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '// Based on code from https://github.com/Uniswap/uniswap-v2-periphery\n', '\n', '// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n', 'library FixedPoint {\n', '    // range: [0, 2**112 - 1]\n', '    // resolution: 1 / 2**112\n', '    struct uq112x112 {\n', '        uint224 _x;\n', '    }\n', '\n', '    // returns a uq112x112 which represents the ratio of the numerator to the denominator\n', '    // equivalent to encode(numerator).div(denominator)\n', '    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n', '        require(denominator > 0, "FixedPoint: DIV_BY_ZERO");\n', '        return uq112x112((uint224(numerator) << 112) / denominator);\n', '    }\n', '\n', '    // decode a uq112x112 into a uint with 18 decimals of precision\n', '    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\n', '        // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\n', '        // instead, get close to:\n', '        //  (x * 1e18) >> 112\n', '        // without risk of overflowing, e.g.:\n', '        //  (x) / 2 ** (112 - lg(1e18))\n', '        return uint(self._x) / 5192296858534827;\n', '    }\n', '}\n', '\n', '// library with helper methods for oracles that are concerned with computing average prices\n', 'library UniswapV2OracleLibrary {\n', '    using FixedPoint for *;\n', '\n', '    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n', '    function currentBlockTimestamp() internal view returns (uint32) {\n', '        return uint32(block.timestamp % 2 ** 32);\n', '    }\n', '\n', '    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n', '    function currentCumulativePrices(\n', '        address pair\n', '    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n', '        blockTimestamp = currentBlockTimestamp();\n', '        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n', '        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n', '\n', '        // if time has elapsed since the last update on the pair, mock the accumulated price values\n', '        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n', '        if (blockTimestampLast != blockTimestamp) {\n', '            // subtraction overflow is desired\n', '            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n', '            // addition overflow is desired\n', '            // counterfactual\n', '            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n', '            // counterfactual\n', '            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n', '        }\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '}\n', '\n', '\n', 'struct Observation {\n', '    uint timestamp;\n', '    uint acc;\n', '}\n', '\n', 'contract UniswapAnchoredView is UniswapConfig {\n', '    using FixedPoint for *;\n', '\n', '    /// @notice The Open Oracle Price Data contract\n', '    OpenOraclePriceData public immutable priceData;\n', '\n', '    /// @notice The number of wei in 1 ETH\n', '    uint public constant ethBaseUnit = 1e18;\n', '\n', '    /// @notice A common scaling factor to maintain precision\n', '    uint public constant expScale = 1e18;\n', '\n', '    /// @notice The Open Oracle Reporter\n', '    address public immutable reporter;\n', '\n', '    /// @notice The highest ratio of the new price to the anchor price that will still trigger the price to be updated\n', '    uint public immutable upperBoundAnchorRatio;\n', '\n', '    /// @notice The lowest ratio of the new price to the anchor price that will still trigger the price to be updated\n', '    uint public immutable lowerBoundAnchorRatio;\n', '\n', '    /// @notice The minimum amount of time in seconds required for the old uniswap price accumulator to be replaced\n', '    uint public immutable anchorPeriod;\n', '\n', '    /// @notice Official prices by symbol hash\n', '    mapping(bytes32 => uint) public prices;\n', '\n', '    /// @notice Circuit breaker for using anchor price oracle directly, ignoring reporter\n', '    bool public reporterInvalidated;\n', '\n', '    /// @notice The old observation for each symbolHash\n', '    mapping(bytes32 => Observation) public oldObservations;\n', '\n', '    /// @notice The new observation for each symbolHash\n', '    mapping(bytes32 => Observation) public newObservations;\n', '\n', '    /// @notice The event emitted when new prices are posted but the stored price is not updated due to the anchor\n', '    event PriceGuarded(string symbol, uint reporter, uint anchor);\n', '\n', '    /// @notice The event emitted when the stored price is updated\n', '    event PriceUpdated(string symbol, uint price);\n', '\n', '    /// @notice The event emitted when anchor price is updated\n', '    event AnchorPriceUpdated(string symbol, uint anchorPrice, uint oldTimestamp, uint newTimestamp);\n', '\n', '    /// @notice The event emitted when the uniswap window changes\n', '    event UniswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\n', '\n', '    /// @notice The event emitted when reporter invalidates itself\n', '    event ReporterInvalidated(address reporter);\n', '\n', '    bytes32 constant ethHash = keccak256(abi.encodePacked("ETH"));\n', '    bytes32 constant rotateHash = keccak256(abi.encodePacked("rotate"));\n', '\n', '    /**\n', '     * @notice Construct a uniswap anchored view for a set of token configurations\n', '     * @dev Note that to avoid immature TWAPs, the system must run for at least a single anchorPeriod before using.\n', '     * @param reporter_ The reporter whose prices are to be used\n', '     * @param anchorToleranceMantissa_ The percentage tolerance that the reporter may deviate from the uniswap anchor\n', '     * @param anchorPeriod_ The minimum amount of time required for the old uniswap price accumulator to be replaced\n', '     * @param configs The static token configurations which define what prices are supported and how\n', '     */\n', '    constructor(OpenOraclePriceData priceData_,\n', '                address reporter_,\n', '                uint anchorToleranceMantissa_,\n', '                uint anchorPeriod_,\n', '                TokenConfig[] memory configs) UniswapConfig(configs) public {\n', '        priceData = priceData_;\n', '        reporter = reporter_;\n', '        anchorPeriod = anchorPeriod_;\n', '\n', '        // Allow the tolerance to be whatever the deployer chooses, but prevent under/overflow (and prices from being 0)\n', '        upperBoundAnchorRatio = anchorToleranceMantissa_ > uint(-1) - 100e16 ? uint(-1) : 100e16 + anchorToleranceMantissa_;\n', '        lowerBoundAnchorRatio = anchorToleranceMantissa_ < 100e16 ? 100e16 - anchorToleranceMantissa_ : 1;\n', '\n', '        for (uint i = 0; i < configs.length; i++) {\n', '            TokenConfig memory config = configs[i];\n', '            require(config.baseUnit > 0, "baseUnit must be greater than zero");\n', '            address uniswapMarket = config.uniswapMarket;\n', '            if (config.priceSource == PriceSource.REPORTER) {\n', '                require(uniswapMarket != address(0), "reported prices must have an anchor");\n', '                bytes32 symbolHash = config.symbolHash;\n', '                uint cumulativePrice = currentCumulativePrice(config);\n', '                oldObservations[symbolHash].timestamp = block.timestamp;\n', '                newObservations[symbolHash].timestamp = block.timestamp;\n', '                oldObservations[symbolHash].acc = cumulativePrice;\n', '                newObservations[symbolHash].acc = cumulativePrice;\n', '                emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\n', '            } else {\n', '                require(uniswapMarket == address(0), "only reported prices utilize an anchor");\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Get the official price for a symbol\n', '     * @param symbol The symbol to fetch the price of\n', '     * @return Price denominated in USD, with 6 decimals\n', '     */\n', '    function price(string memory symbol) external view returns (uint) {\n', '        TokenConfig memory config = getTokenConfigBySymbol(symbol);\n', '        return priceInternal(config);\n', '    }\n', '\n', '    function priceInternal(TokenConfig memory config) internal view returns (uint) {\n', '        if (config.priceSource == PriceSource.REPORTER) return prices[config.symbolHash];\n', '        if (config.priceSource == PriceSource.FIXED_USD) return config.fixedPrice;\n', '        if (config.priceSource == PriceSource.FIXED_ETH) {\n', '            uint usdPerEth = prices[ethHash];\n', '            require(usdPerEth > 0, "ETH price not set, cannot convert to dollars");\n', '            return mul(usdPerEth, config.fixedPrice) / ethBaseUnit;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Get the underlying price of a cToken\n', '     * @dev Implements the PriceOracle interface for Compound v2.\n', '     * @param cToken The cToken address for price retrieval\n', '     * @return Price denominated in USD, with 18 decimals, for the given cToken address\n', '     */\n', '    function getUnderlyingPrice(address cToken) external view returns (uint) {\n', '        TokenConfig memory config = getTokenConfigByCToken(cToken);\n', '         // Comptroller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\n', '         // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6 - baseUnit)\n', '        return mul(1e30, priceInternal(config)) / config.baseUnit;\n', '    }\n', '\n', '    /**\n', '     * @notice Post open oracle reporter prices, and recalculate stored price by comparing to anchor\n', '     * @dev We let anyone pay to post anything, but only prices from configured reporter will be stored in the view.\n', '     * @param messages The messages to post to the oracle\n', '     * @param signatures The signatures for the corresponding messages\n', '     * @param symbols The symbols to compare to anchor for authoritative reading\n', '     */\n', '    function postPrices(bytes[] calldata messages, bytes[] calldata signatures, string[] calldata symbols) external {\n', '        require(messages.length == signatures.length, "messages and signatures must be 1:1");\n', '\n', '        // Save the prices\n', '        for (uint i = 0; i < messages.length; i++) {\n', '            priceData.put(messages[i], signatures[i]);\n', '        }\n', '\n', '        uint ethPrice = fetchEthPrice();\n', '\n', '        // Try to update the view storage\n', '        for (uint i = 0; i < symbols.length; i++) {\n', '            postPriceInternal(symbols[i], ethPrice);\n', '        }\n', '    }\n', '\n', '    function postPriceInternal(string memory symbol, uint ethPrice) internal {\n', '        TokenConfig memory config = getTokenConfigBySymbol(symbol);\n', '        require(config.priceSource == PriceSource.REPORTER, "only reporter prices get posted");\n', '\n', '        bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\n', '        uint reporterPrice = priceData.getPrice(reporter, symbol);\n', '        uint anchorPrice;\n', '        if (symbolHash == ethHash) {\n', '            anchorPrice = ethPrice;\n', '        } else {\n', '            anchorPrice = fetchAnchorPrice(symbol, config, ethPrice);\n', '        }\n', '\n', '        if (reporterInvalidated) {\n', '            prices[symbolHash] = anchorPrice;\n', '            emit PriceUpdated(symbol, anchorPrice);\n', '        } else if (isWithinAnchor(reporterPrice, anchorPrice)) {\n', '            prices[symbolHash] = reporterPrice;\n', '            emit PriceUpdated(symbol, reporterPrice);\n', '        } else {\n', '            emit PriceGuarded(symbol, reporterPrice, anchorPrice);\n', '        }\n', '    }\n', '\n', '    function isWithinAnchor(uint reporterPrice, uint anchorPrice) internal view returns (bool) {\n', '        if (reporterPrice > 0) {\n', '            uint anchorRatio = mul(anchorPrice, 100e16) / reporterPrice;\n', '            return anchorRatio <= upperBoundAnchorRatio && anchorRatio >= lowerBoundAnchorRatio;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Fetches the current token/eth price accumulator from uniswap.\n', '     */\n', '    function currentCumulativePrice(TokenConfig memory config) internal view returns (uint) {\n', '        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\n', '        if (config.isUniswapReversed) {\n', '            return cumulativePrice1;\n', '        } else {\n', '            return cumulativePrice0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Fetches the current eth/usd price from uniswap, with 6 decimals of precision.\n', '     *  Conversion factor is 1e18 for eth/usdc market, since we decode uniswap price statically with 18 decimals.\n', '     */\n', '    function fetchEthPrice() internal returns (uint) {\n', '        return fetchAnchorPrice("ETH", getTokenConfigBySymbolHash(ethHash), ethBaseUnit);\n', '    }\n', '\n', '    /**\n', '     * @dev Fetches the current token/usd price from uniswap, with 6 decimals of precision.\n', '     * @param conversionFactor 1e18 if seeking the ETH price, and a 6 decimal ETH-USDC price in the case of other assets\n', '     */\n', '    function fetchAnchorPrice(string memory symbol, TokenConfig memory config, uint conversionFactor) internal virtual returns (uint) {\n', '        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\n', '\n', '        // This should be impossible, but better safe than sorry\n', '        require(block.timestamp > oldTimestamp, "now must come after before");\n', '        uint timeElapsed = block.timestamp - oldTimestamp;\n', '\n', '        // Calculate uniswap time-weighted average price\n', '        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\n', '        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\n', '        uint rawUniswapPriceMantissa = priceAverage.decode112with18();\n', '        uint unscaledPriceMantissa = mul(rawUniswapPriceMantissa, conversionFactor);\n', '        uint anchorPrice;\n', '\n', '        // Adjust rawUniswapPrice according to the units of the non-ETH asset\n', '        // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\n', '        if (config.isUniswapReversed) {\n', '            // unscaledPriceMantissa * ethBaseUnit / config.baseUnit / expScale, but we simplify bc ethBaseUnit == expScale\n', '            anchorPrice = unscaledPriceMantissa / config.baseUnit;\n', '        } else {\n', '            anchorPrice = mul(unscaledPriceMantissa, config.baseUnit) / ethBaseUnit / expScale;\n', '        }\n', '\n', '        emit AnchorPriceUpdated(symbol, anchorPrice, oldTimestamp, block.timestamp);\n', '\n', '        return anchorPrice;\n', '    }\n', '\n', '    /**\n', '     * @dev Get time-weighted average prices for a token at the current timestamp.\n', '     *  Update new and old observations of lagging window if period elapsed.\n', '     */\n', '    function pokeWindowValues(TokenConfig memory config) internal returns (uint, uint, uint) {\n', '        bytes32 symbolHash = config.symbolHash;\n', '        uint cumulativePrice = currentCumulativePrice(config);\n', '\n', '        Observation memory newObservation = newObservations[symbolHash];\n', '\n', '        // Update new and old observations if elapsed time is greater than or equal to anchor period\n', '        uint timeElapsed = block.timestamp - newObservation.timestamp;\n', '        if (timeElapsed >= anchorPeriod) {\n', '            oldObservations[symbolHash].timestamp = newObservation.timestamp;\n', '            oldObservations[symbolHash].acc = newObservation.acc;\n', '\n', '            newObservations[symbolHash].timestamp = block.timestamp;\n', '            newObservations[symbolHash].acc = cumulativePrice;\n', '            emit UniswapWindowUpdated(config.symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\n', '        }\n', '        return (cumulativePrice, oldObservations[symbolHash].acc, oldObservations[symbolHash].timestamp);\n', '    }\n', '\n', '    /**\n', '     * @notice Invalidate the reporter, and fall back to using anchor directly in all cases\n', '     * @dev Only the reporter may sign a message which allows it to invalidate itself.\n', '     *  To be used in cases of emergency, if the reporter thinks their key may be compromised.\n', '     * @param message The data that was presumably signed\n', '     * @param signature The fingerprint of the data + private key\n', '     */\n', '    function invalidateReporter(bytes memory message, bytes memory signature) external {\n', '        (string memory decodedMessage, ) = abi.decode(message, (string, address));\n', '        require(keccak256(abi.encodePacked(decodedMessage)) == rotateHash, "invalid message must be \'rotate\'");\n', '        require(source(message, signature) == reporter, "invalidation message must come from the reporter");\n', '        reporterInvalidated = true;\n', '        emit ReporterInvalidated(reporter);\n', '    }\n', '\n', '    /**\n', '     * @notice Recovers the source address which signed a message\n', '     * @dev Comparing to a claimed address would add nothing,\n', '     *  as the caller could simply perform the recover and claim that address.\n', '     * @param message The data that was presumably signed\n', '     * @param signature The fingerprint of the data + private key\n', '     * @return The source address which signed the message, presumably\n', '     */\n', '    function source(bytes memory message, bytes memory signature) public pure returns (address) {\n', '        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\n', '        bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(message)));\n', '        return ecrecover(hash, v, r, s);\n', '    }\n', '\n', '    /// @dev Overflow proof multiplication\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) return 0;\n', '        uint c = a * b;\n', '        require(c / a == b, "multiplication overflow");\n', '        return c;\n', '    }\n', '}']