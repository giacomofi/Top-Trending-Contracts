['// File: openzeppelin-solidity/contracts/cryptography/ECDSA.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n', ' *\n', ' * These functions can be used to verify that a message was signed by the holder\n', ' * of the private keys of a given address.\n', ' */\n', 'library ECDSA {\n', '    /**\n', '     * @dev Returns the address that signed a hashed message (`hash`) with\n', '     * `signature`. This address can then be used for verification purposes.\n', '     *\n', '     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n', '     * this function rejects them by requiring the `s` value to be in the lower\n', '     * half order, and the `v` value to be either 27 or 28.\n', '     *\n', '     * NOTE: This call _does not revert_ if the signature is invalid, or\n', '     * if the signer is otherwise unable to be retrieved. In those scenarios,\n', '     * the zero address is returned.\n', '     *\n', '     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n', '     * verification to be secure: it is possible to craft signatures that\n', '     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n', '     * this is by receiving a hash of the original message (which may otherwise\n', '     * be too long), and then calling {toEthSignedMessageHash} on it.\n', '     */\n', '    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n', '        // Check the signature length\n', '        if (signature.length != 65) {\n', '            return (address(0));\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '\n', '        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n', '        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n', '        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n', '        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n', '        //\n', '        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n', '        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n', '        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n', '        // these malleable signatures as well.\n', '        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n', '            return address(0);\n', '        }\n', '\n', '        if (v != 27 && v != 28) {\n', '            return address(0);\n', '        }\n', '\n', '        // If the signature is valid (and not malleable), return the signer address\n', '        return ecrecover(hash, v, r, s);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n', '     * replicates the behavior of the\n', '     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n', '     * JSON-RPC method.\n', '     *\n', '     * See {recover}.\n', '     */\n', '    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n', '        // 32 is the length in bytes of hash,\n', '        // enforced by the type signature above\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '}\n', '\n', '// File: contracts/roles/Roles.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    function add(Role storage role, address account) internal {\n', '        require(!has(role, account), "role already has the account");\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    function remove(Role storage role, address account) internal {\n', '        require(has(role, account), "role dosen\'t have the account");\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '// File: contracts/erc/ERC165.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'interface IERC165 {\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', '\n', '/// @title ERC-165 Standard Interface Detection\n', '/// @dev See https://eips.ethereum.org/EIPS/eip-165\n', 'contract ERC165 is IERC165 {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor () internal {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '// File: contracts/erc/ERC173.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/// @title ERC-173 Contract Ownership Standard\n', '/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md\n', '///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n', 'interface IERC173 /* is ERC165 */ {\n', '    /// @dev This emits when ownership of a contract changes.\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /// @notice Get the address of the owner\n', '    /// @return The address of the owner.\n', '    function owner() external view returns (address);\n', '\n', '    /// @notice Set the address of the new owner of the contract\n', '    /// @param _newOwner The address of the new owner of the contract\n', '    function transferOwnership(address _newOwner) external;\n', '}\n', '\n', 'contract ERC173 is IERC173, ERC165  {\n', '    address private _owner;\n', '\n', '    constructor() public {\n', '        _registerInterface(0x7f5828d0);\n', '        _transferOwnership(msg.sender);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner(), "Must be owner");\n', '        _;\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner() {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address _newOwner) internal {\n', '        address previousOwner = owner();\n', '\t_owner = _newOwner;\n', '        emit OwnershipTransferred(previousOwner, _newOwner);\n', '    }\n', '}\n', '\n', '// File: contracts/roles/Operatable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', 'contract Operatable is ERC173 {\n', '    using Roles for Roles.Role;\n', '\n', '    event OperatorAdded(address indexed account);\n', '    event OperatorRemoved(address indexed account);\n', '\n', '    event Paused(address account);\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '    Roles.Role private operators;\n', '\n', '    constructor() public {\n', '        operators.add(msg.sender);\n', '        _paused = false;\n', '    }\n', '\n', '    modifier onlyOperator() {\n', '        require(isOperator(msg.sender), "Must be operator");\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!_paused, "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused() {\n', '        require(_paused, "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOperator() {\n', '        _transferOwnership(_newOwner);\n', '    }\n', '\n', '    function isOperator(address account) public view returns (bool) {\n', '        return operators.has(account);\n', '    }\n', '\n', '    function addOperator(address account) public onlyOperator() {\n', '        operators.add(account);\n', '        emit OperatorAdded(account);\n', '    }\n', '\n', '    function removeOperator(address account) public onlyOperator() {\n', '        operators.remove(account);\n', '        emit OperatorRemoved(account);\n', '    }\n', '\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    function pause() public onlyOperator() whenNotPaused() {\n', '        _paused = true;\n', '        emit Paused(msg.sender);\n', '    }\n', '\n', '    function unpause() public onlyOperator() whenPaused() {\n', '        _paused = false;\n', '        emit Unpaused(msg.sender);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/roles/Withdrawable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', 'contract Withdrawable {\n', '    using Roles for Roles.Role;\n', '\n', '    event WithdrawerAdded(address indexed account);\n', '    event WithdrawerRemoved(address indexed account);\n', '\n', '    Roles.Role private withdrawers;\n', '\n', '    constructor() public {\n', '        withdrawers.add(msg.sender);\n', '    }\n', '\n', '    modifier onlyWithdrawer() {\n', '        require(isWithdrawer(msg.sender), "Must be withdrawer");\n', '        _;\n', '    }\n', '\n', '    function isWithdrawer(address account) public view returns (bool) {\n', '        return withdrawers.has(account);\n', '    }\n', '\n', '    function addWithdrawer(address account) public onlyWithdrawer() {\n', '        withdrawers.add(account);\n', '        emit WithdrawerAdded(account);\n', '    }\n', '\n', '    function removeWithdrawer(address account) public onlyWithdrawer() {\n', '        withdrawers.remove(account);\n', '        emit WithdrawerRemoved(account);\n', '    }\n', '\n', '    function withdrawEther() public onlyWithdrawer() {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/libraries/Uint256.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'library Uint256 {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "addition overflow");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(a >= b, "subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "division by 0");\n', '        return a / b;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "modulo by 0");\n', '        return a % b;\n', '    }\n', '\n', '    function toString(uint256 a) internal pure returns (string memory) {\n', '        bytes32 retBytes32;\n', '        uint256 len = 0;\n', '        if (a == 0) {\n', '            retBytes32 = "0";\n', '            len++;\n', '        } else {\n', '            uint256 value = a;\n', '            while (value > 0) {\n', '                retBytes32 = bytes32(uint256(retBytes32) / (2 ** 8));\n', '                retBytes32 |= bytes32(((value % 10) + 48) * 2 ** (8 * 31));\n', '                value /= 10;\n', '                len++;\n', '            }\n', '        }\n', '\n', '        bytes memory ret = new bytes(len);\n', '        uint256 i;\n', '\n', '        for (i = 0; i < len; i++) {\n', '            ret[i] = retBytes32[i];\n', '        }\n', '        return string(ret);\n', '    }\n', '}\n', '\n', '// File: contracts/SPLSPLGatewayV1.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '\n', 'interface GuildAsset {\n', '    function getTotalVolume(uint16 _guildType) external view returns (uint256);\n', '}\n', '\n', 'interface SPLGuildPool {\n', '    function addEthToGuildPool(uint16 _guildType, address _purchaseBy) external payable;\n', '}\n', '\n', 'interface IngameMoney {\n', '    function hashTransactedAt(bytes32 _hash) external view returns(uint256);\n', '    function buy(address payable _user, address payable _referrer, uint256 _referralBasisPoint, uint16 _guildType, bytes calldata _signature, bytes32 _hash) external payable;\n', '}\n', '\n', 'contract SPLSPLGatewayV1 is Operatable, Withdrawable, IngameMoney {\n', '    using Uint256 for uint256;\n', '    struct Campaign {\n', '        uint8 purchaseType;\n', '        uint8 subPurchaseType;\n', '        uint8 proxyPurchaseType;\n', '    }\n', '\n', '    uint8 constant PURCHASE_NORMAL = 0;\n', '    uint8 constant PURCHASE_ETH_BACK = 1;\n', '    uint8 constant PURCHASE_UP20 = 2;\n', '    uint8 constant PURCHASE_REGULAR = 3;\n', '    uint8 constant PURCHASE_ETH_BACK_UP20 = 4;\n', '\n', '    Campaign public campaign;\n', '\n', '    mapping(uint256 => bool) public payableOptions;\n', '    address public validater;\n', '\n', '    GuildAsset public guildAsset;\n', '    SPLGuildPool public guildPool;\n', '    uint256 public guildBasisPoint;\n', '\n', '    uint256 constant BASE = 10000;\n', '    uint256 private nonce;\n', '    uint16 public chanceDenom;\n', '    uint256 public ethBackBasisPoint;\n', '    bytes private salt;\n', '    mapping(bytes32 => uint256) private _hashTransactedAt;\n', '\n', '    event Sold(\n', '        address indexed user,\n', '        address indexed referrer,\n', '        uint8 purchaseType,\n', '        uint256 grossValue,\n', '        uint256 referralValue,\n', '        uint256 guildValue,\n', '        uint256 netValue,\n', '        uint16 indexed guildType\n', '    );\n', '\n', '    event CampaignUpdated(\n', '        uint8 purchaseType,\n', '        uint8 subPurchaseType,\n', '        uint8 proxyPurchaseType\n', '    );\n', '\n', '    event GuildBasisPointUpdated(\n', '        uint256 guildBasisPoint\n', '    );\n', '\n', '    constructor(\n', '        address _validater,\n', '        address _guildAssetAddress,\n', '        address payable _guildPoolAddress\n', '    ) public payable {\n', '        setValidater(_validater);\n', '        setGuildAssetAddress(_guildAssetAddress);\n', '        setGuildPoolAddress(_guildPoolAddress);\n', '        setCampaign(0, 0, 0);\n', '        updateGuildBasisPoint(1500);\n', '        updateEthBackBasisPoint(5000);\n', '        updateChance(25);\n', '        salt = bytes("iiNg4uJulaa4Yoh7");\n', '\n', '        nonce = 222;\n', '\n', '        // payableOptions[0] = true;\n', '        payableOptions[0.03 ether] = true;\n', '        payableOptions[0.05 ether] = true;\n', '        payableOptions[0.1 ether] = true;\n', '        payableOptions[0.5 ether] = true;\n', '        payableOptions[1 ether] = true;\n', '        payableOptions[5 ether] = true;\n', '        payableOptions[10 ether] = true;\n', '    }\n', '\n', '    function setValidater(address _varidater) public onlyOperator() {\n', '        validater = _varidater;\n', '    }\n', '\n', '    function setPayableOption(uint256 _option, bool desired) external onlyOperator() {\n', '        payableOptions[_option] = desired;\n', '    }\n', '\n', '    function setCampaign(\n', '        uint8 _purchaseType,\n', '        uint8 _subPurchaseType,\n', '        uint8 _proxyPurchaseType\n', '    )\n', '        public\n', '        onlyOperator()\n', '    {\n', '        campaign = Campaign(_purchaseType, _subPurchaseType, _proxyPurchaseType);\n', '        emit CampaignUpdated(_purchaseType, _subPurchaseType, _proxyPurchaseType);\n', '    }\n', '\n', '    function setGuildAssetAddress(address _guildAssetAddress) public onlyOwner() {\n', '        guildAsset = GuildAsset(_guildAssetAddress);\n', '    }\n', '\n', '    function setGuildPoolAddress(address payable _guildPoolAddress) public onlyOwner() {\n', '        guildPool = SPLGuildPool(_guildPoolAddress);\n', '    }\n', '\n', '    function updateGuildBasisPoint(uint256 _newGuildBasisPoint) public onlyOwner() {\n', '        guildBasisPoint = _newGuildBasisPoint;\n', '        emit GuildBasisPointUpdated(\n', '            guildBasisPoint\n', '        );\n', '    }\n', '\n', '    function updateChance(uint16 _newchanceDenom) public onlyOperator() {\n', '        chanceDenom = _newchanceDenom;\n', '    }\n', '\n', '    function updateEthBackBasisPoint(uint256 _ethBackBasisPoint) public onlyOperator() {\n', '        ethBackBasisPoint = _ethBackBasisPoint;\n', '    }\n', '\n', '    function buy(\n', '        address payable _user,\n', '        address payable _referrer,\n', '        uint256 _referralBasisPoint,\n', '        uint16 _guildType,\n', '        bytes memory _signature,\n', '        bytes32 _hash\n', '    )\n', '        public\n', '        payable\n', '        whenNotPaused()\n', '    {\n', '        require(_referralBasisPoint + ethBackBasisPoint + guildBasisPoint <= BASE, "Invalid basis points");\n', '        require(payableOptions[msg.value], "Invalid msg.value");\n', '        require(validateSig(encodeData(_user, _referrer, _referralBasisPoint, _guildType), _signature), "Invalid signature");\n', '        if (_hash != bytes32(0)) {\n', '            recordHash(_hash);\n', '        }\n', '        uint8 purchaseType = campaign.proxyPurchaseType;\n', '        uint256 netValue = msg.value;\n', '        uint256 referralValue = _referrerBack(_referrer, _referralBasisPoint);\n', '        uint256 guildValue = _guildPoolBack(_guildType);\n', '        netValue = msg.value.sub(referralValue).sub(guildValue);\n', '\n', '        emit Sold(\n', '            _user,\n', '            _referrer,\n', '            purchaseType,\n', '            msg.value,\n', '            referralValue,\n', '            guildValue,\n', '            netValue,\n', '            _guildType\n', '        );\n', '    }\n', '\n', '    function buySPL(\n', '        address payable _referrer,\n', '        uint256 _referralBasisPoint,\n', '        uint16 _guildType,\n', '        bytes memory _signature\n', '    )\n', '        public\n', '        payable\n', '    {\n', '        require(_referralBasisPoint + ethBackBasisPoint + guildBasisPoint <= BASE, "Invalid basis points");\n', '        require(payableOptions[msg.value], "Invalid msg.value");\n', '        require(validateSig(encodeData(msg.sender, _referrer, _referralBasisPoint, _guildType), _signature), "Invalid signature");\n', '\n', '        uint8 purchaseType = campaign.purchaseType;\n', '        uint256 netValue = msg.value;\n', '        uint256 referralValue = 0;\n', '        uint256 guildValue = 0;\n', '\n', '        if (purchaseType == PURCHASE_ETH_BACK || purchaseType == PURCHASE_ETH_BACK_UP20) {\n', '            if (getRandom(chanceDenom, nonce, msg.sender) == 0) {\n', '                uint256 ethBackValue = _ethBack(msg.sender, ethBackBasisPoint);\n', '                netValue = netValue.sub(ethBackValue);\n', '            } else {\n', '                purchaseType = campaign.subPurchaseType;\n', '                referralValue = _referrerBack(_referrer, _referralBasisPoint);\n', '                guildValue = _guildPoolBack(_guildType);\n', '                netValue = msg.value.sub(referralValue).sub(guildValue);\n', '            }\n', '            nonce++;\n', '        } else {\n', '            referralValue = _referrerBack(_referrer, _referralBasisPoint);\n', '            guildValue = _guildPoolBack(_guildType);\n', '            netValue = msg.value.sub(referralValue).sub(guildValue);\n', '        }\n', '\n', '        emit Sold(\n', '            msg.sender,\n', '            _referrer,\n', '            purchaseType,\n', '            msg.value,\n', '            referralValue,\n', '            guildValue,\n', '            netValue,\n', '            _guildType\n', '        );\n', '    }\n', '\n', '    function hashTransactedAt(bytes32 _hash) public view returns (uint256) {\n', '        return _hashTransactedAt[_hash];\n', '    }\n', '\n', '    function recordHash(bytes32 _hash) internal {\n', '        require(_hashTransactedAt[_hash] == 0, "The hash is already transacted");\n', '        _hashTransactedAt[_hash] = block.number;\n', '    }\n', '\n', '    function getRandom(uint16 max, uint256 _nonce, address _sender) public view returns (uint16) {\n', '        return uint16(\n', '            bytes2(\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        blockhash(block.number-1),\n', '                        _sender,\n', '                        _nonce,\n', '                        salt\n', '                    )\n', '                )\n', '            )\n', '        ) % max;\n', '    }\n', '\n', '    function _ethBack(address payable _buyer, uint256 _ethBackBasisPoint) internal returns (uint256) {\n', '        uint256 ethBackValue = msg.value.mul(_ethBackBasisPoint).div(BASE);\n', '        _buyer.transfer(ethBackValue);\n', '        return ethBackValue;\n', '    }\n', '\n', '    function _guildPoolBack(uint16 _guildType) internal returns (uint256) {\n', '        if(_guildType == 0) {\n', '            return 0;\n', '        }\n', '        require(guildAsset.getTotalVolume(_guildType) != 0, "Invalid _guildType");\n', '\n', '        uint256 guildValue;\n', '        guildValue = msg.value.mul(guildBasisPoint).div(BASE);\n', '        guildPool.addEthToGuildPool.value(guildValue)(_guildType, msg.sender);\n', '        return guildValue;\n', '    }\n', '\n', '    function _referrerBack(address payable _referrer, uint256 _referralBasisPoint) internal returns (uint256) {\n', '        if(_referrer == address(0x0) || _referrer == msg.sender) {\n', '            return 0;\n', '        }\n', '        uint256 referralValue = msg.value.mul(_referralBasisPoint).div(BASE);\n', '        _referrer.transfer(referralValue);\n', '        return referralValue;\n', '    }\n', '\n', '    function encodeData(address _sender, address _referrer, uint256 _referralBasisPoint, uint16 _guildType) public pure returns (bytes32) {\n', '        return keccak256(abi.encode(\n', '                            _sender,\n', '                            _referrer,\n', '                            _referralBasisPoint,\n', '                            _guildType\n', '                            )\n', '                    );\n', '    }\n', '\n', '    function validateSig(bytes32 _message, bytes memory _signature) public view returns (bool) {\n', '        require(validater != address(0), "validater must be set");\n', '        address signer = ECDSA.recover(ECDSA.toEthSignedMessageHash(_message), _signature);\n', '        return (signer == validater);\n', '    }\n', '\n', '    function recover(bytes32 _message, bytes memory _signature) public pure returns (address) {\n', '        address signer = ECDSA.recover(ECDSA.toEthSignedMessageHash(_message), _signature);\n', '        return signer;\n', '    }\n', '}']