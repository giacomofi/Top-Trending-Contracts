['pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface AccountInterface {\n', '    function isAuth(address user) external view returns (bool);\n', '    function sheild() external view returns (bool);\n', '    function version() external view returns (uint);\n', '}\n', '\n', 'interface ListInterface {\n', '    struct UserLink {\n', '        uint64 first;\n', '        uint64 last;\n', '        uint64 count;\n', '    }\n', '\n', '    struct UserList {\n', '        uint64 prev;\n', '        uint64 next;\n', '    }\n', '\n', '    struct AccountLink {\n', '        address first;\n', '        address last;\n', '        uint64 count;\n', '    }\n', '\n', '    struct AccountList {\n', '        address prev;\n', '        address next;\n', '    }\n', '\n', '    function accounts() external view returns (uint);\n', '    function accountID(address) external view returns (uint64);\n', '    function accountAddr(uint64) external view returns (address);\n', '    function userLink(address) external view returns (UserLink memory);\n', '    function userList(address, uint64) external view returns (UserList memory);\n', '    function accountLink(uint64) external view returns (AccountLink memory);\n', '    function accountList(uint64, address) external view returns (AccountList memory);\n', '\n', '}\n', '\n', 'interface IndexInterface {\n', '    function master() external view returns (address);\n', '    function list() external view returns (address);\n', '    function connectors(uint) external view returns (address);\n', '    function account(uint) external view returns (address);\n', '    function check(uint) external view returns (address);\n', '    function versionCount() external view returns (uint);\n', '}\n', '\n', 'interface ConnectorsInterface {\n', '    struct List {\n', '        address prev;\n', '        address next;\n', '    }\n', '    function chief(address) external view returns (bool);\n', '    function connectors(address) external view returns (bool);\n', '    function staticConnectors(address) external view returns (bool);\n', '\n', '    function connectorArray(uint) external view returns (address);\n', '    function connectorLength() external view returns (uint);\n', '    function staticConnectorArray(uint) external view returns (address);\n', '    function staticConnectorLength() external view returns (uint);\n', '    function connectorCount() external view returns (uint);\n', '\n', '    function isConnector(address[] calldata _connectors) external view returns (bool isOk);\n', '    function isStaticConnector(address[] calldata _connectors) external view returns (bool isOk);\n', '\n', '}\n', '\n', 'interface ConnectorInterface {\n', '    function name() external view returns (string memory);\n', '}\n', '\n', 'interface GnosisFactoryInterface {\n', '    function proxyRuntimeCode() external pure returns (bytes memory);\n', '}\n', '\n', '\n', 'contract Helpers {\n', '    address public index;\n', '    address public list;\n', '    address public connectors;\n', '    IndexInterface indexContract;\n', '    ListInterface listContract;\n', '    ConnectorsInterface connectorsContract;\n', '\n', '    GnosisFactoryInterface[] public gnosisFactoryContracts;\n', '\n', '    function getContractCode(address _addr) public view returns (bytes memory o_code) {\n', '        assembly {\n', '            // retrieve the size of the code, this needs assembly\n', '            let size := extcodesize(_addr)\n', '            // allocate output byte array - this could also be done without assembly\n', '            // by using o_code = new bytes(size)\n', '            o_code := mload(0x40)\n', '            // new "memory end" including padding\n', '            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n', '            // store length in memory\n', '            mstore(o_code, size)\n', '            // actually retrieve the code, this needs assembly\n', '            extcodecopy(_addr, add(o_code, 0x20), 0, size)\n', '        }\n', '    }\n', '}\n', '\n', 'contract AccountResolver is Helpers {\n', '\n', '    function getID(address account) public view returns(uint id){\n', '        return listContract.accountID(account);\n', '    }\n', '\n', '    function getAccount(uint64 id) public view returns(address account){\n', '        return listContract.accountAddr(uint64(id));\n', '    }\n', '\n', '    function getAuthorityIDs(address authority) public view returns(uint64[] memory){\n', '        ListInterface.UserLink memory userLink = listContract.userLink(authority);\n', '        uint64[] memory IDs = new uint64[](userLink.count);\n', '        uint64 id = userLink.first;\n', '        for (uint i = 0; i < userLink.count; i++) {\n', '            IDs[i] = id;\n', '            ListInterface.UserList memory userList = listContract.userList(authority, id);\n', '            id = userList.next;\n', '        }\n', '        return IDs;\n', '    }\n', '\n', '    function getAuthorityAccounts(address authority) public view returns(address[] memory){\n', '        uint64[] memory IDs = getAuthorityIDs(authority);\n', '        address[] memory accounts = new address[](IDs.length);\n', '        for (uint i = 0; i < IDs.length; i++) {\n', '            accounts[i] = getAccount(IDs[i]);\n', '        }\n', '        return accounts;\n', '    }\n', '\n', '    function getIDAuthorities(uint id) public view returns(address[] memory){\n', '        ListInterface.AccountLink memory accountLink = listContract.accountLink(uint64(id));\n', '        address[] memory authorities = new address[](accountLink.count);\n', '        address authority = accountLink.first;\n', '        for (uint i = 0; i < accountLink.count; i++) {\n', '            authorities[i] = authority;\n', '            ListInterface.AccountList memory accountList = listContract.accountList(uint64(id), authority);\n', '            authority = accountList.next;\n', '        }\n', '        return authorities;\n', '    }\n', '\n', '    function getAccountAuthorities(address account) public view returns(address[] memory){\n', '        return getIDAuthorities(getID(account));\n', '    }\n', '\n', '    function getAccountVersions(address[] memory accounts) public view returns(uint[] memory) {\n', '        uint[] memory versions = new uint[](accounts.length);\n', '        for (uint i = 0; i < accounts.length; i++) {\n', '            versions[i] = AccountInterface(accounts[i]).version();\n', '        }\n', '        return versions;\n', '    }\n', '\n', '    struct AuthorityData {\n', '        uint64[] IDs;\n', '        address[] accounts;\n', '        uint[] versions;\n', '    }\n', '\n', '    struct AccountData {\n', '        uint ID;\n', '        address account;\n', '        uint version;\n', '        address[] authorities;\n', '    }\n', '\n', '    function getAuthorityDetails(address authority) public view returns(AuthorityData memory){\n', '        address[] memory accounts = getAuthorityAccounts(authority);\n', '        return AuthorityData(\n', '            getAuthorityIDs(authority),\n', '            accounts,\n', '            getAccountVersions(accounts)\n', '        );\n', '    }\n', '\n', '    function getAccountIdDetails(uint id) public view returns(AccountData memory){\n', '        address account = getAccount(uint64(id));\n', '        return AccountData(\n', '            id,\n', '            account,\n', '            AccountInterface(account).version(),\n', '            getIDAuthorities(id)\n', '        );\n', '    }\n', '\n', '    function getAccountDetails(address account) public view returns(AccountData memory){\n', '        uint id = getID(account);\n', '        return AccountData(\n', '            id,\n', '            account,\n', '            AccountInterface(account).version(),\n', '            getIDAuthorities(id)\n', '        );\n', '    }\n', '\n', '    function isShield(address account) public view returns(bool shield) {\n', '        shield = AccountInterface(account).sheild();\n', '    }\n', '    \n', '    struct AuthType {\n', '        address owner;\n', '        uint authType;\n', '    }\n', '    \n', '    function getAuthorityTypes(address[] memory authorities) public view returns(AuthType[] memory) {\n', '        AuthType[] memory types = new AuthType[](authorities.length);\n', '        for (uint i = 0; i < authorities.length; i++) {\n', '            bytes memory _contractCode = getContractCode(authorities[i]);\n', '            bool isSafe;\n', '            for (uint k = 0; k < gnosisFactoryContracts.length; k++) {\n', '                bytes memory multiSigCode = gnosisFactoryContracts[k].proxyRuntimeCode();\n', '                if(keccak256(abi.encode(multiSigCode)) == keccak256(abi.encode(_contractCode))) {\n', '                    isSafe = true;\n', '                }\n', '            }\n', '            if (isSafe) {\n', '                 types[i] = AuthType({\n', '                    owner: authorities[i],\n', '                    authType: 1\n', '                });\n', '            } else {\n', '                types[i] = AuthType({\n', '                    owner: authorities[i],\n', '                    authType: 0\n', '                });\n', '            }\n', '        }\n', '        return types;\n', '    }\n', '\n', '    function getAccountAuthoritiesTypes(address account) public view returns(AuthType[] memory) {\n', '        return getAuthorityTypes(getAccountAuthorities(account));\n', '    }\n', '}\n', '\n', '\n', 'contract ConnectorsResolver is AccountResolver {\n', '    struct ConnectorsData {\n', '        address connector;\n', '        uint connectorID;\n', '        string name;\n', '    }\n', '\n', '    function getEnabledConnectors() public view returns(address[] memory){\n', '        uint enabledCount = connectorsContract.connectorCount();\n', '        address[] memory addresses = new address[](enabledCount);\n', '        uint connectorArrayLength = connectorsContract.connectorLength();\n', '        uint count;\n', '        for (uint i = 0; i < connectorArrayLength ; i++) {\n', '            address connector = connectorsContract.connectorArray(i);\n', '            if (connectorsContract.connectors(connector)) {\n', '                addresses[count] = connector;\n', '                count++;\n', '            }\n', '        }\n', '        return addresses;\n', '    }\n', '\n', '    function getEnabledConnectorsData() public view returns(ConnectorsData[] memory){\n', '        uint enabledCount = connectorsContract.connectorCount();\n', '        ConnectorsData[] memory connectorsData = new ConnectorsData[](enabledCount);\n', '        uint connectorArrayLength = connectorsContract.connectorLength();\n', '        uint count;\n', '        for (uint i = 0; i < connectorArrayLength ; i++) {\n', '            address connector = connectorsContract.connectorArray(i);\n', '            if (connectorsContract.connectors(connector)) {\n', '                connectorsData[count] = ConnectorsData(\n', '                    connector,\n', '                    i+1,\n', '                    ConnectorInterface(connector).name()\n', '                );\n', '                count++;\n', '            }\n', '        }\n', '        return connectorsData;\n', '    }\n', '\n', '    function getStaticConnectors() public view returns(address[] memory){\n', '        uint staticLength = connectorsContract.staticConnectorLength();\n', '        address[] memory staticConnectorArray = new address[](staticLength);\n', '        for (uint i = 0; i < staticLength ; i++) {\n', '            staticConnectorArray[i] = connectorsContract.staticConnectorArray(i);\n', '        }\n', '        return staticConnectorArray;\n', '    }\n', '\n', '    function getStaticConnectorsData() public view returns(ConnectorsData[] memory){\n', '        uint staticLength = connectorsContract.staticConnectorLength();\n', '        ConnectorsData[] memory staticConnectorsData = new ConnectorsData[](staticLength);\n', '        for (uint i = 0; i < staticLength ; i++) {\n', '            address staticConnector = connectorsContract.staticConnectorArray(i);\n', '            staticConnectorsData[i] = ConnectorsData(\n', '                staticConnector,\n', '                i+1,\n', '                ConnectorInterface(staticConnector).name()\n', '            );\n', '        }\n', '        return staticConnectorsData;\n', '    }\n', '}\n', '\n', '\n', 'contract InstaDSAResolver is ConnectorsResolver {\n', '    string public constant name = "DSA-Resolver-v1";\n', '    uint public constant version = 1;\n', '\n', '    constructor(address _index, address[] memory _gnosisFactory) public{\n', '        index = _index;\n', '        indexContract = IndexInterface(index);\n', '        list = indexContract.list();\n', '        listContract = ListInterface(list);\n', '        connectors = indexContract.connectors(version);\n', '        connectorsContract = ConnectorsInterface(connectors);\n', '        for (uint i = 0; i < _gnosisFactory.length; i++) {\n', '            require(_gnosisFactory[i] != address(0), "address-not-vaild");\n', '            GnosisFactoryInterface gnosisFactoryContract = GnosisFactoryInterface(_gnosisFactory[i]);\n', '            gnosisFactoryContracts.push(gnosisFactoryContract);\n', '        }\n', '    }\n', '}']