['/* Discussion:\n', ' * //github.com/b-u-i-d-l/dfo-hub\n', ' */\n', '/* Description:\n', ' * QuickScope - A simple DFO Microservice to easily swap Programmable Equities through Uniswap V2\n', ' */\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.1;\n', '\n', '/**\n', ' * @title QuickScope - A simple DFO Microservice to easily swap Programmable Equities through Uniswap V2\n', ' * @dev This general-purpose microservice can be called only by authorized sender, which can be easily set\n', ' * using the DFOhub StateHolder.\n', ' */\n', 'contract QuickScopeMicroservice {\n', '\n', '    string private _metadataLink;\n', '\n', '    /**\n', '     * @dev Microservice Constructor\n', '     * @param metadataLink The IPFS location of the Metadata, saved in JSON Format\n', '     */\n', '    constructor(string memory metadataLink) {\n', '        _metadataLink = metadataLink;\n', '    }\n', '\n', '    /**\n', '     * @dev GET the metadataLink\n', '     */\n', '    function getMetadataLink() public view returns(string memory) {\n', '        return _metadataLink;\n', '    }\n', '\n', '    /**\n', '     * @dev The Microservice method start\n', '     * It sets up the operator able to call the microservice\n', '     */\n', '    function onStart(address, address) public {\n', '        IMVDProxy proxy = IMVDProxy(msg.sender);\n', '        IStateHolder stateHolder = IStateHolder(proxy.getStateHolderAddress());\n', '        address quickScopeOperator = 0xd6b6B5c0F41D77E41C33a8e2B8BACe8fdBf4eDef;\n', '        stateHolder.setBool(string(abi.encode("quickScope.operator.", _toLowerCase(_toString(quickScopeOperator)))), true);\n', '    }\n', '\n', '    /**\n', '     * @dev The Microservice method end\n', '     * It avoids the operator able to call the microservice\n', '     */\n', '    function onStop(address) public {\n', '        IMVDProxy proxy = IMVDProxy(msg.sender);\n', '        IStateHolder stateHolder = IStateHolder(proxy.getStateHolderAddress());\n', '        address quickScopeOperator = 0xd6b6B5c0F41D77E41C33a8e2B8BACe8fdBf4eDef;\n', '        stateHolder.clear(string(abi.encode("quickScope.operator.", _toLowerCase(_toString(quickScopeOperator)))));\n', '    }\n', '\n', '    /**\n', '     * @dev The microservice main method.\n', '     * It transfers the desiderd tokens then swap it on UniswapV2, sending back again the gained tokens to the DFO.\n', '     * @param sender The original msg.sender who called the DFO Proxy. It should be the operator authorized to perform the action.\n', '     * @param uniswapV2RouterAddress The Uniswap V2 Router address useful to perform the operation\n', '     * @param path The token path to be used to swap the token\n', '     * @param amountIn The amount of passed token to be swapped\n', '     * @param amountOutMin The output amount to be received, it can contain the slippage\n', '     * @param deadline The swap deadline before to declare void this swap\n', '     */\n', '    function quickScope(address sender, uint256, address uniswapV2RouterAddress, address[] memory path, uint256 amountIn, uint256 amountOutMin, uint256 deadline) public {\n', '        IMVDProxy proxy = IMVDProxy(msg.sender);\n', '        IStateHolder stateHolder = IStateHolder(proxy.getStateHolderAddress());\n', '        require(stateHolder.getBool(string(abi.encode("quickScope.operator.", _toLowerCase(_toString(sender))))), "Unauthorized Action!");\n', '        address walletAddress = proxy.getMVDWalletAddress();\n', '        proxy.transfer(address(this), amountIn, path[0]);\n', '        _checkAllowance(path[0], amountIn, uniswapV2RouterAddress);\n', '        IUniswapV2Router(uniswapV2RouterAddress).swapExactTokensForTokens(amountIn, amountOutMin, path, walletAddress, deadline);\n', '        _flush(path, walletAddress);\n', '    }\n', '\n', '    function _checkAllowance(\n', '        address tokenAddress,\n', '        uint256 value,\n', '        address spender\n', '    ) private {\n', '        IERC20 token = IERC20(tokenAddress);\n', '        if (token.allowance(address(this), spender) <= value) {\n', '            token.approve(spender, value);\n', '        }\n', '    }\n', '\n', '    function _flush(address[] memory tokenAddresses, address receiver) private {\n', '        for(uint256 i = 0; i < tokenAddresses.length; i++) {\n', '            IERC20 token = IERC20(tokenAddresses[i]);\n', '            uint256 balance = token.balanceOf(address(this));\n', '            if(balance > 0) {\n', '                token.transfer(receiver, balance);\n', '            }\n', '        }\n', '        uint256 balance = address(this).balance;\n', '        if(balance > 0) {\n', '            payable(receiver).transfer(balance);\n', '        }\n', '    }\n', '\n', '    function _toString(address _addr) private pure returns(string memory) {\n', '        bytes32 value = bytes32(uint256(_addr));\n', '        bytes memory alphabet = "0123456789abcdef";\n', '\n', '        bytes memory str = new bytes(42);\n', "        str[0] = '0';\n", "        str[1] = 'x';\n", '        for (uint i = 0; i < 20; i++) {\n', '            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\n', '            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\n', '        }\n', '        return string(str);\n', '    }\n', '\n', '    function _toLowerCase(string memory str) private pure returns(string memory) {\n', '        bytes memory bStr = bytes(str);\n', '        for (uint i = 0; i < bStr.length; i++) {\n', '            bStr[i] = bStr[i] >= 0x41 && bStr[i] <= 0x5A ? bytes1(uint8(bStr[i]) + 0x20) : bStr[i];\n', '        }\n', '        return string(bStr);\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Router {\n', '    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface IMVDProxy {\n', '    function getStateHolderAddress() external view returns(address);\n', '    function getMVDWalletAddress() external view returns (address);\n', '    function transfer(address receiver, uint256 value, address token) external;\n', '}\n', '\n', 'interface IMVDFunctionalitiesManager {\n', '    function isAuthorizedFunctionality(address functionality) external view returns(bool);\n', '}\n', '\n', 'interface IStateHolder {\n', '    function clear(string calldata varName) external returns(string memory oldDataType, bytes memory oldVal);\n', '    function setBool(string calldata varName, bool val) external returns(bool);\n', '    function getBool(string calldata varName) external view returns (bool);\n', '}']