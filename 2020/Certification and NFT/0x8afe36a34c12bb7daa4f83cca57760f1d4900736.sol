['pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'interface DharmaTradeBotV1Interface {\n', '  struct LimitOrderArguments {\n', '    address account;\n', '    address assetToSupply;        // Ether = address(0)\n', '    address assetToReceive;       // Ether = address(0)\n', '    uint256 maximumAmountToSupply;\n', '    uint256 maximumPriceToAccept; // represented as a mantissa (n * 10^18)\n', '    uint256 expiration;\n', '    bytes32 salt;\n', '  }\n', '\n', '  struct LimitOrderExecutionArguments {\n', '    uint256 amountToSupply; // will be lower than maximum for partial fills\n', '    bytes signatures;\n', '    address tradeTarget;\n', '    bytes tradeData;\n', '  }\n', '\n', '  function processLimitOrder(\n', '    LimitOrderArguments calldata args,\n', '    LimitOrderExecutionArguments calldata executionArgs\n', '  ) external returns (uint256 amountReceived);\n', '}\n', '\n', '\n', 'interface TradeBotCommanderV1Interface {\n', '    // events\n', '    event AddedAccount(address account);\n', '    event RemovedAccount(address account);\n', '    event Call(address target, uint256 amount, bytes data, bool ok, bytes returnData);\n', '    \n', '    // callable by accounts\n', '    function processLimitOrder(\n', '        DharmaTradeBotV1Interface.LimitOrderArguments calldata args,\n', '        DharmaTradeBotV1Interface.LimitOrderExecutionArguments calldata executionArgs\n', '    ) external returns (bool ok, uint256 amountReceived);\n', '\n', '    // only callable by owner\n', '    function addAccount(address account) external;\n', '    function removeAccount(address account) external;\n', '    function callAny(\n', '        address payable target, uint256 amount, bytes calldata data\n', '    ) external returns (bool ok, bytes memory returnData);\n', '\n', '    // view functions\n', '    function getAccounts() external view returns (address[] memory);\n', '    function getTradeBot() external view returns (address tradeBot);\n', '}\n', '\n', '\n', 'contract TwoStepOwnable {\n', '  address private _owner;\n', '\n', '  address private _newPotentialOwner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev Initialize contract by setting transaction submitter as initial owner.\n', '   */\n', '  constructor() internal {\n', '    _owner = tx.origin;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the current owner.\n', '   */\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner(), "TwoStepOwnable: caller is not the owner.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns true if the caller is the current owner.\n', '   */\n', '  function isOwner() public view returns (bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows a new account (`newOwner`) to accept ownership.\n', '   * Can only be called by the current owner.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(\n', '      newOwner != address(0),\n', '      "TwoStepOwnable: new potential owner is the zero address."\n', '    );\n', '\n', '    _newPotentialOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Cancel a transfer of ownership to a new account.\n', '   * Can only be called by the current owner.\n', '   */\n', '  function cancelOwnershipTransfer() public onlyOwner {\n', '    delete _newPotentialOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers ownership of the contract to the caller.\n', '   * Can only be called by a new potential owner set by the current owner.\n', '   */\n', '  function acceptOwnership() public {\n', '    require(\n', '      msg.sender == _newPotentialOwner,\n', '      "TwoStepOwnable: current owner must set caller as new potential owner."\n', '    );\n', '\n', '    delete _newPotentialOwner;\n', '\n', '    emit OwnershipTransferred(_owner, msg.sender);\n', '\n', '    _owner = msg.sender;\n', '  }\n', '}\n', '\n', '\n', 'contract TradeBotCommanderV1Staging is TradeBotCommanderV1Interface, TwoStepOwnable {\n', '    // Track all authorized accounts.\n', '    address[] private _accounts;\n', '\n', '    // Indexes start at 1, as 0 signifies non-inclusion\n', '    mapping (address => uint256) private _accountIndexes;\n', '    \n', '    DharmaTradeBotV1Interface private immutable _TRADE_BOT;\n', '    \n', '    bool public constant isStaging = true;\n', '\n', '    constructor(address tradeBot, address[] memory initialAccounts) public {\n', '        _TRADE_BOT = DharmaTradeBotV1Interface(tradeBot);\n', '        for (uint256 i; i < initialAccounts.length; i++) {\n', '            address account = initialAccounts[i];\n', '            _addAccount(account);\n', '        }\n', '    }\n', '    \n', '    function processLimitOrder(\n', '        DharmaTradeBotV1Interface.LimitOrderArguments calldata args,\n', '        DharmaTradeBotV1Interface.LimitOrderExecutionArguments calldata executionArgs\n', '    ) external override returns (bool ok, uint256 amountReceived) {\n', '        require(\n', '            _accountIndexes[msg.sender] != 0,\n', '            "Only authorized accounts may trigger limit orders."\n', '        );\n', '        \n', '        amountReceived = _TRADE_BOT.processLimitOrder(\n', '            args, executionArgs\n', '        );\n', '\n', '        ok = true;\n', '    }\n', '\n', '    function addAccount(address account) external override onlyOwner {\n', '        _addAccount(account);\n', '    }\n', '\n', '    function removeAccount(address account) external override onlyOwner {\n', '        _removeAccount(account);\n', '    }\n', '\n', '    function callAny(\n', '        address payable target, uint256 amount, bytes calldata data\n', '    ) external override onlyOwner returns (bool ok, bytes memory returnData) {\n', '        // Call the specified target and supply the specified amount and data.\n', '        (ok, returnData) = target.call{value: amount}(data);\n', '\n', '        emit Call(target, amount, data, ok, returnData);\n', '    }\n', '\n', '    function getAccounts() external view override returns (address[] memory) {\n', '        return _accounts;\n', '    }\n', '\n', '    function getTradeBot() external view override returns (address tradeBot) {\n', '        return address(_TRADE_BOT);\n', '    }\n', '\n', '    function _addAccount(address account) internal {\n', '        require(\n', '            _accountIndexes[account] == 0,\n', '            "Account matching the provided account already exists."\n', '        );\n', '        _accounts.push(account);\n', '        _accountIndexes[account] = _accounts.length;\n', '\n', '        emit AddedAccount(account);\n', '    }\n', '    \n', '    function _removeAccount(address account) internal {\n', '        uint256 removedAccountIndex = _accountIndexes[account];\n', '        require(\n', '            removedAccountIndex != 0,\n', '            "No account found matching the provided account."\n', '        );\n', '\n', '        // swap account to remove with the last one then pop from the array.\n', '        address lastAccount = _accounts[_accounts.length - 1];\n', '        _accounts[removedAccountIndex - 1] = lastAccount;\n', '        _accountIndexes[lastAccount] = removedAccountIndex;\n', '        _accounts.pop();\n', '        delete _accountIndexes[account];\n', '\n', '        emit RemovedAccount(account); \n', '    }\n', '}']