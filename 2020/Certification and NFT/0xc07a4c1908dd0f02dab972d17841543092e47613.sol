['// File: contracts/external/lockable-token/IERC1132.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '/**\n', ' * @title ERC1132 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/1132\n', ' */\n', '\n', 'contract IERC1132 {\n', '    /**\n', "     * @dev Reasons why a user's tokens have been locked\n", '     */\n', '    mapping(address => bytes32[]) public lockReason;\n', '\n', '    /**\n', '     * @dev locked token structure\n', '     */\n', '    struct LockToken {\n', '        uint256 amount;\n', '        uint256 validity;\n', '        bool claimed;\n', '    }\n', '\n', '    /**\n', '     * @dev Holds number & validity of tokens locked for a given reason for\n', '     *      a specified address\n', '     */\n', '    mapping(address => mapping(bytes32 => LockToken)) public locked;\n', '\n', '    /**\n', '     * @dev Records data of all the tokens Locked\n', '     */\n', '    event Locked(\n', '        address indexed _of,\n', '        bytes32 indexed _reason,\n', '        uint256 _amount,\n', '        uint256 _validity\n', '    );\n', '\n', '    /**\n', '     * @dev Records data of all the tokens unlocked\n', '     */\n', '    event Unlocked(\n', '        address indexed _of,\n', '        bytes32 indexed _reason,\n', '        uint256 _amount\n', '    );\n', '    \n', '    /**\n', '     * @dev Locks a specified amount of tokens against an address,\n', '     *      for a specified reason and time\n', '     * @param _reason The reason to lock tokens\n', '     * @param _amount Number of tokens to be locked\n', '     * @param _time Lock time in seconds\n', '     */\n', '    function lock(bytes32 _reason, uint256 _amount, uint256 _time)\n', '        public returns (bool);\n', '  \n', '    /**\n', '     * @dev Returns tokens locked for a specified address for a\n', '     *      specified reason\n', '     *\n', '     * @param _of The address whose tokens are locked\n', '     * @param _reason The reason to query the lock tokens for\n', '     */\n', '    function tokensLocked(address _of, bytes32 _reason)\n', '        public view returns (uint256 amount);\n', '    \n', '    /**\n', '     * @dev Returns tokens locked for a specified address for a\n', '     *      specified reason at a specific time\n', '     *\n', '     * @param _of The address whose tokens are locked\n', '     * @param _reason The reason to query the lock tokens for\n', '     * @param _time The timestamp to query the lock tokens for\n', '     */\n', '    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\n', '        public view returns (uint256 amount);\n', '    \n', '    /**\n', '     * @dev Returns total tokens held by an address (locked + transferable)\n', '     * @param _of The address to query the total balance of\n', '     */\n', '    function totalBalanceOf(address _of)\n', '        public view returns (uint256 amount);\n', '    \n', '    /**\n', '     * @dev Extends lock for a specified reason and time\n', '     * @param _reason The reason to lock tokens\n', '     * @param _time Lock extension time in seconds\n', '     */\n', '    function extendLock(bytes32 _reason, uint256 _time)\n', '        public returns (bool);\n', '    \n', '    /**\n', '     * @dev Increase number of tokens locked for a specified reason\n', '     * @param _reason The reason to lock tokens\n', '     * @param _amount Number of tokens to be increased\n', '     */\n', '    function increaseLockAmount(bytes32 _reason, uint256 _amount)\n', '        public returns (bool);\n', '\n', '    /**\n', '     * @dev Returns unlockable tokens for a specified address for a specified reason\n', '     * @param _of The address to query the the unlockable token count of\n', '     * @param _reason The reason to query the unlockable tokens for\n', '     */\n', '    function tokensUnlockable(address _of, bytes32 _reason)\n', '        public view returns (uint256 amount);\n', ' \n', '    /**\n', '     * @dev Unlocks the unlockable tokens of a specified address\n', '     * @param _of Address of user, claiming back unlockable tokens\n', '     */\n', '    function unlock(address _of)\n', '        public returns (uint256 unlockableTokens);\n', '\n', '    /**\n', '     * @dev Gets the unlockable tokens of a specified address\n', '     * @param _of The address to query the the unlockable token count of\n', '     */\n', '    function getUnlockableTokens(address _of)\n', '        public view returns (uint256 unlockableTokens);\n', '\n', '}\n', '\n', '// File: contracts/external/openzeppelin-solidity/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see `ERC20Detailed`.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Mints `amount` tokens to address `account`.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function mint(address account, uint256 amount) external returns (bool);\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when `approve` or `transferFrom` are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * > Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an `Approval` event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to `approve`. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/external/openzeppelin-solidity/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library SafeMath64 {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        uint64 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint64 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\n', '        require(b <= a, errorMessage);\n', '        uint64 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint64 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint64 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/external/openzeppelin-solidity/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of the `IERC20` interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using `_mint`.\n', ' * For a generic mechanism see `ERC20Mintable`.\n', ' *\n', ' * *For a detailed writeup see our guide [How to implement supply\n', ' * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See `IERC20.approve`.\n', ' */\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) internal _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to `approve`. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /**\n', '     * @dev See `IERC20.totalSupply`.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.balanceOf`.\n', '     */\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.transfer`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.allowance`.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.approve`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.transferFrom`.\n', '     *\n', '     * Emits an `Approval` event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of `ERC20`;\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `value`.\n', "     * - the caller must have allowance for `sender`'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to `approve` that can be used as a mitigation for\n', '     * problems described in `IERC20.approve`.\n', '     *\n', '     * Emits an `Approval` event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to `approve` that can be used as a mitigation for\n', '     * problems described in `IERC20.approve`.\n', '     *\n', '     * Emits an `Approval` event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to `transfer`, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _balances[sender] = _balances[sender].sub(amount);\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * Emits an `Approval` event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of `ERC20`;\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `value`.\n', "     * - the caller must have allowance for `sender`'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function _transferFrom(address sender, address recipient, uint256 amount) internal {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a `Transfer` event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '     /**\n', '     * @dev Destoys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a `Transfer` event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 value) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _totalSupply = _totalSupply.sub(value);\n', '        _balances[account] = _balances[account].sub(value);\n', '        emit Transfer(account, address(0), value);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an `Approval` event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 value) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n', "     * from the caller's allowance.\n", '     *\n', '     * See `_burn` and `_approve`.\n', '     */\n', '    function _burnFrom(address account, uint256 amount) internal {\n', '        _burn(account, amount);\n', '        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n', '    }\n', '}\n', '\n', '// File: contracts/PlotXToken.sol\n', '\n', '/* Copyright (C) 2020 PlotX.io\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', 'contract PlotXToken is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) public lockedForGV;\n', '\n', '    string public name = "PLOT";\n', '    string public symbol = "PLOT";\n', '    uint8 public decimals = 18;\n', '    address public operator;\n', '\n', '    modifier onlyOperator() {\n', '        require(msg.sender == operator, "Not operator");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Initialize PLOT token\n', '     * @param _initialSupply Initial token supply\n', '     * @param _initialTokenHolder Initial token holder address\n', '     */\n', '    constructor(uint256 _initialSupply, address _initialTokenHolder) public {\n', '        _mint(_initialTokenHolder, _initialSupply);\n', '        operator = _initialTokenHolder;\n', '    }\n', '\n', '    /**\n', '     * @dev change operator address\n', '     * @param _newOperator address of new operator\n', '     */\n', '    function changeOperator(address _newOperator)\n', '        public\n', '        onlyOperator\n', '        returns (bool)\n', '    {\n', '        require(_newOperator != address(0), "New operator cannot be 0 address");\n', '        operator = _newOperator;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev burns an amount of the tokens of the message sender\n', '     * account.\n', '     * @param amount The amount that will be burnt.\n', '     */\n', '    function burn(uint256 amount) public {\n', '        _burn(msg.sender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Burns a specific amount of tokens from the target address and decrements allowance\n', '     * @param from address The address which you want to send tokens from\n', '     * @param value uint256 The amount of token to be burned\n', '     */\n', '    function burnFrom(address from, uint256 value) public {\n', '        _burnFrom(from, value);\n', '    }\n', '\n', '    /**\n', '     * @dev function that mints an amount of the token and assigns it to\n', '     * an account.\n', '     * @param account The account that will receive the created tokens.\n', '     * @param amount The amount that will be created.\n', '     */\n', '    function mint(address account, uint256 amount)\n', '        public\n', '        onlyOperator\n', '        returns (bool)\n', '    {\n', '        _mint(account, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token for a specified address\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        require(lockedForGV[msg.sender] < now, "Locked for governance"); // if not voted under governance\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to transfer to\n', '     * @param value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) public returns (bool) {\n', '        require(lockedForGV[from] < now, "Locked for governance"); // if not voted under governance\n', '        _transferFrom(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * @dev Lock the user's tokens\n", "     * @param _of user's address.\n", '     */\n', '    function lockForGovernanceVote(address _of, uint256 _period)\n', '        public\n', '        onlyOperator\n', '    {\n', '        if (_period.add(now) > lockedForGV[_of])\n', '            lockedForGV[_of] = _period.add(now);\n', '    }\n', '\n', '    function isLockedForGV(address _of) public view returns (bool) {\n', '        return (lockedForGV[_of] > now);\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IbLOTToken.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract IbLOTToken {\n', '    function initiatebLOT(address _defaultMinter) external;\n', '    function convertToPLOT(address _of, address _to, uint256 amount) public;\n', '}\n', '\n', '// File: contracts/Vesting.sol\n', '\n', '/* Copyright (C) 2020 PlotX.io\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', 'contract Vesting {\n', '\n', '  using SafeMath for uint256;\n', '  using SafeMath64 for uint64;\n', '  PlotXToken public token;\n', '  address public owner;\n', '\n', '  uint constant internal SECONDS_PER_DAY = 1 days;\n', '\n', '  event Allocated(address recipient, uint64 startTime, uint256 amount, uint64 vestingDuration, uint64 vestingPeriodInDays, uint _upfront);\n', '  event TokensClaimed(address recipient, uint256 amountClaimed);\n', '\n', '  struct Allocation {\n', '    uint64 vestingDuration; \n', '    uint64 periodClaimed;  \n', '    uint64 periodInDays; \n', '    uint64 startTime; \n', '    uint256 amount;\n', '    uint256 totalClaimed;\n', '  }\n', '  mapping (address => Allocation) public tokenAllocations;\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner, "unauthorized");\n', '    _;\n', '  }\n', '\n', '  modifier nonZeroAddress(address x) {\n', '    require(x != address(0), "token-zero-address");\n', '    _;\n', '  }\n', '\n', '  constructor(address _token, address _owner) public\n', '  nonZeroAddress(_token)\n', '  nonZeroAddress(_owner)\n', '  {\n', '    token = PlotXToken(_token);\n', '    owner = _owner;\n', '  }\n', '\n', '  /// @dev Add a new token vesting for user `_recipient`. Only one vesting per user is allowed\n', '  /// The amount of PlotX tokens here need to be preapproved for transfer by this `Vesting` contract before this call\n', '  /// @param _recipient Address array of the token recipient entitled to claim the vested funds\n', '  /// @param _startTime Vesting start time array as seconds since unix epoch \n', '  /// @param _amount Total number of tokens array in vested\n', '  /// @param _vestingDuration Number of Periods in array.\n', '  /// @param _vestingPeriodInDays Array of Number of days in each Period\n', '  /// @param _upFront array of Amount of tokens `_recipient[i]` will get  right away\n', '  function addTokenVesting(address[] memory _recipient, uint64[] memory _startTime, uint256[] memory _amount, uint64[] memory _vestingDuration, uint64[] memory _vestingPeriodInDays, uint256[] memory _upFront) public \n', '  onlyOwner\n', '  {\n', '\n', '    require(_recipient.length == _startTime.length, "Different array length");\n', '    require(_recipient.length == _amount.length, "Different array length");\n', '    require(_recipient.length == _vestingDuration.length, "Different array length");\n', '    require(_recipient.length == _vestingPeriodInDays.length, "Different array length");\n', '    require(_recipient.length == _upFront.length, "Different array length");\n', '\n', '    for(uint i=0;i<_recipient.length;i++) {\n', '      require(tokenAllocations[_recipient[i]].startTime == 0, "token-user-grant-exists");\n', '      require(_startTime[i] != 0, "should be positive");\n', '      uint256 amountVestedPerPeriod = _amount[i].div(_vestingDuration[i]);\n', '      require(amountVestedPerPeriod > 0, "0-amount-vested-per-period");\n', '\n', '      // Transfer the vesting tokens under the control of the vesting contract\n', '      token.transferFrom(owner, address(this), _amount[i].add(_upFront[i]));\n', '\n', '      Allocation memory _allocation = Allocation({\n', '        startTime: _startTime[i], \n', '        amount: _amount[i],\n', '        vestingDuration: _vestingDuration[i],\n', '        periodInDays: _vestingPeriodInDays[i],\n', '        periodClaimed: 0,\n', '        totalClaimed: 0\n', '      });\n', '      tokenAllocations[_recipient[i]] = _allocation;\n', '\n', '      if(_upFront[i] > 0) {\n', '        token.transfer(_recipient[i], _upFront[i]);\n', '      }\n', '\n', '      emit Allocated(_recipient[i], _startTime[i], _amount[i], _vestingDuration[i], _vestingPeriodInDays[i], _upFront[i]);\n', '    }\n', '  }\n', '\n', '  /// @dev Allows a vesting recipient to claim their vested tokens. Errors if no tokens have vested\n', '  /// It is advised recipients check they are entitled to claim via `calculateVestingClaim` before calling this\n', '  function claimVestedTokens() public {\n', '\n', '    require(!token.isLockedForGV(msg.sender),"Locked for GV vote");\n', '    uint64 periodVested;\n', '    uint256 amountVested;\n', '    (periodVested, amountVested) = calculateVestingClaim(msg.sender);\n', '    require(amountVested > 0, "token-zero-amount-vested");\n', '\n', '    Allocation storage _tokenAllocated = tokenAllocations[msg.sender];\n', '    _tokenAllocated.periodClaimed = _tokenAllocated.periodClaimed.add(periodVested);\n', '    _tokenAllocated.totalClaimed = _tokenAllocated.totalClaimed.add(amountVested);\n', '    \n', '    require(token.transfer(msg.sender, amountVested), "token-sender-transfer-failed");\n', '    emit TokensClaimed(msg.sender, amountVested);\n', '  }\n', '\n', '  /// @dev Calculate the vested and unclaimed period and tokens available for `_recepient` to claim\n', '  /// Due to rounding errors once grant duration is reached, returns the entire left grant amount\n', '  function calculateVestingClaim(address _recipient) public view returns (uint64, uint256) {\n', '    Allocation memory _tokenAllocations = tokenAllocations[_recipient];\n', '\n', "    // For vesting created with a future start date, that hasn't been reached, return 0, 0\n", '    if (now < _tokenAllocations.startTime) {\n', '      return (0, 0);\n', '    }\n', '\n', '    uint256 elapsedTime = now.sub(_tokenAllocations.startTime);\n', '    uint64 elapsedDays = uint64(elapsedTime / SECONDS_PER_DAY);\n', '    \n', '    \n', '    // If over vesting duration, all tokens vested\n', '    if (elapsedDays >= _tokenAllocations.vestingDuration.mul(_tokenAllocations.periodInDays)) {\n', '      uint256 remainingTokens = _tokenAllocations.amount.sub(_tokenAllocations.totalClaimed);\n', '      return (_tokenAllocations.vestingDuration.sub(_tokenAllocations.periodClaimed), remainingTokens);\n', '    } else {\n', '      uint64 elapsedPeriod = elapsedDays.div(_tokenAllocations.periodInDays);\n', '      uint64 periodVested = elapsedPeriod.sub(_tokenAllocations.periodClaimed);\n', '      uint256 amountVestedPerPeriod = _tokenAllocations.amount.div(_tokenAllocations.vestingDuration);\n', '      uint256 amountVested = uint(periodVested).mul(amountVestedPerPeriod);\n', '      return (periodVested, amountVested);\n', '    }\n', '  }\n', '\n', '  /// @dev Returns unclaimed allocation of user. \n', '  function unclaimedAllocation(address _user) external view returns(uint) {\n', '    return tokenAllocations[_user].amount.sub(tokenAllocations[_user].totalClaimed);\n', '  }\n', '}\n', '\n', '// File: contracts/interfaces/Iupgradable.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract Iupgradable {\n', '\n', '    /**\n', '     * @dev change master address\n', '     */\n', '    function setMasterAddress() public;\n', '}\n', '\n', '// File: contracts/interfaces/IToken.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract IToken {\n', '\n', '    function decimals() external view returns(uint8);\n', '\n', '    /**\n', '    * @dev Total number of tokens in existence\n', '    */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param account The address to query the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', '    * @dev Transfer token for a specified address\n', '    * @param recipient The address to transfer to.\n', '    * @param amount The amount to be transferred.\n', '    */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '    * @dev function that mints an amount of the token and assigns it to\n', '    * an account.\n', '    * @param account The account that will receive the created tokens.\n', '    * @param amount The amount that will be created.\n', '    */\n', '    function mint(address account, uint256 amount) external returns (bool);\n', '    \n', '     /**\n', '    * @dev burns an amount of the tokens of the message sender\n', '    * account.\n', '    * @param amount The amount that will be burnt.\n', '    */\n', '    function burn(uint256 amount) external;\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     * Returns a boolean value indicating whether the operation succeeded.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '    * @dev Transfer tokens from one address to another\n', '    * @param sender address The address which you want to send tokens from\n', '    * @param recipient address The address which you want to transfer to\n', '    * @param amount uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '}\n', '\n', '// File: contracts/interfaces/IMarketRegistry.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract IMarketRegistry {\n', '\n', '    enum MarketType {\n', '      HourlyMarket,\n', '      DailyMarket,\n', '      WeeklyMarket\n', '    }\n', '    address public owner;\n', '    address public tokenController;\n', '    address public marketUtility;\n', '    bool public marketCreationPaused;\n', '\n', '    mapping(address => bool) public isMarket;\n', '    function() external payable{}\n', '\n', '    function marketDisputeStatus(address _marketAddress) public view returns(uint _status);\n', '\n', '    function burnDisputedProposalTokens(uint _proposaId) external;\n', '\n', '    function isWhitelistedSponsor(address _address) public view returns(bool);\n', '\n', '    function transferAssets(address _asset, address _to, uint _amount) external;\n', '\n', '    /**\n', '    * @dev Initialize the PlotX.\n', '    * @param _marketConfig The address of market config.\n', '    * @param _plotToken The address of PLOT token.\n', '    */\n', '    function initiate(address _defaultAddress, address _marketConfig, address _plotToken, address payable[] memory _configParams) public;\n', '\n', '    /**\n', '    * @dev Create proposal if user wants to raise the dispute.\n', '    * @param proposalTitle The title of proposal created by user.\n', '    * @param description The description of dispute.\n', '    * @param solutionHash The ipfs solution hash.\n', '    * @param actionHash The action hash for solution.\n', '    * @param stakeForDispute The token staked to raise the diospute.\n', '    * @param user The address who raises the dispute.\n', '    */\n', '    function createGovernanceProposal(string memory proposalTitle, string memory description, string memory solutionHash, bytes memory actionHash, uint256 stakeForDispute, address user, uint256 ethSentToPool, uint256 tokenSentToPool, uint256 proposedValue) public {\n', '    }\n', '\n', '    /**\n', '    * @dev Emits the PlacePrediction event and sets user data.\n', '    * @param _user The address who placed prediction.\n', '    * @param _value The amount of ether user staked.\n', '    * @param _predictionPoints The positions user will get.\n', '    * @param _predictionAsset The prediction assets user will get.\n', '    * @param _prediction The option range on which user placed prediction.\n', '    * @param _leverage The leverage selected by user at the time of place prediction.\n', '    */\n', '    function setUserGlobalPredictionData(address _user,uint _value, uint _predictionPoints, address _predictionAsset, uint _prediction,uint _leverage) public{\n', '    }\n', '\n', '    /**\n', '    * @dev Emits the claimed event.\n', '    * @param _user The address who claim their reward.\n', '    * @param _reward The reward which is claimed by user.\n', '    * @param incentives The incentives of user.\n', '    * @param incentiveToken The incentive tokens of user.\n', '    */\n', '    function callClaimedEvent(address _user , uint[] memory _reward, address[] memory predictionAssets, uint incentives, address incentiveToken) public {\n', '    }\n', '\n', '        /**\n', '    * @dev Emits the MarketResult event.\n', '    * @param _totalReward The amount of reward to be distribute.\n', '    * @param _winningOption The winning option of the market.\n', '    * @param _closeValue The closing value of the market currency.\n', '    */\n', '    function callMarketResultEvent(uint[] memory _totalReward, uint _winningOption, uint _closeValue, uint roundId) public {\n', '    }\n', '}\n', '\n', '// File: contracts/external/govblocks-protocol/Governed.sol\n', '\n', '/* Copyright (C) 2017 GovBlocks.io\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'contract IMaster {\n', '    mapping(address => bool) public whitelistedSponsor;\n', '    function dAppToken() public view returns(address);\n', '    function isInternal(address _address) public view returns(bool);\n', '    function getLatestAddress(bytes2 _module) public view returns(address);\n', '    function isAuthorizedToGovern(address _toCheck) public view returns(bool);\n', '}\n', '\n', '\n', 'contract Governed {\n', '\n', '    address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\n', '\n', '    /// @dev modifier that allows only the authorized addresses to execute the function\n', '    modifier onlyAuthorizedToGovern() {\n', '        IMaster ms = IMaster(masterAddress);\n', '        require(ms.getLatestAddress("GV") == msg.sender, "Not authorized");\n', '        _;\n', '    }\n', '\n', '    /// @dev checks if an address is authorized to govern\n', '    function isAuthorizedToGovern(address _toCheck) public view returns(bool) {\n', '        IMaster ms = IMaster(masterAddress);\n', '        return (ms.getLatestAddress("GV") == _toCheck);\n', '    } \n', '\n', '}\n', '\n', '// File: contracts/external/proxy/Proxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Gives the possibility to delegate any call to a foreign implementation.\n', ' */\n', 'contract Proxy {\n', '    /**\n', '    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n', '    * This function will return whatever the implementation call returns\n', '    */\n', '    function () external payable {\n', '        address _impl = implementation();\n', '        require(_impl != address(0));\n', '\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            calldatacopy(ptr, 0, calldatasize)\n', '            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n', '            let size := returndatasize\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            switch result\n', '            case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '            }\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the implementation where every call will be delegated.\n', '    * @return address of the implementation to which it will be delegated\n', '    */\n', '    function implementation() public view returns (address);\n', '}\n', '\n', '// File: contracts/external/proxy/UpgradeabilityProxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n', ' */\n', 'contract UpgradeabilityProxy is Proxy {\n', '    /**\n', '    * @dev This event will be emitted every time the implementation gets upgraded\n', '    * @param implementation representing the address of the upgraded implementation\n', '    */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    // Storage position of the address of the current implementation\n', '    bytes32 private constant IMPLEMENTATION_POSITION = keccak256("org.govblocks.proxy.implementation");\n', '\n', '    /**\n', '    * @dev Constructor function\n', '    */\n', '    constructor() public {}\n', '\n', '    /**\n', '    * @dev Tells the address of the current implementation\n', '    * @return address of the current implementation\n', '    */\n', '    function implementation() public view returns (address impl) {\n', '        bytes32 position = IMPLEMENTATION_POSITION;\n', '        assembly {\n', '            impl := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Sets the address of the current implementation\n', '    * @param _newImplementation address representing the new implementation to be set\n', '    */\n', '    function _setImplementation(address _newImplementation) internal {\n', '        bytes32 position = IMPLEMENTATION_POSITION;\n', '        assembly {\n', '        sstore(position, _newImplementation)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Upgrades the implementation address\n', '    * @param _newImplementation representing the address of the new implementation to be set\n', '    */\n', '    function _upgradeTo(address _newImplementation) internal {\n', '        address currentImplementation = implementation();\n', '        require(currentImplementation != _newImplementation);\n', '        _setImplementation(_newImplementation);\n', '        emit Upgraded(_newImplementation);\n', '    }\n', '}\n', '\n', '// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title OwnedUpgradeabilityProxy\n', ' * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n', ' */\n', 'contract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n', '    /**\n', '    * @dev Event to show ownership has been transferred\n', '    * @param previousOwner representing the address of the previous owner\n', '    * @param newOwner representing the address of the new owner\n', '    */\n', '    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n', '\n', '    // Storage position of the owner of the contract\n', '    bytes32 private constant PROXY_OWNER_POSITION = keccak256("org.govblocks.proxy.owner");\n', '\n', '    /**\n', '    * @dev the constructor sets the original owner of the contract to the sender account.\n', '    */\n', '    constructor(address _implementation) public {\n', '        _setUpgradeabilityOwner(msg.sender);\n', '        _upgradeTo(_implementation);\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyProxyOwner() {\n', '        require(msg.sender == proxyOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the owner\n', '    * @return the address of the owner\n', '    */\n', '    function proxyOwner() public view returns (address owner) {\n', '        bytes32 position = PROXY_OWNER_POSITION;\n', '        assembly {\n', '            owner := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\n', '        require(_newOwner != address(0));\n', '        _setUpgradeabilityOwner(_newOwner);\n', '        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the proxy owner to upgrade the current version of the proxy.\n', '    * @param _implementation representing the address of the new implementation to be set.\n', '    */\n', '    function upgradeTo(address _implementation) public onlyProxyOwner {\n', '        _upgradeTo(_implementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the owner\n', '    */\n', '    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\n', '        bytes32 position = PROXY_OWNER_POSITION;\n', '        assembly {\n', '            sstore(position, _newProxyOwner)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/TokenController.sol\n', '\n', '/* Copyright (C) 2020 PlotX.io\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity  0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract TokenController is IERC1132, Governed, Iupgradable {\n', '    using SafeMath for uint256;\n', '\n', '    event Burned(address indexed member, bytes32 lockedUnder, uint256 amount);\n', '\n', '   /**\n', '    * @dev Error messages for require statements\n', '    */\n', '    string internal constant ALREADY_LOCKED = "Tokens already locked";\n', '    string internal constant NOT_LOCKED = "No tokens locked";\n', '    string internal constant AMOUNT_ZERO = "Amount can not be 0";\n', '\n', '    uint internal smLockPeriod;\n', '\n', '    bool internal constructorCheck;\n', '\n', '    PlotXToken public token;\n', '    IMarketRegistry public marketRegistry;\n', '    IbLOTToken public bLOTToken;\n', '    Vesting public vesting;\n', '\n', '    modifier onlyAuthorized {\n', '        require(marketRegistry.isMarket(msg.sender), "Not authorized");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Just for interface\n', '    */\n', '    function setMasterAddress() public {\n', '        OwnedUpgradeabilityProxy proxy =  OwnedUpgradeabilityProxy(address(uint160(address(this))));\n', '        require(msg.sender == proxy.proxyOwner(),"Sender is not proxy owner.");\n', '        require(!constructorCheck, "Already ");\n', '        smLockPeriod = 30 days;\n', '        constructorCheck = true;\n', '        masterAddress = msg.sender;\n', '        IMaster ms = IMaster(msg.sender);\n', '        token = PlotXToken(ms.dAppToken());\n', '        bLOTToken = IbLOTToken(ms.getLatestAddress("BL"));\n', '        marketRegistry = IMarketRegistry(address(uint160(ms.getLatestAddress("PL"))));\n', '    }\n', '\n', '    /**\n', '     * @dev Initiate vesting contract\n', '     * @param _vesting Address of vesting contract implementation\n', '     */\n', '    function initiateVesting(address _vesting) external {\n', '        OwnedUpgradeabilityProxy proxy =  OwnedUpgradeabilityProxy(address(uint160(address(this))));\n', '        require(msg.sender == proxy.proxyOwner(),"Sender is not proxy owner.");\n', '        vesting = Vesting(_vesting);\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Swap `_amount` of BPLOT belonging to `_of` to PLOT and transfer to `_to` address\n', '     * @param _of Address from whose BPLOT to be transferred\n', '     * @param _to Recipient address, who recieves PLOT\n', '     * @param _amount Amount of tokens to swap\n', '     */\n', '    function swapBLOT(address _of, address _to, uint256 _amount) public onlyAuthorized {\n', '        bLOTToken.convertToPLOT(_of, _to, _amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers `_amount` of `_token` token from `_of` to `_to`\n', '     * @param _token Token address\n', '     * @param _of Address from whose PLOT to be transferred\n', '     * @param _to Recipient address\n', '     * @param _amount Amount of tokens to transfer\n', '     */\n', '    function transferFrom(address _token, address _of, address _to, uint256 _amount) public onlyAuthorized {\n', '        require(IToken(_token).transferFrom(_of, _to, _amount));\n', '    }\n', '\n', '    /**\n', '     * @dev Updates Uint Parameters of a code\n', '     * @param code whose details we want to update\n', '     * @param val value to set\n', '     */\n', '    function updateUintParameters(bytes8 code, uint val) public onlyAuthorizedToGovern {\n', '        if(code == "SMLP") { //Stake multiplier default lock period\n', '            smLockPeriod = val.mul(1 days);\n', '        }\n', '    }\n', '\n', '    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\n', '        codeVal = code;\n', '        if(code == "SMLP") {\n', '            val= smLockPeriod.div(1 days);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Locks a specified amount of tokens against an address,\n', '     *      for a specified reason and time\n', '     * @param _reason The reason to lock tokens\n', '     * @param _amount Number of tokens to be locked\n', '     * @param _time Lock time in seconds\n', '     */\n', '    function lock(bytes32 _reason, uint256 _amount, uint256 _time)\n', '        public\n', '        returns (bool)\n', '    {\n', '\n', '        require((_reason == "SM" && _time == smLockPeriod) || _reason == "DR", "Unspecified reason or time");\n', '        require(tokensLocked(msg.sender, _reason) == 0, ALREADY_LOCKED);\n', '        require(_amount != 0, AMOUNT_ZERO);\n', '        \n', '        uint256 validUntil = _time.add(now); //solhint-disable-line\n', '\n', '        lockReason[msg.sender].push(_reason);\n', '\n', '        require(token.transferFrom(msg.sender, address(this), _amount));\n', '\n', '        locked[msg.sender][_reason] = LockToken(_amount, validUntil, false);\n', '\n', '        emit Locked(msg.sender, _reason, _amount, validUntil);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns tokens locked for a specified address for a\n', '     *      specified reason\n', '     *\n', '     * @param _of The address whose tokens are locked\n', '     * @param _reason The reason to query the lock tokens for\n', '     */\n', '    function tokensLocked(address _of, bytes32 _reason)\n', '        public\n', '        view\n', '        returns (uint256 amount)\n', '    {\n', '        if (!locked[_of][_reason].claimed)\n', '            amount = locked[_of][_reason].amount;\n', '    }\n', '    \n', '    /**\n', '     * @dev Returns tokens locked for a specified address for a\n', '     *      specified reason at a specific time\n', '     *\n', '     * @param _of The address whose tokens are locked\n', '     * @param _reason The reason to query the lock tokens for\n', '     * @param _time The timestamp to query the lock tokens for\n', '     */\n', '    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\n', '        public\n', '        view\n', '        returns (uint256 amount)\n', '    {\n', '        if (locked[_of][_reason].validity > _time)\n', '            amount = locked[_of][_reason].amount;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns total tokens held by an address (locked + transferable)\n', '     * @param _of The address to query the total balance of\n', '     */\n', '    function totalBalanceOf(address _of)\n', '        public\n', '        view\n', '        returns (uint256 amount)\n', '    {\n', '        amount = token.balanceOf(_of);\n', '\n', '        for (uint256 i = 0; i < lockReason[_of].length; i++) {\n', '            amount = amount.add(tokensLocked(_of, lockReason[_of][i]));\n', '        }  \n', '        amount = amount.add(vesting.unclaimedAllocation(_of)); \n', '    }   \n', '\n', '    function totalSupply() public view returns (uint256)\n', '    {\n', '        return token.totalSupply();\n', '    }\n', '\n', '    /**\n', '     * @dev Increase number of tokens locked for a specified reason\n', '     * @param _reason The reason to lock tokens\n', '     * @param _amount Number of tokens to be increased\n', '     */\n', '    function increaseLockAmount(bytes32 _reason, uint256 _amount)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(_reason == "SM" || _reason == "DR","Unspecified reason");\n', '        require(_amount != 0, AMOUNT_ZERO);\n', '        require(tokensLocked(msg.sender, _reason) > 0, NOT_LOCKED);\n', '        require(token.transferFrom(msg.sender, address(this), _amount));\n', '\n', '        locked[msg.sender][_reason].amount = locked[msg.sender][_reason].amount.add(_amount);\n', '        if(_reason == "SM") {\n', '            locked[msg.sender][_reason].validity = locked[msg.sender][_reason].validity.add(smLockPeriod);\n', '        }\n', '        \n', '        emit Locked(msg.sender, _reason, locked[msg.sender][_reason].amount, locked[msg.sender][_reason].validity);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Extends lock for a specified reason and time\n', '     * @param _reason The reason to lock tokens\n', '     * @param _time Lock extension time in seconds\n', '     */\n', '    function extendLock(bytes32 _reason, uint256 _time)\n', '        public\n', '        returns (bool)\n', '    {\n', '        if(_reason == "SM") {\n', '            require(_time == smLockPeriod, "Must be smLockPeriod");\n', '        }\n', '        require(_time != 0, "Time cannot be zero");\n', '        require(tokensLocked(msg.sender, _reason) > 0, NOT_LOCKED);\n', '\n', '        locked[msg.sender][_reason].validity = locked[msg.sender][_reason].validity.add(_time);\n', '\n', '        emit Locked(msg.sender, _reason, locked[msg.sender][_reason].amount, locked[msg.sender][_reason].validity);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns unlockable tokens for a specified address for a specified reason\n', '     * @param _of The address to query the the unlockable token count of\n', '     * @param _reason The reason to query the unlockable tokens for\n', '     */\n', '    function tokensUnlockable(address _of, bytes32 _reason)\n', '        public\n', '        view\n', '        returns (uint256 amount)\n', '    {\n', '        if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) //solhint-disable-line\n', '            amount = locked[_of][_reason].amount;\n', '    }\n', '\n', '    /**\n', '     * @dev Unlocks the unlockable tokens of a specified address\n', '     * @param _of Address of user, claiming back unlockable tokens\n', '     */\n', '    function unlock(address _of)\n', '        public\n', '        returns (uint256 unlockableTokens)\n', '    {\n', '        // require(!(token.isLockedForGV(_of)));\n', '        uint256 lockedTokens;\n', '\n', '        for (uint256 i = 0; i < lockReason[_of].length; i++) {\n', '            lockedTokens = tokensUnlockable(_of, lockReason[_of][i]);\n', '            if (lockedTokens > 0) {\n', '                unlockableTokens = unlockableTokens.add(lockedTokens);\n', '                locked[_of][lockReason[_of][i]].amount = locked[_of][lockReason[_of][i]].amount.sub(lockedTokens);\n', '                locked[_of][lockReason[_of][i]].claimed = true;\n', '                emit Unlocked(_of, lockReason[_of][i], lockedTokens);\n', '            }\n', '            if (locked[_of][lockReason[_of][i]].amount == 0) {\n', '                _removeReason(_of, lockReason[_of][i]);\n', '                i--;\n', '            }\n', '        }  \n', '\n', '        if (unlockableTokens > 0)\n', '            token.transfer(_of, unlockableTokens);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the unlockable tokens of a specified address\n', '     * @param _of The address to query the the unlockable token count of\n', '     */\n', '    function getUnlockableTokens(address _of)\n', '        public\n', '        view\n', '        returns (uint256 unlockableTokens)\n', '    {\n', '        for (uint256 i = 0; i < lockReason[_of].length; i++) {\n', '            unlockableTokens = unlockableTokens.add(tokensUnlockable(_of, lockReason[_of][i]));\n', '        }  \n', '    }\n', '\n', '    /**\n', "     * @dev Lock the user's tokens\n", "     * @param _of user's address.\n", '     */\n', '    function lockForGovernanceVote(address _of, uint _period) public onlyAuthorizedToGovern {\n', '        token.lockForGovernanceVote(_of, _period);\n', '    }\n', '\n', '\n', '    function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyAuthorizedToGovern\n', '        returns (bool)\n', '    {\n', '        require(_reason == "DR","Reason must be DR");\n', '        uint256 amount = tokensLockedAtTime(_of, _reason, now);\n', '        require(amount >= _amount, "Tokens locked must be greater than amount");\n', '\n', '        locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\n', '        if (locked[_of][_reason].amount == 0) {\n', '            locked[_of][_reason].claimed = true;\n', '            _removeReason(_of, _reason);\n', '        }\n', '        token.burn(_amount);\n', '        emit Burned(_of, _reason, _amount);\n', '    }\n', '\n', '    function _removeReason(address _of, bytes32 _reason) internal {\n', '        uint len = lockReason[_of].length;\n', '        for (uint i = 0; i < len; i++) {\n', '            if (lockReason[_of][i] == _reason) {\n', '                lockReason[_of][i] = lockReason[_of][len.sub(1)];\n', '                lockReason[_of].pop();\n', '                break;\n', '            }\n', '        }   \n', '    }\n', '\n', '}']