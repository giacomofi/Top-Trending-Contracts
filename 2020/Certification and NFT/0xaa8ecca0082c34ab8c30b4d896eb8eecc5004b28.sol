['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '// File: contracts/vaults/ValueVaultMaster.sol\n', '\n', '/*\n', ' * Here we have a list of constants. In order to get access to an address\n', ' * managed by ValueVaultMaster, the calling contract should copy and define\n', ' * some of these constants and use them as keys.\n', ' * Keys themselves are immutable. Addresses can be immutable or mutable.\n', ' *\n', ' * Vault addresses are immutable once set, and the list may grow:\n', ' * K_VAULT_WETH = 0;\n', ' * K_VAULT_ETH_USDC_UNI_V2_LP = 1;\n', ' * K_VAULT_ETH_WBTC_UNI_V2_LP = 2;\n', ' */\n', '\n', '/*\n', ' * ValueVaultMaster manages all the vaults and strategies of our Value Vaults system.\n', ' */\n', 'contract ValueVaultMaster {\n', '    address public governance;\n', '\n', '    address public bank;\n', '    address public minorPool;\n', '    address public profitSharer;\n', '\n', '    address public govToken; // VALUE\n', '    address public yfv; // When harvesting, convert some parts to YFV for govVault\n', '    address public usdc; // we only used USDC to estimate APY\n', '\n', '    address public govVault; // YFV -> VALUE, vUSD, vETH and 6.7% profit from Value Vaults\n', '    address public insuranceFund = 0xb7b2Ea8A1198368f950834875047aA7294A2bDAa; // set to Governance Multisig at start\n', '    address public performanceReward = 0x7Be4D5A99c903C437EC77A20CB6d0688cBB73c7f; // set to deploy wallet at start\n', '\n', '    uint256 public constant FEE_DENOMINATOR = 10000;\n', '    uint256 public govVaultProfitShareFee = 670; // 6.7% | VIP-1 (https://yfv.finance/vip-vote/vip_1)\n', '    uint256 public gasFee = 50; // 0.5% at start and can be set by governance decision\n', '\n', '    uint256 public minStakeTimeToClaimVaultReward = 24 hours;\n', '\n', '    mapping(address => bool) public isVault;\n', '    mapping(uint256 => address) public vaultByKey;\n', '\n', '    mapping(address => bool) public isStrategy;\n', '    mapping(uint256 => address) public strategyByKey;\n', '    mapping(address => uint256) public strategyQuota;\n', '\n', '    constructor(address _govToken, address _yfv, address _usdc) public {\n', '        govToken = _govToken;\n', '        yfv = _yfv;\n', '        usdc = _usdc;\n', '        governance = tx.origin;\n', '    }\n', '\n', '    function setGovernance(address _governance) external {\n', '        require(msg.sender == governance, "!governance");\n', '        governance = _governance;\n', '    }\n', '\n', '    // Immutable once set.\n', '    function setBank(address _bank) external {\n', '        require(msg.sender == governance, "!governance");\n', '        require(bank == address(0));\n', '        bank = _bank;\n', '    }\n', '\n', '    // Mutable in case we want to upgrade the pool.\n', '    function setMinorPool(address _minorPool) external {\n', '        require(msg.sender == governance, "!governance");\n', '        minorPool = _minorPool;\n', '    }\n', '\n', '    // Mutable in case we want to upgrade this module.\n', '    function setProfitSharer(address _profitSharer) external {\n', '        require(msg.sender == governance, "!governance");\n', '        profitSharer = _profitSharer;\n', '    }\n', '\n', '    // Mutable, in case governance want to upgrade VALUE to new version\n', '    function setGovToken(address _govToken) external {\n', '        require(msg.sender == governance, "!governance");\n', '        govToken = _govToken;\n', '    }\n', '\n', '    // Immutable once added, and you can always add more.\n', '    function addVault(uint256 _key, address _vault) external {\n', '        require(msg.sender == governance, "!governance");\n', '        require(vaultByKey[_key] == address(0), "vault: key is taken");\n', '\n', '        isVault[_vault] = true;\n', '        vaultByKey[_key] = _vault;\n', '    }\n', '\n', '    // Mutable and removable.\n', '    function addStrategy(uint256 _key, address _strategy) external {\n', '        require(msg.sender == governance, "!governance");\n', '        isStrategy[_strategy] = true;\n', '        strategyByKey[_key] = _strategy;\n', '    }\n', '\n', '    // Set 0 to disable quota (no limit)\n', '    function setStrategyQuota(address _strategy, uint256 _quota) external {\n', '        require(msg.sender == governance, "!governance");\n', '        strategyQuota[_strategy] = _quota;\n', '    }\n', '\n', '    function removeStrategy(uint256 _key) external {\n', '        require(msg.sender == governance, "!governance");\n', '        isStrategy[strategyByKey[_key]] = false;\n', '        delete strategyByKey[_key];\n', '    }\n', '\n', '    function setGovVault(address _govVault) public {\n', '        require(msg.sender == governance, "!governance");\n', '        govVault = _govVault;\n', '    }\n', '\n', '    function setInsuranceFund(address _insuranceFund) public {\n', '        require(msg.sender == governance, "!governance");\n', '        insuranceFund = _insuranceFund;\n', '    }\n', '\n', '    function setPerformanceReward(address _performanceReward) public{\n', '        require(msg.sender == governance, "!governance");\n', '        performanceReward = _performanceReward;\n', '    }\n', '\n', '    function setGovVaultProfitShareFee(uint256 _govVaultProfitShareFee) public {\n', '        require(msg.sender == governance, "!governance");\n', '        govVaultProfitShareFee = _govVaultProfitShareFee;\n', '    }\n', '\n', '    function setGasFee(uint256 _gasFee) public {\n', '        require(msg.sender == governance, "!governance");\n', '        gasFee = _gasFee;\n', '    }\n', '\n', '    function setMinStakeTimeToClaimVaultReward(uint256 _minStakeTimeToClaimVaultReward) public {\n', '        require(msg.sender == governance, "!governance");\n', '        minStakeTimeToClaimVaultReward = _minStakeTimeToClaimVaultReward;\n', '    }\n', '\n', '    /**\n', '     * This function allows governance to take unsupported tokens out of the contract.\n', '     * This is in an effort to make someone whole, should they seriously mess up.\n', '     * There is no guarantee governance will vote to return these.\n', '     * It also allows for removal of airdropped tokens.\n', '     */\n', '    function governanceRecoverUnsupported(IERC20x _token, uint256 amount, address to) external {\n', '        require(msg.sender == governance, "!governance");\n', '        _token.transfer(to, amount);\n', '    }\n', '}\n', '\n', 'interface IERC20x {\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '}']