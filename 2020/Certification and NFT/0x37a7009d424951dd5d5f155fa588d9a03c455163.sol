['pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// Gelato Data Types\n', 'struct Provider {\n', '    address addr;  //  if msg.sender == provider => self-Provider\n', '    address module;  //  e.g. DSA Provider Module\n', '}\n', '\n', 'struct Condition {\n', '    address inst;  // can be AddressZero for self-conditional Actions\n', '    bytes data;  // can be bytes32(0) for self-conditional Actions\n', '}\n', '\n', 'enum Operation { Call, Delegatecall }\n', '\n', 'enum DataFlow { None, In, Out, InAndOut }\n', '\n', 'struct Action {\n', '    address addr;\n', '    bytes data;\n', '    Operation operation;\n', '    DataFlow dataFlow;\n', '    uint256 value;\n', '    bool termsOkCheck;\n', '}\n', '\n', 'struct Task {\n', '    Condition[] conditions;  // optional\n', '    Action[] actions;\n', '    uint256 selfProviderGasLimit;  // optional: 0 defaults to gelatoMaxGas\n', '    uint256 selfProviderGasPriceCeil;  // optional: 0 defaults to NO_CEIL\n', '}\n', '\n', 'struct TaskReceipt {\n', '    uint256 id;\n', '    address userProxy;\n', '    Provider provider;\n', '    uint256 index;\n', '    Task[] tasks;\n', '    uint256 expiryDate;\n', '    uint256 cycleId;  // auto-filled by GelatoCore. 0 for non-cyclic/chained tasks\n', '    uint256 submissionsLeft;\n', '}\n', '\n', 'struct TaskSpec {\n', '    address[] conditions;   // Address: optional AddressZero for self-conditional actions\n', '    Action[] actions;\n', '    uint256 gasPriceCeil;\n', '}\n', '\n', '// Gelato Interface\n', 'interface IGelatoInterface {\n', '\n', '    /**\n', '     * @dev API to submit a single Task.\n', '    */\n', '    function submitTask(\n', '        Provider calldata _provider,\n', '        Task calldata _task,\n', '        uint256 _expiryDate\n', '    )\n', '        external;\n', '\n', '\n', '    /**\n', '     * @dev A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n', '     * the next one, after they have been executed, where the total number of tasks can\n', '     * be only be an even number\n', '    */\n', '    function submitTaskCycle(\n', '        Provider calldata _provider,\n', '        Task[] calldata _tasks,\n', '        uint256 _expiryDate,\n', '        uint256 _cycles\n', '    )\n', '        external;\n', '\n', '\n', '    /**\n', '     * @dev A Gelato Task Chain consists of 1 or more Tasks that automatically submit\n', '     * the next one, after they have been executed, where the total number of tasks can\n', '     * be an odd number\n', '    */\n', '    function submitTaskChain(\n', '        Provider calldata _provider,\n', '        Task[] calldata _tasks,\n', '        uint256 _expiryDate,\n', '        uint256 _sumOfRequestedTaskSubmits\n', '    )\n', '        external;\n', '\n', '    /**\n', '     * @dev Cancel multiple tasks at once\n', '    */\n', '    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\n', '\n', '    /**\n', '     * @dev Whitelist new executor, TaskSpec(s) and Module(s) in one tx\n', '    */\n', '    function multiProvide(\n', '        address _executor,\n', '        TaskSpec[] calldata _taskSpecs,\n', '        address[] calldata _modules\n', '    )\n', '        external\n', '        payable;\n', '\n', '\n', '    /**\n', '     * @dev De-Whitelist TaskSpec(s), Module(s) and withdraw funds from gelato in one tx\n', '    */\n', '    function multiUnprovide(\n', '        uint256 _withdrawAmount,\n', '        TaskSpec[] calldata _taskSpecs,\n', '        address[] calldata _modules\n', '    )\n', '        external;\n', '}\n', '\n', '\n', 'interface MemoryInterface {\n', '    function setUint(uint _id, uint _val) external;\n', '    function getUint(uint _id) external returns (uint);\n', '}\n', '\n', 'contract Helpers {\n', '\n', '    /**\n', '     * @dev Return Memory Variable Address\n', '    */\n', '    function getMemoryAddr() internal pure returns (address) {\n', '        return 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F; // InstaMemory Address\n', '    }\n', '\n', '    /**\n', '     * @dev Set Uint value in InstaMemory Contract.\n', '    */\n', '    function setUint(uint setId, uint val) internal {\n', '        if (setId != 0) MemoryInterface(getMemoryAddr()).setUint(setId, val);\n', '    }\n', '\n', '    /**\n', '     * @dev Get Uint value from InstaMemory Contract.\n', '    */\n', '    function getUint(uint getId, uint val) internal returns (uint returnVal) {\n', '        returnVal = getId == 0 ? val : MemoryInterface(getMemoryAddr()).getUint(getId);\n', '    }\n', '\n', '    /**\n', '     * @dev Connector Details\n', '    */\n', '    function connectorID() public pure returns(uint _type, uint _id) {\n', '        (_type, _id) = (1, 42);\n', '    }\n', '}\n', '\n', 'contract DSMath {\n', '\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x, "math-not-safe");\n', '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "sub-overflow");\n', '    }\n', '}\n', '\n', 'contract GelatoHelpers is Helpers, DSMath {\n', '\n', '    /**\n', '     * @dev Return Gelato Core Address\n', '    */\n', '    function getGelatoCoreAddr() internal pure returns (address) {\n', '        return 0x1d681d76ce96E4d70a88A00EBbcfc1E47808d0b8; // Gelato Core address\n', '    }\n', '\n', '    /**\n', '     * @dev Return Instapp DSA Provider Module Address\n', '    */\n', '    function getInstadappProviderModuleAddr() internal pure returns (address) {\n', '        return 0x0C25452d20cdFeEd2983fa9b9b9Cf4E81D6f2fE2; // ProviderModuleDSA Address\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract GelatoResolver is GelatoHelpers {\n', '\n', '    event LogMultiProvide(address indexed executor, TaskSpec[] indexed taskspecs, address[] indexed modules, uint256 ethToDeposit, uint256 getId, uint256 setId);\n', '\n', '    event LogSubmitTask(Provider indexed provider, Task indexed task, uint256 indexed expiryDate, uint256 getId, uint256 setId);\n', '\n', '    event LogSubmitTaskCycle(Provider indexed provider, Task[] indexed tasks, uint256 indexed expiryDate, uint256 getId, uint256 setId);\n', '\n', '    event LogSubmitTaskChain(Provider indexed provider, Task[] indexed tasks, uint256 indexed expiryDate, uint256 getId, uint256 setId);\n', '\n', '    event LogMultiUnprovide(TaskSpec[] indexed taskspecs, address[] indexed modules, uint256 ethToWithdraw, uint256 getId, uint256 setId);\n', '\n', '    event LogMultiCancelTasks(TaskReceipt[] indexed taskReceipt, uint256 getId, uint256 setId);\n', '\n', '\n', '    // ===== Gelato ENTRY APIs ======\n', '\n', '    /**\n', '     * @dev Enables first time users to  pre-fund eth, whitelist an executor & register the\n', '     * ProviderModuleDSA.sol to be able to use Gelato\n', "     * @param _executor address of single execot node or gelato'S decentralized execution market\n", '     * @param _taskSpecs enables external providers to whitelist TaskSpecs on gelato\n', '     * @param _modules address of ProviderModuleDSA\n', '     * @param _ethToDeposit amount of eth to deposit on Gelato, only for self-providers\n', '    */\n', '    function multiProvide(\n', '        address _executor,\n', '        TaskSpec[] calldata _taskSpecs,\n', '        address[] calldata _modules,\n', '        uint256 _ethToDeposit,\n', '        uint256 _getId,\n', '        uint256 _setId\n', '    )\n', '        external\n', '        payable\n', '    {\n', '        uint256 ethToDeposit = getUint(_getId, _ethToDeposit);\n', '        ethToDeposit = ethToDeposit == uint(-1) ? address(this).balance : ethToDeposit;\n', '\n', '        IGelatoInterface(getGelatoCoreAddr()).multiProvide.value(ethToDeposit)(\n', '            _executor,\n', '            _taskSpecs,\n', '            _modules\n', '        );\n', '\n', '        setUint(_setId, ethToDeposit);\n', '\n', '        emit LogMultiProvide(_executor, _taskSpecs, _modules, ethToDeposit, _getId, _setId);\n', '    }\n', '\n', '    /**\n', '     * @dev Submits a single, one-time task to Gelato\n', '     * @param _provider Consists of proxy module address (DSA) and provider address ()\n', '     * who will pay for the transaction execution\n', '     * @param _task Task specifying the condition and the action connectors\n', '     * @param _expiryDate Default 0, othweise timestamp after which the task expires\n', '    */\n', '    function submitTask(\n', '        Provider calldata _provider,\n', '        Task calldata _task,\n', '        uint256 _expiryDate\n', '    )\n', '        external\n', '        payable\n', '    {\n', '        IGelatoInterface(getGelatoCoreAddr()).submitTask(_provider, _task, _expiryDate);\n', '\n', '        emit LogSubmitTask(_provider, _task, _expiryDate, 0, 0);\n', '    }\n', '\n', '    /**\n', '     * @dev Submits single or mulitple Task Sequences to Gelato\n', '     * @param _provider Consists of proxy module address (DSA) and provider address ()\n', '     * who will pay for the transaction execution\n', '     * @param _tasks A sequence of Tasks, can be a single or multiples\n', '     * @param _expiryDate Default 0, othweise timestamp after which the task expires\n', '     * @param _cycles How often the Task List should be executed, e.g. 5 times\n', '    */\n', '    function submitTaskCycle(\n', '        Provider calldata _provider,\n', '        Task[] calldata _tasks,\n', '        uint256 _expiryDate,\n', '        uint256 _cycles\n', '    )\n', '        external\n', '        payable\n', '    {\n', '        IGelatoInterface(getGelatoCoreAddr()).submitTaskCycle(\n', '            _provider,\n', '            _tasks,\n', '            _expiryDate,\n', '            _cycles\n', '        );\n', '\n', '        emit LogSubmitTaskCycle(_provider, _tasks, _expiryDate, 0, 0);\n', '    }\n', '\n', '    /**\n', '     * @dev Submits single or mulitple Task Chains to Gelato\n', '     * @param _provider Consists of proxy module address (DSA) and provider address ()\n', '     * who will pay for the transaction execution\n', '     * @param _tasks A sequence of Tasks, can be a single or multiples\n', '     * @param _expiryDate Default 0, othweise timestamp after which the task expires\n', '     * @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\n', '     * that should have occured once the cycle is complete\n', '    */\n', '    function submitTaskChain(\n', '        Provider calldata _provider,\n', '        Task[] calldata _tasks,\n', '        uint256 _expiryDate,\n', '        uint256 _sumOfRequestedTaskSubmits\n', '    )\n', '        external\n', '        payable\n', '    {\n', '        IGelatoInterface(getGelatoCoreAddr()).submitTaskChain(\n', '            _provider,\n', '            _tasks,\n', '            _expiryDate,\n', '            _sumOfRequestedTaskSubmits\n', '        );\n', '\n', '        emit LogSubmitTaskChain(_provider, _tasks, _expiryDate, 0, 0);\n', '    }\n', '\n', '    // ===== Gelato EXIT APIs ======\n', '\n', '    /**\n', '     * @dev Withdraws funds from Gelato, de-whitelists TaskSpecs and Provider Modules\n', '     * in one tx\n', '     * @param _withdrawAmount Amount of ETH to withdraw from Gelato\n', '     * @param _taskSpecs List of Task Specs to de-whitelist, default empty []\n', '     * @param _modules List of Provider Modules to de-whitelist, default empty []\n', '    */\n', '    function multiUnprovide(\n', '        uint256 _withdrawAmount,\n', '        TaskSpec[] calldata _taskSpecs,\n', '        address[] calldata _modules,\n', '        uint256 _getId,\n', '        uint256 _setId\n', '    )\n', '        external\n', '        payable\n', '    {\n', '        uint256 withdrawAmount = getUint(_getId, _withdrawAmount);\n', '        uint256 balanceBefore = address(this).balance;\n', '\n', '        IGelatoInterface(getGelatoCoreAddr()).multiUnprovide(\n', '            withdrawAmount,\n', '            _taskSpecs,\n', '            _modules\n', '        );\n', '\n', '        uint256 actualWithdrawAmount = sub(address(this).balance, balanceBefore);\n', '\n', '        setUint(_setId, actualWithdrawAmount);\n', '\n', '        emit LogMultiUnprovide(_taskSpecs, _modules, actualWithdrawAmount, _getId, _setId);\n', '    }\n', '\n', '    /**\n', '     * @dev Cancels outstanding Tasks\n', '     * @param _taskReceipts List of Task Receipts to cancel\n', '    */\n', '    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts)\n', '        external\n', '        payable\n', '    {\n', '        IGelatoInterface(getGelatoCoreAddr()).multiCancelTasks(_taskReceipts);\n', '\n', '        emit LogMultiCancelTasks(_taskReceipts, 0, 0);\n', '    }\n', '}\n', '\n', '\n', 'contract ConnectGelato is GelatoResolver {\n', '    string public name = "Gelato-v1.0";\n', '}']