['pragma solidity ^0.4.26;\n', '\n', 'contract DSValue {\n', '    \n', '    function peek() public view returns (bytes32, bool);\n', '\n', '    function read() public view returns (bytes32);\n', '}\n', '\n', 'contract ErrorReporter {\n', '\n', '    function fail(Error err, FailureInfo info) internal returns (uint) {\n', '        emit Failure(uint(err), uint(info), 0);\n', '\n', '        return uint(err);\n', '    }\n', '\n', '    function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {\n', '        emit Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);\n', '\n', '        return uint(Error.OPAQUE_ERROR);\n', '    }\n', '\n', '    event Failure(uint error, uint info, uint detail);\n', '\n', '    enum Error {\n', '        NO_ERROR,\n', '        OPAQUE_ERROR, \n', '        UNAUTHORIZED,\n', '        INTEGER_OVERFLOW,\n', '        INTEGER_UNDERFLOW,\n', '        DIVISION_BY_ZERO,\n', '        BAD_INPUT,\n', '        TOKEN_INSUFFICIENT_ALLOWANCE,\n', '        TOKEN_INSUFFICIENT_BALANCE,\n', '        TOKEN_TRANSFER_FAILED,\n', '        MARKET_NOT_SUPPORTED,\n', '        SUPPLY_RATE_CALCULATION_FAILED,\n', '        BORROW_RATE_CALCULATION_FAILED,\n', '        TOKEN_INSUFFICIENT_CASH,\n', '        TOKEN_TRANSFER_OUT_FAILED,\n', '        INSUFFICIENT_LIQUIDITY,\n', '        INSUFFICIENT_BALANCE,\n', '        INVALID_COLLATERAL_RATIO,\n', '        MISSING_ASSET_PRICE,\n', '        EQUITY_INSUFFICIENT_BALANCE,\n', '        INVALID_CLOSE_AMOUNT_REQUESTED,\n', '        ASSET_NOT_PRICED,\n', '        INVALID_LIQUIDATION_DISCOUNT,\n', '        INVALID_COMBINED_RISK_PARAMETERS\n', '    }\n', '\n', '    enum FailureInfo {\n', '        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n', '        BORROW_ACCOUNT_SHORTFALL_PRESENT,\n', '        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\n', '        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\n', '        BORROW_MARKET_NOT_SUPPORTED,\n', '        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\n', '        BORROW_TRANSFER_OUT_FAILED,\n', '        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\n', '        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\n', '        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\n', '        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\n', '        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\n', '        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n', '        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n', '        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\n', '        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\n', '        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\n', '        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\n', '        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n', '        LIQUIDATE_TRANSFER_IN_FAILED,\n', '        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\n', '        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        REPAY_BORROW_TRANSFER_IN_FAILED,\n', '        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n', '        SET_ADMIN_OWNER_CHECK,\n', '        SET_ASSET_PRICE_CHECK_ORACLE,\n', '        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\n', '        SET_ORACLE_OWNER_CHECK,\n', '        SET_ORIGINATION_FEE_OWNER_CHECK,\n', '        SET_RISK_PARAMETERS_OWNER_CHECK,\n', '        SET_RISK_PARAMETERS_VALIDATION,\n', '        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        SUPPLY_MARKET_NOT_SUPPORTED,\n', '        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n', '        SUPPLY_TRANSFER_IN_FAILED,\n', '        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\n', '        SUPPORT_MARKET_OWNER_CHECK,\n', '        SUPPORT_MARKET_PRICE_CHECK,\n', '        SUSPEND_MARKET_OWNER_CHECK,\n', '        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n', '        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\n', '        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\n', '        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\n', '        WITHDRAW_CAPACITY_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n', '        WITHDRAW_TRANSFER_OUT_FAILED,\n', '        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n', '    }\n', '\n', '}\n', '\n', '/**\n', '  * @title Careful Math\n', "  * @notice Derived from OpenZeppelin's SafeMath library\n", '  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '  */\n', '  \n', 'contract CarefulMath is ErrorReporter {\n', '\n', '\n', '    function mul(uint a, uint b) internal pure returns (Error, uint) {\n', '        if (a == 0) {\n', '            return (Error.NO_ERROR, 0);\n', '        }\n', '\n', '        uint c = a * b;\n', '\n', '        if (c / a != b) {\n', '            return (Error.INTEGER_OVERFLOW, 0);\n', '        } else {\n', '            return (Error.NO_ERROR, c);\n', '        }\n', '    }\n', '\n', '    function div(uint a, uint b) internal pure returns (Error, uint) {\n', '        if (b == 0) {\n', '            return (Error.DIVISION_BY_ZERO, 0);\n', '        }\n', '\n', '        return (Error.NO_ERROR, a / b);\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (Error, uint) {\n', '        if (b <= a) {\n', '            return (Error.NO_ERROR, a - b);\n', '        } else {\n', '            return (Error.INTEGER_UNDERFLOW, 0);\n', '        }\n', '    }\n', '\n', '    function add(uint a, uint b) internal pure returns (Error, uint) {\n', '        uint c = a + b;\n', '\n', '        if (c >= a) {\n', '            return (Error.NO_ERROR, c);\n', '        } else {\n', '            return (Error.INTEGER_OVERFLOW, 0);\n', '        }\n', '    }\n', '\n', '    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n', '        (Error err0, uint sum) = add(a, b);\n', '\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, 0);\n', '        }\n', '\n', '        return sub(sum, c);\n', '    }\n', '}\n', '\n', 'contract Exponential is ErrorReporter, CarefulMath {\n', '\n', '    // TODO: We may wish to put the result of 10**18 here instead of the expression.\n', '    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\n', '    // the optimizer MAY replace the expression 10**18 with its calculated value.\n', '    uint constant expScale = 10**18;\n', '\n', '    // See TODO on expScale\n', '    uint constant halfExpScale = expScale/2;\n', '\n', '    struct Exp {\n', '        uint mantissa;\n', '    }\n', '\n', '    uint constant mantissaOne = 10**18;\n', '    uint constant mantissaOneTenth = 10**17;\n', '\n', '    /**\n', '    * @dev Creates an exponential from numerator and denominator values.\n', '    *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n', '    *            or if `denom` is zero.\n', '    */\n', '    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\n', '        (Error err0, uint scaledNumerator) = mul(num, expScale);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (Error err1, uint rational) = div(scaledNumerator, denom);\n', '        if (err1 != Error.NO_ERROR) {\n', '            return (err1, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: rational}));\n', '    }\n', '\n', '\n', '    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n', '        (Error error, uint result) = add(a.mantissa, b.mantissa);\n', '\n', '        return (error, Exp({mantissa: result}));\n', '    }\n', '\n', '\n', '\n', '    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n', '        (Error error, uint result) = sub(a.mantissa, b.mantissa);\n', '\n', '        return (error, Exp({mantissa: result}));\n', '    }\n', '\n', '\n', '    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n', '        (Error err0, uint scaledMantissa) = mul(a.mantissa, scalar);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\n', '    }\n', '\n', '\n', '    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n', '        (Error err0, uint descaledMantissa) = div(a.mantissa, scalar);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\n', '    }\n', '\n', '\n', '    function divScalarByExp(uint scalar, Exp divisor) pure internal returns (Error, Exp memory) {\n', '        /*\n', '            We are doing this as:\n', '            getExp(mul(expScale, scalar), divisor.mantissa)\n', '\n', '            How it works:\n', '            Exp = a / b;\n', '            Scalar = s;\n', '            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n', '        */\n', '        (Error err0, uint numerator) = mul(expScale, scalar);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '        return getExp(numerator, divisor.mantissa);\n', '    }\n', '\n', '\n', '    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n', '\n', '        (Error err0, uint doubleScaledProduct) = mul(a.mantissa, b.mantissa);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        // We add half the scale before dividing so that we get rounding instead of truncation.\n', '        //  See "Listing 6" and text above it at https://accu.org/index.php/journals/1717\n', '        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n', '        (Error err1, uint doubleScaledProductWithHalfScale) = add(halfExpScale, doubleScaledProduct);\n', '        if (err1 != Error.NO_ERROR) {\n', '            return (err1, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (Error err2, uint product) = div(doubleScaledProductWithHalfScale, expScale);\n', '        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n', '        assert(err2 == Error.NO_ERROR);\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: product}));\n', '    }\n', '\n', '    /**\n', '      * @dev Divides two exponentials, returning a new exponential.\n', '      *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n', '      *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n', '      */\n', '    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n', '        return getExp(a.mantissa, b.mantissa);\n', '    }\n', '\n', '    /**\n', '      * @dev Truncates the given exp to a whole number value.\n', '      *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\n', '      */\n', '    function truncate(Exp memory exp) pure internal returns (uint) {\n', "        // Note: We are not using careful math here as we're performing a division that cannot fail\n", '        return exp.mantissa / 10**18;\n', '    }\n', '\n', '    /**\n', '      * @dev Checks if first Exp is less than second Exp.\n', '      */\n', '    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n', '        return left.mantissa < right.mantissa; //TODO: Add some simple tests and this in another PR yo.\n', '    }\n', '\n', '    /**\n', '      * @dev Checks if left Exp <= right Exp.\n', '      */\n', '    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n', '        return left.mantissa <= right.mantissa;\n', '    }\n', '\n', '    /**\n', '      * @dev Checks if first Exp is greater than second Exp.\n', '      */\n', '    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n', '        return left.mantissa > right.mantissa;\n', '    }\n', '\n', '    /**\n', '      * @dev returns true if Exp is exactly zero\n', '      */\n', '    function isZeroExp(Exp memory value) pure internal returns (bool) {\n', '        return value.mantissa == 0;\n', '    }\n', '}\n', 'contract PriceOracle is Exponential {\n', '\n', '    /**\n', '      * @dev flag for whether or not contract is paused\n', '      *\n', '      */\n', '    bool public paused;\n', '\n', '    uint public constant numBlocksPerPeriod = 240; // approximately 1 hour: 60 seconds/minute * 60 minutes/hour * 1 block/15 seconds\n', '\n', '    uint public constant maxSwingMantissa = (10 ** 17); // 0.1\n', '\n', '    /**\n', '      * @dev Mapping of asset addresses to DSValue price oracle contracts. The price contracts\n', '      *      should be DSValue contracts whose value is the `eth:asset` price scaled by 1e18.\n', '      *      That is, 1 eth is worth how much of the asset (e.g. 1 eth = 100 USD). We want\n', '      *      to know the inverse, which is how much eth is one asset worth. This `asset:eth`\n', '      *      is the multiplicative inverse (in that example, 1/100). The math is a bit trickier\n', '      *      since we need to descale the number by 1e18, inverse, and then rescale the number.\n', '      *      We perform this operation to return the `asset:eth` price for these reader assets.\n', '      *\n', '      * map: assetAddress -> DSValue price oracle\n', '      */\n', '    mapping(address => DSValue) public readers;\n', '\n', '    /**\n', '      * @dev Mapping of asset addresses and their corresponding price in terms of Eth-Wei\n', '      *      which is simply equal to AssetWeiPrice * 10e18. For instance, if OMG token was\n', '      *      worth 5x Eth then the price for OMG would be 5*10e18 or Exp({mantissa: 5000000000000000000}).\n', '      * map: assetAddress -> Exp\n', '      */\n', '    mapping(address => Exp) public _assetPrices;\n', '    constructor( ) public {\n', '        anchorAdmin = msg.sender;\n', '        poster = msg.sender;\n', '        maxSwing = Exp({mantissa : maxSwingMantissa}); \n', '    }\n', '    \n', '    /**\n', '      * @notice Do not pay into PriceOracle\n', '      */\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    enum OracleError {\n', '        NO_ERROR,\n', '        UNAUTHORIZED,\n', '        FAILED_TO_SET_PRICE\n', '    }\n', '\n', '    enum OracleFailureInfo {\n', '        ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK,\n', '        SET_PAUSED_OWNER_CHECK,\n', '        SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK,\n', '        SET_PENDING_ANCHOR_PERMISSION_CHECK,\n', '        SET_PRICE_CALCULATE_SWING,\n', '        SET_PRICE_CAP_TO_MAX,\n', '        SET_PRICE_MAX_SWING_CHECK,\n', '        SET_PRICE_NO_ANCHOR_PRICE_OR_INITIAL_PRICE_ZERO,\n', '        SET_PRICE_PERMISSION_CHECK,\n', '        SET_PRICE_ZERO_PRICE,\n', '        SET_PRICES_PARAM_VALIDATION,\n', '        SET_PRICE_IS_READER_ASSET\n', '    }\n', '\n', '    /**\n', '      * @dev `msgSender` is msg.sender; `error` corresponds to enum OracleError; `info` corresponds to enum OracleFailureInfo, and `detail` is an arbitrary\n', '      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n', '      **/\n', '    event OracleFailure(address msgSender, address asset, uint error, uint info, uint detail);\n', '\n', '    /**\n', '      * @dev use this when reporting a known error from the price oracle or a non-upgradeable collaborator\n', '      *      Using Oracle in name because we already inherit a `fail` function from ErrorReporter.sol via Exponential.sol\n', '      */\n', '    function failOracle(address asset, OracleError err, OracleFailureInfo info) internal returns (uint) {\n', '        emit OracleFailure(msg.sender, asset, uint(err), uint(info), 0);\n', '\n', '        return uint(err);\n', '    }\n', '\n', '    /**\n', '      * @dev Use this when reporting an error from the money market. Give the money market result as `details`\n', '      */\n', '    function failOracleWithDetails(address asset, OracleError err, OracleFailureInfo info, uint details) internal returns (uint) {\n', '        emit OracleFailure(msg.sender, asset, uint(err), uint(info), details);\n', '\n', '        return uint(err);\n', '    }\n', '\n', '    /**\n', '      * @dev An administrator who can set the pending anchor value for assets.\n', '      *      Set in the constructor.\n', '      */\n', '    address public anchorAdmin;\n', '\n', '    /**\n', '      * @dev pending anchor administrator for this contract.\n', '      */\n', '    address public pendingAnchorAdmin;\n', '\n', '    /**\n', '      * @dev Address of the price poster.\n', '      *      Set in the constructor.\n', '      */\n', '    address public poster;\n', '\n', '    /**\n', "      * @dev maxSwing the maximum allowed percentage difference between a new price and the anchor's price\n", '      *      Set only in the constructor\n', '      */\n', '    Exp public maxSwing;\n', '\n', '    struct Anchor {\n', '        // floor(block.number / numBlocksPerPeriod) + 1\n', '        uint period;\n', '\n', '        // Price in ETH, scaled by 10**18\n', '        uint priceMantissa;\n', '    }\n', '\n', '    /**\n', '      * @dev anchors by asset\n', '      */\n', '    mapping(address => Anchor) public anchors;\n', '\n', '    /**\n', '      * @dev pending anchor prices by asset\n', '      */\n', '    mapping(address => uint) public pendingAnchors;\n', '\n', '    /**\n', '      * @dev emitted when a pending anchor is set\n', '      * @param asset Asset for which to set a pending anchor\n', '      * @param oldScaledPrice if an unused pending anchor was present, its value; otherwise 0.\n', '      * @param newScaledPrice the new scaled pending anchor price\n', '      */\n', '    event NewPendingAnchor(address anchorAdmin, address asset, uint oldScaledPrice, uint newScaledPrice);\n', '\n', '    /**\n', '      * @notice provides ability to override the anchor price for an asset\n', '      * @dev Admin function to set the anchor price for an asset\n', '      * @param asset Asset for which to override the anchor price\n', '      * @param newScaledPrice New anchor price\n', '      * @return uint 0=success, otherwise a failure (see enum OracleError for details)\n', '      */\n', '    function _setPendingAnchor(address asset, uint newScaledPrice) public returns (uint) {\n', '        // Check caller = anchorAdmin. Note: Deliberately not allowing admin. They can just change anchorAdmin if desired.\n', '        if (msg.sender != anchorAdmin) {\n', '            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_PERMISSION_CHECK);\n', '        }\n', '\n', '        uint oldScaledPrice = pendingAnchors[asset];\n', '        pendingAnchors[asset] = newScaledPrice;\n', '\n', '        emit NewPendingAnchor(msg.sender, asset, oldScaledPrice, newScaledPrice);\n', '\n', '        return uint(OracleError.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @dev emitted for all price changes\n', '      */\n', '    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\n', '\n', '    /**\n', '      * @dev emitted if this contract successfully posts a capped-to-max price to the money market\n', '      */\n', '    event CappedPricePosted(address asset, uint requestedPriceMantissa, uint anchorPriceMantissa, uint cappedPriceMantissa);\n', '\n', '    /**\n', '      * @dev emitted when admin either pauses or resumes the contract; newState is the resulting state\n', '      */\n', '    event SetPaused(bool newState);\n', '\n', '    /**\n', '      * @dev emitted when pendingAnchorAdmin is changed\n', '      */\n', '    event NewPendingAnchorAdmin(address oldPendingAnchorAdmin, address newPendingAnchorAdmin);\n', '\n', '    /**\n', '      * @dev emitted when pendingAnchorAdmin is accepted, which means anchor admin is updated\n', '      */\n', '    event NewAnchorAdmin(address oldAnchorAdmin, address newAnchorAdmin);\n', '\n', '    /**\n', '      * @notice set `paused` to the specified state\n', '      * @dev Admin function to pause or resume the market\n', '      * @param requestedState value to assign to `paused`\n', '      * @return uint 0=success, otherwise a failure\n', '      */\n', '    function _setPaused(bool requestedState) public returns (uint) {\n', '        // Check caller = anchorAdmin\n', '        if (msg.sender != anchorAdmin) {\n', '            return failOracle(0, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PAUSED_OWNER_CHECK);\n', '        }\n', '\n', '        paused = requestedState;\n', '        emit SetPaused(requestedState);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Begins transfer of anchor admin rights. The newPendingAnchorAdmin must call `_acceptAnchorAdmin` to finalize the transfer.\n', '      * @dev Admin function to begin change of anchor admin. The newPendingAnchorAdmin must call `_acceptAnchorAdmin` to finalize the transfer.\n', '      * @param newPendingAnchorAdmin New pending anchor admin.\n', '      * @return uint 0=success, otherwise a failure\n', '      *\n', '      * TODO: Should we add a second arg to verify, like a checksum of `newAnchorAdmin` address?\n', '      */\n', '    function _setPendingAnchorAdmin(address newPendingAnchorAdmin) public returns (uint) {\n', '        // Check caller = anchorAdmin\n', '        if (msg.sender != anchorAdmin) {\n', '            return failOracle(0, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK);\n', '        }\n', '\n', '        // save current value, if any, for inclusion in log\n', '        address oldPendingAnchorAdmin = pendingAnchorAdmin;\n', '        // Store pendingAdmin = newPendingAdmin\n', '        pendingAnchorAdmin = newPendingAnchorAdmin;\n', '\n', '        emit NewPendingAnchorAdmin(oldPendingAnchorAdmin, newPendingAnchorAdmin);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Accepts transfer of anchor admin rights. msg.sender must be pendingAnchorAdmin\n', '      * @dev Admin function for pending anchor admin to accept role and update anchor admin\n', '      * @return uint 0=success, otherwise a failure\n', '      */\n', '    function _acceptAnchorAdmin() public returns (uint) {\n', '        // Check caller = pendingAnchorAdmin\n', "        // msg.sender can't be zero\n", '        if (msg.sender != pendingAnchorAdmin) {\n', '            return failOracle(0, OracleError.UNAUTHORIZED, OracleFailureInfo.ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK);\n', '        }\n', '\n', '        // Save current value for inclusion in log\n', '        address oldAnchorAdmin = anchorAdmin;\n', '        // Store admin = pendingAnchorAdmin\n', '        anchorAdmin = pendingAnchorAdmin;\n', '        // Clear the pending value\n', '        pendingAnchorAdmin = 0;\n', '\n', '        emit NewAnchorAdmin(oldAnchorAdmin, msg.sender);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice retrieves price of an asset\n', '      * @dev function to get price for an asset\n', '      * @param asset Asset for which to get the price\n', '      * @return uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused\n', '      */\n', '    function assetPrices(address asset) public view returns (uint) {\n', '        // Note: zero is treated by the money market as an invalid\n', '        //       price and will cease operations with that asset\n', '        //       when zero.\n', '        //\n', '        // We get the price as:\n', '        //\n', '        //  1. If the contract is paused, return 0.\n', '        //  2. If the asset is a reader asset:\n', '        //    a. If the reader has a value set, invert it and return.\n', '        //    b. Else, return 0.\n', '        //  3. Return price in `_assetPrices`, which may be zero.\n', '\n', '        if (paused) {\n', '            return 0;\n', '        } else {\n', '            if (readers[asset] != address(0)) {\n', '                (bytes32 readValue, bool foundValue) = readers[asset].peek();\n', '\n', '                if (foundValue) {\n', '                    (Error error, Exp memory invertedVal) = getExp(mantissaOne, uint256(readValue));\n', '\n', '                    if (error != Error.NO_ERROR) {\n', '                        return 0;\n', '                    }\n', '\n', '                    return invertedVal.mantissa;\n', '                } else {\n', '                    return 0;\n', '                }\n', '            } else {\n', '                return _assetPrices[asset].mantissa;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '      * @notice retrieves price of an asset\n', '      * @dev function to get price for an asset\n', '      * @param asset Asset for which to get the price\n', '      * @return uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused\n', '      */\n', '    function getPrice(address asset) public view returns (uint) {\n', '        return assetPrices(asset);\n', '    }\n', '\n', '    struct SetPriceLocalVars {\n', '        Exp price;\n', '        Exp swing;\n', '        Exp anchorPrice;\n', '        uint anchorPeriod;\n', '        uint currentPeriod;\n', '        bool priceCapped;\n', '        uint cappingAnchorPriceMantissa;\n', '        uint pendingAnchorMantissa;\n', '    }\n', '\n', '    /**\n', '      * @notice entry point for updating prices\n', '      * @dev function to set price for an asset\n', '      * @param asset Asset for which to set the price\n', '      * @param requestedPriceMantissa requested new price, scaled by 10**18\n', '      * @return uint 0=success, otherwise a failure (see enum OracleError for details)\n', '      */\n', '    function setPrice(address asset, uint requestedPriceMantissa) public returns (uint) {\n', '        // Fail when msg.sender is not poster\n', '        if (msg.sender != poster) {\n', '            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\n', '        }\n', '\n', '        return setPriceInternal(asset, requestedPriceMantissa);\n', '    }\n', '\n', '    function setPriceInternal(address asset, uint requestedPriceMantissa) internal returns (uint) {\n', '        // re-used for intermediate errors\n', '        Error err;\n', '        SetPriceLocalVars memory localVars;\n', "        // We add 1 for currentPeriod so that it can never be zero and there's no ambiguity about an unset value.\n", '        // (It can be a problem in tests with low block numbers.)\n', '        localVars.currentPeriod = (block.number / numBlocksPerPeriod) + 1;\n', '        localVars.pendingAnchorMantissa = pendingAnchors[asset];\n', '        localVars.price = Exp({mantissa : requestedPriceMantissa});\n', '\n', '        if (readers[asset] != address(0)) {\n', '            return failOracle(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_IS_READER_ASSET);\n', '        }\n', '\n', '        if (localVars.pendingAnchorMantissa != 0) {\n', "            // let's explicitly set to 0 rather than relying on default of declaration\n", '            localVars.anchorPeriod = 0;\n', '            localVars.anchorPrice = Exp({mantissa : localVars.pendingAnchorMantissa});\n', '\n', '            // Verify movement is within max swing of pending anchor (currently: 10%)\n', '            (err, localVars.swing) = calculateSwing(localVars.anchorPrice, localVars.price);\n', '            if (err != Error.NO_ERROR) {\n', '                return failOracleWithDetails(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_CALCULATE_SWING, uint(err));\n', '            }\n', '\n', '            // Fail when swing > maxSwing\n', '            if (greaterThanExp(localVars.swing, maxSwing)) {\n', '                return failOracleWithDetails(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_MAX_SWING_CHECK, localVars.swing.mantissa);\n', '            }\n', '        } else {\n', '            localVars.anchorPeriod = anchors[asset].period;\n', '            localVars.anchorPrice = Exp({mantissa : anchors[asset].priceMantissa});\n', '\n', '            if (localVars.anchorPeriod != 0) {\n', '                (err, localVars.priceCapped, localVars.price) = capToMax(localVars.anchorPrice, localVars.price);\n', '                if (err != Error.NO_ERROR) {\n', '                    return failOracleWithDetails(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_CAP_TO_MAX, uint(err));\n', '                }\n', '                if (localVars.priceCapped) {\n', '                    // save for use in log\n', '                    localVars.cappingAnchorPriceMantissa = localVars.anchorPrice.mantissa;\n', '                }\n', '            } else {\n', '                // Setting first price. Accept as is (already assigned above from requestedPriceMantissa) and use as anchor\n', '                localVars.anchorPrice = Exp({mantissa : requestedPriceMantissa});\n', '            }\n', '        }\n', '\n', '        // Fail if anchorPrice or price is zero.\n', '        // zero anchor represents an unexpected situation likely due to a problem in this contract\n', '        // zero price is more likely as the result of bad input from the caller of this function\n', '        if (isZeroExp(localVars.anchorPrice)) {\n', '            // If we get here price could also be zero, but it does not seem worthwhile to distinguish the 3rd case\n', '            return failOracle(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_NO_ANCHOR_PRICE_OR_INITIAL_PRICE_ZERO);\n', '        }\n', '\n', '        if (isZeroExp(localVars.price)) {\n', '            return failOracle(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_ZERO_PRICE);\n', '        }\n', '\n', '        // BEGIN SIDE EFFECTS\n', '\n', '        // Set pendingAnchor = Nothing\n', '        // Pending anchor is only used once.\n', '        if (pendingAnchors[asset] != 0) {\n', '            pendingAnchors[asset] = 0;\n', '        }\n', '\n', '        // If currentPeriod > anchorPeriod:\n', '        //  Set anchors[asset] = (currentPeriod, price)\n', "        //  The new anchor is if we're in a new period or we had a pending anchor, then we become the new anchor\n", '        if (localVars.currentPeriod > localVars.anchorPeriod) {\n', '            anchors[asset] = Anchor({period : localVars.currentPeriod, priceMantissa : localVars.price.mantissa});\n', '        }\n', '\n', '        uint previousPrice = _assetPrices[asset].mantissa;\n', '\n', '        setPriceStorageInternal(asset, localVars.price.mantissa);\n', '\n', '        emit PricePosted(asset, previousPrice, requestedPriceMantissa, localVars.price.mantissa);\n', '\n', '        if (localVars.priceCapped) {\n', '            // We have set a capped price. Log it so we can detect the situation and investigate.\n', '            emit CappedPricePosted(asset, requestedPriceMantissa, localVars.cappingAnchorPriceMantissa, localVars.price.mantissa);\n', '        }\n', '\n', '        return uint(OracleError.NO_ERROR);\n', '    }\n', '\n', '    // As a function to allow harness overrides\n', '    function setPriceStorageInternal(address asset, uint256 priceMantissa) internal {\n', '        _assetPrices[asset] = Exp({mantissa: priceMantissa});\n', '    }\n', '\n', '    // abs(price - anchorPrice) / anchorPrice\n', '    function calculateSwing(Exp memory anchorPrice, Exp memory price) pure internal returns (Error, Exp memory) {\n', '        Exp memory numerator;\n', '        Error err;\n', '\n', '        if (greaterThanExp(anchorPrice, price)) {\n', '            (err, numerator) = subExp(anchorPrice, price);\n', "            // can't underflow\n", '            assert(err == Error.NO_ERROR);\n', '        } else {\n', '            (err, numerator) = subExp(price, anchorPrice);\n', "            // Given greaterThan check above, price >= anchorPrice so can't underflow.\n", '            assert(err == Error.NO_ERROR);\n', '        }\n', '\n', '        return divExp(numerator, anchorPrice);\n', '    }\n', '\n', '    function capToMax(Exp memory anchorPrice, Exp memory price) view internal returns (Error, bool, Exp memory) {\n', '        Exp memory one = Exp({mantissa : mantissaOne});\n', '        Exp memory onePlusMaxSwing;\n', '        Exp memory oneMinusMaxSwing;\n', '        Exp memory max;\n', '        Exp memory min;\n', '        // re-used for intermediate errors\n', '        Error err;\n', '\n', '        (err, onePlusMaxSwing) = addExp(one, maxSwing);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, false, Exp({mantissa : 0}));\n', '        }\n', '\n', '        // max = anchorPrice * (1 + maxSwing)\n', '        (err, max) = mulExp(anchorPrice, onePlusMaxSwing);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, false, Exp({mantissa : 0}));\n', '        }\n', '\n', '        // If price > anchorPrice * (1 + maxSwing)\n', '        // Set price = anchorPrice * (1 + maxSwing)\n', '        if (greaterThanExp(price, max)) {\n', '            return (Error.NO_ERROR, true, max);\n', '        }\n', '\n', '        (err, oneMinusMaxSwing) = subExp(one, maxSwing);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, false, Exp({mantissa : 0}));\n', '        }\n', '\n', '        // min = anchorPrice * (1 - maxSwing)\n', '        (err, min) = mulExp(anchorPrice, oneMinusMaxSwing);\n', "        // We can't overflow here or we would have already overflowed above when calculating `max`\n", '        assert(err == Error.NO_ERROR);\n', '\n', '        // If  price < anchorPrice * (1 - maxSwing)\n', '        // Set price = anchorPrice * (1 - maxSwing)\n', '        if (lessThanExp(price, min)) {\n', '            return (Error.NO_ERROR, true, min);\n', '        }\n', '\n', '        return (Error.NO_ERROR, false, price);\n', '    }\n', '\n', '    /**\n', '      * @notice entry point for updating multiple prices\n', '      * @dev function to set prices for a variable number of assets.\n', '      * @param assets a list of up to assets for which to set a price. required: 0 < assets.length == requestedPriceMantissas.length\n', '      * @param requestedPriceMantissas requested new prices for the assets, scaled by 10**18. required: 0 < assets.length == requestedPriceMantissas.length\n', '      * @return uint values in same order as inputs. For each: 0=success, otherwise a failure (see enum OracleError for details)\n', '      */\n', '    function setPrices(address[] assets, uint[] requestedPriceMantissas) public returns (uint[] memory) {\n', '        uint numAssets = assets.length;\n', '        uint numPrices = requestedPriceMantissas.length;\n', '        uint[] memory result;\n', '\n', '        // Fail when msg.sender is not poster\n', '        if (msg.sender != poster) {\n', '            result = new uint[](1);\n', '            result[0] = failOracle(0, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\n', '            return result;\n', '        }\n', '\n', '        if ((numAssets == 0) || (numPrices != numAssets)) {\n', '            result = new uint[](1);\n', '            result[0] = failOracle(0, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICES_PARAM_VALIDATION);\n', '            return result;\n', '        }\n', '\n', '        result = new uint[](numAssets);\n', '\n', '        for (uint i = 0; i < numAssets; i++) {\n', '            result[i] = setPriceInternal(assets[i], requestedPriceMantissas[i]);\n', '        }\n', '\n', '        return result;\n', '    }\n', '    \n', '}']