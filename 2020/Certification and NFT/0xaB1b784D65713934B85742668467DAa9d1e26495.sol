['pragma solidity ^0.6.9;\n', '\n', '//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n', '//::::::::::: @#::::::::::: @#:::::::::::: #@j:::::::::::::::::::::::::\n', '//::::::::::: ##::::::::::: @#:::::::::::: #@j:::::::::::::::::::::::::\n', '//::::::::::: ##::::::::::: @#:::::::::::: #@j:::::::::::::::::::::::::\n', '//::::: ########: ##:: ##:: DUTCh>: ihD%y: #@Whdqy:::::::::::::::::::::\n', '//::: ###... ###: ##:: ##:: @B... @@7...t: N@N.. R@K:::::::::::::::::::\n', '//::: ##::::: ##: ##:: ##:: @Q::: @Q.::::: N@j:: z@Q:::::::::::::::::::\n', '//:::: ##DuTCH##: .@QQ@@#:: hQQQh <R@QN@Q: N@j:: z@Q:::::::::::::::::::\n', '//::::::.......: =Q@y....:::....:::......::...:::...:::::::::::::::::::\n', "//:::::::::::::: h@W? sWAP@! 'DW;:::::: KK. ydSWAP@t: NNKNQBdt:::::::::\n", "//:::::::::::::: 'zqRqj*. L@R h@w: QQ: L@5 Q@... d@@: @@U... @Q::::::::\n", '//:::::::::::::::::...... Q@^ ^@@N@wt@BQ@ <@Q^::: @@: @@}::: @@:::::::: \n', '//:::::::::::::::::: U@@QKt... D@@L.. B@Q.. KDUTCH@Q: @@QQ#QQq:::::::::\n', '//:::::::::::::::::::.....::::::...:::...::::.......: @@!.....:::::::::\n', '//::::::::::::::::::::::::::::::::::::::::::::::::::: @@!::::::::::::::\n', '//::::::::::::::::::::::::::::::::::::::::::::::::::: @@!::::::::::::::\n', '//::::::::::::::01101100:01101111:01101111:01101011::::::::::::::::::::\n', '//:::::01100100:01100101:01100101:01110000:01111001:01110010:::::::::::\n', '//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n', '//\n', '// DutchSwap Auction V1.3\n', '//   Copyright (c) 2020 DutchSwap.com\n', '//\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  \n', '// If not, see <https://github.com/deepyr/DutchSwap/>.\n', '//\n', '// The above copyright notice and this permission notice shall be\n', '// included in all copies or substantial portions of the Software.\n', '//\n', '// Authors:\n', '// * Adrian Guerrera / Deepyr Pty Ltd\n', '//\n', '// ---------------------------------------------------------------------\n', '// SPDX-License-Identifier: GPL-3.0-or-later                        \n', '// ---------------------------------------------------------------------\n', '\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '    \n', '    function max(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a >= b ? a : b;\n', '    }\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a <= b ? a : b;\n', '    }\n', '}\n', '\n', 'contract DutchSwapAuction  {\n', '\n', '    using SafeMath for uint256;\n', '    /// @dev The placeholder ETH address.\n', '    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '\n', '    uint256 public startDate;\n', '    uint256 public endDate;\n', '    uint256 public startPrice;\n', '    uint256 public minimumPrice;\n', '    uint256 public totalTokens;  // Amount to be sold\n', '    uint256 public priceDrop; // Price reduction from startPrice at endDate\n', '    uint256 public commitmentsTotal;\n', '    uint256 public tokenWithdrawn;  // the amount of auction tokens already withdrawn\n', '    bool private initialised;    // AG: should be private\n', '    bool public finalised;\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '    uint256 private _status;\n', '\n', '    address public auctionToken;\n', '    address public paymentCurrency;\n', '    address payable public wallet;  // Where the auction funds will get paid\n', '    mapping(address => uint256) public commitments;\n', '    mapping(address => uint256) public claimed;\n', '\n', '    event AddedCommitment(address addr, uint256 commitment, uint256 price);\n', '\n', '\n', '    /// @dev Prevents a contract from calling itself, directly or indirectly.\n', '    /// @dev https://eips.ethereum.org/EIPS/eip-2200)\n', '    modifier nonReentrant() {\n', '        require(_status != _ENTERED);          // ReentrancyGuard: reentrant call\n', '        _status = _ENTERED;\n', '        _;\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /// @dev Init function\n', '    function initDutchAuction(\n', '        address _funder,\n', '        address _token,\n', '        uint256 _totalTokens,\n', '        uint256 _startDate,\n', '        uint256 _endDate,\n', '        address _paymentCurrency,\n', '        uint256 _startPrice,\n', '        uint256 _minimumPrice,\n', '        address payable _wallet\n', '    )\n', '        external\n', '    {\n', '        require(!initialised);                // Already Initialised\n', '        require(_endDate > _startDate);       // End date earlier than start date\n', '\n', '        // Try and refactor to remove these requirements\n', '        // require(_startPrice > _minimumPrice); // Starting price lower than minimum price\n', '        require(_minimumPrice > 0);           // Minimum price must be greater than 0\n', '        \n', '        auctionToken = _token;\n', '        paymentCurrency = _paymentCurrency;\n', '\n', '        totalTokens = _totalTokens;\n', '        startDate = _startDate;\n', '        endDate = _endDate;\n', '        startPrice = _startPrice;\n', '        minimumPrice = _minimumPrice;\n', '        wallet = _wallet;\n', '        _status = _NOT_ENTERED;\n', '\n', '        uint256 numerator = startPrice.sub(minimumPrice);\n', '        uint256 denominator = endDate.sub(startDate);\n', '        priceDrop = numerator.div(denominator);\n', '\n', '        // There are many non-compliant ERC20 tokens... this can handle most, adapted from UniSwap V2\n', '        _safeTransferFrom(auctionToken, _funder, _totalTokens);\n', '        initialised = true;\n', '\n', '    }\n', '\n', '    // Dutch Auction Price Function\n', '    // ============================\n', '    //\n', '    // Start Price -----\n', '    //                   \\\n', '    //                    \\\n', '    //                     \\\n', '    //                      \\ ------------ Clearing Price\n', '    //                     / \\            = AmountRaised/TokenSupply\n', '    //      Token Price  --   \\\n', '    //                  /      \\\n', '    //                --        ----------- Minimum Price\n', '    // Amount raised /          End Time\n', '    //\n', '\n', '\n', '\n', '    /// @notice The average price of each token from all commitments. \n', '    function tokenPrice() public view returns (uint256) {\n', '        return commitmentsTotal.mul(1e18).div(totalTokens);\n', '    }\n', '\n', '      /// @notice Returns price during the auction \n', '    function priceFunction() public view returns (uint256) {\n', '        /// @dev Return Auction Price\n', '        if (block.timestamp <= startDate) {\n', '            return startPrice;\n', '        }\n', '        if (block.timestamp >= endDate) {\n', '            return minimumPrice;\n', '        }\n', '         return _currentPrice();\n', '    }\n', '\n', '    /// @notice The current clearing price of the Dutch auction\n', '    function clearingPrice() public view returns (uint256) {\n', '        /// @dev If auction successful, return tokenPrice\n', '        if (tokenPrice() > priceFunction()) {\n', '            return tokenPrice();\n', '        }\n', '        return priceFunction();\n', '    }\n', '\n', '    /// @notice How many tokens the user is able to claim\n', '    function tokensClaimable(address _user) public view returns (uint256) {\n', '        uint256 tokensAvailable = commitments[_user].mul(1e18).div(clearingPrice());\n', '        return tokensAvailable.sub(claimed[msg.sender]);\n', '    }\n', '\n', '    /// @notice Total amount of tokens committed at current auction price\n', '    function totalTokensCommitted() public view returns(uint256) {\n', '        return commitmentsTotal.mul(1e18).div(clearingPrice());\n', '    }\n', '\n', '    /// @notice Total amount of tokens remaining \n', '    function tokensRemaining() public view returns (uint256) {\n', '        uint256 totalCommitted = totalTokensCommitted();\n', '        if (totalCommitted >= totalTokens ) {\n', '            return 0;\n', '        } else {\n', '            return totalTokens.sub(totalCommitted);\n', '        }\n', '    }\n', '\n', '    /// @notice Returns price during the auction\n', '    function _currentPrice() private view returns (uint256) {\n', '        uint256 elapsed = block.timestamp.sub(startDate);\n', '        uint256 priceDiff = elapsed.mul(priceDrop);\n', '        return startPrice.sub(priceDiff);\n', '    }\n', '\n', '    //--------------------------------------------------------\n', '    // Commit to buying tokens! \n', '    //--------------------------------------------------------\n', '\n', '    /// @notice Buy Tokens by committing ETH to this contract address \n', '    /// @dev Needs extra gas limit for additional state changes\n', '    receive () external payable {\n', '        commitEthFrom(msg.sender);\n', '    }\n', '\n', '    /// @dev Needs extra gas limit for additional state changes\n', '    function commitEth() public payable {\n', '        commitEthFrom(msg.sender);\n', '    }\n', '\n', '    /// @notice Commit ETH to buy tokens for any address \n', '    function commitEthFrom (address payable _from) public payable {\n', '        require(!finalised);                                    // Auction was cancelled\n', '        require(address(paymentCurrency) == ETH_ADDRESS);       // Payment currency is not ETH\n', '        // Get ETH able to be committed\n', '        uint256 ethToTransfer = calculateCommitment( msg.value);\n', '\n', '        // Accept ETH Payments\n', '        uint256 ethToRefund = msg.value.sub(ethToTransfer);\n', '        if (ethToTransfer > 0) {\n', '            _addCommitment(_from, ethToTransfer);\n', '        }\n', '        // Return any ETH to be refunded\n', '        if (ethToRefund > 0) {\n', '            _from.transfer(ethToRefund);\n', '        }\n', '    }\n', '\n', '    /// @notice Commit approved ERC20 tokens to buy tokens on sale\n', '    function commitTokens(uint256 _amount) public {\n', '        commitTokensFrom(msg.sender, _amount);\n', '    }\n', '\n', '    /// @dev Users must approve contract prior to committing tokens to auction\n', '    function commitTokensFrom(address _from, uint256 _amount) public nonReentrant {\n', '        require(!finalised);                                     // Auction was cancelled\n', '        require(address(paymentCurrency) != ETH_ADDRESS);          // Only token transfers\n', '        uint256 tokensToTransfer = calculateCommitment( _amount);\n', '        if (tokensToTransfer > 0) {\n', '            _safeTransferFrom(paymentCurrency, _from, tokensToTransfer);\n', '            _addCommitment(_from, tokensToTransfer);\n', '        }\n', '    }\n', '\n', '    /// @notice Returns the amout able to be committed during an auction\n', '    function calculateCommitment( uint256 _commitment) \n', '        public view returns (uint256 committed) \n', '    {\n', '        uint256 maxCommitment = totalTokens.mul(clearingPrice()).div(1e18);\n', '        if (commitmentsTotal.add(_commitment) > maxCommitment) {\n', '            return maxCommitment.sub(commitmentsTotal);\n', '        }\n', '        return _commitment;\n', '    }\n', '\n', '    /// @notice Commits to an amount during an auction\n', '    function _addCommitment(address _addr,  uint256 _commitment) internal {\n', '        require(block.timestamp >= startDate && block.timestamp <= endDate);  // Outside auction hours\n', '        commitments[_addr] = commitments[_addr].add(_commitment);\n', '        commitmentsTotal = commitmentsTotal.add(_commitment);\n', '        emit AddedCommitment(_addr, _commitment, _currentPrice());\n', '\n', '    }\n', '\n', '    //--------------------------------------------------------\n', '    // Finalise Auction\n', '    //--------------------------------------------------------\n', '\n', '    /// @notice Successful if tokens sold equals totalTokens\n', '    function auctionSuccessful() public view returns (bool){\n', '        return tokenPrice() >= clearingPrice();\n', '    }\n', '\n', '    /// @notice Returns bool if successful or time has ended\n', '    /// @dev able to claim early if auction is successful\n', '    function auctionEnded() public view returns (bool){\n', '        return auctionSuccessful() || block.timestamp > endDate;\n', '    }\n', '\n', '    /// @notice Auction finishes successfully above the reserve\n', '    /// @dev Transfer contract funds to initialised wallet. \n', '    function finaliseAuction () public nonReentrant {\n', '        require(!finalised);                                  // Auction already finalised\n', '        if( auctionSuccessful() ) \n', '        {\n', '            /// @dev Successful auction\n', '            /// @dev Transfer contributed tokens to wallet.\n', '            _tokenPayment(paymentCurrency, wallet, commitmentsTotal);\n', '        }\n', '        else if ( commitmentsTotal == 0 )\n', '        {\n', '            /// @dev Cancelled Auction\n', '            /// @dev You can cancel the auction before it starts\n', '            require(block.timestamp <= startDate );            // Auction already started\n', '            _tokenPayment(auctionToken, wallet, totalTokens);\n', '        }\n', '        else\n', '        {\n', '            /// @dev Failed auction\n', '            /// @dev Return auction tokens back to wallet.\n', '            require(block.timestamp > endDate );               // Auction not yet finished\n', '            _tokenPayment(auctionToken, wallet, totalTokens);\n', '        }\n', '        finalised = true;\n', '    }\n', '\n', '    /// @notice Withdraw your tokens once the Auction has ended.\n', '    function withdrawTokens() public nonReentrant {\n', '        if( auctionSuccessful() ) \n', '        {\n', '            /// @dev Successful auction! Transfer claimed tokens.\n', '            /// @dev AG: Could be only > min to allow early withdraw\n', '            uint256 tokensToClaim = tokensClaimable(msg.sender);\n', '            require(tokensToClaim > 0 );                      // No tokens to claim\n', '            claimed[ msg.sender] = claimed[ msg.sender].add(tokensToClaim);\n', '            tokenWithdrawn = tokenWithdrawn.add(tokensToClaim);\n', '            _tokenPayment(auctionToken, msg.sender, tokensToClaim);\n', '        }\n', '        else \n', '        {\n', '            /// @dev Auction did not meet reserve price.\n', '            /// @dev Return committed funds back to user.\n', '            require(block.timestamp > endDate);               // Auction not yet finished\n', '            uint256 fundsCommitted = commitments[ msg.sender];\n', '            require(fundsCommitted > 0);                      // No funds committed\n', '\n', '            commitments[msg.sender] = 0;     // Stop multiple withdrawals and free some gas\n', '            _tokenPayment(paymentCurrency, msg.sender, fundsCommitted);       \n', '        }\n', '    }\n', '\n', '\n', '    //--------------------------------------------------------\n', '    // Helper Functions\n', '    //--------------------------------------------------------\n', '\n', '    // There are many non-compliant ERC20 tokens... this can handle most, adapted from UniSwap V2\n', "    // I'm trying to make it a habit to put external calls last (reentrancy)\n", '    // You can put this in an internal function if you like.\n', '    function _safeTransfer(address token, address to, uint256 amount) internal {\n', '        // solium-disable-next-line security/no-low-level-calls\n', '        (bool success, bytes memory data) = token.call(\n', '            // 0xa9059cbb = bytes4(keccak256("transferFrom(address,address,uint256)"))\n', '            abi.encodeWithSelector(0xa9059cbb, to, amount)\n', '        );\n', '        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 Transfer failed \n', '    }\n', '\n', '    function _safeTransferFrom(address token, address from, uint256 amount) internal {\n', '        // solium-disable-next-line security/no-low-level-calls\n', '        (bool success, bytes memory data) = token.call(\n', '            // 0x23b872dd = bytes4(keccak256("transferFrom(address,address,uint256)"))\n', '            abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\n', '        );\n', '        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 TransferFrom failed \n', '    }\n', '\n', '    /// @dev Helper function to handle both ETH and ERC20 payments\n', '    function _tokenPayment(address _token, address payable _to, uint256 _amount) internal {\n', '        if (address(_token) == ETH_ADDRESS) {\n', '            _to.transfer(_amount);\n', '        } else {\n', '            _safeTransfer(_token, _to, _amount);\n', '        }\n', '    }\n', '}']