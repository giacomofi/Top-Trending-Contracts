['// SPDX-License-Identifier: MIT\n', '\n', '// File: contracts/proxy/Proxy.sol\n', '\n', 'pragma solidity >=0.6 <0.7.0;\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Implements delegation of calls to other contracts, with proper\n', ' * forwarding of return values and bubbling of failures.\n', ' * It defines a fallback function that delegates all calls to the address\n', ' * returned by the abstract _implementation() internal function.\n', ' */\n', 'abstract contract Proxy {\n', '    /**\n', '     * @dev Fallback function.\n', '     * Implemented entirely in `_fallback`.\n', '     */\n', '    fallback () payable external {\n', '        _fallback();\n', '    }\n', '\n', '    /**\n', '     * @dev Receive function.\n', '     * Implemented entirely in `_fallback`.\n', '     */\n', '    receive () payable external {\n', '        _fallback();\n', '    }\n', '\n', '    /**\n', '     * @return The Address of the implementation.\n', '     */\n', '    function _implementation() internal virtual view returns (address);\n', '\n', '    /**\n', '     * @dev Delegates execution to an implementation contract.\n', "     * This is a low level function that doesn't return to its internal call site.\n", '     * It will return to the external caller whatever the implementation returns.\n', '     * @param implementation Address to delegate.\n', '     */\n', '    function _delegate(address implementation) internal {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            // Copy msg.data. We take full control of memory in this inline assembly\n', '            // block because it will not return to Solidity code. We overwrite the\n', '            // Solidity scratch pad at memory position 0.\n', '            calldatacopy(0, 0, calldatasize())\n', '\n', '            // Call the implementation.\n', "            // out and outsize are 0 because we don't know the size yet.\n", '            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n', '\n', '            // Copy the returned data.\n', '            returndatacopy(0, 0, returndatasize())\n', '\n', '            switch result\n', '            // delegatecall returns 0 on error.\n', '            case 0 { revert(0, returndatasize()) }\n', '            default { return(0, returndatasize()) }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function that is run as the first thing in the fallback function.\n', '     * Can be redefined in derived contracts to add functionality.\n', '     * Redefinitions must call super._willFallback().\n', '     */\n', '    function _willFallback() internal virtual {\n', '    }\n', '\n', '    /**\n', '     * @dev fallback implementation.\n', '     * Extracted to enable manual triggering.\n', '     */\n', '    function _fallback() internal {\n', '        _willFallback();\n', '        _delegate(_implementation());\n', '    }\n', '}\n', '\n', '// File: contracts/proxy/UpgradeableProxy.sol\n', '\n', 'pragma solidity >=0.6 <0.7.0;\n', '\n', '\n', '/**\n', ' * @title UpgradeableProxy\n', ' * @dev This contract implements a proxy that allows to change the\n', ' * implementation address to which it will delegate.\n', ' * Such a change is called an implementation upgrade.\n', ' */\n', 'contract UpgradeableProxy is Proxy {\n', '    /**\n', '     * @dev Contract constructor.\n', '     * @param _logic Address of the initial implementation.\n', '     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '     * It should include the signature and the parameters of the function to be called, as described in\n', '     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '     */\n', '    constructor(address _logic, bytes memory _data) public payable {\n', '        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));\n', '        _setImplementation(_logic);\n', '        if(_data.length > 0) {\n', '            // solhint-disable-next-line avoid-low-level-calls\n', '            (bool success,) = _logic.delegatecall(_data);\n', '            require(success);\n', '        }\n', '    }  \n', '\n', '    /**\n', '     * @dev Emitted when the implementation is upgraded.\n', '     * @param implementation Address of the new implementation.\n', '     */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    /**\n', '     * @dev Storage slot with the address of the current implementation.\n', '     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is\n', '     * validated in the constructor.\n', '     */\n', '    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n', '\n', '    /**\n', '     * @dev Returns the current implementation.\n', '     * @return impl Address of the current implementation\n', '     */\n', '    function _implementation() internal override view returns (address impl) {\n', '        bytes32 slot = _IMPLEMENTATION_SLOT;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            impl := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrades the proxy to a new implementation.\n', '     * @param newImplementation Address of the new implementation.\n', '     */\n', '    function _upgradeTo(address newImplementation) internal {\n', '        _setImplementation(newImplementation);\n', '        emit Upgraded(newImplementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the implementation address of the proxy.\n', '     * @param newImplementation Address of the new implementation.\n', '     */\n', '    function _setImplementation(address newImplementation) internal {\n', '        require(isContract(newImplementation), "UpgradeableProxy: new implementation is not a contract");\n', '\n', '        bytes32 slot = _IMPLEMENTATION_SLOT;\n', '\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            sstore(slot, newImplementation)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/utils/ICashier.sol\n', '\n', 'pragma solidity >=0.6 <0.7.0;\n', '\n', 'interface ICashier {\n', '    function getPayee() external view returns (address payable);\n', '    function calcFee(address addr, uint8 kind, bytes4 func) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/utils/Chargeable.sol\n', '\n', 'pragma solidity >=0.6 <0.7.0;\n', '\n', '\n', 'contract Chargeable {\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier AfterCharge() {\n', '        sendFee(ZERO_SIG);\n', '        _;\n', '    }\n', '\n', '    function sendFee(bytes4 func) internal {\n', '        if (func == ZERO_SIG) {\n', '            func = msg.sig;\n', '        }\n', '        address cashier = _getCashier();\n', '        if (address(cashier) == address(0x0)) {\n', '            return;\n', '        }\n', '        address payable payee = ICashier(cashier).getPayee();\n', '        if (payee == address(0x0)) {\n', '            return;\n', '        }\n', '        uint256 fee = ICashier(cashier).calcFee(address(this), 1, func);\n', '        if (fee > 0) {\n', '            payee.transfer(fee);\n', '        }\n', '    }\n', '\n', '    bytes4 internal constant ZERO_SIG = 0x00000000;\n', '    /**\n', '     * @dev Storage slot with the address of the cashier contract.\n', '     * This is the keccak-256 hash of "x.cashier.contract" and is validated in the constructor.\n', '     */\n', '    bytes32\n', '        internal constant _CASHIER_SLOT = 0xe4daccb11a797004e79d649410b00658e14f3296aae1b244a00c23be3d595cd4;\n', '\n', '    /**\n', '     * @dev Returns the current cashier contract address.\n', '     */\n', '    function _getCashier() internal view returns (address cashier) {\n', '        bytes32 slot = _CASHIER_SLOT;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            cashier := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Stores a new address in the cashier slot.\n', '     */\n', '    function _setCashier(address addr) internal {\n', '        // zero address is enabled, which means not chargeable\n', '        bytes32 slot = _CASHIER_SLOT;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            sstore(slot, addr)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/proxy/ManagedProxy.sol\n', '\n', 'pragma solidity >=0.6 <0.7.0;\n', '\n', '\n', '\n', '/**\n', ' * @title ManagedProxy\n', ' * @dev This contract combines an upgradeability proxy with an authorization\n', ' * mechanism for administrative tasks.\n', ' * All external functions in this contract must be guarded by the\n', ' * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n', ' * feature proposal that would enable this to be done automatically.\n', ' */\n', 'contract ManagedProxy is UpgradeableProxy, Chargeable {\n', '    /**\n', '     * Contract constructor.\n', '     * @param _logic address of the initial implementation.\n', '     * @param _cashier address of the cashier contract.\n', '     * @param _admin Address of the proxy administrator.\n', '     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '     * It should include the signature and the parameters of the function to be called, as described in\n', '     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '     */\n', '    constructor(address _logic, address _cashier, address _admin, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\n', '        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));\n', '        _setAdmin(_admin);\n', '        _setCashier(_cashier);\n', '    }\n', '\n', '    /**\n', '     * @dev Emitted when the administration has been transferred.\n', '     * @param previousAdmin Address of the previous admin.\n', '     * @param newAdmin Address of the new admin.\n', '     */\n', '    event AdminChanged(address previousAdmin, address newAdmin);\n', '\n', '    /**\n', '     * @dev Storage slot with the admin of the contract.\n', '     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is\n', '     * validated in the constructor.\n', '     */\n', '\n', '    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n', '\n', '    /**\n', '     * @dev Modifier to check whether the `msg.sender` is the admin.\n', '     * If it is, it will run the function. Otherwise, it will delegate the call\n', '     * to the implementation.\n', '     */\n', '    modifier ifAdmin() {\n', '        if (msg.sender == _admin()) {\n', '            _;\n', '        } else {\n', '            _fallback();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @return The address of the proxy admin.\n', '     */\n', '    function getProxyAdmin() public view returns (address) {\n', '        return _admin();\n', '    }\n', '\n', '    /**\n', '     * @return The address of the implementation.\n', '     */\n', '    function getProxyImplementation() public view returns (address) {\n', '        return _implementation();\n', '    }\n', '\n', '    /**\n', '     * @dev Changes the admin of the proxy.\n', '     * Only the current admin can call this function.\n', '     * @param newAdmin Address to transfer proxy administration to.\n', '     */\n', '    function changeAdmin(address newAdmin) external payable ifAdmin AfterCharge {\n', '        require(newAdmin != address(0), "TransparentUpgradeableProxy: new admin is the zero address");\n', '        emit AdminChanged(_admin(), newAdmin);\n', '        _setAdmin(newAdmin);\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrade the backing implementation of the proxy.\n', '     * Only the admin can call this function.\n', '     * @param newImplementation Address of the new implementation.\n', '     */\n', '    function upgradeTo(address newImplementation) external payable ifAdmin AfterCharge {\n', '        _upgradeTo(newImplementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrade the backing implementation of the proxy and call a function\n', '     * on the new implementation.\n', '     * This is useful to initialize the proxied contract.\n', '     * @param newImplementation Address of the new implementation.\n', '     * @param data Data to send as msg.data in the low level call.\n', '     * It should include the signature and the parameters of the function to be called, as described in\n', '     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '     */\n', '    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin AfterCharge {\n', '        _upgradeTo(newImplementation);\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success,) = newImplementation.delegatecall(data);\n', '        require(success);\n', '    }\n', '\n', '    /**\n', '     * @return adm The admin slot.\n', '     */\n', '    function _admin() internal view returns (address adm) {\n', '        bytes32 slot = _ADMIN_SLOT;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            adm := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the proxy admin.\n', '     * @param newAdmin Address of the new proxy admin.\n', '     */\n', '    function _setAdmin(address newAdmin) internal {\n', '        bytes32 slot = _ADMIN_SLOT;\n', '\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            sstore(slot, newAdmin)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Only fallback when the sender is not the admin.\n', '     */\n', '    function _willFallback() internal override virtual {\n', '        // require(msg.sender != _admin(), "TransparentUpgradeableProxy: admin cannot fallback to proxy target");\n', '        super._willFallback();\n', '    }\n', '}\n', '\n', '// File: contracts/YFIBCProxy.sol\n', '\n', 'pragma solidity >=0.6.0 <0.7.0;\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract YFIBCProxy is ManagedProxy {\n', '    constructor(\n', '        address logic,\n', '        address cashier,\n', '        address admin\n', '    )\n', '        public\n', '        payable\n', '        ManagedProxy(\n', '            logic,\n', '            cashier,\n', '            admin,\n', '            abi.encodeWithSelector(0x9c020061, admin)\n', '        )\n', '    {}\n', '}']