['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.4;\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a <= b ? a : b;\n', '    }\n', '\n', '    function abs(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a < b) {\n', '            return b - a;\n', '        }\n', '        return a - b;\n', '    }\n', '}\n', '\n', 'contract Initializable {\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private initializing;\n', '\n', '    /**\n', '     * @dev Modifier to use in the initializer function of a contract.\n', '     */\n', '    modifier initializer() {\n', '        require(\n', '            initializing || isConstructor() || !initialized,\n', '            "Contract instance has already been initialized"\n', '        );\n', '\n', '        bool isTopLevelCall = !initializing;\n', '        if (isTopLevelCall) {\n', '            initializing = true;\n', '            initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            initializing = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function isConstructor() private view returns (bool) {\n', '        // extcodesize checks the size of the code stored in an address, and\n', '        // address returns the current address. Since the code is still not\n', '        // deployed when running a constructor, any checks on its code size will\n', '        // yield zero, making it an effective way to detect if a contract is\n', '        // under construction or not.\n', '        address self = address(this);\n', '        uint256 cs;\n', '        assembly {\n', '            cs := extcodesize(self)\n', '        }\n', '        return cs == 0;\n', '    }\n', '\n', '    // Reserved storage space to allow for layout changes in the future.\n', '    uint256[50] private ______gap;\n', '}\n', '\n', 'contract InterestRateModelV2 is Initializable {\n', '    using SafeMath for uint256;\n', '    // 基础利率0.02，转折点为0.8，0.8时为30%, 1时为300%, x为使用率\n', '    // y1 = 0.35 * x + 0.02     x∈[0, 0.8] y1∈[0.02, 0.3]\n', '    // y2 = 13.5 * x - 10.5     x∈[0.8, 1] y2∈[0.3, 3]\n', '    uint256 public multiplierPerBlock; // 0.35 ==> 0.35 * 1e18\n', '    uint256 public jumpMultiplierPerBlock;//13.5 ==> 13.5 * 1e18\n', '    uint256 public jumpPoint;//转折点 0.8 ==> 0.8 * 1e18\n', '\n', '    uint256 public baseRatePerBlock;//0.02e18 截距为1\n', '\n', '    uint256 public blocksPerYear;//ETH: 2102400, BSC: 10512000\n', '\n', '    address public admin;\n', '\n', '    function initialize(\n', '        uint256 baseRatePerYear,\n', '        uint256 multiplierPerYear,\n', '        uint256 jumpMultiplierPerYear,\n', '        uint256 _blocksPerYear,\n', '        uint256 _jumpPoint\n', '    ) public initializer {\n', '        blocksPerYear = _blocksPerYear;\n', '        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n', '        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\n', '        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\n', '        jumpPoint = _jumpPoint;\n', '\n', '        admin = msg.sender;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin, "OnlyAdmin");\n', '        _;\n', '    }\n', '\n', '    function set(\n', '        uint256 baseRatePerYear,\n', '        uint256 multiplierPerYear,\n', '        uint256 jumpMultiplierPerYear,\n', '        uint256 _blocksPerYear,\n', '        uint256 _jumpPoint\n', '    ) external onlyAdmin {\n', '        blocksPerYear = _blocksPerYear;\n', '        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n', '        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\n', '        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\n', '        jumpPoint = _jumpPoint;\n', '    }\n', '\n', '    // 计算利用率\n', '    function utilizationRate(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves\n', '    ) public pure returns (uint256) {\n', '        if (borrows == 0) {\n', '            return 0;\n', '        }\n', '\n', '        // borrows/(cash + borrows)\n', '        return borrows.mul(1e18).div(cash.add(borrows));\n', '    }\n', '\n', '    // 借款利率\n', '    function getBorrowRate(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves\n', '    ) public view returns (uint256) {\n', '        uint256 ur = utilizationRate(cash, borrows, reserves);\n', '        if (ur <= jumpPoint) {\n', '            return ur.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);//y1 = 0.35 * x + 0.02\n', '        } else {\n', '            // jumpPointRate = 0.8 * 0.35 + 0.02 = 0.30\n', '            // deltaY = jumpMultiplierPerBlock * (ur - jumpPoint) == deltaX * (ur - 0.8)\n', '            // y = jumpPointRate + deltaY\n', '            uint256 jumpPointRate = jumpPoint.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n', '            uint256 excessUr = ur.sub(jumpPoint);\n', '            return excessUr.mul(jumpMultiplierPerBlock).div(1e18).add(jumpPointRate);// y2 = 13.5 * x - 10.5\n', '        }\n', '    }\n', '\n', '    // 存款利率\n', '    function getSupplyRate(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves,\n', '        uint256 reserveFactorMantissa\n', '    ) public view returns (uint256) {\n', '        uint256 oneMinusReserveFactor = uint256(1e18).sub(\n', '            reserveFactorMantissa\n', '        );\n', '        uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n', '        uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n', '        return\n', '            utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n', '    }\n', '\n', '    function APR(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves\n', '    ) external view returns (uint256) {\n', '        return getBorrowRate(cash, borrows, reserves).mul(blocksPerYear);\n', '    }\n', '\n', '    function APY(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves,\n', '        uint256 reserveFactorMantissa\n', '    ) external view returns (uint256) {\n', '        return\n', '            getSupplyRate(cash, borrows, reserves, reserveFactorMantissa).mul(\n', '                blocksPerYear\n', '            );\n', '    }\n', '}']