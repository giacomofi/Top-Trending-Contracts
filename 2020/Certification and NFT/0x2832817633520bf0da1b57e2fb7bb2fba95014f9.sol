['#@version 0.2.7\n', '\n', 'CONTRACT_VERSION: constant(String[28]) = "0.1.1"\n', '\n', 'from vyper.interfaces import ERC20\n', '\n', 'implements: ERC20\n', '\n', 'interface DetailedERC20:\n', '    def name() -> String[42]: view\n', '    def symbol() -> String[20]: view\n', '    def decimals() -> uint256: view\n', '\n', 'interface Strategy:\n', '    def strategist() -> address: view\n', '    def estimatedTotalAssets() -> uint256: view\n', '    def withdraw(_amount: uint256): nonpayable\n', '    def migrate(_newStrategy: address): nonpayable\n', '\n', 'event Transfer:\n', '    sender: indexed(address)\n', '    receiver: indexed(address)\n', '    value: uint256\n', '\n', 'event Approval:\n', '    owner: indexed(address)\n', '    spender: indexed(address)\n', '    value: uint256\n', '\n', '\n', 'name: public(String[64])\n', 'symbol: public(String[32])\n', 'decimals: public(uint256)\n', '\n', 'balanceOf: public(HashMap[address, uint256])\n', 'allowance: public(HashMap[address, HashMap[address, uint256]])\n', 'totalSupply: public(uint256)\n', '\n', 'token: public(ERC20)\n', 'governance: public(address)\n', 'guardian: public(address)\n', 'pendingGovernance: address\n', '\n', 'struct StrategyParams:\n', "    performanceFee: uint256  # Strategist's fee (basis points)\n", '    activation: uint256  # Activation block.number\n', '    debtLimit: uint256  # Maximum borrow amount\n', '    rateLimit: uint256  # Increase/decrease per block\n', '    lastReport: uint256  # block.number of the last time a report occured\n', '    totalDebt: uint256  # Total outstanding debt that Strategy has\n', '    totalReturns: uint256  # Total returns that Strategy has realized for Vault\n', '\n', 'event StrategyAdded:\n', '    strategy: indexed(address)\n', '    debtLimit: uint256  # Maximum borrow amount\n', '    rateLimit: uint256  # Increase/decrease per block\n', "    performanceFee: uint256  # Strategist's fee (basis points)\n", '\n', 'event StrategyReported:\n', '    strategy: indexed(address)\n', '    returnAdded: uint256\n', '    debtAdded: uint256\n', '    totalReturn: uint256\n', '    totalDebt: uint256\n', '    debtLimit: uint256\n', '\n', '# NOTE: Track the total for overhead targeting purposes\n', 'strategies: public(HashMap[address, StrategyParams])\n', 'MAXIMUM_STRATEGIES: constant(uint256) = 20\n', '\n', '# Ordering that `withdraw` uses to determine which strategies to pull funds from\n', '# NOTE: Does *NOT* have to match the ordering of all the current strategies that\n', '#       exist, but it is recommended that it does or else withdrawal depth is\n', '#       limited to only those inside the the queue.\n', '# NOTE: Ordering is determined by governance, and should be balanced according\n', '#       to risk, slippage, and/or volitility. Can also be ordered to increase the\n', '#       withdrawal speed of a particular strategy.\n', '# NOTE: The first time a ZERO_ADDRESS is encountered, it stops withdrawing\n', 'withdrawalQueue: public(address[MAXIMUM_STRATEGIES])\n', '\n', 'emergencyShutdown: public(bool)\n', '\n', 'depositLimit: public(uint256)  # Limit for totalAssets the Vault can hold\n', 'debtLimit: public(uint256)  # Debt limit for the Vault across all strategies\n', 'totalDebt: public(uint256)  # Amount of tokens that all strategies have borrowed\n', 'lastReport: public(uint256)  # Number of blocks since last report\n', '\n', 'rewards: public(address)  # Rewards contract where Governance fees are sent to\n', 'managementFee: public(uint256)  # Governance Fee for management of Vault (given to `rewards`)\n', 'performanceFee: public(uint256)  # Governance Fee for performance of Vault (given to `rewards`)\n', 'FEE_MAX: constant(uint256) = 10_000  # 100%, or 10k basis points\n', 'BLOCKS_PER_YEAR: constant(uint256) = 2_300_000\n', '\n', '@external\n', 'def __init__(\n', '    _token: address,\n', '    _governance: address,\n', '    _rewards: address,\n', '    _nameOverride: String[64],\n', '    _symbolOverride: String[32]\n', '):\n', '    self.token = ERC20(_token)\n', '    if _nameOverride == "":\n', '        self.name = concat("yearn ", DetailedERC20(_token).name())\n', '    else:\n', '        self.name = _nameOverride\n', '    if _symbolOverride == "":\n', '        self.symbol = concat("y", DetailedERC20(_token).symbol())\n', '    else:\n', '        self.symbol = _symbolOverride\n', '    self.decimals = DetailedERC20(_token).decimals()\n', '    self.governance = _governance\n', '    self.rewards = _rewards\n', '    self.guardian = msg.sender\n', '    self.performanceFee = 450  # 4.5% of yield (per strategy)\n', '    self.managementFee = 200  # 2% per year\n', '    self.depositLimit = MAX_UINT256  # Start unlimited\n', '    self.lastReport = block.number\n', '\n', '\n', '@pure\n', '@external\n', 'def version() -> String[28]:\n', '    return CONTRACT_VERSION\n', '\n', '\n', '# 2-phase commit for a change in governance\n', '@external\n', 'def setGovernance(_governance: address):\n', '    assert msg.sender == self.governance\n', '    self.pendingGovernance = _governance\n', '\n', '\n', '@external\n', 'def acceptGovernance():\n', '    assert msg.sender == self.pendingGovernance\n', '    self.governance = msg.sender\n', '\n', '\n', '@external\n', 'def setRewards(_rewards: address):\n', '    assert msg.sender == self.governance\n', '    self.rewards = _rewards\n', '\n', '\n', '@external\n', 'def setDepositLimit(_limit: uint256):\n', '    assert msg.sender == self.governance\n', '    self.depositLimit = _limit\n', '\n', '\n', '@external\n', 'def setPerformanceFee(_fee: uint256):\n', '    assert msg.sender == self.governance\n', '    self.performanceFee = _fee\n', '\n', '\n', '@external\n', 'def setManagementFee(_fee: uint256):\n', '    assert msg.sender == self.governance\n', '    self.managementFee = _fee\n', '\n', '\n', '@external\n', 'def setGuardian(_guardian: address):\n', '    assert msg.sender in [self.guardian, self.governance]\n', '    self.guardian = _guardian\n', '\n', '\n', '@external\n', 'def setEmergencyShutdown(_active: bool):\n', '    """\n', '    Activates Vault mode where all Strategies go into full withdrawal\n', '    """\n', '    assert msg.sender in [self.guardian, self.governance]\n', '    self.emergencyShutdown = _active\n', '\n', '\n', '@external\n', 'def setWithdrawalQueue(_queue: address[MAXIMUM_STRATEGIES]):\n', '    assert msg.sender == self.governance\n', '    for i in range(MAXIMUM_STRATEGIES):\n', '        if _queue[i] == ZERO_ADDRESS and self.withdrawalQueue[i] == ZERO_ADDRESS:\n', '            break\n', '        assert self.strategies[_queue[i]].activation > 0\n', '        self.withdrawalQueue[i] = _queue[i]\n', '\n', '\n', '@internal\n', 'def _transfer(_from: address, _to: address, _value: uint256):\n', '    # Protect people from accidentally sending their shares to bad places\n', '    assert not (_to in [self, ZERO_ADDRESS])\n', '    self.balanceOf[_from] -= _value\n', '    self.balanceOf[_to] += _value\n', '    log Transfer(_from, _to, _value)\n', '\n', '\n', '@external\n', 'def transfer(_to: address, _value: uint256) -> bool:\n', '    self._transfer(msg.sender, _to, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def transferFrom(_from : address, _to : address, _value : uint256) -> bool:\n', '    if self.allowance[_from][msg.sender] < MAX_UINT256:  # Unlimited approval (saves an SSTORE)\n', '       self.allowance[_from][msg.sender] -= _value\n', '    self._transfer(_from, _to, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def approve(_spender : address, _value : uint256) -> bool:\n', '    """\n', '    @dev Approve the passed address to spend the specified amount of tokens on behalf of\n', '         msg.sender. Beware that changing an allowance with this method brings the risk\n', '         that someone may use both the old and the new allowance by unfortunate transaction\n', '         ordering. One possible solution to mitigate this race condition is to first reduce\n', "         the spender's allowance to 0 and set the desired value afterwards:\n", '         https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    @param _spender The address which will spend the funds.\n', '    @param _value The amount of tokens to be spent.\n', '    """\n', '    assert _value == 0 or self.allowance[msg.sender][_spender] == 0\n', '    self.allowance[msg.sender][_spender] = _value\n', '    log Approval(msg.sender, _spender, _value)\n', '    return True\n', '\n', '\n', '@view\n', '@internal\n', 'def _totalAssets() -> uint256:\n', '    return self.token.balanceOf(self) + self.totalDebt\n', '\n', '\n', '@view\n', '@external\n', 'def totalAssets() -> uint256:\n', '    return self._totalAssets()\n', '\n', '\n', '@view\n', '@internal\n', 'def _balanceSheetOfStrategy(_strategy: address) -> uint256:\n', '    return Strategy(_strategy).estimatedTotalAssets()\n', '\n', '\n', '@view\n', '@external\n', 'def balanceSheetOfStrategy(_strategy: address) -> uint256:\n', '    return self._balanceSheetOfStrategy(_strategy)\n', '\n', '\n', '@view\n', '@external\n', 'def totalBalanceSheet(_strategies: address[2 * MAXIMUM_STRATEGIES]) -> uint256:\n', '    """\n', '    Measure the total balance sheet of this Vault, using the list of strategies\n', "    given above. (2x the expected maximum is used for safety's sake)\n", '    NOTE: The safety of this function depends *entirely* on the list of strategies\n', '          given as the function argument. Care should be taken to choose this list\n', '          to ensure that the estimate is accurate. No additional checking is used.\n', '    NOTE: Guardian should use this value vs. `totalAssets()` to determine\n', '          if a condition exists where the Vault is experiencing a dangerous\n', "          'balance sheet' attack, leading Vault shares to be worth less than\n", '          what their price on paper is (based on their debt)\n', '    """\n', '    balanceSheet: uint256 = self.token.balanceOf(self)\n', '\n', '    for strategy in _strategies:\n', '        if strategy == ZERO_ADDRESS:\n', '            break\n', '        balanceSheet += self._balanceSheetOfStrategy(strategy)\n', '\n', '    return balanceSheet\n', '\n', '\n', '@internal\n', 'def _issueSharesForAmount(_to: address, _amount: uint256) -> uint256:\n', '    # NOTE: shares must be issued prior to taking on new collateral,\n', '    #       or calculation will be wrong. This means that only *trusted*\n', '    #       tokens (with no capability for exploitive behavior) can be used\n', '    shares: uint256 = 0\n', '    # HACK: Saves 2 SLOADs (~4000 gas)\n', '    totalSupply: uint256 = self.totalSupply\n', '    if totalSupply > 0:\n', '        # Mint amount of shares based on what the Vault is managing overall\n', '        shares = _amount * totalSupply / self._totalAssets()\n', '    else:\n', '        # No existing shares, so mint 1:1\n', '        shares = _amount\n', '\n', '    # Mint new shares\n', '    self.totalSupply = totalSupply + shares\n', '    self.balanceOf[_to] += shares\n', '    log Transfer(ZERO_ADDRESS, _to, shares)\n', '\n', '    return shares\n', '\n', '\n', '@external\n', 'def deposit(_amount: uint256) -> uint256:\n', '    assert not self.emergencyShutdown  # Deposits are locked out\n', '    assert self._totalAssets() + _amount <= self.depositLimit  # Max deposit reached\n', '\n', '    # NOTE: Measuring this based on the total outstanding debt that this contract\n', '    #       has ("expected value") instead of the total balance sheet it has\n', '    #       ("estimated value") has important security considerations, and is\n', '    #       done intentionally. If this value were measured against external\n', '    #       systems, it could be purposely manipulated by an attacker to withdraw\n', '    #       more assets than they otherwise should be able to claim by redeeming\n', '    #       their shares.\n', '    #\n', '    #       On deposit, this means that shares are issued against the total amount\n', '    #       that the deposited capital can be given in service of the debt that\n', '    #       Strategies assume. If that number were to be lower than the "expected value"\n', '    #       at some future point, depositing shares via this method could entitle the\n', '    #       depositor to *less* than the deposited value once the "realized value" is\n', '    #       updated from further reportings by the Strategies to the Vaults.\n', '    #\n', '    #       Care should be taken by integrators to account for this discrepency,\n', '    #       by using the view-only methods of this contract (both off-chain and\n', '    #       on-chain) to determine if depositing into the Vault is a "good idea"\n', '\n', '    # Issue new shares (needs to be done before taking deposit to be accurate)\n', '    shares: uint256 = self._issueSharesForAmount(msg.sender, _amount)\n', '\n', '    # Get new collateral\n', '    reserve: uint256 = self.token.balanceOf(self)\n', '    self.token.transferFrom(msg.sender, self, _amount)\n', '    assert self.token.balanceOf(self) - reserve == _amount  # Deflationary token check\n', '\n', '    return shares  # Just in case someone wants them\n', '\n', '\n', '@view\n', '@internal\n', 'def _shareValue(_shares: uint256) -> uint256:\n', '    return (_shares * (self._totalAssets())) / self.totalSupply\n', '\n', '\n', '@view\n', '@internal\n', 'def _sharesForAmount(_amount: uint256) -> uint256:\n', '    if self._totalAssets() > 0:\n', '        return (_amount * self.totalSupply) / self._totalAssets()\n', '    else:\n', '        return 0\n', '\n', '\n', '@view\n', '@external\n', 'def maxAvailableShares() -> uint256:\n', '    shares: uint256 = self._sharesForAmount(self.token.balanceOf(self))\n', '\n', '    for strategy in self.withdrawalQueue:\n', '        if strategy == ZERO_ADDRESS:\n', '            break\n', '        shares += self._sharesForAmount(self.strategies[strategy].totalDebt)\n', '\n', '    return shares\n', '\n', '\n', '@external\n', 'def withdraw(_shares: uint256):\n', '    # Limit to only the shares they own\n', '    assert _shares <= self.balanceOf[msg.sender]\n', '    shares: uint256 = _shares  # May reduce this number below\n', '\n', '    # NOTE: Measuring this based on the total outstanding debt that this contract\n', '    #       has ("expected value") instead of the total balance sheet it has\n', '    #       ("estimated value") has important security considerations, and is\n', '    #       done intentionally. If this value were measured against external\n', '    #       systems, it could be purposely manipulated by an attacker to withdraw\n', '    #       more assets than they otherwise should be able to claim by redeeming\n', '    #       their shares.\n', '    #\n', '    #       On withdrawal, this means that shares are redeemed against the total\n', '    #       amount that the deposited capital had "realized" since the point it\n', '    #       was deposited, up until the point it was withdrawn. If that number\n', '    #       were to be higher than the "expected value" at some future point,\n', '    #       withdrawing shares via this method could entitle the depositor to\n', '    #       *more* than the expected value once the "realized value" is updated\n', '    #       from further reportings by the Strategies to the Vaults.\n', '    #\n', '    #       Under exceptional scenarios, this could cause earlier withdrawals to\n', '    #       earn "more" of the underlying assets than Users might otherwise be\n', "    #       entitled to, if the Vault's estimated value were otherwise measured\n", '    #       through external means, accounting for whatever exceptional scenarios\n', "    #       exist for the Vault (that aren't covered by the Vault's own design)\n", '    value: uint256 = self._shareValue(shares)\n', '\n', '    if value > self.token.balanceOf(self):\n', '        # We need to go get some from our strategies in the withdrawal queue\n', '        # NOTE: This performs forced withdrawals from each strategy.\n', '        for strategy in self.withdrawalQueue:\n', '            if strategy == ZERO_ADDRESS:\n', "                break  # We've exhausted the queue\n", '\n', '            amountNeeded: uint256 = value - self.token.balanceOf(self)\n', '\n', '            if amountNeeded == 0:\n', "                break  # We're done withdrawing\n", '\n', "            # NOTE: Don't withdraw more than the debt so that strategy can still\n", '            #       continue to work based on the profits it has\n', '            # NOTE: This means that user will lose out on any profits that each\n', '            #       strategy in the queue would return on next harvest, benefitting others\n', '            amountNeeded = min(amountNeeded, self.strategies[strategy].totalDebt)\n', '            if amountNeeded == 0:\n', '                continue  # Nothing to withdraw from this strategy, try the next one\n', '\n', '            # Force withdraw amount from each strategy in the order set by governance\n', '            before: uint256 = self.token.balanceOf(self)\n', '            Strategy(strategy).withdraw(amountNeeded)\n', '            withdrawn: uint256 = self.token.balanceOf(self) - before\n', '\n', '            # Reduce the strategy\'s debt by the amount withdrawn ("realized returns")\n', '            # NOTE: This doesn\'t add to returns as it\'s not earned by "normal means"\n', '            self.strategies[strategy].totalDebt -= withdrawn\n', '            self.totalDebt -= withdrawn\n', '\n', '    # NOTE: We have withdrawn everything possible out of the withdrawal queue\n', "    #       but we still don't have enough to fully pay them back, so adjust\n", "    #       to the total amount we've freed up through forced withdrawals\n", '    if value > self.token.balanceOf(self):\n', '        value = self.token.balanceOf(self)\n', '        shares = self._sharesForAmount(value)\n', '\n', '    # Burn shares (full value of what is being withdrawn)\n', '    self.totalSupply -= shares\n', '    self.balanceOf[msg.sender] -= shares\n', '    log Transfer(msg.sender, ZERO_ADDRESS, shares)\n', '\n', '    # Withdraw remaining balance (minus fee)\n', '    self.token.transfer(msg.sender, value)\n', '\n', '\n', '@view\n', '@external\n', 'def pricePerShare() -> uint256:\n', '    return self._shareValue(10 ** self.decimals)\n', '\n', '\n', '@internal\n', 'def _organizeWithdrawalQueue():\n', '    # Reorganize based on premise that if there is an empty value between two\n', '    # actual values, then the empty value should be replaced by the later value\n', '    # NOTE: Relative ordering of non-zero values is maintained\n', '    offset: uint256 = 0\n', '    for idx in range(MAXIMUM_STRATEGIES):\n', '        strategy: address = self.withdrawalQueue[idx]\n', '        if strategy == ZERO_ADDRESS:\n', '            offset += 1  # how many values we need to shift, always `<= idx`\n', '        elif offset > 0:\n', '            self.withdrawalQueue[idx-offset] = strategy\n', '            self.withdrawalQueue[idx] = ZERO_ADDRESS\n', '\n', '\n', '@external\n', 'def addStrategy(\n', '    _strategy: address,\n', '    _debtLimit: uint256,\n', '    _rateLimit: uint256,\n', '    _performanceFee: uint256,\n', '):\n', '    assert msg.sender == self.governance\n', '    assert self.strategies[_strategy].activation == 0\n', '    self.strategies[_strategy] = StrategyParams({\n', '        performanceFee: _performanceFee,\n', '        activation: block.number,\n', '        debtLimit: _debtLimit,\n', '        rateLimit: _rateLimit,\n', '        lastReport: block.number,\n', '        totalDebt: 0,\n', '        totalReturns: 0,\n', '    })\n', '    self.debtLimit += _debtLimit\n', '    log StrategyAdded(_strategy, _debtLimit, _rateLimit, _performanceFee)\n', '\n', '    # queue is full\n', '    assert self.withdrawalQueue[MAXIMUM_STRATEGIES-1] == ZERO_ADDRESS\n', '    self.withdrawalQueue[MAXIMUM_STRATEGIES-1] = _strategy\n', '    self._organizeWithdrawalQueue()\n', '\n', '\n', '@external\n', 'def updateStrategyDebtLimit(\n', '    _strategy: address,\n', '    _debtLimit: uint256,\n', '):\n', '    assert msg.sender == self.governance\n', '    assert self.strategies[_strategy].activation > 0\n', '    self.debtLimit -= self.strategies[_strategy].debtLimit\n', '    self.strategies[_strategy].debtLimit = _debtLimit\n', '    self.debtLimit += _debtLimit\n', '\n', '\n', '@external\n', 'def updateStrategyRateLimit(\n', '    _strategy: address,\n', '    _rateLimit: uint256,\n', '):\n', '    assert msg.sender == self.governance\n', '    assert self.strategies[_strategy].activation > 0\n', '    self.strategies[_strategy].rateLimit = _rateLimit\n', '\n', '\n', '@external\n', 'def updateStrategyPerformanceFee(\n', '    _strategy: address,\n', '    _performanceFee: uint256,\n', '):\n', '    assert msg.sender == self.governance\n', '    assert self.strategies[_strategy].activation > 0\n', '    self.strategies[_strategy].performanceFee = _performanceFee\n', '\n', '\n', '@external\n', 'def migrateStrategy(_oldVersion: address, _newVersion: address):\n', '    """\n', '    Only Governance can migrate a strategy to a new version\n', '    NOTE: Strategy must successfully migrate all capital and positions to\n', '          new Strategy, or else this will upset the balance of the Vault\n', '    NOTE: The new strategy should be "empty" e.g. have no prior commitments\n', '          to this Vault, otherwise it could have issues\n', '    """\n', '    assert msg.sender == self.governance\n', '\n', '    assert self.strategies[_oldVersion].activation > 0\n', '    assert self.strategies[_newVersion].activation == 0\n', '\n', '    strategy: StrategyParams = self.strategies[_oldVersion]\n', '    self.strategies[_oldVersion] = empty(StrategyParams)\n', '    self.strategies[_newVersion] = strategy\n', '\n', '    Strategy(_oldVersion).migrate(_newVersion)\n', '\n', '    for idx in range(MAXIMUM_STRATEGIES):\n', '        if self.withdrawalQueue[idx] == _oldVersion:\n', '            self.withdrawalQueue[idx] = _newVersion\n', "            return  # Don't need to reorder anything because we swapped\n", '\n', '\n', '@external\n', 'def revokeStrategy(_strategy: address = msg.sender):\n', '    """\n', '    Governance can revoke a strategy\n', '    OR\n', '    A strategy can revoke itself (Emergency Exit Mode)\n', '    """\n', '    assert msg.sender in [_strategy, self.governance, self.guardian]\n', '    self.debtLimit -= self.strategies[_strategy].debtLimit\n', '    self.strategies[_strategy].debtLimit = 0\n', '\n', '\n', '@external\n', 'def addStrategyToQueue(_strategy: address):\n', '    assert msg.sender == self.governance\n', '    # Must be a current strategy\n', '    assert self.strategies[_strategy].activation > 0 and self.strategies[_strategy].totalDebt > 0\n', '    # Check if queue is full\n', '    assert self.withdrawalQueue[MAXIMUM_STRATEGIES-1] == ZERO_ADDRESS\n', "    # Can't already be in the queue\n", '    for strategy in self.withdrawalQueue:\n', '        if strategy == ZERO_ADDRESS:\n', '            break\n', '        assert strategy != _strategy\n', '    self.withdrawalQueue[MAXIMUM_STRATEGIES-1] = _strategy\n', '    self._organizeWithdrawalQueue()\n', '\n', '\n', '@external\n', 'def removeStrategyFromQueue(_strategy: address):\n', "    # NOTE: We don't do this with revokeStrategy because it should still\n", "    #       be possible to withdraw from it if it's unwinding\n", '    assert msg.sender == self.governance\n', '    for idx in range(MAXIMUM_STRATEGIES):\n', '        if self.withdrawalQueue[idx] == _strategy:\n', '            self.withdrawalQueue[idx] = ZERO_ADDRESS\n', '            self._organizeWithdrawalQueue()\n', '            return  # We found the right location and cleared it\n', "    raise  # We didn't find the strategy in the queue\n", '\n', '\n', '@view\n', '@internal\n', 'def _debtOutstanding(_strategy: address) -> uint256:\n', '    """\n', '    Amount of tokens in strtaegy that Vault wants to recall\n', '    """\n', '    strategy_debtLimit: uint256 = self.strategies[_strategy].debtLimit\n', '    strategy_totalDebt: uint256 = self.strategies[_strategy].totalDebt\n', '\n', '    if self.emergencyShutdown:\n', '        return strategy_totalDebt\n', '    elif strategy_totalDebt <= strategy_debtLimit:\n', '        return 0\n', '    else:\n', '        return strategy_totalDebt - strategy_debtLimit\n', '\n', '\n', '@view\n', '@external\n', 'def debtOutstanding(_strategy: address = msg.sender) -> uint256:\n', '    return self._debtOutstanding(_strategy)\n', '\n', '\n', '@view\n', '@internal\n', 'def _creditAvailable(_strategy: address) -> uint256:\n', '    """\n', '    Amount of tokens in vault a strategy has access to as a credit line\n', '    """\n', '    if self.emergencyShutdown:\n', '        return 0\n', '\n', '    strategy_debtLimit: uint256 = self.strategies[_strategy].debtLimit\n', '    strategy_totalDebt: uint256 = self.strategies[_strategy].totalDebt\n', '    strategy_rateLimit: uint256 = self.strategies[_strategy].rateLimit\n', '    strategy_lastReport: uint256 = self.strategies[_strategy].lastReport\n', '\n', '    # Exhausted credit line\n', '    if strategy_debtLimit <= strategy_totalDebt or self.debtLimit <= self.totalDebt:\n', '        return 0\n', '\n', '    # Start with debt limit left for the strategy\n', '    available: uint256 = strategy_debtLimit - strategy_totalDebt\n', '\n', '    # Adjust by the global debt limit left\n', '    available = min(available, self.debtLimit - self.totalDebt)\n', '\n', '    # Adjust by the rate limit algorithm (limits the step size per reporting period)\n', '    blockDelta: uint256 = block.number - strategy_lastReport\n', '    # NOTE: Protect against unnecessary overflow faults here\n', '    # NOTE: Set `strategy_rateLimit` to a really high number to disable the rate limit\n', '    # NOTE: *NEVER* set `strategy_rateLimit` to 0 or else this will always throw\n', '    if available / strategy_rateLimit >= blockDelta:\n', '        available = min(available, strategy_rateLimit * blockDelta)\n', '\n', '    # Can only borrow up to what the contract has in reserve\n', '    # NOTE: Running near 100% is discouraged\n', '    return min(available, self.token.balanceOf(self))\n', '\n', '\n', '@view\n', '@external\n', 'def creditAvailable(_strategy: address = msg.sender) -> uint256:\n', '    return self._creditAvailable(_strategy)\n', '\n', '\n', '@view\n', '@internal\n', 'def _expectedReturn(_strategy: address) -> uint256:\n', '    strategy_lastReport: uint256 = self.strategies[_strategy].lastReport\n', '    strategy_totalReturns: uint256 = self.strategies[_strategy].totalReturns\n', '    strategy_activation: uint256 = self.strategies[_strategy].activation\n', '\n', '    blockDelta: uint256 = (block.number - strategy_lastReport)\n', '    if blockDelta > 0:\n', '        return (strategy_totalReturns * blockDelta) / (block.number - strategy_activation)\n', '    else:\n', '        return 0  # Covers the scenario when block.number == strategy_activation\n', '\n', '\n', '@view\n', '@external\n', 'def expectedReturn(_strategy: address = msg.sender) -> uint256:\n', '    return self._expectedReturn(_strategy)\n', '\n', '\n', '@external\n', 'def report(_return: uint256) -> uint256:\n', '    """\n', '    Strategies call this.\n', "    _return: amount Strategy has made on it's investment since its last report,\n", '             and is free to be given back to Vault as earnings\n', '    returns: amount of debt outstanding (iff totalDebt > debtLimit)\n', '    """\n', '    # NOTE: For approved strategies, this is the most efficient behavior.\n', '    #       Strategy reports back what it has free (usually in terms of ROI)\n', '    #       and then Vault "decides" here whether to take some back or give it more.\n', '    #       Note that the most it can take is `_return`, and the most it can give is\n', '    #       all of the remaining reserves. Anything outside of those bounds is abnormal\n', '    #       behavior.\n', '    # NOTE: All approved strategies must have increased diligience around\n', '    #       calling this function, as abnormal behavior could become catastrophic\n', '\n', '    # Only approved strategies can call this function\n', '    assert self.strategies[msg.sender].activation > 0\n', '\n', '    # Outstanding debt the Vault wants to take back from the Strategy (if any)\n', '    debt: uint256 = self._debtOutstanding(msg.sender)\n', '\n', '    # Issue new shares to cover fees\n', '    # NOTE: In effect, this reduces overall share price by the combined fee\n', '    governance_fee: uint256 = (\n', '        self._totalAssets() * (block.number - self.lastReport) * self.managementFee\n', '    ) / FEE_MAX / BLOCKS_PER_YEAR\n', '    self.lastReport = block.number\n', '    strategist_fee: uint256 = 0  # Only applies in certain conditions\n', '\n', '    # NOTE: Applies if strategy is not shutting down, or it is but all debt paid off\n', "    # NOTE: No fee is taken when a strategy is unwinding it's position, until all debt is paid\n", '    if  _return > debt:\n', '        strategist_fee = (\n', '            (_return - debt) * self.strategies[msg.sender].performanceFee\n', '        ) / FEE_MAX\n', '        governance_fee += (_return - debt) * self.performanceFee / FEE_MAX\n', '\n', '    # NOTE: This must be called prior to taking new collateral,\n', '    #       or the calculation will be wrong!\n', '    # NOTE: This must be done at the same time, to ensure the relative\n', '    #       ratio of governance_fee : strategist_fee is kept intact\n', '    total_fee: uint256 = governance_fee + strategist_fee\n', '    reward: uint256 = self._issueSharesForAmount(self, total_fee)\n', '\n', '    # Send the rewards out as new shares in this Vault\n', '    if strategist_fee > 0:\n', '        strategist_reward: uint256 = (strategist_fee * reward) / total_fee\n', '        self._transfer(self, Strategy(msg.sender).strategist(), strategist_reward)\n', '    # NOTE: Governance earns any dust leftover from flooring math above\n', '    self._transfer(self, self.rewards, self.balanceOf[self])\n', '\n', '    # Compute the line of credit the Vault is able to offer the Strategy (if any)\n', '    credit: uint256 = self._creditAvailable(msg.sender)\n', '\n', '    # Give/take balance to Strategy, based on the difference between the return and\n', '    # the credit increase we are offering (if any)\n', '    # NOTE: This is just used to adjust the balance of tokens between the Strategy and\n', "    #       the Vault based on the strategy's debt limit (as well as the Vault's).\n", '    if _return < credit:  # credit surplus, give to strategy\n', '        self.token.transfer(msg.sender, credit - _return)\n', '    elif _return > credit:  # credit deficit, take from strategy\n', '        self.token.transferFrom(msg.sender, self, _return - credit)\n', '\n', "    # else, don't do anything because it is performing well as is\n", '\n', '    # Update the actual debt based on the full credit we are extending to the Strategy\n', '    # or the returns if we are taking funds back\n', '    # NOTE: credit + self.strategies[msg.sender].totalDebt is always < self.debtLimit\n', '    # NOTE: At least one of `credit` or `debt` is always 0 (both can be 0)\n', '    if credit > 0:\n', '        self.strategies[msg.sender].totalDebt += credit\n', '        self.totalDebt += credit\n', '\n', '        # Returns are always "realized gains"\n', '        self.strategies[msg.sender].totalReturns += _return\n', '\n', "    elif debt > 0:  # We're repaying debt now, so there are no gains\n", '        if _return <= debt:\n', '            # Pay down our debt with profit\n', '            # NOTE: Cannot return more than you borrowed\n', '            self.strategies[msg.sender].totalDebt -= _return\n', '            self.totalDebt -= _return\n', '            debt -= _return  # Debt payment complete (to report back to strategy)\n', '\n', '        else:\n', '            # Finish off our debt payments here\n', '            self.totalDebt -= debt\n', '            self.strategies[msg.sender].totalDebt -= debt\n', '\n', '            # Returns are always "realized gains" (after we have paid off our debt)\n', '            self.strategies[msg.sender].totalReturns += _return - debt\n', '            debt = 0  # All debts paid off (to report back to strategy)\n', '\n', '    elif _return > 0:  # No debt to pay, nor credit to expand with, add to profit!\n', '        self.strategies[msg.sender].totalReturns += _return\n', '\n', '    # else, no credit/debt to manage, nor returns to report. Nothing really happened!\n', '\n', '    # Update reporting time\n', '    self.strategies[msg.sender].lastReport = block.number\n', '\n', '    log StrategyReported(\n', '        msg.sender,\n', '        _return,\n', '        credit,\n', '        self.strategies[msg.sender].totalReturns,\n', '        self.strategies[msg.sender].totalDebt,\n', '        self.strategies[msg.sender].debtLimit,\n', '    )\n', '\n', '    if self.strategies[msg.sender].totalDebt == 0 or self.emergencyShutdown:\n', '        # Take every last penny the Strategy has (Emergency Exit/revokeStrategy)\n', '        # NOTE: This is different than `debt` in order to extract *all* of the returns\n', '        return self._balanceSheetOfStrategy(msg.sender)\n', '    else:\n', '        # Otherwise, just return what we have as debt outstanding\n', '        return debt\n', '\n', '\n', '@internal\n', 'def erc20_safe_transfer(_token: address, _to: address, _value: uint256):\n', '    # HACK: Used to handle non-compliant tokens like USDT\n', '    _response: Bytes[32] = raw_call(\n', '        _token,\n', '        concat(\n', '            method_id("transfer(address,uint256)"),\n', '            convert(_to, bytes32),\n', '            convert(_value, bytes32)\n', '        ),\n', '        max_outsize=32\n', '    )\n', '    if len(_response) > 0:\n', '        assert convert(_response, bool), "Transfer failed!"\n', '\n', '\n', '@external\n', 'def sweep(_token: address):\n', "    # Can't be used to steal what this Vault is protecting\n", '    assert _token != self.token.address\n', '    self.erc20_safe_transfer(_token, self.governance, ERC20(_token).balanceOf(self))']