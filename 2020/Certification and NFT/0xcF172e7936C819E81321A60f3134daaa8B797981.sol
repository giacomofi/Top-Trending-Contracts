['// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.6.6;\n', '\n', 'interface UniswapPairContract {\n', '  \n', '  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '}\n', '        \n', '\n', 'interface xETHTokenInterface {\n', '   \n', '    //Public functions\n', '    function maxScalingFactor() external view returns (uint256);\n', '    function xETHScalingFactor() external view returns (uint256);\n', '    //rebase permissioned\n', '    function setTxFee(uint16 fee) external ;\n', '    function setSellFee(uint16 fee) external ;\n', '    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);\n', '}\n', '\n', 'contract xETHRebaser {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    modifier onlyGov() {\n', '        require(msg.sender == gov, "This function can only be called by the governance address");\n', '        _;\n', '    }\n', '\n', '    /// @notice an event emitted when deviationThreshold is changed\n', '    event NewDeviationThreshold(uint256 oldDeviationThreshold, uint256 newDeviationThreshold);\n', '\n', '    /// @notice Governance address\n', '    address public gov;\n', '\n', '    /// @notice Spreads out getting to the target price\n', '    uint256 public rebaseLag;\n', '\n', '    /// @notice Peg target\n', '    uint256 public targetRate;\n', '  \n', '    // If the current exchange rate is within this fractional distance from the target, no supply\n', '    // update is performed. Fixed point number--same format as the rate.\n', '    // (ie) abs(rate - targetRate) / targetRate < deviationThreshold, then no supply change.\n', '    uint256 public deviationThreshold;\n', '\n', '    /// @notice Min time between last rebase and the next one\n', '    uint256 public minRebaseTimeIntervalSec;\n', '\n', '    /// @notice Block timestamp of last rebase operation\n', '    uint256 public lastRebaseTimestampSec;\n', '\n', '    /// @notice The number of rebase cycles since inception\n', '    uint256 public epoch;\n', '\n', '    address public xETHAddress;\n', '   \n', '    address public uniswap_xeth_eth_pair;\n', '    \n', '    mapping(address => bool) public whitelistFrom;\n', '    \n', '    constructor(address xETHAddress_, address xEthEthPair_) public {\n', '          // First rebase can happen straight away\n', '          minRebaseTimeIntervalSec = 0;\n', '          lastRebaseTimestampSec = 0;\n', '       \n', '          // 0.01 ETH\n', '          targetRate = 10**16;\n', '\n', '          // daily rebase, with targeting reaching peg in 2 days\n', '          rebaseLag = 2;\n', '\n', '          // 0.5%\n', '          deviationThreshold = 5 * 10**15;\n', '\n', '          uniswap_xeth_eth_pair = xEthEthPair_;\n', '          xETHAddress = xETHAddress_;\n', '\n', '          gov = msg.sender;\n', '          whitelistFrom[msg.sender] = true;\n', '    }\n', '\n', '    function setGovernance(address _newGovernance) external onlyGov {\n', '        gov = _newGovernance;\n', '    }\n', '\n', '    function setWhitelistedFrom(address _addr, bool _whitelisted) external onlyGov {\n', '        whitelistFrom[_addr] = _whitelisted;\n', '    }\n', '    \n', '     function _isWhitelisted(address _from) internal view returns (bool) {\n', '        return whitelistFrom[_from];\n', '    }\n', '    \n', '    /**\n', '     * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\n', '     *\n', '     * @dev The supply adjustment equals (_totalSupply * DeviationFromTargetRate) / rebaseLag\n', '     *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\n', '     *      and targetRate is 1e18\n', '     */\n', '    function rebase() public {\n', '        // Validate the address which triggered the rebase\n', '        // EOA only\n', '        require(msg.sender == tx.origin, "Message sender is not where the tx originated!");\n', '        require(_isWhitelisted(msg.sender), "Message sender is not authorized for rebasing!");\n', '\n', '        // Validate the gap since last rebase is big enough\n', '        uint256 elapsed = lastRebaseTimestampSec.add(minRebaseTimeIntervalSec);\n', '        require(elapsed < block.timestamp, "Not enough time has elapsed since last rebase!");\n', '\n', '        // Update rebase tracker parameters\n', '        epoch = epoch.add(1);\n', '        lastRebaseTimestampSec = block.timestamp;\n', '        minRebaseTimeIntervalSec = _computeTimeLeftUntilNextWindow();\n', '\n', '        // get price from uniswap v2;\n', '        uint256 exchangeRate = getPrice();\n', '\n', '        // calculates % change to supply\n', '        (uint256 offPegPerc, bool positive) = computeOffPegPerc(exchangeRate);\n', '\n', '        uint256 indexDelta = offPegPerc;\n', '\n', '        // Apply the Dampening factor.\n', '        indexDelta = indexDelta.div(rebaseLag);\n', '\n', '        xETHTokenInterface xETH = xETHTokenInterface(xETHAddress);\n', '\n', '        if (positive) {\n', '            require(xETH.xETHScalingFactor().mul(uint256(10**18).add(indexDelta)).div(10**18) < xETH.maxScalingFactor(), "new scaling factor will be too big");\n', '        }\n', '\n', '        // rebase\n', '        xETH.rebase(epoch, indexDelta, positive);\n', '        assert(xETH.xETHScalingFactor() <= xETH.maxScalingFactor());\n', '    }\n', '\n', '    function _computeTimeLeftUntilNextWindow() private view returns (uint256) {\n', '        uint secsInDay = 1 days;\n', '        return secsInDay - (block.timestamp % secsInDay);\n', '    }\n', '\n', '    function getPrice() public view returns (uint256) {\n', '        (uint xethReserve, uint ethReserve, ) = UniswapPairContract(uniswap_xeth_eth_pair).getReserves();\n', '        uint xEthPrice = ethReserve.mul(10**18).div(xethReserve);\n', '        return xEthPrice;\n', '    }\n', '\n', '    function setDeviationThreshold(uint256 deviationThreshold_) external onlyGov {\n', '        require(deviationThreshold > 0);\n', '        uint256 oldDeviationThreshold = deviationThreshold;\n', '        deviationThreshold = deviationThreshold_;\n', '        emit NewDeviationThreshold(oldDeviationThreshold, deviationThreshold_);\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the rebase lag parameter.\n', '               It is used to dampen the applied supply adjustment by 1 / rebaseLag\n', '               If the rebase lag R, equals 1, the smallest value for R, then the full supply\n', '               correction is applied on each rebase cycle.\n', '               If it is greater than 1, then a correction of 1/R of is applied on each rebase.\n', '     * @param rebaseLag_ The new rebase lag parameter.\n', '     */\n', '    function setRebaseLag(uint256 rebaseLag_) external onlyGov {\n', '        require(rebaseLag_ > 0);\n', '        rebaseLag = rebaseLag_;\n', '    }\n', '    \n', '    /**\n', '     * @notice Sets the targetRate parameter.\n', '     * @param targetRate_ The new target rate parameter.\n', '     */\n', '    function setTargetRate(uint256 targetRate_) external onlyGov {\n', '        require(targetRate_ > 0);\n', '        targetRate = targetRate_;\n', '    }\n', '\n', '    function setSellFee(uint16 _fee) external onlyGov {\n', '        require(_fee > 0);\n', '        xETHTokenInterface(xETHAddress).setSellFee(_fee);\n', '    }\n', '\n', '    function setTxFee(uint16 _fee) external onlyGov {\n', '        require(_fee > 0);\n', '        xETHTokenInterface(xETHAddress).setTxFee(_fee);\n', '    }\n', '\n', '    /**\n', '     * @return Computes in % how far off market is from peg\n', '     */\n', '    function computeOffPegPerc(uint256 rate) private view returns (uint256, bool) {\n', '        if (withinDeviationThreshold(rate)) {\n', '            return (0, false);\n', '        }\n', '\n', '        // indexDelta =  (rate - targetRate) / targetRate\n', '        if (rate > targetRate) {\n', '            return (rate.sub(targetRate).mul(10**18).div(targetRate), true);\n', '        } else {\n', '            return (targetRate.sub(rate).mul(10**18).div(targetRate), false);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @param rate The current exchange rate, an 18 decimal fixed point number.\n', '     * @return If the rate is within the deviation threshold from the target rate, returns true.\n', '     *         Otherwise, returns false.\n', '     */\n', '    function withinDeviationThreshold(uint256 rate) private view returns (bool) {\n', '        uint256 absoluteDeviationThreshold = targetRate.mul(deviationThreshold)\n', '            .div(10 ** 18);\n', '\n', '        return (rate >= targetRate && rate.sub(targetRate) < absoluteDeviationThreshold)\n', '            || (rate < targetRate && targetRate.sub(rate) < absoluteDeviationThreshold);\n', '    }\n', '}\n', '\n', '  library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '\n', '    return c;\n', '  }\n', '\n', ' \n', ' function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); // Solidity only automatically asserts when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', ' \n', ' function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  \n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '\n', '    return c;\n', '  }\n', '  \n', '  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n', '    uint256 c = add(a,m);\n', '    uint256 d = sub(c,1);\n', '    return mul(div(d,m),m);\n', '  }\n', '\n', '  /**\n', '  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '  * reverts when dividing by zero.\n', '  */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '  \n', '  function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        require(y != 0, "Div by zero");\n', '        uint256 r = x / y;\n', '        if (x % y != 0) {\n', '            r = r + 1;\n', '        }\n', '\n', '        return r;\n', '    }\n', '}']