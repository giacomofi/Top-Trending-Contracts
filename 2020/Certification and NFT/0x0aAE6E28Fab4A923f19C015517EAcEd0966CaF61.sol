['// Dependency file: contracts/libraries/TransferHelper.sol\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', '// pragma solidity >=0.6.0;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', '\n', '// Root file: contracts/DemaxConvert.sol\n', '\n', 'pragma solidity >=0.5.16;\n', '\n', "// import 'contracts/libraries/TransferHelper.sol';\n", '\n', 'interface IERC20 {\n', '    function balanceOf(address owner) external view returns (uint);\n', '}\n', '\n', 'contract DemaxConvert {\n', '    event ConvertETHForBNB(address indexed user, uint amount);\n', '    event ConvertTokenForBNB(address indexed user, address token, uint amount);\n', '    event CollectETH(uint amount);\n', '    event CollectToken(address token, uint amount);\n', '    \n', '    address public owner;\n', '    address public wallet;\n', '    \n', '    address[] public allTokens;\n', '    \n', '    mapping (address => bool) public users;\n', '    \n', '    mapping (address => uint) public tokenLimits;\n', '    \n', '    constructor (address _wallet) public {\n', '        owner = msg.sender;\n', '        wallet = _wallet;\n', '    }\n', '    \n', '    function changeWallet(address _wallet) external {\n', '        require(msg.sender == owner, "FORBIDDEN");\n', '        wallet = _wallet;\n', '    }\n', '    \n', '    function enableToken(address _token, uint _limit) external{\n', '        require(msg.sender == owner, "FORBIDDEN");    \n', '        tokenLimits[_token] = _limit;\n', '        \n', '        bool isAdd = false;\n', '        for(uint i = 0;i < allTokens.length;i++) {\n', '            if(allTokens[i] == _token) {\n', '                isAdd = true;\n', '                break;\n', '            }\n', '        }\n', '        \n', '        if(!isAdd) {\n', '            allTokens.push(_token);\n', '        }\n', '    }\n', '    \n', '    function validTokens() external view returns (address[] memory) {\n', '        uint count;\n', '        for (uint i; i < allTokens.length; i++) {\n', '            if (tokenLimits[allTokens[i]] > 0) {\n', '                count++;\n', '            }\n', '        }\n', '        address[] memory res = new address[](count);\n', '        uint index = 0;\n', '        for (uint i; i < allTokens.length; i++) {\n', '            if (tokenLimits[allTokens[i]] > 0) {\n', '                res[index] = allTokens[i];\n', '                index++;\n', '            }\n', '        }\n', '        return res;\n', '    }\n', '    \n', '    function convertETHForBNB() payable external {\n', '        require(msg.value > 0 && msg.value <= tokenLimits[address(0)], "INVALID_AMOUNT");\n', '        require(users[msg.sender] == false, "ALREADY_CONVERT");\n', '        users[msg.sender] = true;\n', '        emit ConvertETHForBNB(msg.sender, msg.value);\n', '    }\n', '    \n', '    function convertTokenForBNB(address _token, uint _amount) external {\n', '        require(_amount > 0 && _amount <= tokenLimits[_token], "INVALID_AMOUNT");\n', '        require(users[msg.sender] == false, "ALREADY_CONVERT");\n', '        users[msg.sender] = true;\n', '        TransferHelper.safeTransferFrom(_token, msg.sender, address(this), _amount);\n', '        emit ConvertTokenForBNB(msg.sender, _token, _amount);\n', '    }\n', '    \n', '    function collect() external {\n', '        require(msg.sender == owner, "FORBIDDEN");\n', '        for(uint i = 0;i < allTokens.length;i++) {\n', '            uint balance = IERC20(allTokens[i]).balanceOf(address(this));\n', '            if(balance > 0) {\n', '                TransferHelper.safeTransfer(allTokens[i], wallet, balance);\n', '                emit CollectToken(allTokens[i], balance);\n', '            }\n', '        }\n', '        \n', '        if(address(this).balance > 0) {\n', '            emit CollectETH(address(this).balance);\n', '            TransferHelper.safeTransferETH(wallet, address(this).balance);\n', '        }\n', '    }\n', '}']