['pragma solidity 0.5.16;\n', '\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol";\n', 'import "./IMorpherToken.sol";\n', '\n', '// ----------------------------------------------------------------------------------\n', '// Data and token balance storage of the Morpher platform\n', '// Writing access is only granted to platform contracts. The contract can be paused\n', '// by an elected platform administrator (see MorpherGovernance) to perform protocol updates.\n', '// ----------------------------------------------------------------------------------\n', '\n', 'contract MorpherState is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    bool public mainChain;\n', '    uint256 public totalSupply;\n', '    uint256 public totalToken;\n', '    uint256 public totalInPositions;\n', '    uint256 public totalOnOtherChain;\n', '    uint256 public maximumLeverage = 10**9; // Leverage precision is 1e8, maximum leverage set to 10 initially\n', '    uint256 constant PRECISION = 10**8;\n', '    uint256 constant DECIMALS = 18;\n', '    uint256 constant REWARDPERIOD = 1 days;\n', '    bool public paused = false;\n', '\n', '    address public morpherGovernance;\n', '    address public morpherRewards;\n', '    address public administrator;\n', '    address public oracleContract;\n', '    address public sideChainOperator;\n', '    address public morpherBridge;\n', '    address public morpherToken;\n', '\n', '    uint256 public rewardBasisPoints;\n', '    uint256 public lastRewardTime;\n', '\n', '    bytes32 public sideChainMerkleRoot;\n', '    uint256 public sideChainMerkleRootWrittenAtTime;\n', '\n', '    // Set initial withdraw limit from sidechain to 20m token or 2% of initial supply\n', '    uint256 public mainChainWithdrawLimit24 = 2 * 10**25;\n', '\n', '    mapping(address => bool) private stateAccess;\n', '    mapping(address => bool) private transferAllowed;\n', '\n', '    mapping(address => uint256) private balances;\n', '    mapping(address => mapping(address => uint256)) private allowed;\n', '\n', '    mapping(bytes32 => bool) private marketActive;\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Position struct records virtual futures\n', '    // ----------------------------------------------------------------------------\n', '    struct position {\n', '        uint256 lastUpdated;\n', '        uint256 longShares;\n', '        uint256 shortShares;\n', '        uint256 meanEntryPrice;\n', '        uint256 meanEntrySpread;\n', '        uint256 meanEntryLeverage;\n', '        uint256 liquidationPrice;\n', '        bytes32 positionHash;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // A portfolio is an address specific collection of postions\n', '    // ----------------------------------------------------------------------------\n', '    mapping(address => mapping(bytes32 => position)) private portfolio;\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Record all addresses that hold a position of a market, needed for clean stock splits\n', '    // ----------------------------------------------------------------------------\n', '    struct hasExposure {\n', '        uint256 maxMappingIndex;\n', '        mapping(address => uint256) index;\n', '        mapping(uint256 => address) addy;\n', '    }\n', '\n', '    mapping(bytes32 => hasExposure) private exposureByMarket;\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Bridge Variables\n', '    // ----------------------------------------------------------------------------\n', '    mapping (address => uint256) private tokenClaimedOnThisChain;\n', '    mapping (address => uint256) private tokenSentToLinkedChain;\n', '    mapping (address => uint256) private tokenSentToLinkedChainTime;\n', '    mapping (bytes32 => bool) private positionClaimedOnMainChain;\n', '\n', '    uint256 public lastWithdrawLimitReductionTime;\n', '    uint256 public last24HoursAmountWithdrawn;\n', '    uint256 public withdrawLimit24Hours;\n', '    uint256 public inactivityPeriod = 3 days;\n', '    uint256 public transferNonce;\n', '    bool public fastTransfersEnabled;\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Sidechain spam protection\n', '    // ----------------------------------------------------------------------------\n', '\n', '    mapping(address => uint256) private lastRequestBlock;\n', '    mapping(address => uint256) private numberOfRequests;\n', '    uint256 public numberOfRequestsLimit;\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Events\n', '    // ----------------------------------------------------------------------------\n', '    event StateAccessGranted(address indexed whiteList, uint256 indexed blockNumber);\n', '    event StateAccessDenied(address indexed blackList, uint256 indexed blockNumber);\n', '\n', '    event TransfersEnabled(address indexed whiteList);\n', '    event TransfersDisabled(address indexed blackList);\n', '\n', '    event Transfer(address indexed sender, address indexed recipient, uint256 amount);\n', '    event Mint(address indexed recipient, uint256 amount, uint256 totalToken);\n', '    event Burn(address indexed recipient, uint256 amount, uint256 totalToken);\n', '    event NewTotalSupply(uint256 newTotalSupply);\n', '    event NewTotalOnOtherChain(uint256 newTotalOnOtherChain);\n', '    event NewTotalInPositions(uint256 newTotalOnOtherChain);\n', '    event OperatingRewardMinted(address indexed recipient, uint256 amount);\n', '\n', '    event RewardsChange(address indexed rewardsAddress, uint256 indexed rewardsBasisPoints);\n', '    event LastRewardTime(uint256 indexed rewardsTime);\n', '    event GovernanceChange(address indexed governanceAddress);\n', '    event TokenChange(address indexed tokenAddress);\n', '    event AdministratorChange(address indexed administratorAddress);\n', '    event OracleChange(address indexed oracleContract);\n', '    event MaximumLeverageChange(uint256 maxLeverage);\n', '    event MarketActivated(bytes32 indexed activateMarket);\n', '    event MarketDeActivated(bytes32 indexed deActivateMarket);\n', '    event BridgeChange(address _bridgeAddress);\n', '    event SideChainMerkleRootUpdate(bytes32 indexed sideChainMerkleRoot);\n', '    event NewSideChainOperator(address indexed sideChainOperator);\n', '    event NumberOfRequestsLimitUpdate(uint256 _numberOfRequests);\n', '\n', '    event MainChainWithdrawLimitUpdate(uint256 indexed mainChainWithdrawLimit24);\n', '    event TokenSentToLinkedChain(address _address, uint256 _token, uint256 _totalTokenSent, bytes32 indexed _tokenSentToLinkedChainHash);\n', '    event TransferredTokenClaimed(address _address, uint256 _token);\n', '    event LastWithdrawAt();\n', '    event RollingWithdrawnAmountUpdated(uint256 _last24HoursAmountWithdrawn, uint256 _lastWithdrawLimitReductionTime);\n', '    event WithdrawLimitUpdated(uint256 _amount);\n', '    event InactivityPeriodUpdated(uint256 _periodLength);\n', '    event FastWithdrawsDisabled();\n', '    event NewBridgeNonce(uint256 _transferNonce);\n', '    event Last24HoursAmountWithdrawnReset();\n', '\n', '    event StatePaused(address administrator, bool _paused);\n', '\n', '    event SetAllowance(address indexed sender, address indexed spender, uint256 tokens);\n', '    event SetPosition(bytes32 indexed positionHash,\n', '        address indexed sender,\n', '        bytes32 indexed marketId,\n', '        uint256 timeStamp,\n', '        uint256 longShares,\n', '        uint256 shortShares,\n', '        uint256 meanEntryPrice,\n', '        uint256 meanEntrySpread,\n', '        uint256 meanEntryLeverage,\n', '        uint256 liquidationPrice\n', '    );\n', '    event SetBalance(address indexed account, uint256 balance, bytes32 indexed balanceHash);\n', '    event TokenTransferredToOtherChain(address indexed account, uint256 tokenTransferredToOtherChain, bytes32 indexed transferHash);\n', '\n', '    modifier notPaused {\n', '        require(paused == false, "MorpherState: Contract paused, aborting");\n', '        _;\n', '    }\n', '\n', '    modifier onlyPlatform {\n', '        require(stateAccess[msg.sender] == true, "MorpherState: Only Platform is allowed to execute operation.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyGovernance {\n', '        require(msg.sender == getGovernance(), "MorpherState: Calling contract not the Governance Contract. Aborting.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdministrator {\n', '        require(msg.sender == getAdministrator(), "MorpherState: Caller is not the Administrator. Aborting.");\n', '        _;\n', '    }\n', '\n', '    modifier onlySideChainOperator {\n', '        require(msg.sender == sideChainOperator, "MorpherState: Caller is not the Sidechain Operator. Aborting.");\n', '        _;\n', '    }\n', '\n', '    modifier canTransfer {\n', '        require(getCanTransfer(msg.sender), "MorpherState: Caller may not transfer token. Aborting.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyBridge {\n', '        require(msg.sender == getMorpherBridge(), "MorpherState: Caller is not the Bridge. Aborting.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyMainChain {\n', '        require(mainChain == true, "MorpherState: Can only be called on mainchain.");\n', '        _;\n', '    }\n', '\n', '    modifier onlySideChain {\n', '        require(mainChain == false, "MorpherState: Can only be called on mainchain.");\n', '        _;\n', '    }\n', '\n', '    constructor(bool _mainChain, address _sideChainOperator, address _morpherTreasury) public {\n', '        // @Deployer: Transfer State Ownership to cold storage address after deploying protocol\n', '        mainChain = _mainChain; // true for Ethereum, false for Morpher PoA sidechain\n', '        setLastRewardTime(now);\n', '        uint256 _sideChainMint = 575000000 * 10**(DECIMALS);\n', '        uint256 _mainChainMint = 425000000 * 10**(DECIMALS);\n', '        grantAccess(owner());\n', '        setSideChainOperator(owner());\n', '        if (mainChain == false) { // Create token only on sidechain\n', '            balances[owner()] = _sideChainMint; // Create airdrop and team token on sidechain\n', '            totalToken = _sideChainMint;\n', '            emit Mint(owner(), balanceOf(owner()), _sideChainMint);\n', '            setRewardBasisPoints(0); // Reward is minted on mainchain\n', '            setRewardAddress(address(0));\n', '            setTotalOnOtherChain(_mainChainMint);\n', '        } else {\n', '            balances[owner()] = _mainChainMint; // Create treasury and investor token on mainchain\n', '            totalToken = _mainChainMint;\n', '            emit Mint(owner(), balanceOf(owner()), _mainChainMint);\n', '            setRewardBasisPoints(15000); // 15000 / PRECISION = 0.00015\n', '            setRewardAddress(_morpherTreasury);\n', '            setTotalOnOtherChain(_sideChainMint);\n', '        }\n', '        fastTransfersEnabled = true;\n', '        setNumberOfRequestsLimit(3);\n', '        setMainChainWithdrawLimit(totalSupply / 50);\n', '        setSideChainOperator(_sideChainOperator);\n', '        denyAccess(owner());\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Setter/Getter functions for market wise exposure\n', '    // ----------------------------------------------------------------------------\n', '\n', '    function getMaxMappingIndex(bytes32 _marketId) public view returns(uint256 _maxMappingIndex) {\n', '        return exposureByMarket[_marketId].maxMappingIndex;\n', '    }\n', '\n', '    function getExposureMappingIndex(bytes32 _marketId, address _address) public view returns(uint256 _mappingIndex) {\n', '        return exposureByMarket[_marketId].index[_address];\n', '    }\n', '\n', '    function getExposureMappingAddress(bytes32 _marketId, uint256 _mappingIndex) public view returns(address _address) {\n', '        return exposureByMarket[_marketId].addy[_mappingIndex];\n', '    }\n', '\n', '    function setMaxMappingIndex(bytes32 _marketId, uint256 _maxMappingIndex) public onlyPlatform {\n', '        exposureByMarket[_marketId].maxMappingIndex = _maxMappingIndex;\n', '    }\n', '\n', '    function setExposureMapping(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform  {\n', '        setExposureMappingIndex(_marketId, _address, _index);\n', '        setExposureMappingAddress(_marketId, _address, _index);\n', '    }\n', '\n', '    function setExposureMappingIndex(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform {\n', '        exposureByMarket[_marketId].index[_address] = _index;\n', '    }\n', '\n', '    function setExposureMappingAddress(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform {\n', '        exposureByMarket[_marketId].addy[_index] = _address;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Setter/Getter functions for bridge variables\n', '    // ----------------------------------------------------------------------------\n', '    function setTokenClaimedOnThisChain(address _address, uint256 _token) public onlyBridge {\n', '        tokenClaimedOnThisChain[_address] = _token;\n', '        emit TransferredTokenClaimed(_address, _token);\n', '    }\n', '\n', '    function getTokenClaimedOnThisChain(address _address) public view returns (uint256 _token) {\n', '        return tokenClaimedOnThisChain[_address];\n', '    }\n', '\n', '    function setTokenSentToLinkedChain(address _address, uint256 _token) public onlyBridge {\n', '        tokenSentToLinkedChain[_address] = _token;\n', '        tokenSentToLinkedChainTime[_address] = now;\n', '        emit TokenSentToLinkedChain(_address, _token, tokenSentToLinkedChain[_address], getBalanceHash(_address, tokenSentToLinkedChain[_address]));\n', '    }\n', '\n', '    function getTokenSentToLinkedChain(address _address) public view returns (uint256 _token) {\n', '        return tokenSentToLinkedChain[_address];\n', '    }\n', '\n', '    function getTokenSentToLinkedChainTime(address _address) public view returns (uint256 _timeStamp) {\n', '        return tokenSentToLinkedChainTime[_address];\n', '    }\n', '\n', '    function add24HoursWithdrawn(uint256 _amount) public onlyBridge {\n', '        last24HoursAmountWithdrawn = last24HoursAmountWithdrawn.add(_amount);\n', '        emit RollingWithdrawnAmountUpdated(last24HoursAmountWithdrawn, lastWithdrawLimitReductionTime);\n', '    }\n', '\n', '    function update24HoursWithdrawLimit(uint256 _amount) public onlyBridge {\n', '        if (last24HoursAmountWithdrawn > _amount) {\n', '            last24HoursAmountWithdrawn = last24HoursAmountWithdrawn.sub(_amount);\n', '        } else {\n', '            last24HoursAmountWithdrawn = 0;\n', '        }\n', '        lastWithdrawLimitReductionTime = now;\n', '        emit RollingWithdrawnAmountUpdated(last24HoursAmountWithdrawn, lastWithdrawLimitReductionTime);\n', '    }\n', '\n', '    function set24HourWithdrawLimit(uint256 _limit) public onlyBridge {\n', '        withdrawLimit24Hours = _limit;\n', '        emit WithdrawLimitUpdated(_limit);\n', '    }\n', '\n', '    function resetLast24HoursAmountWithdrawn() public onlyBridge {\n', '        last24HoursAmountWithdrawn = 0;\n', '        emit Last24HoursAmountWithdrawnReset();\n', '    }\n', '\n', '    function setInactivityPeriod(uint256 _periodLength) public onlyBridge {\n', '        inactivityPeriod = _periodLength;\n', '        emit InactivityPeriodUpdated(_periodLength);\n', '    }\n', '\n', '    function getBridgeNonce() public onlyBridge returns (uint256 _nonce) {\n', '        transferNonce++;\n', '        emit NewBridgeNonce(transferNonce);\n', '        return transferNonce;\n', '    }\n', '\n', '    function disableFastWithdraws() public onlyBridge {\n', '        fastTransfersEnabled = false;\n', '        emit FastWithdrawsDisabled();\n', '    }\n', '\n', '    function setPositionClaimedOnMainChain(bytes32 _positionHash) public onlyBridge {\n', '        positionClaimedOnMainChain[_positionHash] = true;\n', '    }\n', '\n', '    function getPositionClaimedOnMainChain(bytes32 _positionHash) public view returns (bool _alreadyClaimed) {\n', '        return positionClaimedOnMainChain[_positionHash];\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Setter/Getter functions for spam protection\n', '    // ----------------------------------------------------------------------------\n', '\n', '    function setLastRequestBlock(address _address) public onlyPlatform {\n', '        lastRequestBlock[_address] = block.number;\n', '    }\n', '\n', '    function getLastRequestBlock(address _address) public view returns(uint256 _lastRequestBlock) {\n', '        return lastRequestBlock[_address];\n', '    }\n', '\n', '    function setNumberOfRequests(address _address, uint256 _numberOfRequests) public onlyPlatform {\n', '        numberOfRequests[_address] = _numberOfRequests;\n', '    }\n', '\n', '    function increaseNumberOfRequests(address _address) public onlyPlatform{\n', '        numberOfRequests[_address]++;\n', '    }\n', '\n', '    function getNumberOfRequests(address _address) public view returns(uint256 _numberOfRequests) {\n', '        return numberOfRequests[_address];\n', '    }\n', '\n', '    function setNumberOfRequestsLimit(uint256 _numberOfRequestsLimit) public onlyPlatform {\n', '        numberOfRequestsLimit = _numberOfRequestsLimit;\n', '        emit NumberOfRequestsLimitUpdate(_numberOfRequestsLimit);\n', '    }\n', '\n', '    function getNumberOfRequestsLimit() public view returns (uint256 _numberOfRequestsLimit) {\n', '        return numberOfRequestsLimit;\n', '    }\n', '\n', '    function setMainChainWithdrawLimit(uint256 _mainChainWithdrawLimit24) public onlyOwner {\n', '        mainChainWithdrawLimit24 = _mainChainWithdrawLimit24;\n', '        emit MainChainWithdrawLimitUpdate(_mainChainWithdrawLimit24);\n', '    }\n', '\n', '    function getMainChainWithdrawLimit() public view returns (uint256 _mainChainWithdrawLimit24) {\n', '        return mainChainWithdrawLimit24;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Setter/Getter functions for state access\n', '    // ----------------------------------------------------------------------------\n', '\n', '    function grantAccess(address _address) public onlyOwner {\n', '        stateAccess[_address] = true;\n', '        emit StateAccessGranted(_address, block.number);\n', '    }\n', '\n', '    function denyAccess(address _address) public onlyOwner {\n', '        stateAccess[_address] = false;\n', '        emit StateAccessDenied(_address, block.number);\n', '    }\n', '\n', '    function getStateAccess(address _address) public view returns(bool _hasAccess) {\n', '        return stateAccess[_address];\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Setter/Getter functions for addresses that can transfer tokens (sidechain only)\n', '    // ----------------------------------------------------------------------------\n', '\n', '    function enableTransfers(address _address) public onlyOwner {\n', '        transferAllowed[_address] = true;\n', '        emit TransfersEnabled(_address);\n', '    }\n', '\n', '    function disableTransfers(address _address) public onlyOwner {\n', '        transferAllowed[_address] = false;\n', '        emit TransfersDisabled(_address);\n', '    }\n', '\n', '    function getCanTransfer(address _address) public view returns(bool _hasAccess) {\n', '        return transferAllowed[_address];\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Minting/burning/transfer of token\n', '    // ----------------------------------------------------------------------------\n', '\n', '    function transfer(address _from, address _to, uint256 _token) public onlyPlatform notPaused {\n', '        require(balances[_from] >= _token, "MorpherState: Not enough token.");\n', '        balances[_from] = balances[_from].sub(_token);\n', '        balances[_to] = balances[_to].add(_token);\n', '        IMorpherToken(morpherToken).emitTransfer(_from, _to, _token);\n', '        emit Transfer(_from, _to, _token);\n', '        emit SetBalance(_from, balances[_from], getBalanceHash(_from, balances[_from]));\n', '        emit SetBalance(_to, balances[_to], getBalanceHash(_to, balances[_to]));\n', '    }\n', '\n', '    function mint(address _address, uint256 _token) public onlyPlatform notPaused {\n', '        balances[_address] = balances[_address].add(_token);\n', '        totalToken = totalToken.add(_token);\n', '        updateTotalSupply();\n', '        IMorpherToken(morpherToken).emitTransfer(address(0), _address, _token);\n', '        emit Mint(_address, _token, totalToken);\n', '        emit SetBalance(_address, balances[_address], getBalanceHash(_address, balances[_address]));\n', '    }\n', '\n', '    function burn(address _address, uint256 _token) public onlyPlatform notPaused {\n', '        require(balances[_address] >= _token, "MorpherState: Not enough token.");\n', '        balances[_address] = balances[_address].sub(_token);\n', '        totalToken = totalToken.sub(_token);\n', '        updateTotalSupply();\n', '        IMorpherToken(morpherToken).emitTransfer(_address, address(0), _token);\n', '        emit Burn(_address, _token, totalToken);\n', '        emit SetBalance(_address, balances[_address], getBalanceHash(_address, balances[_address]));\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Setter/Getter functions for balance and token functions (ERC20)\n', '    // ----------------------------------------------------------------------------\n', '    function updateTotalSupply() private {\n', '        totalSupply = totalToken.add(totalInPositions).add(totalOnOtherChain);\n', '        emit NewTotalSupply(totalSupply);\n', '    }\n', '\n', '    function setTotalInPositions(uint256 _totalInPositions) public onlyAdministrator {\n', '        totalInPositions = _totalInPositions;\n', '        updateTotalSupply();\n', '        emit NewTotalInPositions(_totalInPositions);\n', '    }\n', '\n', '    function setTotalOnOtherChain(uint256 _newTotalOnOtherChain) public onlySideChainOperator {\n', '        totalOnOtherChain = _newTotalOnOtherChain;\n', '        updateTotalSupply();\n', '        emit NewTotalOnOtherChain(_newTotalOnOtherChain);\n', '    }\n', '\n', '    function balanceOf(address _tokenOwner) public view returns (uint256 balance) {\n', '        return balances[_tokenOwner];\n', '    }\n', '\n', '    function setAllowance(address _from, address _spender, uint256 _tokens) public onlyPlatform {\n', '        allowed[_from][_spender] = _tokens;\n', '        emit SetAllowance(_from, _spender, _tokens);\n', '    }\n', '\n', '    function getAllowance(address _tokenOwner, address spender) public view returns (uint256 remaining) {\n', '        return allowed[_tokenOwner][spender];\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Setter/Getter functions for platform roles\n', '    // ----------------------------------------------------------------------------\n', '\n', '    function setGovernanceContract(address _newGovernanceContractAddress) public onlyOwner {\n', '        morpherGovernance = _newGovernanceContractAddress;\n', '        emit GovernanceChange(_newGovernanceContractAddress);\n', '    }\n', '\n', '    function getGovernance() public view returns (address _governanceContract) {\n', '        return morpherGovernance;\n', '    }\n', '\n', '    function setMorpherBridge(address _newBridge) public onlyOwner {\n', '        morpherBridge = _newBridge;\n', '        emit BridgeChange(_newBridge);\n', '    }\n', '\n', '    function getMorpherBridge() public view returns (address _currentBridge) {\n', '        return morpherBridge;\n', '    }\n', '\n', '    function setOracleContract(address _newOracleContract) public onlyGovernance {\n', '        oracleContract = _newOracleContract;\n', '        emit OracleChange(_newOracleContract);\n', '    }\n', '\n', '    function getOracleContract() public view returns(address) {\n', '        return oracleContract;\n', '    }\n', '\n', '    function setTokenContract(address _newTokenContract) public onlyOwner {\n', '        morpherToken = _newTokenContract;\n', '        emit TokenChange(_newTokenContract);\n', '    }\n', '\n', '    function getTokenContract() public view returns(address) {\n', '        return morpherToken;\n', '    }\n', '\n', '    function setAdministrator(address _newAdministrator) public onlyGovernance {\n', '        administrator = _newAdministrator;\n', '        emit AdministratorChange(_newAdministrator);\n', '    }\n', '\n', '    function getAdministrator() public view returns(address) {\n', '        return administrator;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Setter/Getter functions for platform operating rewards\n', '    // ----------------------------------------------------------------------------\n', '\n', '    function setRewardAddress(address _newRewardsAddress) public onlyOwner {\n', '        morpherRewards = _newRewardsAddress;\n', '        emit RewardsChange(_newRewardsAddress, rewardBasisPoints);\n', '    }\n', '\n', '    function setRewardBasisPoints(uint256 _newRewardBasisPoints) public onlyOwner {\n', '        if (mainChain == true) {\n', '            require(_newRewardBasisPoints <= 15000, "MorpherState: Reward basis points need to be less or equal to 15000.");\n', '        } else {\n', '            require(_newRewardBasisPoints == 0, "MorpherState: Reward basis points can only be set on Ethereum.");\n', '        }\n', '        rewardBasisPoints = _newRewardBasisPoints;\n', '        emit RewardsChange(morpherRewards, _newRewardBasisPoints);\n', '    }\n', '\n', '    function setLastRewardTime(uint256 _lastRewardTime) private {\n', '        lastRewardTime = _lastRewardTime;\n', '        emit LastRewardTime(_lastRewardTime);\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Setter/Getter functions for platform administration\n', '    // ----------------------------------------------------------------------------\n', '\n', '    function activateMarket(bytes32 _activateMarket) public onlyAdministrator {\n', '        marketActive[_activateMarket] = true;\n', '        emit MarketActivated(_activateMarket);\n', '    }\n', '\n', '    function deActivateMarket(bytes32 _deActivateMarket) public onlyAdministrator {\n', '        marketActive[_deActivateMarket] = false;\n', '        emit MarketDeActivated(_deActivateMarket);\n', '    }\n', '\n', '    function getMarketActive(bytes32 _marketId) public view returns(bool _active) {\n', '        return marketActive[_marketId];\n', '    }\n', '\n', '    function setMaximumLeverage(uint256 _newMaximumLeverage) public onlyAdministrator {\n', '        require(_newMaximumLeverage > PRECISION, "MorpherState: Leverage precision is 1e8");\n', '        maximumLeverage = _newMaximumLeverage;\n', '        emit MaximumLeverageChange(_newMaximumLeverage);\n', '    }\n', '\n', '    function getMaximumLeverage() public view returns(uint256 _maxLeverage) {\n', '        return maximumLeverage;\n', '    }\n', '\n', '    function pauseState() public onlyAdministrator {\n', '        paused = true;\n', '        emit StatePaused(msg.sender, true);\n', '    }\n', '\n', '    function unPauseState() public onlyAdministrator {\n', '        paused = false;\n', '        emit StatePaused(msg.sender, false);\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Setter/Getter for side chain state\n', '    // ----------------------------------------------------------------------------\n', '\n', '    function setSideChainMerkleRoot(bytes32 _sideChainMerkleRoot) public onlyBridge {\n', '        sideChainMerkleRoot = _sideChainMerkleRoot;\n', '        sideChainMerkleRootWrittenAtTime = now;\n', '        payOperatingReward;\n', '        emit SideChainMerkleRootUpdate(_sideChainMerkleRoot);\n', '    }\n', '\n', '    function getSideChainMerkleRoot() public view returns(bytes32 _sideChainMerkleRoot) {\n', '        return sideChainMerkleRoot;\n', '    }\n', '\n', '    function setSideChainOperator(address _address) public onlyOwner {\n', '        sideChainOperator = _address;\n', '        emit NewSideChainOperator(_address);\n', '    }\n', '\n', '    function getSideChainOperator() public view returns (address _address) {\n', '        return sideChainOperator;\n', '    }\n', '\n', '    function getSideChainMerkleRootWrittenAtTime() public view returns(uint256 _sideChainMerkleRoot) {\n', '        return sideChainMerkleRootWrittenAtTime;\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Setter/Getter functions for portfolio\n', '    // ----------------------------------------------------------------------------\n', '\n', '    function setPosition(\n', '        address _address,\n', '        bytes32 _marketId,\n', '        uint256 _timeStamp,\n', '        uint256 _longShares,\n', '        uint256 _shortShares,\n', '        uint256 _meanEntryPrice,\n', '        uint256 _meanEntrySpread,\n', '        uint256 _meanEntryLeverage,\n', '        uint256 _liquidationPrice\n', '    ) public onlyPlatform {\n', '        portfolio[_address][_marketId].lastUpdated = _timeStamp;\n', '        portfolio[_address][_marketId].longShares = _longShares;\n', '        portfolio[_address][_marketId].shortShares = _shortShares;\n', '        portfolio[_address][_marketId].meanEntryPrice = _meanEntryPrice;\n', '        portfolio[_address][_marketId].meanEntrySpread = _meanEntrySpread;\n', '        portfolio[_address][_marketId].meanEntryLeverage = _meanEntryLeverage;\n', '        portfolio[_address][_marketId].liquidationPrice = _liquidationPrice;\n', '        portfolio[_address][_marketId].positionHash = getPositionHash(\n', '            _address,\n', '            _marketId,\n', '            _timeStamp,\n', '            _longShares,\n', '            _shortShares,\n', '            _meanEntryPrice,\n', '            _meanEntrySpread,\n', '            _meanEntryLeverage,\n', '            _liquidationPrice\n', '        );\n', '        if (_longShares > 0 || _shortShares > 0) {\n', '            addExposureByMarket(_marketId, _address);\n', '        } else {\n', '            deleteExposureByMarket(_marketId, _address);\n', '        }\n', '        emit SetPosition(\n', '            portfolio[_address][_marketId].positionHash,\n', '            _address,\n', '            _marketId,\n', '            _timeStamp,\n', '            _longShares,\n', '            _shortShares,\n', '            _meanEntryPrice,\n', '            _meanEntrySpread,\n', '            _meanEntryLeverage,\n', '            _liquidationPrice\n', '        );\n', '    }\n', '\n', '    function getPosition(\n', '        address _address,\n', '        bytes32 _marketId\n', '    ) public view returns (\n', '        uint256 _longShares,\n', '        uint256 _shortShares,\n', '        uint256 _meanEntryPrice,\n', '        uint256 _meanEntrySpread,\n', '        uint256 _meanEntryLeverage,\n', '        uint256 _liquidationPrice\n', '    ) {\n', '        return(\n', '        portfolio[_address][_marketId].longShares,\n', '        portfolio[_address][_marketId].shortShares,\n', '        portfolio[_address][_marketId].meanEntryPrice,\n', '        portfolio[_address][_marketId].meanEntrySpread,\n', '        portfolio[_address][_marketId].meanEntryLeverage,\n', '        portfolio[_address][_marketId].liquidationPrice\n', '        );\n', '    }\n', '\n', '    function getPositionHash(\n', '        address _address,\n', '        bytes32 _marketId,\n', '        uint256 _timeStamp,\n', '        uint256 _longShares,\n', '        uint256 _shortShares,\n', '        uint256 _meanEntryPrice,\n', '        uint256 _meanEntrySpread,\n', '        uint256 _meanEntryLeverage,\n', '        uint256 _liquidationPrice\n', '    ) public pure returns (bytes32 _hash) {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                _address,\n', '                _marketId,\n', '                _timeStamp,\n', '                _longShares,\n', '                _shortShares,\n', '                _meanEntryPrice,\n', '                _meanEntrySpread,\n', '                _meanEntryLeverage,\n', '                _liquidationPrice\n', '            )\n', '        );\n', '    }\n', '\n', '    function getBalanceHash(address _address, uint256 _balance) public pure returns (bytes32 _hash) {\n', '        return keccak256(abi.encodePacked(_address, _balance));\n', '    }\n', '\n', '    function getLastUpdated(address _address, bytes32 _marketId) public view returns (uint256 _lastUpdated) {\n', '        return(portfolio[_address][_marketId].lastUpdated);\n', '    }\n', '\n', '    function getLongShares(address _address, bytes32 _marketId) public view returns (uint256 _longShares) {\n', '        return(portfolio[_address][_marketId].longShares);\n', '    }\n', '\n', '    function getShortShares(address _address, bytes32 _marketId) public view returns (uint256 _shortShares) {\n', '        return(portfolio[_address][_marketId].shortShares);\n', '    }\n', '\n', '    function getMeanEntryPrice(address _address, bytes32 _marketId) public view returns (uint256 _meanEntryPrice) {\n', '        return(portfolio[_address][_marketId].meanEntryPrice);\n', '    }\n', '\n', '    function getMeanEntrySpread(address _address, bytes32 _marketId) public view returns (uint256 _meanEntrySpread) {\n', '        return(portfolio[_address][_marketId].meanEntrySpread);\n', '    }\n', '\n', '    function getMeanEntryLeverage(address _address, bytes32 _marketId) public view returns (uint256 _meanEntryLeverage) {\n', '        return(portfolio[_address][_marketId].meanEntryLeverage);\n', '    }\n', '\n', '    function getLiquidationPrice(address _address, bytes32 _marketId) public view returns (uint256 _liquidationPrice) {\n', '        return(portfolio[_address][_marketId].liquidationPrice);\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Record positions by market by address. Needed for exposure aggregations\n', '    // and spits and dividends.\n', '    // ----------------------------------------------------------------------------\n', '    function addExposureByMarket(bytes32 _symbol, address _address) private {\n', '        // Address must not be already recored\n', '        uint256 _myExposureIndex = getExposureMappingIndex(_symbol, _address);\n', '        if (_myExposureIndex == 0) {\n', '            uint256 _maxMappingIndex = getMaxMappingIndex(_symbol).add(1);\n', '            setMaxMappingIndex(_symbol, _maxMappingIndex);\n', '            setExposureMapping(_symbol, _address, _maxMappingIndex);\n', '        }\n', '    }\n', '\n', '    function deleteExposureByMarket(bytes32 _symbol, address _address) private {\n', '        // Get my index in mapping\n', '        uint256 _myExposureIndex = getExposureMappingIndex(_symbol, _address);\n', '        // Get last element of mapping\n', '        uint256 _lastIndex = getMaxMappingIndex(_symbol);\n', '        address _lastAddress = getExposureMappingAddress(_symbol, _lastIndex);\n', '        // If _myExposureIndex is greater than 0 (i.e. there is an exposure of that address on that market) delete it\n', '        if (_myExposureIndex > 0) {\n', '            // If _myExposureIndex is less than _lastIndex overwrite element at _myExposureIndex with element at _lastIndex in\n', '            // deleted elements position.\n', '            if (_myExposureIndex < _lastIndex) {\n', '                setExposureMappingAddress(_symbol, _lastAddress, _myExposureIndex);\n', '                setExposureMappingIndex(_symbol, _lastAddress, _myExposureIndex);\n', '            }\n', '            // Delete _lastIndex and _lastAddress element and reduce maxExposureIndex\n', '            setExposureMappingAddress(_symbol, address(0), _lastIndex);\n', '            setExposureMappingIndex(_symbol, _address, 0);\n', "            // Shouldn't happen, but check that not empty\n", '            if (_lastIndex > 0) {\n', '                setMaxMappingIndex(_symbol, _lastIndex.sub(1));\n', '            }\n', '        }\n', '    }\n', '\n', '    // ----------------------------------------------------------------------------\n', '    // Calculate and send operating reward\n', '    // Every 24 hours the protocol mints rewardBasisPoints/(PRECISION) percent of the total\n', '    // supply as reward for the protocol operator. The amount can not exceed 0.015% per\n', '    // day.\n', '    // ----------------------------------------------------------------------------\n', '\n', '    function payOperatingReward() public onlyMainChain {\n', '        if (now > lastRewardTime.add(REWARDPERIOD)) {\n', '            uint256 _reward = totalSupply.mul(rewardBasisPoints).div(PRECISION);\n', '            setLastRewardTime(lastRewardTime.add(REWARDPERIOD));\n', '            mint(morpherRewards, _reward);\n', '            emit OperatingRewardMinted(morpherRewards, _reward);\n', '        }\n', '    }\n', '}']