['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.4;\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a <= b ? a : b;\n', '    }\n', '\n', '    function abs(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a < b) {\n', '            return b - a;\n', '        }\n', '        return a - b;\n', '    }\n', '}\n', '\n', 'contract InterestRateModel {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public constant blocksPerYear = 2102400;\n', '\n', '    uint256 public multiplierPerBlock;\n', '\n', '    uint256 public baseRatePerBlock;\n', '\n', '    constructor(uint256 baseRatePerYear, uint256 multiplierPerYear) public {\n', '        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n', '        multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\n', '    }\n', '\n', '    // 计算利用率\n', '    function utilizationRate(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves\n', '    ) public pure returns (uint256) {\n', '        if (borrows == 0) {\n', '            return 0;\n', '        }\n', '\n', '        // borrows/(cash + borrows)\n', '        return borrows.mul(1e18).div(cash.add(borrows));\n', '    }\n', '\n', '    // 借款利率\n', '    function getBorrowRate(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves\n', '    ) public view returns (uint256) {\n', '        uint256 ur = utilizationRate(cash, borrows, reserves);\n', '        return ur.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n', '    }\n', '\n', '    // 存款利率\n', '    function getSupplyRate(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves,\n', '        uint256 reserveFactorMantissa\n', '    ) public view returns (uint256) {\n', '        uint256 oneMinusReserveFactor = uint256(1e18).sub(\n', '            reserveFactorMantissa\n', '        );\n', '        uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n', '        uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n', '        return\n', '            utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n', '    }\n', '\n', '    function APR(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves\n', '    ) external view returns (uint256) {\n', '        return getBorrowRate(cash, borrows, reserves).mul(blocksPerYear);\n', '    }\n', '\n', '    function APY(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves,\n', '        uint256 reserveFactorMantissa\n', '    ) external view returns (uint256) {\n', '        return\n', '            getSupplyRate(cash, borrows, reserves, reserveFactorMantissa).mul(\n', '                blocksPerYear\n', '            );\n', '    }\n', '}']