['pragma solidity ^0.6.12;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', 'interface PermittedAddressesInterface {\n', '  function permittedAddresses(address _address) external view returns(bool);\n', '  function addressesTypes(address _address) external view returns(string memory);\n', '  function isMatchTypes(address _address, uint256 addressType) external view returns(bool);\n', '}\n', 'interface ICoTraderGlobalConfig {\n', '  function MAX_TOKENS() external view returns(uint256);\n', '\n', '  function TRADE_FREEZE_TIME() external view returns(uint256);\n', '\n', '  function DW_FREEZE_TIME() external view returns(uint256);\n', '\n', '  function PLATFORM_ADDRESS() external view returns(address);\n', '}\n', 'interface IFundValueOracle {\n', '  function requestValue(address _fundAddress, uint256 _fee) external payable returns (bytes32 requestId);\n', '  function getFundValueByID(bytes32 _requestId) external view returns(uint256 value);\n', '  function fee() external returns(uint256);\n', '}\n', 'interface DefiPortalInterface {\n', '  function callPayableProtocol(\n', '    address[] memory tokensToSend,\n', '    uint256[] memory amountsToSend,\n', '    bytes calldata _additionalData,\n', '    bytes32[] calldata _additionalArgs\n', '  )\n', '    external\n', '    payable\n', '    returns(\n', '      string memory eventType,\n', '      address[] memory tokensToReceive,\n', '      uint256[] memory amountsToReceive\n', '    );\n', '\n', '  function callNonPayableProtocol(\n', '    address[] memory tokensToSend,\n', '    uint256[] memory amountsToSend,\n', '    bytes calldata _additionalData,\n', '    bytes32[] calldata _additionalArgs\n', '  )\n', '    external\n', '    returns(\n', '      string memory eventType,\n', '      address[] memory tokensToReceive,\n', '      uint256[] memory amountsToReceive\n', '    );\n', '}\n', '\n', '\n', 'interface PoolPortalInterface {\n', '  function buyPool\n', '  (\n', '    uint256 _amount,\n', '    uint _type,\n', '    address _poolToken,\n', '    address[] calldata _connectorsAddress,\n', '    uint256[] calldata _connectorsAmount,\n', '    bytes32[] calldata _additionalArgs,\n', '    bytes calldata _additionalData\n', '  )\n', '  external\n', '  payable\n', '  returns(uint256 poolAmountReceive, uint256[] memory connectorsSpended);\n', '\n', '  function sellPool\n', '  (\n', '    uint256 _amount,\n', '    uint _type,\n', '    IERC20 _poolToken,\n', '    bytes32[] calldata _additionalArgs,\n', '    bytes calldata _additionData\n', '  )\n', '  external\n', '  payable\n', '  returns(\n', '    address[] memory connectorsAddress,\n', '    uint256[] memory connectorsAmount\n', '  );\n', '}\n', '\n', '\n', '// interface for fund contract\n', 'interface IExchangePortal {\n', '  function trade(\n', '    IERC20 _source,\n', '    uint256 _sourceAmount,\n', '    IERC20 _destination,\n', '    uint256 _type,\n', '    bytes32[] calldata _proof,\n', '    uint256[] calldata _positions,\n', '    bytes calldata _additionalData,\n', '    bool _verifyDestanation\n', '  )\n', '    external\n', '    payable\n', '    returns (uint256);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '  The SmartFund contract is what holds all the tokens and ether, and contains all the logic\n', '  for calculating its value (and ergo profit), allows users to deposit/withdraw their funds,\n', '  and calculates the fund managers cut of the funds profit among other things.\n', '  The SmartFund gets the value of its token holdings (in Ether) and trades through the ExchangePortal\n', '  contract. This means that as new exchange capabalities are added to new exchange portals, the\n', '  SmartFund will be able to upgrade to a new exchange portal, and trade a wider variety of assets\n', '  with a wider variety of exchanges. The SmartFund is also connected to a permittedAddresses contract,\n', '  which determines which exchange, pool, defi portals the SmartFund is allowed to connect to, restricting\n', '  the fund owners ability to connect to a potentially malicious contract.\n', '\n', '  In additional this contract can use pools and defi protocols voa pool and defi portals.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'abstract contract SmartFundCore is Ownable, IERC20 {\n', '  using SafeMath for uint256;\n', '  using SafeERC20 for IERC20;\n', '\n', '  // Fund type\n', '  bool public isLightFund = false;\n', '\n', '  // Total amount of ether or stable deposited by all users\n', '  uint256 public totalWeiDeposited;\n', '\n', '  // Total amount of ether or stable withdrawn by all users\n', '  uint256 public totalWeiWithdrawn;\n', '\n', '  // The Interface of the Exchange Portal\n', '  IExchangePortal public exchangePortal;\n', '\n', '  // The Interface of pool portall\n', '  PoolPortalInterface public poolPortal;\n', '\n', '  // The interface of DefiPortal\n', '  DefiPortalInterface public defiPortal;\n', '\n', '  // The Smart Contract which stores the addresses of all the authorized Exchange Portals\n', '  PermittedAddressesInterface public permittedAddresses;\n', '\n', '  // portals recognizes ETH by this address\n', '  IERC20 constant internal ETH_TOKEN_ADDRESS = IERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '\n', '  // For ERC20 compliance\n', '  string public name;\n', '\n', '  // Percentages are rounded to 3 decimal places\n', '  uint256 public TOTAL_PERCENTAGE = 10000;\n', '\n', '  // The percentage of earnings paid to the fund manager. 10000 = 100%\n', '  // e.g. 10% is 1000\n', '  uint256 public successFee;\n', '\n', '  // The percentage of fund manager earnings paid to the platform. 10000 = 100%\n', '  // e.g. 10% is 1000\n', '  uint256 public platformFee;\n', '\n', '  // An array of all the erc20 token addresses the smart fund holds\n', '  address[] public tokenAddresses;\n', '\n', '  // Boolean value that determines whether the fund accepts deposits from anyone or\n', '  // only specific addresses approved by the manager\n', '  bool public onlyWhitelist;\n', '\n', "  // Mapping of addresses that are approved to deposit if the manager only want's specific\n", '  // addresses to be able to invest in their fund\n', '  mapping (address => bool) public whitelist;\n', '\n', '  uint public version = 8;\n', '\n', '  // the total number of shares in the fund\n', '  uint256 public totalShares;\n', '\n', '  // Denomination of initial shares\n', '  uint256 constant internal INITIAL_SHARES = 10 ** 18;\n', '\n', '  // The earnings the fund manager has already cashed out\n', '  uint256 public fundManagerCashedOut;\n', '\n', '  // for ETH and USD fund this asset different\n', '  address public coreFundAsset;\n', '\n', '  // If true the contract will require each new asset to buy to be on a special Merkle tree list\n', '  bool public isRequireTradeVerification;\n', '\n', '  // Oracle contract instance\n', '  IFundValueOracle public fundValueOracle;\n', '\n', '  // Data for Oracle updates\n', '  bytes32 public latestOracleRequestID;\n', '  uint256 public latestOracleCallOnTime;\n', '  uint256 public latestOracleCallOnBlock;\n', '  address public latestOracleCaller;\n', '\n', '  // CoTrader platform config\n', '  ICoTraderGlobalConfig public cotraderGlobalConfig;\n', '\n', '  // how many shares belong to each address\n', '  mapping (address => uint256) public addressToShares;\n', '\n', "  // so that we can easily check that we don't add duplicates to our array\n", '  mapping (address => bool) public tokensTraded;\n', '\n', '  // this is really only being used to more easily show profits, but may not be necessary\n', '  // if we do a lot of this offchain using events to track everything\n', '  // total `depositToken` deposited - total `depositToken` withdrawn\n', '  mapping (address => int256) public addressesNetDeposit;\n', '\n', '  // Events\n', '  event DefiCall(\n', '    string eventType,\n', '    address[] tokensToSend,\n', '    uint256[] amountsToSend,\n', '    address[] tokensToReceive,\n', '    uint256[] amountsToReceive\n', '    );\n', '\n', '  event BuyPool(\n', '    address poolAddress,\n', '    uint256 poolAmount,\n', '    address[] connectorsAddress,\n', '    uint256[] connectorsAmount);\n', '\n', '  event SellPool(\n', '    address poolAddress,\n', '    uint256 poolAmount,\n', '    address[] connectorsAddress,\n', '    uint256[] connectorsAmount);\n', '\n', '  event Deposit(address indexed user, uint256 amount, uint256 sharesReceived, uint256 totalShares);\n', '  event Withdraw(address indexed user, uint256 sharesRemoved, uint256 totalShares);\n', '  event Trade(address src, uint256 srcAmount, address dest, uint256 destReceived);\n', '  event SmartFundCreated(address indexed owner);\n', '  event OracleUpdate(address caller, uint256 triggerTime, bytes32 id);\n', '\n', '\n', '  constructor(\n', '    address _owner,\n', '    string memory _name,\n', '    uint256 _successFee,\n', '    address _exchangePortalAddress,\n', '    address _poolPortalAddress,\n', '    address _defiPortal,\n', '    address _permittedAddresses,\n', '    address _coreFundAsset,\n', '    address _fundValueOracle,\n', '    bool    _isRequireTradeVerification,\n', '    address _cotraderGlobalConfig\n', '  )public{\n', '    // never allow a 100% fee\n', '    require(_successFee < TOTAL_PERCENTAGE);\n', '\n', '    name = _name;\n', '    successFee = _successFee;\n', '    platformFee = _successFee; // platform fee the same as manager fee\n', '\n', '    // Init manager\n', '    if(_owner == address(0)){\n', '      transferOwnership(msg.sender);\n', '    }\n', '    else{\n', '      transferOwnership(_owner);\n', '    }\n', '\n', '    // Initial Token is Ether\n', '    tokenAddresses.push(address(ETH_TOKEN_ADDRESS));\n', '\n', '    // Initial interfaces\n', '    exchangePortal = IExchangePortal(_exchangePortalAddress);\n', '    poolPortal = PoolPortalInterface(_poolPortalAddress);\n', '    defiPortal = DefiPortalInterface(_defiPortal);\n', '    permittedAddresses = PermittedAddressesInterface(_permittedAddresses);\n', '\n', '    // Initial core assets\n', '    coreFundAsset = _coreFundAsset;\n', '\n', '    // Initial fund Oracle\n', '    fundValueOracle = IFundValueOracle(_fundValueOracle);\n', '\n', '    // Initial check if fund require trade verification or not\n', '    isRequireTradeVerification = _isRequireTradeVerification;\n', '\n', '    // Initial platform config\n', '    cotraderGlobalConfig = ICoTraderGlobalConfig(_cotraderGlobalConfig);\n', '\n', '    emit SmartFundCreated(owner());\n', '  }\n', '\n', '  // Modifiers\n', '  // We use function instead modifiers because modifiers require more bytes\n', '\n', '  // Not allow trade while user do deposit or withdraw\n', '  function verifyTradeBetweenDW() internal view {\n', '    require(\n', '        now >= latestOracleCallOnTime + cotraderGlobalConfig.TRADE_FREEZE_TIME(),\n', '        "FREEZE_FOR_UPDATE_PRICE"\n', '     );\n', '  }\n', '\n', '  // not allow call user B (for a freeze minutes) if user A not finished operation\n', '  // allow call any user for a first deposit\n', '  function verifyDWSender() internal view {\n', '    if(totalShares > 0){\n', '      if(latestOracleCallOnTime + cotraderGlobalConfig.TRADE_FREEZE_TIME() >= now){\n', '        require(msg.sender == latestOracleCaller, "NOT_LATEST_ORACLE_CALLER");\n', '      }\n', '      else{\n', '        revert("ORACLE_TIME_EXPIRED");\n', '      }\n', '    }\n', '  }\n', '\n', '  // allow update oracle price\n', "  // _oracleTokenAddress it's fee token address\n", '  function updateFundValueFromOracle(address _oracleTokenAddress, uint256 _oracleFee) public payable {\n', '    // allow call Oracle only after a certain time\n', '    require(now >= latestOracleCallOnTime + cotraderGlobalConfig.DW_FREEZE_TIME(), "DW_FREEZE");\n', '\n', '    // pay for using Oracle with ETH\n', '    if(_oracleTokenAddress == address(ETH_TOKEN_ADDRESS)){\n', '      require(msg.value == _oracleFee, "REQUIRE_ETH");\n', '      // call oracle\n', '      latestOracleRequestID = fundValueOracle.requestValue.value(_oracleFee)(address(this), _oracleFee);\n', '    }\n', '    // for using Oracle with ERC20\n', '    else{\n', '      require(msg.value == 0, "NO_NEED_ETH");\n', '      // transfer oracle token from sender and approve to oracle portal\n', '      _transferFromSenderAndApproveTo(IERC20(_oracleTokenAddress), _oracleFee, address(fundValueOracle));\n', '      // call oracle\n', '      latestOracleRequestID = fundValueOracle.requestValue(address(this), _oracleFee);\n', '    }\n', '\n', '    // update data\n', '    latestOracleCallOnTime = now;\n', '    latestOracleCallOnBlock = block.number;\n', '    latestOracleCaller = msg.sender;\n', '\n', '    // emit events\n', '    emit OracleUpdate(latestOracleCaller, latestOracleCallOnTime, latestOracleRequestID);\n', '  }\n', '\n', '  // core function for calculate deposit and withdraw and managerWithdraw\n', '  // return data from Oracle\n', '  function calculateFundValue() public view returns (uint256) {\n', '    // return latest data from Oracle\n', '    return fundValueOracle.getFundValueByID(latestOracleRequestID);\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev Sends (_mul/_div) of every token (and ether) the funds holds to _withdrawAddress\n', '  *\n', '  * @param _mul                The numerator\n', '  * @param _div                The denominator\n', '  * @param _withdrawAddress    Address to send the tokens/ether to\n', '  *\n', '  * NOTE: _withdrawAddress changed from address to address[] arrays because balance calculation should be performed\n', '  * once for all usesr who wants to withdraw from the current balance.\n', '  *\n', '  */\n', '  function _withdraw(\n', '    uint256[] memory _mul,\n', '    uint256[] memory _div,\n', '    address[] memory _withdrawAddress\n', '    )\n', '    internal\n', '    returns (uint256)\n', '  {\n', '    for (uint8 i = 1; i < tokenAddresses.length; i++) {\n', '      // Transfer that _mul/_div of each token we hold to the user\n', '      IERC20 token = IERC20(tokenAddresses[i]);\n', '      uint256 fundAmount = token.balanceOf(address(this));\n', '\n', '      // Transfer ERC20 to _withdrawAddress\n', '      for(uint8 j = 0; j < _withdrawAddress.length; j++){\n', '        // calculate withdraw ERC20 share\n', '        uint256 payoutAmount = fundAmount.mul(_mul[j]).div(_div[j]);\n', '        if(payoutAmount > 0)\n', '          token.transfer(_withdrawAddress[j], payoutAmount);\n', '      }\n', '    }\n', '    // Transfer ETH to _withdrawAddress\n', '    uint256 etherBalance = address(this).balance;\n', '    for(uint8 k = 0; k < _withdrawAddress.length; k++){\n', '      // calculate withdraw ETH share\n', '      uint256 etherPayoutAmount = (etherBalance).mul(_mul[k]).div(_div[k]);\n', '      if(etherPayoutAmount > 0)\n', '        payable(_withdrawAddress[k]).transfer(etherPayoutAmount);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @dev Withdraws users fund holdings, sends (userShares/totalShares) of every held token\n', '  * to msg.sender, defaults to 100% of users shares.\n', '  *\n', '  * @param _percentageWithdraw    The percentage of the users shares to withdraw.\n', '  */\n', '  function withdraw(uint256 _percentageWithdraw) external {\n', '    verifyDWSender();\n', '    require(totalShares != 0, "EMPTY_SHARES");\n', '    require(_percentageWithdraw <= TOTAL_PERCENTAGE, "WRONG_PERCENT");\n', '\n', '    uint256 percentageWithdraw = (_percentageWithdraw == 0) ? TOTAL_PERCENTAGE : _percentageWithdraw;\n', '\n', '    uint256 addressShares = addressToShares[msg.sender];\n', '\n', '    uint256 numberOfWithdrawShares = addressShares.mul(percentageWithdraw).div(TOTAL_PERCENTAGE);\n', '\n', '    uint256 fundManagerCut;\n', '    uint256 fundValue;\n', '\n', "    // Withdraw the users share minus the fund manager's success fee\n", '    (fundManagerCut, fundValue, ) = calculateFundManagerCut();\n', '\n', '    // reset latest Oracle Caller for protect from double call\n', '    latestOracleCaller = address(0);\n', '\n', '    uint256 withdrawShares = numberOfWithdrawShares.mul(fundValue.sub(fundManagerCut)).div(fundValue);\n', '\n', '    // prepare call data for _withdarw\n', '    address[] memory spenders = new address[](1);\n', '    spenders[0] = msg.sender;\n', '\n', '    uint256[] memory value = new uint256[](1);\n', '    value[0] = totalShares;\n', '\n', '    uint256[] memory cut = new uint256[](1);\n', '    cut[0] = withdrawShares;\n', '\n', '    // do withdraw\n', '    _withdraw(cut, value, spenders);\n', '\n', '    // Store the value we are withdrawing in ether\n', '    uint256 valueWithdrawn = fundValue.mul(withdrawShares).div(totalShares);\n', '\n', '    totalWeiWithdrawn = totalWeiWithdrawn.add(valueWithdrawn);\n', '    addressesNetDeposit[msg.sender] -= int256(valueWithdrawn);\n', '\n', '    // Subtract from total shares the number of withdrawn shares\n', '    totalShares = totalShares.sub(numberOfWithdrawShares);\n', '    addressToShares[msg.sender] = addressToShares[msg.sender].sub(numberOfWithdrawShares);\n', '\n', '    emit Withdraw(msg.sender, numberOfWithdrawShares, totalShares);\n', '  }\n', '\n', '  /**\n', '  * @dev Facilitates a trade of the funds holdings via the exchange portal\n', '  *\n', '  * @param _source            ERC20 token to convert from\n', '  * @param _sourceAmount      Amount to convert (in _source token)\n', '  * @param _destination       ERC20 token to convert to\n', '  * @param _type              The type of exchange to trade with\n', '  * @param _proof             Merkle tree proof (if not used just set [])\n', '  * @param _positions         Merkle tree positions (if not used just set [])\n', '  * @param _additionalData    For additional data (if not used just set "0x0")\n', '  * @param _minReturn         Min expected amount of destination\n', '  */\n', '  function trade(\n', '    IERC20 _source,\n', '    uint256 _sourceAmount,\n', '    IERC20 _destination,\n', '    uint256 _type,\n', '    bytes32[] calldata _proof,\n', '    uint256[] calldata _positions,\n', '    bytes calldata _additionalData,\n', '    uint256 _minReturn\n', '  )\n', '   external\n', '   onlyOwner\n', '  {\n', '    verifyTradeBetweenDW();\n', '\n', '    require(_minReturn > 0, "MIN_RETURN_0");\n', '\n', '    uint256 receivedAmount;\n', '\n', '    if (_source == ETH_TOKEN_ADDRESS) {\n', '      // Make sure fund contains enough ether\n', '      require(address(this).balance >= _sourceAmount, "NOT_ENOUGH_ETH");\n', '      // Call trade on ExchangePortal along with ether\n', '      receivedAmount = exchangePortal.trade.value(_sourceAmount)(\n', '        _source,\n', '        _sourceAmount,\n', '        _destination,\n', '        _type,\n', '        _proof,\n', '        _positions,\n', '        _additionalData,\n', '        isRequireTradeVerification\n', '      );\n', '    } else {\n', '      _source.approve(address(exchangePortal), _sourceAmount);\n', '      receivedAmount = exchangePortal.trade(\n', '        _source,\n', '        _sourceAmount,\n', '        _destination,\n', '        _type,\n', '        _proof,\n', '        _positions,\n', '        _additionalData,\n', '        isRequireTradeVerification\n', '      );\n', '    }\n', '\n', '    // make sure fund recive destanation\n', '    require(receivedAmount >= _minReturn, "RECEIVED_LESS_THAN_MIN");\n', '\n', '    // add token to trader list\n', '    _addToken(address(_destination));\n', '\n', '    // emit event\n', '    emit Trade(\n', '      address(_source),\n', '      _sourceAmount,\n', '      address(_destination),\n', '      receivedAmount);\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev buy pool via pool portal\n', '  *\n', "  * @param _amount             For Bancor amount it's relay, for Uniswap amount it's ETH, for Bancor and Uniswap v2 can be 0\n", '  * @param _type               type of pool (0 - Bancor, 1 - Uniswap)\n', '  * @param _poolToken          address of relay for Bancor and exchange for Uniswap\n', '  * @param _connectorsAddress  address of pool connectors\n', '  * @param _connectorsAmount   amount of pool connectors\n', '  * @param _additionalArgs     bytes32 array for case if need pass some extra params, can be empty\n', '  * @param _additionData       for provide any additional data, if not used just set "0x"\n', '  */\n', '  function buyPool(\n', '   uint256            _amount,\n', '   uint               _type,\n', '   address            _poolToken,\n', '   address[] calldata _connectorsAddress,\n', '   uint256[] memory   _connectorsAmount,  // WARNING: this array rewrite from buyPool return (details below)\n', '   bytes32[] calldata _additionalArgs,\n', '   bytes calldata     _additionData\n', '  )\n', '   external\n', '   onlyOwner\n', '  {\n', '   verifyTradeBetweenDW();\n', '   // for determine the exact number of received pool\n', '   uint256 poolAmountReceive;\n', '\n', '   // approve connectors\n', '   // etherAmount for detect ETH case\n', '   uint256 etherAmount = approveArrayOfTokensToSpender(\n', '     _connectorsAddress,\n', '     _connectorsAmount,\n', '     address(poolPortal)\n', '   );\n', '\n', '   // buy pool with ETH (payable case)\n', '   if(etherAmount > 0){\n', '     // WARNING: rewrire _connectorsAmount from return\n', '     // some pools can return some remains for connectors, and for get correct result,\n', '     // for connectors amount to spend for emit event\n', '     // poolPortal calculates and return exactly how many tokens were spent (total - remains),\n', "     // unfortunate due stack too deep issue, we can't declarate new variable\n", '     // so we rewrire _connectorsAmount\n', '    (poolAmountReceive, _connectorsAmount) = poolPortal.buyPool.value(etherAmount)(\n', '      _amount,\n', '      _type,\n', '     _poolToken,\n', '     _connectorsAddress,\n', '     _connectorsAmount,\n', '     _additionalArgs,\n', '     _additionData\n', '     );\n', '   }\n', '   // buy pool only with ERC20 (non payable case)\n', '   else{\n', '     // WARNING: rewrire _connectorsAmount from return\n', '     (poolAmountReceive, _connectorsAmount) = poolPortal.buyPool(\n', '      _amount,\n', '      _type,\n', '     _poolToken,\n', '     _connectorsAddress,\n', '     _connectorsAmount,\n', '     _additionalArgs,\n', '     _additionData\n', '     );\n', '   }\n', '   // make sure fund receive pool token\n', '   require(poolAmountReceive > 0, "EMPTY_POOL");\n', '   // Add pool as ERC20 for withdraw\n', '   _addToken(_poolToken);\n', '   // emit event\n', '   emit BuyPool(\n', '     _poolToken,\n', '     poolAmountReceive,\n', '     _connectorsAddress,\n', '     _connectorsAmount);\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev sell pool via pool portal\n', '  *\n', '  * @param _amount          amount of Bancor relay or Uniswap exchange to sell\n', '  * @param _type            type of pool (0 - Bancor, 1 - Uniswap)\n', '  * @param _poolToken       address of Bancor relay or Uniswap exchange\n', '  * @param _additionalArgs  bytes32 array for case if need pass some extra params, can be empty\n', '  * @param _additionData    for provide any additional data, if not used just set "0x"\n', '  */\n', '  function sellPool(\n', '    uint256 _amount,\n', '    uint _type,\n', '    IERC20 _poolToken,\n', '    bytes32[] calldata _additionalArgs,\n', '    bytes calldata _additionData\n', '  )\n', '   external\n', '   onlyOwner\n', '  {\n', '    verifyTradeBetweenDW();\n', '    // approve pool\n', '    _poolToken.approve(address(poolPortal), _amount);\n', '\n', '    // sell pool\n', '    (address[] memory connectorsAddress,\n', '     uint256[] memory connectorsAmount) = poolPortal.sellPool(\n', '      _amount,\n', '      _type,\n', '     _poolToken,\n', '     _additionalArgs,\n', '     _additionData\n', '    );\n', '\n', '    // Add connectors to fund\n', '    for(uint8 i = 0; i < connectorsAddress.length; i++){\n', '      _addToken(connectorsAddress[i]);\n', '    }\n', '\n', '    // event\n', '    emit SellPool(\n', '      address(_poolToken),\n', '      _amount,\n', '      connectorsAddress,\n', '      connectorsAmount);\n', '  }\n', '\n', '  /**\n', '  * @dev allow manager use newest DEFI protocols\n', "  * NOTE: all logic in DEFI portal hardcoded, and also fund manager can't update\n", '  * non permitted DEFI portal, so this is safe call\n', '  *\n', '\n', '  * @param _additionalData               params data packed in bytes\n', '  * @param _additionalArgs      additional params array for quick unpack\n', '\n', '  */\n', '  function callDefiPortal(\n', '    address[] memory tokensToSend,\n', '    uint256[] memory amountsToSend,\n', '    bytes32[] calldata _additionalArgs,\n', '    bytes calldata _additionalData\n', '  )\n', '    external\n', '    onlyOwner\n', '  {\n', '    verifyTradeBetweenDW();\n', '    // event data\n', '    string memory eventType;\n', '    address[] memory tokensToReceive;\n', '    uint256[] memory amountsToReceive;\n', '\n', '    // approve connectors\n', '    // etherAmount for detect ETH case\n', '    uint256 etherAmount = approveArrayOfTokensToSpender(\n', '      tokensToSend,\n', '      amountsToSend,\n', '      address(defiPortal)\n', '    );\n', '\n', '    // call defi payable case\n', '    if(etherAmount > 0){\n', '      (eventType,\n', '       tokensToReceive,\n', '       amountsToReceive) = defiPortal.callPayableProtocol.value(etherAmount)(\n', '         tokensToSend,\n', '         amountsToSend,\n', '         _additionalData,\n', '         _additionalArgs\n', '        );\n', '    }\n', '    // call defi not payable case\n', '    else{\n', '      (eventType,\n', '       tokensToReceive,\n', '       amountsToReceive) = defiPortal.callNonPayableProtocol(\n', '         tokensToSend,\n', '         amountsToSend,\n', '         _additionalData,\n', '         _additionalArgs\n', '        );\n', '    }\n', '\n', '   // add new tokens in fund\n', '   for(uint8 i = 0; i < tokensToReceive.length; i++){\n', '     _addToken(tokensToReceive[i]);\n', '   }\n', '\n', '   // emit event\n', '    emit DefiCall(\n', '      eventType,\n', '      tokensToSend,\n', '      amountsToSend,\n', '      tokensToReceive,\n', '      amountsToReceive\n', '    );\n', '  }\n', '\n', '\n', '  // pivate helper for approve arary of tokens\n', '  // spender can be Pool or Defi portals\n', '  function approveArrayOfTokensToSpender(\n', '    address[] memory addresses,\n', '    uint256[] memory amounts,\n', '    address spender\n', '  )\n', '    private\n', '    returns (uint256 etherAmount)\n', '  {\n', '    for(uint8 i = 0; i < addresses.length; i++){\n', '      if(addresses[i] != address(ETH_TOKEN_ADDRESS)){\n', '        // approve\n', '        IERC20(addresses[i]).approve(spender, amounts[i]);\n', '      }\n', '      else{\n', '        etherAmount = amounts[i];\n', '      }\n', '    }\n', '  }\n', '\n', '\n', '  // return all tokens addresses from fund\n', '  function getAllTokenAddresses() external view returns (address[] memory) {\n', '    return tokenAddresses;\n', '  }\n', '\n', '  /**\n', "  * @dev Adds a token to tokensTraded if it's not already there\n", '  * @param _token    The token to add\n', '  */\n', '  function _addToken(address _token) internal {\n', "    // don't add token to if we already have it in our list\n", '    if (tokensTraded[_token] || (_token == address(ETH_TOKEN_ADDRESS)))\n', '      return;\n', '\n', '    tokensTraded[_token] = true;\n', '    tokenAddresses.push(_token);\n', '    uint256 tokenCount = tokenAddresses.length;\n', '\n', "    // we can't hold more than MAX_TOKENS tokens\n", '    require(tokenCount <= cotraderGlobalConfig.MAX_TOKENS(), "MAX_TOKENS");\n', '  }\n', '\n', '  /**\n', '  * @dev Removes a token from tokensTraded\n', '  *\n', '  * @param _token         The address of the token to be removed\n', '  * @param _tokenIndex    The index of the token to be removed\n', '  *\n', '  */\n', '  function removeToken(address _token, uint256 _tokenIndex) public onlyOwner {\n', '    require(_token != address(ETH_TOKEN_ADDRESS));\n', '    require(tokensTraded[_token]);\n', '    require(IERC20(_token).balanceOf(address(this)) == 0);\n', '    require(tokenAddresses[_tokenIndex] == _token);\n', '\n', '    tokensTraded[_token] = false;\n', '\n', '    // remove token from array\n', '    uint256 arrayLength = tokenAddresses.length - 1;\n', '    tokenAddresses[_tokenIndex] = tokenAddresses[arrayLength];\n', '    delete tokenAddresses[arrayLength];\n', '    tokenAddresses.pop();\n', '  }\n', '\n', '  /**\n', '  * @dev Calculates the amount of shares received according to ether deposited\n', '  *\n', '  * @param _amount    Amount of ether to convert to shares\n', '  *\n', '  * @return Amount of shares to be received\n', '  */\n', '  function calculateDepositToShares(uint256 _amount) internal view returns (uint256) {\n', '    uint256 fundManagerCut;\n', '    uint256 fundValue;\n', '\n', '    // If there are no shares in the contract, whoever deposits owns 100% of the fund\n', '    // we will set this to 10^18 shares, but this could be any amount\n', '    if (totalShares == 0)\n', '      return INITIAL_SHARES;\n', '\n', '    (fundManagerCut, fundValue, ) = calculateFundManagerCut();\n', '\n', '    uint256 fundValueBeforeDeposit = fundValue.sub(fundManagerCut);\n', '\n', '    if (fundValueBeforeDeposit == 0)\n', '      return 0;\n', '\n', '    return _amount.mul(totalShares).div(fundValueBeforeDeposit);\n', '\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev Calculates the fund managers cut, depending on the funds profit and success fee\n', '  *\n', '  * @return fundManagerRemainingCut    The fund managers cut that they have left to withdraw\n', '  * @return fundValue                  The funds current value\n', '  * @return fundManagerTotalCut        The fund managers total cut of the profits until now\n', '  */\n', '  function calculateFundManagerCut() public view returns (\n', "    uint256 fundManagerRemainingCut, // fm's cut of the profits that has yet to be cashed out (in `depositToken`)\n", '    uint256 fundValue, // total value of fund (in `depositToken`)\n', "    uint256 fundManagerTotalCut // fm's total cut of the profits (in `depositToken`)\n", '  ) {\n', '    fundValue = calculateFundValue();\n', '    // The total amount of ether currently deposited into the fund, takes into account the total ether\n', '    // withdrawn by investors as well as ether withdrawn by the fund manager\n', '    // NOTE: value can be negative if the manager performs well and investors withdraw more\n', '    // ether than they deposited\n', '    int256 curtotalWeiDeposited = int256(totalWeiDeposited) - int256(totalWeiWithdrawn.add(fundManagerCashedOut));\n', '\n', '    // If profit < 0, the fund managers totalCut and remainingCut are 0\n', '    if (int256(fundValue) <= curtotalWeiDeposited) {\n', '      fundManagerTotalCut = 0;\n', '      fundManagerRemainingCut = 0;\n', '    } else {\n', '      // calculate profit. profit = current fund value - total deposited + total withdrawn + total withdrawn by fm\n', '      uint256 profit = uint256(int256(fundValue) - curtotalWeiDeposited);\n', '      // remove the money already taken by the fund manager and take percentage\n', '      fundManagerTotalCut = profit.mul(successFee).div(TOTAL_PERCENTAGE);\n', '      fundManagerRemainingCut = fundManagerTotalCut.sub(fundManagerCashedOut);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @dev Allows the fund manager to withdraw their cut of the funds profit\n', '  */\n', '  function fundManagerWithdraw() external onlyOwner {\n', '    verifyDWSender();\n', '    uint256 fundManagerCut;\n', '    uint256 fundValue;\n', '\n', '    (fundManagerCut, fundValue, ) = calculateFundManagerCut();\n', '\n', '    uint256 platformCut = (platformFee == 0) ? 0 : fundManagerCut.mul(platformFee).div(TOTAL_PERCENTAGE);\n', '\n', '    // prepare call data for _withdarw\n', '    address[] memory spenders = new address[](2);\n', '    spenders[0] = cotraderGlobalConfig.PLATFORM_ADDRESS();\n', '    spenders[1] = owner();\n', '\n', '    uint256[] memory value = new uint256[](2);\n', '    value[0] = fundValue;\n', '    value[1] = fundValue;\n', '\n', '    uint256[] memory cut = new uint256[](2);\n', '    cut[0] = platformCut;\n', '    cut[1] = fundManagerCut - platformCut;\n', '\n', '    // do withdraw\n', '    _withdraw(cut, value, spenders);\n', '\n', '    // add report\n', '    fundManagerCashedOut = fundManagerCashedOut.add(fundManagerCut);\n', '  }\n', '\n', '  /**\n', '  * @dev Allows the manager to set whether or not only whitelisted addresses can deposit into\n', '  * their fund\n', '  *\n', '  * @param _onlyWhitelist    boolean representing whether only whitelisted addresses can deposit\n', '  */\n', '  function setWhitelistOnly(bool _onlyWhitelist) external onlyOwner {\n', '    onlyWhitelist = _onlyWhitelist;\n', '  }\n', '\n', '  /**\n', '  * @dev Allows the fund manager to whitelist specific addresses to control\n', '  * whos allowed to deposit into the fund\n', '  *\n', '  * @param _user       The user address to whitelist\n', '  * @param _allowed    The status of _user, true means allowed to deposit, false means not allowed\n', '  */\n', '  function setWhitelistAddress(address _user, bool _allowed) external onlyOwner {\n', '    whitelist[_user] = _allowed;\n', '  }\n', '\n', '  /**\n', '  * @dev Allows the fund manager to connect to a new permitted exchange portal\n', '  *\n', '  * @param _newExchangePortalAddress    The address of the new permitted exchange portal to use\n', '  */\n', '  function setNewExchangePortal(address _newExchangePortalAddress) public onlyOwner {\n', '    // Require correct permitted address type\n', '    require(permittedAddresses.isMatchTypes(_newExchangePortalAddress, 1), "WRONG_ADDRESS");\n', '    // Set new\n', '    exchangePortal = IExchangePortal(_newExchangePortalAddress);\n', '  }\n', '\n', '  /**\n', '  * @dev Allows the fund manager to connect to a new permitted poolPortal\n', '  *\n', '  * @param _newPoolPortal   The address of the new permitted pool portal to use\n', '  */\n', '  function setNewPoolPortal(address _newPoolPortal) public onlyOwner {\n', '    // Require correct permitted address type\n', '    require(permittedAddresses.isMatchTypes(_newPoolPortal, 2), "WRONG_ADDRESS");\n', '    // Set new\n', '    poolPortal = PoolPortalInterface(_newPoolPortal);\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev Allows the fund manager to connect to a new permitted defi portal\n', '  *\n', '  * @param _newDefiPortalAddress    The address of the new permitted defi portal to use\n', '  */\n', '  function setNewDefiPortal(address _newDefiPortalAddress) public onlyOwner {\n', '    // Require correct permitted address type\n', '    require(permittedAddresses.isMatchTypes(_newDefiPortalAddress, 3), "WRONG_ADDRESS");\n', '    // Set new\n', '    defiPortal = DefiPortalInterface(_newDefiPortalAddress);\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev Allows the fund manager to connect to a new Oracle\n', '  *\n', '  * @param _newOracle    address of new fund value Oracle contract\n', '  */\n', '  function setNewFundValueOracle(address _newOracle) public onlyOwner {\n', '    // Require permitted Oracle\n', '    require(permittedAddresses.isMatchTypes(_newOracle, 5), "WRONG_ADDRESS");\n', '    // Set new\n', '    fundValueOracle = IFundValueOracle(_newOracle);\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev This method is present in the alpha testing phase in case for some reason there are funds\n', '  * left in the SmartFund after all shares were withdrawn\n', '  *\n', '  * @param _token    The address of the token to withdraw\n', '  */\n', '  function emergencyWithdraw(address _token) external onlyOwner {\n', '    require(totalShares == 0);\n', '    if (_token == address(ETH_TOKEN_ADDRESS)) {\n', '      msg.sender.transfer(address(this).balance);\n', '    } else {\n', '      IERC20(_token).transfer(msg.sender, IERC20(_token).balanceOf(address(this)));\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @dev Approve 0 for a certain address\n', '  *\n', '  * NOTE: Some ERC20 has no standard approve logic, and not allow do new approve\n', '  * if alredy approved.\n', '  *\n', '  * @param _token                   address of ERC20\n', '  * @param _spender                 address of spender\n', '  */\n', '  function resetApprove(address _token, address _spender) external onlyOwner {\n', '    IERC20(_token).approve(_spender, 0);\n', '  }\n', '\n', '  /**\n', '  * @dev Transfers tokens to this contract and approves them to another address\n', '  *\n', '  * @param _source          Token to transfer and approve\n', '  * @param _sourceAmount    The amount to transfer and approve (in _source token)\n', '  * @param _to              Address to approve to\n', '  */\n', '  function _transferFromSenderAndApproveTo(IERC20 _source, uint256 _sourceAmount, address _to) private {\n', '    _source.transferFrom(msg.sender, address(this), _sourceAmount);\n', '    // approve\n', '    _source.approve(_to, _sourceAmount);\n', '  }\n', '\n', '  // Fallback payable function in order to be able to receive ether from other contracts\n', '  fallback() external payable {}\n', '\n', '  /**\n', '    **************************** ERC20 Compliance ****************************\n', '  **/\n', '\n', '  // Note that addressesNetDeposit does not get updated when transferring shares, since\n', "  // this is used for updating off-chain data it doesn't affect the smart contract logic,\n", '  // but is an issue that currently exists\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  uint8 public decimals = 18;\n', '\n', '  string public symbol = "FND";\n', '\n', '  mapping (address => mapping (address => uint256)) internal allowed;\n', '\n', '  /**\n', '  * @dev Total number of shares in existence\n', '  */\n', '  function totalSupply() external override view returns (uint256) {\n', '    return totalShares;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  *\n', '  * @param _who    The address to query the the balance of.\n', '  *\n', '  * @return A uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _who) external override view returns (uint256) {\n', '    return addressToShares[_who];\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer shares for a specified address\n', '  *\n', '  * @param _to       The address to transfer to.\n', '  * @param _value    The amount to be transferred.\n', '  *\n', '  * @return true upon success\n', '  */\n', '  function transfer(address _to, uint256 _value) external override returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= addressToShares[msg.sender]);\n', '\n', '    addressToShares[msg.sender] = addressToShares[msg.sender].sub(_value);\n', '    addressToShares[_to] = addressToShares[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer shares from one address to another\n', '   *\n', '   * @param _from     The address which you want to send tokens from\n', '   * @param _to       The address which you want to transfer to\n', '   * @param _value    The amount of shares to be transferred\n', '   *\n', '   * @return true upon success\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) external override returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= addressToShares[_from]);\n', '    require(_value <= allowed[_from][msg.sender]);\n', '\n', '    addressToShares[_from] = addressToShares[_from].sub(_value);\n', '    addressToShares[_to] = addressToShares[_to].add(_value);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Approve the passed address to spend the specified amount of shares on behalf of msg.sender.\n', '   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   *\n', '   * @param _spender    The address which will spend the funds.\n', '   * @param _value      The amount of shares to be spent.\n', '   *\n', '   * @return true upon success\n', '   */\n', '  function approve(address _spender, uint256 _value) external override returns (bool) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of shares that an owner allowed to a spender.\n', '   *\n', '   * @param _owner      The address which owns the funds.\n', '   * @param _spender    The address which will spend the funds.\n', '   *\n', '   * @return A uint256 specifying the amount of shares still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) external override view returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/*\n', '  Note: this smart fund smart fund inherits SmartFundCore and make core operations like deposit,\n', '  calculate fund value etc in ERC20\n', '*/\n', 'contract SmartFundERC20 is SmartFundCore {\n', '  using SafeMath for uint256;\n', '  using SafeERC20 for IERC20;\n', '\n', '  // State for recognize if this fund stable asset based\n', '  bool public isStableCoinBasedFund;\n', '\n', '  /**\n', '  * @dev constructor\n', '  *\n', '  * @param _owner                        Address of the fund manager\n', '  * @param _name                         Name of the fund, required for DetailedERC20 compliance\n', '  * @param _successFee                   Percentage of profit that the fund manager receives\n', '  * @param _exchangePortalAddress        Address of initial exchange portal\n', '  * @param _poolPortalAddress            Address of initial pool portal\n', '  * @param _permittedAddresses           Address of permittedAddresses contract\n', '  * @param _fundValueOracle              Address of Oracle contract\n', '  * @param _isRequireTradeVerification   If true fund will require verification from Merkle White list for each new asset\n', '  * @param _cotraderGlobalConfig         Address of CoTrader global config\n', '  */\n', '  constructor(\n', '    address _owner,\n', '    string memory _name,\n', '    uint256 _successFee,\n', '    address _exchangePortalAddress,\n', '    address _poolPortalAddress,\n', '    address _defiPortal,\n', '    address _permittedAddresses,\n', '    address _coinAddress,\n', '    address _fundValueOracle,\n', '    bool    _isRequireTradeVerification,\n', '    address _cotraderGlobalConfig\n', '  )\n', '  SmartFundCore(\n', '    _owner,\n', '    _name,\n', '    _successFee,\n', '    _exchangePortalAddress,\n', '    _poolPortalAddress,\n', '    _defiPortal,\n', '    _permittedAddresses,\n', '    _coinAddress,\n', '    _fundValueOracle,\n', '    _isRequireTradeVerification,\n', '    _cotraderGlobalConfig\n', '  )\n', '  public {\n', '    // Initial stable coint permitted interface\n', '    permittedAddresses = PermittedAddressesInterface(_permittedAddresses);\n', '    // Push coin in tokens list\n', '    _addToken(_coinAddress);\n', '    // Define is stable based fund\n', '    isStableCoinBasedFund = permittedAddresses.isMatchTypes(_coinAddress, 4);\n', '  }\n', '\n', '  /**\n', '  * @dev Deposits core coin into the fund and allocates a number of shares to the sender\n', '  * depending on the current number of shares, the funds value, and amount deposited\n', '  *\n', '  * @return The amount of shares allocated to the depositor\n', '  */\n', '  function deposit(uint256 depositAmount) external returns (uint256) {\n', '    verifyDWSender();\n', '\n', '    // Check if the sender is allowed to deposit into the fund\n', '    if (onlyWhitelist)\n', '      require(whitelist[msg.sender]);\n', '\n', '    // Require that the amount sent is not 0\n', '    require(depositAmount > 0, "ZERO_DEPOSIT");\n', '\n', '    // Transfer core ERC20 coin from sender\n', '    require(IERC20(coreFundAsset).transferFrom(msg.sender, address(this), depositAmount),\n', '    "TRANSFER_FROM_ISSUE");\n', '\n', '    // Calculate number of shares\n', '    uint256 shares = calculateDepositToShares(depositAmount);\n', '\n', '    // reset latest Oracle Caller for protect from double call\n', '    latestOracleCaller = address(0);\n', '\n', '    totalWeiDeposited += depositAmount;\n', '\n', "    // If user would receive 0 shares, don't continue with deposit\n", '    require(shares != 0, "ZERO_SHARES");\n', '\n', '    // Add shares to total\n', '    totalShares = totalShares.add(shares);\n', '\n', '    // Add shares to address\n', '    addressToShares[msg.sender] = addressToShares[msg.sender].add(shares);\n', '\n', '    addressesNetDeposit[msg.sender] += int256(depositAmount);\n', '\n', '    emit Deposit(msg.sender, depositAmount, shares, totalShares);\n', '\n', '    return shares;\n', '  }\n', '\n', '  /**\n', '  * @dev sets new coreFundAsset NOTE: this works only for stable coins\n', '  *\n', '  * @param _coinAddress    New stable address\n', '  */\n', '  function changeStableCoinAddress(address _coinAddress) external onlyOwner {\n', '    require(isStableCoinBasedFund, "NOT_USD_FUND");\n', '    require(totalWeiDeposited == 0, "NOT_EMPTY_DEPOSIT");\n', '    require(permittedAddresses.isMatchTypes(_coinAddress, 4), "WRONG_ADDRESS");\n', '\n', '    coreFundAsset = _coinAddress;\n', '  }\n', '}\n', '\n', '\n', 'contract SmartFundERC20Factory {\n', '  function createSmartFund(\n', '    address _owner,\n', '    string memory _name,\n', '    uint256 _successFee,\n', '    address _exchangePortalAddress,\n', '    address _poolPortalAddress,\n', '    address _defiPortal,\n', '    address _permittedAddresses,\n', '    address _coinAddress,\n', '    address _fundValueOracle,\n', '    bool    _isRequireTradeVerification,\n', '    address _cotraderGlobalConfig\n', '  )\n', '  public\n', '  returns(address)\n', '  {\n', '    SmartFundERC20 smartFundERC20 = new SmartFundERC20(\n', '      _owner,\n', '      _name,\n', '      _successFee,\n', '      _exchangePortalAddress,\n', '      _poolPortalAddress,\n', '      _defiPortal,\n', '      _permittedAddresses,\n', '      _coinAddress,\n', '      _fundValueOracle,\n', '      _isRequireTradeVerification,\n', '      _cotraderGlobalConfig\n', '    );\n', '\n', '    return address(smartFundERC20);\n', '  }\n', '}']