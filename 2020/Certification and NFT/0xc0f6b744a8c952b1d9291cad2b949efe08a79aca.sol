['/**\n', ' *Submitted for verification at Etherscan.io on 2020-08-25\n', '*/\n', '\n', '/*\n', '*\n', '* ######## ##     ## ########  ######## ######## ##      ##    ###    ##    ##  ######      ##     ## ##    ## ######## \n', '*    ##    ##     ## ##     ## ##       ##       ##  ##  ##   ## ##    ##  ##  ##    ##      ##   ##   ##  ##       ##  \n', '*    ##    ##     ## ##     ## ##       ##       ##  ##  ##  ##   ##    ####   ##             ## ##     ####       ##   \n', '*    ##    ######### ########  ######   ######   ##  ##  ## ##     ##    ##     ######         ###       ##       ##    \n', '*    ##    ##     ## ##   ##   ##       ##       ##  ##  ## #########    ##          ##       ## ##      ##      ##     \n', '*    ##    ##     ## ##    ##  ##       ##       ##  ##  ## ##     ##    ##    ##    ## ###  ##   ##     ##     ##      \n', '*    ##    ##     ## ##     ## ######## ########  ###  ###  ##     ##    ##     ######  ### ##     ##    ##    ######## \n', '*\n', '* Hello\n', '* This is ThreeWays 1.0\n', '* https://threeways.xyz\n', '*\n', '*/\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '// Owner Handler\n', 'contract ownerShip    // Auction Contract Owner and OwherShip change\n', '{\n', '    //Global storage declaration\n', '    address payable public ownerWallet;\n', '    address payable public newOwner;\n', '\n', '    //Event defined for ownership transfered\n', '    event OwnershipTransferredEv(address indexed previousOwner, address indexed newOwner);\n', '\n', '    //Sets owner only on first run\n', '    constructor() public \n', '    {\n', '        //Set contract owner\n', '        ownerWallet = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address payable _newOwner) public onlyOwner\n', '    {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    //the reason for this flow is to protect owners from sending ownership to unintended address due to human error\n', '    function acceptOwnership() public \n', '    {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferredEv(ownerWallet, newOwner);\n', '        ownerWallet = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '\n', '    //This will restrict function only for owner where attached\n', '    modifier onlyOwner() \n', '    {\n', '        require(msg.sender == ownerWallet);\n', '        _;\n', '    }\n', '\n', '}\n', '\n', 'contract threeWays is ownerShip {\n', '\n', '    uint public defaultRefID = 1;   //this ref ID will be used if user joins without any ref ID\n', '    uint public constant maxDownLimit = 2;\n', '    uint public constant levelLifeTime = 31536000;  // = 365 days;\n', '    uint public lastIDCount = 0;\n', '\n', '    struct userInfo {\n', '        bool joined;\n', '        uint id;\n', '        uint referrerID;\n', '        uint originalReferrer;\n', '        address[] referral;\n', '        mapping(uint => uint) levelExpired;\n', '    }\n', '\n', '    mapping(uint => uint) public priceOfLevel;\n', '\n', '    mapping (address => userInfo) public userInfos;\n', '    mapping (uint => address) public userAddressByID;\n', '\n', '\n', '    event regLevelEv(uint indexed _userID, address indexed _userWallet, uint indexed _referrerID, address _referrerWallet, uint _originalReferrer, uint _time);\n', '    event levelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\n', '    event paidForLevelEv(uint userID, address indexed _user, uint referralID, address indexed _referral, uint _level, uint _amount, uint _time);\n', '    event lostForLevelEv(uint userID, address indexed _user, uint referralID, address indexed _referral, uint _level, uint _amount, uint _time);\n', '\n', '    constructor() public {\n', '\n', '        priceOfLevel[1] = 0.1 ether;\n', '        priceOfLevel[2] = 0.2 ether;\n', '        priceOfLevel[3] = 0.4 ether;\n', '        priceOfLevel[4] = 0.8 ether;\n', '        priceOfLevel[5] = 1.6 ether;\n', '        priceOfLevel[6] = 3.2 ether;\n', '        priceOfLevel[7] = 6.4 ether;\n', '        priceOfLevel[8] = 12.8 ether;\n', '\n', '        userInfo memory UserInfo;\n', '        lastIDCount++;\n', '\n', '        UserInfo = userInfo({\n', '            joined: true,\n', '            id: lastIDCount,\n', '            referrerID: 0,\n', '            originalReferrer: 0,\n', '            referral: new address[](0)\n', '        });\n', '\n', '        userInfos[ownerWallet] = UserInfo;\n', '        userAddressByID[lastIDCount] = ownerWallet;\n', '\n', '        for(uint i = 1; i <= 8; i++) {\n', '            userInfos[ownerWallet].levelExpired[i] = 99999999999;\n', '            emit paidForLevelEv(lastIDCount, ownerWallet, 0, address(0), i, priceOfLevel[i], now);\n', '        }\n', '        \n', '        emit regLevelEv(lastIDCount, msg.sender, 0, address(0), 0, now);\n', '    }\n', '    \n', '    function () external payable {\n', '        uint level;\n', '\n', '        if(msg.value == priceOfLevel[1]) level = 1;\n', '        else if(msg.value == priceOfLevel[2]) level = 2;\n', '        else if(msg.value == priceOfLevel[3]) level = 3;\n', '        else if(msg.value == priceOfLevel[4]) level = 4;\n', '        else if(msg.value == priceOfLevel[5]) level = 5;\n', '        else if(msg.value == priceOfLevel[6]) level = 6;\n', '        else if(msg.value == priceOfLevel[7]) level = 7;\n', '        else if(msg.value == priceOfLevel[8]) level = 8;\n', "        else revert('Incorrect Value send');\n", '\n', '        if(userInfos[msg.sender].joined) buyLevel(msg.sender, level);\n', '        else if(level == 1) {\n', '            uint refId = 0;\n', '            address referrer = bytesToAddress(msg.data);\n', '\n', '            if(userInfos[referrer].joined) refId = userInfos[referrer].id;\n', "            else revert('Incorrect referrer');\n", '\n', '            regUser(msg.sender, refId);\n', '        }\n', "        else revert('Please buy first level for 0.1 ETH');\n", '    }\n', '\n', '    function regUser(address _user, uint _referrerID) public payable returns(bool) {\n', '\n', '        if(!(_referrerID > 0 && _referrerID <= lastIDCount)) _referrerID = defaultRefID;\n', '        uint originalReferrer = _referrerID;\n', '\n', "        require(!userInfos[_user].joined, 'User exists');\n", '\n', '        if(msg.sender != ownerWallet){\n', "            require(msg.value == priceOfLevel[1], 'Incorrect Value');\n", "            require(msg.sender == _user, 'Invalid user');\n", '        }\n', '\n', '        if(userInfos[userAddressByID[_referrerID]].referral.length >= maxDownLimit){\n', '\n', '            _referrerID = userInfos[findFreeReferrer(userAddressByID[_referrerID])].id;\n', '        }\n', '\n', '        userInfo memory UserInfo;\n', '        lastIDCount++;\n', '\n', '        UserInfo = userInfo({\n', '            joined: true,\n', '            id: lastIDCount,\n', '            referrerID: _referrerID,\n', '            originalReferrer: originalReferrer,\n', '            referral: new address[](0)\n', '        });\n', '\n', '        userInfos[_user] = UserInfo;\n', '        userAddressByID[lastIDCount] = _user;\n', '\n', '        userInfos[_user].levelExpired[1] = now + levelLifeTime;\n', '\n', '        userInfos[userAddressByID[_referrerID]].referral.push(_user);\n', '\n', '        if(msg.sender != ownerWallet){\n', '            payForCycle(1, _user);  //pay to uplines\n', '        }\n', '\n', '        emit regLevelEv(lastIDCount, _user, _referrerID, userAddressByID[_referrerID], originalReferrer, now);\n', '        return true;\n', '    }\n', '\n', '    function buyLevel(address _user, uint _level) public payable {\n', '        \n', "        require(userInfos[_user].joined, 'User not exist'); \n", "        require(_level > 0 && _level < 9, 'Incorrect level');\n", '\n', '        if(msg.sender != ownerWallet){\n', "            require(msg.value == priceOfLevel[_level], 'Incorrect Value');\n", "            require(msg.sender == _user, 'Invalid user');\n", '        }\n', '\n', '        if(_level == 1) {\n', '            userInfos[_user].levelExpired[1] += levelLifeTime;\n', '        }\n', '        else {\n', "            for(uint l =_level - 1; l > 0; l--) require(userInfos[_user].levelExpired[l] >= now, 'Buy the previous level first');\n", '            if(userInfos[_user].levelExpired[_level] == 0) userInfos[_user].levelExpired[_level] = now + levelLifeTime;\n', '            else userInfos[_user].levelExpired[_level] += levelLifeTime;\n', '        }\n', '        \n', '        if(msg.sender != ownerWallet){\n', '            payForCycle(_level, _user);  //pay to uplines.\n', '        }\n', '\n', '        emit levelBuyEv(_user, _level, msg.value, now);\n', '    }\n', '    \n', '    function payForCycle(uint _level, address _user) internal {\n', '\n', '        address referrer;\n', '        address referrer1;\n', '        address def = userAddressByID[defaultRefID];\n', '        uint256 price = priceOfLevel[_level] * 4500 / 10000;\n', '        uint256 adminPart = price * 10000 / 45000;\n', '\n', '        referrer = findValidUpline(_user, _level);\n', '        referrer1 = findValidUpline(referrer, _level);\n', '\n', '        if(!userInfos[referrer].joined)\n', '        {\n', '            address(uint160(def)).transfer(price);\n', '            emit lostForLevelEv(userInfos[referrer].id, referrer, userInfos[_user].id, _user, _level, price, now);\n', '        }\n', '        else\n', '        {\n', '            address(uint160(referrer)).transfer(price);\n', '            emit paidForLevelEv(userInfos[referrer].id, referrer, userInfos[_user].id, _user, _level, price, now);\n', '        }\n', '\n', '        if(!userInfos[referrer1].joined || !(userInfos[_user].levelExpired[_level] >= now ) )\n', '        {\n', '            address(uint160(def)).transfer(price);\n', '            emit lostForLevelEv(userInfos[referrer1].id, referrer1, userInfos[_user].id, _user, _level, price, now);\n', '        }\n', '        else\n', '        {\n', '            address(uint160(referrer1)).transfer(price);\n', '            emit paidForLevelEv(userInfos[referrer1].id, referrer1, userInfos[_user].id, _user, _level, price, now);\n', '        }\n', '        ownerWallet.transfer(adminPart);\n', '    }\n', '\n', '    function findValidUpline(address _user, uint _level) internal view returns(address)\n', '    {\n', '        for(uint i=0;i<64;i++)\n', '        {\n', '            _user = userAddressByID[userInfos[_user].referrerID];\n', '            if(userInfos[_user].levelExpired[_level] >= now ) break;\n', '        }\n', '        if(!(userInfos[_user].levelExpired[_level] >= now )) _user = userAddressByID[defaultRefID];\n', '        return _user;\n', '    }\n', '\n', '    function findFreeReferrer(address _user) public view returns(address) {\n', '\n', '        if(userInfos[_user].referral.length < maxDownLimit) return _user;\n', '\n', '        address[] memory referrals = new address[](126);\n', '        referrals[0] = userInfos[_user].referral[0];\n', '        referrals[1] = userInfos[_user].referral[1];\n', '\n', '        address freeReferrer;\n', '        bool noFreeReferrer = true;\n', '\n', '        for(uint i = 0; i < 126; i++) {\n', '            if(userInfos[referrals[i]].referral.length == maxDownLimit) {\n', '                if(i < 62) {\n', '                    referrals[(i+1)*2] = userInfos[referrals[i]].referral[0];\n', '                    referrals[(i+1)*2+1] = userInfos[referrals[i]].referral[1];\n', '                }\n', '                else {\n', '                    break;\n', '                }\n', '            }\n', '            else {\n', '                noFreeReferrer = false;\n', '                freeReferrer = referrals[i];\n', '                break;\n', '            }\n', '        }\n', '\n', "        require(!noFreeReferrer, 'No Free Referrer');\n", '\n', '        return freeReferrer;\n', '    }\n', '\n', '    function viewUserReferral(address _user) public view returns(address[] memory) {\n', '        return userInfos[_user].referral;\n', '    }\n', '\n', '    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\n', '        return userInfos[_user].levelExpired[_level];\n', '    }\n', '\n', '    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\n', '        assembly {\n', '            addr := mload(add(bys, 20))\n', '        }\n', '    }\n', '\n', '    function changeDefaultRefID(uint newDefaultRefID) onlyOwner public returns(string memory){\n', '        //this ref ID will be assigned to user who joins without any referral ID.\n', '        defaultRefID = newDefaultRefID;\n', '        return("Default Ref ID updated successfully");\n', '    }\n', '    \n', '    function viewTimestampSinceJoined(address usr) public view returns(uint256[8] memory timeSinceJoined )\n', '    {\n', '        if(userInfos[usr].joined)\n', '        {\n', '            for(uint256 i=0;i<8;i++)\n', '            {\n', '                uint256 t = userInfos[usr].levelExpired[i+1];\n', '                if(t>now)\n', '                {\n', '                    timeSinceJoined[i] = (t-now);\n', '                }\n', '            }\n', '        }\n', '        return timeSinceJoined;\n', '    }\n', '    \n', '    function ownerOnlyCreateUser(address[] memory _user ) public onlyOwner returns(bool)\n', '    {\n', '        require(_user.length <= 50, "invalid input");\n', '        for(uint i=0; i < _user.length; i++ )\n', '        {\n', '            require(regUser(_user[i], 1), "registration fail");\n', '        }\n', '        return true;\n', '    }\n', '    \n', '}']