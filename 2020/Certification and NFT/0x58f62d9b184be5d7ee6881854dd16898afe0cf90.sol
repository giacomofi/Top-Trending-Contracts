['pragma solidity ^0.5.16;\n', '\n', '/**\n', '  * @title ArtDeco Finance\n', '  *\n', '  * @notice Valid NFT-Factory Contract\n', '  * \n', '  */\n', '  \n', 'interface Proxy {\n', '  function setValidFactory( address[] calldata _factorylist ) external;\n', '  function addValidFactory( address _newfactory ) external;\n', '  function removeFactory( address _oldfactory ) external;\n', '  function isValidfactory( address _factory ) external view returns (bool);\n', '}  \n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    int256 constant private INT256_MIN = -2**255;\n', '\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two signed integers, reverts on overflow.\n', '    */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0); // Solidity only automatically asserts when dividing by 0\n', '        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two signed integers, reverts on overflow.\n', '    */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two signed integers, reverts on overflow.\n', '    */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library Address {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'contract proxyvalid is  Ownable \n', '{\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '    \n', '    address public _nextproxy =  address(0);\n', '    address[] public _validfactorylist;\n', '\n', '    constructor() public {\n', '    }\n', '    \n', '    function setProxy( address _proxy ) external onlyOwner\n', '    {\n', '         require ( _proxy != address(0) );\n', '        _nextproxy = _proxy;\n', '    }\n', '    \n', '    function clearProxy() external onlyOwner\n', '    {\n', '         _nextproxy =  address(0);\n', '    }\n', '    \n', '    function setValidFactory( address[] calldata _factorylist ) external onlyOwner\n', '    {\n', '        if( _nextproxy != address(0) )\n', '        {\n', '            Proxy _next =  Proxy(_nextproxy);\n', '            _next.setValidFactory( _factorylist );\n', '        }\n', '        else\n', '        {\n', '            _validfactorylist = _factorylist;\n', '        }\n', '    }\n', '    \n', '    function addValidFactory( address _newfactory ) external onlyOwner\n', '    {\n', '        require ( _newfactory != address(0) );\n', '        if( _nextproxy != address(0) )\n', '        {\n', '            Proxy _next =  Proxy(_nextproxy);\n', '            _next.addValidFactory( _newfactory );\n', '        }\n', '        else\n', '        {\n', '             _validfactorylist.push( _newfactory );\n', '        }\n', '    }\n', '\n', '    function removeFactory( address _oldfactory ) external onlyOwner\n', '    {\n', '        require ( _oldfactory != address(0) );\n', '        if( _nextproxy != address(0) )\n', '        {\n', '            Proxy _next =  Proxy(_nextproxy);\n', '            _next.removeFactory( _oldfactory );\n', '        }\n', '        else\n', '        {\n', '            for (uint i = 0; i < _validfactorylist.length; i++) {\n', '                if( _validfactorylist[i] == _oldfactory )\n', '                {\n', '                      delete _validfactorylist[i];\n', '                }\n', '            }\n', '             \n', '        }\n', '    }\n', '    \n', '    function isValidfactory( address _factory ) public view returns (bool) \n', '    {\n', '        require ( _factory != address(0) );\n', '        if( _nextproxy != address(0) )\n', '        {\n', '            Proxy _next =  Proxy(_nextproxy);\n', '            return _next.isValidfactory( _factory );\n', '        }\n', '        else\n', '        {\n', '            for (uint i = 0; i < _validfactorylist.length; i++) {\n', '                    if( _factory == _validfactorylist[i] )\n', '                    {\n', '                        return true;\n', '                    }\n', '            }\n', '            return false;\n', '        }\n', '    }\n', '    \n', '}']