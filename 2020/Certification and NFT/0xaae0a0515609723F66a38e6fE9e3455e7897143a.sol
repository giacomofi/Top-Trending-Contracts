['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2017 Loopring Technology Limited.\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/// @title Ownable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable\n', '{\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      new owner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership()\n', '        public\n', '        onlyOwner\n', '    {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '/// @title Claimable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable\n', '{\n', '    address public pendingOwner;\n', '\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0) && newOwner != owner, "INVALID_ADDRESS");\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        public\n', '        onlyPendingOwner\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', 'interface IAgent{}\n', '\n', 'interface IAgentRegistry\n', '{\n', '    /// @dev Returns whether an agent address is an agent of an account owner\n', '    /// @param owner The account owner.\n', '    /// @param agent The agent address\n', '    /// @return True if the agent address is an agent for the account owner, else false\n', '    function isAgent(\n', '        address owner,\n', '        address agent\n', '        )\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Returns whether an agent address is an agent of all account owners\n', '    /// @param owners The account owners.\n', '    /// @param agent The agent address\n', '    /// @return True if the agent address is an agent for the account owner, else false\n', '    function isAgent(\n', '        address[] calldata owners,\n', '        address            agent\n', '        )\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title IBlockVerifier\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'abstract contract IBlockVerifier is Claimable\n', '{\n', '    // -- Events --\n', '\n', '    event CircuitRegistered(\n', '        uint8  indexed blockType,\n', '        uint16         blockSize,\n', '        uint8          blockVersion\n', '    );\n', '\n', '    event CircuitDisabled(\n', '        uint8  indexed blockType,\n', '        uint16         blockSize,\n', '        uint8          blockVersion\n', '    );\n', '\n', '    // -- Public functions --\n', '\n', '    /// @dev Sets the verifying key for the specified circuit.\n', '    ///      Every block permutation needs its own circuit and thus its own set of\n', '    ///      verification keys. Only a limited number of block sizes per block\n', '    ///      type are supported.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @param vk The verification key\n', '    function registerCircuit(\n', '        uint8    blockType,\n', '        uint16   blockSize,\n', '        uint8    blockVersion,\n', '        uint[18] calldata vk\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Disables the use of the specified circuit.\n', '    ///      This will stop NEW blocks from using the given circuit, blocks that were already committed\n', '    ///      can still be verified.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    function disableCircuit(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Verifies blocks with the given public data and proofs.\n', '    ///      Verifying a block makes sure all requests handled in the block\n', '    ///      are correctly handled by the operator.\n', '    /// @param blockType The type of block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @param publicInputs The hash of all the public data of the blocks\n', '    /// @param proofs The ZK proofs proving that the blocks are correct\n', '    /// @return True if the block is valid, false otherwise\n', '    function verifyProofs(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion,\n', '        uint[] calldata publicInputs,\n', '        uint[] calldata proofs\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Checks if a circuit with the specified parameters is registered.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @return True if the circuit is registered, false otherwise\n', '    function isCircuitRegistered(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Checks if a circuit can still be used to commit new blocks.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @return True if the circuit is enabled, false otherwise\n', '    function isCircuitEnabled(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title IDepositContract.\n', '/// @dev   Contract storing and transferring funds for an exchange.\n', '///\n', '///        ERC1155 tokens can be supported by registering pseudo token addresses calculated\n', '///        as `address(keccak256(real_token_address, token_params))`. Then the custom\n', '///        deposit contract can look up the real token address and paramsters with the\n', '///        pseudo token address before doing the transfers.\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'interface IDepositContract\n', '{\n', '    /// @dev Returns if a token is suppoprted by this contract.\n', '    function isTokenSupported(address token)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Transfers tokens from a user to the exchange. This function will\n', '    ///      be called when a user deposits funds to the exchange.\n', '    ///      In a simple implementation the funds are simply stored inside the\n', '    ///      deposit contract directly. More advanced implementations may store the funds\n', '    ///      in some DeFi application to earn interest, so this function could directly\n', '    ///      call the necessary functions to store the funds there.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', '    /// @param token The address of the token to transfer (`0x0` for ETH).\n', '    /// @param amount The amount of tokens to transfer.\n', '    /// @param extraData Opaque data that can be used by the contract to handle the deposit\n', "    /// @return amountReceived The amount to deposit to the user's account in the Merkle tree\n", '    function deposit(\n', '        address from,\n', '        address token,\n', '        uint96  amount,\n', '        bytes   calldata extraData\n', '        )\n', '        external\n', '        payable\n', '        returns (uint96 amountReceived);\n', '\n', '    /// @dev Transfers tokens from the exchange to a user. This function will\n', '    ///      be called when a withdrawal is done for a user on the exchange.\n', '    ///      In the simplest implementation the funds are simply stored inside the\n', '    ///      deposit contract directly so this simply transfers the requested tokens back\n', '    ///      to the user. More advanced implementations may store the funds\n', '    ///      in some DeFi application to earn interest so the function would\n', '    ///      need to get those tokens back from the DeFi application first before they\n', '    ///      can be transferred to the user.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', "    /// @param from The address from which 'amount' tokens are transferred.\n", "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (`0x0` for ETH).\n', '    /// @param amount The amount of tokens transferred.\n', '    /// @param extraData Opaque data that can be used by the contract to handle the withdrawal\n', '    function withdraw(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount,\n', '        bytes   calldata extraData\n', '        )\n', '        external\n', '        payable;\n', '\n', '    /// @dev Transfers tokens (ETH not supported) for a user using the allowance set\n', '    ///      for the exchange. This way the approval can be used for all functionality (and\n', '    ///      extended functionality) of the exchange.\n', '    ///      Should NOT be used to deposit/withdraw user funds, `deposit`/`withdraw`\n', '    ///      should be used for that as they will contain specialised logic for those operations.\n', '    ///      This function can be called by the exchange to transfer onchain funds of users\n', '    ///      necessary for Agent functionality.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (ETH is and cannot be suppported).\n', '    /// @param amount The amount of tokens transferred.\n', '    function transfer(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '        )\n', '        external\n', '        payable;\n', '\n', '    /// @dev Checks if the given address is used for depositing ETH or not.\n', '    ///      Is used while depositing to send the correct ETH amount to the deposit contract.\n', '    ///\n', '    ///      Note that 0x0 is always registered for deposting ETH when the exchange is created!\n', '    ///      This function allows additional addresses to be used for depositing ETH, the deposit\n', '    ///      contract can implement different behaviour based on the address value.\n', '    ///\n', '    /// @param addr The address to check\n', '    /// @return True if the address is used for depositing ETH, else false.\n', '    function isETH(address addr)\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title ILoopringV3\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @author Daniel Wang  - <daniel@loopring.org>\n', 'abstract contract ILoopringV3 is Claimable\n', '{\n', '    // == Events ==\n', '    event ExchangeStakeDeposited(address exchangeAddr, uint amount);\n', '    event ExchangeStakeWithdrawn(address exchangeAddr, uint amount);\n', '    event ExchangeStakeBurned(address exchangeAddr, uint amount);\n', '    event SettingsUpdated(uint time);\n', '\n', '    // == Public Variables ==\n', '    mapping (address => uint) internal exchangeStake;\n', '\n', '    address public lrcAddress;\n', '    uint    public totalStake;\n', '    address public blockVerifierAddress;\n', '    uint    public forcedWithdrawalFee;\n', '    uint    public tokenRegistrationFeeLRCBase;\n', '    uint    public tokenRegistrationFeeLRCDelta;\n', '    uint8   public protocolTakerFeeBips;\n', '    uint8   public protocolMakerFeeBips;\n', '\n', '    address payable public protocolFeeVault;\n', '\n', '    // == Public Functions ==\n', '    /// @dev Updates the global exchange settings.\n', '    ///      This function can only be called by the owner of this contract.\n', '    ///\n', '    ///      Warning: these new values will be used by existing and\n', '    ///      new Loopring exchanges.\n', '    function updateSettings(\n', '        address payable _protocolFeeVault,   // address(0) not allowed\n', '        address _blockVerifierAddress,       // address(0) not allowed\n', '        uint    _forcedWithdrawalFee\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Updates the global protocol fee settings.\n', '    ///      This function can only be called by the owner of this contract.\n', '    ///\n', '    ///      Warning: these new values will be used by existing and\n', '    ///      new Loopring exchanges.\n', '    function updateProtocolFeeSettings(\n', '        uint8 _protocolTakerFeeBips,\n', '        uint8 _protocolMakerFeeBips\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the amount of staked LRC for an exchange.\n', '    /// @param exchangeAddr The address of the exchange\n', '    /// @return stakedLRC The amount of LRC\n', '    function getExchangeStake(\n', '        address exchangeAddr\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint stakedLRC);\n', '\n', '    /// @dev Burns a certain amount of staked LRC for a specific exchange.\n', '    ///      This function is meant to be called only from exchange contracts.\n', '    /// @return burnedLRC The amount of LRC burned. If the amount is greater than\n', '    ///         the staked amount, all staked LRC will be burned.\n', '    function burnExchangeStake(\n', '        uint amount\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint burnedLRC);\n', '\n', '    /// @dev Stakes more LRC for an exchange.\n', '    /// @param  exchangeAddr The address of the exchange\n', '    /// @param  amountLRC The amount of LRC to stake\n', '    /// @return stakedLRC The total amount of LRC staked for the exchange\n', '    function depositExchangeStake(\n', '        address exchangeAddr,\n', '        uint    amountLRC\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint stakedLRC);\n', '\n', '    /// @dev Withdraws a certain amount of staked LRC for an exchange to the given address.\n', '    ///      This function is meant to be called only from within exchange contracts.\n', '    /// @param  recipient The address to receive LRC\n', '    /// @param  requestedAmount The amount of LRC to withdraw\n', '    /// @return amountLRC The amount of LRC withdrawn\n', '    function withdrawExchangeStake(\n', '        address recipient,\n', '        uint    requestedAmount\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint amountLRC);\n', '\n', '    /// @dev Gets the protocol fee values for an exchange.\n', '    /// @return takerFeeBips The protocol taker fee\n', '    /// @return makerFeeBips The protocol maker fee\n', '    function getProtocolFeeValues(\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (\n', '            uint8 takerFeeBips,\n', '            uint8 makerFeeBips\n', '        );\n', '}\n', '\n', '\n', '\n', '/// @title ExchangeData\n', '/// @dev All methods in this lib are internal, therefore, there is no need\n', '///      to deploy this library independently.\n', '/// @author Daniel Wang  - <daniel@loopring.org>\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library ExchangeData\n', '{\n', '    // -- Enums --\n', '    enum TransactionType\n', '    {\n', '        NOOP,\n', '        DEPOSIT,\n', '        WITHDRAWAL,\n', '        TRANSFER,\n', '        SPOT_TRADE,\n', '        ACCOUNT_UPDATE,\n', '        AMM_UPDATE\n', '    }\n', '\n', '    // -- Structs --\n', '    struct Token\n', '    {\n', '        address token;\n', '    }\n', '\n', '    struct ProtocolFeeData\n', '    {\n', '        uint32 syncedAt; // only valid before 2105 (85 years to go)\n', '        uint8  takerFeeBips;\n', '        uint8  makerFeeBips;\n', '        uint8  previousTakerFeeBips;\n', '        uint8  previousMakerFeeBips;\n', '    }\n', '\n', '    // General auxiliary data for each conditional transaction\n', '    struct AuxiliaryData\n', '    {\n', '        uint  txIndex;\n', '        bytes data;\n', '    }\n', '\n', '    // This is the (virtual) block the owner  needs to submit onchain to maintain the\n', '    // per-exchange (virtual) blockchain.\n', '    struct Block\n', '    {\n', '        uint8      blockType;\n', '        uint16     blockSize;\n', '        uint8      blockVersion;\n', '        bytes      data;\n', '        uint256[8] proof;\n', '\n', '        // Whether we should store the @BlockInfo for this block on-chain.\n', '        bool storeBlockInfoOnchain;\n', '\n', '        // Block specific data that is only used to help process the block on-chain.\n', '        // It is not used as input for the circuits and it is not necessary for data-availability.\n', '        AuxiliaryData[] auxiliaryData;\n', '\n', '        // Arbitrary data, mainly for off-chain data-availability, i.e.,\n', '        // the multihash of the IPFS file that contains the block data.\n', '        bytes offchainData;\n', '    }\n', '\n', '    struct BlockInfo\n', '    {\n', '        // The time the block was submitted on-chain.\n', '        uint32  timestamp;\n', '        // The public data hash of the block (the 28 most significant bytes).\n', '        bytes28 blockDataHash;\n', '    }\n', '\n', '    // Represents an onchain deposit request.\n', '    struct Deposit\n', '    {\n', '        uint96 amount;\n', '        uint64 timestamp;\n', '    }\n', '\n', '    // A forced withdrawal request.\n', "    // If the actual owner of the account initiated the request (we don't know who the owner is\n", '    // at the time the request is being made) the full balance will be withdrawn.\n', '    struct ForcedWithdrawal\n', '    {\n', '        address owner;\n', '        uint64  timestamp;\n', '    }\n', '\n', '    struct Constants\n', '    {\n', '        uint SNARK_SCALAR_FIELD;\n', '        uint MAX_OPEN_FORCED_REQUESTS;\n', '        uint MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE;\n', '        uint TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS;\n', '        uint MAX_NUM_ACCOUNTS;\n', '        uint MAX_NUM_TOKENS;\n', '        uint MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED;\n', '        uint MIN_TIME_IN_SHUTDOWN;\n', '        uint TX_DATA_AVAILABILITY_SIZE;\n', '        uint MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND;\n', '    }\n', '\n', '    function SNARK_SCALAR_FIELD() internal pure returns (uint) {\n', '        // This is the prime number that is used for the alt_bn128 elliptic curve, see EIP-196.\n', '        return 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n', '    }\n', '    function MAX_OPEN_FORCED_REQUESTS() internal pure returns (uint16) { return 4096; }\n', '    function MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE() internal pure returns (uint32) { return 15 days; }\n', '    function TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS() internal pure returns (uint32) { return 7 days; }\n', '    function MAX_NUM_ACCOUNTS() internal pure returns (uint) { return 2 ** 32; }\n', '    function MAX_NUM_TOKENS() internal pure returns (uint) { return 2 ** 16; }\n', '    function MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED() internal pure returns (uint32) { return 7 days; }\n', '    function MIN_TIME_IN_SHUTDOWN() internal pure returns (uint32) { return 30 days; }\n', '    // The amount of bytes each rollup transaction uses in the block data for data-availability.\n', '    // This is the maximum amount of bytes of all different transaction types.\n', '    function TX_DATA_AVAILABILITY_SIZE() internal pure returns (uint32) { return 68; }\n', '    function MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND() internal pure returns (uint32) { return 15 days; }\n', '    function ACCOUNTID_PROTOCOLFEE() internal pure returns (uint32) { return 0; }\n', '\n', '    function TX_DATA_AVAILABILITY_SIZE_PART_1() internal pure returns (uint32) { return 29; }\n', '    function TX_DATA_AVAILABILITY_SIZE_PART_2() internal pure returns (uint32) { return 39; }\n', '\n', '    struct AccountLeaf\n', '    {\n', '        uint32   accountID;\n', '        address  owner;\n', '        uint     pubKeyX;\n', '        uint     pubKeyY;\n', '        uint32   nonce;\n', '        uint     feeBipsAMM;\n', '    }\n', '\n', '    struct BalanceLeaf\n', '    {\n', '        uint16   tokenID;\n', '        uint96   balance;\n', '        uint96   weightAMM;\n', '        uint     storageRoot;\n', '    }\n', '\n', '    struct MerkleProof\n', '    {\n', '        ExchangeData.AccountLeaf accountLeaf;\n', '        ExchangeData.BalanceLeaf balanceLeaf;\n', '        uint[48]                 accountMerkleProof;\n', '        uint[24]                 balanceMerkleProof;\n', '    }\n', '\n', '    struct BlockContext\n', '    {\n', '        bytes32 DOMAIN_SEPARATOR;\n', '        uint32  timestamp;\n', '    }\n', '\n', '    // Represents the entire exchange state except the owner of the exchange.\n', '    struct State\n', '    {\n', '        uint32  maxAgeDepositUntilWithdrawable;\n', '        bytes32 DOMAIN_SEPARATOR;\n', '\n', '        ILoopringV3      loopring;\n', '        IBlockVerifier   blockVerifier;\n', '        IAgentRegistry   agentRegistry;\n', '        IDepositContract depositContract;\n', '\n', '\n', '        // The merkle root of the offchain data stored in a Merkle tree. The Merkle tree\n', '        // stores balances for users using an account model.\n', '        bytes32 merkleRoot;\n', '\n', '        // List of all blocks\n', '        mapping(uint => BlockInfo) blocks;\n', '        uint  numBlocks;\n', '\n', '        // List of all tokens\n', '        Token[] tokens;\n', '\n', '        // A map from a token to its tokenID + 1\n', '        mapping (address => uint16) tokenToTokenId;\n', '\n', '        // A map from an accountID to a tokenID to if the balance is withdrawn\n', '        mapping (uint32 => mapping (uint16 => bool)) withdrawnInWithdrawMode;\n', '\n', '        // A map from an account to a token to the amount withdrawable for that account.\n', '        // This is only used when the automatic distribution of the withdrawal failed.\n', '        mapping (address => mapping (uint16 => uint)) amountWithdrawable;\n', '\n', '        // A map from an account to a token to the forced withdrawal (always full balance)\n', '        mapping (uint32 => mapping (uint16 => ForcedWithdrawal)) pendingForcedWithdrawals;\n', '\n', '        // A map from an address to a token to a deposit\n', '        mapping (address => mapping (uint16 => Deposit)) pendingDeposits;\n', '\n', '        // A map from an account owner to an approved transaction hash to if the transaction is approved or not\n', '        mapping (address => mapping (bytes32 => bool)) approvedTx;\n', '\n', '        // A map from an account owner to a destination address to a tokenID to an amount to a storageID to a new recipient address\n', '        mapping (address => mapping (address => mapping (uint16 => mapping (uint => mapping (uint32 => address))))) withdrawalRecipient;\n', '\n', '\n', '        // Counter to keep track of how many of forced requests are open so we can limit the work that needs to be done by the owner\n', '        uint32 numPendingForcedTransactions;\n', '\n', '        // Cached data for the protocol fee\n', '        ProtocolFeeData protocolFeeData;\n', '\n', '        // Time when the exchange was shutdown\n', '        uint shutdownModeStartTime;\n', '\n', '        // Time when the exchange has entered withdrawal mode\n', '        uint withdrawalModeStartTime;\n', '\n', '        // Last time the protocol fee was withdrawn for a specific token\n', '        mapping (address => uint) protocolFeeLastWithdrawnTime;\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', 'abstract contract ERC1271 {\n', '    // bytes4(keccak256("isValidSignature(bytes32,bytes)")\n', '    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\n', '\n', '    function isValidSignature(\n', '        bytes32      _hash,\n', '        bytes memory _signature)\n', '        public\n', '        view\n', '        virtual\n', '        returns (bytes4 magicValueB32);\n', '\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library MathUint\n', '{\n', '    using MathUint for uint;\n', '\n', '    function mul(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b, "MUL_OVERFLOW");\n', '    }\n', '\n', '    function sub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        require(b <= a, "SUB_UNDERFLOW");\n', '        return a - b;\n', '    }\n', '\n', '    function add(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '\n', '    function add64(\n', '        uint64 a,\n', '        uint64 b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint64 c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', 'interface IAmmSharedConfig\n', '{\n', '    function maxForcedExitAge() external view returns (uint);\n', '    function maxForcedExitCount() external view returns (uint);\n', '    function forcedExitFee() external view returns (uint);\n', '}\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title IExchangeV3\n', '/// @dev Note that Claimable and RentrancyGuard are inherited here to\n', '///      ensure all data members are declared on IExchangeV3 to make it\n', '///      easy to support upgradability through proxies.\n', '///\n', '///      Subclasses of this contract must NOT define constructor to\n', '///      initialize data.\n', '///\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @author Daniel Wang  - <daniel@loopring.org>\n', 'abstract contract IExchangeV3 is Claimable\n', '{\n', '    // -- Events --\n', '\n', '    event ExchangeCloned(\n', '        address exchangeAddress,\n', '        address owner,\n', '        bytes32 genesisMerkleRoot\n', '    );\n', '\n', '    event TokenRegistered(\n', '        address token,\n', '        uint16  tokenId\n', '    );\n', '\n', '    event Shutdown(\n', '        uint timestamp\n', '    );\n', '\n', '    event WithdrawalModeActivated(\n', '        uint timestamp\n', '    );\n', '\n', '    event BlockSubmitted(\n', '        uint    indexed blockIdx,\n', '        bytes32         merkleRoot,\n', '        bytes32         publicDataHash\n', '    );\n', '\n', '    event DepositRequested(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint16  tokenId,\n', '        uint96  amount\n', '    );\n', '\n', '    event ForcedWithdrawalRequested(\n', '        address owner,\n', '        address token,\n', '        uint32  accountID\n', '    );\n', '\n', '    event WithdrawalCompleted(\n', '        uint8   category,\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '    );\n', '\n', '    event WithdrawalFailed(\n', '        uint8   category,\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '    );\n', '\n', '    event ProtocolFeesUpdated(\n', '        uint8 takerFeeBips,\n', '        uint8 makerFeeBips,\n', '        uint8 previousTakerFeeBips,\n', '        uint8 previousMakerFeeBips\n', '    );\n', '\n', '    event TransactionApproved(\n', '        address owner,\n', '        bytes32 transactionHash\n', '    );\n', '\n', '    // events from libraries\n', '    /*event DepositProcessed(\n', '        address to,\n', '        uint32  toAccountId,\n', '        uint16  token,\n', '        uint    amount\n', '    );*/\n', '\n', '    /*event ForcedWithdrawalProcessed(\n', '        uint32 fromAccountID,\n', '        uint16 tokenID,\n', '        uint   amount\n', '    );*/\n', '\n', '    /*event ConditionalTransferProcessed(\n', '        address from,\n', '        address to,\n', '        uint16  token,\n', '        uint    amount\n', '    );*/\n', '\n', '    /*event AccountUpdated(\n', '        uint32 owner,\n', '        uint   publicKey\n', '    );*/\n', '\n', '\n', '    // -- Initialization --\n', '    /// @dev Initializes this exchange. This method can only be called once.\n', '    /// @param  loopring The LoopringV3 contract address.\n', '    /// @param  owner The owner of this exchange.\n', '    /// @param  genesisMerkleRoot The initial Merkle tree state.\n', '    function initialize(\n', '        address loopring,\n', '        address owner,\n', '        bytes32 genesisMerkleRoot\n', '        )\n', '        virtual\n', '        external;\n', '\n', '    /// @dev Initialized the agent registry contract used by the exchange.\n', '    ///      Can only be called by the exchange owner once.\n', '    /// @param agentRegistry The agent registry contract to be used\n', '    function setAgentRegistry(address agentRegistry)\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the agent registry contract used by the exchange.\n', '    /// @return the agent registry contract\n', '    function getAgentRegistry()\n', '        external\n', '        virtual\n', '        view\n', '        returns (IAgentRegistry);\n', '\n', '    ///      Can only be called by the exchange owner once.\n', '    /// @param depositContract The deposit contract to be used\n', '    function setDepositContract(address depositContract)\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the deposit contract used by the exchange.\n', '    /// @return the deposit contract\n', '    function getDepositContract()\n', '        external\n', '        virtual\n', '        view\n', '        returns (IDepositContract);\n', '\n', '    // @dev Exchange owner withdraws fees from the exchange.\n', '    // @param token Fee token address\n', '    // @param feeRecipient Fee recipient address\n', '    function withdrawExchangeFees(\n', '        address token,\n', '        address feeRecipient\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    // -- Constants --\n', '    /// @dev Returns a list of constants used by the exchange.\n', '    /// @return constants The list of constants.\n', '    function getConstants()\n', '        external\n', '        virtual\n', '        pure\n', '        returns(ExchangeData.Constants memory);\n', '\n', '    // -- Mode --\n', '    /// @dev Returns hether the exchange is in withdrawal mode.\n', '    /// @return Returns true if the exchange is in withdrawal mode, else false.\n', '    function isInWithdrawalMode()\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Returns whether the exchange is shutdown.\n', '    /// @return Returns true if the exchange is shutdown, else false.\n', '    function isShutdown()\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    // -- Tokens --\n', '    /// @dev Registers an ERC20 token for a token id. Note that different exchanges may have\n', '    ///      different ids for the same ERC20 token.\n', '    ///\n', '    ///      Please note that 1 is reserved for Ether (ETH), 2 is reserved for Wrapped Ether (ETH),\n', '    ///      and 3 is reserved for Loopring Token (LRC).\n', '    ///\n', '    ///      This function is only callable by the exchange owner.\n', '    ///\n', "    /// @param  tokenAddress The token's address\n", "    /// @return tokenID The token's ID in this exchanges.\n", '    function registerToken(\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint16 tokenID);\n', '\n', '    /// @dev Returns the id of a registered token.\n', "    /// @param  tokenAddress The token's address\n", "    /// @return tokenID The token's ID in this exchanges.\n", '    function getTokenID(\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint16 tokenID);\n', '\n', '    /// @dev Returns the address of a registered token.\n', "    /// @param  tokenID The token's ID in this exchanges.\n", "    /// @return tokenAddress The token's address\n", '    function getTokenAddress(\n', '        uint16 tokenID\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (address tokenAddress);\n', '\n', '    // -- Stakes --\n', '    /// @dev Gets the amount of LRC the owner has staked onchain for this exchange.\n', '    ///      The stake will be burned if the exchange does not fulfill its duty by\n', '    ///      processing user requests in time. Please note that order matching may potentially\n', "    ///      performed by another party and is not part of the exchange's duty.\n", '    ///\n', '    /// @return The amount of LRC staked\n', '    function getExchangeStake()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    /// @dev Withdraws the amount staked for this exchange.\n', '    ///      This can only be done if the exchange has been correctly shutdown:\n', '    ///      - The exchange owner has shutdown the exchange\n', '    ///      - All deposit requests are processed\n', '    ///      - All funds are returned to the users (merkle root is reset to initial state)\n', '    ///\n', '    ///      Can only be called by the exchange owner.\n', '    ///\n', '    /// @return amountLRC The amount of LRC withdrawn\n', '    function withdrawExchangeStake(\n', '        address recipient\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint amountLRC);\n', '\n', '    /// @dev Can by called by anyone to burn the stake of the exchange when certain\n', '    ///      conditions are fulfilled.\n', '    ///\n', '    ///      Currently this will only burn the stake of the exchange if\n', '    ///      the exchange is in withdrawal mode.\n', '    function burnExchangeStake()\n', '        external\n', '        virtual;\n', '\n', '    // -- Blocks --\n', '\n', "    /// @dev Gets the current Merkle root of this exchange's virtual blockchain.\n", '    /// @return The current Merkle root.\n', '    function getMerkleRoot()\n', '        external\n', '        virtual\n', '        view\n', '        returns (bytes32);\n', '\n', "    /// @dev Gets the height of this exchange's virtual blockchain. The block height for a\n", '    ///      new exchange is 1.\n', '    /// @return The virtual blockchain height which is the index of the last block.\n', '    function getBlockHeight()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', "    /// @dev Gets some minimal info of a previously submitted block that's kept onchain.\n", '    ///      A DEX can use this function to implement a payment receipt verification\n', '    ///      contract with a challange-response scheme.\n', '    /// @param blockIdx The block index.\n', '    function getBlockInfo(uint blockIdx)\n', '        external\n', '        virtual\n', '        view\n', '        returns (ExchangeData.BlockInfo memory);\n', '\n', '    /// @dev Sumbits new blocks to the rollup blockchain.\n', '    ///\n', '    ///      This function can only be called by the exchange operator.\n', '    ///\n', '    /// @param blocks The blocks being submitted\n', '    ///      - blockType: The type of the new block\n', '    ///      - blockSize: The number of onchain or offchain requests/settlements\n', '    ///        that have been processed in this block\n', '    ///      - blockVersion: The circuit version to use for verifying the block\n', '    ///      - storeBlockInfoOnchain: If the block info for this block needs to be stored on-chain\n', '    ///      - data: The data for this block\n', '    ///      - offchainData: Arbitrary data, mainly for off-chain data-availability, i.e.,\n', '    ///        the multihash of the IPFS file that contains the block data.\n', '    function submitBlocks(ExchangeData.Block[] calldata blocks)\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the number of available forced request slots.\n', '    /// @return The number of available slots.\n', '    function getNumAvailableForcedSlots()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    // -- Deposits --\n', '\n', '    /// @dev Deposits Ether or ERC20 tokens to the specified account.\n', '    ///\n', "    ///      This function is only callable by an agent of 'from'.\n", '    ///\n', '    ///      A fee to the owner is paid in ETH to process the deposit.\n', '    ///      The operator is not forced to do the deposit and the user can send\n', '    ///      any fee amount.\n', '    ///\n', '    /// @param from The address that deposits the funds to the exchange\n', "    /// @param to The account owner's address receiving the funds\n", '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    /// @param amount The amount of tokens to deposit\n', '    /// @param auxiliaryData Optional extra data used by the deposit contract\n', '    function deposit(\n', '        address from,\n', '        address to,\n', '        address tokenAddress,\n', '        uint96  amount,\n', '        bytes   calldata auxiliaryData\n', '        )\n', '        external\n', '        virtual\n', '        payable;\n', '\n', "    /// @dev Gets the amount of tokens that may be added to the owner's account.\n", '    /// @param owner The destination address for the amount deposited.\n', '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    /// @return The amount of tokens pending.\n', '    function getPendingDepositAmount(\n', '        address owner,\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint96);\n', '\n', '    // -- Withdrawals --\n', '    /// @dev Submits an onchain request to force withdraw Ether or ERC20 tokens.\n', '    ///      This request always withdraws the full balance.\n', '    ///\n', '    ///      This function is only callable by an agent of the account.\n', '    ///\n', "    ///      The total fee in ETH that the user needs to pay is 'withdrawalFee'.\n", '    ///      If the user sends too much ETH the surplus is sent back immediately.\n', '    ///\n', '    ///      Note that after such an operation, it will take the owner some\n', '    ///      time (no more than MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE) to process the request\n', '    ///      and create the deposit to the offchain account.\n', '    ///\n', '    /// @param owner The expected owner of the account\n', '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    /// @param accountID The address the account in the Merkle tree.\n', '    function forceWithdraw(\n', '        address owner,\n', '        address tokenAddress,\n', '        uint32  accountID\n', '        )\n', '        external\n', '        virtual\n', '        payable;\n', '\n', '    /// @dev Checks if a forced withdrawal is pending for an account balance.\n', '    /// @param  accountID The accountID of the account to check.\n', '    /// @param  token The token address\n', '    /// @return True if a request is pending, false otherwise\n', '    function isForcedWithdrawalPending(\n', '        uint32  accountID,\n', '        address token\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Submits an onchain request to withdraw Ether or ERC20 tokens from the\n', '    ///      protocol fees account. The complete balance is always withdrawn.\n', '    ///\n', '    ///      Anyone can request a withdrawal of the protocol fees.\n', '    ///\n', '    ///      Note that after such an operation, it will take the owner some\n', '    ///      time (no more than MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE) to process the request\n', '    ///      and create the deposit to the offchain account.\n', '    ///\n', '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    function withdrawProtocolFees(\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        payable;\n', '\n', '    /// @dev Gets the time the protocol fee for a token was last withdrawn.\n', '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    /// @return The time the protocol fee was last withdrawn.\n', '    function getProtocolFeeLastWithdrawnTime(\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    /// @dev Allows anyone to withdraw funds for a specified user using the balances stored\n', '    ///      in the Merkle tree. The funds will be sent to the owner of the acount.\n', '    ///\n', '    ///      Can only be used in withdrawal mode (i.e. when the owner has stopped\n', '    ///      committing blocks and is not able to commit any more blocks).\n', '    ///\n', '    ///      This will NOT modify the onchain merkle root! The merkle root stored\n', '    ///      onchain will remain the same after the withdrawal. We store if the user\n', '    ///      has withdrawn the balance in State.withdrawnInWithdrawMode.\n', '    ///\n', '    /// @param  merkleProof The Merkle inclusion proof\n', '    function withdrawFromMerkleTree(\n', '        ExchangeData.MerkleProof calldata merkleProof\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Checks if the balance for the account was withdrawn with `withdrawFromMerkleTree`.\n', '    /// @param  accountID The accountID of the balance to check.\n', '    /// @param  token The token address\n', '    /// @return True if it was already withdrawn, false otherwise\n', '    function isWithdrawnInWithdrawalMode(\n', '        uint32  accountID,\n', '        address token\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Allows withdrawing funds deposited to the contract in a deposit request when\n', '    ///      it was never processed by the owner within the maximum time allowed.\n', '    ///\n', '    ///      Can be called by anyone. The deposited tokens will be sent back to\n', '    ///      the owner of the account they were deposited in.\n', '    ///\n', '    /// @param  owner The address of the account the withdrawal was done for.\n', '    /// @param  token The token address\n', '    function withdrawFromDepositRequest(\n', '        address owner,\n', '        address token\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Allows withdrawing funds after a withdrawal request (either onchain\n', '    ///      or offchain) was submitted in a block by the operator.\n', '    ///\n', '    ///      Can be called by anyone. The withdrawn tokens will be sent to\n', '    ///      the owner of the account they were withdrawn out.\n', '    ///\n', '    ///      Normally it is should not be needed for users to call this manually.\n', '    ///      Funds from withdrawal requests will be sent to the account owner\n', '    ///      immediately by the owner when the block is submitted.\n', '    ///      The user will however need to call this manually if the transfer failed.\n', '    ///\n', '    ///      Tokens and owners must have the same size.\n', '    ///\n', '    /// @param  owners The addresses of the account the withdrawal was done for.\n', '    /// @param  tokens The token addresses\n', '    function withdrawFromApprovedWithdrawals(\n', '        address[] calldata owners,\n', '        address[] calldata tokens\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the amount that can be withdrawn immediately with `withdrawFromApprovedWithdrawals`.\n', '    /// @param  owner The address of the account the withdrawal was done for.\n', '    /// @param  token The token address\n', '    /// @return The amount withdrawable\n', '    function getAmountWithdrawable(\n', '        address owner,\n', '        address token\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    /// @dev Notifies the exchange that the owner did not process a forced request.\n', '    ///      If this is indeed the case, the exchange will enter withdrawal mode.\n', '    ///\n', '    ///      Can be called by anyone.\n', '    ///\n', '    /// @param  accountID The accountID the forced request was made for\n', '    /// @param  token The token address of the the forced request\n', '    function notifyForcedRequestTooOld(\n', '        uint32  accountID,\n', '        address token\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Allows a withdrawal to be done to an adddresss that is different\n', '    ///      than initialy specified in the withdrawal request. This can be used to\n', '    ///      implement functionality like fast withdrawals.\n', '    ///\n', '    ///      This function can only be called by an agent.\n', '    ///\n', '    /// @param from The address of the account that does the withdrawal.\n', "    /// @param to The address to which 'amount' tokens were going to be withdrawn.\n", "    /// @param token The address of the token that is withdrawn ('0x0' for ETH).\n", '    /// @param amount The amount of tokens that are going to be withdrawn.\n', '    /// @param storageID The storageID of the withdrawal request.\n', '    /// @param newRecipient The new recipient address of the withdrawal.\n', '    function setWithdrawalRecipient(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint96  amount,\n', '        uint32  storageID,\n', '        address newRecipient\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the withdrawal recipient.\n', '    ///\n', '    /// @param from The address of the account that does the withdrawal.\n', "    /// @param to The address to which 'amount' tokens were going to be withdrawn.\n", "    /// @param token The address of the token that is withdrawn ('0x0' for ETH).\n", '    /// @param amount The amount of tokens that are going to be withdrawn.\n', '    /// @param storageID The storageID of the withdrawal request.\n', '    function getWithdrawalRecipient(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint96  amount,\n', '        uint32  storageID\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (address);\n', '\n', '    /// @dev Allows an agent to transfer ERC-20 tokens for a user using the allowance\n', '    ///      the user has set for the exchange. This way the user only needs to approve a single exchange contract\n', '    ///      for all exchange/agent features, which allows for a more seamless user experience.\n', '    ///\n', '    ///      This function can only be called by an agent.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (ETH is and cannot be suppported).\n', '    /// @param amount The amount of tokens transferred.\n', '    function onchainTransferFrom(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Allows an agent to approve a rollup tx.\n', '    ///\n', '    ///      This function can only be called by an agent.\n', '    ///\n', '    /// @param owner The owner of the account\n', '    /// @param txHash The hash of the transaction\n', '    function approveTransaction(\n', '        address owner,\n', '        bytes32 txHash\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Allows an agent to approve multiple rollup txs.\n', '    ///\n', '    ///      This function can only be called by an agent.\n', '    ///\n', '    /// @param owners The account owners\n', '    /// @param txHashes The hashes of the transactions\n', '    function approveTransactions(\n', '        address[] calldata owners,\n', '        bytes32[] calldata txHashes\n', '        )\n', '        external\n', '        virtual;\n', '\n', "    /// @dev Checks if a rollup tx is approved using the tx's hash.\n", '    ///\n', '    /// @param owner The owner of the account that needs to authorize the tx\n', '    /// @param txHash The hash of the transaction\n', '    /// @return True if the tx is approved, else false\n', '    function isTransactionApproved(\n', '        address owner,\n', '        bytes32 txHash\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    // -- Admins --\n', '    /// @dev Sets the max time deposits have to wait before becoming withdrawable.\n', '    /// @param newValue The new value.\n', '    /// @return  The old value.\n', '    function setMaxAgeDepositUntilWithdrawable(\n', '        uint32 newValue\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint32);\n', '\n', '    /// @dev Returns the max time deposits have to wait before becoming withdrawable.\n', '    /// @return The value.\n', '    function getMaxAgeDepositUntilWithdrawable()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint32);\n', '\n', '    /// @dev Shuts down the exchange.\n', '    ///      Once the exchange is shutdown all onchain requests are permanently disabled.\n', '    ///      When all requirements are fulfilled the exchange owner can withdraw\n', '    ///      the exchange stake with withdrawStake.\n', '    ///\n', '    ///      Note that the exchange can still enter the withdrawal mode after this function\n', '    ///      has been invoked successfully. To prevent entering the withdrawal mode before the\n', '    ///      the echange stake can be withdrawn, all withdrawal requests still need to be handled\n', '    ///      for at least MIN_TIME_IN_SHUTDOWN seconds.\n', '    ///\n', '    ///      Can only be called by the exchange owner.\n', '    ///\n', '    /// @return success True if the exchange is shutdown, else False\n', '    function shutdown()\n', '        external\n', '        virtual\n', '        returns (bool success);\n', '\n', '    /// @dev Gets the protocol fees for this exchange.\n', '    /// @return syncedAt The timestamp the protocol fees were last updated\n', '    /// @return takerFeeBips The protocol taker fee\n', '    /// @return makerFeeBips The protocol maker fee\n', '    /// @return previousTakerFeeBips The previous protocol taker fee\n', '    /// @return previousMakerFeeBips The previous protocol maker fee\n', '    function getProtocolFeeValues()\n', '        external\n', '        virtual\n', '        view\n', '        returns (\n', '            uint32 syncedAt,\n', '            uint8 takerFeeBips,\n', '            uint8 makerFeeBips,\n', '            uint8 previousTakerFeeBips,\n', '            uint8 previousMakerFeeBips\n', '        );\n', '\n', '    /// @dev Gets the domain separator used in this exchange.\n', '    function getDomainSeparator()\n', '        external\n', '        virtual\n', '        view\n', '        returns (bytes32);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '//Mainly taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n', '\n', '\n', 'library BytesUtil {\n', '\n', '    function concat(\n', '        bytes memory _preBytes,\n', '        bytes memory _postBytes\n', '    )\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            // Get a location of some free memory and store it in tempBytes as\n', '            // Solidity does for memory variables.\n', '            tempBytes := mload(0x40)\n', '\n', '            // Store the length of the first bytes array at the beginning of\n', '            // the memory for tempBytes.\n', '            let length := mload(_preBytes)\n', '            mstore(tempBytes, length)\n', '\n', '            // Maintain a memory counter for the current write location in the\n', '            // temp bytes array by adding the 32 bytes for the array length to\n', '            // the starting location.\n', '            let mc := add(tempBytes, 0x20)\n', '            // Stop copying when the memory counter reaches the length of the\n', '            // first bytes array.\n', '            let end := add(mc, length)\n', '\n', '            for {\n', '                // Initialize a copy counter to the start of the _preBytes data,\n', '                // 32 bytes into its memory.\n', '                let cc := add(_preBytes, 0x20)\n', '            } lt(mc, end) {\n', '                // Increase both counters by 32 bytes each iteration.\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                // Write the _preBytes data into the tempBytes memory 32 bytes\n', '                // at a time.\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Add the length of _postBytes to the current length of tempBytes\n', '            // and store it as the new length in the first 32 bytes of the\n', '            // tempBytes memory.\n', '            length := mload(_postBytes)\n', '            mstore(tempBytes, add(length, mload(tempBytes)))\n', '\n', '            // Move the memory counter back from a multiple of 0x20 to the\n', '            // actual end of the _preBytes data.\n', '            mc := end\n', '            // Stop copying when the memory counter reaches the new combined\n', '            // length of the arrays.\n', '            end := add(mc, length)\n', '\n', '            for {\n', '                let cc := add(_postBytes, 0x20)\n', '            } lt(mc, end) {\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Update the free-memory pointer by padding our last write location\n', '            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n', '            // next 32 byte block, then round down to the nearest multiple of\n', '            // 32. If the sum of the length of the two arrays is zero then add\n', '            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n', '            mstore(0x40, and(\n', '              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n', '              not(31) // Round down to the nearest 32 bytes.\n', '            ))\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function slice(\n', '        bytes memory _bytes,\n', '        uint _start,\n', '        uint _length\n', '    )\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        require(_bytes.length >= (_start + _length));\n', '\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            switch iszero(_length)\n', '            case 0 {\n', '                // Get a location of some free memory and store it in tempBytes as\n', '                // Solidity does for memory variables.\n', '                tempBytes := mload(0x40)\n', '\n', '                // The first word of the slice result is potentially a partial\n', '                // word read from the original array. To read it, we calculate\n', '                // the length of that partial word and start copying that many\n', '                // bytes into the array. The first word we copy will start with\n', "                // data we don't care about, but the last `lengthmod` bytes will\n", '                // land at the beginning of the contents of the new array. When\n', "                // we're done copying, we overwrite the full first word with\n", '                // the actual length of the slice.\n', '                let lengthmod := and(_length, 31)\n', '\n', '                // The multiplication in the next line is necessary\n', '                // because when slicing multiples of 32 bytes (lengthmod == 0)\n', "                // the following copy loop was copying the origin's length\n", '                // and then ending prematurely not copying everything it should.\n', '                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                let end := add(mc, _length)\n', '\n', '                for {\n', '                    // The multiplication in the next line has the same exact purpose\n', '                    // as the one above.\n', '                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                } lt(mc, end) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    mstore(mc, mload(cc))\n', '                }\n', '\n', '                mstore(tempBytes, _length)\n', '\n', '                //update free-memory pointer\n', '                //allocating the array padded to 32 bytes like the compiler does now\n', '                mstore(0x40, and(add(mc, 31), not(31)))\n', '            }\n', "            //if we want a zero-length slice let's just return a zero-length array\n", '            default {\n', '                tempBytes := mload(0x40)\n', '\n', '                mstore(0x40, add(tempBytes, 0x20))\n', '            }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n', '        require(_bytes.length >= (_start + 20));\n', '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n', '        require(_bytes.length >= (_start + 1));\n', '        uint8 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x1), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\n', '        require(_bytes.length >= (_start + 2));\n', '        uint16 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x2), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\n', '        require(_bytes.length >= (_start + 3));\n', '        uint24 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x3), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\n', '        require(_bytes.length >= (_start + 4));\n', '        uint32 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x4), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\n', '        require(_bytes.length >= (_start + 8));\n', '        uint64 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x8), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\n', '        require(_bytes.length >= (_start + 12));\n', '        uint96 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0xc), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\n', '        require(_bytes.length >= (_start + 16));\n', '        uint128 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x10), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n', '        require(_bytes.length >= (_start + 32));\n', '        uint256 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\n', '        require(_bytes.length >= (_start + 4));\n', '        bytes4 tempBytes4;\n', '\n', '        assembly {\n', '            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes4;\n', '    }\n', '\n', '    function toBytes20(bytes memory _bytes, uint _start) internal  pure returns (bytes20) {\n', '        require(_bytes.length >= (_start + 20));\n', '        bytes20 tempBytes20;\n', '\n', '        assembly {\n', '            tempBytes20 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes20;\n', '    }\n', '\n', '    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\n', '        require(_bytes.length >= (_start + 32));\n', '        bytes32 tempBytes32;\n', '\n', '        assembly {\n', '            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes32;\n', '    }\n', '\n', '    function fastSHA256(\n', '        bytes memory data\n', '        )\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        bytes32[] memory result = new bytes32[](1);\n', '        bool success;\n', '        assembly {\n', '             let ptr := add(data, 32)\n', '             success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)\n', '        }\n', '        require(success, "SHA256_FAILED");\n', '        return result[0];\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Utility Functions for addresses\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library AddressUtil\n', '{\n', '    using AddressUtil for *;\n', '\n', '    function isContract(\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(addr) }\n', '        return (codehash != 0x0 &&\n', '                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n', '    }\n', '\n', '    function toPayable(\n', '        address addr\n', '        )\n', '        internal\n', '        pure\n', '        returns (address payable)\n', '    {\n', '        return payable(addr);\n', '    }\n', '\n', '    // Works like address.send but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETH(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        if (amount == 0) {\n', '            return true;\n', '        }\n', '        address payable recipient = to.toPayable();\n', '        /* solium-disable-next-line */\n', '        (success, ) = recipient.call{value: amount, gas: gasLimit}("");\n', '    }\n', '\n', '    // Works like address.transfer but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETHAndVerify(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        success = to.sendETH(amount, gasLimit);\n', '        require(success, "TRANSFER_FAILURE");\n', '    }\n', '\n', '    // Works like call but is slightly more efficient when data\n', '    // needs to be copied from memory to do the call.\n', '    function fastCall(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bool success, bytes memory returnData)\n', '    {\n', '        if (to != address(0)) {\n', '            assembly {\n', '                // Do the call\n', '                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\n', '                // Copy the return data\n', '                let size := returndatasize()\n', '                returnData := mload(0x40)\n', '                mstore(returnData, size)\n', '                returndatacopy(add(returnData, 32), 0, size)\n', '                // Update free memory pointer\n', '                mstore(0x40, add(returnData, add(32, size)))\n', '            }\n', '        }\n', '    }\n', '\n', '    // Like fastCall, but throws when the call is unsuccessful.\n', '    function fastCallAndVerify(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bytes memory returnData)\n', '    {\n', '        bool success;\n', '        (success, returnData) = fastCall(to, gasLimit, value, data);\n', '        if (!success) {\n', '            assembly {\n', '                revert(add(returnData, 32), mload(returnData))\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/// @title SignatureUtil\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', "/// @dev This method supports multihash standard. Each signature's last byte indicates\n", "///      the signature's type.\n", 'library SignatureUtil\n', '{\n', '    using BytesUtil     for bytes;\n', '    using MathUint      for uint;\n', '    using AddressUtil   for address;\n', '\n', '    enum SignatureType {\n', '        ILLEGAL,\n', '        INVALID,\n', '        EIP_712,\n', '        ETH_SIGN,\n', '        WALLET   // deprecated\n', '    }\n', '\n', '    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\n', '\n', '    function verifySignatures(\n', '        bytes32          signHash,\n', '        address[] memory signers,\n', '        bytes[]   memory signatures\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        require(signers.length == signatures.length, "BAD_SIGNATURE_DATA");\n', '        address lastSigner;\n', '        for (uint i = 0; i < signers.length; i++) {\n', '            require(signers[i] > lastSigner, "INVALID_SIGNERS_ORDER");\n', '            lastSigner = signers[i];\n', '            if (!verifySignature(signHash, signers[i], signatures[i])) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function verifySignature(\n', '        bytes32        signHash,\n', '        address        signer,\n', '        bytes   memory signature\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (signer == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        return signer.isContract()?\n', '            verifyERC1271Signature(signHash, signer, signature):\n', '            verifyEOASignature(signHash, signer, signature);\n', '    }\n', '\n', '    function recoverECDSASigner(\n', '        bytes32      signHash,\n', '        bytes memory signature\n', '        )\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        if (signature.length != 65) {\n', '            return address(0);\n', '        }\n', '\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8   v;\n', '        // we jump 32 (0x20) as the first slot of bytes contains the length\n', '        // we jump 65 (0x41) per signature\n', '        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := and(mload(add(signature, 0x41)), 0xff)\n', '        }\n', '        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\n', '        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n', '            return address(0);\n', '        }\n', '        if (v == 27 || v == 28) {\n', '            return ecrecover(signHash, v, r, s);\n', '        } else {\n', '            return address(0);\n', '        }\n', '    }\n', '\n', '    function verifyEOASignature(\n', '        bytes32        signHash,\n', '        address        signer,\n', '        bytes   memory signature\n', '        )\n', '        private\n', '        pure\n', '        returns (bool success)\n', '    {\n', '        if (signer == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        uint signatureTypeOffset = signature.length.sub(1);\n', '        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\n', '\n', '        // Strip off the last byte of the signature by updating the length\n', '        assembly {\n', '            mstore(signature, signatureTypeOffset)\n', '        }\n', '\n', '        if (signatureType == SignatureType.EIP_712) {\n', '            success = (signer == recoverECDSASigner(signHash, signature));\n', '        } else if (signatureType == SignatureType.ETH_SIGN) {\n', '            bytes32 hash = keccak256(\n', '                abi.encodePacked("\\x19Ethereum Signed Message:\\n32", signHash)\n', '            );\n', '            success = (signer == recoverECDSASigner(hash, signature));\n', '        } else {\n', '            success = false;\n', '        }\n', '\n', '        // Restore the signature length\n', '        assembly {\n', '            mstore(signature, add(signatureTypeOffset, 1))\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '    function verifyERC1271Signature(\n', '        bytes32 signHash,\n', '        address signer,\n', '        bytes   memory signature\n', '        )\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            ERC1271.isValidSignature.selector,\n', '            signHash,\n', '            signature\n', '        );\n', '        (bool success, bytes memory result) = signer.staticcall(callData);\n', '        return (\n', '            success &&\n', '            result.length == 32 &&\n', '            result.toBytes4(0) == ERC1271_MAGICVALUE\n', '        );\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library MathUint96\n', '{\n', '    function add(\n', '        uint96 a,\n', '        uint96 b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint96 c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '\n', '    function sub(\n', '        uint96 a,\n', '        uint96 b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint96 c)\n', '    {\n', '        require(b <= a, "SUB_UNDERFLOW");\n', '        return a - b;\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', 'library EIP712\n', '{\n', '    struct Domain {\n', '        string  name;\n', '        string  version;\n', '        address verifyingContract;\n', '    }\n', '\n', '    bytes32 constant internal EIP712_DOMAIN_TYPEHASH = keccak256(\n', '        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n', '    );\n', '\n', '    string constant internal EIP191_HEADER = "\\x19\\x01";\n', '\n', '    function hash(Domain memory domain)\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        uint _chainid;\n', '        assembly { _chainid := chainid() }\n', '\n', '        return keccak256(\n', '            abi.encode(\n', '                EIP712_DOMAIN_TYPEHASH,\n', '                keccak256(bytes(domain.name)),\n', '                keccak256(bytes(domain.version)),\n', '                _chainid,\n', '                domain.verifyingContract\n', '            )\n', '        );\n', '    }\n', '\n', '    function hashPacked(\n', '        bytes32 domainHash,\n', '        bytes32 dataHash\n', '        )\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                EIP191_HEADER,\n', '                domainHash,\n', '                dataHash\n', '            )\n', '        );\n', '    }\n', '}\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title AmmData\n', 'library AmmData\n', '{\n', '    function POOL_TOKEN_BASE() internal pure returns (uint) { return 100 * (10 ** 8); }\n', '    function POOL_TOKEN_MINTED_SUPPLY() internal pure returns (uint) { return uint96(-1); }\n', '\n', '    enum PoolTxType\n', '    {\n', '        NOOP,\n', '        JOIN,\n', '        EXIT\n', '    }\n', '\n', '    struct PoolConfig\n', '    {\n', '        address   sharedConfig;\n', '        address   exchange;\n', '        string    poolName;\n', '        uint32    accountID;\n', '        address[] tokens;\n', '        uint96[]  weights;\n', '        uint8     feeBips;\n', '        string    tokenSymbol;\n', '    }\n', '\n', '    struct PoolJoin\n', '    {\n', '        address   owner;\n', '        uint96[]  joinAmounts;\n', '        uint32[]  joinStorageIDs;\n', '        uint96    mintMinAmount;\n', '        uint32    validUntil;\n', '    }\n', '\n', '    struct PoolExit\n', '    {\n', '        address   owner;\n', '        uint96    burnAmount;\n', '        uint32    burnStorageID; // for pool token withdrawal from user to the pool\n', '        uint96[]  exitMinAmounts; // the amount to receive BEFORE paying the fee.\n', '        uint96    fee;\n', '        uint32    validUntil;\n', '    }\n', '\n', '    struct PoolTx\n', '    {\n', '        PoolTxType txType;\n', '        bytes      data;\n', '        bytes      signature;\n', '    }\n', '\n', '    struct Token\n', '    {\n', '        address addr;\n', '        uint96  weight;\n', '        uint16  tokenID;\n', '    }\n', '\n', '    struct Context\n', '    {\n', '        // functional parameters\n', '        uint txIdx;\n', '\n', '        // Exchange state variables\n', '        IExchangeV3 exchange;\n', '        bytes32     exchangeDomainSeparator;\n', '\n', '        // AMM pool state variables\n', '        bytes32 domainSeparator;\n', '        uint32  accountID;\n', '\n', '        uint16  poolTokenID;\n', '        uint    totalSupply;\n', '\n', '        Token[]  tokens;\n', '        uint96[] tokenBalancesL2;\n', '\n', '        TransactionBuffer transactionBuffer;\n', '    }\n', '\n', '    struct TransactionBuffer\n', '    {\n', '        uint      size;\n', '        address[] owners;\n', '        bytes32[] txHashes;\n', '    }\n', '\n', '    struct State {\n', '        // Pool token state variables\n', '        string poolName;\n', '        string symbol;\n', '        uint   _totalSupply;\n', '\n', '        mapping(address => uint) balanceOf;\n', '        mapping(address => mapping(address => uint)) allowance;\n', '        mapping(address => uint) nonces;\n', '\n', '        // AMM pool state variables\n', '        IAmmSharedConfig sharedConfig;\n', '\n', '        Token[]     tokens;\n', '\n', '        // The order of the following variables important to minimize loads\n', '        bytes32     exchangeDomainSeparator;\n', '        bytes32     domainSeparator;\n', '        IExchangeV3 exchange;\n', '        uint32      accountID;\n', '        uint16      poolTokenID;\n', '        uint8       feeBips;\n', '\n', '        address     exchangeOwner;\n', '\n', '        uint64      shutdownTimestamp;\n', '        uint16      forcedExitCount;\n', '\n', '        // A map from a user to the forced exit.\n', '        mapping (address => PoolExit) forcedExit;\n', '        mapping (bytes32 => bool) approvedTx;\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title AmmPoolToken\n', 'library AmmPoolToken\n', '{\n', '    using MathUint      for uint;\n', '    using MathUint96    for uint96;\n', '    using SignatureUtil for bytes32;\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from,  address indexed to,      uint value);\n', '\n', '    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '\n', '    function totalSupply(\n', '        AmmData.State storage S\n', '        )\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        return S._totalSupply;\n', '    }\n', '\n', '    function approve(\n', '        AmmData.State storage S,\n', '        address               spender,\n', '        uint                  value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        _approve(S, msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(\n', '        AmmData.State storage S,\n', '        address               to,\n', '        uint                  value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        _transfer(S, msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        AmmData.State storage S,\n', '        address               from,\n', '        address               to,\n', '        uint                  value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        if (msg.sender != address(this) &&\n', '            S.allowance[from][msg.sender] != uint(-1)) {\n', '            S.allowance[from][msg.sender] = S.allowance[from][msg.sender].sub(value);\n', '        }\n', '         _transfer(S, from, to, value);\n', '        return true;\n', '    }\n', '\n', '    function permit(\n', '        AmmData.State storage S,\n', '        address               owner,\n', '        address               spender,\n', '        uint256               value,\n', '        uint256               deadline,\n', '        bytes        calldata signature\n', '        )\n', '        internal\n', '    {\n', "        require(deadline >= block.timestamp, 'EXPIRED');\n", '\n', '        bytes32 hash = EIP712.hashPacked(\n', '            S.domainSeparator,\n', '            keccak256(\n', '                abi.encode(\n', '                    PERMIT_TYPEHASH,\n', '                    owner,\n', '                    spender,\n', '                    value,\n', '                    S.nonces[owner]++,\n', '                    deadline\n', '                )\n', '            )\n', '        );\n', '\n', "        require(hash.verifySignature(owner, signature), 'INVALID_SIGNATURE');\n", '        _approve(S, owner, spender, value);\n', '    }\n', '\n', '    function _approve(\n', '        AmmData.State storage S,\n', '        address               owner,\n', '        address               spender,\n', '        uint                  value\n', '        )\n', '        private\n', '    {\n', '        if (spender != address(this)) {\n', '            S.allowance[owner][spender] = value;\n', '            emit Approval(owner, spender, value);\n', '        }\n', '    }\n', '\n', '    function _transfer(\n', '        AmmData.State storage S,\n', '        address               from,\n', '        address               to,\n', '        uint                  value\n', '        )\n', '        private\n', '    {\n', '        S.balanceOf[from] = S.balanceOf[from].sub(value);\n', '        S.balanceOf[to] = S.balanceOf[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'abstract contract ERC20\n', '{\n', '    function totalSupply()\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    function balanceOf(\n', '        address who\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function approve(\n', '        address spender,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title AmmStatus\n', 'library AmmStatus\n', '{\n', '    using AmmPoolToken      for AmmData.State;\n', '    using MathUint          for uint;\n', '    using MathUint96        for uint96;\n', '    using SignatureUtil     for bytes32;\n', '\n', '    event Shutdown(uint timestamp);\n', '\n', '    function isOnline(AmmData.State storage S)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return S.shutdownTimestamp == 0;\n', '    }\n', '\n', '    function setupPool(\n', '        AmmData.State      storage  S,\n', '        AmmData.PoolConfig calldata config\n', '        )\n', '        public\n', '    {\n', '        require(\n', '            bytes(config.poolName).length > 0 && bytes(config.tokenSymbol).length > 0,\n', '            "INVALID_NAME_OR_SYMBOL"\n', '        );\n', '        require(config.sharedConfig != address(0), "INVALID_SHARED_CONFIG");\n', '        require(config.tokens.length == config.weights.length, "INVALID_DATA");\n', '        require(config.tokens.length >= 2, "INVALID_DATA");\n', '        require(config.exchange != address(0), "INVALID_EXCHANGE");\n', '        require(config.accountID != 0, "INVALID_ACCOUNT_ID");\n', '        require(S.tokens.length == 0, "ALREADY_INITIALIZED");\n', '\n', '        S.sharedConfig = IAmmSharedConfig(config.sharedConfig);\n', '        IExchangeV3 exchange = IExchangeV3(config.exchange);\n', '        S.exchange = exchange;\n', '        S.exchangeOwner = exchange.owner();\n', '        S.exchangeDomainSeparator = exchange.getDomainSeparator();\n', '        S.accountID = config.accountID;\n', '        S.poolTokenID = exchange.getTokenID(address(this));\n', '        S.feeBips = config.feeBips;\n', '        S.domainSeparator = EIP712.hash(EIP712.Domain(config.poolName, "1.0.0", address(this)));\n', '\n', '        S.poolName = config.poolName;\n', '        S.symbol = config.tokenSymbol;\n', '\n', '        for (uint i = 0; i < config.tokens.length; i++) {\n', '            require(config.weights[i] > 0, "INVALID_TOKEN_WEIGHT");\n', '\n', '            address token = config.tokens[i];\n', '            S.tokens.push(AmmData.Token({\n', '                addr: token,\n', '                tokenID: exchange.getTokenID(token),\n', '                weight: config.weights[i]\n', '            }));\n', '        }\n', '\n', '        // Mint all liquidity tokens to the pool account on L2\n', '        S.balanceOf[address(this)] = AmmData.POOL_TOKEN_MINTED_SUPPLY();\n', '        S.allowance[address(this)][address(exchange.getDepositContract())] = uint(-1);\n', '        exchange.deposit(\n', '            address(this), // from\n', '            address(this), // to\n', '            address(this), // token\n', '            uint96(AmmData.POOL_TOKEN_MINTED_SUPPLY()),\n', '            new bytes(0)\n', '        );\n', '    }\n', '\n', "    // Anyone is able to shut down the pool when requests aren't being processed any more.\n", '    function shutdown(\n', '        AmmData.State storage S,\n', '        address               exitOwner\n', '        )\n', '        public\n', '    {\n', '        // If the exchange is in withdrawal mode allow the pool to be shutdown immediately\n', '        if (!S.exchange.isInWithdrawalMode()) {\n', '            uint64 validUntil = S.forcedExit[exitOwner].validUntil;\n', '            require(validUntil > 0 && validUntil < block.timestamp, "INVALID_CHALLENGE");\n', '\n', '            uint size = S.tokens.length;\n', '\n', '            for (uint i = 0; i < size; i++) {\n', '                S.exchange.forceWithdraw{value: msg.value / size}(\n', '                    address(this),\n', '                    S.tokens[i].addr,\n', '                    S.accountID\n', '                );\n', '            }\n', '        }\n', '        S.shutdownTimestamp = uint64(block.timestamp);\n', '        emit Shutdown(block.timestamp);\n', '    }\n', '\n', '    // Anyone is able to update the cached exchange owner to the current owner.\n', '    function updateExchangeOwner(AmmData.State storage S)\n', '        public\n', '    {\n', '        S.exchangeOwner = S.exchange.owner();\n', '    }\n', '}']