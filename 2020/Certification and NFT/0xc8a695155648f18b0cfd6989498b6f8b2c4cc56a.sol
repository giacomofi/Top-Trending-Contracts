['// File: contracts/IManager.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', 'contract IManager {\n', '    event SetController(address controller);\n', '    event ParameterUpdate(string param);\n', '\n', '    function setController(address _controller) external;\n', '}\n', '\n', '// File: contracts/zeppelin/Ownable.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/zeppelin/Pausable.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    */\n', '    function pause() public onlyOwner whenNotPaused {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to unpause, returns to normal state\n', '    */\n', '    function unpause() public onlyOwner whenPaused {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', '// File: contracts/IController.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', 'contract IController is Pausable {\n', '    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);\n', '\n', '    function setContractInfo(bytes32 _id, address _contractAddress, bytes20 _gitCommitHash) external;\n', '    function updateController(bytes32 _id, address _controller) external;\n', '    function getContract(bytes32 _id) public view returns (address);\n', '}\n', '\n', '// File: contracts/Manager.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', '\n', 'contract Manager is IManager {\n', '    // Controller that contract is registered with\n', '    IController public controller;\n', '\n', '    // Check if sender is controller\n', '    modifier onlyController() {\n', '        require(msg.sender == address(controller), "caller must be Controller");\n', '        _;\n', '    }\n', '\n', '    // Check if sender is controller owner\n', '    modifier onlyControllerOwner() {\n', '        require(msg.sender == controller.owner(), "caller must be Controller owner");\n', '        _;\n', '    }\n', '\n', '    // Check if controller is not paused\n', '    modifier whenSystemNotPaused() {\n', '        require(!controller.paused(), "system is paused");\n', '        _;\n', '    }\n', '\n', '    // Check if controller is paused\n', '    modifier whenSystemPaused() {\n', '        require(controller.paused(), "system is not paused");\n', '        _;\n', '    }\n', '\n', '    constructor(address _controller) public {\n', '        controller = IController(_controller);\n', '    }\n', '\n', '    /**\n', '     * @notice Set controller. Only callable by current controller\n', '     * @param _controller Controller contract address\n', '     */\n', '    function setController(address _controller) external onlyController {\n', '        controller = IController(_controller);\n', '\n', '        emit SetController(_controller);\n', '    }\n', '}\n', '\n', '// File: contracts/ManagerProxyTarget.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', '/**\n', ' * @title ManagerProxyTarget\n', ' * @notice The base contract that target contracts used by a proxy contract should inherit from\n', ' * @dev Both the target contract and the proxy contract (implemented as ManagerProxy) MUST inherit from ManagerProxyTarget in order to guarantee\n', ' that both contracts have the same storage layout. Differing storage layouts in a proxy contract and target contract can\n', ' potentially break the delegate proxy upgradeability mechanism\n', ' */\n', 'contract ManagerProxyTarget is Manager {\n', "    // Used to look up target contract address in controller's registry\n", '    bytes32 public targetContractId;\n', '}\n', '\n', '// File: contracts/bonding/IBondingManager.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '/**\n', ' * @title Interface for BondingManager\n', ' * TODO: switch to interface type\n', ' */\n', 'contract IBondingManager {\n', '    event TranscoderUpdate(address indexed transcoder, uint256 rewardCut, uint256 feeShare);\n', '    event TranscoderActivated(address indexed transcoder, uint256 activationRound);\n', '    event TranscoderDeactivated(address indexed transcoder, uint256 deactivationRound);\n', '    event TranscoderSlashed(address indexed transcoder, address finder, uint256 penalty, uint256 finderReward);\n', '    event Reward(address indexed transcoder, uint256 amount);\n', '    event Bond(address indexed newDelegate, address indexed oldDelegate, address indexed delegator, uint256 additionalAmount, uint256 bondedAmount);\n', '    event Unbond(address indexed delegate, address indexed delegator, uint256 unbondingLockId, uint256 amount, uint256 withdrawRound);\n', '    event Rebond(address indexed delegate, address indexed delegator, uint256 unbondingLockId, uint256 amount);\n', '    event WithdrawStake(address indexed delegator, uint256 unbondingLockId, uint256 amount, uint256 withdrawRound);\n', '    event WithdrawFees(address indexed delegator);\n', '    event EarningsClaimed(address indexed delegate, address indexed delegator, uint256 rewards, uint256 fees, uint256 startRound, uint256 endRound);\n', '\n', '    // Deprecated events\n', '    // These event signatures can be used to construct the appropriate topic hashes to filter for past logs corresponding\n', '    // to these deprecated events.\n', '    // event Bond(address indexed delegate, address indexed delegator);\n', '    // event Unbond(address indexed delegate, address indexed delegator);\n', '    // event WithdrawStake(address indexed delegator);\n', '    // event TranscoderUpdate(address indexed transcoder, uint256 pendingRewardCut, uint256 pendingFeeShare, uint256 pendingPricePerSegment, bool registered);\n', '    // event TranscoderEvicted(address indexed transcoder);\n', '    // event TranscoderResigned(address indexed transcoder);\n', '\n', '    // External functions\n', '    function updateTranscoderWithFees(address _transcoder, uint256 _fees, uint256 _round) external;\n', '    function slashTranscoder(address _transcoder, address _finder, uint256 _slashAmount, uint256 _finderFee) external;\n', '    function setCurrentRoundTotalActiveStake() external;\n', '\n', '    // Public functions\n', '    function getTranscoderPoolSize() public view returns (uint256);\n', '    function transcoderTotalStake(address _transcoder) public view returns (uint256);\n', '    function isActiveTranscoder(address _transcoder) public view returns (bool);\n', '    function getTotalBonded() public view returns (uint256);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/SortedDoublyLL.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', '/**\n', ' * @title A sorted doubly linked list with nodes sorted in descending order. Optionally accepts insert position hints\n', ' *\n', ' * Given a new node with a `key`, a hint is of the form `(prevId, nextId)` s.t. `prevId` and `nextId` are adjacent in the list.\n', ' * `prevId` is a node with a key >= `key` and `nextId` is a node with a key <= `key`. If the sender provides a hint that is a valid insert position\n', ' * the insert operation is a constant time storage write. However, the provided hint in a given transaction might be a valid insert position, but if other transactions are included first, when\n', ' * the given transaction is executed the provided hint may no longer be a valid insert position. For example, one of the nodes referenced might be removed or their keys may\n', ' * be updated such that the the pair of nodes in the hint no longer represent a valid insert position. If one of the nodes in the hint becomes invalid, we still try to use the other\n', ' * valid node as a starting point for finding the appropriate insert position. If both nodes in the hint become invalid, we use the head of the list as a starting point\n', ' * to find the appropriate insert position.\n', ' */\n', 'library SortedDoublyLL {\n', '    using SafeMath for uint256;\n', '\n', '    // Information for a node in the list\n', '    struct Node {\n', "        uint256 key;                     // Node's key used for sorting\n", '        address nextId;                  // Id of next node (smaller key) in the list\n', '        address prevId;                  // Id of previous node (larger key) in the list\n', '    }\n', '\n', '    // Information for the list\n', '    struct Data {\n', '        address head;                        // Head of the list. Also the node in the list with the largest key\n', '        address tail;                        // Tail of the list. Also the node in the list with the smallest key\n', '        uint256 maxSize;                     // Maximum size of the list\n', '        uint256 size;                        // Current size of the list\n', '        mapping (address => Node) nodes;     // Track the corresponding ids for each node in the list\n', '    }\n', '\n', '    /**\n', '     * @dev Set the maximum size of the list\n', '     * @param _size Maximum size\n', '     */\n', '    function setMaxSize(Data storage self, uint256 _size) public {\n', '        require(_size > self.maxSize, "new max size must be greater than old max size");\n', '\n', '        self.maxSize = _size;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a node to the list\n', "     * @param _id Node's id\n", "     * @param _key Node's key\n", '     * @param _prevId Id of previous node for the insert position\n', '     * @param _nextId Id of next node for the insert position\n', '     */\n', '    function insert(Data storage self, address _id, uint256 _key, address _prevId, address _nextId) public {\n', '        // List must not be full\n', '        require(!isFull(self), "list is full");\n', '        // List must not already contain node\n', '        require(!contains(self, _id), "node already in list");\n', '        // Node id must not be null\n', '        require(_id != address(0), "node id is null");\n', '        // Key must be non-zero\n', '        require(_key > 0, "key is zero");\n', '\n', '        address prevId = _prevId;\n', '        address nextId = _nextId;\n', '\n', '        if (!validInsertPosition(self, _key, prevId, nextId)) {\n', "            // Sender's hint was not a valid insert position\n", "            // Use sender's hint to find a valid insert position\n", '            (prevId, nextId) = findInsertPosition(self, _key, prevId, nextId);\n', '        }\n', '\n', '        self.nodes[_id].key = _key;\n', '\n', '        if (prevId == address(0) && nextId == address(0)) {\n', '            // Insert as head and tail\n', '            self.head = _id;\n', '            self.tail = _id;\n', '        } else if (prevId == address(0)) {\n', '            // Insert before `prevId` as the head\n', '            self.nodes[_id].nextId = self.head;\n', '            self.nodes[self.head].prevId = _id;\n', '            self.head = _id;\n', '        } else if (nextId == address(0)) {\n', '            // Insert after `nextId` as the tail\n', '            self.nodes[_id].prevId = self.tail;\n', '            self.nodes[self.tail].nextId = _id;\n', '            self.tail = _id;\n', '        } else {\n', '            // Insert at insert position between `prevId` and `nextId`\n', '            self.nodes[_id].nextId = nextId;\n', '            self.nodes[_id].prevId = prevId;\n', '            self.nodes[prevId].nextId = _id;\n', '            self.nodes[nextId].prevId = _id;\n', '        }\n', '\n', '        self.size = self.size.add(1);\n', '    }\n', '\n', '    /**\n', '     * @dev Remove a node from the list\n', "     * @param _id Node's id\n", '     */\n', '    function remove(Data storage self, address _id) public {\n', '        // List must contain the node\n', '        require(contains(self, _id), "node not in list");\n', '\n', '        if (self.size > 1) {\n', '            // List contains more than a single node\n', '            if (_id == self.head) {\n', '                // The removed node is the head\n', '                // Set head to next node\n', '                self.head = self.nodes[_id].nextId;\n', '                // Set prev pointer of new head to null\n', '                self.nodes[self.head].prevId = address(0);\n', '            } else if (_id == self.tail) {\n', '                // The removed node is the tail\n', '                // Set tail to previous node\n', '                self.tail = self.nodes[_id].prevId;\n', '                // Set next pointer of new tail to null\n', '                self.nodes[self.tail].nextId = address(0);\n', '            } else {\n', '                // The removed node is neither the head nor the tail\n', '                // Set next pointer of previous node to the next node\n', '                self.nodes[self.nodes[_id].prevId].nextId = self.nodes[_id].nextId;\n', '                // Set prev pointer of next node to the previous node\n', '                self.nodes[self.nodes[_id].nextId].prevId = self.nodes[_id].prevId;\n', '            }\n', '        } else {\n', '            // List contains a single node\n', '            // Set the head and tail to null\n', '            self.head = address(0);\n', '            self.tail = address(0);\n', '        }\n', '\n', '        delete self.nodes[_id];\n', '        self.size = self.size.sub(1);\n', '    }\n', '\n', '    /**\n', '     * @dev Update the key of a node in the list\n', "     * @param _id Node's id\n", "     * @param _newKey Node's new key\n", '     * @param _prevId Id of previous node for the new insert position\n', '     * @param _nextId Id of next node for the new insert position\n', '     */\n', '    function updateKey(Data storage self, address _id, uint256 _newKey, address _prevId, address _nextId) public {\n', '        // List must contain the node\n', '        require(contains(self, _id), "node not in list");\n', '\n', '        // Remove node from the list\n', '        remove(self, _id);\n', '\n', '        if (_newKey > 0) {\n', '            // Insert node if it has a non-zero key\n', '            insert(self, _id, _newKey, _prevId, _nextId);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if the list contains a node\n', '     * @param _id Address of transcoder\n', "     * @return true if '_id' is in list\n", '     */\n', '    function contains(Data storage self, address _id) public view returns (bool) {\n', '        // List only contains non-zero keys, so if key is non-zero the node exists\n', '        return self.nodes[_id].key > 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if the list is full\n', '     * @return true if list is full\n', '     */\n', '    function isFull(Data storage self) public view returns (bool) {\n', '        return self.size == self.maxSize;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if the list is empty\n', '     * @return true if list is empty\n', '     */\n', '    function isEmpty(Data storage self) public view returns (bool) {\n', '        return self.size == 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current size of the list\n', '     * @return current size of the list\n', '     */\n', '    function getSize(Data storage self) public view returns (uint256) {\n', '        return self.size;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the maximum size of the list\n', '     */\n', '    function getMaxSize(Data storage self) public view returns (uint256) {\n', '        return self.maxSize;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the key of a node in the list\n', "     * @param _id Node's id\n", "     * @return key for node with '_id'\n", '     */\n', '    function getKey(Data storage self, address _id) public view returns (uint256) {\n', '        return self.nodes[_id].key;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the first node in the list (node with the largest key)\n', '     * @return address for the head of the list\n', '     */\n', '    function getFirst(Data storage self) public view returns (address) {\n', '        return self.head;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the last node in the list (node with the smallest key)\n', '     * @return address for the tail of the list\n', '     */\n', '    function getLast(Data storage self) public view returns (address) {\n', '        return self.tail;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the next node (with a smaller key) in the list for a given node\n', "     * @param _id Node's id\n", "     * @return address for the node following node in list with '_id'\n", '     */\n', '    function getNext(Data storage self, address _id) public view returns (address) {\n', '        return self.nodes[_id].nextId;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the previous node (with a larger key) in the list for a given node\n', "     * @param _id Node's id\n", "     * address for the node before node in list with '_id'\n", '     */\n', '    function getPrev(Data storage self, address _id) public view returns (address) {\n', '        return self.nodes[_id].prevId;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if a pair of nodes is a valid insertion point for a new node with the given key\n', "     * @param _key Node's key\n", '     * @param _prevId Id of previous node for the insert position\n', '     * @param _nextId Id of next node for the insert position\n', '     * @return if the insert position is valid\n', '     */\n', '    function validInsertPosition(Data storage self, uint256 _key, address _prevId, address _nextId) public view returns (bool) {\n', '        if (_prevId == address(0) && _nextId == address(0)) {\n', '            // `(null, null)` is a valid insert position if the list is empty\n', '            return isEmpty(self);\n', '        } else if (_prevId == address(0)) {\n', '            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list\n', '            return self.head == _nextId && _key >= self.nodes[_nextId].key;\n', '        } else if (_nextId == address(0)) {\n', '            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list\n', '            return self.tail == _prevId && _key <= self.nodes[_prevId].key;\n', '        } else {\n', "            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_key` falls between the two nodes' keys\n", '            return self.nodes[_prevId].nextId == _nextId && self.nodes[_prevId].key >= _key && _key >= self.nodes[_nextId].key;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Descend the list (larger keys to smaller keys) to find a valid insert position\n', "     * @param _key Node's key\n", '     * @param _startId Id of node to start ascending the list from\n', '     */\n', '    function descendList(Data storage self, uint256 _key, address _startId) private view returns (address, address) {\n', '        // If `_startId` is the head, check if the insert position is before the head\n', '        if (self.head == _startId && _key >= self.nodes[_startId].key) {\n', '            return (address(0), _startId);\n', '        }\n', '\n', '        address prevId = _startId;\n', '        address nextId = self.nodes[prevId].nextId;\n', '\n', '        // Descend the list until we reach the end or until we find a valid insert position\n', '        while (prevId != address(0) && !validInsertPosition(self, _key, prevId, nextId)) {\n', '            prevId = self.nodes[prevId].nextId;\n', '            nextId = self.nodes[prevId].nextId;\n', '        }\n', '\n', '        return (prevId, nextId);\n', '    }\n', '\n', '    /**\n', '     * @dev Ascend the list (smaller keys to larger keys) to find a valid insert position\n', "     * @param _key Node's key\n", '     * @param _startId Id of node to start descending the list from\n', '     */\n', '    function ascendList(Data storage self, uint256 _key, address _startId) private view returns (address, address) {\n', '        // If `_startId` is the tail, check if the insert position is after the tail\n', '        if (self.tail == _startId && _key <= self.nodes[_startId].key) {\n', '            return (_startId, address(0));\n', '        }\n', '\n', '        address nextId = _startId;\n', '        address prevId = self.nodes[nextId].prevId;\n', '\n', '        // Ascend the list until we reach the end or until we find a valid insertion point\n', '        while (nextId != address(0) && !validInsertPosition(self, _key, prevId, nextId)) {\n', '            nextId = self.nodes[nextId].prevId;\n', '            prevId = self.nodes[nextId].prevId;\n', '        }\n', '\n', '        return (prevId, nextId);\n', '    }\n', '\n', '    /**\n', '     * @dev Find the insert position for a new node with the given key\n', "     * @param _key Node's key\n", '     * @param _prevId Id of previous node for the insert position\n', '     * @param _nextId Id of next node for the insert position\n', '     */\n', '    function findInsertPosition(Data storage self, uint256 _key, address _prevId, address _nextId) private view returns (address, address) {\n', '        address prevId = _prevId;\n', '        address nextId = _nextId;\n', '\n', '        if (prevId != address(0)) {\n', '            if (!contains(self, prevId) || _key > self.nodes[prevId].key) {\n', '                // `prevId` does not exist anymore or now has a smaller key than the given key\n', '                prevId = address(0);\n', '            }\n', '        }\n', '\n', '        if (nextId != address(0)) {\n', '            if (!contains(self, nextId) || _key < self.nodes[nextId].key) {\n', '                // `nextId` does not exist anymore or now has a larger key than the given key\n', '                nextId = address(0);\n', '            }\n', '        }\n', '\n', '        if (prevId == address(0) && nextId == address(0)) {\n', '            // No hint - descend list starting from head\n', '            return descendList(self, _key, self.head);\n', '        } else if (prevId == address(0)) {\n', '            // No `prevId` for hint - ascend list starting from `nextId`\n', '            return ascendList(self, _key, nextId);\n', '        } else if (nextId == address(0)) {\n', '            // No `nextId` for hint - descend list starting from `prevId`\n', '            return descendList(self, _key, prevId);\n', '        } else {\n', '            // Descend list starting from `prevId`\n', '            return descendList(self, _key, prevId);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/MathUtils.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', 'library MathUtils {\n', '    using SafeMath for uint256;\n', '\n', '    // Divisor used for representing percentages\n', '    uint256 public constant PERC_DIVISOR = 1000000;\n', '\n', '    /**\n', '     * @dev Returns whether an amount is a valid percentage out of PERC_DIVISOR\n', '     * @param _amount Amount that is supposed to be a percentage\n', '     */\n', '    function validPerc(uint256 _amount) internal pure returns (bool) {\n', '        return _amount <= PERC_DIVISOR;\n', '    }\n', '\n', '    /**\n', '     * @dev Compute percentage of a value with the percentage represented by a fraction\n', '     * @param _amount Amount to take the percentage of\n', '     * @param _fracNum Numerator of fraction representing the percentage\n', '     * @param _fracDenom Denominator of fraction representing the percentage\n', '     */\n', '    function percOf(uint256 _amount, uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\n', '        return _amount.mul(percPoints(_fracNum, _fracDenom)).div(PERC_DIVISOR);\n', '    }\n', '\n', '    /**\n', '     * @dev Compute percentage of a value with the percentage represented by a fraction over PERC_DIVISOR\n', '     * @param _amount Amount to take the percentage of\n', '     * @param _fracNum Numerator of fraction representing the percentage with PERC_DIVISOR as the denominator\n', '     */\n', '    function percOf(uint256 _amount, uint256 _fracNum) internal pure returns (uint256) {\n', '        return _amount.mul(_fracNum).div(PERC_DIVISOR);\n', '    }\n', '\n', '    /**\n', '     * @dev Compute percentage representation of a fraction\n', '     * @param _fracNum Numerator of fraction represeting the percentage\n', '     * @param _fracDenom Denominator of fraction represeting the percentage\n', '     */\n', '    function percPoints(uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\n', '        return _fracNum.mul(PERC_DIVISOR).div(_fracDenom);\n', '    }\n', '}\n', '\n', '// File: contracts/bonding/libraries/EarningsPool.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title EarningsPool\n', ' * @dev Manages reward and fee pools for delegators and transcoders\n', ' */\n', 'library EarningsPool {\n', '    using SafeMath for uint256;\n', '\n', '    // Represents rewards and fees to be distributed to delegators\n', '    // The `hasTranscoderRewardFeePool` flag was introduced so that EarningsPool.Data structs used by the BondingManager\n', '    // created with older versions of this library can be differentiated from EarningsPool.Data structs used by the BondingManager\n', '    // created with a newer version of this library. If the flag is true, then the struct was initialized using the `init` function\n', '    // using a newer version of this library meaning that it is using separate transcoder reward and fee pools\n', '    struct Data {\n', '        uint256 rewardPool;                // Delegator rewards. If `hasTranscoderRewardFeePool` is false, this will contain transcoder rewards as well\n', '        uint256 feePool;                   // Delegator fees. If `hasTranscoderRewardFeePool` is false, this will contain transcoder fees as well\n', "        uint256 totalStake;                // Transcoder's total stake during the earnings pool's round\n", '        uint256 claimableStake;            // Stake that can be used to claim portions of the fee and reward pools\n', "        uint256 transcoderRewardCut;       // Transcoder's reward cut during the earnings pool's round\n", "        uint256 transcoderFeeShare;        // Transcoder's fee share during the earnings pool's round\n", '        uint256 transcoderRewardPool;      // Transcoder rewards. If `hasTranscoderRewardFeePool` is false, this should always be 0\n', '        uint256 transcoderFeePool;         // Transcoder fees. If `hasTranscoderRewardFeePool` is false, this should always be 0\n', '        bool hasTranscoderRewardFeePool;   // Flag to indicate if the earnings pool has separate transcoder reward and fee pools\n', '\n', '        // LIP-36 (https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-36.md) fields\n', '        // See EarningsPoolLIP36.sol\n', '        uint256 cumulativeRewardFactor;\n', '        uint256 cumulativeFeeFactor;\n', '    }\n', '\n', '    /**\n', '     * @dev Sets transcoderRewardCut and transcoderFeeshare for an EarningsPool\n', '     * @param earningsPool Storage pointer to EarningsPool struct\n', "     * @param _rewardCut Reward cut of transcoder during the earnings pool's round\n", "     * @param _feeShare Fee share of transcoder during the earnings pool's round\n", '     */\n', '    function setCommission(EarningsPool.Data storage earningsPool, uint256 _rewardCut, uint256 _feeShare) internal {\n', '        earningsPool.transcoderRewardCut = _rewardCut;\n', '        earningsPool.transcoderFeeShare = _feeShare;\n', '        // Prior to LIP-36, we set this flag to true here to differentiate between EarningsPool structs created using older versions of this library.\n', '        // When using a version of this library after the introduction of this flag to read an EarningsPool struct created using an older version\n', '        // of this library, this flag should be false in the returned struct because the default value for EVM storage is 0\n', '        // earningsPool.hasTranscoderRewardFeePool = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Sets totalStake for an EarningsPool\n', '     * @param earningsPool Storage pointer to EarningsPool struct\n', "     * @param _stake Total stake of the transcoder during the earnings pool's round\n", '     */\n', '    function setStake(EarningsPool.Data storage earningsPool, uint256 _stake) internal {\n', '        earningsPool.totalStake = _stake;\n', '        // Prior to LIP-36, we also set the claimableStake\n', '        // earningsPool.claimableStake = _stake;\n', '    }\n', '\n', '    /**\n', '     * @dev Return whether this earnings pool has claimable shares i.e. is there unclaimed stake\n', '     * @param earningsPool Storage pointer to EarningsPool struct\n', '     */\n', '    function hasClaimableShares(EarningsPool.Data storage earningsPool) internal view returns (bool) {\n', '        return earningsPool.claimableStake > 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the fee pool share for a claimant. If the claimant is a transcoder, include transcoder fees as well.\n', '     * @param earningsPool Storage pointer to EarningsPool struct\n', '     * @param _stake Stake of claimant\n', '     * @param _isTranscoder Flag indicating whether the claimant is a transcoder\n', '     */\n', '    function feePoolShare(EarningsPool.Data storage earningsPool, uint256 _stake, bool _isTranscoder) internal view returns (uint256) {\n', '        uint256 delegatorFees = 0;\n', '        uint256 transcoderFees = 0;\n', '\n', '        if (earningsPool.hasTranscoderRewardFeePool) {\n', '            (delegatorFees, transcoderFees) = feePoolShareWithTranscoderRewardFeePool(earningsPool, _stake, _isTranscoder);\n', '        } else {\n', '            (delegatorFees, transcoderFees) = feePoolShareNoTranscoderRewardFeePool(earningsPool, _stake, _isTranscoder);\n', '        }\n', '\n', '        return delegatorFees.add(transcoderFees);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the reward pool share for a claimant. If the claimant is a transcoder, include transcoder rewards as well.\n', '     * @param earningsPool Storage pointer to EarningsPool struct\n', '     * @param _stake Stake of claimant\n', '     * @param _isTranscoder Flag indicating whether the claimant is a transcoder\n', '     */\n', '    function rewardPoolShare(EarningsPool.Data storage earningsPool, uint256 _stake, bool _isTranscoder) internal view returns (uint256) {\n', '        uint256 delegatorRewards = 0;\n', '        uint256 transcoderRewards = 0;\n', '\n', '        if (earningsPool.hasTranscoderRewardFeePool) {\n', '            (delegatorRewards, transcoderRewards) = rewardPoolShareWithTranscoderRewardFeePool(earningsPool, _stake, _isTranscoder);\n', '        } else {\n', '            (delegatorRewards, transcoderRewards) = rewardPoolShareNoTranscoderRewardFeePool(earningsPool, _stake, _isTranscoder);\n', '        }\n', '\n', '        return delegatorRewards.add(transcoderRewards);\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to calculate fee pool share if the earnings pool has a separate transcoder fee pool\n', '     * @param earningsPool Storage pointer to EarningsPool struct\n', '     * @param _stake Stake of claimant\n', '     * @param _isTranscoder Flag indicating whether the claimant is a transcoder\n', '     */\n', '    function feePoolShareWithTranscoderRewardFeePool(\n', '        EarningsPool.Data storage earningsPool,\n', '        uint256 _stake,\n', '        bool _isTranscoder\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256, uint256)\n', '    {\n', '        // If there is no claimable stake, the fee pool share is 0\n', "        // If there is claimable stake, calculate fee pool share based on remaining amount in fee pool, remaining claimable stake and claimant's stake\n", '        uint256 delegatorFees = earningsPool.claimableStake > 0 ? MathUtils.percOf(earningsPool.feePool, _stake, earningsPool.claimableStake) : 0;\n', '\n', '        // If claimant is a transcoder, include transcoder fee pool as well\n', '        return _isTranscoder ? (delegatorFees, earningsPool.transcoderFeePool) : (delegatorFees, 0);\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to calculate reward pool share if the earnings pool has a separate transcoder reward pool\n', '     * @param earningsPool Storage pointer to EarningsPool struct\n', '     * @param _stake Stake of claimant\n', '     * @param _isTranscoder Flag indicating whether the claimant is a transcoder\n', '     */\n', '    function rewardPoolShareWithTranscoderRewardFeePool(\n', '        EarningsPool.Data storage earningsPool,\n', '        uint256 _stake,\n', '        bool _isTranscoder\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256, uint256)\n', '    {\n', '        // If there is no claimable stake, the reward pool share is 0\n', "        // If there is claimable stake, calculate reward pool share based on remaining amount in reward pool, remaining claimable stake and claimant's stake\n", '        uint256 delegatorRewards = earningsPool.claimableStake > 0 ? MathUtils.percOf(earningsPool.rewardPool, _stake, earningsPool.claimableStake) : 0;\n', '\n', '        // If claimant is a transcoder, include transcoder reward pool as well\n', '        return _isTranscoder ? (delegatorRewards, earningsPool.transcoderRewardPool) : (delegatorRewards, 0);\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to calculate the fee pool share if the earnings pool does not have a separate transcoder fee pool\n', '     * This implements calculation logic from a previous version of this library\n', '     * @param earningsPool Storage pointer to EarningsPool struct\n', '     * @param _stake Stake of claimant\n', '     * @param _isTranscoder Flag indicating whether the claimant is a transcoder\n', '     */\n', '    function feePoolShareNoTranscoderRewardFeePool(\n', '        EarningsPool.Data storage earningsPool,\n', '        uint256 _stake,\n', '        bool _isTranscoder\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 transcoderFees = 0;\n', '        uint256 delegatorFees = 0;\n', '\n', '        if (earningsPool.claimableStake > 0) {\n', '            uint256 delegatorsFees = MathUtils.percOf(earningsPool.feePool, earningsPool.transcoderFeeShare);\n', '            transcoderFees = earningsPool.feePool.sub(delegatorsFees);\n', '            delegatorFees = MathUtils.percOf(delegatorsFees, _stake, earningsPool.claimableStake);\n', '        }\n', '\n', '        if (_isTranscoder) {\n', '            return (delegatorFees, transcoderFees);\n', '        } else {\n', '            return (delegatorFees, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Helper function to calculate the reward pool share if the earnings pool does not have a separate transcoder reward pool\n', '     * This implements calculation logic from a previous version of this library\n', '     * @param earningsPool Storage pointer to EarningsPool struct\n', '     * @param _stake Stake of claimant\n', '     * @param _isTranscoder Flag indicating whether the claimant is a transcoder\n', '     */\n', '    function rewardPoolShareNoTranscoderRewardFeePool(\n', '        EarningsPool.Data storage earningsPool,\n', '        uint256 _stake,\n', '        bool _isTranscoder\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 transcoderRewards = 0;\n', '        uint256 delegatorRewards = 0;\n', '\n', '        if (earningsPool.claimableStake > 0) {\n', '            transcoderRewards = MathUtils.percOf(earningsPool.rewardPool, earningsPool.transcoderRewardCut);\n', '            delegatorRewards = MathUtils.percOf(earningsPool.rewardPool.sub(transcoderRewards), _stake, earningsPool.claimableStake);\n', '        }\n', '\n', '        if (_isTranscoder) {\n', '            return (delegatorRewards, transcoderRewards);\n', '        } else {\n', '            return (delegatorRewards, 0);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/bonding/libraries/EarningsPoolLIP36.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', '\n', 'library EarningsPoolLIP36 {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * @notice Update the cumulative fee factor stored in an earnings pool with new fees\n', '     * @param earningsPool Storage pointer to EarningsPools.Data struct\n', '     * @param _prevEarningsPool In-memory EarningsPool.Data struct that stores the previous cumulative reward and fee factors\n', '     * @param _fees Amount of new fees\n', '     */\n', '    function updateCumulativeFeeFactor(EarningsPool.Data storage earningsPool, EarningsPool.Data memory _prevEarningsPool, uint256 _fees) internal {\n', '        uint256 prevCumulativeFeeFactor = _prevEarningsPool.cumulativeFeeFactor;\n', '        uint256 prevCumulativeRewardFactor = _prevEarningsPool.cumulativeRewardFactor != 0 ? _prevEarningsPool.cumulativeRewardFactor : MathUtils.percPoints(1,1);\n', '\n', '        // Initialize the cumulativeFeeFactor when adding fees for the first time\n', '        if (earningsPool.cumulativeFeeFactor == 0) {\n', '            earningsPool.cumulativeFeeFactor = prevCumulativeFeeFactor.add(\n', '                MathUtils.percOf(prevCumulativeRewardFactor, _fees, earningsPool.totalStake)\n', '            );\n', '            return;\n', '        }\n', '\n', '        earningsPool.cumulativeFeeFactor = earningsPool.cumulativeFeeFactor.add(\n', '            MathUtils.percOf(prevCumulativeRewardFactor, _fees, earningsPool.totalStake)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Update the cumulative reward factor stored in an earnings pool with new rewards\n', '     * @param earningsPool Storage pointer to EarningsPool.Data struct\n', '     * @param _prevEarningsPool Storage pointer to EarningsPool.Data struct that stores the previous cumulative reward factor\n', '     * @param _rewards Amount of new rewards\n', '     */\n', '    function updateCumulativeRewardFactor(EarningsPool.Data storage earningsPool, EarningsPool.Data storage _prevEarningsPool, uint256 _rewards) internal {\n', '        uint256 prevCumulativeRewardFactor = _prevEarningsPool.cumulativeRewardFactor != 0 ? _prevEarningsPool.cumulativeRewardFactor : MathUtils.percPoints(1,1);\n', '\n', '        earningsPool.cumulativeRewardFactor = prevCumulativeRewardFactor.add(\n', '            MathUtils.percOf(prevCumulativeRewardFactor, _rewards, earningsPool.totalStake)\n', '        );\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see `ERC20Detailed`.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when `approve` or `transferFrom` are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * > Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an `Approval` event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to `approve`. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of the `IERC20` interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using `_mint`.\n', ' * For a generic mechanism see `ERC20Mintable`.\n', ' *\n', ' * *For a detailed writeup see our guide [How to implement supply\n', ' * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See `IERC20.approve`.\n', ' */\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev See `IERC20.totalSupply`.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.balanceOf`.\n', '     */\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.transfer`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.allowance`.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.approve`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.transferFrom`.\n', '     *\n', '     * Emits an `Approval` event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of `ERC20`;\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `value`.\n', "     * - the caller must have allowance for `sender`'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to `approve` that can be used as a mitigation for\n', '     * problems described in `IERC20.approve`.\n', '     *\n', '     * Emits an `Approval` event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to `approve` that can be used as a mitigation for\n', '     * problems described in `IERC20.approve`.\n', '     *\n', '     * Emits an `Approval` event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to `transfer`, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _balances[sender] = _balances[sender].sub(amount);\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a `Transfer` event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '     /**\n', '     * @dev Destoys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a `Transfer` event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 value) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _totalSupply = _totalSupply.sub(value);\n', '        _balances[account] = _balances[account].sub(value);\n', '        emit Transfer(account, address(0), value);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an `Approval` event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 value) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n', "     * from the caller's allowance.\n", '     *\n', '     * See `_burn` and `_approve`.\n', '     */\n', '    function _burnFrom(address account, uint256 amount) internal {\n', '        _burn(account, amount);\n', '        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n', '    }\n', '}\n', '\n', '// File: contracts/token/ILivepeerToken.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', '\n', 'contract ILivepeerToken is ERC20, Ownable {\n', '    function mint(address _to, uint256 _amount) public returns (bool);\n', '    function burn(uint256 _amount) public;\n', '}\n', '\n', '// File: contracts/token/IMinter.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '\n', '/**\n', ' * @title Minter interface\n', ' */\n', 'contract IMinter {\n', '    // Events\n', '    event SetCurrentRewardTokens(uint256 currentMintableTokens, uint256 currentInflation);\n', '\n', '    // External functions\n', '    function createReward(uint256 _fracNum, uint256 _fracDenom) external returns (uint256);\n', '    function trustedTransferTokens(address _to, uint256 _amount) external;\n', '    function trustedBurnTokens(uint256 _amount) external;\n', '    function trustedWithdrawETH(address payable _to, uint256 _amount) external;\n', '    function depositETH() external payable returns (bool);\n', '    function setCurrentRewardTokens() external;\n', '    function currentMintableTokens() external view returns (uint256);\n', '    function currentMintedTokens() external view returns (uint256);\n', '    // Public functions\n', '    function getController() public view returns (IController);\n', '}\n', '\n', '// File: contracts/rounds/IRoundsManager.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', '/**\n', ' * @title RoundsManager interface\n', ' */\n', 'contract IRoundsManager {\n', '    // Events\n', '    event NewRound(uint256 indexed round, bytes32 blockHash);\n', '\n', '    // Deprecated events\n', '    // These event signatures can be used to construct the appropriate topic hashes to filter for past logs corresponding\n', '    // to these deprecated events.\n', '    // event NewRound(uint256 round)\n', '\n', '    // External functions\n', '    function initializeRound() external;\n', '    function lipUpgradeRound(uint256 _lip) external view returns (uint256);\n', '\n', '    // Public functions\n', '    function blockNum() public view returns (uint256);\n', '    function blockHash(uint256 _block) public view returns (bytes32);\n', '    function blockHashForRound(uint256 _round) public view returns (bytes32);\n', '    function currentRound() public view returns (uint256);\n', '    function currentRoundStartBlock() public view returns (uint256);\n', '    function currentRoundInitialized() public view returns (bool);\n', '    function currentRoundLocked() public view returns (bool);\n', '}\n', '\n', '// File: contracts/snapshots/IMerkleSnapshot.sol\n', '\n', 'pragma solidity ^0.5.11;\n', '\n', '\n', 'contract IMerkleSnapshot {\n', '    function verify(bytes32 _id, bytes32[] calldata _proof, bytes32 _leaf) external view returns (bool);\n', '}\n', '\n', '// File: contracts/bonding/BondingManager.sol\n', '\n', 'pragma solidity 0.5.11;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title BondingManager\n', ' * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol\n', ' */\n', 'contract BondingManager is ManagerProxyTarget, IBondingManager {\n', '    using SafeMath for uint256;\n', '    using SortedDoublyLL for SortedDoublyLL.Data;\n', '    using EarningsPool for EarningsPool.Data;\n', '    using EarningsPoolLIP36 for EarningsPool.Data;\n', '\n', '    // Constants\n', '    // Occurances are replaced at compile time\n', '    // and computed to a single value if possible by the optimizer\n', '    uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;\n', '\n', '    // Time between unbonding and possible withdrawl in rounds\n', '    uint64 public unbondingPeriod;\n', '    // DEPRECATED - DO NOT USE\n', '    uint256 public numActiveTranscodersDEPRECATED;\n', '    // Max number of rounds that a caller can claim earnings for at once\n', '    uint256 public maxEarningsClaimsRounds;\n', '\n', "    // Represents a transcoder's current state\n", '    struct Transcoder {\n', '        uint256 lastRewardRound;                                        // Last round that the transcoder called reward\n', '        uint256 rewardCut;                                              // % of reward paid to transcoder by a delegator\n', '        uint256 feeShare;                                               // % of fees paid to delegators by transcoder\n', '        uint256 pricePerSegmentDEPRECATED;                              // DEPRECATED - DO NOT USE\n', '        uint256 pendingRewardCutDEPRECATED;                             // DEPRECATED - DO NOT USE\n', '        uint256 pendingFeeShareDEPRECATED;                              // DEPRECATED - DO NOT USE\n', '        uint256 pendingPricePerSegmentDEPRECATED;                       // DEPRECATED - DO NOT USE\n', '        mapping (uint256 => EarningsPool.Data) earningsPoolPerRound;    // Mapping of round => earnings pool for the round\n', '        uint256 lastActiveStakeUpdateRound;                             // Round for which the stake was last updated while the transcoder is active\n', '        uint256 activationRound;                                        // Round in which the transcoder became active - 0 if inactive\n', '        uint256 deactivationRound;                                      // Round in which the transcoder will become inactive\n', "        uint256 activeCumulativeRewards;                                // The transcoder's cumulative rewards that are active in the current round\n", "        uint256 cumulativeRewards;                                      // The transcoder's cumulative rewards (earned via the its active staked rewards and its reward cut).\n", "        uint256 cumulativeFees;                                         // The transcoder's cumulative fees (earned via the its active staked rewards and its fee share)\n", '        uint256 lastFeeRound;                                           // Latest round in which the transcoder received fees\n', '    }\n', '\n', '    // The various states a transcoder can be in\n', '    enum TranscoderStatus { NotRegistered, Registered }\n', '\n', "    // Represents a delegator's current state\n", '    struct Delegator {\n', '        uint256 bondedAmount;                    // The amount of bonded tokens\n', '        uint256 fees;                            // The amount of fees collected\n', '        address delegateAddress;                 // The address delegated to\n', '        uint256 delegatedAmount;                 // The amount of tokens delegated to the delegator\n', '        uint256 startRound;                      // The round the delegator transitions to bonded phase and is delegated to someone\n', '        uint256 withdrawRoundDEPRECATED;         // DEPRECATED - DO NOT USE\n', '        uint256 lastClaimRound;                  // The last round during which the delegator claimed its earnings\n', '        uint256 nextUnbondingLockId;             // ID for the next unbonding lock created\n', '        mapping (uint256 => UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID => unbonding lock\n', '    }\n', '\n', '    // The various states a delegator can be in\n', '    enum DelegatorStatus { Pending, Bonded, Unbonded }\n', '\n', '    // Represents an amount of tokens that are being unbonded\n', '    struct UnbondingLock {\n', '        uint256 amount;              // Amount of tokens being unbonded\n', '        uint256 withdrawRound;       // Round at which unbonding period is over and tokens can be withdrawn\n', '    }\n', '\n', '    // Keep track of the known transcoders and delegators\n', '    mapping (address => Delegator) private delegators;\n', '    mapping (address => Transcoder) private transcoders;\n', '\n', '    // DEPRECATED - DO NOT USE\n', '    // The function getTotalBonded() no longer uses this variable\n', '    // and instead calculates the total bonded value separately\n', '    uint256 private totalBondedDEPRECATED;\n', '\n', '    // DEPRECATED - DO NOT USE\n', '    SortedDoublyLL.Data private transcoderPoolDEPRECATED;\n', '\n', '    // DEPRECATED - DO NOT USE\n', '    struct ActiveTranscoderSetDEPRECATED {\n', '        address[] transcoders;\n', '        mapping (address => bool) isActive;\n', '        uint256 totalStake;\n', '    }\n', '\n', '    // DEPRECATED - DO NOT USE\n', '    mapping (uint256 => ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;\n', '\n', '    // The total active stake (sum of the stake of active set members) for the current round\n', '    uint256 public currentRoundTotalActiveStake;\n', '    // The total active stake (sum of the stake of active set members) for the next round\n', '    uint256 public nextRoundTotalActiveStake;\n', '\n', '    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.\n', '    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders\n', '    // in the pool are locked into the active set for round N + 1\n', '    SortedDoublyLL.Data private transcoderPoolV2;\n', '\n', '    // Check if sender is TicketBroker\n', '    modifier onlyTicketBroker() {\n', '        _onlyTicketBroker();\n', '        _;\n', '    }\n', '\n', '    // Check if sender is RoundsManager\n', '    modifier onlyRoundsManager() {\n', '        _onlyRoundsManager();\n', '        _;\n', '    }\n', '\n', '    // Check if sender is Verifier\n', '    modifier onlyVerifier() {\n', '        _onlyVerifier();\n', '        _;\n', '    }\n', '\n', '    // Check if current round is initialized\n', '    modifier currentRoundInitialized() {\n', '        _currentRoundInitialized();\n', '        _;\n', '    }\n', '\n', '    // Automatically claim earnings from lastClaimRound through the current round\n', '    modifier autoClaimEarnings() {\n', '        _autoClaimEarnings();\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n', '     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions\n', '     * should be used to initialize state variables post-deployment:\n', '     * - setUnbondingPeriod()\n', '     * - setNumActiveTranscoders()\n', '     * - setMaxEarningsClaimsRounds()\n', '     * @param _controller Address of Controller that this contract will be registered with\n', '     */\n', '    constructor(address _controller) public Manager(_controller) {}\n', '\n', '    /**\n', '     * @notice Set unbonding period. Only callable by Controller owner\n', '     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal\n', '     */\n', '    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {\n', '        unbondingPeriod = _unbondingPeriod;\n', '\n', '        emit ParameterUpdate("unbondingPeriod");\n', '    }\n', '\n', '    /**\n', '     * @notice Set maximum number of active transcoders. Only callable by Controller owner\n', '     * @param _numActiveTranscoders Number of active transcoders\n', '     */\n', '    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\n', '        transcoderPoolV2.setMaxSize(_numActiveTranscoders);\n', '\n', '        emit ParameterUpdate("numActiveTranscoders");\n', '    }\n', '\n', '    /**\n', '     * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner\n', '     * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once\n', '     */\n', '    function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {\n', '        maxEarningsClaimsRounds = _maxEarningsClaimsRounds;\n', '\n', '        emit ParameterUpdate("maxEarningsClaimsRounds");\n', '    }\n', '\n', '    /**\n', '     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it\n', '     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR\n', '     * @param _rewardCut % of reward paid to transcoder by a delegator\n', '     * @param _feeShare % of fees paid to delegators by a transcoder\n', '     */\n', '    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {\n', '        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));\n', '    }\n', '\n', '    /**\n', '     * @notice Delegate stake towards a specific address\n', '     * @param _amount The amount of tokens to stake\n', '     * @param _to The address of the transcoder to stake towards\n', '     */\n', '    function bond(uint256 _amount, address _to) external {\n', '        bondWithHint(\n', '            _amount,\n', '            _to,\n', '            address(0),\n', '            address(0),\n', '            address(0),\n', '            address(0)\n', '        );\n', '    }\n', '\n', '    /**\n', "     * @notice Unbond an amount of the delegator's bonded stake\n", '     * @param _amount Amount of tokens to unbond\n', '     */\n', '    function unbond(uint256 _amount) external {\n', '        unbondWithHint(_amount, address(0), address(0));\n', '    }\n', '\n', '    /**\n', "     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status\n", '     * @param _unbondingLockId ID of unbonding lock to rebond with\n', '     */\n', '    function rebond(uint256 _unbondingLockId) external {\n', '        rebondWithHint(_unbondingLockId, address(0), address(0));\n', '    }\n', '\n', '    /**\n', '     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status\n', '     * @param _to Address of delegate\n', '     * @param _unbondingLockId ID of unbonding lock to rebond with\n', '     */\n', '    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {\n', '        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));\n', '    }\n', '\n', '    /**\n', '     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period\n', '     * @param _unbondingLockId ID of unbonding lock to withdraw with\n', '     */\n', '    function withdrawStake(uint256 _unbondingLockId)\n', '        external\n', '        whenSystemNotPaused\n', '        currentRoundInitialized\n', '    {\n', '        Delegator storage del = delegators[msg.sender];\n', '        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n', '\n', '        require(isValidUnbondingLock(msg.sender, _unbondingLockId), "invalid unbonding lock ID");\n', '        require(lock.withdrawRound <= roundsManager().currentRound(), "withdraw round must be before or equal to the current round");\n', '\n', '        uint256 amount = lock.amount;\n', '        uint256 withdrawRound = lock.withdrawRound;\n', '        // Delete unbonding lock\n', '        delete del.unbondingLocks[_unbondingLockId];\n', '\n', '        // Tell Minter to transfer stake (LPT) to the delegator\n', '        minter().trustedTransferTokens(msg.sender, amount);\n', '\n', '        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);\n', '    }\n', '\n', '    /**\n', '     * @notice Withdraws fees to the caller\n', '     */\n', '    function withdrawFees()\n', '        external\n', '        whenSystemNotPaused\n', '        currentRoundInitialized\n', '        autoClaimEarnings\n', '    {\n', '        uint256 fees = delegators[msg.sender].fees;\n', '        require(fees > 0, "no fees to withdraw");\n', '        delegators[msg.sender].fees = 0;\n', '\n', '        // Tell Minter to transfer fees (ETH) to the delegator\n', '        minter().trustedWithdrawETH(msg.sender, fees);\n', '\n', '        emit WithdrawFees(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Mint token rewards for an active transcoder and its delegators\n', '     */\n', '    function reward() external {\n', '        rewardWithHint(address(0), address(0));\n', '    }\n', '\n', '    /**\n', "     * @notice Update transcoder's fee pool. Only callable by the TicketBroker\n", '     * @param _transcoder Transcoder address\n', '     * @param _fees Fees to be added to the fee pool\n', '     */\n', '    function updateTranscoderWithFees(\n', '        address _transcoder,\n', '        uint256 _fees,\n', '        uint256 _round\n', '    )\n', '        external\n', '        whenSystemNotPaused\n', '        onlyTicketBroker\n', '    {\n', '        // Silence unused param compiler warning\n', '        _round;\n', '\n', '        require(isRegisteredTranscoder(_transcoder), "transcoder must be registered");\n', '\n', '        uint256 currentRound = roundsManager().currentRound();\n', '\n', '        Transcoder storage t = transcoders[_transcoder];\n', '\n', '        uint256 lastRewardRound = t.lastRewardRound;\n', '        uint256 activeCumulativeRewards = t.activeCumulativeRewards;\n', '\n', "        // LIP-36: Add fees for the current round instead of '_round'\n", '        // https://github.com/livepeer/LIPs/issues/35#issuecomment-673659199\n', '        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n', '        EarningsPool.Data memory prevEarningsPool = latestCumulativeFactorsPool(t, currentRound.sub(1));\n', '\n', "        // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare', 'transcoderRewardCut' and 'totalStake'\n", "        // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected\n", '        // for cumulative fee calculation this would result in division by zero.\n', '        if (currentRound > lastRewardRound) {\n', '            earningsPool.setCommission(\n', '                t.rewardCut,\n', '                t.feeShare\n', '            );\n', '\n', '            uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\n', '            if (lastUpdateRound < currentRound) {\n', '                earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\n', '            }\n', '\n', "            // If reward() has not been called yet in the current round, then the transcoder's activeCumulativeRewards has not\n", '            // yet been set in for the round. When the transcoder calls reward() its activeCumulativeRewards will be set to its\n', "            // current cumulativeRewards. So, we can just use the transcoder's cumulativeRewards here because this will become\n", "            // the transcoder's activeCumulativeRewards if it calls reward() later on in the current round\n", '            activeCumulativeRewards = t.cumulativeRewards;\n', '        }\n', '\n', '        uint256 totalStake = earningsPool.totalStake;\n', '        if (prevEarningsPool.cumulativeRewardFactor == 0 && lastRewardRound == currentRound) {\n', "            // if transcoder called reward for 'currentRound' but not for 'currentRound - 1' (missed reward call)\n", "            // retroactively calculate what its cumulativeRewardFactor would have been for 'currentRound - 1' (cfr. previous lastRewardRound for transcoder)\n", '            // based on rewards for currentRound\n', '            IMinter mtr = minter();\n', '            uint256 rewards = MathUtils.percOf(mtr.currentMintableTokens().add(mtr.currentMintedTokens()), totalStake, currentRoundTotalActiveStake);\n', '            uint256 transcoderCommissionRewards = MathUtils.percOf(rewards, earningsPool.transcoderRewardCut);\n', '            uint256 delegatorsRewards = rewards.sub(transcoderCommissionRewards);\n', '\n', '            prevEarningsPool.cumulativeRewardFactor = MathUtils.percOf(\n', '                earningsPool.cumulativeRewardFactor,\n', '                totalStake,\n', '                delegatorsRewards.add(totalStake)\n', '            );\n', '        }\n', '\n', '        uint256 delegatorsFees = MathUtils.percOf(_fees, earningsPool.transcoderFeeShare);\n', '        uint256 transcoderCommissionFees = _fees.sub(delegatorsFees);\n', "        // Calculate the fees earned by the transcoder's earned rewards\n", '        uint256 transcoderRewardStakeFees = MathUtils.percOf(delegatorsFees, activeCumulativeRewards, totalStake);\n', '        // Track fees earned by the transcoder based on its earned rewards and feeShare\n', '        t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees).add(transcoderCommissionFees);\n', '        // Update cumulative fee factor with new fees\n', '        // The cumulativeFeeFactor is used to calculate fees for all delegators including the transcoder (self-delegated)\n', '        // Note that delegatorsFees includes transcoderRewardStakeFees, but no delegator will claim that amount using\n', "        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeFees field\n", '        earningsPool.updateCumulativeFeeFactor(prevEarningsPool, delegatorsFees);\n', '\n', '        t.lastFeeRound = currentRound;\n', '    }\n', '\n', '    /**\n', '     * @notice Slash a transcoder. Only callable by the Verifier\n', '     * @param _transcoder Transcoder address\n', '     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder\n', '     * @param _slashAmount Percentage of transcoder bond to be slashed\n', '     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder\n', '     */\n', '    function slashTranscoder(\n', '        address _transcoder,\n', '        address _finder,\n', '        uint256 _slashAmount,\n', '        uint256 _finderFee\n', '    )\n', '        external\n', '        whenSystemNotPaused\n', '        onlyVerifier\n', '    {\n', '        Delegator storage del = delegators[_transcoder];\n', '\n', '        if (del.bondedAmount > 0) {\n', '            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);\n', '\n', '            // If active transcoder, resign it\n', '            if (transcoderPoolV2.contains(_transcoder)) {\n', '                resignTranscoder(_transcoder);\n', '            }\n', '\n', '            // Decrease bonded stake\n', '            del.bondedAmount = del.bondedAmount.sub(penalty);\n', '\n', "            // If still bonded decrease delegate's delegated amount\n", '            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {\n', '                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(penalty);\n', '            }\n', '\n', '            // Account for penalty\n', '            uint256 burnAmount = penalty;\n', '\n', '            // Award finder fee if there is a finder address\n', '            if (_finder != address(0)) {\n', '                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);\n', '                minter().trustedTransferTokens(_finder, finderAmount);\n', '\n', '                // Minter burns the slashed funds - finder reward\n', '                minter().trustedBurnTokens(burnAmount.sub(finderAmount));\n', '\n', '                emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);\n', '            } else {\n', '                // Minter burns the slashed funds\n', '                minter().trustedBurnTokens(burnAmount);\n', '\n', '                emit TranscoderSlashed(_transcoder, address(0), penalty, 0);\n', '            }\n', '        } else {\n', '            emit TranscoderSlashed(_transcoder, _finder, 0, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round\n', '     * @param _endRound The last round for which to claim token pools shares for a delegator\n', '     */\n', '    function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {\n', '        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;\n', '        require(lastClaimRound < _endRound, "end round must be after last claim round");\n', '        require(_endRound <= roundsManager().currentRound(), "end round must be before or equal to current round");\n', '\n', '        updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound);\n', '    }\n', '\n', '    /**\n', '     * @notice Claim earnings for a delegator based on the snapshot taken in LIP-52\n', '     * @dev https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-52.md\n', '     * @param _pendingStake the amount of pending stake for the delegator (current stake + pending rewards)\n', '     * @param _pendingFees the amount of pending fees for the delegator (current fees + pending fees)\n', '     * @param _earningsProof array of keccak256 sibling hashes on the branch of the leaf for the delegator up to the root\n', '     * @param _data (optional) raw transaction data to be executed on behalf of msg.sender after claiming snapshot earnings\n', '     */\n', '    function claimSnapshotEarnings(\n', '        uint256 _pendingStake,\n', '        uint256 _pendingFees,\n', '        bytes32[] calldata _earningsProof,\n', '        bytes calldata _data\n', '    )\n', '        external\n', '        whenSystemNotPaused\n', '        currentRoundInitialized\n', '    {\n', '        Delegator storage del = delegators[msg.sender];\n', '\n', '        uint256 lip52Round = roundsManager().lipUpgradeRound(52);\n', '\n', '        uint256 lastClaimRound = del.lastClaimRound;\n', '\n', '        require(lastClaimRound < lip52Round, "Already claimed for LIP-52");\n', '\n', '        bytes32 leaf = keccak256(abi.encode(msg.sender, _pendingStake, _pendingFees));\n', '\n', '        require(\n', '            IMerkleSnapshot(controller.getContract(keccak256("MerkleSnapshot"))).verify(keccak256("LIP-52"), _earningsProof, leaf),\n', '            "Merkle proof is invalid"\n', '        );\n', '\n', '        emit EarningsClaimed(\n', '            del.delegateAddress,\n', '            msg.sender,\n', '            _pendingStake.sub(del.bondedAmount),\n', '            _pendingFees.sub(del.fees),\n', '            lastClaimRound.add(1),\n', '            lip52Round\n', '        );\n', '\n', '        del.lastClaimRound = lip52Round;\n', '        del.bondedAmount = _pendingStake;\n', '        del.fees = _pendingFees;\n', '\n', '        // allow for execution of subsequent claiming or staking operations\n', '        if (_data.length > 0) {\n', '            (bool success, bytes memory returnData) = address(this).delegatecall(_data);\n', '            require(success, string(returnData));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager\n', '     */\n', '    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {\n', '        currentRoundTotalActiveStake = nextRoundTotalActiveStake;\n', '    }\n', '\n', '    /**\n', '     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint\n', '     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the\n', '     * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will\n', '     * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.\n', '     * See SortedDoublyLL.sol for details on list hints\n', '     * @param _rewardCut % of reward paid to transcoder by a delegator\n', '     * @param _feeShare % of fees paid to delegators by a transcoder\n', '     * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool\n', '     * @param _newPosNext Address of next transcoder in pool if the caller joins the pool\n', '     */\n', '    function transcoderWithHint(uint256 _rewardCut, uint256 _feeShare, address _newPosPrev, address _newPosNext)\n', '        public\n', '        whenSystemNotPaused\n', '        currentRoundInitialized\n', '    {\n', '        require(\n', '            !roundsManager().currentRoundLocked(),\n', '            "can\'t update transcoder params, current round is locked"\n', '        );\n', '        require(MathUtils.validPerc(_rewardCut), "invalid rewardCut percentage");\n', '        require(MathUtils.validPerc(_feeShare), "invalid feeShare percentage");\n', '        require(isRegisteredTranscoder(msg.sender), "transcoder must be registered");\n', '\n', '        Transcoder storage t = transcoders[msg.sender];\n', '        uint256 currentRound = roundsManager().currentRound();\n', '\n', '        require(\n', '            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,\n', '            "caller can\'t be active or must have already called reward for the current round"\n', '        );\n', '\n', '        t.rewardCut = _rewardCut;\n', '        t.feeShare = _feeShare;\n', '\n', '        if (!transcoderPoolV2.contains(msg.sender)) {\n', '            tryToJoinActiveSet(msg.sender, delegators[msg.sender].delegatedAmount, currentRound.add(1), _newPosPrev, _newPosNext);\n', '        }\n', '\n', '        emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare);\n', '    }\n', '\n', '    /**\n', '     * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed\n', '     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint\n', '     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.\n', '     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the\n', '     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.\n', '     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\n', '     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n', '     * @param _amount The amount of tokens to stake.\n', '     * @param _to The address of the transcoder to stake towards\n', '     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate\n', '     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate\n', '     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate\n', '     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate\n', '     */\n', '    function bondWithHint(\n', '        uint256 _amount,\n', '        address _to,\n', '        address _oldDelegateNewPosPrev,\n', '        address _oldDelegateNewPosNext,\n', '        address _currDelegateNewPosPrev,\n', '        address _currDelegateNewPosNext\n', '    )\n', '        public\n', '        whenSystemNotPaused\n', '        currentRoundInitialized\n', '        autoClaimEarnings\n', '    {\n', '        Delegator storage del = delegators[msg.sender];\n', '\n', '        uint256 currentRound = roundsManager().currentRound();\n', '        // Amount to delegate\n', '        uint256 delegationAmount = _amount;\n', '        // Current delegate\n', '        address currentDelegate = del.delegateAddress;\n', '\n', '        if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {\n', '            // New delegate\n', '            // Set start round\n', "            // Don't set start round if delegator is in pending state because the start round would not change\n", '            del.startRound = currentRound.add(1);\n', '            // Unbonded state = no existing delegate and no bonded stake\n', '            // Thus, delegation amount = provided amount\n', '        } else if (currentDelegate != address(0) && currentDelegate != _to) {\n', '            // A registered transcoder cannot delegate its bonded stake toward another address\n', '            // because it can only be delegated toward itself\n', '            // In the future, if delegation towards another registered transcoder as an already\n', '            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction\n', '            // could be removed\n', '            require(!isRegisteredTranscoder(msg.sender), "registered transcoders can\'t delegate towards other addresses");\n', '            // Changing delegate\n', '            // Set start round\n', '            del.startRound = currentRound.add(1);\n', '            // Update amount to delegate with previous delegation amount\n', '            delegationAmount = delegationAmount.add(del.bondedAmount);\n', '\n', '            decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);\n', '        }\n', '\n', '        // cannot delegate to someone without having bonded stake\n', '        require(delegationAmount > 0, "delegation amount must be greater than 0");\n', '        // Update delegate\n', '        del.delegateAddress = _to;\n', '        // Update bonded amount\n', '        del.bondedAmount = del.bondedAmount.add(_amount);\n', '\n', '        increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);\n', '\n', '        if (_amount > 0) {\n', '            // Transfer the LPT to the Minter\n', '            livepeerToken().transferFrom(msg.sender, address(minter()), _amount);\n', '        }\n', '\n', '        emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount);\n', '    }\n', '\n', '    /**\n', "     * @notice Unbond an amount of the delegator's bonded stake and updates the transcoder pool using an optional list hint if needed\n", '     * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the\n', '     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\n', '     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints\n', '     * @param _amount Amount of tokens to unbond\n', '     * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool\n', '     * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool\n', '     */\n', '    function unbondWithHint(uint256 _amount, address _newPosPrev, address _newPosNext)\n', '        public\n', '        whenSystemNotPaused\n', '        currentRoundInitialized\n', '        autoClaimEarnings\n', '    {\n', '        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, "caller must be bonded");\n', '\n', '        Delegator storage del = delegators[msg.sender];\n', '\n', '        require(_amount > 0, "unbond amount must be greater than 0");\n', '        require(_amount <= del.bondedAmount, "amount is greater than bonded amount");\n', '\n', '        address currentDelegate = del.delegateAddress;\n', '        uint256 currentRound = roundsManager().currentRound();\n', '        uint256 withdrawRound = currentRound.add(unbondingPeriod);\n', '        uint256 unbondingLockId = del.nextUnbondingLockId;\n', '\n', '        // Create new unbonding lock\n', '        del.unbondingLocks[unbondingLockId] = UnbondingLock({\n', '            amount: _amount,\n', '            withdrawRound: withdrawRound\n', '        });\n', '        // Increment ID for next unbonding lock\n', '        del.nextUnbondingLockId = unbondingLockId.add(1);\n', "        // Decrease delegator's bonded amount\n", '        del.bondedAmount = del.bondedAmount.sub(_amount);\n', '\n', '        if (del.bondedAmount == 0) {\n', '            // Delegator no longer delegated to anyone if it does not have a bonded amount\n', '            del.delegateAddress = address(0);\n', '            // Delegator does not have a start round if it is no longer delegated to anyone\n', '            del.startRound = 0;\n', '\n', '            if (transcoderPoolV2.contains(msg.sender)) {\n', '                resignTranscoder(msg.sender);\n', '            }\n', '        }\n', '\n', '        // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount\n', '        decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);\n', '\n', '        emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound);\n', '    }\n', '\n', '    /**\n', "     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status and updates\n", '     * the transcoder pool using an optional list hint if needed\n', "     * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the\n", '     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\n', '     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints\n', '     * @param _unbondingLockId ID of unbonding lock to rebond with\n', '     * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool\n', '     * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool\n', '     */\n', '    function rebondWithHint(\n', '        uint256 _unbondingLockId,\n', '        address _newPosPrev,\n', '        address _newPosNext\n', '    )\n', '        public\n', '        whenSystemNotPaused\n', '        currentRoundInitialized\n', '        autoClaimEarnings\n', '    {\n', '        require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, "caller must be bonded");\n', '\n', '        // Process rebond using unbonding lock\n', '        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);\n', '    }\n', '\n', '    /**\n', '     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using\n', '     * an optional list hint if needed\n', "     * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the\n", '     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\n', '     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n', '     * @param _to Address of delegate\n', '     * @param _unbondingLockId ID of unbonding lock to rebond with\n', '     * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool\n', '     * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool\n', '     */\n', '    function rebondFromUnbondedWithHint(\n', '        address _to,\n', '        uint256 _unbondingLockId,\n', '        address _newPosPrev,\n', '        address _newPosNext\n', '    )\n', '        public\n', '        whenSystemNotPaused\n', '        currentRoundInitialized\n', '        autoClaimEarnings\n', '    {\n', '        require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, "caller must be unbonded");\n', '\n', "        // Set delegator's start round and transition into Pending state\n", '        delegators[msg.sender].startRound = roundsManager().currentRound().add(1);\n', "        // Set delegator's delegate\n", '        delegators[msg.sender].delegateAddress = _to;\n', '        // Process rebond using unbonding lock\n', '        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);\n', '    }\n', '\n', '    /**\n', '     * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed\n', '     * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the\n', '     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.\n', '     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n', '     * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool\n', '     * @param _newPosNext Address of next transcoder in pool if the caller is in the pool\n', '     */\n', '    function rewardWithHint(address _newPosPrev, address _newPosNext) public whenSystemNotPaused currentRoundInitialized {\n', '        uint256 currentRound = roundsManager().currentRound();\n', '\n', '        require(isActiveTranscoder(msg.sender), "caller must be an active transcoder");\n', '        require(transcoders[msg.sender].lastRewardRound != currentRound, "caller has already called reward for the current round");\n', '\n', '        Transcoder storage t = transcoders[msg.sender];\n', '        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n', '\n', '        // Set last round that transcoder called reward\n', '        earningsPool.setCommission(t.rewardCut, t.feeShare);\n', '\n', "        // If transcoder didn't receive stake updates during the previous round and hasn't called reward for > 1 round\n", "        // the 'totalStake' on its 'EarningsPool' for the current round wouldn't be initialized\n", "        // Thus we sync the the transcoder's stake to when it was last updated\n", "        // 'updateTrancoderWithRewards()' will set the update round to 'currentRound +1' so this synchronization shouldn't occur frequently\n", '        uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\n', '        if (lastUpdateRound < currentRound) {\n', '            earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\n', '        }\n', '\n', "        // Create reward based on active transcoder's stake relative to the total active stake\n", '        // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake\n', '        uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);\n', '\n', '        updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);\n', '\n', '        // Set last round that transcoder called reward\n', '        t.lastRewardRound = currentRound;\n', '\n', '        emit Reward(msg.sender, rewardTokens);\n', '    }\n', '\n', '    /**\n', '     * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round\n', '     * @param _delegator Address of delegator\n', '     * @param _endRound The last round to compute pending stake from\n', "     * @return Pending bonded stake for '_delegator' since last claiming rewards\n", '     */\n', '    function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {\n', '        (\n', '            uint256 stake,\n', '        ) = pendingStakeAndFees(_delegator, _endRound);\n', '        return stake;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns pending fees for a delegator from its lastClaimRound through an end round\n', '     * @param _delegator Address of delegator\n', '     * @param _endRound The last round to compute pending fees from\n', "     * @return Pending fees for '_delegator' since last claiming fees\n", '     */\n', '    function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {\n', '        (\n', '            ,\n', '            uint256 fees\n', '        ) = pendingStakeAndFees(_delegator, _endRound);\n', '        return fees;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns total bonded stake for a transcoder\n', '     * @param _transcoder Address of transcoder\n', '     * @return total bonded stake for a delegator\n', '     */\n', '    function transcoderTotalStake(address _transcoder) public view returns (uint256) {\n', '        return delegators[_transcoder].delegatedAmount;\n', '    }\n', '\n', '    /**\n', '     * @notice Computes transcoder status\n', '     * @param _transcoder Address of transcoder\n', '     * @return registered or not registered transcoder status\n', '     */\n', '    function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {\n', '        if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;\n', '        return TranscoderStatus.NotRegistered;\n', '    }\n', '\n', '    /**\n', '     * @notice Computes delegator status\n', '     * @param _delegator Address of delegator\n', '     * @return bonded, unbonded or pending delegator status\n', '     */\n', '    function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {\n', '        Delegator storage del = delegators[_delegator];\n', '\n', '        if (del.bondedAmount == 0) {\n', '            // Delegator unbonded all its tokens\n', '            return DelegatorStatus.Unbonded;\n', '        } else if (del.startRound > roundsManager().currentRound()) {\n', '            // Delegator round start is in the future\n', '            return DelegatorStatus.Pending;\n', '        } else {\n', '            // Delegator round start is now or in the past\n', '            // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which\n', '            // would trigger the first if clause\n', '            return DelegatorStatus.Bonded;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Return transcoder information\n', '     * @param _transcoder Address of transcoder\n', "     * @return lastRewardRound Trancoder's last reward round\n", "     * @return rewardCut Transcoder's reward cut\n", "     * @return feeShare Transcoder's fee share\n", "     * @return lastActiveStakeUpdateRound Round in which transcoder's stake was last updated while active\n", '     * @return activationRound Round in which transcoder became active\n', '     * @return deactivationRound Round in which transcoder will no longer be active\n', "     * @return activeCumulativeRewards Transcoder's cumulative rewards that are currently active\n", "     * @return cumulativeRewards Transcoder's cumulative rewards (earned via its active staked rewards and its reward cut)\n", "     * @return cumulativeFees Transcoder's cumulative fees (earned via its active staked rewards and its fee share)\n", '     * @return lastFeeRound Latest round that the transcoder received fees\n', '     */\n', '    function getTranscoder(\n', '        address _transcoder\n', '    )\n', '        public\n', '        view\n', '        returns (uint256 lastRewardRound, uint256 rewardCut, uint256 feeShare, uint256 lastActiveStakeUpdateRound, uint256 activationRound, uint256 deactivationRound, uint256 activeCumulativeRewards, uint256 cumulativeRewards, uint256 cumulativeFees, uint256 lastFeeRound)\n', '    {\n', '        Transcoder storage t = transcoders[_transcoder];\n', '\n', '        lastRewardRound = t.lastRewardRound;\n', '        rewardCut = t.rewardCut;\n', '        feeShare = t.feeShare;\n', '        lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;\n', '        activationRound = t.activationRound;\n', '        deactivationRound = t.deactivationRound;\n', '        activeCumulativeRewards = t.activeCumulativeRewards;\n', '        cumulativeRewards = t.cumulativeRewards;\n', '        cumulativeFees = t.cumulativeFees;\n', '        lastFeeRound = t.lastFeeRound;\n', '    }\n', '\n', '    /**\n', "     * @notice Return transcoder's earnings pool for a given round\n", '     * @param _transcoder Address of transcoder\n', '     * @param _round Round number\n', '     * @return rewardPool Reward pool for delegators (only used before LIP-36)\n', '     * @return feePool Fee pool for delegators (only used before LIP-36)\n', "     * @return totalStake Transcoder's total stake in '_round'\n", '     * @return claimableStake Remaining stake that can be used to claim from the pool (only used before LIP-36)\n', "     * @return transcoderRewardCut Transcoder's reward cut for '_round'\n", "     * @return transcoderFeeShare Transcoder's fee share for '_round'\n", "     * @return transcoderRewardPool Transcoder's rewards for '_round' (only used before LIP-36)\n", "     * @return transcoderFeePool Transcoder's fees for '_round' (only used before LIP-36)\n", '     * @return hasTranscoderRewardFeePool True if there is a split reward/fee pool for the transcoder (only used before LIP-36)\n', '     * @return cumulativeRewardFactor The cumulative reward factor for delegator rewards calculation (only used after LIP-36)\n', '     * @return cumulativeFeeFactor The cumulative fee factor for delegator fees calculation (only used after LIP-36)\n', '     */\n', '    function getTranscoderEarningsPoolForRound(\n', '        address _transcoder,\n', '        uint256 _round\n', '    )\n', '        public\n', '        view\n', '        returns (uint256 rewardPool, uint256 feePool, uint256 totalStake, uint256 claimableStake, uint256 transcoderRewardCut, uint256 transcoderFeeShare, uint256 transcoderRewardPool, uint256 transcoderFeePool, bool hasTranscoderRewardFeePool, uint256 cumulativeRewardFactor, uint256 cumulativeFeeFactor)\n', '    {\n', '        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];\n', '\n', '        rewardPool = earningsPool.rewardPool;\n', '        feePool = earningsPool.feePool;\n', '        totalStake = earningsPool.totalStake;\n', '        claimableStake = earningsPool.claimableStake;\n', '        transcoderRewardCut = earningsPool.transcoderRewardCut;\n', '        transcoderFeeShare = earningsPool.transcoderFeeShare;\n', '        transcoderRewardPool = earningsPool.transcoderRewardPool;\n', '        transcoderFeePool = earningsPool.transcoderFeePool;\n', '        hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool;\n', '        cumulativeRewardFactor = earningsPool.cumulativeRewardFactor;\n', '        cumulativeFeeFactor = earningsPool.cumulativeFeeFactor;\n', '    }\n', '\n', '    /**\n', '     * @notice Return delegator info\n', '     * @param _delegator Address of delegator\n', "     * @return total amount bonded by '_delegator'\n", "     * @return amount of fees collected by '_delegator'\n", "     * @return address '_delegator' has bonded to\n", "     * @return total amount delegated to '_delegator'\n", "     * @return round in which bond for '_delegator' became effective\n", "     * @return round for which '_delegator' has last claimed earnings\n", "     * @return ID for the next unbonding lock created for '_delegator'\n", '     */\n', '    function getDelegator(\n', '        address _delegator\n', '    )\n', '        public\n', '        view\n', '        returns (uint256 bondedAmount, uint256 fees, address delegateAddress, uint256 delegatedAmount, uint256 startRound, uint256 lastClaimRound, uint256 nextUnbondingLockId)\n', '    {\n', '        Delegator storage del = delegators[_delegator];\n', '\n', '        bondedAmount = del.bondedAmount;\n', '        fees = del.fees;\n', '        delegateAddress = del.delegateAddress;\n', '        delegatedAmount = del.delegatedAmount;\n', '        startRound = del.startRound;\n', '        lastClaimRound = del.lastClaimRound;\n', '        nextUnbondingLockId = del.nextUnbondingLockId;\n', '    }\n', '\n', '    /**\n', "     * @notice Return delegator's unbonding lock info\n", '     * @param _delegator Address of delegator\n', '     * @param _unbondingLockId ID of unbonding lock\n', '     * @return amount of stake locked up by unbonding lock\n', "     * @return round in which 'amount' becomes available for withdrawal\n", '     */\n', '    function getDelegatorUnbondingLock(\n', '        address _delegator,\n', '        uint256 _unbondingLockId\n', '    )\n', '        public\n', '        view\n', '        returns (uint256 amount, uint256 withdrawRound)\n', '    {\n', '        UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];\n', '\n', '        return (lock.amount, lock.withdrawRound);\n', '    }\n', '\n', '    /**\n', '     * @notice Returns max size of transcoder pool\n', '     * @return transcoder pool max size\n', '     */\n', '    function getTranscoderPoolMaxSize() public view returns (uint256) {\n', '        return transcoderPoolV2.getMaxSize();\n', '    }\n', '\n', '    /**\n', '     * @notice Returns size of transcoder pool\n', '     * @return transcoder pool current size\n', '     */\n', '    function getTranscoderPoolSize() public view returns (uint256) {\n', '        return transcoderPoolV2.getSize();\n', '    }\n', '\n', '    /**\n', '     * @notice Returns transcoder with most stake in pool\n', '     * @return address for transcoder with highest stake in transcoder pool\n', '     */\n', '    function getFirstTranscoderInPool() public view returns (address) {\n', '        return transcoderPoolV2.getFirst();\n', '    }\n', '\n', '    /**\n', '     * @notice Returns next transcoder in pool for a given transcoder\n', '     * @param _transcoder Address of a transcoder in the pool\n', "     * @return address for the transcoder after '_transcoder' in transcoder pool\n", '     */\n', '    function getNextTranscoderInPool(address _transcoder) public view returns (address) {\n', '        return transcoderPoolV2.getNext(_transcoder);\n', '    }\n', '\n', '    /**\n', '     * @notice Return total bonded tokens\n', '     * @return total active stake for the current round\n', '     */\n', '    function getTotalBonded() public view returns (uint256) {\n', '        return currentRoundTotalActiveStake;\n', '    }\n', '\n', '   /**\n', '     * @notice Return whether a transcoder is active for the current round\n', '     * @param _transcoder Transcoder address\n', '     * @return true if transcoder is active\n', '     */\n', '    function isActiveTranscoder(address _transcoder) public view returns (bool) {\n', '        Transcoder storage t = transcoders[_transcoder];\n', '        uint256 currentRound = roundsManager().currentRound();\n', '        return t.activationRound <= currentRound && currentRound < t.deactivationRound;\n', '    }\n', '\n', '    /**\n', '     * @notice Return whether a transcoder is registered\n', '     * @param _transcoder Transcoder address\n', '     * @return true if transcoder is self-bonded\n', '     */\n', '    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {\n', '        Delegator storage d = delegators[_transcoder];\n', '        return d.delegateAddress == _transcoder && d.bondedAmount > 0;\n', '    }\n', '\n', '    /**\n', '     * @notice Return whether an unbonding lock for a delegator is valid\n', '     * @param _delegator Address of delegator\n', '     * @param _unbondingLockId ID of unbonding lock\n', '     * @return true if unbondingLock for ID has a non-zero withdraw round\n', '     */\n', '    function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {\n', '        // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)\n', '        return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0;\n', '    }\n', '\n', '    /**\n', '     * @notice Return an EarningsPool.Data struct with the latest cumulative factors for a given round\n', '     * @param _transcoder Storage pointer to a transcoder struct\n', '     * @param _round The round to fetch the latest cumulative factors for\n', '     * @return pool An EarningsPool.Data populated with the latest cumulative factors for _round\n', '     */\n', '    function latestCumulativeFactorsPool(Transcoder storage _transcoder, uint256 _round) internal view returns (EarningsPool.Data memory pool) {\n', '        pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_round].cumulativeRewardFactor;\n', '        pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_round].cumulativeFeeFactor;\n', '\n', '        uint256 lastRewardRound = _transcoder.lastRewardRound;\n', '        // Only use the cumulativeRewardFactor for lastRewardRound if lastRewardRound is before _round\n', '        if (pool.cumulativeRewardFactor == 0 && lastRewardRound < _round) {\n', '            pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[lastRewardRound].cumulativeRewardFactor;\n', '        }\n', '\n', '        uint256 lastFeeRound = _transcoder.lastFeeRound;\n', '        // Only use the cumulativeFeeFactor for lastFeeRound if lastFeeRound is before _round\n', '        if (pool.cumulativeFeeFactor == 0 && lastFeeRound < _round) {\n', '            pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[lastFeeRound].cumulativeFeeFactor;\n', '        }\n', '\n', '        return pool;\n', '    }\n', '\n', '    /**\n', "     * @notice Return a delegator's cumulative stake and fees using the LIP-36 earnings claiming algorithm\n", "     * @param _transcoder Storage pointer to a transcoder struct for a delegator's delegate\n", '     * @param _startRound The round for the start cumulative factors\n', '     * @param _endRound The round for the end cumulative factors\n', "     * @param _stake The delegator's initial stake before including earned rewards\n", "     * @param _fees The delegator's initial fees before including earned fees\n", "     * @return (cStake, cFees) where cStake is the delegator's cumulative stake including earned rewards and cFees is the delegator's cumulative fees including earned fees\n", '     */\n', '    function delegatorCumulativeStakeAndFees(\n', '        Transcoder storage _transcoder,\n', '        uint256 _startRound,\n', '        uint256 _endRound,\n', '        uint256 _stake,\n', '        uint256 _fees\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256 cStake, uint256 cFees)\n', '    {\n', '        uint256 baseRewardFactor = MathUtils.percPoints(1, 1);\n', '\n', '        // Fetch start cumulative factors\n', '        EarningsPool.Data memory startPool;\n', '        startPool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_startRound].cumulativeRewardFactor;\n', '        startPool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_startRound].cumulativeFeeFactor;\n', '\n', '        if (startPool.cumulativeRewardFactor == 0) {\n', '            startPool.cumulativeRewardFactor = baseRewardFactor;\n', '        }\n', '\n', '        // Fetch end cumulative factors\n', '        EarningsPool.Data memory endPool = latestCumulativeFactorsPool(_transcoder, _endRound);\n', '\n', '        if (endPool.cumulativeRewardFactor == 0) {\n', '            endPool.cumulativeRewardFactor = baseRewardFactor;\n', '        }\n', '\n', '        cFees = _fees.add(\n', '            MathUtils.percOf(\n', '                _stake,\n', '                endPool.cumulativeFeeFactor.sub(startPool.cumulativeFeeFactor),\n', '                startPool.cumulativeRewardFactor\n', '            )\n', '        );\n', '\n', '        cStake = MathUtils.percOf(\n', '            _stake,\n', '            endPool.cumulativeRewardFactor,\n', '            startPool.cumulativeRewardFactor\n', '        );\n', '\n', '        return (cStake, cFees);\n', '    }\n', '\n', '    /**\n', '     * @notice Return the pending stake and fees for a delegator\n', '     * @param _delegator Address of a delegator\n', '     * @param _endRound The last round to claim earnings for when calculating the pending stake and fees\n', "     * @return (stake, fees) where stake is the delegator's pending stake and fees is the delegator's pending fees\n", '     */\n', '    function pendingStakeAndFees(address _delegator, uint256 _endRound) internal view returns (uint256 stake, uint256 fees) {\n', '        Delegator storage del = delegators[_delegator];\n', '        Transcoder storage t = transcoders[del.delegateAddress];\n', '\n', '        fees = del.fees;\n', '        stake = del.bondedAmount;\n', '\n', '        uint256 startRound = del.lastClaimRound.add(1);\n', '        address delegateAddr = del.delegateAddress;\n', '        bool isTranscoder = _delegator == delegateAddr;\n', '\n', '        uint256 lip36Round = roundsManager().lipUpgradeRound(36);\n', '        while (startRound <= _endRound && startRound <= lip36Round) {\n', '            EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[startRound];\n', '\n', '            // If earningsPool.hasTranscoderRewardFeePool is not set during lip36Round then the transcoder did not call\n', '            // reward during lip36Round before the upgrade. In this case, if the transcoder calls reward in lip36Round\n', '            // the delegator can use the LIP-36 earnings claiming algorithm to claim for lip36Round\n', '            if (startRound == lip36Round && !earningsPool.hasTranscoderRewardFeePool) {\n', '                break;\n', '            }\n', '\n', '            if (earningsPool.hasClaimableShares()) {\n', '                // Calculate and add fee pool share from this round\n', '                fees = fees.add(earningsPool.feePoolShare(stake, isTranscoder));\n', '                // Calculate new bonded amount with rewards from this round. Updated bonded amount used\n', '                // to calculate fee pool share in next round\n', '                stake = stake.add(earningsPool.rewardPoolShare(stake, isTranscoder));\n', '            }\n', '\n', '            startRound = startRound.add(1);\n', '        }\n', '\n', '        // If the transcoder called reward during lip36Round the upgrade, then startRound = lip36Round\n', '        // Otherwise, startRound = lip36Round + 1\n', '\n', "        // If the start round is greater than the end round, we've already claimed for the end round so we do not\n", '        // need to execute the LIP-36 earnings claiming algorithm. This could be the case if:\n', '        // - _endRound < lip36Round i.e. we are not claiming through the lip36Round\n', '        // - _endRound == lip36Round AND startRound = lip36Round + 1 i.e we already claimed through the lip36Round\n', '        if (startRound > _endRound) {\n', '            return (stake, fees);\n', '        }\n', '\n', "        // The LIP-36 earnings claiming algorithm uses the cumulative factors from the delegator's lastClaimRound i.e. startRound - 1\n", '        // and from the specified _endRound\n', '        (\n', '            stake,\n', '            fees\n', '        ) = delegatorCumulativeStakeAndFees(t, startRound.sub(1), _endRound, stake, fees);\n', '\n', '        if (isTranscoder) {\n', '            stake = stake.add(t.cumulativeRewards);\n', '            fees = fees.add(t.cumulativeFees);\n', '        }\n', '\n', '        return (stake, fees);\n', '    }\n', '\n', '    /**\n', "     * @dev Increase the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'\n", '     * @param _delegate The delegate to increase the stake for\n', "     * @param _amount The amount to increase the stake for '_delegate' by\n", '     */\n', '    function increaseTotalStake(address _delegate, uint256 _amount, address _newPosPrev, address _newPosNext) internal {\n', '        if (isRegisteredTranscoder(_delegate)) {\n', '            uint256 currStake = transcoderTotalStake(_delegate);\n', '            uint256 newStake = currStake.add(_amount);\n', '            uint256 currRound = roundsManager().currentRound();\n', '            uint256 nextRound = currRound.add(1);\n', '\n', '            // If the transcoder is already in the active set update its stake and return\n', '            if (transcoderPoolV2.contains(_delegate)) {\n', '                transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);\n', '                nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);\n', '                Transcoder storage t = transcoders[_delegate];\n', '\n', "                // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound\n", '                // because it is updated every time lastActiveStakeUpdateRound is updated\n', '                // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()\n', '                // and updateTranscoderWithFees() when lastActiveStakeUpdateRound > currentRound\n', '                if (t.lastActiveStakeUpdateRound < currRound) {\n', '                    t.earningsPoolPerRound[currRound].setStake(currStake);\n', '                }\n', '\n', '                t.earningsPoolPerRound[nextRound].setStake(newStake);\n', '                t.lastActiveStakeUpdateRound = nextRound;\n', '            } else {\n', '                // Check if the transcoder is eligible to join the active set in the update round\n', '                tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);\n', '            }\n', '        }\n', '\n', "        // Increase delegate's delegated amount\n", '        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount);\n', '    }\n', '\n', '    /**\n', "     * @dev Decrease the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'\n", '     * @param _delegate The transcoder to decrease the stake for\n', "     * @param _amount The amount to decrease the stake for '_delegate' by\n", '     */\n', '    function decreaseTotalStake(address _delegate, uint256 _amount, address _newPosPrev, address _newPosNext) internal {\n', '        if (transcoderPoolV2.contains(_delegate)) {\n', '            uint256 currStake = transcoderTotalStake(_delegate);\n', '            uint256 newStake = currStake.sub(_amount);\n', '            uint256 currRound = roundsManager().currentRound();\n', '            uint256 nextRound = currRound.add(1);\n', '\n', '            transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);\n', '            nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);\n', '            Transcoder storage t = transcoders[_delegate];\n', '\n', "            // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound\n", '            // because it is updated every time lastActiveStakeUpdateRound is updated\n', '            // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()\n', '            // and updateTranscoderWithFees() when lastActiveStakeUpdateRound > currentRound\n', '            if (t.lastActiveStakeUpdateRound < currRound) {\n', '                t.earningsPoolPerRound[currRound].setStake(currStake);\n', '            }\n', '\n', '            t.lastActiveStakeUpdateRound = nextRound;\n', '            t.earningsPoolPerRound[nextRound].setStake(newStake);\n', '        }\n', '\n', "        // Decrease old delegate's delegated amount\n", '        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full\n', '     * @param _transcoder The transcoder to insert into the transcoder pool\n', "     * @param _totalStake The total stake for '_transcoder'\n", '     * @param _activationRound The round in which the transcoder should become active\n', '     */\n', '    function tryToJoinActiveSet(\n', '        address _transcoder,\n', '        uint256 _totalStake,\n', '        uint256 _activationRound,\n', '        address _newPosPrev,\n', '        address _newPosNext\n', '    )\n', '        internal\n', '    {\n', '        uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;\n', '\n', '        if (transcoderPoolV2.isFull()) {\n', '            address lastTranscoder = transcoderPoolV2.getLast();\n', '            uint256 lastStake = transcoderTotalStake(lastTranscoder);\n', '\n', '            // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool\n', '            // then the transcoder is unable to join the active set for the next round\n', '            if (_totalStake <= lastStake) {\n', '                return;\n', '            }\n', '\n', '            // Evict the least stake transcoder from the active set for the next round\n', "            // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)\n", '            // There should be no side-effects as long as the value is properly updated on stake updates\n', "            // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as\n", "            // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.\n", '            transcoderPoolV2.remove(lastTranscoder);\n', '            transcoders[lastTranscoder].deactivationRound = _activationRound;\n', '            pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);\n', '\n', '            emit TranscoderDeactivated(lastTranscoder, _activationRound);\n', '        }\n', '\n', '        transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);\n', '        pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);\n', '        Transcoder storage t = transcoders[_transcoder];\n', '        t.lastActiveStakeUpdateRound = _activationRound;\n', '        t.activationRound = _activationRound;\n', '        t.deactivationRound = MAX_FUTURE_ROUND;\n', '        t.earningsPoolPerRound[_activationRound].setStake(_totalStake);\n', '        nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;\n', '        emit TranscoderActivated(_transcoder, _activationRound);\n', '    }\n', '\n', '    /**\n', '     * @dev Remove a transcoder from the pool and deactivate it\n', '     */\n', '    function resignTranscoder(address _transcoder) internal {\n', "        // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)\n", '        // There should be no side-effects as long as the value is properly updated on stake updates\n', "        // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as\n", "        // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.\n", '        transcoderPoolV2.remove(_transcoder);\n', '        nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));\n', '        uint256 deactivationRound = roundsManager().currentRound().add(1);\n', '        transcoders[_transcoder].deactivationRound = deactivationRound;\n', '        emit TranscoderDeactivated(_transcoder, deactivationRound);\n', '    }\n', '\n', '    /**\n', '     * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.\n', '     * See SortedDoublyLL.sol for details on list hints\n', '     * @param _transcoder Address of transcoder\n', '     * @param _rewards Amount of rewards\n', '     * @param _round Round that transcoder is updated\n', '     * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool\n', '     * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool\n', '     */\n', '    function updateTranscoderWithRewards(\n', '        address _transcoder,\n', '        uint256 _rewards,\n', '        uint256 _round,\n', '        address _newPosPrev,\n', '        address _newPosNext\n', '    )\n', '        internal\n', '    {\n', '        Transcoder storage t = transcoders[_transcoder];\n', '        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];\n', '        EarningsPool.Data storage prevEarningsPool = t.earningsPoolPerRound[t.lastRewardRound];\n', '\n', '        t.activeCumulativeRewards = t.cumulativeRewards;\n', '\n', '        uint256 transcoderCommissionRewards = MathUtils.percOf(_rewards, earningsPool.transcoderRewardCut);\n', '        uint256 delegatorsRewards = _rewards.sub(transcoderCommissionRewards);\n', "        // Calculate the rewards earned by the transcoder's earned rewards\n", '        uint256 transcoderRewardStakeRewards = MathUtils.percOf(delegatorsRewards, t.activeCumulativeRewards, earningsPool.totalStake);\n', '        // Track rewards earned by the transcoder based on its earned rewards and rewardCut\n', '        t.cumulativeRewards = t.cumulativeRewards.add(transcoderRewardStakeRewards).add(transcoderCommissionRewards);\n', '        // Update cumulative reward factor with new rewards\n', '        // The cumulativeRewardFactor is used to calculate rewards for all delegators including the transcoder (self-delegated)\n', '        // Note that delegatorsRewards includes transcoderRewardStakeRewards, but no delegator will claim that amount using\n', "        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeRewards field\n", '        earningsPool.updateCumulativeRewardFactor(prevEarningsPool, delegatorsRewards);\n', "        // Update transcoder's total stake with rewards\n", '        increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext);\n', '    }\n', '\n', '    /**\n', '     * @dev Update a delegator with token pools shares from its lastClaimRound through a given round\n', '     * @param _delegator Delegator address\n', "     * @param _endRound The last round for which to update a delegator's stake with earnings pool shares\n", '     * @param _lastClaimRound The round for which a delegator has last claimed earnings\n', '     */\n', '    function updateDelegatorWithEarnings(address _delegator, uint256 _endRound, uint256 _lastClaimRound) internal {\n', '        Delegator storage del = delegators[_delegator];\n', '        uint256 startRound = _lastClaimRound.add(1);\n', '        uint256 currentBondedAmount = del.bondedAmount;\n', '        uint256 currentFees = del.fees;\n', '\n', '        uint256 lip36Round = roundsManager().lipUpgradeRound(36);\n', '\n', '        // Only will have earnings to claim if you have a delegate\n', '        // If not delegated, skip the earnings claim process\n', '        if (del.delegateAddress != address(0)) {\n', '            if (startRound <= lip36Round) {\n', '                // Cannot claim earnings for more than maxEarningsClaimsRounds before LIP-36\n', '                // This is a number to cause transactions to fail early if\n', '                // we know they will require too much gas to loop through all the necessary rounds to claim earnings\n', '                // The user should instead manually invoke `claimEarnings` to split up the claiming process\n', '                // across multiple transactions\n', '                uint256 endLoopRound = _endRound <= lip36Round ? _endRound : lip36Round;\n', '                require(endLoopRound.sub(_lastClaimRound) <= maxEarningsClaimsRounds, "too many rounds to claim through");\n', '            }\n', '\n', '            (\n', '                currentBondedAmount,\n', '                currentFees\n', '            ) = pendingStakeAndFees(_delegator, _endRound);\n', '\n', '            // Check whether the endEarningsPool is initialised\n', "            // If it is not initialised set it's cumulative factors so that they can be used when a delegator\n", '            // next claims earnings as the start cumulative factors (see delegatorCumulativeStakeAndFees())\n', '            Transcoder storage t = transcoders[del.delegateAddress];\n', '            EarningsPool.Data storage endEarningsPool = t.earningsPoolPerRound[_endRound];\n', '            if (endEarningsPool.cumulativeRewardFactor == 0) {\n', '                endEarningsPool.cumulativeRewardFactor = t.earningsPoolPerRound[t.lastRewardRound].cumulativeRewardFactor;\n', '            }\n', '            if (endEarningsPool.cumulativeFeeFactor == 0) {\n', '                endEarningsPool.cumulativeFeeFactor = t.earningsPoolPerRound[t.lastFeeRound].cumulativeFeeFactor;\n', '            }\n', '\n', '            if (del.delegateAddress == _delegator) {\n', '                t.cumulativeFees = 0;\n', '                t.cumulativeRewards = 0;\n', '                // activeCumulativeRewards is not cleared here because the next reward() call will set it to cumulativeRewards\n', '            }\n', '        }\n', '\n', '        emit EarningsClaimed(\n', '            del.delegateAddress,\n', '            _delegator,\n', '            currentBondedAmount.sub(del.bondedAmount),\n', '            currentFees.sub(del.fees),\n', '            startRound,\n', '            _endRound\n', '        );\n', '\n', '        del.lastClaimRound = _endRound;\n', '        // Rewards are bonded by default\n', '        del.bondedAmount = currentBondedAmount;\n', '        del.fees = currentFees;\n', '    }\n', '\n', '    /**\n', '     * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional\n', '     * list hint if needed. See SortedDoublyLL.sol for details on list hints\n', '     * @param _delegator Address of delegator\n', '     * @param _unbondingLockId ID of unbonding lock to rebond with\n', '     * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool\n', '     * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool\n', '     */\n', '    function processRebond(address _delegator, uint256 _unbondingLockId, address _newPosPrev, address _newPosNext) internal {\n', '        Delegator storage del = delegators[_delegator];\n', '        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n', '\n', '        require(isValidUnbondingLock(_delegator, _unbondingLockId), "invalid unbonding lock ID");\n', '\n', '        uint256 amount = lock.amount;\n', "        // Increase delegator's bonded amount\n", '        del.bondedAmount = del.bondedAmount.add(amount);\n', '\n', '        // Delete lock\n', '        delete del.unbondingLocks[_unbondingLockId];\n', '\n', '        increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);\n', '\n', '        emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Return LivepeerToken interface\n', '     * @return Livepeer token contract registered with Controller\n', '     */\n', '    function livepeerToken() internal view returns (ILivepeerToken) {\n', '        return ILivepeerToken(controller.getContract(keccak256("LivepeerToken")));\n', '    }\n', '\n', '    /**\n', '     * @dev Return Minter interface\n', '     * @return Minter contract registered with Controller\n', '     */\n', '    function minter() internal view returns (IMinter) {\n', '        return IMinter(controller.getContract(keccak256("Minter")));\n', '    }\n', '\n', '    /**\n', '     * @dev Return RoundsManager interface\n', '     * @return RoundsManager contract registered with Controller\n', '     */\n', '    function roundsManager() internal view returns (IRoundsManager) {\n', '        return IRoundsManager(controller.getContract(keccak256("RoundsManager")));\n', '    }\n', '\n', '    function _onlyTicketBroker() internal view {\n', '        require(\n', '            msg.sender == controller.getContract(keccak256("TicketBroker")),\n', '            "caller must be TicketBroker"\n', '        );\n', '    }\n', '\n', '    function _onlyRoundsManager() internal view {\n', '        require(\n', '            msg.sender == controller.getContract(keccak256("RoundsManager")),\n', '            "caller must be RoundsManager"\n', '        );\n', '    }\n', '\n', '    function _onlyVerifier() internal view {\n', '        require(msg.sender == controller.getContract(keccak256("Verifier")), "caller must be Verifier");\n', '    }\n', '\n', '    function  _currentRoundInitialized() internal view {\n', '        require(roundsManager().currentRoundInitialized(), "current round is not initialized");\n', '    }\n', '\n', '    function _autoClaimEarnings() internal {\n', '        uint256 currentRound = roundsManager().currentRound();\n', '        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;\n', '        if (lastClaimRound < currentRound) {\n', '            updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);\n', '        }\n', '    }\n', '}']