['pragma solidity 0.6.9;\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    // function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    //     require(b != 0, "SafeMath: modulo by zero");\n', '    //     return a % b;\n', '    // }\n', '}\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be aplied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address _owner;\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor (address own) internal {\n', '        _owner = own;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address account) external view returns (uint256);\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '  function decimals() external view returns (uint8);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '  function token0() external view returns (address);\n', '  function token1() external view returns (address);\n', '}\n', '\n', 'contract SDCPStaking is Ownable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    address private immutable sdcpToken;\n', '    address private immutable v2Pair;\n', '\n', '    uint8 private immutable sdcpDec;\n', '\n', '    uint constant BASE_EP = 5;\n', '\n', '    uint constant DAY =  60 * 60 * 24;\n', '\n', '    uint constant RATE = 1660000;  // \n', '    uint constant LEAST = 500;\n', '\n', '    constructor(address sdcp , address v2) Ownable(msg.sender) public {\n', '      sdcpToken = sdcp;\n', '      sdcpDec = IERC20(sdcp).decimals();\n', '      v2Pair = v2;\n', '      require(IUniswapV2Pair(v2).token0() == sdcp || IUniswapV2Pair(v2).token1() == sdcp, "E/no sdcp");\n', '    }\n', '\n', '    struct Staking {\n', '      uint128 amount;\n', '      uint32 stakeTime;\n', '      uint32 earnTime;\n', '      uint64 stype;   \n', '    }\n', '\n', '    mapping(address => Staking) V2Stakings;\n', '\n', '    mapping(uint => uint) dayPrices;\n', '\n', '    mapping(uint => uint) public earnPercent;\n', '\n', '    function myV2Staking() external view returns (uint128, uint32, uint32, uint64, uint) {\n', '      return (V2Stakings[msg.sender].amount,\n', '              V2Stakings[msg.sender].stakeTime,\n', '              V2Stakings[msg.sender].earnTime,\n', '              V2Stakings[msg.sender].stype,\n', '              myV2Earn());\n', '    }\n', '\n', '    function stakingV2(uint amount, uint64 stype) external {\n', '      require(V2Stakings[msg.sender].amount == 0, "E/aleady staking");\n', '      require(stype <= 2, "E/type error");\n', '      require(IERC20(v2Pair).transferFrom(msg.sender, address(this), amount), "E/transfer error");\n', '      V2Stakings[msg.sender] = Staking(uint128(amount), uint32(now), uint32(now), stype);\n', '    }\n', '\n', '    function wdV2(uint amount) external {\n', '      Staking memory s = V2Stakings[msg.sender];\n', '      uint stakingToal = s.amount;\n', '      uint stakingTime = s.stakeTime;\n', '\n', '      require(stakingToal >= amount, "E/not enough");\n', '      if(s.stype == 1) {\n', '        require(now >= stakingTime + DAY, "E/locked"); \n', '      } else {\n', '        require(now >= stakingTime + 30 * DAY, "E/12 locked"); \n', '      } \n', '\n', '\n', '      wdV2Earn() ;\n', '\n', '      IERC20(v2Pair).transfer(msg.sender, amount);\n', '\n', '      if(stakingToal - amount > 0) {\n', '        V2Stakings[msg.sender] = Staking(uint128(stakingToal - amount), uint32(now), uint32(now), s.stype);\n', '      } else {\n', '        delete V2Stakings[msg.sender];\n', '      }\n', '    }\n', '\n', '    function myV2Earn() internal view returns (uint) {\n', '      Staking memory s = V2Stakings[msg.sender];\n', '      if(s.amount == 0) {\n', '        return 0;\n', '      }\n', '\n', '      uint endDay = getDay(now);\n', '      uint startDay = getDay(s.earnTime);\n', '      if(endDay > startDay) {\n', '        uint earnDays = endDay - startDay;\n', '        uint earnPs = earnDays * BASE_EP;\n', '\n', '        while(endDay > startDay) {\n', '          if(earnPercent[startDay] > 0) {\n', '            earnPs += earnPercent[startDay];\n', '          }\n', '          startDay += 1;\n', '        }\n', '\n', '        uint earns = 0;\n', '        if(earnPs > 0) {\n', '          earns = uint(s.amount).mul(earnPs).mul(RATE).div(1000).div(10 ** (uint(18).sub(sdcpDec)));\n', '        }\n', '        if(s.stype == 2) {\n', '          return earns * 2;\n', '        } else {\n', '          return earns;\n', '        }\n', '      } \n', '      return 0;\n', '    }\n', '\n', '    function wdV2Earn() public {\n', '      uint earnsTotal = myV2Earn();\n', '\n', '      IERC20(sdcpToken).transfer(msg.sender, earnsTotal);\n', '      V2Stakings[msg.sender].earnTime = uint32(now);\n', '    }\n', '\n', '\n', '    // get 1 sdcp  =  x eth\n', '    function fetchPrice() internal view returns (uint) {\n', '      (uint reserve0, uint reserve1,) = IUniswapV2Pair(v2Pair).getReserves();\n', "      require(reserve0 > 0 && reserve1 > 0, 'E/INSUFFICIENT_LIQUIDITY');\n", '      uint oneSdcp = 10 ** uint(sdcpDec);  \n', '\n', '      if(IUniswapV2Pair(v2Pair).token0() == sdcpToken) {\n', '        return oneSdcp.mul(reserve1) / reserve0;\n', '      } else {\n', '        return oneSdcp.mul(reserve0) / reserve1;\n', '      }\n', '    }\n', '\n', '    function getDay(uint ts) internal pure returns (uint) {   \n', '      return ts / DAY;\n', '    }\n', '\n', '    function updatePrice() external {\n', '      uint d = getDay(now);\n', '      uint p = fetchPrice();\n', '\n', '      dayPrices[d] = p;\n', '      uint lastPrice = dayPrices[d-1];\n', '      \n', '      if(lastPrice > 0 && p > lastPrice) {\n', '        \n', '        uint ep = BASE_EP;\n', '        uint t = (p - lastPrice) / (lastPrice / 10); \n', '        earnPercent[d] = ep * t;\n', '      }\n', '    }\n', '\n', '    function withdrawSDCP(uint amount) external onlyOwner {\n', '      IERC20(sdcpToken).transfer(msg.sender, amount);\n', '    }\n', '\n', '}']