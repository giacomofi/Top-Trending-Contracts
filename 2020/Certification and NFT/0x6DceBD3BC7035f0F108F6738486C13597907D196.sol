['pragma solidity >=0.5.22 <0.6.12;\n', '\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '    \n', '    contract ERC20 {\n', '        \n', '    // Balances\n', '    mapping(address => uint) tokenBalances;\n', '    // Allowances\n', '    mapping(address => mapping(address => uint)) tokenAllowances;\n', '    // The owner of this token\n', '    address public owner;\n', '    // Optional ERC-20 Functions\n', '    string public constant name = "Worth";\n', '    string public constant symbol = "WTH";\n', '    uint256 public constant decimals = 8;\n', '\n', '    // Constructor. Called ONCE when the contract is deployed.\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        currentSupply = 0;\n', '    }\n', '\n', '    // Implement a minting function here -OR- generate a fixed\n', '    // supply in the constructor\n', '\n', '\n', '    uint currentSupply;\n', '\n', '    // Required ERC-20 Functions\n', '    /** Returns the current total supply of tokens available. The easisest\n', '        way to implement this function is to keep track of the total supply\n', '        in a storage variable and to return it when this functino is called. */\n', '    function totalSupply() public view returns (uint) {\n', '        return currentSupply;\n', '    }\n', '\n', '    /** Return the balance of a given token owner. */\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return tokenBalances[tokenOwner];\n', '    }\n', '\n', '    /** Return the tokens that spender is still allowed to return from tokenOwner. */\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return tokenAllowances[tokenOwner][spender];\n', '    }\n', '\n', "    /** Transfer tokens from sender's account to the to account.\n", '        Zero-value transfers MUST be treated as normal transfers.\n', '        This function should throw an error (use require(condition, message)) if\n', '        the account has insufficient tokens.\n', '        A successful transfer should emit the Transfer() event.\n', '     */\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        uint tokenBalance = tokenBalances[msg.sender];\n', '        require(tokenBalance > tokens, "You do not have enough tokens");\n', '        tokenBalances[msg.sender] -= tokens;\n', '        tokenBalances[to] += tokens;\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', "    /** Approve spender to spend tokens from caller's account.\n", '        If this function is called multiple times, the previous allowance\n', '        is replaced.\n', '        Successful execution of this function should emit the Approval() event.\n', '     */\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        tokenAllowances[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    function mint(address to, uint tokens) public returns (bool success) {\n', '        require(msg.sender == owner, "You must be the token owner to call this function");\n', '        tokenBalances[to] += tokens;\n', '        currentSupply += tokens;\n', '        return true;\n', '    }\n', '\n', '    /** Transfer tokens from one account to another account.\n', '        Zero-value transfers MUST be treated as normal transfers.\n', '        This function should throw an error (use require(condition, message)) if\n', '        the from account has insufficient tokens or there is insufficient allowance\n', '        for the caller account.\n', '        A successful transfer should emit the Transfer() event.\n', '     */\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        require(tokenAllowances[from][msg.sender] > tokens, "Not enough token allowance to transfer!");\n', '        require(tokenBalances[from] > tokens, "Account does not have enough tokens");\n', '        tokenBalances[from] -= tokens;\n', '        tokenBalances[to] += tokens;\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    /** This event is emitted when tokens are transferred from one account to another. */\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '\n', '    /** This event is emitted when tokens are approved for transfer from one account to another.. */\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}']