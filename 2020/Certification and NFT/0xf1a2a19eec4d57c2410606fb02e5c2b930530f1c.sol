['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', 'library Math {\n', '    \n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    \n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    \n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        \n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', 'contract Context {\n', '    \n', '    \n', '    constructor () internal { }\n', '\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; \n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    \n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    \n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    \n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    \n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    \n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    \n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        \n', '        \n', '        \n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    \n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        \n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        \n', '\n', '        return c;\n', '    }\n', '\n', '    \n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    \n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract UserBonus {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public constant BONUS_PERCENTS_PER_WEEK = 1;\n', '    uint256 public constant BONUS_TIME = 1 weeks;\n', '\n', '    struct UserBonusData {\n', '        uint256 threadPaid;\n', '        uint256 lastPaidTime;\n', '        uint256 numberOfUsers;\n', '        mapping(address => bool) userRegistered;\n', '        mapping(address => uint256) userPaid;\n', '    }\n', '\n', '    UserBonusData public bonus;\n', '\n', '    event BonusPaid(uint256 users, uint256 amount);\n', '    event UserAddedToBonus(address indexed user);\n', '\n', '    modifier payRepBonusIfNeeded {\n', '        payRepresentativeBonus();\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        bonus.lastPaidTime = block.timestamp;\n', '    }\n', '\n', '    function payRepresentativeBonus() public {\n', '        while (bonus.numberOfUsers > 0 && bonus.lastPaidTime.add(BONUS_TIME) <= block.timestamp) {\n', '            uint256 reward = address(this).balance.mul(BONUS_PERCENTS_PER_WEEK).div(100);\n', '            bonus.threadPaid = bonus.threadPaid.add(reward.div(bonus.numberOfUsers));\n', '            bonus.lastPaidTime = bonus.lastPaidTime.add(BONUS_TIME);\n', '            emit BonusPaid(bonus.numberOfUsers, reward);\n', '        }\n', '    }\n', '\n', '    function userRegisteredForBonus(address user) public view returns(bool) {\n', '        return bonus.userRegistered[user];\n', '    }\n', '\n', '    function userBonusPaid(address user) public view returns(uint256) {\n', '        return bonus.userPaid[user];\n', '    }\n', '\n', '    function userBonusEarned(address user) public view returns(uint256) {\n', '        return bonus.userRegistered[user] ? bonus.threadPaid.sub(bonus.userPaid[user]) : 0;\n', '    }\n', '\n', '    function retrieveBonus() public virtual payRepBonusIfNeeded {\n', '        require(bonus.userRegistered[msg.sender], "User not registered for bonus");\n', '\n', '        uint256 amount = Math.min(address(this).balance, userBonusEarned(msg.sender));\n', '        bonus.userPaid[msg.sender] = bonus.userPaid[msg.sender].add(amount);\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    function _addUserToBonus(address user) internal payRepBonusIfNeeded {\n', '        require(!bonus.userRegistered[user], "User already registered for bonus");\n', '\n', '        bonus.userRegistered[user] = true;\n', '        bonus.userPaid[user] = bonus.threadPaid;\n', '        bonus.numberOfUsers = bonus.numberOfUsers.add(1);\n', '        emit UserAddedToBonus(user);\n', '    }\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '\n', '    address public pendingOwner;\n', '\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner);\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public override(Ownable) onlyOwner {\n', '        revert();\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public override(Ownable) onlyOwner {\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    function claimOwnership() public virtual onlyPendingOwner {\n', '        transferOwnership(pendingOwner);\n', '        delete pendingOwner;\n', '    }\n', '}\n', '\n', 'contract EtherHives is Claimable, UserBonus {\n', '\n', '    struct Player {\n', '        uint256 registeredDate;\n', '        bool airdropCollected;\n', '        address referrer;\n', '        uint256 balanceHoney;\n', '        uint256 balanceWax;\n', '        uint256 points;\n', '        uint256 medals;\n', '        uint256 qualityLevel;\n', '        uint256 lastTimeCollected;\n', '        uint256 unlockedBee;\n', '        uint256[BEES_COUNT] bees;\n', '\n', '        uint256 totalDeposited;\n', '        uint256 totalWithdrawed;\n', '        uint256 referralsTotalDeposited;\n', '        uint256 subreferralsCount;\n', '        address[] referrals;\n', '    }\n', '\n', '    uint256 public constant BEES_COUNT = 8;\n', '    uint256 public constant SUPER_BEE_INDEX = BEES_COUNT - 1;\n', '    uint256 public constant TRON_BEE_INDEX = BEES_COUNT - 2;\n', '    uint256 public constant MEDALS_COUNT = 10;\n', '    uint256 public constant QUALITIES_COUNT = 6;\n', '    uint256[BEES_COUNT] public BEES_PRICES = [0e18, 1500e18, 7500e18, 30000e18, 75000e18, 250000e18, 750000e18, 100000e18];\n', '    uint256[BEES_COUNT] public BEES_LEVELS_PRICES = [0e18, 0e18, 11250e18, 45000e18, 112500e18, 375000e18, 1125000e18, 0];\n', '    uint256[BEES_COUNT] public BEES_MONTHLY_PERCENTS = [0, 220, 223, 226, 229, 232, 235, 333];\n', '    uint256[MEDALS_COUNT] public MEDALS_POINTS = [0e18, 50000e18, 190000e18, 510000e18, 1350000e18, 3225000e18, 5725000e18, 8850000e18, 12725000e18, 23500000e18];\n', '    uint256[MEDALS_COUNT] public MEDALS_REWARDS = [0e18, 3500e18, 10500e18, 24000e18, 65000e18, 140000e18, 185000e18, 235000e18, 290000e18, 800000e18];\n', '    uint256[QUALITIES_COUNT] public QUALITY_HONEY_PERCENT = [80, 82, 84, 86, 88, 90];\n', '    uint256[QUALITIES_COUNT] public QUALITY_PRICE = [0e18, 15000e18, 50000e18, 120000e18, 250000e18, 400000e18];\n', '\n', '    uint256 public constant COINS_PER_ETH = 250000;\n', '    uint256 public constant MAX_BEES_PER_TARIFF = 32;\n', '    uint256 public constant FIRST_BEE_AIRDROP_AMOUNT = 500e18;\n', '    uint256 public constant ADMIN_PERCENT = 10;\n', '    uint256 public constant HONEY_DISCOUNT_PERCENT = 10;\n', '    uint256 public constant SUPERBEE_PERCENT_UNLOCK = 5;\n', '    uint256 public constant SUPER_BEE_BUYER_PERIOD = 7 days;\n', '    uint256[] public REFERRAL_PERCENT_PER_LEVEL = [5, 3, 2];\n', '    uint256[] public REFERRAL_POINT_PERCENT = [50, 25, 0];\n', '\n', '    uint256 public maxBalance;\n', '    uint256 public totalPlayers;\n', '    uint256 public totalDeposited;\n', '    uint256 public totalWithdrawed;\n', '    uint256 public totalBeesBought;\n', '    mapping(address => Player) public players;\n', '\n', '    event Registered(address indexed user, address indexed referrer);\n', '    event Deposited(address indexed user, uint256 amount);\n', '    event Withdrawed(address indexed user, uint256 amount);\n', '    event ReferrerPaid(address indexed user, address indexed referrer, uint256 indexed level, uint256 amount);\n', '    event MedalAwarded(address indexed user, uint256 indexed medal);\n', '    event QualityUpdated(address indexed user, uint256 indexed quality);\n', '    event RewardCollected(address indexed user, uint256 honeyReward, uint256 waxReward);\n', '    event BeeUnlocked(address indexed user, uint256 bee);\n', '    event BeesBought(address indexed user, uint256 bee, uint256 count);\n', '\n', '    constructor() public {\n', '        _register(owner(), address(0));\n', '    }\n', '\n', '    receive() external payable {\n', '        if (msg.value == 0) {\n', '            if (players[msg.sender].registeredDate > 0) {\n', '                collect();\n', '            }\n', '        } else {\n', '            deposit(address(0));\n', '        }\n', '    }\n', '\n', '    function playerBees(address who) public view returns(uint256[BEES_COUNT] memory) {\n', '        return players[who].bees;\n', '    }\n', '\n', '    function superBeeUnlocked() public view returns(bool) {\n', '        return address(this).balance <= maxBalance.mul(100 - SUPERBEE_PERCENT_UNLOCK).div(100);\n', '    }\n', '\n', '    function referrals(address user) public view returns(address[] memory) {\n', '        return players[user].referrals;\n', '    }\n', '\n', '    function referrerOf(address user, address ref) internal view returns(address) {\n', '        if (players[user].registeredDate == 0 && ref != user) {\n', '            return ref;\n', '        }\n', '        return players[user].referrer;\n', '    }\n', '\n', '    function transfer(address account, uint256 amount) public returns(bool) {\n', '        require(msg.sender == owner());\n', '\n', '        collect();\n', '\n', '        _payWithWaxAndHoney(msg.sender, amount);\n', '        players[account].balanceWax = players[account].balanceWax.add(amount);\n', '        return true;\n', '    }\n', '\n', '    function deposit(address ref) public payable payRepBonusIfNeeded {\n', '        Player storage player = players[msg.sender];\n', '        address refAddress = referrerOf(msg.sender, ref);\n', '\n', '        require((msg.value == 0) != player.registeredDate > 0, "Send 0 for registration");\n', '\n', '        \n', '        if (player.registeredDate == 0) {\n', '            _register(msg.sender, refAddress);\n', '        }\n', '\n', '        collect();\n', '\n', '        \n', '        uint256 wax = msg.value.mul(COINS_PER_ETH);\n', '        player.balanceWax = player.balanceWax.add(wax);\n', '        player.totalDeposited = player.totalDeposited.add(msg.value);\n', '        totalDeposited = totalDeposited.add(msg.value);\n', '        player.points = player.points.add(wax);\n', '        emit Deposited(msg.sender, msg.value);\n', '\n', '        \n', '\n', '        _distributeFees(msg.sender, wax, msg.value, refAddress);\n', '\n', '        _addToBonusIfNeeded(msg.sender);\n', '\n', '        uint256 adminWithdrawed = players[owner()].totalWithdrawed;\n', '        maxBalance = Math.max(maxBalance, address(this).balance.add(adminWithdrawed));\n', '    }\n', '\n', '    function withdraw(uint256 amount) public {\n', '        Player storage player = players[msg.sender];\n', '\n', '        collect();\n', '\n', '        uint256 value = amount.div(COINS_PER_ETH);\n', '        require(value > 0, "Trying to withdraw too small");\n', '        player.balanceHoney = player.balanceHoney.sub(amount);\n', '        player.totalWithdrawed = player.totalWithdrawed.add(value);\n', '        totalWithdrawed = totalWithdrawed.add(value);\n', '        msg.sender.transfer(value);\n', '        emit Withdrawed(msg.sender, value);\n', '    }\n', '\n', '    function collect() public payRepBonusIfNeeded {\n', '        Player storage player = players[msg.sender];\n', '        require(player.registeredDate > 0, "Not registered yet");\n', '\n', '        if (userBonusEarned(msg.sender) > 0) {\n', '            retrieveBonus();\n', '        }\n', '\n', '        (uint256 balanceHoney, uint256 balanceWax) = instantBalance(msg.sender);\n', '        emit RewardCollected(\n', '            msg.sender,\n', '            balanceHoney.sub(player.balanceHoney),\n', '            balanceWax.sub(player.balanceWax)\n', '        );\n', '\n', '        if (!player.airdropCollected && player.registeredDate < now) {\n', '            player.airdropCollected = true;\n', '        }\n', '\n', '        player.balanceHoney = balanceHoney;\n', '        player.balanceWax = balanceWax;\n', '        player.lastTimeCollected = block.timestamp;\n', '    }\n', '\n', '    function instantBalance(address account)\n', '        public\n', '        view\n', '        returns(\n', '            uint256 balanceHoney,\n', '            uint256 balanceWax\n', '        )\n', '    {\n', '        Player storage player = players[account];\n', '        if (player.registeredDate == 0) {\n', '            return (0, 0);\n', '        }\n', '\n', '        balanceHoney = player.balanceHoney;\n', '        balanceWax = player.balanceWax;\n', '\n', '        uint256 collected = earned(account);\n', '        if (!player.airdropCollected && player.registeredDate < now) {\n', '            collected = collected.sub(FIRST_BEE_AIRDROP_AMOUNT);\n', '            balanceWax = balanceWax.add(FIRST_BEE_AIRDROP_AMOUNT);\n', '        }\n', '\n', '        uint256 honeyReward = collected.mul(QUALITY_HONEY_PERCENT[player.qualityLevel]).div(100);\n', '        uint256 waxReward = collected.sub(honeyReward);\n', '\n', '        balanceHoney = balanceHoney.add(honeyReward);\n', '        balanceWax = balanceWax.add(waxReward);\n', '    }\n', '\n', '    function unlock(uint256 bee) public payable payRepBonusIfNeeded {\n', '        Player storage player = players[msg.sender];\n', '\n', '        if (msg.value > 0) {\n', '            deposit(address(0));\n', '        }\n', '\n', '        collect();\n', '\n', '        require(bee < SUPER_BEE_INDEX, "No more levels to unlock"); \n', '        require(player.bees[bee - 1] == MAX_BEES_PER_TARIFF, "Prev level must be filled");\n', '        require(bee == player.unlockedBee + 1, "Trying to unlock wrong bee type");\n', '\n', '        if (bee == TRON_BEE_INDEX) {\n', '            require(player.medals >= 9);\n', '        }\n', '        _payWithWaxAndHoney(msg.sender, BEES_LEVELS_PRICES[bee]);\n', '        player.unlockedBee = bee;\n', '        player.bees[bee] = 1;\n', '        emit BeeUnlocked(msg.sender, bee);\n', '    }\n', '\n', '    function buyBees(uint256 bee, uint256 count) public payable payRepBonusIfNeeded {\n', '        Player storage player = players[msg.sender];\n', '\n', '        if (msg.value > 0) {\n', '            deposit(address(0));\n', '        }\n', '\n', '        collect();\n', '\n', '        require(bee > 0 && bee < BEES_COUNT, "Don\'t try to buy bees of type 0");\n', '        if (bee == SUPER_BEE_INDEX) {\n', '            require(superBeeUnlocked(), "SuperBee is not unlocked yet");\n', '            require(block.timestamp.sub(player.registeredDate) < SUPER_BEE_BUYER_PERIOD, "You should be registered less than 7 days ago");\n', '        } else {\n', '            require(bee <= player.unlockedBee, "This bee type not unlocked yet");\n', '        }\n', '\n', '        require(player.bees[bee].add(count) <= MAX_BEES_PER_TARIFF);\n', '        player.bees[bee] = player.bees[bee].add(count);\n', '        totalBeesBought = totalBeesBought.add(count);\n', '        uint256 honeySpent = _payWithWaxAndHoney(msg.sender, BEES_PRICES[bee].mul(count));\n', '\n', '        _distributeFees(msg.sender, honeySpent, 0, referrerOf(msg.sender, address(0)));\n', '\n', '        emit BeesBought(msg.sender, bee, count);\n', '    }\n', '\n', '    function updateQualityLevel() public payRepBonusIfNeeded {\n', '        Player storage player = players[msg.sender];\n', '\n', '        collect();\n', '\n', '        require(player.qualityLevel < QUALITIES_COUNT - 1);\n', '        _payWithHoneyOnly(msg.sender, QUALITY_PRICE[player.qualityLevel + 1]);\n', '        player.qualityLevel++;\n', '        emit QualityUpdated(msg.sender, player.qualityLevel);\n', '    }\n', '\n', '    function earned(address user) public view returns(uint256) {\n', '        Player storage player = players[user];\n', '        if (player.registeredDate == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 total = 0;\n', '        for (uint i = 1; i < BEES_COUNT; i++) {\n', '            total = total.add(\n', '                player.bees[i].mul(BEES_PRICES[i]).mul(BEES_MONTHLY_PERCENTS[i]).div(100)\n', '            );\n', '        }\n', '\n', '        return total\n', '            .mul(block.timestamp.sub(player.lastTimeCollected))\n', '            .div(30 days)\n', '            .add(player.airdropCollected || player.registeredDate == now ? 0 : FIRST_BEE_AIRDROP_AMOUNT);\n', '    }\n', '\n', '    function collectMedals(address user) public payRepBonusIfNeeded {\n', '        Player storage player = players[user];\n', '\n', '        collect();\n', '\n', '        for (uint i = player.medals; i < MEDALS_COUNT; i++) {\n', '            if (player.points >= MEDALS_POINTS[i]) {\n', '                player.balanceWax = player.balanceWax.add(MEDALS_REWARDS[i]);\n', '                player.medals = i + 1;\n', '                emit MedalAwarded(user, i + 1);\n', '            }\n', '        }\n', '    }\n', '\n', '    function retrieveBonus() public override(UserBonus) {\n', '        totalWithdrawed = totalWithdrawed.add(userBonusEarned(msg.sender));\n', '        super.retrieveBonus();\n', '    }\n', '\n', '    function claimOwnership() public override(Claimable) {\n', '        super.claimOwnership();\n', '        _register(owner(), address(0));\n', '    }\n', '\n', '    function _distributeFees(address user, uint256 wax, uint256 deposited, address refAddress) internal {\n', '        \n', '        address(uint160(owner())).transfer(wax * ADMIN_PERCENT / 100 / COINS_PER_ETH);\n', '\n', '        \n', '        if (refAddress != address(0)) {\n', '            Player storage referrer = players[refAddress];\n', '            referrer.referralsTotalDeposited = referrer.referralsTotalDeposited.add(deposited);\n', '            _addToBonusIfNeeded(refAddress);\n', '\n', '            \n', '            address to = refAddress;\n', '            for (uint i = 0; to != address(0) && i < REFERRAL_PERCENT_PER_LEVEL.length; i++) {\n', '                uint256 reward = wax.mul(REFERRAL_PERCENT_PER_LEVEL[i]).div(100);\n', '                players[to].balanceHoney = players[to].balanceHoney.add(reward);\n', '                players[to].points = players[to].points.add(wax.mul(REFERRAL_POINT_PERCENT[i]).div(100));\n', '                emit ReferrerPaid(user, to, i + 1, reward);\n', '                \n', '\n', '                to = players[to].referrer;\n', '            }\n', '        }\n', '    }\n', '\n', '    function _register(address user, address refAddress) internal {\n', '        Player storage player = players[user];\n', '\n', '        player.registeredDate = block.timestamp;\n', '        player.bees[0] = MAX_BEES_PER_TARIFF;\n', '        player.unlockedBee = 1;\n', '        player.lastTimeCollected = block.timestamp;\n', '        totalBeesBought = totalBeesBought.add(MAX_BEES_PER_TARIFF);\n', '        totalPlayers++;\n', '\n', '        if (refAddress != address(0)) {\n', '            player.referrer = refAddress;\n', '            players[refAddress].referrals.push(user);\n', '\n', '            if (players[refAddress].referrer != address(0)) {\n', '                players[players[refAddress].referrer].subreferralsCount++;\n', '            }\n', '\n', '            _addToBonusIfNeeded(refAddress);\n', '        }\n', '        emit Registered(user, refAddress);\n', '    }\n', '\n', '    function _payWithHoneyOnly(address user, uint256 amount) internal {\n', '        Player storage player = players[user];\n', '        player.balanceHoney = player.balanceHoney.sub(amount);\n', '    }\n', '\n', '    function _payWithWaxOnly(address user, uint256 amount) internal {\n', '        Player storage player = players[user];\n', '        player.balanceWax = player.balanceWax.sub(amount);\n', '    }\n', '\n', '    function _payWithWaxAndHoney(address user, uint256 amount) internal returns(uint256) {\n', '        Player storage player = players[user];\n', '\n', '        uint256 wax = Math.min(amount, player.balanceWax);\n', '        uint256 honey = amount.sub(wax).mul(100 - HONEY_DISCOUNT_PERCENT).div(100);\n', '\n', '        player.balanceWax = player.balanceWax.sub(wax);\n', '        _payWithHoneyOnly(user, honey);\n', '\n', '        return honey;\n', '    }\n', '\n', '    function _addToBonusIfNeeded(address user) internal {\n', '        if (user != address(0) && !bonus.userRegistered[user]) {\n', '            Player storage player = players[user];\n', '\n', '            if (player.totalDeposited >= 5 ether &&\n', '                player.referrals.length >= 10 &&\n', '                player.referralsTotalDeposited >= 50 ether)\n', '            {\n', '                _addUserToBonus(user);\n', '            }\n', '        }\n', '    }\n', '}']