['pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface ERC20 {\n', '  function decimals() external view returns (uint8);\n', '\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  function balanceOf(address _who) external view returns (uint256);\n', '\n', '  function allowance(address _owner, address _spender) external view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) external returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// Database interface\n', 'interface DBInterface {\n', '\n', '  function setContractManager(address _contractManager)\n', '  external;\n', '\n', '    // --------------------Set Functions------------------------\n', '\n', '    function setAddress(bytes32 _key, address _value)\n', '    external;\n', '\n', '    function setUint(bytes32 _key, uint _value)\n', '    external;\n', '\n', '    function setString(bytes32 _key, string _value)\n', '    external;\n', '\n', '    function setBytes(bytes32 _key, bytes _value)\n', '    external;\n', '\n', '    function setBytes32(bytes32 _key, bytes32 _value)\n', '    external;\n', '\n', '    function setBool(bytes32 _key, bool _value)\n', '    external;\n', '\n', '    function setInt(bytes32 _key, int _value)\n', '    external;\n', '\n', '\n', '     // -------------- Deletion Functions ------------------\n', '\n', '    function deleteAddress(bytes32 _key)\n', '    external;\n', '\n', '    function deleteUint(bytes32 _key)\n', '    external;\n', '\n', '    function deleteString(bytes32 _key)\n', '    external;\n', '\n', '    function deleteBytes(bytes32 _key)\n', '    external;\n', '\n', '    function deleteBytes32(bytes32 _key)\n', '    external;\n', '\n', '    function deleteBool(bytes32 _key)\n', '    external;\n', '\n', '    function deleteInt(bytes32 _key)\n', '    external;\n', '\n', '    // ----------------Variable Getters---------------------\n', '\n', '    function uintStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (uint);\n', '\n', '    function stringStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (string);\n', '\n', '    function addressStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '    function bytesStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (bytes);\n', '\n', '    function bytes32Storage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (bytes32);\n', '\n', '    function boolStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (bool);\n', '\n', '    function intStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (bool);\n', '}\n', '\n', 'contract Events {\n', '  DBInterface public database;\n', '\n', '  constructor(address _database) public{\n', '    database = DBInterface(_database);\n', '  }\n', '\n', '  function message(string _message)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogEvent(_message, keccak256(abi.encodePacked(_message)), tx.origin);\n', '  }\n', '\n', '  function transaction(string _message, address _from, address _to, uint _amount, address _token)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogTransaction(_message, keccak256(abi.encodePacked(_message)), _from, _to, _amount, _token, tx.origin);\n', '  }\n', '\n', '  function registration(string _message, address _account)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogAddress(_message, keccak256(abi.encodePacked(_message)), _account, tx.origin);\n', '  }\n', '\n', '  function contractChange(string _message, address _account, string _name)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogContractChange(_message, keccak256(abi.encodePacked(_message)), _account, _name, tx.origin);\n', '  }\n', '\n', '  function asset(string _message, string _uri, address _assetAddress, address _manager)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogAsset(_message, keccak256(abi.encodePacked(_message)), _uri, keccak256(abi.encodePacked(_uri)), _assetAddress, _manager, tx.origin);\n', '  }\n', '\n', '  function escrow(string _message, address _assetAddress, bytes32 _escrowID, address _manager, uint _amount)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogEscrow(_message, keccak256(abi.encodePacked(_message)), _assetAddress, _escrowID, _manager, _amount, tx.origin);\n', '  }\n', '\n', '  function order(string _message, bytes32 _orderID, uint _amount, uint _price)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogOrder(_message, keccak256(abi.encodePacked(_message)), _orderID, _amount, _price, tx.origin);\n', '  }\n', '\n', '  function exchange(string _message, bytes32 _orderID, address _assetAddress, address _account)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogExchange(_message, keccak256(abi.encodePacked(_message)), _orderID, _assetAddress, _account, tx.origin);\n', '  }\n', '\n', '  function operator(string _message, bytes32 _id, string _name, string _ipfs, address _account)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogOperator(_message, keccak256(abi.encodePacked(_message)), _id, _name, _ipfs, _account, tx.origin);\n', '  }\n', '\n', '  function consensus(string _message, bytes32 _executionID, bytes32 _votesID, uint _votes, uint _tokens, uint _quorum)\n', '  external\n', '  onlyApprovedContract {\n', '    emit LogConsensus(_message, keccak256(abi.encodePacked(_message)), _executionID, _votesID, _votes, _tokens, _quorum, tx.origin);\n', '  }\n', '\n', '  //Generalized events\n', '  event LogEvent(string message, bytes32 indexed messageID, address indexed origin);\n', '  event LogTransaction(string message, bytes32 indexed messageID, address indexed from, address indexed to, uint amount, address token, address origin); //amount and token will be empty on some events\n', '  event LogAddress(string message, bytes32 indexed messageID, address indexed account, address indexed origin);\n', '  event LogContractChange(string message, bytes32 indexed messageID, address indexed account, string name, address indexed origin);\n', '  event LogAsset(string message, bytes32 indexed messageID, string uri, bytes32 indexed assetID, address asset, address manager, address indexed origin);\n', '  event LogEscrow(string message, bytes32 indexed messageID, address asset, bytes32  escrowID, address indexed manager, uint amount, address indexed origin);\n', '  event LogOrder(string message, bytes32 indexed messageID, bytes32 indexed orderID, uint amount, uint price, address indexed origin);\n', '  event LogExchange(string message, bytes32 indexed messageID, bytes32 orderID, address indexed asset, address account, address indexed origin);\n', '  event LogOperator(string message, bytes32 indexed messageID, bytes32 id, string name, string ipfs, address indexed account, address indexed origin);\n', '  event LogConsensus(string message, bytes32 indexed messageID, bytes32 executionID, bytes32 votesID, uint votes, uint tokens, uint quorum, address indexed origin);\n', '\n', '\n', '  // --------------------------------------------------------------------------------------\n', '  // Caller must be registered as a contract through ContractManager.sol\n', '  // --------------------------------------------------------------------------------------\n', '  modifier onlyApprovedContract() {\n', '      require(database.boolStorage(keccak256(abi.encodePacked("contract", msg.sender))));\n', '      _;\n', '  }\n', '\n', '}\n', '\n', '// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '// @title SafeMath: overflow/underflow checks\n', '// @notice Math operations with safety checks that throw on error\n', 'library SafeMath {\n', '\n', '  // @notice Multiplies two numbers, throws on overflow.\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  // @notice Integer division of two numbers, truncating the quotient.\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  // @notice Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  // @notice Adds two numbers, throws on overflow.\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  // @notice Returns fractional amount\n', '  function getFractionalAmount(uint256 _amount, uint256 _percentage)\n', '  internal\n', '  pure\n', '  returns (uint256) {\n', '    return div(mul(_amount, _percentage), 100);\n', '  }\n', '\n', '}\n', '\n', 'interface DToken {\n', '  function withdraw() external returns (bool);\n', '  function getAmountOwed(address _user) external view returns (uint);\n', '  function balanceOf(address _tokenHolder) external view returns (uint);\n', '  function transfer(address _to, uint _amount) external returns (bool success);\n', '  function getERC20() external  view returns (address);\n', '}\n', '\n', '// @title A dividend-token holding contract that locks tokens and retrieves dividends for assetManagers\n', '// @notice This contract receives newly minted tokens and retrieves Ether or ERC20 tokens received from the asset\n', '// @author Kyle Dewhurst & Peter Phillips, MyBit Foundation\n', 'contract AssetManagerFunds {\n', '  using SafeMath for uint256;\n', '\n', '  DBInterface public database;\n', '  Events public events;\n', '\n', '  uint256 private transactionNumber;\n', '\n', '  // @notice constructor: initializes database\n', '  constructor(address _database, address _events)\n', '  public {\n', '    database = DBInterface(_database);\n', '    events = Events(_events);\n', '  }\n', '\n', '  // @notice asset manager can withdraw his dividend fee from assets here\n', '  // @param : address _assetAddress = the address of this asset on the platform\n', '  function withdraw(address _assetAddress)\n', '  external\n', '  nonReentrant\n', '  returns (bool) {\n', '    require(_assetAddress != address(0));\n', '    require(msg.sender == database.addressStorage(keccak256(abi.encodePacked("asset.manager", _assetAddress))));\n', '    DToken token = DToken( _assetAddress);\n', '    uint amountOwed;\n', '    uint balanceBefore;\n', '    if (token.getERC20() == address(0)){\n', '      balanceBefore = address(this).balance;\n', '      amountOwed = token.getAmountOwed(address(this));\n', '      require(amountOwed > 0);\n', '      uint balanceAfter = balanceBefore.add(amountOwed);\n', '      require(token.withdraw());\n', '      require(address(this).balance == balanceAfter);\n', '      msg.sender.transfer(amountOwed);\n', '    }\n', '    else {\n', '      amountOwed = token.getAmountOwed(address(this));\n', '      require(amountOwed > 0);\n', '      DToken fundingToken = DToken(token.getERC20());\n', '      balanceBefore = fundingToken.balanceOf(address(this));\n', '      require(token.withdraw());\n', '      require(fundingToken.balanceOf(address(this)).sub(amountOwed) == balanceBefore);\n', '      fundingToken.transfer(msg.sender, amountOwed);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function retrieveAssetManagerTokens(address[] _assetAddress)\n', '  external\n', '  nonReentrant\n', '  returns (bool) {\n', '    require(_assetAddress.length <= 42);\n', '    uint[] memory payoutAmounts = new uint[](_assetAddress.length);\n', '    address[] memory tokenAddresses = new address[](_assetAddress.length);\n', '    uint8 numEntries;\n', '    for(uint8 i = 0; i < _assetAddress.length; i++){\n', '      require(msg.sender == database.addressStorage(keccak256(abi.encodePacked("asset.manager", _assetAddress[i]))) );\n', '      DToken token = DToken(_assetAddress[i]);\n', '      require(address(token) != address(0));\n', '      uint tokensOwed = token.getAmountOwed(address(this));\n', '      if(tokensOwed > 0){\n', '        DToken fundingToken = DToken(token.getERC20());\n', '        uint balanceBefore = fundingToken.balanceOf(address(this));\n', '        uint8 tokenIndex = containsAddress(tokenAddresses, address(token));\n', '        if (tokenIndex < _assetAddress.length) {  payoutAmounts[tokenIndex] = payoutAmounts[tokenIndex].add(tokensOwed); }\n', '        else {\n', '          tokenAddresses[numEntries] = address(fundingToken);\n', '          payoutAmounts[numEntries] = tokensOwed;\n', '          numEntries++;\n', '        }\n', '        require(token.withdraw());\n', '        require(fundingToken.balanceOf(address(this)).sub(tokensOwed) == balanceBefore);\n', '      }\n', '    }\n', '\n', '    for(i = 0; i < numEntries; i++){\n', '      require(ERC20(tokenAddresses[i]).transfer(msg.sender, payoutAmounts[i]));\n', '    }\n', '    return true;\n', '  }\n', '\n', '\n', '  function retrieveAssetManagerETH(address[] _assetAddress)\n', '  external\n', '  nonReentrant\n', '  returns (bool) {\n', '    require(_assetAddress.length <= 93);\n', '    uint weiOwed;\n', '    for(uint8 i = 0; i < _assetAddress.length; i++){\n', '      require(msg.sender == database.addressStorage(keccak256(abi.encodePacked("asset.manager", _assetAddress[i]))));\n', '      DToken token = DToken(_assetAddress[i]);\n', '      uint balanceBefore = address(this).balance;\n', '      uint amountOwed = token.getAmountOwed(address(this));\n', '      if(amountOwed > 0){\n', '        uint balanceAfter = balanceBefore.add(amountOwed);\n', '        require(token.withdraw());\n', '        require(address(this).balance == balanceAfter);\n', '        weiOwed = weiOwed.add(amountOwed);\n', '      }\n', '    }\n', '    msg.sender.transfer(weiOwed);\n', '    return true;\n', '  }\n', '\n', '  function viewBalance(address _assetAddress, address _assetManager)\n', '  external\n', '  view\n', '  returns (uint){\n', "    require(_assetAddress != address(0), 'Empty address passed');\n", '    require(_assetManager == database.addressStorage(keccak256(abi.encodePacked("asset.manager", _assetAddress))), \'That user does not manage the asset\');\n', '    DToken token = DToken( _assetAddress);\n', '    uint balance = token.balanceOf(address(this));\n', '    return balance;\n', '  }\n', '\n', '  function viewAmountOwed(address _assetAddress, address _assetManager)\n', '  external\n', '  view\n', '  returns (uint){\n', "    require(_assetAddress != address(0), 'Empty address passed');\n", '    require(_assetManager == database.addressStorage(keccak256(abi.encodePacked("asset.manager", _assetAddress))), \'That user does not manage the asset\');\n', '    DToken token = DToken( _assetAddress);\n', '    uint amountOwed = token.getAmountOwed(address(this));\n', '    return amountOwed;\n', '  }\n', '\n', '  // @notice returns the index if the address is in the list, otherwise returns list length + 1\n', '  function containsAddress(address[] _addressList, address _addr)\n', '  internal\n', '  pure\n', '  returns (uint8) {\n', '    for (uint8 i = 0; i < _addressList.length; i++){\n', '      if (_addressList[i] == _addr) return i;\n', '    }\n', '    return uint8(_addressList.length + 1);\n', '  }\n', '\n', '  // @notice platform owners can destroy contract here\n', '  function destroy()\n', '  onlyOwner\n', '  external {\n', "    events.transaction('AssetManagerFunds destroyed', address(this), msg.sender, address(this).balance, address(0));\n", '    selfdestruct(msg.sender);\n', '  }\n', '\n', '  // @notice prevents calls from re-entering contract\n', '  modifier nonReentrant() {\n', '    transactionNumber += 1;\n', '    uint256 localCounter = transactionNumber;\n', '    _;\n', '    require(localCounter == transactionNumber);\n', '  }\n', '\n', '  // @notice reverts if caller is not the owner\n', '  modifier onlyOwner {\n', '    require(database.boolStorage(keccak256(abi.encodePacked("owner", msg.sender))) == true);\n', '    _;\n', '  }\n', '\n', '  function ()\n', '  payable\n', '  public {\n', '    emit EtherReceived(msg.sender, msg.value);\n', '  }\n', '\n', '  event EtherReceived(address sender, uint amount);\n', '\n', '}']