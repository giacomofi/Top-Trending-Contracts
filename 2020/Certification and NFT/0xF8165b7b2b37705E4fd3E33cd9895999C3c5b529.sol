['/**\n', ' * Copyright 2017-2020, bZeroX, LLC <https://bzx.network/>. All Rights Reserved.\n', ' * Licensed under the Apache License, Version 2.0.\n', ' */\n', '\n', 'pragma solidity 0.5.17;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'interface IWeth {\n', '    function deposit() external payable;\n', '    function withdraw(uint256 wad) external;\n', '}\n', '\n', 'contract IERC20 {\n', '    string public name;\n', '    uint8 public decimals;\n', '    string public symbol;\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address _who) public view returns (uint256);\n', '    function allowance(address _owner, address _spender) public view returns (uint256);\n', '    function approve(address _spender, uint256 _value) public returns (bool);\n', '    function transfer(address _to, uint256 _value) public returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract IWethERC20 is IWeth, IERC20 {}\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b != 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, rounding up and truncating the quotient\n', '    */\n', '    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return divCeil(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, rounding up and truncating the quotient\n', '    */\n', '    function divCeil(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b != 0, errorMessage);\n', '\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = ((a - 1) / b) + 1;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '    function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        return _a < _b ? _a : _b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SignedSafeMath\n', ' * @dev Signed math operations with safety checks that revert on error.\n', ' */\n', 'library SignedSafeMath {\n', '    int256 constant private _INT256_MIN = -2**255;\n', '\n', '        /**\n', '     * @dev Returns the multiplication of two signed integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == _INT256_MIN), "SignedSafeMath: multiplication overflow");\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b, "SignedSafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two signed integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0, "SignedSafeMath: division by zero");\n', '        require(!(b == -1 && a == _INT256_MIN), "SignedSafeMath: division overflow");\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two signed integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a), "SignedSafeMath: subtraction overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two signed integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a), "SignedSafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Helps contracts guard against reentrancy attacks.\n', ' * @author Remco Bloemen <remco@2Ï€.com>, Eenae <alexey@mixbytes.io>\n', ' * @dev If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '    /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\n', '    /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\n', '    uint256 internal constant REENTRANCY_GUARD_FREE = 1;\n', '\n', '    /// @dev Constant for locked guard state\n', '    uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\n', '\n', '    /**\n', '    * @dev We use a single lock for the whole contract.\n', '    */\n', '    uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\n', '\n', '    /**\n', '    * @dev Prevents a contract from calling itself, directly or indirectly.\n', '    * If you mark a function `nonReentrant`, you should also\n', '    * mark it `external`. Calling one `nonReentrant` function from\n', '    * another is not supported. Instead, you can implement a\n', '    * `private` function doing the actual work, and an `external`\n', '    * wrapper marked as `nonReentrant`.\n', '    */\n', '    modifier nonReentrant() {\n', '        require(reentrancyLock == REENTRANCY_GUARD_FREE, "nonReentrant");\n', '        reentrancyLock = REENTRANCY_GUARD_LOCKED;\n', '        _;\n', '        reentrancyLock = REENTRANCY_GUARD_FREE;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following \n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "unauthorized");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface ProtocolLike {\n', '    function borrowOrTradeFromPool(\n', '        bytes32 loanParamsId,\n', '        bytes32 loanId, // if 0, start a new loan\n', '        bool isTorqueLoan,\n', '        uint256 initialMargin,\n', '        address[4] calldata sentAddresses,\n', '            // lender: must match loan if loanId provided\n', '            // borrower: must match loan if loanId provided\n', '            // receiver: receiver of funds (address(0) assumes borrower address)\n', '            // manager: delegated manager of loan unless address(0)\n', '        uint256[5] calldata sentValues,\n', '            // newRate: new loan interest rate\n', '            // newPrincipal: new loan size (borrowAmount + any borrowed interest)\n', '            // torqueInterest: new amount of interest to escrow for Torque loan (determines initial loan length)\n', '            // loanTokenReceived: total loanToken deposit (amount not sent to borrower in the case of Torque loans)\n', '            // collateralTokenReceived: total collateralToken deposit\n', '        bytes calldata loanDataBytes)\n', '        external\n', '        payable\n', '        returns (uint256 newPrincipal, uint256 newCollateral);\n', '\n', '    function getTotalPrincipal(\n', '        address lender,\n', '        address loanToken)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function withdrawAccruedInterest(\n', '        address loanToken)\n', '        external;\n', '\n', '    function getLenderInterestData(\n', '        address lender,\n', '        address loanToken)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 interestPaid,\n', '            uint256 interestPaidDate,\n', '            uint256 interestOwedPerDay,\n', '            uint256 interestUnPaid,\n', '            uint256 interestFeePercent,\n', '            uint256 principalTotal);\n', '\n', '    function priceFeeds()\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    function getEstimatedMarginExposure(\n', '        address loanToken,\n', '        address collateralToken,\n', '        uint256 loanTokenSent,\n', '        uint256 collateralTokenSent,\n', '        uint256 interestRate,\n', '        uint256 newPrincipal)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function getRequiredCollateralByParams(\n', '        bytes32 loanParamsId,\n', '        address loanToken,\n', '        address collateralToken,\n', '        uint256 newPrincipal,\n', '        bool isTorqueLoan)\n', '        external\n', '        view\n', '        returns (uint256 collateralAmountRequired);\n', '\n', '    function getBorrowAmountByParams(\n', '        bytes32 loanParamsId,\n', '        address loanToken,\n', '        address collateralToken,\n', '        uint256 collateralTokenAmount,\n', '        bool isTorqueLoan)\n', '        external\n', '        view\n', '        returns (uint256 borrowAmount);\n', '\n', '    function isLoanPool(\n', '        address loanPool)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    function lendingFeePercent()\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', 'interface FeedsLike {\n', '    function queryRate(\n', '        address sourceTokenAddress,\n', '        address destTokenAddress)\n', '        external\n', '        view\n', '        returns (uint256 rate, uint256 precision);\n', '}\n', '\n', 'contract ITokenHolderLike {\n', '    function balanceOf(address _who) public view returns (uint256);\n', '    function freeUpTo(uint256 value) public returns (uint256);\n', '    function freeFromUpTo(address from, uint256 value) public returns (uint256);\n', '}\n', '\n', 'contract GasTokenUser {\n', '\n', '    ITokenHolderLike constant public gasToken = ITokenHolderLike(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n', '    ITokenHolderLike constant public tokenHolder = ITokenHolderLike(0x55Eb3DD3f738cfdda986B8Eff3fa784477552C61);\n', '\n', '    modifier usesGasToken(address holder) {\n', '        if (holder == address(0)) {\n', '            holder = address(tokenHolder);\n', '        }\n', '\n', '        if (gasToken.balanceOf(holder) != 0) {\n', '            uint256 gasCalcValue = gasleft();\n', '\n', '            _;\n', '\n', '            gasCalcValue = (_gasUsed(gasCalcValue) + 14154) / 41947;\n', '\n', '            if (holder == address(tokenHolder)) {\n', '                tokenHolder.freeUpTo(\n', '                    gasCalcValue\n', '                );\n', '            } else {\n', '                tokenHolder.freeFromUpTo(\n', '                    holder,\n', '                    gasCalcValue\n', '                );\n', '            }\n', '\n', '        } else {\n', '            _;\n', '        }\n', '    }\n', '\n', '    function _gasUsed(\n', '        uint256 startingGas)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return 21000 +\n', '            startingGas -\n', '            gasleft() +\n', '            16 *\n', '            msg.data.length;\n', '\n', '    }\n', '}\n', '\n', 'contract Pausable {\n', '\n', '    // keccak256("Pausable_FunctionPause")\n', '    bytes32 internal constant Pausable_FunctionPause = 0xa7143c84d793a15503da6f19bf9119a2dac94448ca45d77c8bf08f57b2e91047;\n', '\n', '    modifier pausable(bytes4 sig) {\n', '        require(!_isPaused(sig), "unauthorized");\n', '        _;\n', '    }\n', '\n', '    function _isPaused(\n', '        bytes4 sig)\n', '        internal\n', '        view\n', '        returns (bool isPaused)\n', '    {\n', '        bytes32 slot = keccak256(abi.encodePacked(sig, Pausable_FunctionPause));\n', '        assembly {\n', '            isPaused := sload(slot)\n', '        }\n', '    }\n', '}\n', '\n', 'contract LoanTokenBase is ReentrancyGuard, Ownable, Pausable {\n', '\n', '    uint256 internal constant WEI_PRECISION = 10**18;\n', '    uint256 internal constant WEI_PERCENT_PRECISION = 10**20;\n', '\n', '    int256 internal constant sWEI_PRECISION = 10**18;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    // uint88 for tight packing -> 8 + 88 + 160 = 256\n', '    uint88 internal lastSettleTime_;\n', '\n', '    address public loanTokenAddress;\n', '\n', '    uint256 public baseRate;\n', '    uint256 public rateMultiplier;\n', '    uint256 public lowUtilBaseRate;\n', '    uint256 public lowUtilRateMultiplier;\n', '\n', '    uint256 public targetLevel;\n', '    uint256 public kinkLevel;\n', '    uint256 public maxScaleRate;\n', '\n', '    uint256 internal _flTotalAssetSupply;\n', '    uint256 public checkpointSupply;\n', '    uint256 public initialPrice;\n', '\n', '    mapping (uint256 => bytes32) public loanParamsIds; // mapping of keccak256(collateralToken, isTorqueLoan) to loanParamsId\n', '    mapping (address => uint256) internal checkpointPrices_; // price of token at last user checkpoint\n', '}\n', '\n', 'contract AdvancedTokenStorage is LoanTokenBase {\n', '    using SafeMath for uint256;\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '\n', '    event Mint(\n', '        address indexed minter,\n', '        uint256 tokenAmount,\n', '        uint256 assetAmount,\n', '        uint256 price\n', '    );\n', '\n', '    event Burn(\n', '        address indexed burner,\n', '        uint256 tokenAmount,\n', '        uint256 assetAmount,\n', '        uint256 price\n', '    );\n', '\n', '    mapping(address => uint256) internal balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    uint256 internal totalSupply_;\n', '\n', '    function totalSupply()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function balanceOf(\n', '        address _owner)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(\n', '        address _owner,\n', '        address _spender)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract AdvancedToken is AdvancedTokenStorage {\n', '    using SafeMath for uint256;\n', '\n', '    function approve(\n', '        address _spender,\n', '        uint256 _value)\n', '        public\n', '        returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint256 _addedValue)\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint256 _allowed = allowed[msg.sender][_spender]\n', '            .add(_addedValue);\n', '        allowed[msg.sender][_spender] = _allowed;\n', '\n', '        emit Approval(msg.sender, _spender, _allowed);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint256 _subtractedValue)\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint256 _allowed = allowed[msg.sender][_spender];\n', '        if (_subtractedValue >= _allowed) {\n', '            _allowed = 0;\n', '        } else {\n', '            _allowed -= _subtractedValue;\n', '        }\n', '        allowed[msg.sender][_spender] = _allowed;\n', '\n', '        emit Approval(msg.sender, _spender, _allowed);\n', '        return true;\n', '    }\n', '\n', '    function _mint(\n', '        address _to,\n', '        uint256 _tokenAmount,\n', '        uint256 _assetAmount,\n', '        uint256 _price)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        require(_to != address(0), "15");\n', '\n', '        uint256 _balance = balances[_to]\n', '            .add(_tokenAmount);\n', '        balances[_to] = _balance;\n', '\n', '        totalSupply_ = totalSupply_\n', '            .add(_tokenAmount);\n', '\n', '        emit Mint(_to, _tokenAmount, _assetAmount, _price);\n', '        emit Transfer(address(0), _to, _tokenAmount);\n', '\n', '        return _balance;\n', '    }\n', '\n', '    function _burn(\n', '        address _who,\n', '        uint256 _tokenAmount,\n', '        uint256 _assetAmount,\n', '        uint256 _price)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        uint256 _balance = balances[_who].sub(_tokenAmount, "16");\n', '        \n', '        // a rounding error may leave dust behind, so we clear this out\n', '        if (_balance <= 10) {\n', '            _tokenAmount = _tokenAmount.add(_balance);\n', '            _balance = 0;\n', '        }\n', '        balances[_who] = _balance;\n', '\n', '        totalSupply_ = totalSupply_.sub(_tokenAmount);\n', '\n', '        emit Burn(_who, _tokenAmount, _assetAmount, _price);\n', '        emit Transfer(_who, address(0), _tokenAmount);\n', '\n', '        return _balance;\n', '    }\n', '}\n', '\n', 'contract LoanTokenLogicStandard is AdvancedToken, GasTokenUser {\n', '    using SafeMath for uint256;\n', '    using SignedSafeMath for int256;\n', '\n', '    modifier settlesInterest() {\n', '        _settleInterest();\n', '        _;\n', '    }\n', '\n', '    address internal target_;\n', '\n', '    uint256 public constant VERSION = 6;\n', '    address internal constant arbitraryCaller = 0x000F400e6818158D541C3EBE45FE3AA0d47372FF;\n', '\n', '    address public constant bZxContract = 0xD8Ee69652E4e4838f2531732a46d1f7F584F0b7f;\n', '    address public constant wethToken = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '\n', '    bytes32 internal constant iToken_ProfitSoFar = 0x37aa2b7d583612f016e4a4de4292cb015139b3d7762663d06a53964912ea2fb6;          // keccak256("iToken_ProfitSoFar")\n', '    bytes32 internal constant iToken_LowerAdminAddress = 0x7ad06df6a0af6bd602d90db766e0d5f253b45187c3717a0f9026ea8b10ff0d4b;    // keccak256("iToken_LowerAdminAddress")\n', '    bytes32 internal constant iToken_LowerAdminContract = 0x34b31cff1dbd8374124bd4505521fc29cab0f9554a5386ba7d784a4e611c7e31;   // keccak256("iToken_LowerAdminContract")\n', '\n', '\n', '    constructor(\n', '        address _newOwner)\n', '        public\n', '    {\n', '        transferOwnership(_newOwner);\n', '    }\n', '\n', '    function()\n', '        external\n', '    {\n', '        revert("fallback not allowed");\n', '    }\n', '\n', '    /* Public functions */\n', '\n', '    function mint(\n', '        address receiver,\n', '        uint256 depositAmount)\n', '        external\n', '        nonReentrant\n', '        returns (uint256) // mintAmount\n', '    {\n', '        return _mintToken(\n', '            receiver,\n', '            depositAmount\n', '        );\n', '    }\n', '\n', '    function burn(\n', '        address receiver,\n', '        uint256 burnAmount)\n', '        external\n', '        nonReentrant\n', '        returns (uint256 loanAmountPaid)\n', '    {\n', '        loanAmountPaid = _burnToken(\n', '            burnAmount\n', '        );\n', '\n', '        if (loanAmountPaid != 0) {\n', '            _safeTransfer(loanTokenAddress, receiver, loanAmountPaid, "5");\n', '        }\n', '    }\n', '\n', '    function flashBorrow(\n', '        uint256 borrowAmount,\n', '        address borrower,\n', '        address target,\n', '        string calldata signature,\n', '        bytes calldata data)\n', '        external\n', '        payable\n', '        nonReentrant\n', '        pausable(msg.sig)\n', '        settlesInterest\n', '        returns (bytes memory)\n', '    {\n', '        require(borrowAmount != 0, "38");\n', '\n', '        // save before balances\n', '        uint256 beforeEtherBalance = address(this).balance.sub(msg.value);\n', '        uint256 beforeAssetsBalance = _underlyingBalance()\n', '            .add(totalAssetBorrow());\n', '\n', '        // lock totalAssetSupply for duration of flash loan\n', '        _flTotalAssetSupply = beforeAssetsBalance;\n', '\n', '        // transfer assets to calling contract\n', '        _safeTransfer(loanTokenAddress, borrower, borrowAmount, "39");\n', '\n', '        bytes memory callData;\n', '        if (bytes(signature).length == 0) {\n', '            callData = data;\n', '        } else {\n', '            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n', '        }\n', '\n', '        // arbitrary call\n', '        (bool success, bytes memory returnData) = arbitraryCaller.call.value(msg.value)(\n', '            abi.encodeWithSelector(\n', '                0xde064e0d, // sendCall(address,bytes)\n', '                target,\n', '                callData\n', '            )\n', '        );\n', '        require(success, "call failed");\n', '\n', '        // unlock totalAssetSupply\n', '        _flTotalAssetSupply = 0;\n', '\n', '        // verifies return of flash loan\n', '        require(\n', '            address(this).balance >= beforeEtherBalance &&\n', '            _underlyingBalance()\n', '                .add(totalAssetBorrow()) >= beforeAssetsBalance,\n', '            "40"\n', '        );\n', '\n', '        return returnData;\n', '    }\n', '\n', '    // ***** NOTE: Reentrancy is allowed here to allow flashloan use cases *****\n', '    function borrow(\n', '        bytes32 loanId,                 // 0 if new loan\n', '        uint256 withdrawAmount,\n', '        uint256 initialLoanDuration,    // duration in seconds\n', '        uint256 collateralTokenSent,    // if 0, loanId must be provided; any ETH sent must equal this value\n', '        address collateralTokenAddress, // if address(0), this means ETH and ETH must be sent with the call or loanId must be provided\n', '        address borrower,\n', '        address receiver,\n', '        bytes memory /*loanDataBytes*/) // arbitrary order data (for future use)\n', '        public\n', '        payable\n', '        nonReentrant\n', '        returns (uint256, uint256) // returns new principal and new collateral added to loan\n', '    {\n', '        return _borrow(\n', '            loanId,\n', '            withdrawAmount,\n', '            initialLoanDuration,\n', '            collateralTokenSent,\n', '            collateralTokenAddress,\n', '            borrower,\n', '            receiver,\n', '            ""\n', '        );\n', '    }\n', '\n', '    // ***** NOTE: Reentrancy is allowed here to allow flashloan use cases *****\n', '    function borrowWithGasToken(\n', '        bytes32 loanId,                 // 0 if new loan\n', '        uint256 withdrawAmount,\n', '        uint256 initialLoanDuration,    // duration in seconds\n', '        uint256 collateralTokenSent,    // if 0, loanId must be provided; any ETH sent must equal this value\n', '        address collateralTokenAddress, // if address(0), this means ETH and ETH must be sent with the call or loanId must be provided\n', '        address borrower,\n', '        address receiver,\n', '        address gasTokenUser,           // specifies an address that has given spend approval for gas/chi token\n', '        bytes memory /*loanDataBytes*/) // arbitrary order data (for future use)\n', '        public\n', '        payable\n', '        nonReentrant\n', '        usesGasToken(gasTokenUser)\n', '        returns (uint256, uint256) // returns new principal and new collateral added to loan\n', '    {\n', '        return _borrow(\n', '            loanId,\n', '            withdrawAmount,\n', '            initialLoanDuration,\n', '            collateralTokenSent,\n', '            collateralTokenAddress,\n', '            borrower,\n', '            receiver,\n', '            ""\n', '        );\n', '    }\n', '\n', '    // Called to borrow and immediately get into a position\n', '    // ***** NOTE: Reentrancy is allowed here to allow flashloan use cases *****\n', '    function marginTrade(\n', '        bytes32 loanId,                 // 0 if new loan\n', '        uint256 leverageAmount,\n', '        uint256 loanTokenSent,\n', '        uint256 collateralTokenSent,\n', '        address collateralTokenAddress,\n', '        address trader,\n', '        bytes memory loanDataBytes)     // arbitrary order data\n', '        public\n', '        payable\n', '        nonReentrant\n', '        returns (uint256, uint256) // returns new principal and new collateral added to trade\n', '    {\n', '        return _marginTrade(\n', '            loanId,\n', '            leverageAmount,\n', '            loanTokenSent,\n', '            collateralTokenSent,\n', '            collateralTokenAddress,\n', '            trader,\n', '            loanDataBytes\n', '        );\n', '    }\n', '\n', '    // Called to borrow and immediately get into a position\n', '    // ***** NOTE: Reentrancy is allowed here to allow flashloan use cases *****\n', '    function marginTradeWithGasToken(\n', '        bytes32 loanId,                 // 0 if new loan\n', '        uint256 leverageAmount,\n', '        uint256 loanTokenSent,\n', '        uint256 collateralTokenSent,\n', '        address collateralTokenAddress,\n', '        address trader,\n', '        address gasTokenUser,           // specifies an address that has given spend approval for gas/chi token\n', '        bytes memory loanDataBytes)     // arbitrary order data\n', '        public\n', '        payable\n', '        nonReentrant\n', '        usesGasToken(gasTokenUser)\n', '        returns (uint256, uint256) // returns new principal and new collateral added to trade\n', '    {\n', '        return _marginTrade(\n', '            loanId,\n', '            leverageAmount,\n', '            loanTokenSent,\n', '            collateralTokenSent,\n', '            collateralTokenAddress,\n', '            trader,\n', '            loanDataBytes\n', '        );\n', '    }\n', '\n', '    function transfer(\n', '        address _to,\n', '        uint256 _value)\n', '        external\n', '        returns (bool)\n', '    {\n', '        return _internalTransferFrom(\n', '            msg.sender,\n', '            _to,\n', '            _value,\n', '            uint256(-1)\n', '        );\n', '    }\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value)\n', '        external\n', '        returns (bool)\n', '    {\n', '        return _internalTransferFrom(\n', '            _from,\n', '            _to,\n', '            _value,\n', '            allowed[_from][msg.sender]\n', '            /*ProtocolLike(bZxContract).isLoanPool(msg.sender) ?\n', '                uint256(-1) :\n', '                allowed[_from][msg.sender]*/\n', '        );\n', '    }\n', '\n', '    function _internalTransferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value,\n', '        uint256 _allowanceAmount)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        if (_allowanceAmount != uint256(-1)) {\n', '            allowed[_from][msg.sender] = _allowanceAmount.sub(_value, "14");\n', '        }\n', '\n', '        require(_to != address(0), "15");\n', '\n', '        uint256 _balancesFrom = balances[_from];\n', '        uint256 _balancesFromNew = _balancesFrom\n', '            .sub(_value, "16");\n', '        balances[_from] = _balancesFromNew;\n', '\n', '        uint256 _balancesTo = balances[_to];\n', '        uint256 _balancesToNew = _balancesTo\n', '            .add(_value);\n', '        balances[_to] = _balancesToNew;\n', '\n', '        // handle checkpoint update\n', '        uint256 _currentPrice = tokenPrice();\n', '\n', '        _updateCheckpoints(\n', '            _from,\n', '            _balancesFrom,\n', '            _balancesFromNew,\n', '            _currentPrice\n', '        );\n', '        _updateCheckpoints(\n', '            _to,\n', '            _balancesTo,\n', '            _balancesToNew,\n', '            _currentPrice\n', '        );\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function _updateCheckpoints(\n', '        address _user,\n', '        uint256 _oldBalance,\n', '        uint256 _newBalance,\n', '        uint256 _currentPrice)\n', '        internal\n', '    {\n', '        bytes32 slot = keccak256(\n', '            abi.encodePacked(_user, iToken_ProfitSoFar)\n', '        );\n', '\n', '        int256 _currentProfit;\n', '        if (_newBalance == 0) {\n', '            _currentPrice = 0;\n', '        } else if (_oldBalance != 0) {\n', '            _currentProfit = _profitOf(\n', '                slot,\n', '                _oldBalance,\n', '                _currentPrice,\n', '                checkpointPrices_[_user]\n', '            );\n', '        }\n', '\n', '        assembly {\n', '            sstore(slot, _currentProfit)\n', '        }\n', '\n', '        checkpointPrices_[_user] = _currentPrice;\n', '    }\n', '\n', '    /* Public View functions */\n', '\n', '    function profitOf(\n', '        address user)\n', '        public\n', '        view\n', '        returns (int256)\n', '    {\n', '        bytes32 slot = keccak256(\n', '            abi.encodePacked(user, iToken_ProfitSoFar)\n', '        );\n', '\n', '        return _profitOf(\n', '            slot,\n', '            balances[user],\n', '            tokenPrice(),\n', '            checkpointPrices_[user]\n', '        );\n', '    }\n', '\n', '    function _profitOf(\n', '        bytes32 slot,\n', '        uint256 _balance,\n', '        uint256 _currentPrice,\n', '        uint256 _checkpointPrice)\n', '        internal\n', '        view\n', '        returns (int256 profitSoFar)\n', '    {\n', '        if (_checkpointPrice == 0) {\n', '            return 0;\n', '        }\n', '\n', '        assembly {\n', '            profitSoFar := sload(slot)\n', '        }\n', '\n', '        profitSoFar = int256(_currentPrice)\n', '            .sub(int256(_checkpointPrice))\n', '            .mul(int256(_balance))\n', '            .div(sWEI_PRECISION)\n', '            .add(profitSoFar);\n', '    }\n', '\n', '    function tokenPrice()\n', '        public\n', '        view\n', '        returns (uint256) // price\n', '    {\n', '        uint256 interestUnPaid;\n', '        if (lastSettleTime_ != uint88(block.timestamp)) {\n', '            (,interestUnPaid) = _getAllInterest();\n', '        }\n', '\n', '        return _tokenPrice(_totalAssetSupply(interestUnPaid));\n', '    }\n', '\n', '    function checkpointPrice(\n', '        address _user)\n', '        public\n', '        view\n', '        returns (uint256) // price\n', '    {\n', '        return checkpointPrices_[_user];\n', '    }\n', '\n', '    function marketLiquidity()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 totalSupply = _totalAssetSupply(0);\n', '        uint256 totalBorrow = totalAssetBorrow();\n', '        if (totalSupply > totalBorrow) {\n', '            return totalSupply - totalBorrow;\n', '        }\n', '    }\n', '\n', '    function avgBorrowInterestRate()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _avgBorrowInterestRate(totalAssetBorrow());\n', '    }\n', '\n', '    // the minimum rate the next base protocol borrower will receive for variable-rate loans\n', '    function borrowInterestRate()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _nextBorrowInterestRate(0);\n', '    }\n', '\n', '    function nextBorrowInterestRate(\n', '        uint256 borrowAmount)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _nextBorrowInterestRate(borrowAmount);\n', '    }\n', '\n', '    // interest that lenders are currently receiving when supplying to the pool\n', '    function supplyInterestRate()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return totalSupplyInterestRate(_totalAssetSupply(0));\n', '    }\n', '\n', '    function nextSupplyInterestRate(\n', '        uint256 supplyAmount)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return totalSupplyInterestRate(_totalAssetSupply(0).add(supplyAmount));\n', '    }\n', '\n', '    function totalSupplyInterestRate(\n', '        uint256 assetSupply)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 assetBorrow = totalAssetBorrow();\n', '        if (assetBorrow != 0) {\n', '            return _supplyInterestRate(\n', '                assetBorrow,\n', '                assetSupply\n', '            );\n', '        }\n', '    }\n', '\n', '    function totalAssetBorrow()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return ProtocolLike(bZxContract).getTotalPrincipal(\n', '            address(this),\n', '            loanTokenAddress\n', '        );\n', '    }\n', '\n', '    function totalAssetSupply()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 interestUnPaid;\n', '        if (lastSettleTime_ != uint88(block.timestamp)) {\n', '            (,interestUnPaid) = _getAllInterest();\n', '        }\n', '\n', '        return _totalAssetSupply(interestUnPaid);\n', '    }\n', '\n', '    function getMaxEscrowAmount(\n', '        uint256 leverageAmount)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 initialMargin = SafeMath.div(WEI_PRECISION * WEI_PERCENT_PRECISION, leverageAmount);\n', '        return marketLiquidity()\n', '            .mul(initialMargin)\n', '            .div(_adjustValue(\n', '                WEI_PERCENT_PRECISION, // maximum possible interest (100%)\n', '                2419200, // 28 day duration for margin trades\n', '                initialMargin));\n', '    }\n', '\n', "    // returns the user's balance of underlying token\n", '    function assetBalanceOf(\n', '        address _owner)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return balanceOf(_owner)\n', '            .mul(tokenPrice())\n', '            .div(WEI_PRECISION);\n', '    }\n', '\n', '    function getEstimatedMarginDetails(\n', '        uint256 leverageAmount,\n', '        uint256 loanTokenSent,\n', '        uint256 collateralTokenSent,\n', '        address collateralTokenAddress)     // address(0) means ETH\n', '        public\n', '        view\n', '        returns (uint256 principal, uint256 collateral, uint256 interestRate)\n', '    {\n', '        if (collateralTokenAddress == address(0)) {\n', '            collateralTokenAddress = wethToken;\n', '        }\n', '\n', '        uint256 totalDeposit = _totalDeposit(\n', '            collateralTokenAddress,\n', '            collateralTokenSent,\n', '            loanTokenSent\n', '        );\n', '\n', '        (principal, interestRate) = _getMarginBorrowAmountAndRate(\n', '            leverageAmount,\n', '            totalDeposit\n', '        );\n', '        if (principal > _underlyingBalance()) {\n', '            return (0, 0, 0);\n', '        }\n', '\n', '        loanTokenSent = loanTokenSent\n', '            .add(principal);\n', '\n', '        collateral = ProtocolLike(bZxContract).getEstimatedMarginExposure(\n', '            loanTokenAddress,\n', '            collateralTokenAddress,\n', '            loanTokenSent,\n', '            collateralTokenSent,\n', '            interestRate,\n', '            principal\n', '        );\n', '    }\n', '\n', '    function getDepositAmountForBorrow(\n', '        uint256 borrowAmount,\n', '        uint256 initialLoanDuration,        // duration in seconds\n', '        address collateralTokenAddress)     // address(0) means ETH\n', '        public\n', '        view\n', '        returns (uint256) // depositAmount\n', '    {\n', '        if (borrowAmount != 0) {\n', '            (,,uint256 newBorrowAmount) = _getInterestRateAndBorrowAmount(\n', '                borrowAmount,\n', '                totalAssetSupply(),\n', '                initialLoanDuration\n', '            );\n', '\n', '            if (newBorrowAmount <= _underlyingBalance()) {\n', '                return ProtocolLike(bZxContract).getRequiredCollateralByParams(\n', '                    loanParamsIds[uint256(keccak256(abi.encodePacked(\n', '                        collateralTokenAddress,\n', '                        true\n', '                    )))],\n', '                    loanTokenAddress,\n', '                    collateralTokenAddress != address(0) ? collateralTokenAddress : wethToken,\n', '                    newBorrowAmount,\n', '                    true // isTorqueLoan\n', '                ).add(10); // some dust to compensate for rounding errors\n', '            }\n', '        }\n', '    }\n', '\n', '    function getBorrowAmountForDeposit(\n', '        uint256 depositAmount,\n', '        uint256 initialLoanDuration,        // duration in seconds\n', '        address collateralTokenAddress)     // address(0) means ETH\n', '        public\n', '        view\n', '        returns (uint256 borrowAmount)\n', '    {\n', '        if (depositAmount != 0) {\n', '            borrowAmount = ProtocolLike(bZxContract).getBorrowAmountByParams(\n', '                loanParamsIds[uint256(keccak256(abi.encodePacked(\n', '                    collateralTokenAddress,\n', '                    true\n', '                )))],\n', '                loanTokenAddress,\n', '                collateralTokenAddress != address(0) ? collateralTokenAddress : wethToken,\n', '                depositAmount,\n', '                true // isTorqueLoan\n', '            );\n', '\n', '            (,,borrowAmount) = _getInterestRateAndBorrowAmount(\n', '                borrowAmount,\n', '                totalAssetSupply(),\n', '                initialLoanDuration\n', '            );\n', '\n', '            if (borrowAmount > _underlyingBalance()) {\n', '                borrowAmount = 0;\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /* Internal functions */\n', '\n', '    function _mintToken(\n', '        address receiver,\n', '        uint256 depositAmount)\n', '        internal\n', '        settlesInterest\n', '        returns (uint256 mintAmount)\n', '    {\n', '        require (depositAmount != 0, "17");\n', '\n', '        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\n', '        mintAmount = depositAmount\n', '            .mul(WEI_PRECISION)\n', '            .div(currentPrice);\n', '\n', '        if (msg.value == 0) {\n', '            _safeTransferFrom(loanTokenAddress, msg.sender, address(this), depositAmount, "18");\n', '        } else {\n', '            require(msg.value == depositAmount, "18");\n', '            IWeth(wethToken).deposit.value(depositAmount)();\n', '        }\n', '\n', '        _updateCheckpoints(\n', '            receiver,\n', '            balances[receiver],\n', '            _mint(receiver, mintAmount, depositAmount, currentPrice), // newBalance\n', '            currentPrice\n', '        );\n', '    }\n', '\n', '    function _burnToken(\n', '        uint256 burnAmount)\n', '        internal\n', '        settlesInterest\n', '        returns (uint256 loanAmountPaid)\n', '    {\n', '        require(burnAmount != 0, "19");\n', '\n', '        if (burnAmount > balanceOf(msg.sender)) {\n', '            require(burnAmount == uint256(-1), "32");\n', '            burnAmount = balanceOf(msg.sender);\n', '        }\n', '\n', '        uint256 currentPrice = _tokenPrice(_totalAssetSupply(0));\n', '\n', '        uint256 loanAmountOwed = burnAmount\n', '            .mul(currentPrice)\n', '            .div(WEI_PRECISION);\n', '        uint256 loanAmountAvailableInContract = _underlyingBalance();\n', '\n', '        loanAmountPaid = loanAmountOwed;\n', '        require(loanAmountPaid <= loanAmountAvailableInContract, "37");\n', '\n', '        _updateCheckpoints(\n', '            msg.sender,\n', '            balances[msg.sender],\n', '            _burn(msg.sender, burnAmount, loanAmountPaid, currentPrice), // newBalance\n', '            currentPrice\n', '        );\n', '    }\n', '\n', '    function _borrow(\n', '        bytes32 loanId,                 // 0 if new loan\n', '        uint256 withdrawAmount,\n', '        uint256 initialLoanDuration,    // duration in seconds\n', '        uint256 collateralTokenSent,    // if 0, loanId must be provided; any ETH sent must equal this value\n', '        address collateralTokenAddress, // if address(0), this means ETH and ETH must be sent with the call or loanId must be provided\n', '        address borrower,\n', '        address receiver,\n', '        bytes memory /*loanDataBytes*/) // arbitrary order data (for future use)\n', '        internal\n', '        pausable(msg.sig)\n', '        settlesInterest\n', '        returns (uint256, uint256) // returns new principal and new collateral added to loan\n', '    {\n', '        require(withdrawAmount != 0, "6");\n', '\n', '        require(msg.value == 0 || msg.value == collateralTokenSent, "7");\n', '        require(collateralTokenSent != 0 || loanId != 0, "8");\n', '        require(collateralTokenAddress != address(0) || msg.value != 0 || loanId != 0, "9");\n', '\n', '        // ensures authorized use of existing loan\n', '        require(loanId == 0 || msg.sender == borrower, "13");\n', '\n', '        if (collateralTokenAddress == address(0)) {\n', '            collateralTokenAddress = wethToken;\n', '        }\n', '        require(collateralTokenAddress != loanTokenAddress, "10");\n', '\n', '        address[4] memory sentAddresses;\n', '        uint256[5] memory sentAmounts;\n', '\n', '        sentAddresses[0] = address(this); // lender\n', '        sentAddresses[1] = borrower;\n', '        sentAddresses[2] = receiver;\n', '        //sentAddresses[3] = address(0); // manager\n', '\n', '        //sentAmounts[0] = 0; // interestRate (found later)\n', '        //sentAmounts[1] = 0; // borrowAmount (found later)\n', '        //sentAmounts[2] = 0; // interestInitialAmount (found later)\n', '        //sentAmounts[3] = 0; // loanTokenSent\n', '        sentAmounts[4] = collateralTokenSent;\n', '\n', '        // interestRate, interestInitialAmount, borrowAmount (newBorrowAmount)\n', '        (sentAmounts[0], sentAmounts[2], sentAmounts[1]) = _getInterestRateAndBorrowAmount(\n', '            withdrawAmount,\n', '            _totalAssetSupply(0), // interest is settled above\n', '            initialLoanDuration\n', '        );\n', '\n', '        return _borrowOrTrade(\n', '            loanId,\n', '            withdrawAmount,\n', '            0, // leverageAmount (calculated later)\n', '            collateralTokenAddress,\n', '            sentAddresses,\n', '            sentAmounts,\n', '            "" // loanDataBytes\n', '        );\n', '    }\n', '\n', '    function _marginTrade(\n', '        bytes32 loanId,                 // 0 if new loan\n', '        uint256 leverageAmount,\n', '        uint256 loanTokenSent,\n', '        uint256 collateralTokenSent,\n', '        address collateralTokenAddress,\n', '        address trader,\n', '        bytes memory loanDataBytes)\n', '        internal\n', '        pausable(msg.sig)\n', '        settlesInterest\n', '        returns (uint256, uint256) // returns new principal and new collateral added to trade\n', '    {\n', '        // ensures authorized use of existing loan\n', '        require(loanId == 0 || msg.sender == trader, "13");\n', '\n', '        if (collateralTokenAddress == address(0)) {\n', '            collateralTokenAddress = wethToken;\n', '        }\n', '        require(collateralTokenAddress != loanTokenAddress, "11");\n', '\n', '        uint256 totalDeposit = _totalDeposit(\n', '            collateralTokenAddress,\n', '            collateralTokenSent,\n', '            loanTokenSent\n', '        );\n', '        require(totalDeposit != 0, "12");\n', '\n', '        address[4] memory sentAddresses;\n', '        uint256[5] memory sentAmounts;\n', '\n', '        sentAddresses[0] = address(this); // lender\n', '        sentAddresses[1] = trader;\n', '        sentAddresses[2] = trader;\n', '        //sentAddresses[3] = address(0); // manager\n', '\n', '        //sentAmounts[0] = 0; // interestRate (found later)\n', '        //sentAmounts[1] = 0; // borrowAmount (found later)\n', '        //sentAmounts[2] = 0; // interestInitialAmount (interest is calculated based on fixed-term loan)\n', '        sentAmounts[3] = loanTokenSent;\n', '        sentAmounts[4] = collateralTokenSent;\n', '\n', '        (sentAmounts[1], sentAmounts[0]) = _getMarginBorrowAmountAndRate( // borrowAmount, interestRate\n', '            leverageAmount,\n', '            totalDeposit\n', '        );\n', '\n', '        return _borrowOrTrade(\n', '            loanId,\n', '            0, // withdrawAmount\n', '            leverageAmount,\n', '            collateralTokenAddress,\n', '            sentAddresses,\n', '            sentAmounts,\n', '            loanDataBytes\n', '        );\n', '    }\n', '\n', '    function _settleInterest()\n', '        internal\n', '    {\n', '        uint88 ts = uint88(block.timestamp);\n', '        if (lastSettleTime_ != ts) {\n', '            ProtocolLike(bZxContract).withdrawAccruedInterest(\n', '                loanTokenAddress\n', '            );\n', '\n', '            lastSettleTime_ = ts;\n', '        }\n', '    }\n', '\n', '    function _totalDeposit(\n', '        address collateralTokenAddress,\n', '        uint256 collateralTokenSent,\n', '        uint256 loanTokenSent)\n', '        internal\n', '        view\n', '        returns (uint256 totalDeposit)\n', '    {\n', '        totalDeposit = loanTokenSent;\n', '        if (collateralTokenSent != 0) {\n', '            (uint256 sourceToDestRate, uint256 sourceToDestPrecision) = FeedsLike(ProtocolLike(bZxContract).priceFeeds()).queryRate(\n', '                collateralTokenAddress,\n', '                loanTokenAddress\n', '            );\n', '            if (sourceToDestRate != 0) {\n', '                totalDeposit = collateralTokenSent\n', '                    .mul(sourceToDestRate)\n', '                    .div(sourceToDestPrecision)\n', '                    .add(totalDeposit);\n', '            }\n', '        }\n', '    }\n', '\n', '    function _getInterestRateAndBorrowAmount(\n', '        uint256 borrowAmount,\n', '        uint256 assetSupply,\n', '        uint256 initialLoanDuration) // duration in seconds\n', '        internal\n', '        view\n', '        returns (uint256 interestRate, uint256 interestInitialAmount, uint256 newBorrowAmount)\n', '    {\n', '        interestRate = _nextBorrowInterestRate2(\n', '            borrowAmount,\n', '            assetSupply\n', '        );\n', '\n', '        // newBorrowAmount = borrowAmount * 10^18 / (10^18 - (interestRate * initialLoanDuration * 10^18 / (31536000 * 10^20)))\n', '        newBorrowAmount = borrowAmount\n', '            .mul(WEI_PRECISION)\n', '            .div(\n', '                SafeMath.sub(WEI_PRECISION,\n', '                    interestRate\n', '                        .mul(initialLoanDuration)\n', '                        .mul(WEI_PRECISION)\n', '                        .div(31536000 * WEI_PERCENT_PRECISION) // 365 * 86400 * WEI_PERCENT_PRECISION\n', '                )\n', '            );\n', '\n', '        interestInitialAmount = newBorrowAmount\n', '            .sub(borrowAmount);\n', '    }\n', '\n', '    // returns newPrincipal\n', '    function _borrowOrTrade(\n', '        bytes32 loanId,\n', '        uint256 withdrawAmount,\n', '        uint256 leverageAmount,\n', '        address collateralTokenAddress,\n', '        address[4] memory sentAddresses,\n', '        uint256[5] memory sentAmounts,\n', '        bytes memory loanDataBytes)\n', '        internal\n', '        returns (uint256, uint256)\n', '    {\n', '        require (sentAmounts[1] <= _underlyingBalance() && // newPrincipal\n', '            sentAddresses[1] != address(0), // borrower\n', '            "24"\n', '        );\n', '\n', '\t    if (sentAddresses[2] == address(0)) {\n', '            sentAddresses[2] = sentAddresses[1]; // receiver = borrower\n', '        }\n', '\n', '        // handle transfers prior to adding newPrincipal to loanTokenSent\n', '        uint256 msgValue = _verifyTransfers(\n', '            collateralTokenAddress,\n', '            sentAddresses,\n', '            sentAmounts,\n', '            withdrawAmount\n', '        );\n', '\n', '        // adding the loan token portion from the lender to loanTokenSent\n', '        sentAmounts[3] = sentAmounts[3]\n', '            .add(sentAmounts[1]); // newPrincipal\n', '\n', '        if (withdrawAmount != 0) {\n', "            // withdrawAmount already sent to the borrower, so we aren't sending it to the protocol\n", '            sentAmounts[3] = sentAmounts[3]\n', '                .sub(withdrawAmount);\n', '        }\n', '\n', '        bool isTorqueLoan = withdrawAmount != 0 ?\n', '            true :\n', '            false;\n', '\n', '        bytes32 loanParamsId = loanParamsIds[uint256(keccak256(abi.encodePacked(\n', '            collateralTokenAddress,\n', '            isTorqueLoan\n', '        )))];\n', '\n', '        // converting to initialMargin\n', '        if (leverageAmount != 0) {\n', '            leverageAmount = SafeMath.div(WEI_PRECISION * WEI_PERCENT_PRECISION, leverageAmount);\n', '        }\n', '\n', '        (sentAmounts[1], sentAmounts[4]) = ProtocolLike(bZxContract).borrowOrTradeFromPool.value(msgValue)( // newPrincipal, newCollateral\n', '            loanParamsId,\n', '            loanId,\n', '            isTorqueLoan,\n', '            leverageAmount, // initialMargin\n', '            sentAddresses,\n', '            sentAmounts,\n', '            loanDataBytes\n', '        );\n', '        require (sentAmounts[1] != 0, "25");\n', '\n', '        return (sentAmounts[1], sentAmounts[4]); // newPrincipal, newCollateral\n', '    }\n', '\n', '    // sentAddresses[0]: lender\n', '    // sentAddresses[1]: borrower\n', '    // sentAddresses[2]: receiver\n', '    // sentAddresses[3]: manager\n', '    // sentAmounts[0]: interestRate\n', '    // sentAmounts[1]: newPrincipal\n', '    // sentAmounts[2]: interestInitialAmount\n', '    // sentAmounts[3]: loanTokenSent\n', '    // sentAmounts[4]: collateralTokenSent\n', '    function _verifyTransfers(\n', '        address collateralTokenAddress,\n', '        address[4] memory sentAddresses,\n', '        uint256[5] memory sentAmounts,\n', '        uint256 withdrawalAmount)\n', '        internal\n', '        returns (uint256 msgValue)\n', '    {\n', '        address _wethToken = wethToken;\n', '        address _loanTokenAddress = loanTokenAddress;\n', '        address receiver = sentAddresses[2];\n', '        uint256 newPrincipal = sentAmounts[1];\n', '        uint256 loanTokenSent = sentAmounts[3];\n', '        uint256 collateralTokenSent = sentAmounts[4];\n', '\n', '        require(_loanTokenAddress != collateralTokenAddress, "26");\n', '\n', '        msgValue = msg.value;\n', '\n', '        if (withdrawalAmount != 0) { // withdrawOnOpen == true\n', '            _safeTransfer(_loanTokenAddress, receiver, withdrawalAmount, "27");\n', '            if (newPrincipal > withdrawalAmount) {\n', '                _safeTransfer(_loanTokenAddress, bZxContract, newPrincipal - withdrawalAmount, "27");\n', '            }\n', '        } else {\n', '            _safeTransfer(_loanTokenAddress, bZxContract, newPrincipal, "27");\n', '        }\n', '\n', '        if (collateralTokenSent != 0) {\n', '            if (collateralTokenAddress == _wethToken && msgValue != 0 && msgValue >= collateralTokenSent) {\n', '                IWeth(_wethToken).deposit.value(collateralTokenSent)();\n', '                _safeTransfer(collateralTokenAddress, bZxContract, collateralTokenSent, "28");\n', '                msgValue -= collateralTokenSent;\n', '            } else {\n', '                _safeTransferFrom(collateralTokenAddress, msg.sender, bZxContract, collateralTokenSent, "28");\n', '            }\n', '        }\n', '\n', '        if (loanTokenSent != 0) {\n', '            _safeTransferFrom(_loanTokenAddress, msg.sender, bZxContract, loanTokenSent, "29");\n', '        }\n', '    }\n', '\n', '    function _safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 amount,\n', '        string memory errorMsg)\n', '        internal\n', '    {\n', '        _callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(IERC20(token).transfer.selector, to, amount),\n', '            errorMsg\n', '        );\n', '    }\n', '\n', '    function _safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        string memory errorMsg)\n', '        internal\n', '    {\n', '        _callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(IERC20(token).transferFrom.selector, from, to, amount),\n', '            errorMsg\n', '        );\n', '    }\n', '\n', '    function _callOptionalReturn(\n', '        address token,\n', '        bytes memory data,\n', '        string memory errorMsg)\n', '        internal\n', '    {\n', '        (bool success, bytes memory returndata) = token.call(data);\n', '        require(success, errorMsg);\n', '\n', '        if (returndata.length != 0) {\n', '            require(abi.decode(returndata, (bool)), errorMsg);\n', '        }\n', '    }\n', '\n', '    function _underlyingBalance()\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return IERC20(loanTokenAddress).balanceOf(address(this));\n', '    }\n', '\n', '    /* Internal View functions */\n', '\n', '    function _tokenPrice(\n', '        uint256 assetSupply)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 totalTokenSupply = totalSupply_;\n', '\n', '        return totalTokenSupply != 0 ?\n', '            assetSupply\n', '                .mul(WEI_PRECISION)\n', '                .div(totalTokenSupply) : initialPrice;\n', '    }\n', '\n', '    function _avgBorrowInterestRate(\n', '        uint256 assetBorrow)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (assetBorrow != 0) {\n', '            (uint256 interestOwedPerDay,) = _getAllInterest();\n', '            return interestOwedPerDay\n', '                .mul(365 * WEI_PERCENT_PRECISION)\n', '                .div(assetBorrow);\n', '        }\n', '    }\n', '\n', '    // next supply interest adjustment\n', '    function _supplyInterestRate(\n', '        uint256 assetBorrow,\n', '        uint256 assetSupply)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (assetBorrow != 0 && assetSupply >= assetBorrow) {\n', '            return _avgBorrowInterestRate(assetBorrow)\n', '                .mul(_utilizationRate(assetBorrow, assetSupply))\n', '                .mul(SafeMath.sub(WEI_PERCENT_PRECISION, ProtocolLike(bZxContract).lendingFeePercent()))\n', '                .div(WEI_PERCENT_PRECISION * WEI_PERCENT_PRECISION);\n', '        }\n', '    }\n', '\n', '    function _nextBorrowInterestRate(\n', '        uint256 borrowAmount)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 interestUnPaid;\n', '        if (borrowAmount != 0) {\n', '            if (lastSettleTime_ != uint88(block.timestamp)) {\n', '                (,interestUnPaid) = _getAllInterest();\n', '            }\n', '\n', '            uint256 balance = _underlyingBalance()\n', '                .add(interestUnPaid);\n', '            if (borrowAmount > balance) {\n', '                borrowAmount = balance;\n', '            }\n', '        }\n', '\n', '        return _nextBorrowInterestRate2(\n', '            borrowAmount,\n', '            _totalAssetSupply(interestUnPaid)\n', '        );\n', '    }\n', '\n', '    function _nextBorrowInterestRate2(\n', '        uint256 newBorrowAmount,\n', '        uint256 assetSupply)\n', '        internal\n', '        view\n', '        returns (uint256 nextRate)\n', '    {\n', '        uint256 utilRate = _utilizationRate(\n', '            totalAssetBorrow().add(newBorrowAmount),\n', '            assetSupply\n', '        );\n', '\n', '        uint256 thisMinRate;\n', '        uint256 thisMaxRate;\n', '        uint256 thisBaseRate = baseRate;\n', '        uint256 thisRateMultiplier = rateMultiplier;\n', '        uint256 thisTargetLevel = targetLevel;\n', '        uint256 thisKinkLevel = kinkLevel;\n', '        uint256 thisMaxScaleRate = maxScaleRate;\n', '\n', '        if (utilRate < thisTargetLevel) {\n', '            // target targetLevel utilization when utilization is under targetLevel\n', '            utilRate = thisTargetLevel;\n', '        }\n', '\n', '        if (utilRate > thisKinkLevel) {\n', '            // scale rate proportionally up to 100%\n', '            uint256 thisMaxRange = WEI_PERCENT_PRECISION - thisKinkLevel; // will not overflow\n', '\n', '            utilRate -= thisKinkLevel;\n', '            if (utilRate > thisMaxRange)\n', '                utilRate = thisMaxRange;\n', '\n', '            thisMaxRate = thisRateMultiplier\n', '                .add(thisBaseRate)\n', '                .mul(thisKinkLevel)\n', '                .div(WEI_PERCENT_PRECISION);\n', '\n', '            nextRate = utilRate\n', '                .mul(SafeMath.sub(thisMaxScaleRate, thisMaxRate))\n', '                .div(thisMaxRange)\n', '                .add(thisMaxRate);\n', '        } else {\n', '            nextRate = utilRate\n', '                .mul(thisRateMultiplier)\n', '                .div(WEI_PERCENT_PRECISION)\n', '                .add(thisBaseRate);\n', '\n', '            thisMinRate = thisBaseRate;\n', '            thisMaxRate = thisRateMultiplier\n', '                .add(thisBaseRate);\n', '\n', '            if (nextRate < thisMinRate)\n', '                nextRate = thisMinRate;\n', '            else if (nextRate > thisMaxRate)\n', '                nextRate = thisMaxRate;\n', '        }\n', '    }\n', '\n', '    function _getAllInterest()\n', '        internal\n', '        view\n', '        returns (\n', '            uint256 interestOwedPerDay,\n', '            uint256 interestUnPaid)\n', '    {\n', '        // interestPaid, interestPaidDate, interestOwedPerDay, interestUnPaid, interestFeePercent, principalTotal\n', '        uint256 interestFeePercent;\n', '        (,,interestOwedPerDay,interestUnPaid,interestFeePercent,) = ProtocolLike(bZxContract).getLenderInterestData(\n', '            address(this),\n', '            loanTokenAddress\n', '        );\n', '\n', '        interestUnPaid = interestUnPaid\n', '            .mul(SafeMath.sub(WEI_PERCENT_PRECISION, interestFeePercent))\n', '            .div(WEI_PERCENT_PRECISION);\n', '    }\n', '\n', '    function _getMarginBorrowAmountAndRate(\n', '        uint256 leverageAmount,\n', '        uint256 depositAmount)\n', '        internal\n', '        view\n', '        returns (uint256 borrowAmount, uint256 interestRate)\n', '    {\n', '        uint256 initialMargin = SafeMath.div(WEI_PRECISION * WEI_PERCENT_PRECISION, leverageAmount);\n', '\n', '        interestRate = _nextBorrowInterestRate2(\n', '            depositAmount\n', '                .mul(WEI_PERCENT_PRECISION)\n', '                .div(initialMargin),\n', '            _totalAssetSupply(0)\n', '        );\n', '\n', '        // assumes that loan, collateral, and interest token are the same\n', '        borrowAmount = depositAmount\n', '            .mul(WEI_PERCENT_PRECISION * WEI_PERCENT_PRECISION)\n', '            .div(_adjustValue(\n', '                interestRate,\n', '                2419200, // 28 day duration for margin trades\n', '                initialMargin))\n', '            .div(initialMargin);\n', '    }\n', '\n', '    function _totalAssetSupply(\n', '        uint256 interestUnPaid)\n', '        internal\n', '        view\n', '        returns (uint256) // assetSupply\n', '    {\n', '        if (totalSupply_ != 0) {\n', '            uint256 assetsBalance = _flTotalAssetSupply; // temporary locked totalAssetSupply during a flash loan transaction\n', '            if (assetsBalance == 0) {\n', '                assetsBalance = _underlyingBalance()\n', '                    .add(totalAssetBorrow());\n', '            }\n', '\n', '            return assetsBalance\n', '                .add(interestUnPaid);\n', '        }\n', '    }\n', '\n', '    function _adjustValue(\n', '        uint256 interestRate,\n', '        uint256 maxDuration,\n', '        uint256 marginAmount)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return maxDuration != 0 ?\n', '            interestRate\n', '                .mul(WEI_PERCENT_PRECISION)\n', '                .mul(maxDuration)\n', '                .div(31536000) // 86400 * 365\n', '                .div(marginAmount)\n', '                .add(WEI_PERCENT_PRECISION) :\n', '            WEI_PERCENT_PRECISION;\n', '    }\n', '\n', '    function _utilizationRate(\n', '        uint256 assetBorrow,\n', '        uint256 assetSupply)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        if (assetBorrow != 0 && assetSupply != 0) {\n', '            // U = total_borrow / total_supply\n', '            return assetBorrow\n', '                .mul(WEI_PERCENT_PRECISION)\n', '                .div(assetSupply);\n', '        }\n', '    }\n', '\n', '\n', '    /* Owner-Only functions */\n', '\n', '    function updateSettings(\n', '        address settingsTarget,\n', '        bytes memory callData)\n', '        public\n', '    {\n', '        if (msg.sender != owner()) {\n', '            address _lowerAdmin;\n', '            address _lowerAdminContract;\n', '            assembly {\n', '                _lowerAdmin := sload(iToken_LowerAdminAddress)\n', '                _lowerAdminContract := sload(iToken_LowerAdminContract)\n', '            }\n', '            require(msg.sender == _lowerAdmin && settingsTarget == _lowerAdminContract);\n', '        }\n', '\n', '        address currentTarget = target_;\n', '        target_ = settingsTarget;\n', '\n', '        (bool result,) = address(this).call(callData);\n', '\n', '        uint256 size;\n', '        uint256 ptr;\n', '        assembly {\n', '            size := returndatasize\n', '            ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '            if eq(result, 0) { revert(ptr, size) }\n', '        }\n', '\n', '        target_ = currentTarget;\n', '\n', '        assembly {\n', '            return(ptr, size)\n', '        }\n', '    }\n', '}\n', '\n', 'contract LoanTokenLogicWeth is LoanTokenLogicStandard {\n', '\n', '    constructor(\n', '        address _newOwner)\n', '        public\n', '        LoanTokenLogicStandard(_newOwner)\n', '    {}\n', '\n', '    function mintWithEther(\n', '        address receiver)\n', '        external\n', '        payable\n', '        nonReentrant\n', '        returns (uint256 mintAmount)\n', '    {\n', '        return _mintToken(\n', '            receiver,\n', '            msg.value\n', '        );\n', '    }\n', '\n', '    function burnToEther(\n', '        address receiver,\n', '        uint256 burnAmount)\n', '        external\n', '        nonReentrant\n', '        returns (uint256 loanAmountPaid)\n', '    {\n', '        loanAmountPaid = _burnToken(\n', '            burnAmount\n', '        );\n', '\n', '        if (loanAmountPaid != 0) {\n', '            IWethERC20(wethToken).withdraw(loanAmountPaid);\n', '            Address.sendValue(\n', '                receiver,\n', '                loanAmountPaid\n', '            );\n', '        }\n', '    }\n', '\n', '    /* Internal functions */\n', '\n', '    // sentAddresses[0]: lender\n', '    // sentAddresses[1]: borrower\n', '    // sentAddresses[2]: receiver\n', '    // sentAddresses[3]: manager\n', '    // sentAmounts[0]: interestRate\n', '    // sentAmounts[1]: newPrincipal\n', '    // sentAmounts[2]: interestInitialAmount\n', '    // sentAmounts[3]: loanTokenSent\n', '    // sentAmounts[4]: collateralTokenSent\n', '    function _verifyTransfers(\n', '        address collateralTokenAddress,\n', '        address[4] memory sentAddresses,\n', '        uint256[5] memory sentAmounts,\n', '        uint256 withdrawalAmount)\n', '        internal\n', '        returns (uint256 msgValue)\n', '    {\n', '        address _wethToken = wethToken;\n', '        address _loanTokenAddress = _wethToken;\n', '        address receiver = sentAddresses[2];\n', '        uint256 newPrincipal = sentAmounts[1];\n', '        uint256 loanTokenSent = sentAmounts[3];\n', '        uint256 collateralTokenSent = sentAmounts[4];\n', '\n', '        require(_loanTokenAddress != collateralTokenAddress, "26");\n', '\n', '        msgValue = msg.value;\n', '\n', '        if (withdrawalAmount != 0) { // withdrawOnOpen == true\n', '            IWethERC20(_wethToken).withdraw(withdrawalAmount);\n', '            Address.sendValue(\n', '                receiver,\n', '                withdrawalAmount\n', '            );\n', '            if (newPrincipal > withdrawalAmount) {\n', '                _safeTransfer(_loanTokenAddress, bZxContract, newPrincipal - withdrawalAmount, "27");\n', '            }\n', '        } else {\n', '            _safeTransfer(_loanTokenAddress, bZxContract, newPrincipal, "27");\n', '        }\n', '\n', '        if (collateralTokenSent != 0) {\n', '            _safeTransferFrom(collateralTokenAddress, msg.sender, bZxContract, collateralTokenSent, "28");\n', '        }\n', '\n', '        if (loanTokenSent != 0) {\n', '            if (msgValue != 0 && msgValue >= loanTokenSent) {\n', '                IWeth(_wethToken).deposit.value(loanTokenSent)();\n', '                _safeTransfer(_loanTokenAddress, bZxContract, loanTokenSent, "29");\n', '                msgValue -= loanTokenSent;\n', '            } else {\n', '                _safeTransferFrom(_loanTokenAddress, msg.sender, bZxContract, loanTokenSent, "29");\n', '            }\n', '        }\n', '    }\n', '}']