['/**************************************************************************\n', ' *            ____        _                              \n', ' *           / ___|      | |     __ _  _   _   ___  _ __ \n', " *          | |    _____ | |    / _` || | | | / _ \\| '__|\n", ' *          | |___|_____|| |___| (_| || |_| ||  __/| |   \n', ' *           \\____|      |_____|\\__,_| \\__, | \\___||_|   \n', ' *                                     |___/             \n', ' * \n', ' **************************************************************************\n', ' *\n', ' *  The MIT License (MIT)\n', ' * SPDX-License-Identifier: MIT\n', ' *\n', ' * Copyright (c) 2016-2020 Cyril Lapinte\n', ' *\n', ' * Permission is hereby granted, free of charge, to any person obtaining\n', ' * a copy of this software and associated documentation files (the\n', ' * "Software"), to deal in the Software without restriction, including\n', ' * without limitation the rights to use, copy, modify, merge, publish,\n', ' * distribute, sublicense, and/or sell copies of the Software, and to\n', ' * permit persons to whom the Software is furnished to do so, subject to\n', ' * the following conditions:\n', ' *\n', ' * The above copyright notice and this permission notice shall be included\n', ' * in all copies or substantial portions of the Software.\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' *\n', ' **************************************************************************\n', ' *\n', ' * Flatten Contract: TokenCore\n', ' *\n', ' * Git Commit:\n', ' * https://github.com/c-layer/contracts/commit/9993912325afde36151b04d0247ac9ea9ffa2a93\n', ' *\n', ' **************************************************************************/\n', '\n', '\n', '// File: @c-layer/common/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IAccessDefinitions.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IAccessDefinitions\n', ' * @dev IAccessDefinitions\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'contract IAccessDefinitions {\n', '\n', '  // Hardcoded role granting all - non sysop - privileges\n', '  bytes32 internal constant ALL_PRIVILEGES = bytes32("AllPrivileges");\n', '  address internal constant ALL_PROXIES = address(0x416c6C50726F78696573); // "AllProxies"\n', '\n', '  // Roles\n', '  bytes32 internal constant FACTORY_CORE_ROLE = bytes32("FactoryCoreRole");\n', '  bytes32 internal constant FACTORY_PROXY_ROLE = bytes32("FactoryProxyRole");\n', '\n', '  // Sys Privileges\n', '  bytes4 internal constant DEFINE_ROLE_PRIV =\n', '    bytes4(keccak256("defineRole(bytes32,bytes4[])"));\n', '  bytes4 internal constant ASSIGN_OPERATORS_PRIV =\n', '    bytes4(keccak256("assignOperators(bytes32,address[])"));\n', '  bytes4 internal constant REVOKE_OPERATORS_PRIV =\n', '    bytes4(keccak256("revokeOperators(address[])"));\n', '  bytes4 internal constant ASSIGN_PROXY_OPERATORS_PRIV =\n', '    bytes4(keccak256("assignProxyOperators(address,bytes32,address[])"));\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IOperableStorage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title IOperableStorage\n', ' * @dev The Operable storage\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'abstract contract IOperableStorage is IAccessDefinitions {\n', '  function proxyDelegateId(address _proxy) virtual public view returns (uint256);\n', '  function delegate(uint256 _delegateId) virtual public view returns (address);\n', '\n', '  function coreRole(address _address) virtual public view returns (bytes32);\n', '  function proxyRole(address _proxy, address _address) virtual public view returns (bytes32);\n', '  function rolePrivilege(bytes32 _role, bytes4 _privilege) virtual public view returns (bool);\n', '  function roleHasPrivilege(bytes32 _role, bytes4 _privilege) virtual public view returns (bool);\n', '  function hasCorePrivilege(address _address, bytes4 _privilege) virtual public view returns (bool);\n', '  function hasProxyPrivilege(address _address, address _proxy, bytes4 _privilege) virtual public view returns (bool);\n', '\n', '  event RoleDefined(bytes32 role);\n', '  event OperatorAssigned(bytes32 role, address operator);\n', '  event ProxyOperatorAssigned(address proxy, bytes32 role, address operator);\n', '  event OperatorRevoked(address operator);\n', '  event ProxyOperatorRevoked(address proxy, address operator);\n', '\n', '  event ProxyDefined(address proxy, uint256 delegateId);\n', '  event ProxyMigrated(address proxy, address newCore);\n', '  event ProxyRemoved(address proxy);\n', '}\n', '\n', '// File: @c-layer/common/contracts/operable/Ownable.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * @dev functions, this simplifies the implementation of "user permissions".\n', ' *\n', ' *\n', ' * Error messages\n', ' *   OW01: Message sender is not the owner\n', ' *   OW02: New owner must be valid\n', '*/\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "OW01");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0), "OW02");\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/Storage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title Storage\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' **/\n', 'contract Storage {\n', '  mapping(address => uint256) internal proxyDelegateIds;\n', '  mapping(uint256 => address) internal delegates;\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/OperableStorage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title OperableStorage\n', ' * @dev The Operable contract enable the restrictions of operations to a set of operators\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'contract OperableStorage is IOperableStorage, Ownable, Storage {\n', '\n', '  struct RoleData {\n', '    mapping(bytes4 => bool) privileges;\n', '  }\n', '\n', '  struct OperatorData {\n', '    bytes32 coreRole;\n', '    mapping(address => bytes32) proxyRoles;\n', '  }\n', '\n', '  // Mapping address => role\n', '  // Mapping role => bytes4 => bool\n', '  mapping (address => OperatorData) internal operators;\n', '  mapping (bytes32 => RoleData) internal roles;\n', '\n', '  /**\n', '   * @dev proxyDelegateId\n', '   */\n', '  function proxyDelegateId(address _proxy) override public view returns (uint256) {\n', '    return proxyDelegateIds[_proxy];\n', '  }\n', '\n', '  /**\n', '   * @dev delegate\n', '   */\n', '  function delegate(uint256 _delegateId) override public view returns (address) {\n', '    return delegates[_delegateId];\n', '  }\n', '\n', '  /**\n', '   * @dev core role\n', '   * @param _address operator address\n', '   */\n', '  function coreRole(address _address) override public view returns (bytes32) {\n', '    return operators[_address].coreRole;\n', '  }\n', '\n', '  /**\n', '   * @dev proxy role\n', '   * @param _address operator address\n', '   */\n', '  function proxyRole(address _proxy, address _address)\n', '    override public view returns (bytes32)\n', '  {\n', '    return operators[_address].proxyRoles[_proxy];\n', '  }\n', '\n', '  /**\n', '   * @dev has role privilege\n', '   * @dev low level access to role privilege\n', '   * @dev ignores ALL_PRIVILEGES role\n', '   */\n', '  function rolePrivilege(bytes32 _role, bytes4 _privilege)\n', '    override public view returns (bool)\n', '  {\n', '    return roles[_role].privileges[_privilege];\n', '  }\n', '\n', '  /**\n', '   * @dev roleHasPrivilege\n', '   */\n', '  function roleHasPrivilege(bytes32 _role, bytes4 _privilege) override public view returns (bool) {\n', '    return (_role == ALL_PRIVILEGES) || roles[_role].privileges[_privilege];\n', '  }\n', '\n', '  /**\n', '   * @dev hasCorePrivilege\n', '   * @param _address operator address\n', '   */\n', '  function hasCorePrivilege(address _address, bytes4 _privilege) override public view returns (bool) {\n', '    bytes32 role = operators[_address].coreRole;\n', '    return (role == ALL_PRIVILEGES) || roles[role].privileges[_privilege];\n', '  }\n', '\n', '  /**\n', '   * @dev hasProxyPrivilege\n', '   * @dev the default proxy role can be set with proxy address(0)\n', '   * @param _address operator address\n', '   */\n', '  function hasProxyPrivilege(address _address, address _proxy, bytes4 _privilege) override public view returns (bool) {\n', '    OperatorData storage data = operators[_address];\n', '    bytes32 role = (data.proxyRoles[_proxy] != bytes32(0)) ?\n', '      data.proxyRoles[_proxy] : data.proxyRoles[ALL_PROXIES];\n', '    return (role == ALL_PRIVILEGES) || roles[role].privileges[_privilege];\n', '  }\n', '}\n', '\n', '// File: contracts/interface/IRule.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IRule\n', ' * @dev IRule interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' **/\n', 'interface IRule {\n', '  function isAddressValid(address _address) external view returns (bool);\n', '  function isTransferValid(address _from, address _to, uint256 _amount)\n', '    external view returns (bool);\n', '}\n', '\n', '// File: @c-layer/oracle/contracts/interface/IUserRegistry.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IUserRegistry\n', ' * @dev IUserRegistry interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' **/\n', 'abstract contract IUserRegistry {\n', '\n', '  enum KeyCode {\n', '    KYC_LIMIT_KEY,\n', '    RECEPTION_LIMIT_KEY,\n', '    EMISSION_LIMIT_KEY\n', '  }\n', '\n', '  event UserRegistered(uint256 indexed userId, address address_, uint256 validUntilTime);\n', '  event AddressAttached(uint256 indexed userId, address address_);\n', '  event AddressDetached(uint256 indexed userId, address address_);\n', '  event UserSuspended(uint256 indexed userId);\n', '  event UserRestored(uint256 indexed userId);\n', '  event UserValidity(uint256 indexed userId, uint256 validUntilTime);\n', '  event UserExtendedKey(uint256 indexed userId, uint256 key, uint256 value);\n', '  event UserExtendedKeys(uint256 indexed userId, uint256[] values);\n', '  event ExtendedKeysDefinition(uint256[] keys);\n', '\n', '  function registerManyUsersExternal(address[] calldata _addresses, uint256 _validUntilTime)\n', '    virtual external returns (bool);\n', '  function registerManyUsersFullExternal(\n', '    address[] calldata _addresses,\n', '    uint256 _validUntilTime,\n', '    uint256[] calldata _values) virtual external returns (bool);\n', '  function attachManyAddressesExternal(uint256[] calldata _userIds, address[] calldata _addresses)\n', '    virtual external returns (bool);\n', '  function detachManyAddressesExternal(address[] calldata _addresses)\n', '    virtual external returns (bool);\n', '  function suspendManyUsersExternal(uint256[] calldata _userIds) virtual external returns (bool);\n', '  function restoreManyUsersExternal(uint256[] calldata _userIds) virtual external returns (bool);\n', '  function updateManyUsersExternal(\n', '    uint256[] calldata _userIds,\n', '    uint256 _validUntilTime,\n', '    bool _suspended) virtual external returns (bool);\n', '  function updateManyUsersExtendedExternal(\n', '    uint256[] calldata _userIds,\n', '    uint256 _key, uint256 _value) virtual external returns (bool);\n', '  function updateManyUsersAllExtendedExternal(\n', '    uint256[] calldata _userIds,\n', '    uint256[] calldata _values) virtual external returns (bool);\n', '  function updateManyUsersFullExternal(\n', '    uint256[] calldata _userIds,\n', '    uint256 _validUntilTime,\n', '    bool _suspended,\n', '    uint256[] calldata _values) virtual external returns (bool);\n', '\n', '  function name() virtual public view returns (string memory);\n', '  function currency() virtual public view returns (bytes32);\n', '\n', '  function userCount() virtual public view returns (uint256);\n', '  function userId(address _address) virtual public view returns (uint256);\n', '  function validUserId(address _address) virtual public view returns (uint256);\n', '  function validUser(address _address, uint256[] memory _keys)\n', '    virtual public view returns (uint256, uint256[] memory);\n', '  function validity(uint256 _userId) virtual public view returns (uint256, bool);\n', '\n', '  function extendedKeys() virtual public view returns (uint256[] memory);\n', '  function extended(uint256 _userId, uint256 _key)\n', '    virtual public view returns (uint256);\n', '  function manyExtended(uint256 _userId, uint256[] memory _key)\n', '    virtual public view returns (uint256[] memory);\n', '\n', '  function isAddressValid(address _address) virtual public view returns (bool);\n', '  function isValid(uint256 _userId) virtual public view returns (bool);\n', '\n', '  function defineExtendedKeys(uint256[] memory _extendedKeys) virtual public returns (bool);\n', '\n', '  function registerUser(address _address, uint256 _validUntilTime)\n', '    virtual public returns (bool);\n', '  function registerUserFull(\n', '    address _address,\n', '    uint256 _validUntilTime,\n', '    uint256[] memory _values) virtual public returns (bool);\n', '\n', '  function attachAddress(uint256 _userId, address _address) virtual public returns (bool);\n', '  function detachAddress(address _address) virtual public returns (bool);\n', '  function detachSelf() virtual public returns (bool);\n', '  function detachSelfAddress(address _address) virtual public returns (bool);\n', '  function suspendUser(uint256 _userId) virtual public returns (bool);\n', '  function restoreUser(uint256 _userId) virtual public returns (bool);\n', '  function updateUser(uint256 _userId, uint256 _validUntilTime, bool _suspended)\n', '    virtual public returns (bool);\n', '  function updateUserExtended(uint256 _userId, uint256 _key, uint256 _value)\n', '    virtual public returns (bool);\n', '  function updateUserAllExtended(uint256 _userId, uint256[] memory _values)\n', '    virtual public returns (bool);\n', '  function updateUserFull(\n', '    uint256 _userId,\n', '    uint256 _validUntilTime,\n', '    bool _suspended,\n', '    uint256[] memory _values) virtual public returns (bool);\n', '}\n', '\n', '// File: @c-layer/oracle/contracts/interface/IRatesProvider.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IRatesProvider\n', ' * @dev IRatesProvider interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'abstract contract IRatesProvider {\n', '\n', '  function defineRatesExternal(uint256[] calldata _rates) virtual external returns (bool);\n', '\n', '  function name() virtual public view returns (string memory);\n', '\n', '  function rate(bytes32 _currency) virtual public view returns (uint256);\n', '\n', '  function currencies() virtual public view\n', '    returns (bytes32[] memory, uint256[] memory, uint256);\n', '  function rates() virtual public view returns (uint256, uint256[] memory);\n', '\n', '  function convert(uint256 _amount, bytes32 _fromCurrency, bytes32 _toCurrency)\n', '    virtual public view returns (uint256);\n', '\n', '  function defineCurrencies(\n', '    bytes32[] memory _currencies,\n', '    uint256[] memory _decimals,\n', '    uint256 _rateOffset) virtual public returns (bool);\n', '  function defineRates(uint256[] memory _rates) virtual public returns (bool);\n', '\n', '  event RateOffset(uint256 rateOffset);\n', '  event Currencies(bytes32[] currencies, uint256[] decimals);\n', '  event Rate(bytes32 indexed currency, uint256 rate);\n', '}\n', '\n', '// File: contracts/interface/ITokenStorage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ITokenStorage\n', ' * @dev Token storage interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'abstract contract ITokenStorage {\n', '  enum TransferCode {\n', '    UNKNOWN,\n', '    OK,\n', '    INVALID_SENDER,\n', '    NO_RECIPIENT,\n', '    INSUFFICIENT_TOKENS,\n', '    LOCKED,\n', '    FROZEN,\n', '    RULE,\n', '    INVALID_RATE,\n', '    NON_REGISTRED_SENDER,\n', '    NON_REGISTRED_RECEIVER,\n', '    LIMITED_EMISSION,\n', '    LIMITED_RECEPTION\n', '  }\n', '\n', '  enum Scope {\n', '    DEFAULT\n', '  }\n', '\n', '  enum AuditStorageMode {\n', '    ADDRESS,\n', '    USER_ID,\n', '    SHARED\n', '  }\n', '\n', '  enum AuditTriggerMode {\n', '    UNDEFINED,\n', '    NONE,\n', '    SENDER_ONLY,\n', '    RECEIVER_ONLY,\n', '    BOTH\n', '  }\n', '\n', '  address internal constant ANY_ADDRESSES = address(0x416e79416464726573736573); // "AnyAddresses"\n', '\n', '  event OracleDefined(\n', '    IUserRegistry userRegistry,\n', '    IRatesProvider ratesProvider,\n', '    address currency);\n', '  event TokenDelegateDefined(uint256 indexed delegateId, address delegate, uint256[] configurations);\n', '  event TokenDelegateRemoved(uint256 indexed delegateId);\n', '  event AuditConfigurationDefined(\n', '    uint256 indexed configurationId,\n', '    uint256 scopeId,\n', '    AuditTriggerMode mode,\n', '    uint256[] senderKeys,\n', '    uint256[] receiverKeys,\n', '    IRatesProvider ratesProvider,\n', '    address currency);\n', '  event AuditTriggersDefined(\n', '    uint256 indexed configurationId,\n', '    address[] senders,\n', '    address[] receivers,\n', '    AuditTriggerMode[] modes);\n', '  event AuditsRemoved(address scope, uint256 scopeId);\n', '  event SelfManaged(address indexed holder, bool active);\n', '\n', '  event Minted(address indexed token, uint256 amount);\n', '  event MintFinished(address indexed token);\n', '  event Burned(address indexed token, uint256 amount);\n', '  event RulesDefined(address indexed token, IRule[] rules);\n', '  event LockDefined(\n', '    address indexed lock,\n', '    address sender,\n', '    address receiver,\n', '    uint256 startAt,\n', '    uint256 endAt\n', '  );\n', '  event Seize(address indexed token, address account, uint256 amount);\n', '  event Freeze(address address_, uint256 until);\n', '  event ClaimDefined(\n', '    address indexed token,\n', '    address indexed claim,\n', '    uint256 claimAt);\n', '  event TokenLocksDefined(\n', '    address indexed token,\n', '    address[] locks);\n', '  event TokenDefined(\n', '    address indexed token,\n', '    string name,\n', '    string symbol,\n', '    uint256 decimals);\n', '  event LogTransferData(\n', '    address token, address caller, address sender, address receiver,\n', '    uint256 senderId, uint256[] senderKeys, bool senderFetched,\n', '    uint256 receiverId, uint256[] receiverKeys, bool receiverFetched,\n', '    uint256 value, uint256 convertedValue);\n', '  event LogTransferAuditData(\n', '    uint256 auditConfigurationId, uint256 scopeId,\n', '    address currency, IRatesProvider ratesProvider,\n', '    bool senderAuditRequired, bool receiverAuditRequired);\n', '  event LogAuditData(\n', '    uint64 createdAt, uint64 lastTransactionAt,\n', '    uint256 cumulatedEmission, uint256 cumulatedReception\n', '  );\n', '}\n', '\n', '// File: contracts/TokenStorage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Token storage\n', ' * @dev Token storage\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'contract TokenStorage is ITokenStorage, OperableStorage {\n', '  using SafeMath for uint256;\n', '\n', '  struct LockData {\n', '    uint64 startAt;\n', '    uint64 endAt;\n', '  }\n', '\n', '  struct TokenData {\n', '    string name;\n', '    string symbol;\n', '    uint256 decimals;\n', '\n', '    uint256 totalSupply;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowances;\n', '\n', '    bool mintingFinished;\n', '\n', '    uint256 allTimeMinted;\n', '    uint256 allTimeBurned;\n', '    uint256 allTimeSeized;\n', '\n', '    mapping (address => uint256) frozenUntils;\n', '    address[] locks;\n', '    IRule[] rules;\n', '  }\n', '\n', '  struct AuditData {\n', '    uint64 createdAt;\n', '    uint64 lastTransactionAt;\n', '    uint256 cumulatedEmission;\n', '    uint256 cumulatedReception;\n', '  }\n', '\n', '  struct AuditStorage {\n', '    address currency;\n', '\n', '    AuditData sharedData;\n', '    mapping(uint256 => AuditData) userData;\n', '    mapping(address => AuditData) addressData;\n', '  }\n', '\n', '  struct AuditConfiguration {\n', '    uint256 scopeId;\n', '\n', '    uint256[] senderKeys;\n', '    uint256[] receiverKeys;\n', '    IRatesProvider ratesProvider;\n', '\n', '    mapping (address => mapping(address => AuditTriggerMode)) triggers;\n', '  }\n', '\n', '  // AuditConfigurationId => AuditConfiguration\n', '  mapping (uint256 => AuditConfiguration) internal auditConfigurations;\n', '  // DelegateId => AuditConfigurationId[]\n', '  mapping (uint256 => uint256[]) internal delegatesConfigurations_;\n', '  mapping (address => TokenData) internal tokens;\n', '\n', '  // Scope x ScopeId => AuditStorage\n', '  mapping (address => mapping (uint256 => AuditStorage)) internal audits;\n', '\n', '  // Prevents operator to act on behalf\n', '  mapping (address => bool) internal selfManaged;\n', '\n', '  // Proxy x Sender x Receiver x LockData\n', '  mapping (address => mapping (address => mapping(address => LockData))) internal locks;\n', '\n', '  IUserRegistry internal userRegistry_;\n', '  IRatesProvider internal ratesProvider_;\n', '  address internal currency_;\n', '  string internal name_;\n', '\n', '  /**\n', '   * @dev currentTime()\n', '   */\n', '  function currentTime() internal view returns (uint64) {\n', '    // solhint-disable-next-line not-rely-on-time\n', '    return uint64(now);\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IProxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @title IProxy\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' **/\n', 'interface IProxy {\n', '\n', '  function core() external view returns (address);\n', '\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/Proxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' *   PR01: Only accessible by core\n', ' *   PR02: Core request should be successful\n', ' **/\n', 'contract Proxy is IProxy {\n', '\n', '  address public override core;\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than a core\n', '   */\n', '  modifier onlyCore {\n', '    require(core == msg.sender, "PR01");\n', '    _;\n', '  }\n', '\n', '  constructor(address _core) public {\n', '    core = _core;\n', '  }\n', '\n', '  /**\n', '   * @dev update the core\n', '   */\n', '  function updateCore(address _core)\n', '    public onlyCore returns (bool)\n', '  {\n', '    core = _core;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev enforce static immutability (view)\n', '   * @dev in order to read core value through internal core delegateCall\n', '   */\n', '  function staticCallUint256() internal view returns (uint256 value) {\n', '    (bool status, bytes memory result) = core.staticcall(msg.data);\n', '    require(status, string(result));\n', '    value = abi.decode(result, (uint256));\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IOperableCore.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title IOperableCore\n', ' * @dev The Operable contract enable the restrictions of operations to a set of operators\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'abstract contract IOperableCore is IOperableStorage {\n', '  function defineRole(bytes32 _role, bytes4[] memory _privileges) virtual public returns (bool);\n', '  function assignOperators(bytes32 _role, address[] memory _operators) virtual public returns (bool);\n', '  function assignProxyOperators(\n', '    address _proxy, bytes32 _role, address[] memory _operators) virtual public returns (bool);\n', '  function revokeOperators(address[] memory _operators) virtual public returns (bool);\n', '  function revokeProxyOperators(address _proxy, address[] memory _operators) virtual public returns (bool);\n', '\n', '  function defineProxy(address _proxy, uint256 _delegateId) virtual public returns (bool);\n', '  function migrateProxy(address _proxy, address _newCore) virtual public returns (bool);\n', '  function removeProxy(address _proxy) virtual public returns (bool);\n', '}\n', '\n', '// File: @c-layer/common/contracts/call/DelegateCall.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title DelegateCall\n', ' * @dev Calls delegates for non view functions only\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error Messages:\n', ' **/\n', 'library DelegateCall {\n', '\n', '  function _delegateCall(address _delegate) internal virtual returns (bool status)\n', '  {\n', '    bytes memory result;\n', '    // solhint-disable-next-line avoid-low-level-calls\n', '    (status, result) = _delegate.delegatecall(msg.data);\n', '    require(status, string(result));\n', '  }\n', '\n', '  function _delegateCallBool(address _delegate) internal returns (bool status)\n', '  {\n', '    return abi.decode(_delegateCallBytes(_delegate), (bool));\n', '  }\n', '\n', '  function _delegateCallUint256(address _delegate) internal returns (uint256)\n', '  {\n', '    return abi.decode(_delegateCallBytes(_delegate), (uint256));\n', '  }\n', '\n', '  function _delegateCallBytes(address _delegate)\n', '    internal returns (bytes memory result)\n', '  {\n', '    bool status;\n', '    // solhint-disable-next-line avoid-low-level-calls\n', '    (status, result) = _delegate.delegatecall(msg.data);\n', '    require(status, string(result));\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/Core.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Core\n', ' * @dev Solidity version 0.5.x prevents to mark as view\n', ' * @dev functions using delegate call.\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' *   CO01: Only Proxy may access the function\n', ' *   CO02: Address 0 is an invalid delegate address\n', ' *   CO03: Delegatecall should be successful\n', ' *   CO04: DelegateId must be greater than 0\n', ' *   CO05: Proxy must exist\n', ' *   CO06: Proxy must be already defined\n', ' *   CO07: Proxy update must be successful\n', ' **/\n', 'contract Core is Storage {\n', '  using DelegateCall for address;\n', '\n', '  modifier onlyProxy {\n', '    require(delegates[proxyDelegateIds[msg.sender]] != address(0), "CO01");\n', '    _;\n', '  }\n', '\n', '  function validProxyDelegate(address _proxy) internal view returns (address delegate) {\n', '    uint256 delegateId = proxyDelegateIds[_proxy];\n', '    delegate = delegates[delegateId];\n', '    require(delegate != address(0), "CO02");\n', '  }\n', '\n', '  function delegateCall(address _proxy) internal returns (bool status)\n', '  {\n', '    return validProxyDelegate(_proxy)._delegateCall();\n', '  }\n', '\n', '  function delegateCallBool(address _proxy)\n', '    internal returns (bool)\n', '  {\n', '    return validProxyDelegate(_proxy)._delegateCallBool();\n', '  }\n', '\n', '  function delegateCallUint256(address _proxy)\n', '    internal returns (uint256)\n', '  {\n', '    return validProxyDelegate(_proxy)._delegateCallUint256();\n', '  }\n', '\n', '  function delegateCallBytes(address _proxy)\n', '    internal returns (bytes memory result)\n', '  {\n', '    return validProxyDelegate(_proxy)._delegateCallBytes();\n', '  }\n', '\n', '  function defineDelegateInternal(uint256 _delegateId, address _delegate) internal returns (bool) {\n', '    require(_delegateId != 0, "CO04");\n', '    delegates[_delegateId] = _delegate;\n', '    return true;\n', '  }\n', '\n', '  function defineProxyInternal(address _proxy, uint256 _delegateId)\n', '    virtual internal returns (bool)\n', '  {\n', '    require(delegates[_delegateId] != address(0), "CO02");\n', '    require(_proxy != address(0), "CO05");\n', '\n', '    proxyDelegateIds[_proxy] = _delegateId;\n', '    return true;\n', '  }\n', '\n', '  function migrateProxyInternal(address _proxy, address _newCore)\n', '    internal returns (bool)\n', '  {\n', '    require(proxyDelegateIds[_proxy] != 0, "CO06");\n', '    require(Proxy(_proxy).updateCore(_newCore), "CO07");\n', '    return true;\n', '  }\n', '\n', '  function removeProxyInternal(address _proxy)\n', '    internal virtual returns (bool)\n', '  {\n', '    require(proxyDelegateIds[_proxy] != 0, "CO06");\n', '    delete proxyDelegateIds[_proxy];\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/OperableCore.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title OperableCore\n', ' * @dev The Operable contract enable the restrictions of operations to a set of operators\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' *   OC01: Sender is not a system operator\n', ' *   OC02: Sender is not a core operator\n', ' *   OC03: Sender is not a proxy operator\n', ' *   OC04: Role must not be null\n', ' *   OC05: AllPrivileges is a reserved role\n', ' *   OC06: AllProxies is not a valid proxy address\n', ' *   OC07: Proxy must be valid\n', ' *   OC08: Operator has no role\n', ' */\n', 'contract OperableCore is IOperableCore, Core, OperableStorage {\n', '\n', '  constructor(address[] memory _sysOperators) public {\n', '    assignOperators(ALL_PRIVILEGES, _sysOperators);\n', '    assignProxyOperators(ALL_PROXIES, ALL_PRIVILEGES, _sysOperators);\n', '  }\n', '\n', '  /**\n', '   * @dev onlySysOp modifier\n', '   * @dev for safety reason, core owner\n', '   * @dev can always define roles and assign or revoke operatos\n', '   */\n', '  modifier onlySysOp() {\n', '    require(msg.sender == owner || hasCorePrivilege(msg.sender, msg.sig), "OC01");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev onlyCoreOp modifier\n', '   */\n', '  modifier onlyCoreOp() {\n', '    require(hasCorePrivilege(msg.sender, msg.sig), "OC02");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev onlyProxyOp modifier\n', '   */\n', '  modifier onlyProxyOp(address _proxy) {\n', '    require(hasProxyPrivilege(msg.sender, _proxy, msg.sig), "OC03");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev defineRoles\n', '   * @param _role operator role\n', '   * @param _privileges as 4 bytes of the method\n', '   */\n', '  function defineRole(bytes32 _role, bytes4[] memory _privileges)\n', '    override public onlySysOp returns (bool)\n', '  {\n', '    require(_role != bytes32(0), "OC04");\n', '    require(_role != ALL_PRIVILEGES, "OC05");\n', '\n', '    delete roles[_role];\n', '    for (uint256 i=0; i < _privileges.length; i++) {\n', '      roles[_role].privileges[_privileges[i]] = true;\n', '    }\n', '    emit RoleDefined(_role);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev assignOperators\n', '   * @param _role operator role. May be a role not defined yet.\n', '   * @param _operators addresses\n', '   */\n', '  function assignOperators(bytes32 _role, address[] memory _operators)\n', '    override public onlySysOp returns (bool)\n', '  {\n', '    require(_role != bytes32(0), "OC04");\n', '\n', '    for (uint256 i=0; i < _operators.length; i++) {\n', '      operators[_operators[i]].coreRole = _role;\n', '      emit OperatorAssigned(_role, _operators[i]);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev assignProxyOperators\n', '   * @param _role operator role. May be a role not defined yet.\n', '   * @param _operators addresses\n', '   */\n', '  function assignProxyOperators(\n', '    address _proxy, bytes32 _role, address[] memory _operators)\n', '    override public onlySysOp returns (bool)\n', '  {\n', '    require(_proxy == ALL_PROXIES ||\n', '      delegates[proxyDelegateIds[_proxy]] != address(0), "OC07");\n', '    require(_role != bytes32(0), "OC04");\n', '\n', '    for (uint256 i=0; i < _operators.length; i++) {\n', '      operators[_operators[i]].proxyRoles[_proxy] = _role;\n', '      emit ProxyOperatorAssigned(_proxy, _role, _operators[i]);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev revokeOperator\n', '   * @param _operators addresses\n', '   */\n', '  function revokeOperators(address[] memory _operators)\n', '    override public onlySysOp returns (bool)\n', '  {\n', '    for (uint256 i=0; i < _operators.length; i++) {\n', '      OperatorData storage operator = operators[_operators[i]];\n', '      require(operator.coreRole != bytes32(0), "OC08");\n', '      operator.coreRole = bytes32(0);\n', '\n', '      emit OperatorRevoked(_operators[i]);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev revokeProxyOperator\n', '   * @param _operators addresses\n', '   */\n', '  function revokeProxyOperators(address _proxy, address[] memory _operators)\n', '    override public onlySysOp returns (bool)\n', '  {\n', '    for (uint256 i=0; i < _operators.length; i++) {\n', '      OperatorData storage operator = operators[_operators[i]];\n', '      require(operator.proxyRoles[_proxy] != bytes32(0), "OC08");\n', '      operator.proxyRoles[_proxy] = bytes32(0);\n', '\n', '      emit ProxyOperatorRevoked(_proxy, _operators[i]);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function defineProxy(address _proxy, uint256 _delegateId)\n', '    override public onlyCoreOp returns (bool)\n', '  {\n', '    require(_proxy != ALL_PROXIES, "OC06");\n', '    defineProxyInternal(_proxy, _delegateId);\n', '    emit ProxyDefined(_proxy, _delegateId);\n', '    return true;\n', '  }\n', '\n', '  function migrateProxy(address _proxy, address _newCore)\n', '    override public onlyCoreOp returns (bool)\n', '  {\n', '    migrateProxyInternal(_proxy, _newCore);\n', '    emit ProxyMigrated(_proxy, _newCore);\n', '    return true;\n', '  }\n', '\n', '  function removeProxy(address _proxy)\n', '    override public onlyCoreOp returns (bool)\n', '  {\n', '    removeProxyInternal(_proxy);\n', '    emit ProxyRemoved(_proxy);\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/OperableProxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title OperableProxy\n', ' * @dev The OperableAs contract enable the restrictions of operations to a set of operators\n', ' * @dev It relies on another Operable contract and reuse the same list of operators\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' * OP01: Message sender must be authorized\n', ' */\n', 'contract OperableProxy is Proxy {\n', '\n', '  // solhint-disable-next-line no-empty-blocks\n', '  constructor(address _core) public Proxy(_core) { }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the operator\n', '   */\n', '  modifier onlyOperator {\n', '    require(OperableCore(core).hasProxyPrivilege(\n', '      msg.sender, address(this), msg.sig), "OP01");\n', '    _;\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' *\n', ' */\n', 'interface IERC20 {\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '\n', '  function name() external view returns (string memory);\n', '  function symbol() external view returns (string memory);\n', '  function decimals() external view returns (uint256);\n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address _owner) external view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '\n', '  function allowance(address _owner, address _spender)\n', '    external view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    external returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) external returns (bool);\n', '\n', '  function increaseApproval(address _spender, uint256 _addedValue)\n', '    external returns (bool);\n', '\n', '  function decreaseApproval(address _spender, uint256 _subtractedValue)\n', '    external returns (bool);\n', '}\n', '\n', '// File: contracts/interface/ITokenProxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title IToken proxy\n', ' * @dev Token proxy interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'abstract contract ITokenProxy is IERC20, Proxy {\n', '\n', '  function canTransfer(address, address, uint256)\n', '    virtual public view returns (uint256);\n', '\n', '  function emitTransfer(address _from, address _to, uint256 _value)\n', '    virtual public returns (bool);\n', '\n', '  function emitApproval(address _owner, address _spender, uint256 _value)\n', '    virtual public returns (bool);\n', '}\n', '\n', '// File: contracts/interface/ITokenCore.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ITokenCore\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' **/\n', 'abstract contract ITokenCore is ITokenStorage, IOperableCore {\n', '\n', '  function name() virtual public view returns (string memory);\n', '  function oracle() virtual public view returns (\n', '    IUserRegistry userRegistry,\n', '    IRatesProvider ratesProvider,\n', '    address currency);\n', '\n', '  function auditConfiguration(uint256 _configurationId)\n', '    virtual public view returns (\n', '      uint256 scopeId,\n', '      AuditTriggerMode _mode,\n', '      uint256[] memory senderKeys,\n', '      uint256[] memory receiverKeys,\n', '      IRatesProvider ratesProvider,\n', '      address currency);\n', '  function auditTrigger(uint256 _configurationId, address _sender, address _receiver)\n', '    virtual public view returns (AuditTriggerMode);\n', '  function delegatesConfigurations(uint256 _delegateId)\n', '    virtual public view returns (uint256[] memory);\n', '\n', '  function auditCurrency(\n', '    address _scope,\n', '    uint256 _scopeId\n', '  ) virtual external view returns (address currency);\n', '  function audit(\n', '    address _scope,\n', '    uint256 _scopeId,\n', '    AuditStorageMode _storageMode,\n', '    bytes32 _storageId) virtual external view returns (\n', '    uint64 createdAt,\n', '    uint64 lastTransactionAt,\n', '    uint256 cumulatedEmission,\n', '    uint256 cumulatedReception);\n', '\n', '  /**************  ERC20  **************/\n', '  function tokenName() virtual external view returns (string memory);\n', '  function tokenSymbol() virtual external view returns (string memory);\n', '\n', '  function decimals() virtual external returns (uint256);\n', '  function totalSupply() virtual external returns (uint256);\n', '  function balanceOf(address) virtual external returns (uint256);\n', '  function allowance(address, address) virtual external returns (uint256);\n', '  function transfer(address, address, uint256)\n', '    virtual external returns (bool status);\n', '  function transferFrom(address, address, address, uint256)\n', '    virtual external returns (bool status);\n', '  function approve(address, address, uint256)\n', '    virtual external returns (bool status);\n', '  function increaseApproval(address, address, uint256)\n', '    virtual external returns (bool status);\n', '  function decreaseApproval(address, address, uint256)\n', '    virtual external returns (bool status);\n', '\n', '  /***********  TOKEN DATA   ***********/\n', '  function token(address _token) virtual external view returns (\n', '    bool mintingFinished,\n', '    uint256 allTimeMinted,\n', '    uint256 allTimeBurned,\n', '    uint256 allTimeSeized,\n', '    address[] memory locks,\n', '    uint256 freezedUntil,\n', '    IRule[] memory);\n', '  function lock(address _lock, address _sender, address _receiver) virtual external view returns (\n', '    uint64 startAt, uint64 endAt);\n', '  function canTransfer(address, address, uint256)\n', '    virtual external returns (uint256);\n', '\n', '  /***********  TOKEN ADMIN  ***********/\n', '  function mint(address, address[] calldata, uint256[] calldata)\n', '    virtual external returns (bool);\n', '  function finishMinting(address)\n', '    virtual external returns (bool);\n', '  function burn(address, uint256)\n', '    virtual external returns (bool);\n', '  function seize(address _token, address, uint256)\n', '    virtual external returns (bool);\n', '  function defineLock(address, address, address, uint64, uint64)\n', '    virtual external returns (bool);\n', '  function defineTokenLocks(address _token, address[] memory locks)\n', '    virtual external returns (bool);\n', '  function freezeManyAddresses(\n', '    address _token,\n', '    address[] calldata _addresses,\n', '    uint256 _until) virtual external returns (bool);\n', '  function defineRules(address, IRule[] calldata) virtual external returns (bool);\n', '\n', '  /************  CORE ADMIN  ************/\n', '  function defineToken(\n', '    address _token,\n', '    uint256 _delegateId,\n', '    string memory _name,\n', '    string memory _symbol,\n', '    uint256 _decimals) virtual external returns (bool);\n', '\n', '  function defineOracle(\n', '    IUserRegistry _userRegistry,\n', '    IRatesProvider _ratesProvider,\n', '    address _currency) virtual external returns (bool);\n', '  function defineTokenDelegate(\n', '    uint256 _delegateId,\n', '    address _delegate,\n', '    uint256[] calldata _configurations) virtual external returns (bool);\n', '  function defineAuditConfiguration(\n', '    uint256 _configurationId,\n', '    uint256 _scopeId,\n', '    AuditTriggerMode _mode,\n', '    uint256[] calldata _senderKeys,\n', '    uint256[] calldata _receiverKeys,\n', '    IRatesProvider _ratesProvider,\n', '    address _currency) virtual external returns (bool);\n', '  function removeAudits(address _scope, uint256 _scopeId)\n', '    virtual external returns (bool);\n', '  function defineAuditTriggers(\n', '    uint256 _configurationId,\n', '    address[] calldata _senders,\n', '    address[] calldata _receivers,\n', '    AuditTriggerMode[] calldata _modes) virtual external returns (bool);\n', '\n', '  function isSelfManaged(address _owner)\n', '    virtual external view returns (bool);\n', '  function manageSelf(bool _active)\n', '    virtual external returns (bool);\n', '}\n', '\n', '// File: contracts/interface/ITokenDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title Token Delegate Interface\n', ' * @dev Token Delegate Interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'abstract contract ITokenDelegate is ITokenStorage {\n', '\n', '  function decimals() virtual public view returns (uint256);\n', '  function totalSupply() virtual public view returns (uint256);\n', '  function balanceOf(address _owner) virtual public view returns (uint256);\n', '  function allowance(address _owner, address _spender)\n', '    virtual public view returns (uint256);\n', '  function transfer(address _sender, address _receiver, uint256 _value)\n', '    virtual public returns (bool);\n', '  function transferFrom(\n', '    address _caller, address _sender, address _receiver, uint256 _value)\n', '    virtual public returns (bool);\n', '  function canTransfer(\n', '    address _sender,\n', '    address _receiver,\n', '    uint256 _value) virtual public view returns (TransferCode);\n', '  function approve(address _sender, address _spender, uint256 _value)\n', '    virtual public returns (bool);\n', '  function increaseApproval(address _sender, address _spender, uint _addedValue)\n', '    virtual public returns (bool);\n', '  function decreaseApproval(address _sender, address _spender, uint _subtractedValue)\n', '    virtual public returns (bool);\n', '  function checkConfigurations(uint256[] memory _auditConfigurationIds)\n', '    virtual public returns (bool);\n', '}\n', '\n', '// File: contracts/TokenCore.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title TokenCore\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' *   TC01: Token cannot be equivalent to AllProxies\n', ' *   TC02: Currency stored values must remain consistent\n', ' *   TC03: Delegate has invalid audit configurations values\n', ' *   TC04: Mismatched between the configuration and the audit storage currency\n', ' *   TC05: The audit triggers definition requires the same number of addresses and values\n', ' **/\n', 'contract TokenCore is ITokenCore, OperableCore, TokenStorage {\n', '\n', '  /**\n', '   * @dev constructor\n', '   */\n', '  constructor(string memory _name, address[] memory _sysOperators)\n', '    public OperableCore(_sysOperators)\n', '  {\n', '    name_ = _name;\n', '  }\n', '\n', '  function name() override public view returns (string memory) {\n', '    return name_;\n', '  }\n', '\n', '  function oracle() override public view returns (\n', '    IUserRegistry userRegistry,\n', '    IRatesProvider ratesProvider,\n', '    address currency)\n', '  {\n', '    return (userRegistry_, ratesProvider_, currency_);\n', '  }\n', '\n', '  function auditConfiguration(uint256 _configurationId)\n', '    override public view returns (\n', '      uint256 scopeId,\n', '      AuditTriggerMode mode,\n', '      uint256[] memory senderKeys,\n', '      uint256[] memory receiverKeys,\n', '      IRatesProvider ratesProvider,\n', '      address currency)\n', '  {\n', '    AuditConfiguration storage auditConfiguration_ = auditConfigurations[_configurationId];\n', '    return (\n', '      auditConfiguration_.scopeId,\n', '      auditConfiguration_.triggers[ANY_ADDRESSES][ANY_ADDRESSES],\n', '      auditConfiguration_.senderKeys,\n', '      auditConfiguration_.receiverKeys,\n', '      auditConfiguration_.ratesProvider,\n', '      audits[address(this)][auditConfiguration_.scopeId].currency\n', '    );\n', '  }\n', '\n', '  function auditTrigger(uint256 _configurationId, address _sender, address _receiver)\n', '    override public view returns (AuditTriggerMode)\n', '  {\n', '    return auditConfigurations[_configurationId].triggers[_sender][_receiver];\n', '  }\n', '\n', '  function delegatesConfigurations(uint256 _delegateId)\n', '    override public view returns (uint256[] memory)\n', '  {\n', '    return delegatesConfigurations_[_delegateId];\n', '  }\n', '\n', '  function auditCurrency(\n', '    address _scope,\n', '    uint256 _scopeId\n', '  ) override external view returns (address currency) {\n', '    return audits[_scope][_scopeId].currency;\n', '  }\n', '\n', '  function audit(\n', '    address _scope,\n', '    uint256 _scopeId,\n', '    AuditStorageMode _storageMode,\n', '    bytes32 _storageId) override external view returns (\n', '    uint64 createdAt,\n', '    uint64 lastTransactionAt,\n', '    uint256 cumulatedEmission,\n', '    uint256 cumulatedReception)\n', '  {\n', '    AuditData memory auditData;\n', '    if (_storageMode == AuditStorageMode.SHARED) {\n', '      auditData = audits[_scope][_scopeId].sharedData;\n', '    }\n', '    if (_storageMode == AuditStorageMode.ADDRESS) {\n', '      auditData = audits[_scope][_scopeId].addressData[address(bytes20(_storageId))];\n', '    }\n', '    if (_storageMode == AuditStorageMode.USER_ID) {\n', '      auditData = audits[_scope][_scopeId].userData[uint256(_storageId)];\n', '    }\n', '\n', '    createdAt = auditData.createdAt;\n', '    lastTransactionAt = auditData.lastTransactionAt;\n', '    cumulatedEmission = auditData.cumulatedEmission;\n', '    cumulatedReception = auditData.cumulatedReception;\n', '  }\n', '\n', '  /**************  ERC20  **************/\n', '  function tokenName() override external view returns (string memory) {\n', '    return tokens[msg.sender].name;\n', '  }\n', '\n', '  function tokenSymbol() override external view returns (string memory) {\n', '    return tokens[msg.sender].symbol;\n', '  }\n', '\n', '  function decimals() override external onlyProxy returns (uint256) {\n', '    return delegateCallUint256(msg.sender);\n', '  }\n', '\n', '  function totalSupply() override external onlyProxy returns (uint256) {\n', '    return delegateCallUint256(msg.sender);\n', '  }\n', '\n', '  function balanceOf(address) external onlyProxy override returns (uint256) {\n', '    return delegateCallUint256(msg.sender);\n', '  }\n', '\n', '  function allowance(address, address)\n', '    override external onlyProxy returns (uint256)\n', '  {\n', '    return delegateCallUint256(msg.sender);\n', '  }\n', '\n', '  function transfer(address, address, uint256)\n', '    override external onlyProxy returns (bool status)\n', '  {\n', '    return delegateCall(msg.sender);\n', '  }\n', '\n', '  function transferFrom(address, address, address, uint256)\n', '    override external onlyProxy returns (bool status)\n', '  {\n', '    return delegateCall(msg.sender);\n', '  }\n', '\n', '  function approve(address, address, uint256)\n', '    override external onlyProxy returns (bool status)\n', '  {\n', '    return delegateCall(msg.sender);\n', '  }\n', '\n', '  function increaseApproval(address, address, uint256)\n', '    override external onlyProxy returns (bool status)\n', '  {\n', '    return delegateCall(msg.sender);\n', '  }\n', '\n', '  function decreaseApproval(address, address, uint256)\n', '    override external onlyProxy returns (bool status)\n', '  {\n', '    return delegateCall(msg.sender);\n', '  }\n', '\n', '  /***********  TOKEN DATA   ***********/\n', '  function token(address _token) override external view returns (\n', '    bool mintingFinished,\n', '    uint256 allTimeMinted,\n', '    uint256 allTimeBurned,\n', '    uint256 allTimeSeized,\n', '    address[] memory locks,\n', '    uint256 frozenUntil,\n', '    IRule[] memory rules) {\n', '    TokenData storage tokenData = tokens[_token];\n', '\n', '    mintingFinished = tokenData.mintingFinished;\n', '    allTimeMinted = tokenData.allTimeMinted;\n', '    allTimeBurned = tokenData.allTimeBurned;\n', '    allTimeSeized = tokenData.allTimeSeized;\n', '    locks = tokenData.locks;\n', '    frozenUntil = tokenData.frozenUntils[_token];\n', '    rules = tokenData.rules;\n', '  }\n', '\n', '  function lock(address _lock, address _sender, address _receiver) override external view returns (\n', '    uint64 startAt, uint64 endAt)\n', '  {\n', '    LockData storage lockData_ = locks[_lock][_sender][_receiver];\n', '    return (lockData_.startAt, lockData_.endAt);\n', '  }\n', '\n', '  function canTransfer(address, address, uint256)\n', '    override external onlyProxy returns (uint256)\n', '  {\n', '    return delegateCallUint256(msg.sender);\n', '  }\n', '\n', '  /***********  TOKEN ADMIN  ***********/\n', '  function mint(address _token, address[] calldata, uint256[] calldata)\n', '    override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  function finishMinting(address _token)\n', '    override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  function burn(address _token, uint256)\n', '    override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  function seize(address _token, address, uint256)\n', '    override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  function freezeManyAddresses(\n', '    address _token,\n', '    address[] calldata,\n', '    uint256) override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  function defineLock(address _lock, address, address, uint64, uint64)\n', '    override external onlyProxyOp(_lock) returns (bool)\n', '  {\n', '    return delegateCall(_lock);\n', '  }\n', '\n', '  function defineTokenLocks(address _token, address[] calldata)\n', '    override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  function defineRules(address _token, IRule[] calldata)\n', '    override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  /************  CORE ADMIN  ************/\n', '  function removeProxyInternal(address _token)\n', '    internal override returns (bool)\n', '  {\n', '    super.removeProxyInternal(_token);\n', '    delete tokens[_token];\n', '    return true;\n', '  }\n', '\n', '  function defineToken(\n', '    address _token,\n', '    uint256 _delegateId,\n', '    string calldata _name,\n', '    string calldata _symbol,\n', '    uint256 _decimals)\n', '    override external onlyCoreOp returns (bool)\n', '  {\n', '    require(_token != ALL_PROXIES, "TC01");\n', '    defineProxy(_token, _delegateId);\n', '    TokenData storage tokenData = tokens[_token];\n', '    tokenData.name = _name;\n', '    tokenData.symbol = _symbol;\n', '    tokenData.decimals = _decimals;\n', '\n', '    emit TokenDefined(_token, _name, _symbol, _decimals);\n', '    return true;\n', '  }\n', '\n', '  function defineOracle(\n', '    IUserRegistry _userRegistry,\n', '    IRatesProvider _ratesProvider,\n', '    address _currency)\n', '    override external onlyCoreOp returns (bool)\n', '  {\n', '    userRegistry_ = _userRegistry;\n', '    ratesProvider_ = _ratesProvider;\n', '    currency_ = _currency;\n', '\n', '    emit OracleDefined(userRegistry_, _ratesProvider, _currency);\n', '    return true;\n', '  }\n', '\n', '  function defineTokenDelegate(\n', '    uint256 _delegateId,\n', '    address _delegate,\n', '    uint256[] calldata _auditConfigurations) override external onlyCoreOp returns (bool)\n', '  {\n', '    require(_delegate == address(0) ||\n', '      ITokenDelegate(_delegate).checkConfigurations(_auditConfigurations), "TC03");\n', '\n', '    defineDelegateInternal(_delegateId, _delegate);\n', '    if(_delegate != address(0)) {\n', '      delegatesConfigurations_[_delegateId] = _auditConfigurations;\n', '      emit TokenDelegateDefined(_delegateId, _delegate, _auditConfigurations);\n', '    } else {\n', '      delete delegatesConfigurations_[_delegateId];\n', '      emit TokenDelegateRemoved(_delegateId);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function defineAuditConfiguration(\n', '    uint256 _configurationId,\n', '    uint256 _scopeId,\n', '    AuditTriggerMode _mode,\n', '    uint256[] calldata _senderKeys,\n', '    uint256[] calldata _receiverKeys,\n', '    IRatesProvider _ratesProvider,\n', '    address _currency) override external onlyCoreOp returns (bool)\n', '  {\n', '    // Mark permanently the core audit storage with the currency to be used with\n', '    AuditStorage storage auditStorage = audits[address(this)][_scopeId];\n', '    if(auditStorage.currency == address(0)) {\n', '      auditStorage.currency = _currency;\n', '    } else {\n', '      require(auditStorage.currency == _currency, "TC04");\n', '    }\n', '\n', '    AuditConfiguration storage auditConfiguration_ = auditConfigurations[_configurationId];\n', '    auditConfiguration_.scopeId = _scopeId;\n', '    auditConfiguration_.senderKeys = _senderKeys;\n', '    auditConfiguration_.receiverKeys = _receiverKeys;\n', '    auditConfiguration_.ratesProvider = _ratesProvider;\n', '    auditConfiguration_.triggers[ANY_ADDRESSES][ANY_ADDRESSES] = _mode;\n', '\n', '    emit AuditConfigurationDefined(\n', '      _configurationId,\n', '      _scopeId,\n', '      _mode,\n', '      _senderKeys,\n', '      _receiverKeys,\n', '      _ratesProvider,\n', '      _currency);\n', '    return true;\n', '  }\n', '\n', '  function removeAudits(address _scope, uint256 _scopeId)\n', '    override external onlyCoreOp returns (bool)\n', '  {\n', '    delete audits[_scope][_scopeId];\n', '    emit AuditsRemoved(_scope, _scopeId);\n', '    return true;\n', '  }\n', '\n', '  function defineAuditTriggers(\n', '    uint256 _configurationId,\n', '    address[] calldata _senders,\n', '    address[] calldata _receivers,\n', '    AuditTriggerMode[] calldata _modes) override external onlyCoreOp returns (bool)\n', '  {\n', '    require(_senders.length == _receivers.length && _senders.length == _modes.length, "TC05");\n', '\n', '    AuditConfiguration storage auditConfiguration_ = auditConfigurations[_configurationId];\n', '    for(uint256 i=0; i < _senders.length; i++) {\n', '      auditConfiguration_.triggers[_senders[i]][_receivers[i]] = _modes[i];\n', '    }\n', '\n', '    emit AuditTriggersDefined(_configurationId, _senders, _receivers, _modes);\n', '    return true;\n', '  }\n', '\n', '  function isSelfManaged(address _owner)\n', '    override external view returns (bool)\n', '  {\n', '    return selfManaged[_owner];\n', '  }\n', '\n', '  function manageSelf(bool _active)\n', '    override external returns (bool)\n', '  {\n', '    selfManaged[msg.sender] = _active;\n', '    emit SelfManaged(msg.sender, _active);\n', '  }\n', '}\n', '\n', '// File: contracts/TokenProxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Token proxy\n', ' * @dev Token proxy default implementation\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'contract TokenProxy is ITokenProxy, OperableProxy {\n', '\n', '  // solhint-disable-next-line no-empty-blocks\n', '  constructor(address _core) public OperableProxy(_core) { }\n', '\n', '  function name() override public view returns (string memory) {\n', '    return TokenCore(core).tokenName();\n', '  }\n', '\n', '  function symbol() override public view returns (string memory) {\n', '    return TokenCore(core).tokenSymbol();\n', '  }\n', '\n', '  function decimals() override public view returns (uint256) {\n', '    return staticCallUint256();\n', '  }\n', '\n', '  function totalSupply() override public view returns (uint256) {\n', '    return staticCallUint256();\n', '  }\n', '\n', '  function balanceOf(address) override public view returns (uint256) {\n', '    return staticCallUint256();\n', '  }\n', '\n', '  function allowance(address, address)\n', '    override public view returns (uint256)\n', '  {\n', '    return staticCallUint256();\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) override public returns (bool status)\n', '  {\n', '    return TokenCore(core).transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    override public returns (bool status)\n', '  {\n', '    return TokenCore(core).transferFrom(msg.sender, _from, _to, _value);\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value)\n', '    override public returns (bool status)\n', '  {\n', '    return TokenCore(core).approve(msg.sender, _spender, _value);\n', '  }\n', '\n', '  function increaseApproval(address _spender, uint256 _addedValue)\n', '    override public returns (bool status)\n', '  {\n', '    return TokenCore(core).increaseApproval(msg.sender, _spender, _addedValue);\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint256 _subtractedValue)\n', '    override public returns (bool status)\n', '  {\n', '    return TokenCore(core).decreaseApproval(msg.sender, _spender, _subtractedValue);\n', '  }\n', '\n', '  function canTransfer(address, address, uint256)\n', '    override public view returns (uint256)\n', '  {\n', '    return staticCallUint256();\n', '  }\n', '\n', '  function emitTransfer(address _from, address _to, uint256 _value)\n', '    override public onlyCore returns (bool)\n', '  {\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function emitApproval(address _owner, address _spender, uint256 _value)\n', '    override public onlyCore returns (bool)\n', '  {\n', '    emit Approval(_owner, _spender, _value);\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/delegate/MintableDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title MintableDelegate\n', ' * @dev MintableDelegate contract\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' * MT01: Transfer events must be generated\n', ' * MT02: Token is already minted\n', ' * MT03: Parameters must be same length\n', ' */\n', 'abstract contract MintableDelegate is TokenStorage {\n', '\n', '  modifier canMint(address _token) {\n', '    require(!tokens[_token].mintingFinished, "MT02");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to burn tokens\n', '   * @param _amount The amount of tokens to burn.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function burn(address _token, uint256 _amount)\n', '    public returns (bool)\n', '  {\n', '    TokenData storage token = tokens[_token];\n', '    token.totalSupply = token.totalSupply.sub(_amount);\n', '    token.balances[msg.sender] = token.balances[msg.sender].sub(_amount);\n', '    token.allTimeBurned = token.allTimeBurned.add(_amount);\n', '\n', '    require(\n', '      TokenProxy(_token).emitTransfer(msg.sender, address(0), _amount),\n', '      "MT01");\n', '    emit Burned(_token, _amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint all tokens at once\n', '   * @param _recipients The addresses that will receive the minted tokens.\n', '   * @param _amounts The amounts of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mint(address _token, address[] memory _recipients, uint256[] memory _amounts)\n', '    public canMint(_token) returns (bool)\n', '  {\n', '    require(_recipients.length == _amounts.length, "MT03");\n', '\n', '    bool result = true;\n', '    for (uint256 i=0; i < _recipients.length; i++) {\n', '      result = result && mintInternal(_token, _recipients[i], _amounts[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '  function finishMinting(address _token)\n', '    public canMint(_token) returns (bool)\n', '  {\n', '    tokens[_token].mintingFinished = true;\n', '    emit MintFinished(_token);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens internal\n', '   * @param _to The address that will receive the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '  function mintInternal(address _token, address _to, uint256 _amount)\n', '    virtual internal canMint(_token) returns (bool)\n', '  {\n', '    TokenData storage token = tokens[_token];\n', '    token.totalSupply = token.totalSupply.add(_amount);\n', '    token.balances[_to] = token.balances[_to].add(_amount);\n', '    token.allTimeMinted = token.allTimeMinted.add(_amount);\n', '\n', '    require(\n', '      TokenProxy(_token).emitTransfer(address(0), _to, _amount),\n', '      "MT01");\n', '    emit Minted(_token, _amount);\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/delegate/STransferData.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @title STransferData\n', ' * @dev STransferData structure\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', '**/\n', '\n', 'struct STransferData {\n', '  address token;\n', '  address caller;\n', '  address sender;\n', '  address receiver;\n', '\n', '  uint256 senderId;\n', '  uint256[] senderKeys;\n', '  bool senderFetched;\n', '\n', '  uint256 receiverId;\n', '  uint256[] receiverKeys;\n', '  bool receiverFetched;\n', '\n', '  uint256 value;\n', '  uint256 convertedValue;\n', '}\n', '\n', '// File: contracts/delegate/BaseTokenDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Base Token Delegate\n', ' * @dev Base Token Delegate\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' * TD01: Recipient must not be null or be a reserved address\n', ' * TD02: Not enougth tokens\n', ' * TD03: Transfer event must be generated\n', ' * TD04: Allowance limit reached\n', ' */\n', 'contract BaseTokenDelegate is ITokenDelegate, TokenStorage {\n', '\n', '  function decimals() virtual override public view returns (uint256) {\n', '    return tokens[msg.sender].decimals;\n', '  }\n', '\n', '  function totalSupply() virtual override public view returns (uint256) {\n', '    return tokens[msg.sender].totalSupply;\n', '  }\n', '\n', '  function balanceOf(address _owner) virtual override public view returns (uint256) {\n', '    return tokens[msg.sender].balances[_owner];\n', '  }\n', '\n', '  function allowance(address _owner, address _spender)\n', '    virtual override public view returns (uint256)\n', '  {\n', '    return tokens[msg.sender].allowances[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * @dev Overriden transfer function\n', '   */\n', '  function transfer(address _sender, address _receiver, uint256 _value)\n', '    virtual override public returns (bool)\n', '  {\n', '    return transferInternal(\n', '      transferData(msg.sender, address(0), _sender, _receiver, _value));\n', '  }\n', '\n', '  /**\n', '   * @dev Overriden transferFrom function\n', '   */\n', '  function transferFrom(\n', '    address _caller, address _sender, address _receiver, uint256 _value)\n', '    virtual override public returns (bool)\n', '  {\n', '    return transferInternal(\n', '      transferData(msg.sender, _caller, _sender, _receiver, _value));\n', '  }\n', '\n', '  /**\n', '   * @dev can transfer\n', '   */\n', '  function canTransfer(\n', '    address _sender,\n', '    address _receiver,\n', '    uint256 _value) virtual override public view returns (TransferCode)\n', '  {\n', '    return canTransferInternal(\n', '      transferData(msg.sender, address(0), _sender, _receiver, _value));\n', '  }\n', '\n', '  /**\n', '   * @dev approve\n', '   */\n', '  function approve(address _sender, address _spender, uint256 _value)\n', '    virtual override public returns (bool)\n', '  {\n', '    TokenData storage token = tokens[msg.sender];\n', '    token.allowances[_sender][_spender] = _value;\n', '    require(\n', '      TokenProxy(msg.sender).emitApproval(_sender, _spender, _value),\n', '      "TD03");\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev increase approval\n', '   */\n', '  function increaseApproval(address _sender, address _spender, uint _addedValue)\n', '    virtual override public returns (bool)\n', '  {\n', '    TokenData storage token = tokens[msg.sender];\n', '    token.allowances[_sender][_spender] = (\n', '      token.allowances[_sender][_spender].add(_addedValue));\n', '    require(\n', '      TokenProxy(msg.sender).emitApproval(_sender, _spender, token.allowances[_sender][_spender]),\n', '      "TD03");\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev decrease approval\n', '   */\n', '  function decreaseApproval(address _sender, address _spender, uint _subtractedValue)\n', '    virtual override public returns (bool)\n', '  {\n', '    TokenData storage token = tokens[msg.sender];\n', '    uint oldValue = token.allowances[_sender][_spender];\n', '    if (_subtractedValue > oldValue) {\n', '      token.allowances[_sender][_spender] = 0;\n', '    } else {\n', '      token.allowances[_sender][_spender] = oldValue.sub(_subtractedValue);\n', '    }\n', '    require(\n', '      TokenProxy(msg.sender).emitApproval(_sender, _spender, token.allowances[_sender][_spender]),\n', '      "TD03");\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev check configuration\n', '   **/\n', '  function checkConfigurations(uint256[] memory) virtual override public returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev transfer\n', '   */\n', '  function transferInternal(STransferData memory _transferData)\n', '    virtual internal returns (bool)\n', '  {\n', '    TokenData storage token = tokens[_transferData.token];\n', '    address caller = _transferData.caller;\n', '    address sender = _transferData.sender;\n', '    address receiver = _transferData.receiver;\n', '    uint256 value = _transferData.value;\n', '\n', '    require(receiver != address(0) || receiver != ANY_ADDRESSES, "TD01");\n', '    require(value <= token.balances[sender], "TD02");\n', '\n', '    if (caller != address(0)\n', '      && (selfManaged[sender]\n', '        || !hasProxyPrivilege(caller, _transferData.token, msg.sig)))\n', '    {\n', '      require(value <= token.allowances[sender][caller], "TD04");\n', '      token.allowances[sender][caller] = token.allowances[sender][caller].sub(value);\n', '    }\n', '\n', '    token.balances[sender] = token.balances[sender].sub(value);\n', '    token.balances[receiver] = token.balances[receiver].add(value);\n', '    require(\n', '      TokenProxy(msg.sender).emitTransfer(sender, receiver, value),\n', '      "TD03");\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev can transfer\n', '   */\n', '  function canTransferInternal(STransferData memory _transferData)\n', '    virtual internal view returns (TransferCode)\n', '  {\n', '    TokenData storage token = tokens[_transferData.token];\n', '    address sender = _transferData.sender;\n', '    address receiver = _transferData.receiver;\n', '    uint256 value = _transferData.value;\n', '\n', '    if (sender == address(0)) {\n', '      return TransferCode.INVALID_SENDER;\n', '    }\n', '\n', '    if (receiver == address(0)) {\n', '      return TransferCode.NO_RECIPIENT;\n', '    }\n', '\n', '    if (value > token.balances[sender]) {\n', '      return TransferCode.INSUFFICIENT_TOKENS;\n', '    }\n', '\n', '    return TransferCode.OK;\n', '  }\n', '\n', '  /**\n', '   * @dev transferData\n', '   */\n', '  function transferData(\n', '    address _token, address _caller,\n', '    address _sender, address _receiver, uint256 _value)\n', '    internal pure returns (STransferData memory)\n', '  {\n', '    uint256[] memory emptyArray = new uint256[](1);\n', '    return STransferData(\n', '        _token,\n', '        _caller,\n', '        _sender,\n', '        _receiver,\n', '        0,\n', '        emptyArray,\n', '        false,\n', '        0,\n', '        emptyArray,\n', '        false,\n', '        _value,\n', '        0\n', '    );\n', '  }\n', '}\n', '\n', '// File: contracts/delegate/RuleEngineDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title RuleEngineDelegate\n', ' * @dev RuleEngineDelegate contract\n', ' * TokenRuleEngine is a token that will apply\n', ' * rules restricting transferability\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' **/\n', 'abstract contract RuleEngineDelegate is TokenStorage {\n', '\n', '  /**\n', '   * @dev Define rules to the token\n', '   */\n', '  function defineRules(address _token, IRule[] memory _rules)\n', '    public returns (bool)\n', '  {\n', '    tokens[_token].rules = _rules;\n', '    emit RulesDefined(_token, _rules);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Check if the rules are valid\n', '   */\n', '  function areTransferRulesValid(STransferData memory _transferData)\n', '    internal view returns (bool)\n', '  {\n', '    IRule[] memory rules_ = tokens[_transferData.token].rules;\n', '    for (uint256 i = 0; i < rules_.length; i++) {\n', '      if (!rules_[i].isTransferValid(_transferData.sender, _transferData.receiver, _transferData.value)) {\n', '        return false;\n', '      }\n', '    }\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/delegate/MintableTokenDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Token Delegate\n', ' * @dev Token Delegate\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'contract MintableTokenDelegate is RuleEngineDelegate, MintableDelegate, BaseTokenDelegate {\n', '}\n', '\n', '// File: contracts/delegate/SeizableDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SeizableDelegate\n', ' * @dev Token which allows owner to seize accounts\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' * ST01: Transfer events must be generated\n', ' * ST02: Operator cannot seize itself\n', '*/\n', 'abstract contract SeizableDelegate is TokenStorage {\n', '\n', '  /**\n', '   * @dev called by the owner to seize value from the account\n', '   */\n', '  function seize(\n', '    address _token,\n', '    address _account,\n', '    uint256 _amount) public returns (bool)\n', '  {\n', '    require(_account != msg.sender, "ST02");\n', '    TokenData storage token = tokens[_token];\n', '\n', '    token.balances[_account] = token.balances[_account].sub(_amount);\n', '    token.balances[msg.sender] = token.balances[msg.sender].add(_amount);\n', '    token.allTimeSeized = token.allTimeSeized.add(_amount);\n', '\n', '    require(\n', '      TokenProxy(_token).emitTransfer(_account, msg.sender, _amount),\n', '      "ST01");\n', '    emit Seize(_token, _account, _amount);\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/delegate/FreezableDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title FreezableDelegate\n', ' * @dev FreezableDelegate contract\n', ' * This rule allow a legal authority to enforce a freeze of assets.\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' * FTD01: The address is frozen\n', ' */\n', 'abstract contract FreezableDelegate is TokenStorage {\n', '\n', '  /**\n', '   * @dev allow owner to freeze several addresses\n', '   * @param _until allows to auto unlock if the frozen time is known initially.\n', '   * otherwise infinity can be used\n', '   */\n', '  function freezeManyAddresses(\n', '    address _token,\n', '    address[] memory _addresses,\n', '    uint256 _until) public returns (bool)\n', '  {\n', '    mapping(address => uint256) storage frozenUntils = tokens[_token].frozenUntils;\n', '    for (uint256 i = 0; i < _addresses.length; i++) {\n', '      frozenUntils[_addresses[i]] = _until;\n', '      emit Freeze(_addresses[i], _until);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev isFrozen\n', '   */\n', '  function isFrozen(STransferData memory _transferData) internal view returns (bool) {\n', '    mapping(address => uint256) storage frozenUntils = tokens[_transferData.token].frozenUntils;\n', '    // solhint-disable-next-line not-rely-on-time\n', '    uint256 currentTime = now;\n', '    return currentTime < frozenUntils[_transferData.caller]\n', '      || currentTime < frozenUntils[_transferData.sender]\n', '      || currentTime < frozenUntils[_transferData.receiver];\n', '  }\n', '}\n', '\n', '// File: contracts/delegate/LockableDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title LockableDelegate\n', ' * @dev LockableDelegate contract\n', ' * This rule allows to lock assets for a period of time\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' * LD01: locks must be valid proxies\n', ' * LD02: startAt must be before or equal to endAt\n', ' */\n', 'abstract contract LockableDelegate is TokenStorage {\n', '\n', '  /**\n', '   * @dev define token lock\n', '   */\n', '  function defineTokenLocks(address _token, address[] memory _locks) public returns (bool)\n', '  {\n', '    for(uint256 i=0; i < _locks.length; i++) {\n', '      require(delegates[proxyDelegateIds[_locks[i]]] != address(0), "LD01");\n', '    }\n', '\n', '    tokens[_token].locks = _locks;\n', '    emit TokenLocksDefined(_token, _locks);\n', '  }\n', '\n', '  /**\n', '   * @dev define lock\n', '   */\n', '  function defineLock(\n', '    address _lock,\n', '    address _sender,\n', '    address _receiver,\n', '    uint64 _startAt,\n', '    uint64 _endAt) public returns (bool)\n', '  {\n', '    require(_startAt <= _endAt, "LD02");\n', '    locks[_lock][_sender][_receiver] = LockData(_startAt, _endAt);\n', '    emit LockDefined(_lock, _sender, _receiver, _startAt, _endAt);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev isLocked\n', '   */\n', '  function isLocked(STransferData memory _transferData)\n', '    internal view returns (bool isLocked_)\n', '  {\n', '    address[] storage lockAddresses = tokens[_transferData.token].locks;\n', '\n', '    // solhint-disable-next-line not-rely-on-time\n', '    uint256 currentTime = now;\n', '\n', '    for (uint256 i=0; i < lockAddresses.length && !isLocked_; i++) {\n', '      address lockAddress = lockAddresses[i];\n', '      LockData storage lockData = locks[lockAddress][_transferData.sender][_transferData.receiver];\n', '\n', '      if (lockData.endAt < currentTime) {\n', '        LockData storage senderLockData = locks[lockAddress][_transferData.sender][ANY_ADDRESSES];\n', '        LockData storage receiverLockData = locks[lockAddress][ANY_ADDRESSES][_transferData.receiver];\n', '\n', '        if (senderLockData.endAt >= currentTime && receiverLockData.endAt >= currentTime) {\n', '          isLocked_ =\n', '            (currentTime < senderLockData.endAt && currentTime >= senderLockData.startAt) ||\n', '            (currentTime < receiverLockData.endAt && currentTime >= receiverLockData.startAt);\n', '          continue;\n', '        }\n', '\n', '        lockData = senderLockData;\n', '        if (lockData.endAt < currentTime) {\n', '          lockData = receiverLockData;\n', '        }\n', '      }\n', '\n', '      if (lockData.endAt < currentTime) {\n', '        lockData = locks[lockAddress][ANY_ADDRESSES][ANY_ADDRESSES];\n', '      }\n', '\n', '      isLocked_ =\n', '        (currentTime < lockData.endAt && currentTime >= lockData.startAt);\n', '    }\n', '  }\n', '}\n', '\n', '// File: contracts/delegate/STransferAuditData.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title STransferAuditData\n', ' * @dev SAuditData structure\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', '**/\n', '\n', 'struct STransferAuditData {\n', '  uint256 auditConfigurationId;\n', '  uint256 scopeId;\n', '  address currency;\n', '  IRatesProvider ratesProvider;\n', '\n', '  bool senderAuditRequired;\n', '  bool receiverAuditRequired;\n', '}\n', '\n', '// File: contracts/delegate/OracleEnrichedDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title OracleEnrichedDelegate\n', ' * @dev OracleEnrichedDelegate contract\n', " * @dev Enriched the transfer with oracle's informations\n", ' * @dev needed for the delegate processing\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'contract OracleEnrichedDelegate is TokenStorage {\n', '\n', '  uint256 internal constant SENDER_LIMIT_ID = 0;\n', '  uint256 internal constant RECEIVER_LIMIT_ID = 0;\n', '\n', '  /**\n', '   * @dev fetchSenderUserId\n', '   */\n', '  function fetchSenderUserId(STransferData memory _transferData) internal view\n', '  {\n', '    if (!_transferData.senderFetched) {\n', '      _transferData.senderId = userRegistry_.validUserId(_transferData.sender);\n', '      _transferData.senderFetched = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev fetchSenderUser\n', '   */\n', '  function fetchSenderUser(STransferData memory _transferData,\n', '     STransferAuditData memory _transferAuditData) internal view\n', '  {\n', '    if (!_transferData.senderFetched) {\n', '      (_transferData.senderId, _transferData.senderKeys) =\n', '        userRegistry_.validUser(_transferData.sender,\n', '        auditConfigurations[_transferAuditData.auditConfigurationId].senderKeys);\n', '      _transferData.senderFetched = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev fetchReceiverUserId\n', '   */\n', '  function fetchReceiverUserId(STransferData memory _transferData) internal view\n', '  {\n', '    if (!_transferData.receiverFetched) {\n', '      _transferData.receiverId = userRegistry_.validUserId(_transferData.receiver);\n', '      _transferData.receiverFetched = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev fetchReceiverUser\n', '   */\n', '  function fetchReceiverUser(STransferData memory _transferData,\n', '    STransferAuditData memory _transferAuditData) internal view\n', '  {\n', '    if (!_transferData.receiverFetched) {\n', '      (_transferData.receiverId, _transferData.receiverKeys) =\n', '        userRegistry_.validUser(_transferData.receiver,\n', '        auditConfigurations[_transferAuditData.auditConfigurationId].receiverKeys);\n', '      _transferData.receiverFetched = true;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev fetchConvertedValue\n', '   * @dev warning: a converted value of 0 should be considered invalid\n', '   * @dev it is left to the code calling this function to handle this case\n', '   */\n', '  function fetchConvertedValue(STransferData memory _transferData,\n', '    STransferAuditData memory _transferAuditData) internal view\n', '  {\n', '    if (_transferData.convertedValue == 0 && _transferData.value != 0) {\n', '      address currencyFrom = _transferData.token;\n', '      _transferData.convertedValue = (\n', '         _transferAuditData.currency != address(0) && currencyFrom != _transferAuditData.currency\n', '      ) ? _transferAuditData.ratesProvider.convert(_transferData.value,\n', '            bytes32(bytes20(currencyFrom)), bytes32(bytes20(_transferAuditData.currency))\n', '          ) : _transferData.value;\n', '    }\n', '  }\n', '}\n', '\n', '// File: contracts/delegate/AuditableDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title AuditableDelegate\n', ' * @dev Auditable delegate contract\n', ' * Auditable provides transaction data which can be used\n', ' * in other smart contracts\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' * AT01: Configuration and User Registry must have the same currency\n', ' **/\n', 'contract AuditableDelegate is OracleEnrichedDelegate {\n', '\n', '  uint256 internal constant AUDIT_CONFIGURATION_LIMITABLE_TRANSFERABILITY = 0;\n', '\n', '  /**\n', '   * @dev prepareAuditInternal\n', '   */\n', '  function prepareAuditInternal(STransferData memory _transferData)\n', '    internal view returns (STransferAuditData memory)\n', '  {\n', '    uint256 configurationId = delegatesConfigurations_[proxyDelegateIds[_transferData.token]\n', '      ][AUDIT_CONFIGURATION_LIMITABLE_TRANSFERABILITY];\n', '    AuditConfiguration storage configuration = auditConfigurations[configurationId];\n', '\n', '    AuditTriggerMode mode = configuration.triggers[_transferData.sender][_transferData.receiver];\n', '    if (mode == AuditTriggerMode.UNDEFINED) {\n', '      mode = configuration.triggers[_transferData.sender][ANY_ADDRESSES];\n', '    }\n', '    if (mode == AuditTriggerMode.UNDEFINED) {\n', '      mode = configuration.triggers[ANY_ADDRESSES][_transferData.receiver];\n', '    }\n', '    if (mode == AuditTriggerMode.UNDEFINED) {\n', '      mode = configuration.triggers[ANY_ADDRESSES][ANY_ADDRESSES];\n', '    }\n', '\n', '    return STransferAuditData(\n', '      configurationId,\n', '      configuration.scopeId,\n', '      audits[address(this)][configuration.scopeId].currency,\n', '      configuration.ratesProvider,\n', '      (mode == AuditTriggerMode.BOTH || mode == AuditTriggerMode.SENDER_ONLY),\n', '      (mode == AuditTriggerMode.BOTH || mode == AuditTriggerMode.RECEIVER_ONLY)\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Update audit data\n', '   */\n', '  function updateAllAuditsInternal(STransferData memory _transferData,\n', '    STransferAuditData memory _transferAuditData) internal returns (bool)\n', '  {\n', '    uint64 transactionAt = currentTime();\n', '    audits[_transferData.token][uint256(Scope.DEFAULT)\n', '      ].addressData[_transferData.sender].lastTransactionAt = transactionAt;\n', '    audits[_transferData.token][uint256(Scope.DEFAULT)\n', '      ].addressData[_transferData.sender].lastTransactionAt = transactionAt;\n', '\n', '    if (_transferAuditData.senderAuditRequired || _transferAuditData.receiverAuditRequired) {\n', '      fetchConvertedValue(_transferData, _transferAuditData);\n', '\n', '      if (_transferAuditData.senderAuditRequired) {\n', '        fetchSenderUser(_transferData, _transferAuditData);\n', '        if (_transferData.senderId != 0) {\n', '          AuditData storage senderAudit =\n', '            audits[address(this)][_transferAuditData.scopeId].userData[_transferData.senderId];\n', '          if (senderAudit.createdAt == 0) {\n', '            senderAudit.createdAt = transactionAt;\n', '          }\n', '\n', '          senderAudit.cumulatedEmission =\n', '            senderAudit.cumulatedEmission.add(_transferData.convertedValue);\n', '        }\n', '      }\n', '\n', '      if (_transferAuditData.receiverAuditRequired) {\n', '        fetchReceiverUser(_transferData, _transferAuditData);\n', '        if (_transferData.receiverId != 0) {\n', '          AuditData storage receiverAudit =\n', '            audits[address(this)][_transferAuditData.scopeId].userData[_transferData.receiverId];\n', '          if (receiverAudit.createdAt == 0) {\n', '            receiverAudit.createdAt = transactionAt;\n', '          }\n', '          receiverAudit.cumulatedReception =\n', '            receiverAudit.cumulatedReception.add(_transferData.convertedValue);\n', '        }\n', '      }\n', '    }\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/delegate/KYCOnlyTransferabilityDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title KYCOnlyTransferabilityDelegate\n', ' * @dev KYCOnlyTransferabilityDelegate contract\n', ' * This rule allow a legal authority to limite the transferability.\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' * LR01: The transfer constraints must remain valid\n', '*/\n', 'contract KYCOnlyTransferabilityDelegate is AuditableDelegate {\n', '\n', '  /**\n', '   * @dev hasTransferValidUsers\n', '   */\n', '  function hasTransferValidUsers(STransferData memory _transferData,\n', '    STransferAuditData memory _transferAuditData) internal view returns (TransferCode code)\n', '  {\n', '    if (_transferAuditData.senderAuditRequired) {\n', '      fetchSenderUserId(_transferData);\n', '      if (_transferData.senderId == 0) {\n', '        return TransferCode.NON_REGISTRED_SENDER;\n', '      }\n', '    }\n', '\n', '    if (_transferAuditData.receiverAuditRequired) {\n', '      fetchReceiverUserId(_transferData);\n', '      if (_transferData.receiverId == 0) {\n', '        return TransferCode.NON_REGISTRED_RECEIVER;\n', '      }\n', '    }\n', '    return TransferCode.OK;\n', '  }\n', '}\n', '\n', '// File: contracts/delegate/KYCOnlyTokenDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title KYCOnly Token Delegate\n', ' * @dev KYCOnly Token Delegate\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messagesa\n', ' * KOT01: The token must not be locked\n', ' * KOT02: The addresses must not be frozen\n', ' * KOT03: The transfer rules must be valid\n', ' * KOT04: The sender or receiver are not valid\n', ' */\n', 'contract KYCOnlyTokenDelegate is\n', '  KYCOnlyTransferabilityDelegate,\n', '  RuleEngineDelegate,\n', '  SeizableDelegate,\n', '  FreezableDelegate,\n', '  LockableDelegate,\n', '  MintableTokenDelegate\n', '{\n', '\n', '  uint256 internal constant AUDIT_CONFIG_REQUIREMENTS = 1; // 1- Transfer Limits\n', '\n', '  /**\n', '   * @dev check config requirements\n', '   **/\n', '  function checkConfigurations(uint256[] memory _auditConfigurationIds)\n', '    override public returns (bool)\n', '  {\n', '    return (_auditConfigurationIds.length >= AUDIT_CONFIG_REQUIREMENTS);\n', '  }\n', '\n', ' /**\n', '   * @dev transfer\n', '   */\n', '  function transferInternal(STransferData memory _transferData)\n', '    override internal returns (bool)\n', '  {\n', '    require(!isLocked(_transferData), "KOT01");\n', '    require(!isFrozen(_transferData), "KOT02");\n', '    require(areTransferRulesValid(_transferData), "KOT03");\n', '\n', '    STransferAuditData memory _transferAuditData =\n', '      prepareAuditInternal(_transferData);\n', '    require(hasTransferValidUsers(_transferData, _transferAuditData) == TransferCode.OK, "KOT04");\n', '\n', '    return super.transferInternal(_transferData);\n', '  }\n', '\n', '  /**\n', '   * @dev can transfer\n', '   */\n', '  function canTransferInternal(STransferData memory _transferData)\n', '    override internal view returns (TransferCode code)\n', '  {\n', '    if (isLocked(_transferData)) {\n', '      return TransferCode.LOCKED;\n', '    }\n', '    if (isFrozen(_transferData)) {\n', '      return TransferCode.FROZEN;\n', '    }\n', '    if (!areTransferRulesValid(_transferData)) {\n', '      return TransferCode.RULE;\n', '    }\n', '\n', '    STransferAuditData memory _transferAuditData =\n', '      prepareAuditInternal(_transferData);\n', '    code = hasTransferValidUsers(_transferData, _transferAuditData);\n', '\n', '    return (code == TransferCode.OK) ?\n', '      super.canTransferInternal(_transferData) : code;\n', '  }\n', '}']