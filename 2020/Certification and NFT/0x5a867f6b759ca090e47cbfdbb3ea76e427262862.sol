['//SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            if (returndata.length > 0) {\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface IERC20Token is IERC20 {\n', '    function maxSupply() external view returns (uint256);\n', '    function issue(address account, uint256 amount) external returns (bool);\n', '    function burn(uint256 amount) external returns (bool);\n', '}\n', '\n', 'contract DevAward {\n', '    // dev line release\n', '    address public dev;\n', '    uint256 public devStartBlock;\n', '    uint256 public devAccAwards;\n', '    uint256 public devPerBlock;\n', '    uint256 public MaxAvailAwards;\n', '    uint256 public claimedIncentives;\n', '}\n', '\n', 'contract AwardInfo {\n', '    struct TaxInfo {\n', '        uint256 epoch;\n', '        uint256 amount;\n', '    }\n', '\n', '    struct UserInfo {\n', '        uint256 freeAmount;\n', '        uint256 taxHead;     // queue head element index\n', '        uint256 taxTail;     // queue tail next element index\n', '        bool notEmpty;       // whether taxList is empty where taxHead = taxTail\n', '        TaxInfo[] taxList;\n', '    }\n', '\n', '    // tax epoch info\n', '    uint256 public taxEpoch = 9;     // tax epoch and user taxlist max length\n', '    uint256 public epUnit = 1 weeks;  // epoch unit => week\n', '\n', '    // user info\n', '    mapping(address => UserInfo) internal userInfo;\n', '\n', '    // tax treasury address\n', '    address public treasury;\n', '}\n', '\n', 'contract AwardContract is DevAward, AwardInfo, Ownable {\n', '\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20Token;\n', '\n', '    // platform token\n', '    IERC20Token public platformToken;\n', '    mapping(address => bool) public governors;\n', '    modifier onlyGovernor{\n', '        require(governors[_msgSender()], "AwardContract: caller is not the governor");\n', '        _;\n', '    }\n', '\n', '    event AddFreeAward(address user, uint256 amount);\n', '    event AddAward(address user, uint256 amount);\n', '    event Withdraw(address user, uint256 amount, uint256 tax);\n', '\n', '    constructor(\n', '        IERC20Token _platformToken,\n', '        uint256 _taxEpoch,\n', '        address _treasury,\n', '        address _dev,\n', '        uint256 _devStartBlock,\n', '        uint256 _devPerBlock\n', '    ) public {\n', '        require(_taxEpoch > 0, "AwardContract: taxEpoch invalid");\n', '        require(_dev != address(0), "AwardContract: dev invalid");\n', '        require(address(_platformToken) != address(0), "AwardContract: platform token invalid");\n', '        require(_devStartBlock != 0, "AwardContract: dev start block invalid");\n', '\n', '        platformToken = _platformToken;\n', '        taxEpoch = _taxEpoch;\n', '        governors[_msgSender()] = true;\n', '\n', '        // get tax fee\n', '        treasury = _treasury;\n', '        // dev info\n', '        dev = _dev;\n', '        // Dev can receive 10% of platformToken\n', '        MaxAvailAwards = platformToken.maxSupply().mul(10).div(100);\n', '        devPerBlock = _devPerBlock;\n', '        devStartBlock = _devStartBlock;\n', '    }\n', '\n', '    // get user total rewards\n', '    function getUserTotalAwards(address user) view public returns (uint256){\n', '        UserInfo memory info = userInfo[user];\n', '        uint256 amount = info.freeAmount;\n', '        if (info.notEmpty) {\n', '            uint256 cursor = info.taxHead;\n', '            while (true) {\n', '                amount = amount.add(info.taxList[cursor].amount);\n', '                cursor = cursor.add(1).mod(taxEpoch);\n', '                if (cursor == info.taxTail) {\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '        return amount;\n', '    }\n', '\n', '    // get user free rewards amount\n', '    function getCurrentFreeAwards(address user) view public returns (uint256){\n', '        uint256 rebaseEp = getCurrEpoch().sub(taxEpoch);\n', '        UserInfo memory info = userInfo[user];\n', '        uint256 amount = info.freeAmount;\n', '        if (info.notEmpty) {\n', '            uint256 cursor = info.taxHead;\n', '            while (info.taxList[cursor].epoch <= rebaseEp) {\n', '                amount = amount.add(info.taxList[cursor].amount);\n', '                cursor = cursor.add(1).mod(taxEpoch);\n', '                if (cursor == info.taxTail) {\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '        return amount;\n', '    }\n', '\n', '    // get available awards\n', '    function getUserAvailAwards(address user) view public returns (uint256){\n', '        uint256 current = getCurrEpoch();\n', '        uint256 rebaseEp = current.sub(taxEpoch);\n', '        UserInfo memory info = userInfo[user];\n', '        uint256 amount = info.freeAmount;\n', '        if (info.notEmpty) {\n', '            uint256 _ep = taxEpoch.add(1);\n', '            uint256 cursor = info.taxHead;\n', '            while (true) {\n', '                if (info.taxList[cursor].epoch > rebaseEp) {\n', '                    uint rate = current.sub(info.taxList[cursor].epoch).add(1).mul(1e12).div(_ep);\n', '                    uint256 available = info.taxList[cursor].amount.mul(rate).div(1e12);\n', '                    amount = amount.add(available);\n', '                } else {\n', '                    amount = amount.add(info.taxList[cursor].amount);\n', '                }\n', '                cursor = cursor.add(1).mod(taxEpoch);\n', '                if (cursor == info.taxTail) {\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '        return amount;\n', '    }\n', '\n', '    // estimate gas\n', '    function estimateTax(uint256 _amount) view external returns (uint256){\n', '        uint256 _current = getCurrEpoch();\n', '        uint256 tax = 0;\n', '        UserInfo memory user = userInfo[msg.sender];\n', '        if (user.freeAmount >= _amount) {\n', '            return 0;\n', '        }\n', '        else {\n', '            uint256 current = _current;\n', '            uint256 arrears = _amount.sub(user.freeAmount);\n', '            uint256 _head = user.taxHead;\n', '            uint256 _ep = taxEpoch.add(1);\n', '            while (user.notEmpty) {\n', '                // non-levied tax rate\n', '                TaxInfo memory taxInfo = user.taxList[_head];\n', '                uint rate = current.sub(taxInfo.epoch).add(1).mul(1e12).div(_ep);\n', '                if (rate > 1e12) {\n', '                    rate = 1e12;\n', '                }\n', '                uint256 available = taxInfo.amount.mul(rate).div(1e12);\n', '                if (available >= arrears) {\n', '                    uint256 newAmount = arrears.mul(1e12).div(rate);\n', '                    tax = tax.add(newAmount.sub(arrears));\n', '                    arrears = 0;\n', '                    break;\n', '                }\n', '                else {\n', '                    arrears = arrears.sub(available);\n', '                    tax = tax.add(taxInfo.amount.sub(available));\n', '                    _head = _head.add(1).mod(taxEpoch);\n', '                    if (_head == user.taxTail) {\n', '                        break;\n', '                    }\n', '                }\n', '            }\n', '            require(arrears == 0, "AwardContract: Insufficient Balance");\n', '            return tax;\n', '        }\n', '    }\n', '\n', '    // add governor\n', '    function addGovernor(address governor) onlyOwner external {\n', '        governors[governor] = true;\n', '    }\n', '\n', '    // remove governor\n', '    function removeGovernor(address governor) onlyOwner external {\n', '        governors[governor] = false;\n', '    }\n', '\n', '    // dev get rewards\n', '    function claimDevAwards() external {\n', '        require(msg.sender == dev, "AwardContract: only dev can receive awards");\n', '        require(devAccAwards < MaxAvailAwards, "AwardContract: dev awards exceed permitted amount");\n', '        uint256 amount = block.number.sub(devStartBlock).mul(devPerBlock);\n', '        uint256 rewards = amount.sub(devAccAwards);\n', '        if (amount > MaxAvailAwards) {\n', '            rewards = MaxAvailAwards.sub(devAccAwards);\n', '        }\n', '        safeIssue(dev, rewards, "AwardContract: dev claim awards failed");\n', '        devAccAwards = devAccAwards.add(rewards);\n', '    }\n', '\n', '    // add free amount\n', '    function addFreeAward(address _user, uint256 _amount) onlyGovernor external {\n', '        UserInfo storage user = userInfo[_user];\n', '        user.freeAmount = user.freeAmount.add(_amount);\n', '        emit AddFreeAward(_user, _amount);\n', '    }\n', '\n', '    // add award\n', '    function addAward(address _user, uint256 _amount) onlyGovernor public {\n', '        uint256 current = getCurrEpoch();\n', '        // get epoch\n', '        UserInfo storage user = userInfo[_user];\n', '        //\n', '        if (user.taxList.length == 0) {\n', '            user.taxList.push(TaxInfo({\n', '            epoch : current,\n', '            amount : _amount\n', '            }));\n', '            user.taxHead = 0;\n', '            user.taxTail = 1;\n', '            user.notEmpty = true;\n', '        }\n', '        else {\n', '            // taxList not full\n', '            if (user.notEmpty) {\n', '                uint256 end;\n', '                if (user.taxTail == 0) {\n', '                    end = user.taxList.length - 1;\n', '                } else {\n', '                    end = user.taxTail.sub(1);\n', '                }\n', '                if (user.taxList[end].epoch >= current) {\n', '                    user.taxList[end].amount = user.taxList[end].amount.add(_amount);\n', '                } else {\n', '                    if (user.taxList.length < taxEpoch) {\n', '                        user.taxList.push(TaxInfo({\n', '                        epoch : current,\n', '                        amount : _amount\n', '                        }));\n', '                    } else {\n', '                        if (user.taxHead == user.taxTail) {\n', '                            rebase(user, current);\n', '                        }\n', '                        user.taxList[user.taxTail].epoch = current;\n', '                        user.taxList[user.taxTail].amount = _amount;\n', '                    }\n', '                    user.taxTail = user.taxTail.add(1).mod(taxEpoch);\n', '                }\n', '            } else {// user.taxHead == user.taxTail\n', '                if (user.taxList.length < taxEpoch) {\n', '                    user.taxList.push(TaxInfo({\n', '                    epoch : current,\n', '                    amount : _amount\n', '                    }));\n', '                } else {\n', '                    user.taxList[user.taxTail].epoch = current;\n', '                    user.taxList[user.taxTail].amount = _amount;\n', '                }\n', '                user.taxTail = user.taxTail.add(1).mod(taxEpoch);\n', '                user.notEmpty = true;\n', '            }\n', '        }\n', '        emit AddAward(_user, _amount);\n', '    }\n', '\n', '    // batch add awards\n', '    function batchAddAwards(address[] memory _users, uint256[] memory _amounts) onlyGovernor external {\n', '        require(_users.length == _amounts.length, "AwardContract: params invalid");\n', '        for (uint i = 0; i < _users.length; i++) {\n', '            addAward(_users[i], _amounts[i]);\n', '        }\n', '    }\n', '\n', '    function withdraw(uint256 _amount) external {\n', '        uint256 current = getCurrEpoch();\n', '        uint256 _destroy = 0;\n', '        // get base time\n', '        UserInfo storage user = userInfo[msg.sender];\n', '        // rebase\n', '        rebase(user, current);\n', '\n', '        if (user.freeAmount >= _amount) {\n', '            user.freeAmount = user.freeAmount.sub(_amount);\n', '        }\n', '        else {\n', '            uint256 arrears = _amount.sub(user.freeAmount);\n', '            user.freeAmount = 0;\n', '            uint256 _head = user.taxHead;\n', '            uint256 _ep = taxEpoch.add(1);\n', '            while (user.notEmpty) {\n', '                // non-levied tax rate\n', '                uint rate = current.sub(user.taxList[_head].epoch).add(1).mul(1e12).div(_ep);\n', '\n', '                uint256 available = user.taxList[_head].amount.mul(rate).div(1e12);\n', '                // available token\n', '                if (available >= arrears) {\n', '                    uint256 newAmount = arrears.mul(1e12).div(rate);\n', '                    user.taxList[_head].amount = user.taxList[_head].amount.sub(newAmount);\n', '                    _destroy = _destroy.add(newAmount.sub(arrears));\n', '                    arrears = 0;\n', '                    break;\n', '                }\n', '                else {\n', '                    arrears = arrears.sub(available);\n', '                    _destroy = _destroy.add(user.taxList[_head].amount.sub(available));\n', '                    _head = _head.add(1).mod(taxEpoch);\n', '                    if (_head == user.taxTail) {\n', '                        user.notEmpty = false;\n', '                    }\n', '                }\n', '            }\n', '            user.taxHead = _head;\n', '            require(arrears == 0, "AwardContract: Insufficient Balance");\n', '            safeIssue(treasury, _destroy, "AwardContract: levy tax failed");\n', '        }\n', '        safeIssue(msg.sender, _amount, "AwardContract: claim awards failed");\n', '        emit Withdraw(msg.sender, _amount, _destroy);\n', '    }\n', '\n', '    function pendingIncentives() view public returns (uint256){\n', "        uint256 startBlock = 11210456;   // It's staking start block\n", '        if (block.number <= startBlock) return 0;\n', '\n', '        uint256 maxIncent = 745000 * 10 ** 18;\n', '        uint256 incents = block.number.sub(startBlock).mul(15 * 10 ** 16);\n', '        if (incents > maxIncent) {\n', '            return maxIncent.sub(claimedIncentives);\n', '        } else {\n', '            return incents.sub(claimedIncentives);\n', '        }\n', '    }\n', '\n', '    function claimIncentives(address to, uint256 amount) external {\n', '        require(msg.sender == dev, "AwardContract: unauthorized");\n', '        require(to != dev, "AwardContract: dev so greedy");\n', '        uint256 pending = pendingIncentives();\n', '        require(amount <= pending, "AwardContract: incentives exceed");\n', '        safeIssue(to, amount, "AwardContract: claim incentives err");\n', '        claimedIncentives = claimedIncentives.add(amount);\n', '    }\n', '\n', '    function destroy(uint256 amount) onlyGovernor external {\n', '        safeIssue(treasury, amount, "AwardContract: levy tax failed");\n', '    }\n', '\n', '    function getCurrEpoch() internal view returns (uint256) {\n', '        return now.div(epUnit);\n', '    }\n', '\n', '    function safeIssue(address user, uint256 amount, string memory err) internal {\n', '        if (amount > 0) {\n', '            require(amount.add(platformToken.totalSupply()) <= platformToken.maxSupply(), "AwardContract: awards exceeds maxSupply");\n', '            require(platformToken.issue(user, amount), err);\n', '        }\n', '    }\n', '\n', '    function rebase(UserInfo storage _user, uint256 _current) internal {\n', '        uint256 rebaseEp = _current.sub(taxEpoch);\n', '        uint256 head = _user.taxHead;\n', '        while (_user.notEmpty && _user.taxList[head].epoch <= rebaseEp) {\n', '            _user.freeAmount = _user.freeAmount.add(_user.taxList[head].amount);\n', '            head = head.add(1).mod(taxEpoch);\n', '            if (head == _user.taxTail) {\n', '                _user.notEmpty = false;\n', '            }\n', '        }\n', '        _user.taxHead = head;\n', '    }\n', '}']