['// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 { // brief interface for erc20 token tx\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', 'library Address { // helper for address type - see openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '}\n', '\n', 'library SafeERC20 { // wrapper around erc20 token tx for non-standard contract - see openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\n', '    using Address for address;\n', '    \n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '    \n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '    \n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '        (bool success, bytes memory returnData) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returnData.length > 0) { // return data is optional\n', '            require(abi.decode(returnData, (bool)), "SafeERC20: erc20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath { // arithmetic wrapper for unit under/overflow check\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ReentrancyGuard { // call wrapper for reentrancy check\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '    uint256 private _status;\n', '\n', '    constructor() internal {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '        _status = _ENTERED;\n', '        _;\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', 'contract MYSTIC is ReentrancyGuard { \n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    /***************\n', '    GLOBAL CONSTANTS\n', '    ***************/\n', '    address public depositToken; // deposit token contract reference - default = wETH\n', '    address public stakeToken; // stake token contract reference for guild voting shares \n', '    address public constant wETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // canonical ether token wrapper contract reference \n', '    uint256 public proposalDeposit; // default = 10 deposit token \n', '    uint256 public processingReward; // default = 0.1 - amount of deposit token to give to whoever processes a proposal\n', '    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\n', '    uint256 public votingPeriodLength; // default = 35 periods (7 days)\n', '    uint256 public gracePeriodLength; // default = 35 periods (7 days)\n', '    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\n', '    uint256 public summoningTime; // needed to determine the current period\n', '    bool private initialized; // internally tracks deployment under eip-1167 proxy pattern\n', '    \n', '    // HARD-CODED LIMITS\n', '    uint256 constant MAX_GUILD_BOUND = 10**36; // maximum bound for guild member accounting\n', '    uint256 constant MAX_TOKEN_WHITELIST_COUNT = 400; // maximum number of whitelisted tokens\n', '    uint256 constant MAX_TOKEN_GUILDBANK_COUNT = 200; // maximum number of tokens with non-zero balance in guildbank\n', '\n', '    // GUILD TOKEN DETAILS\n', '    uint8 public constant decimals = 18;\n', '    string public guildName; // set at summoning\n', '    string public constant symbol = "DAO";\n', '    \n', '    // *******************\n', '    // INTERNAL ACCOUNTING\n', '    // *******************\n', '    address public constant GUILD = address(0xdead);\n', '    address public constant ESCROW = address(0xdeaf);\n', '    address public constant TOTAL = address(0xdeed);\n', '    uint256 public proposalCount; // total proposals submitted\n', '    uint256 public totalShares; // total shares across all members\n', '    uint256 public totalLoot; // total loot across all members\n', '    uint256 public totalSupply; // total shares & loot across all members (total guild tokens)\n', '    uint256 public totalGuildBankTokens; // total tokens with non-zero balance in guild bank\n', '\n', '    mapping(address => uint256) public balanceOf; // guild token balances\n', '    mapping(address => mapping(address => uint256)) public allowance; // guild token (loot) allowances\n', '    mapping(address => mapping(address => uint256)) private userTokenBalances; // userTokenBalances[userAddress][tokenAddress]\n', '    \n', '    address[] public approvedTokens;\n', '    mapping(address => bool) public tokenWhitelist;\n', '    \n', '    uint256[] public proposalQueue;\n', '    mapping(uint256 => bytes) public actions; \n', '    mapping(uint256 => Proposal) public proposals;\n', '\n', '    mapping(address => bool) public proposedToWhitelist;\n', '    mapping(address => bool) public proposedToKick;\n', '    \n', '    mapping(address => Member) public members;\n', '    mapping(address => address) public memberAddressByDelegateKey;\n', '\n', '    // **************\n', '    // EVENT TRACKING\n', '    // **************\n', '    event SubmitProposal(address indexed applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken, bytes32 details, uint8[8] flags, bytes data, uint256 proposalId, address indexed delegateKey, address indexed memberAddress);\n', '    event CancelProposal(uint256 indexed proposalId, address applicantAddress);\n', '    event SponsorProposal(address indexed delegateKey, address indexed memberAddress, uint256 proposalId, uint256 proposalIndex, uint256 startingPeriod);\n', '    event SubmitVote(uint256 proposalId, uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\n', '    event ProcessProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\n', '    event ProcessActionProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\n', '    event ProcessGuildKickProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\n', '    event ProcessWhitelistProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\n', '    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\n', '    event Ragequit(address indexed memberAddress, uint256 sharesToBurn, uint256 lootToBurn);\n', '    event TokensCollected(address indexed token, uint256 amountToCollect);\n', '    event Withdraw(address indexed memberAddress, address token, uint256 amount);\n', '    event ConvertSharesToLoot(address indexed memberAddress, uint256 amount);\n', '    event StakeTokenForShares(address indexed memberAddress, uint256 amount);\n', '    event Approval(address indexed owner, address indexed spender, uint256 amount); // guild token (loot) allowance tracking\n', '    event Transfer(address indexed sender, address indexed recipient, uint256 amount); // guild token mint, burn & loot transfer tracking\n', '    \n', '    enum Vote {\n', '        Null, // default value, counted as abstention\n', '        Yes,\n', '        No\n', '    }\n', '    \n', '    struct Member {\n', '        address delegateKey; // the key responsible for submitting proposals & voting - defaults to member address unless updated\n', '        uint8 exists; // always true (1) once a member has been created\n', '        uint256 shares; // the # of voting shares assigned to this member\n', '        uint256 loot; // the loot amount available to this member (combined with shares on ragekick) - transferable by guild token\n', '        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\n', '        uint256 jailed; // set to proposalIndex of a passing guild kick proposal for this member, prevents voting on & sponsoring proposals\n', '    }\n', '    \n', '    struct Proposal {\n', '        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals (doubles as target for alt. proposals)\n', '        address proposer; // the account that submitted the proposal (can be non-member)\n', '        address sponsor; // the member that sponsored the proposal (moving it into the queue)\n', '        address tributeToken; // tribute token contract reference\n', '        address paymentToken; // payment token contract reference\n', '        uint8[8] flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action, standard]\n', '        uint256 sharesRequested; // the # of shares the applicant is requesting\n', '        uint256 lootRequested; // the amount of loot the applicant is requesting\n', '        uint256 paymentRequested; // amount of tokens requested as payment\n', '        uint256 tributeOffered; // amount of tokens offered as tribute\n', '        uint256 startingPeriod; // the period in which voting can start for this proposal\n', '        uint256 yesVotes; // the total number of YES votes for this proposal\n', '        uint256 noVotes; // the total number of NO votes for this proposal\n', '        uint256 maxTotalSharesAndLootAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\n', '        bytes32 details; // proposal details to add context for members \n', '        mapping(address => Vote) votesByMember; // the votes on this proposal by each member\n', '    }\n', '    \n', '    modifier onlyDelegate {\n', '        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, "!delegate");\n', '        _;\n', '    }\n', '\n', '    function init(\n', '        address _depositToken,\n', '        address _stakeToken,\n', '        address[] memory _summoner,\n', '        uint256[] memory _summonerShares,\n', '        uint256 _summonerDeposit,\n', '        uint256 _proposalDeposit,\n', '        uint256 _processingReward,\n', '        uint256 _periodDuration,\n', '        uint256 _votingPeriodLength,\n', '        uint256 _gracePeriodLength,\n', '        uint256 _dilutionBound,\n', '        string memory _guildName\n', '    ) external {\n', '        require(!initialized, "initialized");\n', '        require(_depositToken != _stakeToken, "depositToken = stakeToken");\n', '        require(_summoner.length == _summonerShares.length, "summoner != summonerShares");\n', '        require(_proposalDeposit >= _processingReward, "_processingReward > _proposalDeposit");\n', '        \n', '        for (uint256 i = 0; i < _summoner.length; i++) {\n', '            growGuild(_summoner[i], _summonerShares[i], 0);\n', '        }\n', '        \n', '        require(totalShares <= MAX_GUILD_BOUND, "guild maxed");\n', '        tokenWhitelist[_depositToken] = true;\n', '        approvedTokens.push(_depositToken);\n', '        \n', '        if (_summonerDeposit > 0) {\n', '            totalGuildBankTokens += 1;\n', '            unsafeAddToBalance(GUILD, _depositToken, _summonerDeposit);\n', '        }\n', '        \n', '        depositToken = _depositToken;\n', '        stakeToken = _stakeToken;\n', '        proposalDeposit = _proposalDeposit;\n', '        processingReward = _processingReward;\n', '        periodDuration = _periodDuration;\n', '        votingPeriodLength = _votingPeriodLength;\n', '        gracePeriodLength = _gracePeriodLength;\n', '        dilutionBound = _dilutionBound;\n', '        summoningTime = now;\n', '        guildName = _guildName;\n', '        initialized = true;\n', '    }\n', '    \n', '    /*****************\n', '    PROPOSAL FUNCTIONS\n', '    *****************/\n', '    function submitProposal(\n', '        address applicant,\n', '        uint256 sharesRequested,\n', '        uint256 lootRequested,\n', '        uint256 tributeOffered,\n', '        address tributeToken,\n', '        uint256 paymentRequested,\n', '        address paymentToken,\n', '        bytes32 details\n', '    ) external nonReentrant payable returns (uint256 proposalId) {\n', '        require(sharesRequested.add(lootRequested) <= MAX_GUILD_BOUND, "guild maxed");\n', '        require(tokenWhitelist[tributeToken], "tributeToken != whitelist");\n', '        require(tokenWhitelist[paymentToken], "paymentToken != whitelist");\n', '        require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, "applicant unreservable");\n', '        require(members[applicant].jailed == 0, "applicant jailed");\n', '\n', '        if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) {\n', '            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, "guildbank maxed");\n', '        }\n', '        \n', '        // collect tribute from proposer & store it in MYSTIC until the proposal is processed - if ether, wrap into wETH\n', '        if (msg.value > 0) {\n', '            require(tributeToken == wETH && msg.value == tributeOffered, "!ethBalance");\n', '            (bool success, ) = wETH.call{value: msg.value}("");\n', '            require(success, "!ethCall");\n', '            IERC20(wETH).safeTransfer(address(this), msg.value);\n', '        } else {\n', '            IERC20(tributeToken).safeTransferFrom(msg.sender, address(this), tributeOffered);\n', '        }\n', '        \n', '        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\n', '        \n', '        uint8[8] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action, standard]\n', '        flags[7] = 1; // standard\n', '\n', '        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, "");\n', '        \n', '        return proposalCount - 1; // return proposalId - contracts calling submit might want it\n', '    }\n', '    \n', "     function submitActionProposal( // stages arbitrary function calls for member vote - based on Raid Guild 'Minion'\n", '        address actionTo, // target account for action (e.g., address to receive ether, token, dao, etc.)\n', '        uint256 actionTokenAmount, // helps check outbound guild bank token amount does not exceed internal balance / amount to update bank if successful \n', '        uint256 actionValue, // ether value, if any, in call \n', '        bytes32 details, // details tx staged for member execution - as external, extra care should be applied in diligencing action \n', '        bytes calldata data // data for function call\n', '    ) external nonReentrant returns (uint256 proposalId) {\n', '        uint8[8] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action, standard]\n', '        flags[6] = 1; // action\n', '        \n', '        _submitProposal(actionTo, 0, 0, actionValue, address(0), actionTokenAmount, address(0), details, flags, data);\n', '        \n', '        return proposalCount - 1;\n', '    }\n', '\n', '    function submitGuildKickProposal(address memberToKick, bytes32 details) external nonReentrant returns (uint256 proposalId) {\n', '        Member memory member = members[memberToKick];\n', '        require(member.shares > 0 || member.loot > 0, "!share||loot");\n', '        require(members[memberToKick].jailed == 0, "jailed");\n', '        uint8[8] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action, standard]\n', '        flags[5] = 1; // guildkick\n', '\n', '        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags, "");\n', '        \n', '        return proposalCount - 1;\n', '    }\n', '    \n', '    function submitWhitelistProposal(address tokenToWhitelist, bytes32 details) external nonReentrant returns (uint256 proposalId) {\n', '        require(tokenToWhitelist != address(0), "!token");\n', '        require(tokenToWhitelist != stakeToken, "tokenToWhitelist = stakeToken");\n', '        require(!tokenWhitelist[tokenToWhitelist], "whitelisted");\n', '        require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, "whitelist maxed");\n', '        uint8[8] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick, action, standard]\n', '        flags[4] = 1; // whitelist\n', '\n', '        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags, "");\n', '        \n', '        return proposalCount - 1;\n', '    }\n', '\n', '    function _submitProposal(\n', '        address applicant,\n', '        uint256 sharesRequested,\n', '        uint256 lootRequested,\n', '        uint256 tributeOffered,\n', '        address tributeToken,\n', '        uint256 paymentRequested,\n', '        address paymentToken,\n', '        bytes32 details,\n', '        uint8[8] memory flags,\n', '        bytes memory data\n', '    ) internal {\n', '        Proposal memory proposal = Proposal({\n', '            applicant : applicant,\n', '            proposer : msg.sender,\n', '            sponsor : address(0),\n', '            tributeToken : tributeToken,\n', '            paymentToken : paymentToken,\n', '            flags : flags,\n', '            sharesRequested : sharesRequested,\n', '            lootRequested : lootRequested,\n', '            paymentRequested : paymentRequested,\n', '            tributeOffered : tributeOffered,\n', '            startingPeriod : 0,\n', '            yesVotes : 0,\n', '            noVotes : 0,\n', '            maxTotalSharesAndLootAtYesVote : 0,\n', '            details : details\n', '        });\n', '        \n', '        if (proposal.flags[6] == 1) {\n', '            actions[proposalCount] = data;\n', '        }\n', '        \n', '        proposals[proposalCount] = proposal;\n', '        // NOTE: argument order matters, avoid stack too deep\n', '        emit SubmitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags, data, proposalCount, msg.sender, memberAddressByDelegateKey[msg.sender]);\n', '        \n', '        proposalCount += 1;\n', '    }\n', '\n', '    function sponsorProposal(uint256 proposalId) external nonReentrant onlyDelegate {\n', '        // collect proposal deposit from sponsor & store it in MYSTIC until the proposal is processed\n', '        IERC20(depositToken).safeTransferFrom(msg.sender, address(this), proposalDeposit);\n', '        unsafeAddToBalance(ESCROW, depositToken, proposalDeposit);\n', '        Proposal storage proposal = proposals[proposalId];\n', '        require(proposal.proposer != address(0), "!proposed");\n', '        require(proposal.flags[0] == 0, "sponsored");\n', '        require(proposal.flags[3] == 0, "cancelled");\n', '        require(members[proposal.applicant].jailed == 0, "applicant jailed");\n', '\n', '        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0) {\n', '            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, "guildbank maxed");\n', '        }\n', '\n', '        // whitelist proposal\n', '        if (proposal.flags[4] == 1) {\n', '            require(!tokenWhitelist[address(proposal.tributeToken)], "whitelisted");\n', '            require(!proposedToWhitelist[address(proposal.tributeToken)], "whitelist proposed");\n', '            require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, "whitelist maxed");\n', '            proposedToWhitelist[address(proposal.tributeToken)] = true;\n', '\n', '        // guild kick proposal\n', '        } else if (proposal.flags[5] == 1) {\n', '            require(!proposedToKick[proposal.applicant], "kick proposed");\n', '            proposedToKick[proposal.applicant] = true;\n', '        }\n', '\n', '        // compute startingPeriod for proposal\n', '        uint256 startingPeriod = max(\n', '            getCurrentPeriod(),\n', '            proposalQueue.length == 0 ? 0 : proposals[proposalQueue[proposalQueue.length - 1]].startingPeriod\n', '        ) + 1;\n', '\n', '        proposal.startingPeriod = startingPeriod;\n', '        proposal.sponsor = memberAddressByDelegateKey[msg.sender];\n', '        proposal.flags[0] = 1; // sponsored\n', '        // append proposal to the queue\n', '        proposalQueue.push(proposalId);\n', '        \n', '        emit SponsorProposal(msg.sender, proposal.sponsor, proposalId, proposalQueue.length - 1, startingPeriod);\n', '    }\n', '\n', '    // NOTE: In MYSTIC, proposalIndex != proposalId\n', '    function submitVote(uint256 proposalIndex, uint8 uintVote) external nonReentrant onlyDelegate {\n', '        address memberAddress = memberAddressByDelegateKey[msg.sender];\n', '        Member storage member = members[memberAddress];\n', '        require(proposalIndex < proposalQueue.length, "!proposed");\n', '        uint256 proposalId = proposalQueue[proposalIndex];\n', '        Proposal storage proposal = proposals[proposalId];\n', '        require(uintVote < 3, ">2");\n', '        Vote vote = Vote(uintVote);\n', '        require(getCurrentPeriod() >= proposal.startingPeriod, "pending");\n', '        require(!hasVotingPeriodExpired(proposal.startingPeriod), "expired");\n', '        require(proposal.votesByMember[memberAddress] == Vote.Null, "voted");\n', '        require(vote == Vote.Yes || vote == Vote.No, "!Yes||No");\n', '        proposal.votesByMember[memberAddress] = vote;\n', '\n', '        if (vote == Vote.Yes) {\n', '            proposal.yesVotes += member.shares;\n', '\n', '            // set highest index (latest) yes vote - must be processed for member to ragequit\n', '            if (proposalIndex > member.highestIndexYesVote) {\n', '                member.highestIndexYesVote = proposalIndex;\n', '            }\n', '\n', '            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\n', '            if (totalSupply > proposal.maxTotalSharesAndLootAtYesVote) {\n', '                proposal.maxTotalSharesAndLootAtYesVote = totalSupply;\n', '            }\n', '\n', '        } else if (vote == Vote.No) {\n', '            proposal.noVotes += member.shares;\n', '        }\n', '     \n', "        // NOTE: subgraph indexes by proposalId not proposalIndex since proposalIndex isn't set until it's been sponsored but proposal is created on submission\n", '        emit SubmitVote(proposalId, proposalIndex, msg.sender, memberAddress, uintVote);\n', '    }\n', '\n', '    function processProposal(uint256 proposalIndex) external nonReentrant {\n', '        _validateProposalForProcessing(proposalIndex);\n', '        uint256 proposalId = proposalQueue[proposalIndex];\n', '        Proposal storage proposal = proposals[proposalId];\n', '        require(proposal.flags[7] == 1, "!standard");\n', '        proposal.flags[1] = 1; // processed\n', '        \n', '        bool didPass = _didPass(proposalIndex);\n', '        // Make the proposal fail if the new total number of shares & loot exceeds the limit\n', '        if (totalSupply.add(proposal.sharesRequested).add(proposal.lootRequested) > MAX_GUILD_BOUND) {\n', '            didPass = false;\n', '        }\n', '\n', '        // Make the proposal fail if it is requesting more tokens as payment than the available guild bank balance\n', '        if (proposal.paymentRequested > userTokenBalances[GUILD][proposal.paymentToken]) {\n', '            didPass = false;\n', '        }\n', '\n', '        // Make the proposal fail if it would result in too many tokens with non-zero balance in guild bank\n', '        if (proposal.tributeOffered > 0 && userTokenBalances[GUILD][proposal.tributeToken] == 0 && totalGuildBankTokens >= MAX_TOKEN_GUILDBANK_COUNT) {\n', '            didPass = false;\n', '        }\n', '\n', '        // PROPOSAL PASSED\n', '        if (didPass) {\n', '            proposal.flags[2] = 1; // didPass\n', '\n', '            growGuild(proposal.applicant, proposal.sharesRequested, proposal.lootRequested);\n', '\n', '            // if the proposal tribute is the first token of its kind to make it into the guild bank, increment total guild bank tokens\n', '            if (userTokenBalances[GUILD][proposal.tributeToken] == 0 && proposal.tributeOffered > 0) {\n', '                totalGuildBankTokens += 1;\n', '            }\n', '\n', '            unsafeInternalTransfer(ESCROW, GUILD, proposal.tributeToken, proposal.tributeOffered);\n', '            unsafeInternalTransfer(GUILD, proposal.applicant, proposal.paymentToken, proposal.paymentRequested);\n', '\n', '            // if the proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens\n', '            if (userTokenBalances[GUILD][proposal.paymentToken] == 0 && proposal.paymentRequested > 0) {\n', '                totalGuildBankTokens -= 1;\n', '            }\n', '\n', '        // PROPOSAL FAILED\n', '        } else {\n', '            // return all tokens to the proposer (not the applicant, because funds come from proposer)\n', '            unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\n', '        }\n', '\n', '        _returnDeposit(proposal.sponsor);\n', '        \n', '        emit ProcessProposal(proposalIndex, proposalId, didPass);\n', '    }\n', '    \n', '     function processActionProposal(uint256 proposalIndex) external nonReentrant returns (bool, bytes memory) {\n', '        _validateProposalForProcessing(proposalIndex);\n', '        uint256 proposalId = proposalQueue[proposalIndex];\n', '        bytes storage action = actions[proposalId];\n', '        Proposal storage proposal = proposals[proposalId];\n', '        require(proposal.flags[6] == 1, "!action");\n', '        proposal.flags[1] = 1; // processed\n', '\n', '        bool didPass = _didPass(proposalIndex);\n', '        // Make the proposal fail if it is requesting more accounted tokens than the available guild bank balance\n', '        if (tokenWhitelist[proposal.applicant] && proposal.paymentRequested > userTokenBalances[GUILD][proposal.applicant]) {\n', '            didPass = false;\n', '        }\n', '        \n', '        // Make the proposal fail if it is requesting more ether than the available local balance\n', '        if (proposal.tributeOffered > address(this).balance) {\n', '            didPass = false;\n', '        }\n', '\n', '        if (didPass) {\n', '            proposal.flags[2] = 1; // didPass\n', '            (bool success, bytes memory returnData) = proposal.applicant.call{value: proposal.tributeOffered}(action);\n', '            if (tokenWhitelist[proposal.applicant]) {\n', '                unsafeSubtractFromBalance(GUILD, proposal.applicant, proposal.paymentRequested);\n', '                // if the action proposal spends 100% of guild bank balance for a token, decrement total guild bank tokens\n', '                if (userTokenBalances[GUILD][proposal.applicant] == 0 && proposal.paymentRequested > 0) {totalGuildBankTokens -= 1;}\n', '            }\n', '            return (success, returnData);\n', '        }\n', '        \n', '        _returnDeposit(proposal.sponsor);\n', '        \n', '        emit ProcessActionProposal(proposalIndex, proposalId, didPass);\n', '    }\n', '\n', '    function processGuildKickProposal(uint256 proposalIndex) external nonReentrant {\n', '        _validateProposalForProcessing(proposalIndex);\n', '        uint256 proposalId = proposalQueue[proposalIndex];\n', '        Proposal storage proposal = proposals[proposalId];\n', '        require(proposal.flags[5] == 1, "!kick");\n', '        proposal.flags[1] = 1; // processed\n', '\n', '        bool didPass = _didPass(proposalIndex);\n', '        if (didPass) {\n', '            proposal.flags[2] = 1; // didPass\n', '            Member storage member = members[proposal.applicant];\n', '            member.jailed = proposalIndex;\n', '            // transfer shares to loot\n', '            member.loot = member.loot.add(member.shares);\n', '            totalShares = totalShares.sub(member.shares);\n', '            totalLoot = totalLoot.add(member.shares);\n', '            member.shares = 0; // revoke all shares\n', '        }\n', '\n', '        proposedToKick[proposal.applicant] = false;\n', '\n', '        _returnDeposit(proposal.sponsor);\n', '        \n', '        emit ProcessGuildKickProposal(proposalIndex, proposalId, didPass);\n', '    }\n', '    \n', '    function processWhitelistProposal(uint256 proposalIndex) external nonReentrant {\n', '        _validateProposalForProcessing(proposalIndex);\n', '        uint256 proposalId = proposalQueue[proposalIndex];\n', '        Proposal storage proposal = proposals[proposalId];\n', '        require(proposal.flags[4] == 1, "!whitelist");\n', '        proposal.flags[1] = 1; // processed\n', '\n', '        bool didPass = _didPass(proposalIndex);\n', '        if (approvedTokens.length >= MAX_TOKEN_WHITELIST_COUNT) {\n', '            didPass = false;\n', '        }\n', '\n', '        if (didPass) {\n', '            proposal.flags[2] = 1; // didPass\n', '            tokenWhitelist[address(proposal.tributeToken)] = true;\n', '            approvedTokens.push(proposal.tributeToken);\n', '        }\n', '\n', '        proposedToWhitelist[address(proposal.tributeToken)] = false;\n', '\n', '        _returnDeposit(proposal.sponsor);\n', '        \n', '        emit ProcessWhitelistProposal(proposalIndex, proposalId, didPass);\n', '    }\n', '    \n', '    function _didPass(uint256 proposalIndex) internal view returns (bool didPass) {\n', '        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\n', '        \n', '        if (proposal.yesVotes > proposal.noVotes) {\n', '            didPass = true;\n', '        }\n', '        \n', '        // Make the proposal fail if the dilutionBound is exceeded\n', '        if ((totalSupply.mul(dilutionBound)) < proposal.maxTotalSharesAndLootAtYesVote) {\n', '            didPass = false;\n', '        }\n', '\n', '        // Make the proposal fail if the applicant is jailed\n', "        // - for standard proposals, we don't want the applicant to get any shares/loot/payment\n", "        // - for guild kick proposals, we should never be able to propose to kick a jailed member (or have two kick proposals active), so it doesn't matter\n", '        if (members[proposal.applicant].jailed != 0) {\n', '            didPass = false;\n', '        }\n', '\n', '        return didPass;\n', '    }\n', '\n', '    function _validateProposalForProcessing(uint256 proposalIndex) internal view {\n', '        require(proposalIndex < proposalQueue.length, "!proposal");\n', '        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\n', '        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), "!ready");\n', '        require(proposal.flags[1] == 0, "processed");\n', '        require(proposalIndex == 0 || proposals[proposalQueue[proposalIndex - 1]].flags[1] == 1, "prior !processed");\n', '    }\n', '\n', '    function _returnDeposit(address sponsor) internal {\n', '        unsafeInternalTransfer(ESCROW, msg.sender, depositToken, processingReward);\n', '        unsafeInternalTransfer(ESCROW, sponsor, depositToken, proposalDeposit - processingReward);\n', '    }\n', '\n', '    function ragequit(uint256 sharesToBurn, uint256 lootToBurn) external nonReentrant {\n', '        require(members[msg.sender].exists == 1, "!member");\n', '        _ragequit(msg.sender, sharesToBurn, lootToBurn);\n', '    }\n', '\n', '    function _ragequit(address memberAddress, uint256 sharesToBurn, uint256 lootToBurn) internal {\n', '        uint256 initialTotalSharesAndLoot = totalSupply;\n', '        Member storage member = members[memberAddress];\n', '        require(member.shares >= sharesToBurn, "!shares");\n', '        require(member.loot >= lootToBurn, "!loot");\n', '        require(canRagequit(member.highestIndexYesVote), "!ragequit until highest index proposal member voted YES processes");\n', '        uint256 sharesAndLootToBurn = sharesToBurn.add(lootToBurn);\n', '\n', '        // burn guild token, shares & loot\n', '        balanceOf[memberAddress] = balanceOf[memberAddress].sub(sharesAndLootToBurn);\n', '        member.shares = member.shares.sub(sharesToBurn);\n', '        member.loot = member.loot.sub(lootToBurn);\n', '        totalShares = totalShares.sub(sharesToBurn);\n', '        totalLoot = totalLoot.sub(lootToBurn);\n', '        totalSupply = totalShares.add(totalLoot);\n', '\n', '        for (uint256 i = 0; i < approvedTokens.length; i++) {\n', '            uint256 amountToRagequit = fairShare(userTokenBalances[GUILD][approvedTokens[i]], sharesAndLootToBurn, initialTotalSharesAndLoot);\n', '            if (amountToRagequit > 0) { // gas optimization to allow a higher maximum token limit\n', '                // deliberately not using safemath here to keep overflows from preventing the function execution (which would break ragekicks)\n', "                // if a token overflows, it is because the supply was artificially inflated to oblivion, so we probably don't care about it anyways\n", '                userTokenBalances[GUILD][approvedTokens[i]] -= amountToRagequit;\n', '                userTokenBalances[memberAddress][approvedTokens[i]] += amountToRagequit;\n', '            }\n', '        }\n', '\n', '        emit Ragequit(memberAddress, sharesToBurn, lootToBurn);\n', '        emit Transfer(memberAddress, address(0), sharesAndLootToBurn);\n', '    }\n', '\n', '    function ragekick(address memberToKick) external nonReentrant onlyDelegate {\n', '        Member storage member = members[memberToKick];\n', '        require(member.jailed != 0, "!jailed");\n', '        require(member.loot > 0, "!loot"); // note - should be impossible for jailed member to have shares\n', '        require(canRagequit(member.highestIndexYesVote), "!ragequit until highest index proposal member voted YES processes");\n', '        _ragequit(memberToKick, 0, member.loot);\n', '    }\n', '    \n', '    function withdrawBalance(address token, uint256 amount) external nonReentrant {\n', '        _withdrawBalance(token, amount);\n', '    }\n', '\n', '    function withdrawBalances(address[] calldata tokens, uint256[] calldata amounts, bool max) external nonReentrant {\n', '        require(tokens.length == amounts.length, "tokens != amounts");\n', '        for (uint256 i=0; i < tokens.length; i++) {\n', '            uint256 withdrawAmount = amounts[i];\n', '            if (max) { // withdraw the maximum balance\n', '                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\n', '            }\n', '            _withdrawBalance(tokens[i], withdrawAmount);\n', '        }\n', '    }\n', '    \n', '    function _withdrawBalance(address token, uint256 amount) internal {\n', '        require(userTokenBalances[msg.sender][token] >= amount, "!balance");\n', '        IERC20(token).safeTransfer(msg.sender, amount);\n', '        unsafeSubtractFromBalance(msg.sender, token, amount);\n', '        emit Withdraw(msg.sender, token, amount);\n', '    }\n', '\n', '    function collectTokens(address token) external nonReentrant onlyDelegate {\n', '        uint256 amountToCollect = IERC20(token).balanceOf(address(this)).sub(userTokenBalances[TOTAL][token]);\n', '        // only collect if 1) there are tokens to collect & 2) token is whitelisted\n', '        require(amountToCollect > 0, "!amount");\n', '        require(tokenWhitelist[token], "!whitelisted");\n', '        \n', '        if (userTokenBalances[GUILD][token] == 0 && totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT) {totalGuildBankTokens += 1;}\n', '        unsafeAddToBalance(GUILD, token, amountToCollect);\n', '\n', '        emit TokensCollected(token, amountToCollect);\n', '    }\n', '\n', '    // NOTE: requires that delegate key which sent the original proposal cancels, msg.sender = proposal.proposer\n', '    function cancelProposal(uint256 proposalId) external nonReentrant {\n', '        Proposal storage proposal = proposals[proposalId];\n', '        require(proposal.flags[0] == 0, "sponsored");\n', '        require(proposal.flags[3] == 0, "cancelled");\n', '        require(msg.sender == proposal.proposer, "!proposer");\n', '        proposal.flags[3] = 1; // cancelled\n', '       \n', '        unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);\n', '        \n', '        emit CancelProposal(proposalId, msg.sender);\n', '    }\n', '\n', '    function updateDelegateKey(address newDelegateKey) external nonReentrant {\n', '        require(members[msg.sender].shares > 0, "!shareholder");\n', '        require(newDelegateKey != address(0), "newDelegateKey = 0");\n', '\n', '        // skip checks if member is setting the delegate key to their member address\n', '        if (newDelegateKey != msg.sender) {\n', '            require(members[newDelegateKey].exists == 0, "!overwrite members");\n', '            require(members[memberAddressByDelegateKey[newDelegateKey]].exists == 0, "!overwrite keys");\n', '        }\n', '\n', '        Member storage member = members[msg.sender];\n', '        memberAddressByDelegateKey[member.delegateKey] = address(0);\n', '        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\n', '        member.delegateKey = newDelegateKey;\n', '\n', '        emit UpdateDelegateKey(msg.sender, newDelegateKey);\n', '    }\n', '    \n', '    // can only ragequit if the latest proposal you voted YES on has been processed\n', '    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\n', '        require(highestIndexYesVote < proposalQueue.length, "!proposal");\n', '        return proposals[proposalQueue[highestIndexYesVote]].flags[1] == 1;\n', '    }\n', '\n', '    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\n', '        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\n', '    }\n', '    \n', '    /***************\n', '    GETTER FUNCTIONS\n', '    ***************/\n', '    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        return x >= y ? x : y;\n', '    }\n', '    \n', '    function getCurrentPeriod() public view returns (uint256) {\n', '        return now.sub(summoningTime).div(periodDuration);\n', '    }\n', '    \n', '    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) external view returns (Vote) {\n', '        require(members[memberAddress].exists == 1, "!member");\n', '        require(proposalIndex < proposalQueue.length, "!proposed");\n', '        return proposals[proposalQueue[proposalIndex]].votesByMember[memberAddress];\n', '    }\n', '\n', '    function getProposalFlags(uint256 proposalId) external view returns (uint8[8] memory) {\n', '        return proposals[proposalId].flags;\n', '    }\n', '    \n', '    function getProposalQueueLength() external view returns (uint256) {\n', '        return proposalQueue.length;\n', '    }\n', '    \n', '    function getTokenCount() external view returns (uint256) {\n', '        return approvedTokens.length;\n', '    }\n', '\n', '    function getUserTokenBalance(address user, address token) external view returns (uint256) {\n', '        return userTokenBalances[user][token];\n', '    }\n', '    \n', '    /***************\n', '    HELPER FUNCTIONS\n', '    ***************/\n', '    receive() external payable {}\n', '    \n', '    function fairShare(uint256 balance, uint256 shares, uint256 totalSharesAndLoot) internal pure returns (uint256) {\n', '        require(totalSharesAndLoot != 0);\n', '\n', '        if (balance == 0) { return 0; }\n', '\n', '        uint256 prod = balance * shares;\n', '\n', '        if (prod / balance == shares) { // no overflow in multiplication above?\n', '            return prod / totalSharesAndLoot;\n', '        }\n', '\n', '        return (balance / totalSharesAndLoot) * shares;\n', '    }\n', '    \n', '    function growGuild(address account, uint256 shares, uint256 loot) internal {\n', '        // if the account is already a member, add to their existing shares & loot\n', '        if (members[account].exists == 1) {\n', '            members[account].shares = members[account].shares.add(shares);\n', '            members[account].loot = members[account].loot.add(loot);\n', '\n', '        // if the account is a new member, create a new record for them\n', '        } else {\n', "            // if new member is already taken by a member's delegateKey, reset it to their member address\n", '            if (members[memberAddressByDelegateKey[account]].exists == 1) {\n', '                address memberToOverride = memberAddressByDelegateKey[account];\n', '                memberAddressByDelegateKey[memberToOverride] = memberToOverride;\n', '                members[memberToOverride].delegateKey = memberToOverride;\n', '            }\n', '        \n', '            members[account] = Member({\n', '                delegateKey : account,\n', "                exists : 1, // 'true'\n", '                shares : shares,\n', '                loot : loot.add(members[account].loot), // take into account loot from pre-membership transfers\n', '                highestIndexYesVote : 0,\n', '                jailed : 0\n', '            });\n', '            memberAddressByDelegateKey[account] = account;\n', '        }\n', '        \n', '        uint256 sharesAndLoot = shares.add(loot);\n', '        // mint new guild token, update total shares & loot \n', '        balanceOf[account] = balanceOf[account].add(sharesAndLoot);\n', '        totalShares = totalShares.add(shares);\n', '        totalLoot = totalLoot.add(loot);\n', '        totalSupply = totalShares.add(totalLoot);\n', '        \n', '        emit Transfer(address(0), account, sharesAndLoot);\n', '    }\n', '    \n', '    function unsafeAddToBalance(address user, address token, uint256 amount) internal {\n', '        userTokenBalances[user][token] += amount;\n', '        userTokenBalances[TOTAL][token] += amount;\n', '    }\n', '    \n', '    function unsafeInternalTransfer(address from, address to, address token, uint256 amount) internal {\n', '        unsafeSubtractFromBalance(from, token, amount);\n', '        unsafeAddToBalance(to, token, amount);\n', '    }\n', '\n', '    function unsafeSubtractFromBalance(address user, address token, uint256 amount) internal {\n', '        userTokenBalances[user][token] -= amount;\n', '        userTokenBalances[TOTAL][token] -= amount;\n', '    }\n', '    \n', '    /********************\n', '    GUILD TOKEN FUNCTIONS\n', '    ********************/\n', '    function approve(address spender, uint256 amount) external returns (bool) {\n', '        require(amount == 0 || allowance[msg.sender][spender] == 0);\n', '        allowance[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function convertSharesToLoot(uint256 sharesToLoot) external nonReentrant {\n', '        members[msg.sender].shares = members[msg.sender].shares.sub(sharesToLoot);\n', '        members[msg.sender].loot = members[msg.sender].loot.add(sharesToLoot);\n', '        totalShares = totalShares.sub(sharesToLoot);\n', '        totalLoot = totalLoot.add(sharesToLoot);\n', '        emit ConvertSharesToLoot(msg.sender, sharesToLoot);\n', '    }\n', '    \n', '    function stakeTokenForShares(uint256 amount) external nonReentrant {\n', '        IERC20(stakeToken).safeTransferFrom(msg.sender, address(this), amount); // deposit stake token & claim shares (1:1)\n', '        growGuild(msg.sender, amount, 0);\n', '        require(totalSupply <= MAX_GUILD_BOUND, "guild maxed");\n', '        emit StakeTokenForShares(msg.sender, amount);\n', '    }\n', '\n', '    function transfer(address recipient, uint256 lootToTransfer) external returns (bool) {\n', '        members[msg.sender].loot = members[msg.sender].loot.sub(lootToTransfer);\n', '        members[recipient].loot = members[recipient].loot.add(lootToTransfer);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(lootToTransfer);\n', '        balanceOf[recipient] = balanceOf[recipient].add(lootToTransfer);\n', '        emit Transfer(msg.sender, recipient, lootToTransfer);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address sender, address recipient, uint256 lootToTransfer) external returns (bool) {\n', '        allowance[sender][msg.sender] = allowance[sender][msg.sender].sub(lootToTransfer);\n', '        members[sender].loot = members[sender].loot.sub(lootToTransfer);\n', '        members[recipient].loot = members[recipient].loot.add(lootToTransfer);\n', '        balanceOf[sender] = balanceOf[sender].sub(lootToTransfer);\n', '        balanceOf[recipient] = balanceOf[recipient].add(lootToTransfer);\n', '        emit Transfer(sender, recipient, lootToTransfer);\n', '        return true;\n', '    }\n', '}']