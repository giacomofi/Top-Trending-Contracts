['pragma solidity 0.5.11; // optimization runs: 200, evm version: petersburg\n', '\n', '\n', '/**\n', ' * @title DTokenInterface\n', ' * @author 0age\n', ' * @notice Interface for dTokens (in addition to the standard ERC20 interface).\n', ' */\n', 'interface DTokenInterface {\n', "  // Events bear similarity to Compound's supply-related events.\n", '  event Mint(address minter, uint256 mintAmount, uint256 mintDTokens);\n', '  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemDTokens);\n', '  event Accrue(uint256 dTokenExchangeRate, uint256 cTokenExchangeRate);\n', '  event CollectSurplus(uint256 surplusAmount, uint256 surplusCTokens);\n', '\n', '  // The block number and cToken + dToken exchange rates are updated on accrual.\n', '  struct AccrualIndex {\n', '    uint112 dTokenExchangeRate;\n', '    uint112 cTokenExchangeRate;\n', '    uint32 block;\n', '  }\n', '\n', '  // These external functions trigger accrual on the dToken and backing cToken.\n', '  function mint(uint256 underlyingToSupply) external returns (uint256 dTokensMinted);\n', '  function redeem(uint256 dTokensToBurn) external returns (uint256 underlyingReceived);\n', '  function redeemUnderlying(uint256 underelyingToReceive) external returns (uint256 dTokensBurned);\n', '  function pullSurplus() external returns (uint256 cTokenSurplus);\n', '\n', '  // These external functions only trigger accrual on the dToken.\n', '  function mintViaCToken(uint256 cTokensToSupply) external returns (uint256 dTokensMinted);\n', '  function redeemToCToken(uint256 dTokensToBurn) external returns (uint256 cTokensReceived);\n', '  function redeemUnderlyingToCToken(uint256 underlyingToReceive) external returns (uint256 dTokensBurned);\n', '  function accrueInterest() external;\n', '  function transferUnderlying(\n', '    address recipient, uint256 underlyingEquivalentAmount\n', '  ) external returns (bool success);\n', '  function transferUnderlyingFrom(\n', '    address sender, address recipient, uint256 underlyingEquivalentAmount\n', '  ) external returns (bool success);\n', '\n', '  // This function provides basic meta-tx support and does not trigger accrual.\n', '  function modifyAllowanceViaMetaTransaction(\n', '    address owner,\n', '    address spender,\n', '    uint256 value,\n', '    bool increase,\n', '    uint256 expiration,\n', '    bytes32 salt,\n', '    bytes calldata signatures\n', '  ) external returns (bool success);\n', '\n', '  // View and pure functions do not trigger accrual on the dToken or the cToken.\n', '  function getMetaTransactionMessageHash(\n', '    bytes4 functionSelector, bytes calldata arguments, uint256 expiration, bytes32 salt\n', '  ) external view returns (bytes32 digest, bool valid);\n', '  function totalSupplyUnderlying() external view returns (uint256);\n', '  function balanceOfUnderlying(address account) external view returns (uint256 underlyingBalance);\n', '  function exchangeRateCurrent() external view returns (uint256 dTokenExchangeRate);\n', '  function supplyRatePerBlock() external view returns (uint256 dTokenInterestRate);\n', '  function accrualBlockNumber() external view returns (uint256 blockNumber);\n', '  function getSurplus() external view returns (uint256 cTokenSurplus);\n', '  function getSurplusUnderlying() external view returns (uint256 underlyingSurplus);\n', '  function getSpreadPerBlock() external view returns (uint256 rateSpread);\n', '  function getVersion() external pure returns (uint256 version);\n', '  function getCToken() external pure returns (address cToken);\n', '  function getUnderlying() external pure returns (address underlying);\n', '}\n', '\n', '\n', 'interface ERC20Interface {\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '  function approve(address spender, uint256 amount) external returns (bool);\n', '  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address account) external view returns (uint256);\n', '}\n', '\n', '\n', 'interface ERC1271Interface {\n', '  function isValidSignature(\n', '    bytes calldata data, bytes calldata signature\n', '  ) external view returns (bytes4 magicValue);\n', '}\n', '\n', '\n', 'interface CTokenInterface {\n', '  function mint(uint256 mintAmount) external returns (uint256 err);\n', '  function redeem(uint256 redeemAmount) external returns (uint256 err);\n', '  function redeemUnderlying(uint256 redeemAmount) external returns (uint256 err);\n', '  function accrueInterest() external returns (uint256 err);\n', '  function transfer(address recipient, uint256 value) external returns (bool);\n', '  function transferFrom(address sender, address recipient, uint256 value) external returns (bool);\n', '  function approve(address spender, uint256 amount) external returns (bool);\n', '  function balanceOfUnderlying(address account) external returns (uint256 balance);\n', '  function exchangeRateCurrent() external returns (uint256 exchangeRate);\n', '\n', '  function getCash() external view returns (uint256);\n', '  function totalSupply() external view returns (uint256 supply);\n', '  function totalBorrows() external view returns (uint256 borrows);\n', '  function totalReserves() external view returns (uint256 reserves);\n', '  function interestRateModel() external view returns (address model);\n', '  function reserveFactorMantissa() external view returns (uint256 factor);\n', '  function supplyRatePerBlock() external view returns (uint256 rate);\n', '  function exchangeRateStored() external view returns (uint256 rate);\n', '  function accrualBlockNumber() external view returns (uint256 blockNumber);\n', '  function balanceOf(address account) external view returns (uint256 balance);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '}\n', '\n', '\n', 'interface CUSDCInterestRateModelInterface {\n', '  function getBorrowRate(\n', '    uint256 cash, uint256 borrows, uint256 reserves\n', '  ) external view returns (uint256 err, uint256 borrowRate);\n', '}\n', '\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title DharmaTokenOverrides\n', ' * @author 0age\n', ' * @notice A collection of internal view and pure functions that should be\n', ' * overridden by the ultimate Dharma Token implementation.\n', ' */\n', 'contract DharmaTokenOverrides {\n', '  /**\n', '   * @notice Internal view function to get the current cToken exchange rate and\n', '   * supply rate per block. This function is meant to be overridden by the\n', '   * dToken that inherits this contract.\n', '   * @return The current cToken exchange rate, or amount of underlying tokens\n', '   * that are redeemable for each cToken, and the cToken supply rate per block\n', '   * (with 18 decimal places added to each returned rate).\n', '   */\n', '  function _getCurrentCTokenRates() internal view returns (\n', '    uint256 exchangeRate, uint256 supplyRate\n', '  );\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the name of the underlying token.\n', '   * @return The name of the underlying token.\n', '   */\n', '  function _getUnderlyingName() internal pure returns (string memory underlyingName);\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the address of the underlying\n', '   * token.\n', '   * @return The address of the underlying token.\n', '   */\n', '  function _getUnderlying() internal pure returns (address underlying);\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the symbol of the backing cToken.\n', '   * @return The symbol of the backing cToken.\n', '   */\n', '  function _getCTokenSymbol() internal pure returns (string memory cTokenSymbol);\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the address of the backing cToken.\n', '   * @return The address of the backing cToken.\n', '   */\n', '  function _getCToken() internal pure returns (address cToken);\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the name of the dToken.\n', '   * @return The name of the dToken.\n', '   */\n', '  function _getDTokenName() internal pure returns (string memory dTokenName);\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the symbol of the dToken.\n', '   * @return The symbol of the dToken.\n', '   */\n', '  function _getDTokenSymbol() internal pure returns (string memory dTokenSymbol);\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the address of the vault that\n', '   * receives surplus cTokens whenever the surplus is pulled.\n', '   * @return The address of the vault.\n', '   */\n', '  function _getVault() internal pure returns (address vault);\n', '}\n', '\n', '\n', '/**\n', ' * @title DharmaTokenHelpers\n', ' * @author 0age\n', ' * @notice A collection of constants and internal pure functions used by Dharma\n', ' * Tokens.\n', ' */\n', 'contract DharmaTokenHelpers is DharmaTokenOverrides {\n', '  using SafeMath for uint256;\n', '\n', '  uint8 internal constant _DECIMALS = 8; // matches cToken decimals\n', '  uint256 internal constant _SCALING_FACTOR = 1e18;\n', '  uint256 internal constant _SCALING_FACTOR_MINUS_ONE = 999999999999999999;\n', '  uint256 internal constant _HALF_OF_SCALING_FACTOR = 5e17;\n', '  uint256 internal constant _COMPOUND_SUCCESS = 0;\n', '  uint256 internal constant _MAX_UINT_112 = 5192296858534827628530496329220095;\n', '  /* solhint-disable separate-by-one-line-in-contract */\n', '  uint256 internal constant _MAX_UNMALLEABLE_S = (\n', '    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n', '  );\n', '  /* solhint-enable separate-by-one-line-in-contract */\n', '\n', '  /**\n', '   * @notice Internal pure function to determine if a call to Compound succeeded\n', '   * and to revert, supplying the reason, if it failed. Failure can be caused by\n', '   * a call that reverts, or by a call that does not revert but returns a\n', '   * non-zero error code.\n', '   * @param functionSelector bytes4 The function selector that was called.\n', '   * @param ok bool A boolean representing whether the call returned or\n', '   * reverted.\n', '   * @param data bytes The data provided by the returned or reverted call.\n', '   */\n', '  function _checkCompoundInteraction(\n', '    bytes4 functionSelector, bool ok, bytes memory data\n', '  ) internal pure {\n', '    CTokenInterface cToken;\n', '    if (ok) {\n', '      if (\n', '        functionSelector == cToken.transfer.selector ||\n', '        functionSelector == cToken.transferFrom.selector\n', '      ) {\n', '        require(\n', '          abi.decode(data, (bool)), string(\n', '            abi.encodePacked(\n', '              "Compound ",\n', '              _getCTokenSymbol(),\n', '              " contract returned false on calling ",\n', '              _getFunctionName(functionSelector),\n', '              "."\n', '            )\n', '          )\n', '        );\n', '      } else {\n', '        uint256 compoundError = abi.decode(data, (uint256)); // throw on no data\n', '        if (compoundError != _COMPOUND_SUCCESS) {\n', '          revert(\n', '            string(\n', '              abi.encodePacked(\n', '                "Compound ",\n', '                _getCTokenSymbol(),\n', '                " contract returned error code ",\n', '                uint8((compoundError / 10) + 48),\n', '                uint8((compoundError % 10) + 48),\n', '                " on calling ",\n', '                _getFunctionName(functionSelector),\n', '                "."\n', '              )\n', '            )\n', '          );\n', '        }\n', '      }\n', '    } else {\n', '      revert(\n', '        string(\n', '          abi.encodePacked(\n', '            "Compound ",\n', '            _getCTokenSymbol(),\n', '            " contract reverted while attempting to call ",\n', '            _getFunctionName(functionSelector),\n', '            ": ",\n', '            _decodeRevertReason(data)\n', '          )\n', '        )\n', '      );\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to get a Compound function name based on the\n', '   * selector.\n', '   * @param functionSelector bytes4 The function selector.\n', '   * @return The name of the function as a string.\n', '   */\n', '  function _getFunctionName(\n', '    bytes4 functionSelector\n', '  ) internal pure returns (string memory functionName) {\n', '    CTokenInterface cToken;\n', '    if (functionSelector == cToken.mint.selector) {\n', '      functionName = "mint";\n', '    } else if (functionSelector == cToken.redeem.selector) {\n', '      functionName = "redeem";\n', '    } else if (functionSelector == cToken.redeemUnderlying.selector) {\n', '      functionName = "redeemUnderlying";\n', '    } else if (functionSelector == cToken.transferFrom.selector) {\n', '      functionName = "transferFrom";\n', '    } else if (functionSelector == cToken.transfer.selector) {\n', '      functionName = "transfer";\n', '    } else if (functionSelector == cToken.accrueInterest.selector) {\n', '      functionName = "accrueInterest";\n', '    } else {\n', '      functionName = "an unknown function";\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to decode revert reasons. The revert reason\n', '   * prefix is removed and the remaining string argument is decoded.\n', '   * @param revertData bytes The raw data supplied alongside the revert.\n', '   * @return The decoded revert reason string.\n', '   */\n', '  function _decodeRevertReason(\n', '    bytes memory revertData\n', '  ) internal pure returns (string memory revertReason) {\n', '    // Solidity prefixes revert reason with 0x08c379a0 -> Error(string) selector\n', '    if (\n', '      revertData.length > 68 && // prefix (4) + position (32) + length (32)\n', '      revertData[0] == byte(0x08) &&\n', '      revertData[1] == byte(0xc3) &&\n', '      revertData[2] == byte(0x79) &&\n', '      revertData[3] == byte(0xa0)\n', '    ) {\n', '      // Get the revert reason without the prefix from the revert data.\n', '      bytes memory revertReasonBytes = new bytes(revertData.length - 4);\n', '      for (uint256 i = 4; i < revertData.length; i++) {\n', '        revertReasonBytes[i - 4] = revertData[i];\n', '      }\n', '\n', '      // Decode the resultant revert reason as a string.\n', '      revertReason = abi.decode(revertReasonBytes, (string));\n', '    } else {\n', '      // Simply return the default, with no revert reason.\n', '      revertReason = "(no revert reason)";\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to construct a failure message string for\n', '   * the revert reason on transfers of underlying tokens that do not succeed.\n', '   * @return The failure message.\n', '   */\n', '  function _getTransferFailureMessage() internal pure returns (\n', '    string memory message\n', '  ) {\n', '    message = string(\n', '      abi.encodePacked(_getUnderlyingName(), " transfer failed.")\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to convert a uint256 to a uint112, reverting\n', '   * if the conversion would cause an overflow.\n', '   * @param input uint256 The unsigned integer to convert.\n', '   * @return The converted unsigned integer.\n', '   */\n', '  function _safeUint112(uint256 input) internal pure returns (uint112 output) {\n', '    require(input <= _MAX_UINT_112, "Overflow on conversion to uint112.");\n', '    output = uint112(input);\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to convert an underlying amount to a dToken\n', '   * or cToken amount using an exchange rate and fixed-point arithmetic.\n', '   * @param underlying uint256 The underlying amount to convert.\n', '   * @param exchangeRate uint256 The exchange rate (multiplied by 10^18).\n', '   * @param roundUp bool Whether the final amount should be rounded up - it will\n', '   * instead be truncated (rounded down) if this value is false.\n', '   * @return The cToken or dToken amount.\n', '   */\n', '  function _fromUnderlying(\n', '    uint256 underlying, uint256 exchangeRate, bool roundUp\n', '  ) internal pure returns (uint256 amount) {\n', '    if (roundUp) {\n', '      amount = (\n', '        (underlying.mul(_SCALING_FACTOR)).add(exchangeRate.sub(1))\n', '      ).div(exchangeRate);\n', '    } else {\n', '      amount = (underlying.mul(_SCALING_FACTOR)).div(exchangeRate);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to convert a dToken or cToken amount to the\n', '   * underlying amount using an exchange rate and fixed-point arithmetic.\n', '   * @param amount uint256 The cToken or dToken amount to convert.\n', '   * @param exchangeRate uint256 The exchange rate (multiplied by 10^18).\n', '   * @param roundUp bool Whether the final amount should be rounded up - it will\n', '   * instead be truncated (rounded down) if this value is false.\n', '   * @return The underlying amount.\n', '   */\n', '  function _toUnderlying(\n', '    uint256 amount, uint256 exchangeRate, bool roundUp\n', '  ) internal pure returns (uint256 underlying) {\n', '    if (roundUp) {\n', '      underlying = (\n', '        (amount.mul(exchangeRate).add(_SCALING_FACTOR_MINUS_ONE)\n', '      ) / _SCALING_FACTOR);\n', '    } else {\n', '      underlying = amount.mul(exchangeRate) / _SCALING_FACTOR;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to convert an underlying amount to a dToken\n', '   * or cToken amount and back to the underlying, so as to properly capture\n', '   * rounding errors, by using an exchange rate and fixed-point arithmetic.\n', '   * @param underlying uint256 The underlying amount to convert.\n', '   * @param exchangeRate uint256 The exchange rate (multiplied by 10^18).\n', '   * @param roundUpOne bool Whether the intermediate dToken or cToken amount\n', '   * should be rounded up - it will instead be truncated (rounded down) if this\n', '   * value is false.\n', '   * @param roundUpTwo bool Whether the final underlying amount should be\n', '   * rounded up - it will instead be truncated (rounded down) if this value is\n', '   * false.\n', '   * @return The intermediate cToken or dToken amount and the final underlying\n', '   * amount.\n', '   */\n', '  function _fromUnderlyingAndBack(\n', '    uint256 underlying, uint256 exchangeRate, bool roundUpOne, bool roundUpTwo\n', '  ) internal pure returns (uint256 amount, uint256 adjustedUnderlying) {\n', '    amount = _fromUnderlying(underlying, exchangeRate, roundUpOne);\n', '    adjustedUnderlying = _toUnderlying(amount, exchangeRate, roundUpTwo);\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title DharmaTokenV2\n', ' * @author 0age (dToken mechanics derived from Compound cTokens, ERC20 mechanics\n', " * derived from Open Zeppelin's ERC20 contract)\n", ' * @notice DharmaTokenV2 deprecates the interest-bearing component and prevents\n', ' * minting of new tokens or redeeming to cTokens. It also returns COMP in\n', ' * proportion to the respective dToken balance in relation to total supply.\n', ' */\n', 'contract DharmaTokenV2 is ERC20Interface, DTokenInterface, DharmaTokenHelpers {\n', '  // Set the version of the Dharma Token as a constant.\n', '  uint256 private constant _DTOKEN_VERSION = 2;\n', '\n', '  ERC20Interface internal constant _COMP = ERC20Interface(\n', '    0xc00e94Cb662C3520282E6f5717214004A7f26888 // mainnet\n', '  );\n', '\n', '  // Set block number and dToken + cToken exchange rate in slot zero on accrual.\n', '  AccrualIndex private _accrualIndex;\n', '\n', '  // Slot one tracks the total issued dTokens.\n', '  uint256 private _totalSupply;\n', '\n', '  // Slots two and three are entrypoints into balance and allowance mappings.\n', '  mapping (address => uint256) private _balances;\n', '  mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '  // Slot four is an entrypoint into a mapping for used meta-transaction hashes.\n', '  mapping (bytes32 => bool) private _executedMetaTxs;\n', '  \n', '  bool exchangeRateFrozen; // initially false\n', '\n', '  /**\n', '   * @notice Deprecated.\n', '   */\n', '  function mint(\n', '    uint256 underlyingToSupply\n', '  ) external returns (uint256 dTokensMinted) {\n', '    revert("Minting is no longer supported.");\n', '  }\n', '\n', '  /**\n', '   * @notice Deprecated.\n', '   */\n', '  function mintViaCToken(\n', '    uint256 cTokensToSupply\n', '  ) external returns (uint256 dTokensMinted) {\n', '    revert("Minting is no longer supported.");\n', '  }\n', '\n', '  /**\n', '   * @notice Redeem `dTokensToBurn` dTokens from `msg.sender`, use the\n', '   * corresponding cTokens to redeem the required underlying, and transfer the\n', '   * redeemed underlying tokens to `msg.sender`.\n', '   * @param dTokensToBurn uint256 The amount of dTokens to provide in exchange\n', '   * for underlying tokens.\n', '   * @return The amount of underlying received in return for the provided\n', '   * dTokens.\n', '   */\n', '  function redeem(\n', '    uint256 dTokensToBurn\n', '  ) external returns (uint256 underlyingReceived) {\n', '    require(exchangeRateFrozen, "Call `pullSurplus()` to freeze exchange rate first.");\n', '\n', '    // Instantiate interface for the underlying token.\n', '    ERC20Interface underlying = ERC20Interface(_getUnderlying());\n', '\n', '    require(dTokensToBurn > 0, "No funds specified to redeem.");\n', '    \n', '    // Get the total supply, as well as current underlying and COMP balances.\n', '    uint256 originalSupply = _totalSupply;\n', '    uint256 underlyingBalance = underlying.balanceOf(address(this));\n', '    uint256 compBalance = _COMP.balanceOf(address(this));\n', '\n', '     // Apply dToken ratio to balances to determine amount to transfer out.\n', '    underlyingReceived = underlyingBalance.mul(dTokensToBurn) / originalSupply;\n', '    uint256 compReceived = compBalance.mul(dTokensToBurn) / originalSupply;\n', '    require(\n', '      underlyingReceived.add(compReceived) > 0,\n', '      "Supplied dTokens are insufficient to redeem."\n', '    );\n', '    \n', '    // Burn the dTokens.\n', '    _burn(msg.sender, underlyingReceived, dTokensToBurn);\n', '    \n', '    // Transfer out the proportion of each associated with the burned tokens.\n', '    if (underlyingReceived > 0) {\n', '      require(\n', '        underlying.transfer(msg.sender, underlyingReceived),\n', '        _getTransferFailureMessage()\n', '      );\n', '    }\n', '\n', '    if (compReceived > 0) {\n', '      require(\n', '        _COMP.transfer(msg.sender, compReceived),\n', '        "COMP transfer out failed."\n', '      );\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Deprecated.\n', '   */\n', '  function redeemToCToken(\n', '    uint256 dTokensToBurn\n', '  ) external returns (uint256 cTokensReceived) {\n', '    revert("Redeeming to cTokens is no longer supported.");\n', '  }\n', '\n', '  /**\n', '   * @notice Redeem the dToken equivalent value of the underlying token amount\n', '   * `underlyingToReceive` from `msg.sender`, use the corresponding cTokens to\n', '   * redeem the underlying, and transfer the underlying to `msg.sender`.\n', '   * @param underlyingToReceive uint256 The amount, denominated in the\n', '   * underlying token, of the cToken to redeem in exchange for the received\n', '   * underlying token.\n', '   * @return The amount of dTokens burned in exchange for the returned\n', '   * underlying tokens.\n', '   */\n', '  function redeemUnderlying(\n', '    uint256 underlyingToReceive\n', '  ) external returns (uint256 dTokensBurned) {\n', '    require(exchangeRateFrozen, "Call `pullSurplus()` to freeze exchange rate first.");\n', '\n', '    // Instantiate interface for the underlying token.\n', '    ERC20Interface underlying = ERC20Interface(_getUnderlying());\n', '\n', '    // Get the dToken exchange rate.\n', '    (uint256 dTokenExchangeRate, ) = _accrue(false);\n', '\n', '    // Determine dToken amount to burn using the exchange rate, rounded up.\n', '    dTokensBurned = _fromUnderlying(\n', '      underlyingToReceive, dTokenExchangeRate, true\n', '    );\n', '\n', '    // Determine dToken amount for returning COMP by rounding down.\n', '    uint256 dTokensForCOMP = _fromUnderlying(\n', '      underlyingToReceive, dTokenExchangeRate, false\n', '    );\n', '    \n', '    // Get the total supply and current COMP balance.\n', '    uint256 originalSupply = _totalSupply;\n', '    uint256 compBalance = _COMP.balanceOf(address(this));\n', '\n', '     // Apply dToken ratio to COMP balance to determine amount to transfer out.\n', '    uint256 compReceived = compBalance.mul(dTokensForCOMP) / originalSupply;\n', '    require(\n', '      underlyingToReceive.add(compReceived) > 0,\n', '      "Supplied amount is insufficient to redeem."\n', '    );\n', '    \n', '    // Burn the dTokens.\n', '    _burn(msg.sender, underlyingToReceive, dTokensBurned);\n', '    \n', '    // Transfer out the proportion of each associated with the burned tokens.\n', '    if (underlyingToReceive > 0) {\n', '      require(\n', '        underlying.transfer(msg.sender, underlyingToReceive),\n', '        _getTransferFailureMessage()\n', '      );\n', '    }\n', '\n', '    if (compReceived > 0) {\n', '      require(\n', '        _COMP.transfer(msg.sender, compReceived),\n', '        "COMP transfer out failed."\n', '      );\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Deprecated.\n', '   */\n', '  function redeemUnderlyingToCToken(\n', '    uint256 underlyingToReceive\n', '  ) external returns (uint256 dTokensBurned) {\n', '    revert("Redeeming to cTokens is no longer supported.");\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer cTokens with underlying value in excess of the total\n', '   * underlying dToken value to a dedicated "vault" account. A "hard" accrual\n', '   * will first be performed, triggering an accrual on both the cToken and the\n', '   * dToken.\n', '   * @return The amount of cTokens transferred to the vault account.\n', '   */\n', '  function pullSurplus() external returns (uint256 cTokenSurplus) {\n', '    require(!exchangeRateFrozen, "No surplus left to pull.");\n', '\n', '    // Instantiate the interface for the backing cToken.\n', '    CTokenInterface cToken = CTokenInterface(_getCToken());\n', '\n', '    // Accrue interest on the cToken and ensure that the operation succeeds.\n', '    (bool ok, bytes memory data) = address(cToken).call(abi.encodeWithSelector(\n', '      cToken.accrueInterest.selector\n', '    ));\n', '    _checkCompoundInteraction(cToken.accrueInterest.selector, ok, data);\n', '\n', '    // Accrue interest on the dToken, reusing the stored cToken exchange rate.\n', '    _accrue(false);\n', '\n', '    // Determine cToken surplus in underlying (cToken value - dToken value).\n', '    uint256 underlyingSurplus;\n', '    (underlyingSurplus, cTokenSurplus) = _getSurplus();\n', '\n', '    // Transfer cToken surplus to vault and ensure that the operation succeeds.\n', '    (ok, data) = address(cToken).call(abi.encodeWithSelector(\n', '      cToken.transfer.selector, _getVault(), cTokenSurplus\n', '    ));\n', '    _checkCompoundInteraction(cToken.transfer.selector, ok, data);\n', '\n', '    emit CollectSurplus(underlyingSurplus, cTokenSurplus);\n', '    \n', '    exchangeRateFrozen = true;\n', '    \n', '    // Redeem all cTokens for underlying and ensure that the operation succeeds.\n', '    (ok, data) = address(cToken).call(abi.encodeWithSelector(\n', '      cToken.redeem.selector, cToken.balanceOf(address(this))\n', '    ));\n', '    _checkCompoundInteraction(cToken.redeem.selector, ok, data);\n', '  }\n', '\n', '  /**\n', '   * @notice Deprecated.\n', '   */\n', '  function accrueInterest() external {\n', '    revert("Interest accrual is longer supported.");\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer `amount` dTokens from `msg.sender` to `recipient`.\n', '   * @param recipient address The account to transfer the dTokens to.\n', '   * @param amount uint256 The amount of dTokens to transfer.\n', '   * @return A boolean indicating whether the transfer was successful.\n', '   */\n', '  function transfer(\n', '    address recipient, uint256 amount\n', '  ) external returns (bool success) {\n', '    _transfer(msg.sender, recipient, amount);\n', '    success = true;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer dTokens equivalent to `underlyingEquivalentAmount`\n', '   * underlying from `msg.sender` to `recipient`.\n', '   * @param recipient address The account to transfer the dTokens to.\n', '   * @param underlyingEquivalentAmount uint256 The underlying equivalent amount\n', '   * of dTokens to transfer.\n', '   * @return A boolean indicating whether the transfer was successful.\n', '   */\n', '  function transferUnderlying(\n', '    address recipient, uint256 underlyingEquivalentAmount\n', '  ) external returns (bool success) {\n', '    // Accrue interest and retrieve the current dToken exchange rate.\n', '    (uint256 dTokenExchangeRate, ) = _accrue(true);\n', '\n', '    // Determine dToken amount to transfer using the exchange rate, rounded up.\n', '    uint256 dTokenAmount = _fromUnderlying(\n', '      underlyingEquivalentAmount, dTokenExchangeRate, true\n', '    );\n', '\n', '    // Transfer the dTokens.\n', '    _transfer(msg.sender, recipient, dTokenAmount);\n', '    success = true;\n', '  }\n', '\n', '  /**\n', '   * @notice Approve `spender` to transfer up to `value` dTokens on behalf of\n', '   * `msg.sender`.\n', '   * @param spender address The account to grant the allowance.\n', '   * @param value uint256 The size of the allowance to grant.\n', '   * @return A boolean indicating whether the approval was successful.\n', '   */\n', '  function approve(\n', '    address spender, uint256 value\n', '  ) external returns (bool success) {\n', '    _approve(msg.sender, spender, value);\n', '    success = true;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer `amount` dTokens from `sender` to `recipient` as long as\n', '   * `msg.sender` has sufficient allowance.\n', '   * @param sender address The account to transfer the dTokens from.\n', '   * @param recipient address The account to transfer the dTokens to.\n', '   * @param amount uint256 The amount of dTokens to transfer.\n', '   * @return A boolean indicating whether the transfer was successful.\n', '   */\n', '  function transferFrom(\n', '    address sender, address recipient, uint256 amount\n', '  ) external returns (bool success) {\n', '    _transferFrom(sender, recipient, amount);\n', '    success = true;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer dTokens eqivalent to `underlyingEquivalentAmount`\n', '   * underlying from `sender` to `recipient` as long as `msg.sender` has\n', '   * sufficient allowance.\n', '   * @param sender address The account to transfer the dTokens from.\n', '   * @param recipient address The account to transfer the dTokens to.\n', '   * @param underlyingEquivalentAmount uint256 The underlying equivalent amount\n', '   * of dTokens to transfer.\n', '   * @return A boolean indicating whether the transfer was successful.\n', '   */\n', '  function transferUnderlyingFrom(\n', '    address sender, address recipient, uint256 underlyingEquivalentAmount\n', '  ) external returns (bool success) {\n', '    // Accrue interest and retrieve the current dToken exchange rate.\n', '    (uint256 dTokenExchangeRate, ) = _accrue(true);\n', '\n', '    // Determine dToken amount to transfer using the exchange rate, rounded up.\n', '    uint256 dTokenAmount = _fromUnderlying(\n', '      underlyingEquivalentAmount, dTokenExchangeRate, true\n', '    );\n', '\n', '    // Transfer the dTokens and adjust allowance accordingly.\n', '    _transferFrom(sender, recipient, dTokenAmount);\n', '    success = true;\n', '  }\n', '\n', '  /**\n', '   * @notice Increase the current allowance of `spender` by `value` dTokens.\n', '   * @param spender address The account to grant the additional allowance.\n', '   * @param addedValue uint256 The amount to increase the allowance by.\n', '   * @return A boolean indicating whether the modification was successful.\n', '   */\n', '  function increaseAllowance(\n', '    address spender, uint256 addedValue\n', '  ) external returns (bool success) {\n', '    _approve(\n', '      msg.sender, spender, _allowances[msg.sender][spender].add(addedValue)\n', '    );\n', '    success = true;\n', '  }\n', '\n', '  /**\n', '   * @notice Decrease the current allowance of `spender` by `value` dTokens.\n', '   * @param spender address The account to decrease the allowance for.\n', '   * @param subtractedValue uint256 The amount to subtract from the allowance.\n', '   * @return A boolean indicating whether the modification was successful.\n', '   */\n', '  function decreaseAllowance(\n', '    address spender, uint256 subtractedValue\n', '  ) external returns (bool success) {\n', '    _approve(\n', '      msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue)\n', '    );\n', '    success = true;\n', '  }\n', '\n', '  /**\n', '   * @notice Modify the current allowance of `spender` for `owner` by `value`\n', '   * dTokens, increasing it if `increase` is true otherwise decreasing it, via a\n', '   * meta-transaction that expires at `expiration` (or does not expire if the\n', '   * value is zero) and uses `salt` as an additional input, validated using\n', '   * `signatures`.\n', '   * @param owner address The account granting the modified allowance.\n', '   * @param spender address The account to modify the allowance for.\n', '   * @param value uint256 The amount to modify the allowance by.\n', '   * @param increase bool A flag that indicates whether the allowance will be\n', '   * increased by the specified value (if true) or decreased by it (if false).\n', '   * @param expiration uint256 A timestamp indicating how long the modification\n', '   * meta-transaction is valid for - a value of zero will signify no expiration.\n', '   * @param salt bytes32 An arbitrary salt to be provided as an additional input\n', '   * to the hash digest used to validate the signatures.\n', '   * @param signatures bytes A signature, or collection of signatures, that the\n', '   * owner must provide in order to authorize the meta-transaction. If the\n', '   * account of the owner does not have any runtime code deployed to it, the\n', '   * signature will be verified using ecrecover; otherwise, it will be supplied\n', '   * to the owner along with the message digest and context via ERC-1271 for\n', '   * validation.\n', '   * @return A boolean indicating whether the modification was successful.\n', '   */\n', '  function modifyAllowanceViaMetaTransaction(\n', '    address owner,\n', '    address spender,\n', '    uint256 value,\n', '    bool increase,\n', '    uint256 expiration,\n', '    bytes32 salt,\n', '    bytes calldata signatures\n', '  ) external returns (bool success) {\n', '    require(expiration == 0 || now <= expiration, "Meta-transaction expired.");\n', '\n', "    // Construct the meta-transaction's message hash based on relevant context.\n", '    bytes memory context = abi.encodePacked(\n', '      address(this),\n', '      // _DTOKEN_VERSION,\n', '      this.modifyAllowanceViaMetaTransaction.selector,\n', '      expiration,\n', '      salt,\n', '      abi.encode(owner, spender, value, increase)\n', '    );\n', '    bytes32 messageHash = keccak256(context);\n', '\n', '    // Ensure message hash has never been used before and register it as used.\n', '    require(!_executedMetaTxs[messageHash], "Meta-transaction already used.");\n', '    _executedMetaTxs[messageHash] = true;\n', '\n', '    // Construct the digest to compare signatures against using EIP-191 0x45.\n', '    bytes32 digest = keccak256(\n', '      abi.encodePacked("\\x19Ethereum Signed Message:\\n32", messageHash)\n', '    );\n', '\n', '    // Calculate new allowance by applying modification to current allowance.\n', '    uint256 currentAllowance = _allowances[owner][spender];\n', '    uint256 newAllowance = (\n', '      increase ? currentAllowance.add(value) : currentAllowance.sub(value)\n', '    );\n', '\n', '    // Use EIP-1271 if owner is a contract - otherwise, use ecrecover.\n', '    if (_isContract(owner)) {\n', '      // Validate via ERC-1271 against the owner account.\n', '      bytes memory data = abi.encode(digest, context);\n', '      bytes4 magic = ERC1271Interface(owner).isValidSignature(data, signatures);\n', '      require(magic == bytes4(0x20c13b0b), "Invalid signatures.");\n', '    } else {\n', '      // Validate via ecrecover against the owner account.\n', '      _verifyRecover(owner, digest, signatures);\n', '    }\n', '\n', '    // Modify the allowance.\n', '    _approve(owner, spender, newAllowance);\n', '    success = true;\n', '  }\n', '\n', '  /**\n', '   * @notice View function to determine a meta-transaction message hash, and to\n', '   * determine if it is still valid (i.e. it has not yet been used and is not\n', '   * expired). The returned message hash will need to be prefixed using EIP-191\n', '   * 0x45 and hashed again in order to generate a final digest for the required\n', '   * signature - in other words, the same procedure utilized by `eth_Sign`.\n', '   * @param functionSelector bytes4 The function selector for the given\n', '   * meta-transaction. There is only one function selector available for V1:\n', '   * `0x2d657fa5` (the selector for `modifyAllowanceViaMetaTransaction`).\n', '   * @param arguments bytes The abi-encoded function arguments (aside from the\n', '   * `expiration`, `salt`, and `signatures` arguments) that should be supplied\n', '   * to the given function.\n', '   * @param expiration uint256 A timestamp indicating how long the given\n', '   * meta-transaction is valid for - a value of zero will signify no expiration.\n', '   * @param salt bytes32 An arbitrary salt to be provided as an additional input\n', '   * to the hash digest used to validate the signatures.\n', '   * @return The total supply.\n', '   */\n', '  function getMetaTransactionMessageHash(\n', '    bytes4 functionSelector,\n', '    bytes calldata arguments,\n', '    uint256 expiration,\n', '    bytes32 salt\n', '  ) external view returns (bytes32 messageHash, bool valid) {\n', "    // Construct the meta-transaction's message hash based on relevant context.\n", '    messageHash = keccak256(\n', '      abi.encodePacked(\n', '        address(this), functionSelector, expiration, salt, arguments\n', '      )\n', '    );\n', '\n', '    // The meta-transaction is valid if it has not been used and is not expired.\n', '    valid = (\n', '      !_executedMetaTxs[messageHash] && (expiration == 0 || now <= expiration)\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get the total dToken supply.\n', '   * @return The total supply.\n', '   */\n', '  function totalSupply() external view returns (uint256 dTokenTotalSupply) {\n', '    dTokenTotalSupply = _totalSupply;\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get the total dToken supply, denominated in the\n', '   * underlying token.\n', '   * @return The total supply.\n', '   */\n', '  function totalSupplyUnderlying() external view returns (\n', '    uint256 dTokenTotalSupplyInUnderlying\n', '  ) {\n', '    (uint256 dTokenExchangeRate, ,) = _getExchangeRates(true);\n', '\n', '    // Determine total value of all issued dTokens, denominated as underlying.\n', '    dTokenTotalSupplyInUnderlying = _toUnderlying(\n', '      _totalSupply, dTokenExchangeRate, false\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get the total dToken balance of an account.\n', '   * @param account address The account to check the dToken balance for.\n', '   * @return The balance of the given account.\n', '   */\n', '  function balanceOf(address account) external view returns (uint256 dTokens) {\n', '    dTokens = _balances[account];\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get the dToken balance of an account, denominated\n', '   * in the underlying equivalent value.\n', '   * @param account address The account to check the balance for.\n', '   * @return The total underlying-equivalent dToken balance.\n', '   */\n', '  function balanceOfUnderlying(\n', '    address account\n', '  ) external view returns (uint256 underlyingBalance) {\n', '    // Get most recent dToken exchange rate by determining accrued interest.\n', '    (uint256 dTokenExchangeRate, ,) = _getExchangeRates(true);\n', '\n', '    // Convert account balance to underlying equivalent using the exchange rate.\n', '    underlyingBalance = _toUnderlying(\n', '      _balances[account], dTokenExchangeRate, false\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get the total allowance that `spender` has to\n', '   * transfer dTokens from the `owner` account using `transferFrom`.\n', '   * @param owner address The account that is granting the allowance.\n', '   * @param spender address The account that has been granted the allowance.\n', '   * @return The allowance of the given spender for the given owner.\n', '   */\n', '  function allowance(\n', '    address owner, address spender\n', '  ) external view returns (uint256 dTokenAllowance) {\n', '    dTokenAllowance = _allowances[owner][spender];\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get the current dToken exchange rate (multiplied\n', '   * by 10^18).\n', '   * @return The current exchange rate.\n', '   */\n', '  function exchangeRateCurrent() external view returns (\n', '    uint256 dTokenExchangeRate\n', '  ) {\n', '    // Get most recent dToken exchange rate by determining accrued interest.\n', '    (dTokenExchangeRate, ,) = _getExchangeRates(true);\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get the current dToken interest earned per block\n', '   * (multiplied by 10^18).\n', '   * @return The current interest rate.\n', '   */\n', '  function supplyRatePerBlock() external view returns (\n', '    uint256 dTokenInterestRate\n', '  ) {\n', '    (dTokenInterestRate,) = _getRatePerBlock();\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get the block number where accrual was last\n', '   * performed.\n', '   * @return The block number where accrual was last performed.\n', '   */\n', '  function accrualBlockNumber() external view returns (uint256 blockNumber) {\n', '    blockNumber = _accrualIndex.block;\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get the total surplus, or the cToken balance that\n', '   * exceeds the aggregate underlying value of the total dToken supply.\n', '   * @return The total surplus in cTokens.\n', '   */\n', '  function getSurplus() external view returns (uint256 cTokenSurplus) {\n', '    // Determine the cToken (cToken underlying value - dToken underlying value).\n', '    (, cTokenSurplus) = _getSurplus();\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get the total surplus in the underlying, or the\n', '   * underlying equivalent of the cToken balance that exceeds the aggregate\n', '   * underlying value of the total dToken supply.\n', '   * @return The total surplus, denominated in the underlying.\n', '   */\n', '  function getSurplusUnderlying() external view returns (\n', '    uint256 underlyingSurplus\n', '  ) {\n', '    // Determine cToken surplus in underlying (cToken value - dToken value).\n', '    (underlyingSurplus, ) = _getSurplus();\n', '  }\n', '\n', '  /**\n', '   * @notice View function to get the interest rate spread taken by the dToken\n', '   * from the current cToken supply rate per block (multiplied by 10^18).\n', '   * @return The current interest rate spread.\n', '   */\n', '  function getSpreadPerBlock() external view returns (uint256 rateSpread) {\n', '    (\n', '      uint256 dTokenInterestRate, uint256 cTokenInterestRate\n', '    ) = _getRatePerBlock();\n', '    rateSpread = cTokenInterestRate.sub(dTokenInterestRate);\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function to get the name of the dToken.\n', '   * @return The name of the dToken.\n', '   */\n', '  function name() external pure returns (string memory dTokenName) {\n', '    dTokenName = _getDTokenName();\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function to get the symbol of the dToken.\n', '   * @return The symbol of the dToken.\n', '   */\n', '  function symbol() external pure returns (string memory dTokenSymbol) {\n', '    dTokenSymbol = _getDTokenSymbol();\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function to get the number of decimals of the dToken.\n', '   * @return The number of decimals of the dToken.\n', '   */\n', '  function decimals() external pure returns (uint8 dTokenDecimals) {\n', '    dTokenDecimals = _DECIMALS;\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function to get the dToken version.\n', '   * @return The version of the dToken.\n', '   */\n', '  function getVersion() external pure returns (uint256 version) {\n', '    version = _DTOKEN_VERSION;\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function to get the address of the cToken backing this dToken.\n', '   * @return The address of the cToken backing this dToken.\n', '   */\n', '  function getCToken() external pure returns (address cToken) {\n', '    cToken = _getCToken();\n', '  }\n', '\n', '  /**\n', '   * @notice Pure function to get the address of the underlying token of this\n', '   * dToken.\n', '   * @return The address of the underlying token for this dToken.\n', '   */\n', '  function getUnderlying() external pure returns (address underlying) {\n', '    underlying = _getUnderlying();\n', '  }\n', '\n', '  /**\n', '   * @notice Private function to trigger accrual and to update the dToken and\n', '   * cToken exchange rates in storage if necessary. The `compute` argument can\n', '   * be set to false if an accrual has already taken place on the cToken before\n', '   * calling this function.\n', '   * @param compute bool A flag to indicate whether the cToken exchange rate\n', '   * needs to be computed - if false, it will simply be read from storage on the\n', '   * cToken in question.\n', '   * @return The current dToken and cToken exchange rates.\n', '   */\n', '  function _accrue(bool compute) private returns (\n', '    uint256 dTokenExchangeRate, uint256 cTokenExchangeRate\n', '  ) {\n', '    bool alreadyAccrued;\n', '    (\n', '      dTokenExchangeRate, cTokenExchangeRate, alreadyAccrued\n', '    ) = _getExchangeRates(compute);\n', '\n', '    if (!alreadyAccrued) {\n', '      // Update storage with dToken + cToken exchange rates as of current block.\n', '      AccrualIndex storage accrualIndex = _accrualIndex;\n', '      accrualIndex.dTokenExchangeRate = _safeUint112(dTokenExchangeRate);\n', '      accrualIndex.cTokenExchangeRate = _safeUint112(cTokenExchangeRate);\n', '      accrualIndex.block = uint32(block.number);\n', '      emit Accrue(dTokenExchangeRate, cTokenExchangeRate);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Private function to burn `amount` tokens by exchanging `exchanged`\n', '   * tokens from `account` and emit corresponding `Redeeem` & `Transfer` events.\n', '   * @param account address The account to burn tokens from.\n', '   * @param exchanged uint256 The amount of underlying tokens given for burning.\n', '   * @param amount uint256 The amount of tokens to burn.\n', '   */\n', '  function _burn(address account, uint256 exchanged, uint256 amount) private {\n', '    require(\n', '      exchanged > 0 && amount > 0, "Redeem failed: insufficient funds supplied."\n', '    );\n', '\n', '    uint256 balancePriorToBurn = _balances[account];\n', '    require(\n', '      balancePriorToBurn >= amount, "Supplied amount exceeds account balance."\n', '    );\n', '\n', '    _totalSupply = _totalSupply.sub(amount);\n', '    _balances[account] = balancePriorToBurn - amount; // overflow checked above\n', '\n', '    emit Transfer(account, address(0), amount);\n', '    emit Redeem(account, exchanged, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Private function to move `amount` tokens from `sender` to\n', '   * `recipient` and emit a corresponding `Transfer` event.\n', '   * @param sender address The account to transfer tokens from.\n', '   * @param recipient address The account to transfer tokens to.\n', '   * @param amount uint256 The amount of tokens to transfer.\n', '   */\n', '  function _transfer(\n', '    address sender, address recipient, uint256 amount\n', '  ) private {\n', '    require(sender != address(0), "ERC20: transfer from the zero address");\n', '    require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '    uint256 senderBalance = _balances[sender];\n', '    require(senderBalance >= amount, "Insufficient funds.");\n', '\n', '    _balances[sender] = senderBalance - amount; // overflow checked above.\n', '    _balances[recipient] = _balances[recipient].add(amount);\n', '\n', '    emit Transfer(sender, recipient, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Private function to transfer `amount` tokens from `sender` to\n', '   * `recipient` and to deduct the transferred amount from the allowance of the\n', '   * caller unless the allowance is set to the maximum amount.\n', '   * @param sender address The account to transfer tokens from.\n', '   * @param recipient address The account to transfer tokens to.\n', '   * @param amount uint256 The amount of tokens to transfer.\n', '   */\n', '  function _transferFrom(\n', '    address sender, address recipient, uint256 amount\n', '  ) private {\n', '    _transfer(sender, recipient, amount);\n', '    uint256 callerAllowance = _allowances[sender][msg.sender];\n', '    if (callerAllowance != uint256(-1)) {\n', '      require(callerAllowance >= amount, "Insufficient allowance.");\n', '      _approve(sender, msg.sender, callerAllowance - amount); // overflow safe.\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Private function to set the allowance for `spender` to transfer up\n', '   * to `value` tokens on behalf of `owner`.\n', '   * @param owner address The account that has granted the allowance.\n', '   * @param spender address The account to grant the allowance.\n', '   * @param value uint256 The size of the allowance to grant.\n', '   */\n', '  function _approve(address owner, address spender, uint256 value) private {\n', '    require(owner != address(0), "ERC20: approve for the zero address");\n', '    require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '    _allowances[owner][spender] = value;\n', '    emit Approval(owner, spender, value);\n', '  }\n', '\n', '  /**\n', '   * @notice Private view function to get the latest dToken and cToken exchange\n', '   * rates and provide the value for each. The `compute` argument can be set to\n', '   * false if an accrual has already taken place on the cToken before calling\n', '   * this function.\n', '   * @param compute bool A flag to indicate whether the cToken exchange rate\n', '   * needs to be computed - if false, it will simply be read from storage on the\n', '   * cToken in question.\n', '   * @return The dToken and cToken exchange rate, as well as a boolean\n', '   * indicating if interest accrual has been processed already or needs to be\n', '   * calculated and placed in storage.\n', '   */\n', '  function _getExchangeRates(bool compute) private view returns (\n', '    uint256 dTokenExchangeRate, uint256 cTokenExchangeRate, bool fullyAccrued\n', '  ) {\n', '    // Get the stored accrual block and dToken + cToken exhange rates.\n', '    AccrualIndex memory accrualIndex = _accrualIndex;\n', '    uint256 storedDTokenExchangeRate = uint256(accrualIndex.dTokenExchangeRate);\n', '    uint256 storedCTokenExchangeRate = uint256(accrualIndex.cTokenExchangeRate);\n', '    uint256 accrualBlock = uint256(accrualIndex.block);\n', '\n', '    // Use stored exchange rates if an accrual has already occurred this block.\n', '    fullyAccrued = (accrualBlock == block.number);\n', '    if (fullyAccrued) {\n', '      dTokenExchangeRate = storedDTokenExchangeRate;\n', '      cTokenExchangeRate = storedCTokenExchangeRate;\n', '    } else {\n', '      // Only compute cToken exchange rate if it has not accrued this block.\n', '      if (compute) {\n', '        // Get current cToken exchange rate; inheriting contract overrides this.\n', '        (cTokenExchangeRate,) = _getCurrentCTokenRates();\n', '      } else {\n', '        // Otherwise, get the stored cToken exchange rate.\n', '        cTokenExchangeRate = CTokenInterface(_getCToken()).exchangeRateStored();\n', '      }\n', '\n', '      if (exchangeRateFrozen) {\n', '         dTokenExchangeRate = storedDTokenExchangeRate;\n', '      } else {\n', '        // Determine the cToken interest earned during the period.\n', '        uint256 cTokenInterest = (\n', '          (cTokenExchangeRate.mul(_SCALING_FACTOR)).div(storedCTokenExchangeRate)\n', '        ).sub(_SCALING_FACTOR);\n', '    \n', '        // Calculate dToken exchange rate by applying 90% of the cToken interest.\n', '        dTokenExchangeRate = storedDTokenExchangeRate.mul(\n', '          _SCALING_FACTOR.add(cTokenInterest.mul(9) / 10)\n', '        ) / _SCALING_FACTOR;          \n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Private view function to get the total surplus, or cToken\n', '   * balance that exceeds the total dToken balance.\n', '   * @return The total surplus, denominated in both the underlying and in the\n', '   * cToken.\n', '   */\n', '  function _getSurplus() private view returns (\n', '    uint256 underlyingSurplus, uint256 cTokenSurplus\n', '  ) {\n', '    if (exchangeRateFrozen) {\n', '        underlyingSurplus = 0;\n', '        cTokenSurplus = 0;\n', '    } else {\n', '      // Instantiate the interface for the backing cToken.\n', '      CTokenInterface cToken = CTokenInterface(_getCToken());\n', '\n', '      (\n', '        uint256 dTokenExchangeRate, uint256 cTokenExchangeRate,\n', '      ) = _getExchangeRates(true);\n', '\n', '      // Determine value of all issued dTokens in the underlying, rounded up.\n', '      uint256 dTokenUnderlying = _toUnderlying(\n', '        _totalSupply, dTokenExchangeRate, true\n', '      );\n', '\n', '      // Determine value of all retained cTokens in the underlying, rounded down.\n', '      uint256 cTokenUnderlying = _toUnderlying(\n', '        cToken.balanceOf(address(this)), cTokenExchangeRate, false\n', '      );\n', '\n', '      // Determine the size of the surplus in terms of underlying amount.\n', '      underlyingSurplus = cTokenUnderlying > dTokenUnderlying\n', '        ? cTokenUnderlying - dTokenUnderlying // overflow checked above\n', '        : 0;\n', '\n', '      // Determine the cToken equivalent of this surplus amount.\n', '      cTokenSurplus = underlyingSurplus == 0\n', '        ? 0\n', '        : _fromUnderlying(underlyingSurplus, cTokenExchangeRate, false);\n', '        \n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Private view function to get the current dToken and cToken interest\n', '   * supply rate per block (multiplied by 10^18).\n', '   * @return The current dToken and cToken interest rates.\n', '   */\n', '  function _getRatePerBlock() private view returns (\n', '    uint256 dTokenSupplyRate, uint256 cTokenSupplyRate\n', '  ) {\n', '    (, cTokenSupplyRate) = _getCurrentCTokenRates();\n', '    if (exchangeRateFrozen) {\n', '      dTokenSupplyRate = 0;\n', '    } else {\n', '      dTokenSupplyRate = cTokenSupplyRate.mul(9) / 10;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Private view function to determine if a given account has runtime\n', '   * code or not - in other words, whether or not a contract is deployed to the\n', '   * account in question. Note that contracts that are in the process of being\n', '   * deployed will return false on this check.\n', '   * @param account address The account to check for contract runtime code.\n', '   * @return Whether or not there is contract runtime code at the account.\n', '   */\n', '  function _isContract(address account) private view returns (bool isContract) {\n', '    uint256 size;\n', '    assembly { size := extcodesize(account) }\n', '    isContract = size > 0;\n', '  }\n', '\n', '  /**\n', '   * @notice Private pure function to verify that a given signature of a digest\n', '   * resolves to the supplied account. Any error, including incorrect length,\n', '   * malleable signature types, or unsupported `v` values, will cause a revert.\n', '   * @param account address The account to validate against.\n', '   * @param digest bytes32 The digest to use.\n', '   * @param signature bytes The signature to verify.\n', '   */\n', '  function _verifyRecover(\n', '    address account, bytes32 digest, bytes memory signature\n', '  ) private pure {\n', '    // Ensure the signature length is correct.\n', '    require(\n', '      signature.length == 65,\n', '      "Must supply a single 65-byte signature when owner is not a contract."\n', '    );\n', '\n', '    // Divide the signature in r, s and v variables.\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '    assembly {\n', '      r := mload(add(signature, 0x20))\n', '      s := mload(add(signature, 0x40))\n', '      v := byte(0, mload(add(signature, 0x60)))\n', '    }\n', '\n', '    require(\n', '      uint256(s) <= _MAX_UNMALLEABLE_S,\n', '      "Signature `s` value cannot be potentially malleable."\n', '    );\n', '\n', '    require(v == 27 || v == 28, "Signature `v` value not permitted.");\n', '\n', '    require(account == ecrecover(digest, v, r, s), "Invalid signature.");\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title DharmaUSDCImplementationV2\n', ' * @author 0age (dToken mechanics derived from Compound cTokens, ERC20 methods\n', " * derived from Open Zeppelin's ERC20 contract)\n", ' * @notice This contract provides the V2 implementation of Dharma USD Coin (or\n', ' * dUSDC), which effectively deprecates Dharma USD Coin.\n', ' */\n', 'contract DharmaUSDCImplementationV2 is DharmaTokenV2 {\n', '  string internal constant _NAME = "Dharma USD Coin";\n', '  string internal constant _SYMBOL = "dUSDC";\n', '  string internal constant _UNDERLYING_NAME = "USD Coin";\n', '  string internal constant _CTOKEN_SYMBOL = "cUSDC";\n', '\n', '  CTokenInterface internal constant _CUSDC = CTokenInterface(\n', '    0x39AA39c021dfbaE8faC545936693aC917d5E7563 // mainnet\n', '  );\n', '\n', '  ERC20Interface internal constant _USDC = ERC20Interface(\n', '    0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 // mainnet\n', '  );\n', '\n', '  address internal constant _VAULT = 0x7e4A8391C728fEd9069B2962699AB416628B19Fa;\n', '\n', '  uint256 internal constant _SCALING_FACTOR_SQUARED = 1e36;\n', '\n', '  /**\n', '   * @notice Internal view function to get the current cUSDC exchange rate and\n', '   * supply rate per block.\n', '   * @return The current cUSDC exchange rate, or amount of USDC that is\n', '   * redeemable for each cUSDC, and the cUSDC supply rate per block (with 18\n', '   * decimal places added to each returned rate).\n', '   */\n', '  function _getCurrentCTokenRates() internal view returns (\n', '    uint256 exchangeRate, uint256 supplyRate\n', '  ) {\n', '    // Determine number of blocks that have elapsed since last cUSDC accrual.\n', '    uint256 blockDelta = block.number.sub(_CUSDC.accrualBlockNumber());\n', '\n', '    // Return stored values if accrual has already been performed this block.\n', '    if (blockDelta == 0) return (\n', '      _CUSDC.exchangeRateStored(), _CUSDC.supplyRatePerBlock()\n', '    );\n', '\n', '    // Determine total "cash" held by cUSDC contract.\n', '    uint256 cash = _USDC.balanceOf(address(_CUSDC));\n', '\n', '    // Get the latest interest rate model from the cUSDC contract.\n', '    CUSDCInterestRateModelInterface interestRateModel = (\n', '      CUSDCInterestRateModelInterface(_CUSDC.interestRateModel())\n', '    );\n', '\n', '    // Get the current stored total borrows, reserves, and reserve factor.\n', '    uint256 borrows = _CUSDC.totalBorrows();\n', '    uint256 reserves = _CUSDC.totalReserves();\n', '    uint256 reserveFactor = _CUSDC.reserveFactorMantissa();\n', '\n', '    // Get the current borrow rate from the latest cUSDC interest rate model.\n', '    (uint256 err, uint256 borrowRate) = interestRateModel.getBorrowRate(\n', '      cash, borrows, reserves\n', '    );\n', '    require(\n', '      err == _COMPOUND_SUCCESS, "Interest Rate Model borrow rate check failed."\n', '    );\n', '\n', '    // Get accumulated borrow interest via borrows, borrow rate, & block delta.\n', '    uint256 interest = borrowRate.mul(blockDelta).mul(borrows) / _SCALING_FACTOR;\n', '\n', '    // Update total borrows and reserves using calculated accumulated interest.\n', '    borrows = borrows.add(interest);\n', '    reserves = reserves.add(reserveFactor.mul(interest) / _SCALING_FACTOR);\n', '\n', '    // Get "underlying" via (cash + borrows - reserves).\n', '    uint256 underlying = (cash.add(borrows)).sub(reserves);\n', '\n', '    // Determine cUSDC exchange rate via underlying / total supply.\n', '    exchangeRate = (underlying.mul(_SCALING_FACTOR)).div(_CUSDC.totalSupply());\n', '\n', '    // Get "borrows per" by dividing total borrows by underlying and scaling up.\n', '    uint256 borrowsPer = (borrows.mul(_SCALING_FACTOR)).div(underlying);\n', '\n', '    // Supply rate is borrow rate * (1 - reserveFactor) * borrowsPer.\n', '    supplyRate = (\n', '      borrowRate.mul(_SCALING_FACTOR.sub(reserveFactor)).mul(borrowsPer)\n', '    ) / _SCALING_FACTOR_SQUARED;\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the name of the underlying token.\n', '   * @return The name of the underlying token.\n', '   */\n', '  function _getUnderlyingName() internal pure returns (string memory underlyingName) {\n', '    underlyingName = _UNDERLYING_NAME;\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the address of the underlying\n', '   * token.\n', '   * @return The address of the underlying token.\n', '   */\n', '  function _getUnderlying() internal pure returns (address underlying) {\n', '    underlying = address(_USDC);\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the symbol of the backing cToken.\n', '   * @return The symbol of the backing cToken.\n', '   */\n', '  function _getCTokenSymbol() internal pure returns (string memory cTokenSymbol) {\n', '    cTokenSymbol = _CTOKEN_SYMBOL;\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the address of the backing cToken.\n', '   * @return The address of the backing cToken.\n', '   */\n', '  function _getCToken() internal pure returns (address cToken) {\n', '    cToken = address(_CUSDC);\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the name of the dToken.\n', '   * @return The name of the dToken.\n', '   */\n', '  function _getDTokenName() internal pure returns (string memory dTokenName) {\n', '    dTokenName = _NAME;\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the symbol of the dToken.\n', '   * @return The symbol of the dToken.\n', '   */\n', '  function _getDTokenSymbol() internal pure returns (string memory dTokenSymbol) {\n', '    dTokenSymbol = _SYMBOL;\n', '  }\n', '\n', '  /**\n', '   * @notice Internal pure function to supply the address of the vault that\n', '   * receives surplus cTokens whenever the surplus is pulled.\n', '   * @return The address of the vault.\n', '   */\n', '  function _getVault() internal pure returns (address vault) {\n', '    vault = _VAULT;\n', '  }\n', '}']