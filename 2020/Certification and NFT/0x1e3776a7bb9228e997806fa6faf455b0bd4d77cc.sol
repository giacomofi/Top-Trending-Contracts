['pragma solidity ^0.5.16;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'contract EliteGovernorAlpha {\n', '    /// @notice The name of this contract\n', '    string public constant name = "Eliteswap Governor Alpha";\n', '\n', '    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n', '    function quorumVotes() public pure returns (uint) { return 400_000_000e18; } // 4% of Elt\n', '\n', '    /// @notice The number of votes required in order for a voter to become a proposer\n', '    function proposalThreshold() public pure returns (uint) { return 100_000_000e18; } // 1% of Elt\n', '\n', '    /// @notice The maximum number of actions that can be included in a proposal\n', '    function proposalMaxOperations() public pure returns (uint) { return 10; } // 10 actions\n', '\n', '    /// @notice The delay before voting on a proposal may take place, once proposed\n', '    function votingDelay() public pure returns (uint) { return 1; } // 1 block\n', '\n', '    /// @notice The duration of voting on a proposal, in blocks\n', '    function votingPeriod() public pure returns (uint) { return 40_320; } // ~7 days in blocks (assuming 15s blocks)\n', '\n', '    /// @notice The address of the Eliteswap Protocol Timelock\n', '    EliteTimelockInterface public timelock;\n', '\n', '    /// @notice The address of the Eliteswap governance token\n', '    EliteInterface public elt;\n', '\n', '    /// @notice The total number of proposals\n', '    uint public proposalCount;\n', '\n', '    struct Proposal {\n', '        /// @notice Unique id for looking up a proposal\n', '        uint id;\n', '\n', '        /// @notice Creator of the proposal\n', '        address proposer;\n', '\n', '        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n', '        uint eta;\n', '\n', '        /// @notice the ordered list of target addresses for calls to be made\n', '        address[] targets;\n', '\n', '        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n', '        uint[] values;\n', '\n', '        /// @notice The ordered list of function signatures to be called\n', '        string[] signatures;\n', '\n', '        /// @notice The ordered list of calldata to be passed to each call\n', '        bytes[] calldatas;\n', '\n', '        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n', '        uint startBlock;\n', '\n', '        /// @notice The block at which voting ends: votes must be cast prior to this block\n', '        uint endBlock;\n', '\n', '        /// @notice Current number of votes in favor of this proposal\n', '        uint forVotes;\n', '\n', '        /// @notice Current number of votes in opposition to this proposal\n', '        uint againstVotes;\n', '\n', '        /// @notice Flag marking whether the proposal has been canceled\n', '        bool canceled;\n', '\n', '        /// @notice Flag marking whether the proposal has been executed\n', '        bool executed;\n', '\n', '        /// @notice Receipts of ballots for the entire set of voters\n', '        mapping (address => Receipt) receipts;\n', '    }\n', '\n', '    /// @notice Ballot receipt record for a voter\n', '    struct Receipt {\n', '        /// @notice Whether or not a vote has been cast\n', '        bool hasVoted;\n', '\n', '        /// @notice Whether or not the voter supports the proposal\n', '        bool support;\n', '\n', '        /// @notice The number of votes the voter had, which were cast\n', '        uint96 votes;\n', '    }\n', '\n', '    /// @notice Possible states that a proposal may be in\n', '    enum ProposalState {\n', '        Pending,\n', '        Active,\n', '        Canceled,\n', '        Defeated,\n', '        Succeeded,\n', '        Queued,\n', '        Expired,\n', '        Executed\n', '    }\n', '\n', '    /// @notice The official record of all proposals ever proposed\n', '    mapping (uint => Proposal) public proposals;\n', '\n', '    /// @notice The latest proposal for each proposer\n', '    mapping (address => uint) public latestProposalIds;\n', '\n', "    /// @notice The EIP-712 typehash for the contract's domain\n", '    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");\n', '\n', '    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n', '    bytes32 public constant BALLOT_TYPEHASH = keccak256("Ballot(uint256 proposalId,bool support)");\n', '\n', '    /// @notice An event emitted when a new proposal is created\n', '    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\n', '\n', '    /// @notice An event emitted when a vote has been cast on a proposal\n', '    event VoteCast(address voter, uint proposalId, bool support, uint votes);\n', '\n', '    /// @notice An event emitted when a proposal has been canceled\n', '    event ProposalCanceled(uint id);\n', '\n', '    /// @notice An event emitted when a proposal has been queued in the EliteTimelock\n', '    event ProposalQueued(uint id, uint eta);\n', '\n', '    /// @notice An event emitted when a proposal has been executed in the EliteTimelock\n', '    event ProposalExecuted(uint id);\n', '\n', '    constructor(address timelock_, address elt_) public {\n', '        timelock = EliteTimelockInterface(timelock_);\n', '        elt = EliteInterface(elt_);\n', '    }\n', '\n', '    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n', '        require(elt.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), "EliteGovernorAlpha::propose: proposer votes below proposal threshold");\n', '        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, "EliteGovernorAlpha::propose: proposal function information arity mismatch");\n', '        require(targets.length != 0, "EliteGovernorAlpha::propose: must provide actions");\n', '        require(targets.length <= proposalMaxOperations(), "EliteGovernorAlpha::propose: too many actions");\n', '\n', '        uint latestProposalId = latestProposalIds[msg.sender];\n', '        if (latestProposalId != 0) {\n', '          ProposalState proposersLatestProposalState = state(latestProposalId);\n', '          require(proposersLatestProposalState != ProposalState.Active, "EliteGovernorAlpha::propose: one live proposal per proposer, found an already active proposal");\n', '          require(proposersLatestProposalState != ProposalState.Pending, "EliteGovernorAlpha::propose: one live proposal per proposer, found an already pending proposal");\n', '        }\n', '\n', '        uint startBlock = add256(block.number, votingDelay());\n', '        uint endBlock = add256(startBlock, votingPeriod());\n', '\n', '        proposalCount++;\n', '        Proposal memory newProposal = Proposal({\n', '            id: proposalCount,\n', '            proposer: msg.sender,\n', '            eta: 0,\n', '            targets: targets,\n', '            values: values,\n', '            signatures: signatures,\n', '            calldatas: calldatas,\n', '            startBlock: startBlock,\n', '            endBlock: endBlock,\n', '            forVotes: 0,\n', '            againstVotes: 0,\n', '            canceled: false,\n', '            executed: false\n', '        });\n', '\n', '        proposals[newProposal.id] = newProposal;\n', '        latestProposalIds[newProposal.proposer] = newProposal.id;\n', '\n', '        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n', '        return newProposal.id;\n', '    }\n', '\n', '    function queue(uint proposalId) public {\n', '        require(state(proposalId) == ProposalState.Succeeded, "EliteGovernorAlpha::queue: proposal can only be queued if it is succeeded");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        uint eta = add256(block.timestamp, timelock.delay());\n', '        for (uint i = 0; i < proposal.targets.length; i++) {\n', '            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n', '        }\n', '        proposal.eta = eta;\n', '        emit ProposalQueued(proposalId, eta);\n', '    }\n', '\n', '    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n', '        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), "EliteGovernorAlpha::_queueOrRevert: proposal action already queued at eta");\n', '        timelock.queueTransaction(target, value, signature, data, eta);\n', '    }\n', '\n', '    function execute(uint proposalId) public payable {\n', '        require(state(proposalId) == ProposalState.Queued, "EliteGovernorAlpha::execute: proposal can only be executed if it is queued");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        proposal.executed = true;\n', '        for (uint i = 0; i < proposal.targets.length; i++) {\n', '            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n', '        }\n', '        emit ProposalExecuted(proposalId);\n', '    }\n', '\n', '    function cancel(uint proposalId) public {\n', '        ProposalState state = state(proposalId);\n', '        require(state != ProposalState.Executed, "EliteGovernorAlpha::cancel: cannot cancel executed proposal");\n', '\n', '        Proposal storage proposal = proposals[proposalId];\n', '        require(elt.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), "EliteGovernorAlpha::cancel: proposer above threshold");\n', '\n', '        proposal.canceled = true;\n', '        for (uint i = 0; i < proposal.targets.length; i++) {\n', '            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n', '        }\n', '\n', '        emit ProposalCanceled(proposalId);\n', '    }\n', '\n', '    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\n', '        Proposal storage p = proposals[proposalId];\n', '        return (p.targets, p.values, p.signatures, p.calldatas);\n', '    }\n', '\n', '    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\n', '        return proposals[proposalId].receipts[voter];\n', '    }\n', '\n', '    function state(uint proposalId) public view returns (ProposalState) {\n', '        require(proposalCount >= proposalId && proposalId > 0, "EliteGovernorAlpha::state: invalid proposal id");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        if (proposal.canceled) {\n', '            return ProposalState.Canceled;\n', '        } else if (block.number <= proposal.startBlock) {\n', '            return ProposalState.Pending;\n', '        } else if (block.number <= proposal.endBlock) {\n', '            return ProposalState.Active;\n', '        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n', '            return ProposalState.Defeated;\n', '        } else if (proposal.eta == 0) {\n', '            return ProposalState.Succeeded;\n', '        } else if (proposal.executed) {\n', '            return ProposalState.Executed;\n', '        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n', '            return ProposalState.Expired;\n', '        } else {\n', '            return ProposalState.Queued;\n', '        }\n', '    }\n', '\n', '    function castVote(uint proposalId, bool support) public {\n', '        return _castVote(msg.sender, proposalId, support);\n', '    }\n', '\n', '    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\n', '        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n', '        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n', '        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '        address signatory = ecrecover(digest, v, r, s);\n', '        require(signatory != address(0), "EliteGovernorAlpha::castVoteBySig: invalid signature");\n', '        return _castVote(signatory, proposalId, support);\n', '    }\n', '\n', '    function _castVote(address voter, uint proposalId, bool support) internal {\n', '        require(state(proposalId) == ProposalState.Active, "EliteGovernorAlpha::_castVote: voting is closed");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        Receipt storage receipt = proposal.receipts[voter];\n', '        require(receipt.hasVoted == false, "EliteGovernorAlpha::_castVote: voter already voted");\n', '        uint96 votes = elt.getPriorVotes(voter, proposal.startBlock);\n', '\n', '        if (support) {\n', '            proposal.forVotes = add256(proposal.forVotes, votes);\n', '        } else {\n', '            proposal.againstVotes = add256(proposal.againstVotes, votes);\n', '        }\n', '\n', '        receipt.hasVoted = true;\n', '        receipt.support = support;\n', '        receipt.votes = votes;\n', '\n', '        emit VoteCast(voter, proposalId, support, votes);\n', '    }\n', '\n', '    function add256(uint256 a, uint256 b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "addition overflow");\n', '        return c;\n', '    }\n', '\n', '    function sub256(uint256 a, uint256 b) internal pure returns (uint) {\n', '        require(b <= a, "subtraction underflow");\n', '        return a - b;\n', '    }\n', '\n', '    function getChainId() internal pure returns (uint) {\n', '        uint chainId;\n', '        assembly { chainId := chainid() }\n', '        return chainId;\n', '    }\n', '}\n', '\n', 'interface EliteTimelockInterface {\n', '    function delay() external view returns (uint);\n', '    function GRACE_PERIOD() external view returns (uint);\n', '    function acceptAdmin() external;\n', '    function queuedTransactions(bytes32 hash) external view returns (bool);\n', '    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n', '    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n', '    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n', '}\n', '\n', 'interface EliteInterface {\n', '    function getPriorVotes(address account, uint blockNumber) external view returns (uint96);\n', '}']