['pragma solidity ^0.5.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20Mintable}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for `sender`'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n', "     * from the caller's allowance.\n", '     *\n', '     * See {_burn} and {_approve}.\n', '     */\n', '    function _burnFrom(address account, uint256 amount) internal {\n', '        _burn(account, amount);\n', '        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Base interface for a contract that will be called via the GSN from {IRelayHub}.\n', ' *\n', " * TIP: You don't need to write an implementation yourself! Inherit from {GSNRecipient} instead.\n", ' */\n', 'interface IRelayRecipient {\n', '    /**\n', '     * @dev Returns the address of the {IRelayHub} instance this recipient interacts with.\n', '     */\n', '    function getHubAddr() external view returns (address);\n', '\n', '    /**\n', '     * @dev Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the\n', '     * recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not).\n', '     *\n', '     * The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call\n', '     * calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas,\n', "     * and the transaction executed with a gas price of at least `gasPrice`. `relay`'s fee is `transactionFee`, and the\n", "     * recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for\n", '     * replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature\n', '     * over all or some of the previous values.\n', '     *\n', '     * Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code,\n', '     * values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions.\n', '     *\n', '     * {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered\n', '     * rejected. A regular revert will also trigger a rejection.\n', '     */\n', '    function acceptRelayedCall(\n', '        address relay,\n', '        address from,\n', '        bytes calldata encodedFunction,\n', '        uint256 transactionFee,\n', '        uint256 gasPrice,\n', '        uint256 gasLimit,\n', '        uint256 nonce,\n', '        bytes calldata approvalData,\n', '        uint256 maxPossibleCharge\n', '    )\n', '        external\n', '        view\n', '        returns (uint256, bytes memory);\n', '\n', '    /**\n', '     * @dev Called by {IRelayHub} on approved relay call requests, before the relayed call is executed. This allows to e.g.\n', '     * pre-charge the sender of the transaction.\n', '     *\n', '     * `context` is the second value returned in the tuple by {acceptRelayedCall}.\n', '     *\n', '     * Returns a value to be passed to {postRelayedCall}.\n', '     *\n', '     * {preRelayedCall} is called with 100k gas: if it runs out during exection or otherwise reverts, the relayed call\n', "     * will not be executed, but the recipient will still be charged for the transaction's cost.\n", '     */\n', '    function preRelayedCall(bytes calldata context) external returns (bytes32);\n', '\n', '    /**\n', '     * @dev Called by {IRelayHub} on approved relay call requests, after the relayed call is executed. This allows to e.g.\n', '     * charge the user for the relayed call costs, return any overcharges from {preRelayedCall}, or perform\n', '     * contract-specific bookkeeping.\n', '     *\n', '     * `context` is the second value returned in the tuple by {acceptRelayedCall}. `success` is the execution status of\n', '     * the relayed call. `actualCharge` is an estimate of how much the recipient will be charged for the transaction,\n', "     * not including any gas used by {postRelayedCall} itself. `preRetVal` is {preRelayedCall}'s return value.\n", '     *\n', '     *\n', '     * {postRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call\n', '     * and the call to {preRelayedCall} will be reverted retroactively, but the recipient will still be charged for the\n', "     * transaction's cost.\n", '     */\n', '    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external;\n', '}\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface for `RelayHub`, the core contract of the GSN. Users should not need to interact with this contract\n', ' * directly.\n', ' *\n', ' * See the https://github.com/OpenZeppelin/openzeppelin-gsn-helpers[OpenZeppelin GSN helpers] for more information on\n', ' * how to deploy an instance of `RelayHub` on your local test network.\n', ' */\n', 'interface IRelayHub {\n', '    // Relay management\n', '\n', '    /**\n', '     * @dev Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller\n', '     * of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay\n', '     * cannot be its own owner.\n', '     *\n', "     * All Ether in this function call will be added to the relay's stake.\n", '     * Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one.\n', '     *\n', '     * Emits a {Staked} event.\n', '     */\n', '    function stake(address relayaddr, uint256 unstakeDelay) external payable;\n', '\n', '    /**\n', "     * @dev Emitted when a relay's stake or unstakeDelay are increased\n", '     */\n', '    event Staked(address indexed relay, uint256 stake, uint256 unstakeDelay);\n', '\n', '    /**\n', '     * @dev Registers the caller as a relay.\n', '     * The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA).\n', '     *\n', '     * This function can be called multiple times, emitting new {RelayAdded} events. Note that the received\n', '     * `transactionFee` is not enforced by {relayCall}.\n', '     *\n', '     * Emits a {RelayAdded} event.\n', '     */\n', '    function registerRelay(uint256 transactionFee, string calldata url) external;\n', '\n', '    /**\n', '     * @dev Emitted when a relay is registered or re-registerd. Looking at these events (and filtering out\n', '     * {RelayRemoved} events) lets a client discover the list of available relays.\n', '     */\n', '    event RelayAdded(address indexed relay, address indexed owner, uint256 transactionFee, uint256 stake, uint256 unstakeDelay, string url);\n', '\n', '    /**\n', '     * @dev Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed.\n', '     *\n', "     * Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be\n", '     * callable.\n', '     *\n', '     * Emits a {RelayRemoved} event.\n', '     */\n', '    function removeRelayByOwner(address relay) external;\n', '\n', '    /**\n', '     * @dev Emitted when a relay is removed (deregistered). `unstakeTime` is the time when unstake will be callable.\n', '     */\n', '    event RelayRemoved(address indexed relay, uint256 unstakeTime);\n', '\n', '    /** Deletes the relay from the system, and gives back its stake to the owner.\n', '     *\n', '     * Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called.\n', '     *\n', '     * Emits an {Unstaked} event.\n', '     */\n', '    function unstake(address relay) external;\n', '\n', '    /**\n', '     * @dev Emitted when a relay is unstaked for, including the returned stake.\n', '     */\n', '    event Unstaked(address indexed relay, uint256 stake);\n', '\n', '    // States a relay can be in\n', '    enum RelayState {\n', '        Unknown, // The relay is unknown to the system: it has never been staked for\n', '        Staked, // The relay has been staked for, but it is not yet active\n', '        Registered, // The relay has registered itself, and is active (can relay calls)\n', '        Removed    // The relay has been removed by its owner and can no longer relay calls. It must wait for its unstakeDelay to elapse before it can unstake\n', '    }\n', '\n', '    /**\n', "     * @dev Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function\n", '     * to return an empty entry.\n', '     */\n', '    function getRelay(address relay) external view returns (uint256 totalStake, uint256 unstakeDelay, uint256 unstakeTime, address payable owner, RelayState state);\n', '\n', '    // Balance management\n', '\n', '    /**\n', '     * @dev Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions.\n', '     *\n', '     * Unused balance can only be withdrawn by the contract itself, by calling {withdraw}.\n', '     *\n', '     * Emits a {Deposited} event.\n', '     */\n', '    function depositFor(address target) external payable;\n', '\n', '    /**\n', '     * @dev Emitted when {depositFor} is called, including the amount and account that was funded.\n', '     */\n', '    event Deposited(address indexed recipient, address indexed from, uint256 amount);\n', '\n', '    /**\n', "     * @dev Returns an account's deposits. These can be either a contracts's funds, or a relay owner's revenue.\n", '     */\n', '    function balanceOf(address target) external view returns (uint256);\n', '\n', '    /**\n', "     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and\n", '     * contracts can use it to reduce their funding.\n', '     *\n', '     * Emits a {Withdrawn} event.\n', '     */\n', '    function withdraw(uint256 amount, address payable dest) external;\n', '\n', '    /**\n', '     * @dev Emitted when an account withdraws funds from `RelayHub`.\n', '     */\n', '    event Withdrawn(address indexed account, address indexed dest, uint256 amount);\n', '\n', '    // Relaying\n', '\n', '    /**\n', '     * @dev Checks if the `RelayHub` will accept a relayed operation.\n', '     * Multiple things must be true for this to happen:\n', '     *  - all arguments must be signed for by the sender (`from`)\n', "     *  - the sender's nonce must be the current one\n", '     *  - the recipient must accept this transaction (via {acceptRelayedCall})\n', '     *\n', '     * Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error\n', '     * code if it returns one in {acceptRelayedCall}.\n', '     */\n', '    function canRelay(\n', '        address relay,\n', '        address from,\n', '        address to,\n', '        bytes calldata encodedFunction,\n', '        uint256 transactionFee,\n', '        uint256 gasPrice,\n', '        uint256 gasLimit,\n', '        uint256 nonce,\n', '        bytes calldata signature,\n', '        bytes calldata approvalData\n', '    ) external view returns (uint256 status, bytes memory recipientContext);\n', '\n', '    // Preconditions for relaying, checked by canRelay and returned as the corresponding numeric values.\n', '    enum PreconditionCheck {\n', '        OK,                         // All checks passed, the call can be relayed\n', '        WrongSignature,             // The transaction to relay is not signed by requested sender\n', '        WrongNonce,                 // The provided nonce has already been used by the sender\n', '        AcceptRelayedCallReverted,  // The recipient rejected this call via acceptRelayedCall\n', '        InvalidRecipientStatusCode  // The recipient returned an invalid (reserved) status code\n', '    }\n', '\n', '    /**\n', '     * @dev Relays a transaction.\n', '     *\n', '     * For this to succeed, multiple conditions must be met:\n', '     *  - {canRelay} must `return PreconditionCheck.OK`\n', '     *  - the sender must be a registered relay\n', "     *  - the transaction's gas price must be larger or equal to the one that was requested by the sender\n", '     *  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the\n', '     * recipient) use all gas available to them\n', '     *  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is\n', '     * spent)\n', '     *\n', '     * If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded\n', '     * function and {postRelayedCall} will be called in that order.\n', '     *\n', '     * Parameters:\n', '     *  - `from`: the client originating the request\n', '     *  - `to`: the target {IRelayRecipient} contract\n', '     *  - `encodedFunction`: the function call to relay, including data\n', '     *  - `transactionFee`: fee (%) the relay takes over actual gas cost\n', '     *  - `gasPrice`: gas price the client is willing to pay\n', '     *  - `gasLimit`: gas to forward when calling the encoded function\n', "     *  - `nonce`: client's nonce\n", "     *  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses\n", '     *  - `approvalData`: dapp-specific data forwared to {acceptRelayedCall}. This value is *not* verified by the\n', '     * `RelayHub`, but it still can be used for e.g. a signature.\n', '     *\n', '     * Emits a {TransactionRelayed} event.\n', '     */\n', '    function relayCall(\n', '        address from,\n', '        address to,\n', '        bytes calldata encodedFunction,\n', '        uint256 transactionFee,\n', '        uint256 gasPrice,\n', '        uint256 gasLimit,\n', '        uint256 nonce,\n', '        bytes calldata signature,\n', '        bytes calldata approvalData\n', '    ) external;\n', '\n', '    /**\n', '     * @dev Emitted when an attempt to relay a call failed.\n', '     *\n', '     * This can happen due to incorrect {relayCall} arguments, or the recipient not accepting the relayed call. The\n', '     * actual relayed call was not executed, and the recipient not charged.\n', '     *\n', '     * The `reason` parameter contains an error code: values 1-10 correspond to `PreconditionCheck` entries, and values\n', '     * over 10 are custom recipient error codes returned from {acceptRelayedCall}.\n', '     */\n', '    event CanRelayFailed(address indexed relay, address indexed from, address indexed to, bytes4 selector, uint256 reason);\n', '\n', '    /**\n', '     * @dev Emitted when a transaction is relayed. \n', "     * Useful when monitoring a relay's operation and relayed calls to a contract\n", '     *\n', '     * Note that the actual encoded function might be reverted: this is indicated in the `status` parameter.\n', '     *\n', "     * `charge` is the Ether value deducted from the recipient's balance, paid to the relay's owner.\n", '     */\n', '    event TransactionRelayed(address indexed relay, address indexed from, address indexed to, bytes4 selector, RelayCallStatus status, uint256 charge);\n', '\n', '    // Reason error codes for the TransactionRelayed event\n', '    enum RelayCallStatus {\n', '        OK,                      // The transaction was successfully relayed and execution successful - never included in the event\n', '        RelayedCallFailed,       // The transaction was relayed, but the relayed call failed\n', '        PreRelayedFailed,        // The transaction was not relayed due to preRelatedCall reverting\n', '        PostRelayedFailed,       // The transaction was relayed and reverted due to postRelatedCall reverting\n', "        RecipientBalanceChanged  // The transaction was relayed and reverted due to the recipient's balance changing\n", '    }\n', '\n', '    /**\n', '     * @dev Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will\n', '     * spend up to `relayedCallStipend` gas.\n', '     */\n', '    function requiredGas(uint256 relayedCallStipend) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.\n', '     */\n', '    function maxPossibleCharge(uint256 relayedCallStipend, uint256 gasPrice, uint256 transactionFee) external view returns (uint256);\n', '\n', '     // Relay penalization. \n', '     // Any account can penalize relays, removing them from the system immediately, and rewarding the\n', "    // reporter with half of the relay's stake. The other half is burned so that, even if the relay penalizes itself, it\n", '    // still loses half of its stake.\n', '\n', '    /**\n', '     * @dev Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and\n', '     * different data (gas price, gas limit, etc. may be different).\n', '     *\n', '     * The (unsigned) transaction data and signature for both transactions must be provided.\n', '     */\n', '    function penalizeRepeatedNonce(bytes calldata unsignedTx1, bytes calldata signature1, bytes calldata unsignedTx2, bytes calldata signature2) external;\n', '\n', '    /**\n', "     * @dev Penalize a relay that sent a transaction that didn't target `RelayHub`'s {registerRelay} or {relayCall}.\n", '     */\n', '    function penalizeIllegalTransaction(bytes calldata unsignedTx, bytes calldata signature) external;\n', '\n', '    /**\n', '     * @dev Emitted when a relay is penalized.\n', '     */\n', '    event Penalized(address indexed relay, address sender, uint256 amount);\n', '\n', '    /**\n', "     * @dev Returns an account's nonce in `RelayHub`.\n", '     */\n', '    function getNonce(address from) external view returns (uint256);\n', '}\n', '\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Base GSN recipient contract: includes the {IRelayRecipient} interface\n', ' * and enables GSN support on all contracts in the inheritance tree.\n', ' *\n', ' * TIP: This contract is abstract. The functions {IRelayRecipient-acceptRelayedCall},\n', ' *  {_preRelayedCall}, and {_postRelayedCall} are not implemented and must be\n', ' * provided by derived contracts. See the\n', ' * xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategies] for more\n', ' * information on how to use the pre-built {GSNRecipientSignature} and\n', ' * {GSNRecipientERC20Fee}, or how to write your own.\n', ' */\n', 'contract GSNRecipient is IRelayRecipient, Context {\n', '    // Default RelayHub address, deployed on mainnet and all testnets at the same address\n', '    address private _relayHub = 0xD216153c06E857cD7f72665E0aF1d7D82172F494;\n', '\n', '    uint256 constant private RELAYED_CALL_ACCEPTED = 0;\n', '    uint256 constant private RELAYED_CALL_REJECTED = 11;\n', '\n', '    // How much gas is forwarded to postRelayedCall\n', '    uint256 constant internal POST_RELAYED_CALL_MAX_GAS = 100000;\n', '\n', '    /**\n', '     * @dev Emitted when a contract changes its {IRelayHub} contract to a new one.\n', '     */\n', '    event RelayHubChanged(address indexed oldRelayHub, address indexed newRelayHub);\n', '\n', '    /**\n', '     * @dev Returns the address of the {IRelayHub} contract for this recipient.\n', '     */\n', '    function getHubAddr() public view returns (address) {\n', '        return _relayHub;\n', '    }\n', '\n', '    /**\n', "     * @dev Switches to a new {IRelayHub} instance. This method is added for future-proofing: there's no reason to not\n", '     * use the default instance.\n', '     *\n', '     * IMPORTANT: After upgrading, the {GSNRecipient} will no longer be able to receive relayed calls from the old\n', '     * {IRelayHub} instance. Additionally, all funds should be previously withdrawn via {_withdrawDeposits}.\n', '     */\n', '    function _upgradeRelayHub(address newRelayHub) internal {\n', '        address currentRelayHub = _relayHub;\n', '        require(newRelayHub != address(0), "GSNRecipient: new RelayHub is the zero address");\n', '        require(newRelayHub != currentRelayHub, "GSNRecipient: new RelayHub is the current one");\n', '\n', '        emit RelayHubChanged(currentRelayHub, newRelayHub);\n', '\n', '        _relayHub = newRelayHub;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the version string of the {IRelayHub} for which this recipient implementation was built. If\n', '     * {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.\n', '     */\n', '    // This function is view for future-proofing, it may require reading from\n', '    // storage in the future.\n', '    function relayHubVersion() public view returns (string memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return "1.0.0";\n', '    }\n', '\n', '    /**\n', "     * @dev Withdraws the recipient's deposits in `RelayHub`.\n", '     *\n', '     * Derived contracts should expose this in an external interface with proper access control.\n', '     */\n', '    function _withdrawDeposits(uint256 amount, address payable payee) internal {\n', '        IRelayHub(_relayHub).withdraw(amount, payee);\n', '    }\n', '\n', "    // Overrides for Context's functions: when called from RelayHub, sender and\n", '    // data require some pre-processing: the actual sender is stored at the end\n', '    // of the call data, which in turns means it needs to be removed from it\n', '    // when handling said data.\n', '\n', '    /**\n', '     * @dev Replacement for msg.sender. Returns the actual sender of a transaction: msg.sender for regular transactions,\n', '     * and the end-user for GSN relayed calls (where msg.sender is actually `RelayHub`).\n', '     *\n', '     * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.sender`, and use {_msgSender} instead.\n', '     */\n', '    function _msgSender() internal view returns (address payable) {\n', '        if (msg.sender != _relayHub) {\n', '            return msg.sender;\n', '        } else {\n', '            return _getRelayedCallSender();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Replacement for msg.data. Returns the actual calldata of a transaction: msg.data for regular transactions,\n', '     * and a reduced version for GSN relayed calls (where msg.data contains additional information).\n', '     *\n', '     * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.data`, and use {_msgData} instead.\n', '     */\n', '    function _msgData() internal view returns (bytes memory) {\n', '        if (msg.sender != _relayHub) {\n', '            return msg.data;\n', '        } else {\n', '            return _getRelayedCallData();\n', '        }\n', '    }\n', '\n', '    // Base implementations for pre and post relayedCall: only RelayHub can invoke them, and data is forwarded to the\n', '    // internal hook.\n', '\n', '    /**\n', '     * @dev See `IRelayRecipient.preRelayedCall`.\n', '     *\n', '     * This function should not be overriden directly, use `_preRelayedCall` instead.\n', '     *\n', '     * * Requirements:\n', '     *\n', '     * - the caller must be the `RelayHub` contract.\n', '     */\n', '    function preRelayedCall(bytes calldata context) external returns (bytes32) {\n', '        require(msg.sender == getHubAddr(), "GSNRecipient: caller is not RelayHub");\n', '        return _preRelayedCall(context);\n', '    }\n', '\n', '    /**\n', '     * @dev See `IRelayRecipient.preRelayedCall`.\n', '     *\n', '     * Called by `GSNRecipient.preRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts\n', '     * must implement this function with any relayed-call preprocessing they may wish to do.\n', '     *\n', '     */\n', '    function _preRelayedCall(bytes memory context) internal returns (bytes32);\n', '\n', '    /**\n', '     * @dev See `IRelayRecipient.postRelayedCall`.\n', '     *\n', '     * This function should not be overriden directly, use `_postRelayedCall` instead.\n', '     *\n', '     * * Requirements:\n', '     *\n', '     * - the caller must be the `RelayHub` contract.\n', '     */\n', '    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external {\n', '        require(msg.sender == getHubAddr(), "GSNRecipient: caller is not RelayHub");\n', '        _postRelayedCall(context, success, actualCharge, preRetVal);\n', '    }\n', '\n', '    /**\n', '     * @dev See `IRelayRecipient.postRelayedCall`.\n', '     *\n', '     * Called by `GSNRecipient.postRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts\n', '     * must implement this function with any relayed-call postprocessing they may wish to do.\n', '     *\n', '     */\n', '    function _postRelayedCall(bytes memory context, bool success, uint256 actualCharge, bytes32 preRetVal) internal;\n', '\n', '    /**\n', '     * @dev Return this in acceptRelayedCall to proceed with the execution of a relayed call. Note that this contract\n', '     * will be charged a fee by RelayHub\n', '     */\n', '    function _approveRelayedCall() internal pure returns (uint256, bytes memory) {\n', '        return _approveRelayedCall("");\n', '    }\n', '\n', '    /**\n', '     * @dev See `GSNRecipient._approveRelayedCall`.\n', '     *\n', '     * This overload forwards `context` to _preRelayedCall and _postRelayedCall.\n', '     */\n', '    function _approveRelayedCall(bytes memory context) internal pure returns (uint256, bytes memory) {\n', '        return (RELAYED_CALL_ACCEPTED, context);\n', '    }\n', '\n', '    /**\n', '     * @dev Return this in acceptRelayedCall to impede execution of a relayed call. No fees will be charged.\n', '     */\n', '    function _rejectRelayedCall(uint256 errorCode) internal pure returns (uint256, bytes memory) {\n', '        return (RELAYED_CALL_REJECTED + errorCode, "");\n', '    }\n', '\n', '    /*\n', "     * @dev Calculates how much RelayHub will charge a recipient for using `gas` at a `gasPrice`, given a relayer's\n", '     * `serviceFee`.\n', '     */\n', '    function _computeCharge(uint256 gas, uint256 gasPrice, uint256 serviceFee) internal pure returns (uint256) {\n', '        // The fee is expressed as a percentage. E.g. a value of 40 stands for a 40% fee, so the recipient will be\n', '        // charged for 1.4 times the spent amount.\n', '        return (gas * gasPrice * (100 + serviceFee)) / 100;\n', '    }\n', '\n', '    function _getRelayedCallSender() private pure returns (address payable result) {\n', '        // We need to read 20 bytes (an address) located at array index msg.data.length - 20. In memory, the array\n', '        // is prefixed with a 32-byte length value, so we first add 32 to get the memory read index. However, doing\n', '        // so would leave the address in the upper 20 bytes of the 32-byte word, which is inconvenient and would\n', '        // require bit shifting. We therefore subtract 12 from the read index so the address lands on the lower 20\n', '        // bytes. This can always be done due to the 32-byte prefix.\n', '\n', '        // The final memory read index is msg.data.length - 20 + 32 - 12 = msg.data.length. Using inline assembly is the\n', '        // easiest/most-efficient way to perform this operation.\n', '\n', '        // These fields are not accessible from assembly\n', '        bytes memory array = msg.data;\n', '        uint256 index = msg.data.length;\n', '\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n', '            result := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n', '        }\n', '        return result;\n', '    }\n', '\n', '    function _getRelayedCallData() private pure returns (bytes memory) {\n', '        // RelayHub appends the sender address at the end of the calldata, so in order to retrieve the actual msg.data,\n', '        // we must strip the last 20 bytes (length of an address type) from it.\n', '\n', '        uint256 actualDataLength = msg.data.length - 20;\n', '        bytes memory actualData = new bytes(actualDataLength);\n', '\n', '        for (uint256 i = 0; i < actualDataLength; ++i) {\n', '            actualData[i] = msg.data[i];\n', '        }\n', '\n', '        return actualData;\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity = 0.5.16;\n', '\n', 'contract SimpleSale is Ownable, GSNRecipient {\n', '    using SafeMath for uint256;\n', '\n', '    enum ErrorCodes {\n', '        RESTRICTED_METHOD,\n', '        INSUFFICIENT_BALANCE\n', '    }\n', '\n', '    struct Price {\n', '        uint256 ethPrice;\n', '        uint256 erc20Price;\n', '    }\n', '\n', '    event Purchased(\n', '        string purchaseId,\n', '        address paymentToken,\n', '        uint256 price,\n', '        uint256 quantity,\n', '        address destination,\n', '        address operator\n', '    );\n', '\n', '    event PriceUpdated(\n', '        string purchaseId,\n', '        uint256 ethPrice,\n', '        uint256 erc20Price\n', '    );\n', '\n', '    address public ETH_ADDRESS = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '\n', '    address public _erc20Token;\n', '    address payable public _payoutWallet;\n', '\n', '    mapping(string => Price) public _prices; //  purchaseId => price in tokens\n', '\n', '    constructor(address payable payoutWallet, address erc20Token) public {\n', '        setPayoutWallet(payoutWallet);\n', '        _erc20Token = erc20Token;\n', '    }\n', '\n', '    function setPayoutWallet(address payable payoutWallet) public onlyOwner {\n', '        require(payoutWallet != address(0));\n', '        require(payoutWallet != address(this));\n', '        _payoutWallet = payoutWallet;\n', '    }\n', '\n', '    function setErc20Token(address erc20Token) public onlyOwner {\n', '        _erc20Token = erc20Token;\n', '    }\n', '    \n', '    function setPrice(string memory purchaseId, uint256 ethPrice, uint256 erc20TokenPrice) public onlyOwner {\n', '        _prices[purchaseId] = Price(ethPrice, erc20TokenPrice);\n', '        emit PriceUpdated(purchaseId, ethPrice, erc20TokenPrice);\n', '    }\n', '\n', '    function purchaseFor(\n', '        address destination,\n', '        string memory purchaseId,\n', '        uint256 quantity,\n', '        address paymentToken\n', '    ) public payable {\n', '        require(quantity > 0, "Quantity can\'t be 0");\n', '        require(paymentToken == ETH_ADDRESS || paymentToken == _erc20Token, "Unsupported payment token");\n', '\n', '        address payable sender = _msgSender();\n', '\n', '        Price memory price = _prices[purchaseId];\n', '\n', '        if (paymentToken == ETH_ADDRESS) {\n', '            require(price.ethPrice != 0, "purchaseId not found");\n', '            uint totalPrice = price.ethPrice.mul(quantity);\n', '            require(msg.value >= totalPrice, "Insufficient ETH");\n', '            _payoutWallet.transfer(totalPrice);\n', '\n', '            uint256 change = msg.value.sub(totalPrice);\n', '            if (change > 0) {\n', '                sender.transfer(change);\n', '            }\n', '            emit Purchased(purchaseId, paymentToken, price.ethPrice, quantity, destination, sender);\n', '        } else {\n', '            require(_erc20Token != address(0), "ERC20 payment not supported");\n', '            require(price.erc20Price != 0, "Price not found");\n', '            uint totalPrice = price.erc20Price.mul(quantity);\n', '            require(ERC20(_erc20Token).transferFrom(sender, _payoutWallet, totalPrice));\n', '            emit Purchased(purchaseId, paymentToken, price.erc20Price, quantity, destination, sender);\n', '        }\n', '    }\n', '\n', '    /////////////////////////////////////////// GSNRecipient implementation ///////////////////////////////////\n', '    /**\n', '     * @dev Ensures that only users with enough gas payment token balance can have transactions relayed through the GSN.\n', '     */\n', '    function acceptRelayedCall(\n', '        address /*relay*/,\n', '        address /*from*/,\n', '        bytes calldata encodedFunction,\n', '        uint256 /*transactionFee*/,\n', '        uint256 /*gasPrice*/,\n', '        uint256 /*gasLimit*/,\n', '        uint256 /*nonce*/,\n', '        bytes calldata /*approvalData*/,\n', '        uint256 /*maxPossibleCharge*/\n', '    )\n', '        external\n', '        view\n', '        returns (uint256, bytes memory mem)\n', '    {\n', '        // restrict to burn function only\n', '        // load methodId stored in first 4 bytes https://solidity.readthedocs.io/en/v0.5.16/abi-spec.html#function-selector-and-argument-encoding\n', '        // load amount stored in the next 32 bytes https://solidity.readthedocs.io/en/v0.5.16/abi-spec.html#function-selector-and-argument-encoding\n', '        // 32 bytes offset is required to skip array length\n', '        bytes4 methodId;\n', '        address recipient;\n', '        string memory purchaseId;\n', '        uint256 quantity;\n', '        address paymentToken;\n', '        mem = encodedFunction;\n', '        assembly {\n', '            let dest := add(mem, 32)\n', '            methodId := mload(dest)\n', '            dest := add(dest, 4)\n', '            recipient := mload(dest)\n', '            dest := add(dest, 32)\n', '            purchaseId := mload(dest)\n', '            dest := add(dest, 32)\n', '            quantity := mload(dest)\n', '            dest := add(dest, 32)\n', '            paymentToken := mload(dest)\n', '        }\n', '\n', '        // bytes4(keccak256("purchaseFor(address,string,uint256,address)")) == 0xwwwwww\n', '        // if (methodId != 0xwwwwww) {\n', '            // return _rejectRelayedCall(uint256(ErrorCodes.RESTRICTED_METHOD));\n', '        // }\n', '\n', '        // Check that user has enough balance\n', '        // if (balanceOf(from) < amountParam) {\n', '        //     return _rejectRelayedCall(uint256(ErrorCodes.INSUFFICIENT_BALANCE));\n', '        // }\n', '\n', '        //TODO restrict to purchaseFor() and add validation checks\n', '\n', '        return _approveRelayedCall();\n', '    }\n', '\n', '    function _preRelayedCall(bytes memory) internal returns (bytes32) {\n', '        // solhint-disable-previous-line no-empty-blocks\n', '    }\n', '\n', '    function _postRelayedCall(bytes memory, bool, uint256, bytes32) internal {\n', '        // solhint-disable-previous-line no-empty-blocks\n', '    }\n', '\n', '    /**\n', "     * @dev Withdraws the recipient's deposits in `RelayHub`.\n", '     */\n', '    function withdrawDeposits(uint256 amount, address payable payee) external onlyOwner {\n', '        _withdrawDeposits(amount, payee);\n', '    }\n', '}']