['/**************************************************************************\n', ' *            ____        _                              \n', ' *           / ___|      | |     __ _  _   _   ___  _ __ \n', " *          | |    _____ | |    / _` || | | | / _ \\| '__|\n", ' *          | |___|_____|| |___| (_| || |_| ||  __/| |   \n', ' *           \\____|      |_____|\\__,_| \\__, | \\___||_|   \n', ' *                                     |___/             \n', ' * \n', ' **************************************************************************\n', ' *\n', ' *  The MIT License (MIT)\n', ' * SPDX-License-Identifier: MIT\n', ' *\n', ' * Copyright (c) 2016-2020 Cyril Lapinte\n', ' *\n', ' * Permission is hereby granted, free of charge, to any person obtaining\n', ' * a copy of this software and associated documentation files (the\n', ' * "Software"), to deal in the Software without restriction, including\n', ' * without limitation the rights to use, copy, modify, merge, publish,\n', ' * distribute, sublicense, and/or sell copies of the Software, and to\n', ' * permit persons to whom the Software is furnished to do so, subject to\n', ' * the following conditions:\n', ' *\n', ' * The above copyright notice and this permission notice shall be included\n', ' * in all copies or substantial portions of the Software.\n', ' *\n', ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n', ' * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n', ' * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n', ' * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n', ' * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n', ' * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n', ' * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', ' *\n', ' **************************************************************************\n', ' *\n', ' * Flatten Contract: TokenCore\n', ' *\n', ' * Git Commit:\n', ' * https://github.com/c-layer/contracts/commit/9993912325afde36151b04d0247ac9ea9ffa2a93\n', ' *\n', ' **************************************************************************/\n', '\n', '\n', '// File: @c-layer/common/contracts/interface/IProxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @title IProxy\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' **/\n', 'interface IProxy {\n', '\n', '  function core() external view returns (address);\n', '\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/Proxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' *   PR01: Only accessible by core\n', ' *   PR02: Core request should be successful\n', ' **/\n', 'contract Proxy is IProxy {\n', '\n', '  address public override core;\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than a core\n', '   */\n', '  modifier onlyCore {\n', '    require(core == msg.sender, "PR01");\n', '    _;\n', '  }\n', '\n', '  constructor(address _core) public {\n', '    core = _core;\n', '  }\n', '\n', '  /**\n', '   * @dev update the core\n', '   */\n', '  function updateCore(address _core)\n', '    public onlyCore returns (bool)\n', '  {\n', '    core = _core;\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev enforce static immutability (view)\n', '   * @dev in order to read core value through internal core delegateCall\n', '   */\n', '  function staticCallUint256() internal view returns (uint256 value) {\n', '    (bool status, bytes memory result) = core.staticcall(msg.data);\n', '    require(status, string(result));\n', '    value = abi.decode(result, (uint256));\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IAccessDefinitions.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IAccessDefinitions\n', ' * @dev IAccessDefinitions\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'contract IAccessDefinitions {\n', '\n', '  // Hardcoded role granting all - non sysop - privileges\n', '  bytes32 internal constant ALL_PRIVILEGES = bytes32("AllPrivileges");\n', '  address internal constant ALL_PROXIES = address(0x416c6C50726F78696573); // "AllProxies"\n', '\n', '  // Roles\n', '  bytes32 internal constant FACTORY_CORE_ROLE = bytes32("FactoryCoreRole");\n', '  bytes32 internal constant FACTORY_PROXY_ROLE = bytes32("FactoryProxyRole");\n', '\n', '  // Sys Privileges\n', '  bytes4 internal constant DEFINE_ROLE_PRIV =\n', '    bytes4(keccak256("defineRole(bytes32,bytes4[])"));\n', '  bytes4 internal constant ASSIGN_OPERATORS_PRIV =\n', '    bytes4(keccak256("assignOperators(bytes32,address[])"));\n', '  bytes4 internal constant REVOKE_OPERATORS_PRIV =\n', '    bytes4(keccak256("revokeOperators(address[])"));\n', '  bytes4 internal constant ASSIGN_PROXY_OPERATORS_PRIV =\n', '    bytes4(keccak256("assignProxyOperators(address,bytes32,address[])"));\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IOperableStorage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title IOperableStorage\n', ' * @dev The Operable storage\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'abstract contract IOperableStorage is IAccessDefinitions {\n', '  function proxyDelegateId(address _proxy) virtual public view returns (uint256);\n', '  function delegate(uint256 _delegateId) virtual public view returns (address);\n', '\n', '  function coreRole(address _address) virtual public view returns (bytes32);\n', '  function proxyRole(address _proxy, address _address) virtual public view returns (bytes32);\n', '  function rolePrivilege(bytes32 _role, bytes4 _privilege) virtual public view returns (bool);\n', '  function roleHasPrivilege(bytes32 _role, bytes4 _privilege) virtual public view returns (bool);\n', '  function hasCorePrivilege(address _address, bytes4 _privilege) virtual public view returns (bool);\n', '  function hasProxyPrivilege(address _address, address _proxy, bytes4 _privilege) virtual public view returns (bool);\n', '\n', '  event RoleDefined(bytes32 role);\n', '  event OperatorAssigned(bytes32 role, address operator);\n', '  event ProxyOperatorAssigned(address proxy, bytes32 role, address operator);\n', '  event OperatorRevoked(address operator);\n', '  event ProxyOperatorRevoked(address proxy, address operator);\n', '\n', '  event ProxyDefined(address proxy, uint256 delegateId);\n', '  event ProxyMigrated(address proxy, address newCore);\n', '  event ProxyRemoved(address proxy);\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IOperableCore.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title IOperableCore\n', ' * @dev The Operable contract enable the restrictions of operations to a set of operators\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'abstract contract IOperableCore is IOperableStorage {\n', '  function defineRole(bytes32 _role, bytes4[] memory _privileges) virtual public returns (bool);\n', '  function assignOperators(bytes32 _role, address[] memory _operators) virtual public returns (bool);\n', '  function assignProxyOperators(\n', '    address _proxy, bytes32 _role, address[] memory _operators) virtual public returns (bool);\n', '  function revokeOperators(address[] memory _operators) virtual public returns (bool);\n', '  function revokeProxyOperators(address _proxy, address[] memory _operators) virtual public returns (bool);\n', '\n', '  function defineProxy(address _proxy, uint256 _delegateId) virtual public returns (bool);\n', '  function migrateProxy(address _proxy, address _newCore) virtual public returns (bool);\n', '  function removeProxy(address _proxy) virtual public returns (bool);\n', '}\n', '\n', '// File: @c-layer/common/contracts/operable/Ownable.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * @dev functions, this simplifies the implementation of "user permissions".\n', ' *\n', ' *\n', ' * Error messages\n', ' *   OW01: Message sender is not the owner\n', ' *   OW02: New owner must be valid\n', '*/\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner, "OW01");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address _newOwner) public onlyOwner {\n', '    _transferOwnership(_newOwner);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function _transferOwnership(address _newOwner) internal {\n', '    require(_newOwner != address(0), "OW02");\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/Storage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title Storage\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' **/\n', 'contract Storage {\n', '  mapping(address => uint256) internal proxyDelegateIds;\n', '  mapping(uint256 => address) internal delegates;\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/OperableStorage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title OperableStorage\n', ' * @dev The Operable contract enable the restrictions of operations to a set of operators\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'contract OperableStorage is IOperableStorage, Ownable, Storage {\n', '\n', '  struct RoleData {\n', '    mapping(bytes4 => bool) privileges;\n', '  }\n', '\n', '  struct OperatorData {\n', '    bytes32 coreRole;\n', '    mapping(address => bytes32) proxyRoles;\n', '  }\n', '\n', '  // Mapping address => role\n', '  // Mapping role => bytes4 => bool\n', '  mapping (address => OperatorData) internal operators;\n', '  mapping (bytes32 => RoleData) internal roles;\n', '\n', '  /**\n', '   * @dev proxyDelegateId\n', '   */\n', '  function proxyDelegateId(address _proxy) override public view returns (uint256) {\n', '    return proxyDelegateIds[_proxy];\n', '  }\n', '\n', '  /**\n', '   * @dev delegate\n', '   */\n', '  function delegate(uint256 _delegateId) override public view returns (address) {\n', '    return delegates[_delegateId];\n', '  }\n', '\n', '  /**\n', '   * @dev core role\n', '   * @param _address operator address\n', '   */\n', '  function coreRole(address _address) override public view returns (bytes32) {\n', '    return operators[_address].coreRole;\n', '  }\n', '\n', '  /**\n', '   * @dev proxy role\n', '   * @param _address operator address\n', '   */\n', '  function proxyRole(address _proxy, address _address)\n', '    override public view returns (bytes32)\n', '  {\n', '    return operators[_address].proxyRoles[_proxy];\n', '  }\n', '\n', '  /**\n', '   * @dev has role privilege\n', '   * @dev low level access to role privilege\n', '   * @dev ignores ALL_PRIVILEGES role\n', '   */\n', '  function rolePrivilege(bytes32 _role, bytes4 _privilege)\n', '    override public view returns (bool)\n', '  {\n', '    return roles[_role].privileges[_privilege];\n', '  }\n', '\n', '  /**\n', '   * @dev roleHasPrivilege\n', '   */\n', '  function roleHasPrivilege(bytes32 _role, bytes4 _privilege) override public view returns (bool) {\n', '    return (_role == ALL_PRIVILEGES) || roles[_role].privileges[_privilege];\n', '  }\n', '\n', '  /**\n', '   * @dev hasCorePrivilege\n', '   * @param _address operator address\n', '   */\n', '  function hasCorePrivilege(address _address, bytes4 _privilege) override public view returns (bool) {\n', '    bytes32 role = operators[_address].coreRole;\n', '    return (role == ALL_PRIVILEGES) || roles[role].privileges[_privilege];\n', '  }\n', '\n', '  /**\n', '   * @dev hasProxyPrivilege\n', '   * @dev the default proxy role can be set with proxy address(0)\n', '   * @param _address operator address\n', '   */\n', '  function hasProxyPrivilege(address _address, address _proxy, bytes4 _privilege) override public view returns (bool) {\n', '    OperatorData storage data = operators[_address];\n', '    bytes32 role = (data.proxyRoles[_proxy] != bytes32(0)) ?\n', '      data.proxyRoles[_proxy] : data.proxyRoles[ALL_PROXIES];\n', '    return (role == ALL_PRIVILEGES) || roles[role].privileges[_privilege];\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/call/DelegateCall.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title DelegateCall\n', ' * @dev Calls delegates for non view functions only\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error Messages:\n', ' **/\n', 'library DelegateCall {\n', '\n', '  function _delegateCall(address _delegate) internal virtual returns (bool status)\n', '  {\n', '    bytes memory result;\n', '    // solhint-disable-next-line avoid-low-level-calls\n', '    (status, result) = _delegate.delegatecall(msg.data);\n', '    require(status, string(result));\n', '  }\n', '\n', '  function _delegateCallBool(address _delegate) internal returns (bool status)\n', '  {\n', '    return abi.decode(_delegateCallBytes(_delegate), (bool));\n', '  }\n', '\n', '  function _delegateCallUint256(address _delegate) internal returns (uint256)\n', '  {\n', '    return abi.decode(_delegateCallBytes(_delegate), (uint256));\n', '  }\n', '\n', '  function _delegateCallBytes(address _delegate)\n', '    internal returns (bytes memory result)\n', '  {\n', '    bool status;\n', '    // solhint-disable-next-line avoid-low-level-calls\n', '    (status, result) = _delegate.delegatecall(msg.data);\n', '    require(status, string(result));\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/Core.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Core\n', ' * @dev Solidity version 0.5.x prevents to mark as view\n', ' * @dev functions using delegate call.\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' *   CO01: Only Proxy may access the function\n', ' *   CO02: Address 0 is an invalid delegate address\n', ' *   CO03: Delegatecall should be successful\n', ' *   CO04: DelegateId must be greater than 0\n', ' *   CO05: Proxy must exist\n', ' *   CO06: Proxy must be already defined\n', ' *   CO07: Proxy update must be successful\n', ' **/\n', 'contract Core is Storage {\n', '  using DelegateCall for address;\n', '\n', '  modifier onlyProxy {\n', '    require(delegates[proxyDelegateIds[msg.sender]] != address(0), "CO01");\n', '    _;\n', '  }\n', '\n', '  function validProxyDelegate(address _proxy) internal view returns (address delegate) {\n', '    uint256 delegateId = proxyDelegateIds[_proxy];\n', '    delegate = delegates[delegateId];\n', '    require(delegate != address(0), "CO02");\n', '  }\n', '\n', '  function delegateCall(address _proxy) internal returns (bool status)\n', '  {\n', '    return validProxyDelegate(_proxy)._delegateCall();\n', '  }\n', '\n', '  function delegateCallBool(address _proxy)\n', '    internal returns (bool)\n', '  {\n', '    return validProxyDelegate(_proxy)._delegateCallBool();\n', '  }\n', '\n', '  function delegateCallUint256(address _proxy)\n', '    internal returns (uint256)\n', '  {\n', '    return validProxyDelegate(_proxy)._delegateCallUint256();\n', '  }\n', '\n', '  function delegateCallBytes(address _proxy)\n', '    internal returns (bytes memory result)\n', '  {\n', '    return validProxyDelegate(_proxy)._delegateCallBytes();\n', '  }\n', '\n', '  function defineDelegateInternal(uint256 _delegateId, address _delegate) internal returns (bool) {\n', '    require(_delegateId != 0, "CO04");\n', '    delegates[_delegateId] = _delegate;\n', '    return true;\n', '  }\n', '\n', '  function defineProxyInternal(address _proxy, uint256 _delegateId)\n', '    virtual internal returns (bool)\n', '  {\n', '    require(delegates[_delegateId] != address(0), "CO02");\n', '    require(_proxy != address(0), "CO05");\n', '\n', '    proxyDelegateIds[_proxy] = _delegateId;\n', '    return true;\n', '  }\n', '\n', '  function migrateProxyInternal(address _proxy, address _newCore)\n', '    internal returns (bool)\n', '  {\n', '    require(proxyDelegateIds[_proxy] != 0, "CO06");\n', '    require(Proxy(_proxy).updateCore(_newCore), "CO07");\n', '    return true;\n', '  }\n', '\n', '  function removeProxyInternal(address _proxy)\n', '    internal virtual returns (bool)\n', '  {\n', '    require(proxyDelegateIds[_proxy] != 0, "CO06");\n', '    delete proxyDelegateIds[_proxy];\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/OperableCore.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title OperableCore\n', ' * @dev The Operable contract enable the restrictions of operations to a set of operators\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' *   OC01: Sender is not a system operator\n', ' *   OC02: Sender is not a core operator\n', ' *   OC03: Sender is not a proxy operator\n', ' *   OC04: Role must not be null\n', ' *   OC05: AllPrivileges is a reserved role\n', ' *   OC06: AllProxies is not a valid proxy address\n', ' *   OC07: Proxy must be valid\n', ' *   OC08: Operator has no role\n', ' */\n', 'contract OperableCore is IOperableCore, Core, OperableStorage {\n', '\n', '  constructor(address[] memory _sysOperators) public {\n', '    assignOperators(ALL_PRIVILEGES, _sysOperators);\n', '    assignProxyOperators(ALL_PROXIES, ALL_PRIVILEGES, _sysOperators);\n', '  }\n', '\n', '  /**\n', '   * @dev onlySysOp modifier\n', '   * @dev for safety reason, core owner\n', '   * @dev can always define roles and assign or revoke operatos\n', '   */\n', '  modifier onlySysOp() {\n', '    require(msg.sender == owner || hasCorePrivilege(msg.sender, msg.sig), "OC01");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev onlyCoreOp modifier\n', '   */\n', '  modifier onlyCoreOp() {\n', '    require(hasCorePrivilege(msg.sender, msg.sig), "OC02");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev onlyProxyOp modifier\n', '   */\n', '  modifier onlyProxyOp(address _proxy) {\n', '    require(hasProxyPrivilege(msg.sender, _proxy, msg.sig), "OC03");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev defineRoles\n', '   * @param _role operator role\n', '   * @param _privileges as 4 bytes of the method\n', '   */\n', '  function defineRole(bytes32 _role, bytes4[] memory _privileges)\n', '    override public onlySysOp returns (bool)\n', '  {\n', '    require(_role != bytes32(0), "OC04");\n', '    require(_role != ALL_PRIVILEGES, "OC05");\n', '\n', '    delete roles[_role];\n', '    for (uint256 i=0; i < _privileges.length; i++) {\n', '      roles[_role].privileges[_privileges[i]] = true;\n', '    }\n', '    emit RoleDefined(_role);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev assignOperators\n', '   * @param _role operator role. May be a role not defined yet.\n', '   * @param _operators addresses\n', '   */\n', '  function assignOperators(bytes32 _role, address[] memory _operators)\n', '    override public onlySysOp returns (bool)\n', '  {\n', '    require(_role != bytes32(0), "OC04");\n', '\n', '    for (uint256 i=0; i < _operators.length; i++) {\n', '      operators[_operators[i]].coreRole = _role;\n', '      emit OperatorAssigned(_role, _operators[i]);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev assignProxyOperators\n', '   * @param _role operator role. May be a role not defined yet.\n', '   * @param _operators addresses\n', '   */\n', '  function assignProxyOperators(\n', '    address _proxy, bytes32 _role, address[] memory _operators)\n', '    override public onlySysOp returns (bool)\n', '  {\n', '    require(_proxy == ALL_PROXIES ||\n', '      delegates[proxyDelegateIds[_proxy]] != address(0), "OC07");\n', '    require(_role != bytes32(0), "OC04");\n', '\n', '    for (uint256 i=0; i < _operators.length; i++) {\n', '      operators[_operators[i]].proxyRoles[_proxy] = _role;\n', '      emit ProxyOperatorAssigned(_proxy, _role, _operators[i]);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev revokeOperator\n', '   * @param _operators addresses\n', '   */\n', '  function revokeOperators(address[] memory _operators)\n', '    override public onlySysOp returns (bool)\n', '  {\n', '    for (uint256 i=0; i < _operators.length; i++) {\n', '      OperatorData storage operator = operators[_operators[i]];\n', '      require(operator.coreRole != bytes32(0), "OC08");\n', '      operator.coreRole = bytes32(0);\n', '\n', '      emit OperatorRevoked(_operators[i]);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev revokeProxyOperator\n', '   * @param _operators addresses\n', '   */\n', '  function revokeProxyOperators(address _proxy, address[] memory _operators)\n', '    override public onlySysOp returns (bool)\n', '  {\n', '    for (uint256 i=0; i < _operators.length; i++) {\n', '      OperatorData storage operator = operators[_operators[i]];\n', '      require(operator.proxyRoles[_proxy] != bytes32(0), "OC08");\n', '      operator.proxyRoles[_proxy] = bytes32(0);\n', '\n', '      emit ProxyOperatorRevoked(_proxy, _operators[i]);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function defineProxy(address _proxy, uint256 _delegateId)\n', '    override public onlyCoreOp returns (bool)\n', '  {\n', '    require(_proxy != ALL_PROXIES, "OC06");\n', '    defineProxyInternal(_proxy, _delegateId);\n', '    emit ProxyDefined(_proxy, _delegateId);\n', '    return true;\n', '  }\n', '\n', '  function migrateProxy(address _proxy, address _newCore)\n', '    override public onlyCoreOp returns (bool)\n', '  {\n', '    migrateProxyInternal(_proxy, _newCore);\n', '    emit ProxyMigrated(_proxy, _newCore);\n', '    return true;\n', '  }\n', '\n', '  function removeProxy(address _proxy)\n', '    override public onlyCoreOp returns (bool)\n', '  {\n', '    removeProxyInternal(_proxy);\n', '    emit ProxyRemoved(_proxy);\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/core/OperableProxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title OperableProxy\n', ' * @dev The OperableAs contract enable the restrictions of operations to a set of operators\n', ' * @dev It relies on another Operable contract and reuse the same list of operators\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' * OP01: Message sender must be authorized\n', ' */\n', 'contract OperableProxy is Proxy {\n', '\n', '  // solhint-disable-next-line no-empty-blocks\n', '  constructor(address _core) public Proxy(_core) { }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the operator\n', '   */\n', '  modifier onlyOperator {\n', '    require(OperableCore(core).hasProxyPrivilege(\n', '      msg.sender, address(this), msg.sig), "OP01");\n', '    _;\n', '  }\n', '}\n', '\n', '// File: @c-layer/common/contracts/interface/IERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' *\n', ' */\n', 'interface IERC20 {\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '\n', '  function name() external view returns (string memory);\n', '  function symbol() external view returns (string memory);\n', '  function decimals() external view returns (uint256);\n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address _owner) external view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '\n', '  function allowance(address _owner, address _spender)\n', '    external view returns (uint256);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    external returns (bool);\n', '\n', '  function approve(address _spender, uint256 _value) external returns (bool);\n', '\n', '  function increaseApproval(address _spender, uint256 _addedValue)\n', '    external returns (bool);\n', '\n', '  function decreaseApproval(address _spender, uint256 _subtractedValue)\n', '    external returns (bool);\n', '}\n', '\n', '// File: contracts/interface/ITokenProxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title IToken proxy\n', ' * @dev Token proxy interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'abstract contract ITokenProxy is IERC20, Proxy {\n', '\n', '  function canTransfer(address, address, uint256)\n', '    virtual public view returns (uint256);\n', '\n', '  function emitTransfer(address _from, address _to, uint256 _value)\n', '    virtual public returns (bool);\n', '\n', '  function emitApproval(address _owner, address _spender, uint256 _value)\n', '    virtual public returns (bool);\n', '}\n', '\n', '// File: @c-layer/common/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/interface/IRule.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IRule\n', ' * @dev IRule interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' **/\n', 'interface IRule {\n', '  function isAddressValid(address _address) external view returns (bool);\n', '  function isTransferValid(address _from, address _to, uint256 _amount)\n', '    external view returns (bool);\n', '}\n', '\n', '// File: @c-layer/oracle/contracts/interface/IUserRegistry.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IUserRegistry\n', ' * @dev IUserRegistry interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' **/\n', 'abstract contract IUserRegistry {\n', '\n', '  enum KeyCode {\n', '    KYC_LIMIT_KEY,\n', '    RECEPTION_LIMIT_KEY,\n', '    EMISSION_LIMIT_KEY\n', '  }\n', '\n', '  event UserRegistered(uint256 indexed userId, address address_, uint256 validUntilTime);\n', '  event AddressAttached(uint256 indexed userId, address address_);\n', '  event AddressDetached(uint256 indexed userId, address address_);\n', '  event UserSuspended(uint256 indexed userId);\n', '  event UserRestored(uint256 indexed userId);\n', '  event UserValidity(uint256 indexed userId, uint256 validUntilTime);\n', '  event UserExtendedKey(uint256 indexed userId, uint256 key, uint256 value);\n', '  event UserExtendedKeys(uint256 indexed userId, uint256[] values);\n', '  event ExtendedKeysDefinition(uint256[] keys);\n', '\n', '  function registerManyUsersExternal(address[] calldata _addresses, uint256 _validUntilTime)\n', '    virtual external returns (bool);\n', '  function registerManyUsersFullExternal(\n', '    address[] calldata _addresses,\n', '    uint256 _validUntilTime,\n', '    uint256[] calldata _values) virtual external returns (bool);\n', '  function attachManyAddressesExternal(uint256[] calldata _userIds, address[] calldata _addresses)\n', '    virtual external returns (bool);\n', '  function detachManyAddressesExternal(address[] calldata _addresses)\n', '    virtual external returns (bool);\n', '  function suspendManyUsersExternal(uint256[] calldata _userIds) virtual external returns (bool);\n', '  function restoreManyUsersExternal(uint256[] calldata _userIds) virtual external returns (bool);\n', '  function updateManyUsersExternal(\n', '    uint256[] calldata _userIds,\n', '    uint256 _validUntilTime,\n', '    bool _suspended) virtual external returns (bool);\n', '  function updateManyUsersExtendedExternal(\n', '    uint256[] calldata _userIds,\n', '    uint256 _key, uint256 _value) virtual external returns (bool);\n', '  function updateManyUsersAllExtendedExternal(\n', '    uint256[] calldata _userIds,\n', '    uint256[] calldata _values) virtual external returns (bool);\n', '  function updateManyUsersFullExternal(\n', '    uint256[] calldata _userIds,\n', '    uint256 _validUntilTime,\n', '    bool _suspended,\n', '    uint256[] calldata _values) virtual external returns (bool);\n', '\n', '  function name() virtual public view returns (string memory);\n', '  function currency() virtual public view returns (bytes32);\n', '\n', '  function userCount() virtual public view returns (uint256);\n', '  function userId(address _address) virtual public view returns (uint256);\n', '  function validUserId(address _address) virtual public view returns (uint256);\n', '  function validUser(address _address, uint256[] memory _keys)\n', '    virtual public view returns (uint256, uint256[] memory);\n', '  function validity(uint256 _userId) virtual public view returns (uint256, bool);\n', '\n', '  function extendedKeys() virtual public view returns (uint256[] memory);\n', '  function extended(uint256 _userId, uint256 _key)\n', '    virtual public view returns (uint256);\n', '  function manyExtended(uint256 _userId, uint256[] memory _key)\n', '    virtual public view returns (uint256[] memory);\n', '\n', '  function isAddressValid(address _address) virtual public view returns (bool);\n', '  function isValid(uint256 _userId) virtual public view returns (bool);\n', '\n', '  function defineExtendedKeys(uint256[] memory _extendedKeys) virtual public returns (bool);\n', '\n', '  function registerUser(address _address, uint256 _validUntilTime)\n', '    virtual public returns (bool);\n', '  function registerUserFull(\n', '    address _address,\n', '    uint256 _validUntilTime,\n', '    uint256[] memory _values) virtual public returns (bool);\n', '\n', '  function attachAddress(uint256 _userId, address _address) virtual public returns (bool);\n', '  function detachAddress(address _address) virtual public returns (bool);\n', '  function detachSelf() virtual public returns (bool);\n', '  function detachSelfAddress(address _address) virtual public returns (bool);\n', '  function suspendUser(uint256 _userId) virtual public returns (bool);\n', '  function restoreUser(uint256 _userId) virtual public returns (bool);\n', '  function updateUser(uint256 _userId, uint256 _validUntilTime, bool _suspended)\n', '    virtual public returns (bool);\n', '  function updateUserExtended(uint256 _userId, uint256 _key, uint256 _value)\n', '    virtual public returns (bool);\n', '  function updateUserAllExtended(uint256 _userId, uint256[] memory _values)\n', '    virtual public returns (bool);\n', '  function updateUserFull(\n', '    uint256 _userId,\n', '    uint256 _validUntilTime,\n', '    bool _suspended,\n', '    uint256[] memory _values) virtual public returns (bool);\n', '}\n', '\n', '// File: @c-layer/oracle/contracts/interface/IRatesProvider.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title IRatesProvider\n', ' * @dev IRatesProvider interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'abstract contract IRatesProvider {\n', '\n', '  function defineRatesExternal(uint256[] calldata _rates) virtual external returns (bool);\n', '\n', '  function name() virtual public view returns (string memory);\n', '\n', '  function rate(bytes32 _currency) virtual public view returns (uint256);\n', '\n', '  function currencies() virtual public view\n', '    returns (bytes32[] memory, uint256[] memory, uint256);\n', '  function rates() virtual public view returns (uint256, uint256[] memory);\n', '\n', '  function convert(uint256 _amount, bytes32 _fromCurrency, bytes32 _toCurrency)\n', '    virtual public view returns (uint256);\n', '\n', '  function defineCurrencies(\n', '    bytes32[] memory _currencies,\n', '    uint256[] memory _decimals,\n', '    uint256 _rateOffset) virtual public returns (bool);\n', '  function defineRates(uint256[] memory _rates) virtual public returns (bool);\n', '\n', '  event RateOffset(uint256 rateOffset);\n', '  event Currencies(bytes32[] currencies, uint256[] decimals);\n', '  event Rate(bytes32 indexed currency, uint256 rate);\n', '}\n', '\n', '// File: contracts/interface/ITokenStorage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ITokenStorage\n', ' * @dev Token storage interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'abstract contract ITokenStorage {\n', '  enum TransferCode {\n', '    UNKNOWN,\n', '    OK,\n', '    INVALID_SENDER,\n', '    NO_RECIPIENT,\n', '    INSUFFICIENT_TOKENS,\n', '    LOCKED,\n', '    FROZEN,\n', '    RULE,\n', '    INVALID_RATE,\n', '    NON_REGISTRED_SENDER,\n', '    NON_REGISTRED_RECEIVER,\n', '    LIMITED_EMISSION,\n', '    LIMITED_RECEPTION\n', '  }\n', '\n', '  enum Scope {\n', '    DEFAULT\n', '  }\n', '\n', '  enum AuditStorageMode {\n', '    ADDRESS,\n', '    USER_ID,\n', '    SHARED\n', '  }\n', '\n', '  enum AuditTriggerMode {\n', '    UNDEFINED,\n', '    NONE,\n', '    SENDER_ONLY,\n', '    RECEIVER_ONLY,\n', '    BOTH\n', '  }\n', '\n', '  address internal constant ANY_ADDRESSES = address(0x416e79416464726573736573); // "AnyAddresses"\n', '\n', '  event OracleDefined(\n', '    IUserRegistry userRegistry,\n', '    IRatesProvider ratesProvider,\n', '    address currency);\n', '  event TokenDelegateDefined(uint256 indexed delegateId, address delegate, uint256[] configurations);\n', '  event TokenDelegateRemoved(uint256 indexed delegateId);\n', '  event AuditConfigurationDefined(\n', '    uint256 indexed configurationId,\n', '    uint256 scopeId,\n', '    AuditTriggerMode mode,\n', '    uint256[] senderKeys,\n', '    uint256[] receiverKeys,\n', '    IRatesProvider ratesProvider,\n', '    address currency);\n', '  event AuditTriggersDefined(\n', '    uint256 indexed configurationId,\n', '    address[] senders,\n', '    address[] receivers,\n', '    AuditTriggerMode[] modes);\n', '  event AuditsRemoved(address scope, uint256 scopeId);\n', '  event SelfManaged(address indexed holder, bool active);\n', '\n', '  event Minted(address indexed token, uint256 amount);\n', '  event MintFinished(address indexed token);\n', '  event Burned(address indexed token, uint256 amount);\n', '  event RulesDefined(address indexed token, IRule[] rules);\n', '  event LockDefined(\n', '    address indexed lock,\n', '    address sender,\n', '    address receiver,\n', '    uint256 startAt,\n', '    uint256 endAt\n', '  );\n', '  event Seize(address indexed token, address account, uint256 amount);\n', '  event Freeze(address address_, uint256 until);\n', '  event ClaimDefined(\n', '    address indexed token,\n', '    address indexed claim,\n', '    uint256 claimAt);\n', '  event TokenLocksDefined(\n', '    address indexed token,\n', '    address[] locks);\n', '  event TokenDefined(\n', '    address indexed token,\n', '    string name,\n', '    string symbol,\n', '    uint256 decimals);\n', '  event LogTransferData(\n', '    address token, address caller, address sender, address receiver,\n', '    uint256 senderId, uint256[] senderKeys, bool senderFetched,\n', '    uint256 receiverId, uint256[] receiverKeys, bool receiverFetched,\n', '    uint256 value, uint256 convertedValue);\n', '  event LogTransferAuditData(\n', '    uint256 auditConfigurationId, uint256 scopeId,\n', '    address currency, IRatesProvider ratesProvider,\n', '    bool senderAuditRequired, bool receiverAuditRequired);\n', '  event LogAuditData(\n', '    uint64 createdAt, uint64 lastTransactionAt,\n', '    uint256 cumulatedEmission, uint256 cumulatedReception\n', '  );\n', '}\n', '\n', '// File: contracts/TokenStorage.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Token storage\n', ' * @dev Token storage\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'contract TokenStorage is ITokenStorage, OperableStorage {\n', '  using SafeMath for uint256;\n', '\n', '  struct LockData {\n', '    uint64 startAt;\n', '    uint64 endAt;\n', '  }\n', '\n', '  struct TokenData {\n', '    string name;\n', '    string symbol;\n', '    uint256 decimals;\n', '\n', '    uint256 totalSupply;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowances;\n', '\n', '    bool mintingFinished;\n', '\n', '    uint256 allTimeMinted;\n', '    uint256 allTimeBurned;\n', '    uint256 allTimeSeized;\n', '\n', '    mapping (address => uint256) frozenUntils;\n', '    address[] locks;\n', '    IRule[] rules;\n', '  }\n', '\n', '  struct AuditData {\n', '    uint64 createdAt;\n', '    uint64 lastTransactionAt;\n', '    uint256 cumulatedEmission;\n', '    uint256 cumulatedReception;\n', '  }\n', '\n', '  struct AuditStorage {\n', '    address currency;\n', '\n', '    AuditData sharedData;\n', '    mapping(uint256 => AuditData) userData;\n', '    mapping(address => AuditData) addressData;\n', '  }\n', '\n', '  struct AuditConfiguration {\n', '    uint256 scopeId;\n', '\n', '    uint256[] senderKeys;\n', '    uint256[] receiverKeys;\n', '    IRatesProvider ratesProvider;\n', '\n', '    mapping (address => mapping(address => AuditTriggerMode)) triggers;\n', '  }\n', '\n', '  // AuditConfigurationId => AuditConfiguration\n', '  mapping (uint256 => AuditConfiguration) internal auditConfigurations;\n', '  // DelegateId => AuditConfigurationId[]\n', '  mapping (uint256 => uint256[]) internal delegatesConfigurations_;\n', '  mapping (address => TokenData) internal tokens;\n', '\n', '  // Scope x ScopeId => AuditStorage\n', '  mapping (address => mapping (uint256 => AuditStorage)) internal audits;\n', '\n', '  // Prevents operator to act on behalf\n', '  mapping (address => bool) internal selfManaged;\n', '\n', '  // Proxy x Sender x Receiver x LockData\n', '  mapping (address => mapping (address => mapping(address => LockData))) internal locks;\n', '\n', '  IUserRegistry internal userRegistry_;\n', '  IRatesProvider internal ratesProvider_;\n', '  address internal currency_;\n', '  string internal name_;\n', '\n', '  /**\n', '   * @dev currentTime()\n', '   */\n', '  function currentTime() internal view returns (uint64) {\n', '    // solhint-disable-next-line not-rely-on-time\n', '    return uint64(now);\n', '  }\n', '}\n', '\n', '// File: contracts/interface/ITokenCore.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ITokenCore\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' **/\n', 'abstract contract ITokenCore is ITokenStorage, IOperableCore {\n', '\n', '  function name() virtual public view returns (string memory);\n', '  function oracle() virtual public view returns (\n', '    IUserRegistry userRegistry,\n', '    IRatesProvider ratesProvider,\n', '    address currency);\n', '\n', '  function auditConfiguration(uint256 _configurationId)\n', '    virtual public view returns (\n', '      uint256 scopeId,\n', '      AuditTriggerMode _mode,\n', '      uint256[] memory senderKeys,\n', '      uint256[] memory receiverKeys,\n', '      IRatesProvider ratesProvider,\n', '      address currency);\n', '  function auditTrigger(uint256 _configurationId, address _sender, address _receiver)\n', '    virtual public view returns (AuditTriggerMode);\n', '  function delegatesConfigurations(uint256 _delegateId)\n', '    virtual public view returns (uint256[] memory);\n', '\n', '  function auditCurrency(\n', '    address _scope,\n', '    uint256 _scopeId\n', '  ) virtual external view returns (address currency);\n', '  function audit(\n', '    address _scope,\n', '    uint256 _scopeId,\n', '    AuditStorageMode _storageMode,\n', '    bytes32 _storageId) virtual external view returns (\n', '    uint64 createdAt,\n', '    uint64 lastTransactionAt,\n', '    uint256 cumulatedEmission,\n', '    uint256 cumulatedReception);\n', '\n', '  /**************  ERC20  **************/\n', '  function tokenName() virtual external view returns (string memory);\n', '  function tokenSymbol() virtual external view returns (string memory);\n', '\n', '  function decimals() virtual external returns (uint256);\n', '  function totalSupply() virtual external returns (uint256);\n', '  function balanceOf(address) virtual external returns (uint256);\n', '  function allowance(address, address) virtual external returns (uint256);\n', '  function transfer(address, address, uint256)\n', '    virtual external returns (bool status);\n', '  function transferFrom(address, address, address, uint256)\n', '    virtual external returns (bool status);\n', '  function approve(address, address, uint256)\n', '    virtual external returns (bool status);\n', '  function increaseApproval(address, address, uint256)\n', '    virtual external returns (bool status);\n', '  function decreaseApproval(address, address, uint256)\n', '    virtual external returns (bool status);\n', '\n', '  /***********  TOKEN DATA   ***********/\n', '  function token(address _token) virtual external view returns (\n', '    bool mintingFinished,\n', '    uint256 allTimeMinted,\n', '    uint256 allTimeBurned,\n', '    uint256 allTimeSeized,\n', '    address[] memory locks,\n', '    uint256 freezedUntil,\n', '    IRule[] memory);\n', '  function lock(address _lock, address _sender, address _receiver) virtual external view returns (\n', '    uint64 startAt, uint64 endAt);\n', '  function canTransfer(address, address, uint256)\n', '    virtual external returns (uint256);\n', '\n', '  /***********  TOKEN ADMIN  ***********/\n', '  function mint(address, address[] calldata, uint256[] calldata)\n', '    virtual external returns (bool);\n', '  function finishMinting(address)\n', '    virtual external returns (bool);\n', '  function burn(address, uint256)\n', '    virtual external returns (bool);\n', '  function seize(address _token, address, uint256)\n', '    virtual external returns (bool);\n', '  function defineLock(address, address, address, uint64, uint64)\n', '    virtual external returns (bool);\n', '  function defineTokenLocks(address _token, address[] memory locks)\n', '    virtual external returns (bool);\n', '  function freezeManyAddresses(\n', '    address _token,\n', '    address[] calldata _addresses,\n', '    uint256 _until) virtual external returns (bool);\n', '  function defineRules(address, IRule[] calldata) virtual external returns (bool);\n', '\n', '  /************  CORE ADMIN  ************/\n', '  function defineToken(\n', '    address _token,\n', '    uint256 _delegateId,\n', '    string memory _name,\n', '    string memory _symbol,\n', '    uint256 _decimals) virtual external returns (bool);\n', '\n', '  function defineOracle(\n', '    IUserRegistry _userRegistry,\n', '    IRatesProvider _ratesProvider,\n', '    address _currency) virtual external returns (bool);\n', '  function defineTokenDelegate(\n', '    uint256 _delegateId,\n', '    address _delegate,\n', '    uint256[] calldata _configurations) virtual external returns (bool);\n', '  function defineAuditConfiguration(\n', '    uint256 _configurationId,\n', '    uint256 _scopeId,\n', '    AuditTriggerMode _mode,\n', '    uint256[] calldata _senderKeys,\n', '    uint256[] calldata _receiverKeys,\n', '    IRatesProvider _ratesProvider,\n', '    address _currency) virtual external returns (bool);\n', '  function removeAudits(address _scope, uint256 _scopeId)\n', '    virtual external returns (bool);\n', '  function defineAuditTriggers(\n', '    uint256 _configurationId,\n', '    address[] calldata _senders,\n', '    address[] calldata _receivers,\n', '    AuditTriggerMode[] calldata _modes) virtual external returns (bool);\n', '\n', '  function isSelfManaged(address _owner)\n', '    virtual external view returns (bool);\n', '  function manageSelf(bool _active)\n', '    virtual external returns (bool);\n', '}\n', '\n', '// File: contracts/interface/ITokenDelegate.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '/**\n', ' * @title Token Delegate Interface\n', ' * @dev Token Delegate Interface\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' */\n', 'abstract contract ITokenDelegate is ITokenStorage {\n', '\n', '  function decimals() virtual public view returns (uint256);\n', '  function totalSupply() virtual public view returns (uint256);\n', '  function balanceOf(address _owner) virtual public view returns (uint256);\n', '  function allowance(address _owner, address _spender)\n', '    virtual public view returns (uint256);\n', '  function transfer(address _sender, address _receiver, uint256 _value)\n', '    virtual public returns (bool);\n', '  function transferFrom(\n', '    address _caller, address _sender, address _receiver, uint256 _value)\n', '    virtual public returns (bool);\n', '  function canTransfer(\n', '    address _sender,\n', '    address _receiver,\n', '    uint256 _value) virtual public view returns (TransferCode);\n', '  function approve(address _sender, address _spender, uint256 _value)\n', '    virtual public returns (bool);\n', '  function increaseApproval(address _sender, address _spender, uint _addedValue)\n', '    virtual public returns (bool);\n', '  function decreaseApproval(address _sender, address _spender, uint _subtractedValue)\n', '    virtual public returns (bool);\n', '  function checkConfigurations(uint256[] memory _auditConfigurationIds)\n', '    virtual public returns (bool);\n', '}\n', '\n', '// File: contracts/TokenCore.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title TokenCore\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' *\n', ' * Error messages\n', ' *   TC01: Token cannot be equivalent to AllProxies\n', ' *   TC02: Currency stored values must remain consistent\n', ' *   TC03: Delegate has invalid audit configurations values\n', ' *   TC04: Mismatched between the configuration and the audit storage currency\n', ' *   TC05: The audit triggers definition requires the same number of addresses and values\n', ' **/\n', 'contract TokenCore is ITokenCore, OperableCore, TokenStorage {\n', '\n', '  /**\n', '   * @dev constructor\n', '   */\n', '  constructor(string memory _name, address[] memory _sysOperators)\n', '    public OperableCore(_sysOperators)\n', '  {\n', '    name_ = _name;\n', '  }\n', '\n', '  function name() override public view returns (string memory) {\n', '    return name_;\n', '  }\n', '\n', '  function oracle() override public view returns (\n', '    IUserRegistry userRegistry,\n', '    IRatesProvider ratesProvider,\n', '    address currency)\n', '  {\n', '    return (userRegistry_, ratesProvider_, currency_);\n', '  }\n', '\n', '  function auditConfiguration(uint256 _configurationId)\n', '    override public view returns (\n', '      uint256 scopeId,\n', '      AuditTriggerMode mode,\n', '      uint256[] memory senderKeys,\n', '      uint256[] memory receiverKeys,\n', '      IRatesProvider ratesProvider,\n', '      address currency)\n', '  {\n', '    AuditConfiguration storage auditConfiguration_ = auditConfigurations[_configurationId];\n', '    return (\n', '      auditConfiguration_.scopeId,\n', '      auditConfiguration_.triggers[ANY_ADDRESSES][ANY_ADDRESSES],\n', '      auditConfiguration_.senderKeys,\n', '      auditConfiguration_.receiverKeys,\n', '      auditConfiguration_.ratesProvider,\n', '      audits[address(this)][auditConfiguration_.scopeId].currency\n', '    );\n', '  }\n', '\n', '  function auditTrigger(uint256 _configurationId, address _sender, address _receiver)\n', '    override public view returns (AuditTriggerMode)\n', '  {\n', '    return auditConfigurations[_configurationId].triggers[_sender][_receiver];\n', '  }\n', '\n', '  function delegatesConfigurations(uint256 _delegateId)\n', '    override public view returns (uint256[] memory)\n', '  {\n', '    return delegatesConfigurations_[_delegateId];\n', '  }\n', '\n', '  function auditCurrency(\n', '    address _scope,\n', '    uint256 _scopeId\n', '  ) override external view returns (address currency) {\n', '    return audits[_scope][_scopeId].currency;\n', '  }\n', '\n', '  function audit(\n', '    address _scope,\n', '    uint256 _scopeId,\n', '    AuditStorageMode _storageMode,\n', '    bytes32 _storageId) override external view returns (\n', '    uint64 createdAt,\n', '    uint64 lastTransactionAt,\n', '    uint256 cumulatedEmission,\n', '    uint256 cumulatedReception)\n', '  {\n', '    AuditData memory auditData;\n', '    if (_storageMode == AuditStorageMode.SHARED) {\n', '      auditData = audits[_scope][_scopeId].sharedData;\n', '    }\n', '    if (_storageMode == AuditStorageMode.ADDRESS) {\n', '      auditData = audits[_scope][_scopeId].addressData[address(bytes20(_storageId))];\n', '    }\n', '    if (_storageMode == AuditStorageMode.USER_ID) {\n', '      auditData = audits[_scope][_scopeId].userData[uint256(_storageId)];\n', '    }\n', '\n', '    createdAt = auditData.createdAt;\n', '    lastTransactionAt = auditData.lastTransactionAt;\n', '    cumulatedEmission = auditData.cumulatedEmission;\n', '    cumulatedReception = auditData.cumulatedReception;\n', '  }\n', '\n', '  /**************  ERC20  **************/\n', '  function tokenName() override external view returns (string memory) {\n', '    return tokens[msg.sender].name;\n', '  }\n', '\n', '  function tokenSymbol() override external view returns (string memory) {\n', '    return tokens[msg.sender].symbol;\n', '  }\n', '\n', '  function decimals() override external onlyProxy returns (uint256) {\n', '    return delegateCallUint256(msg.sender);\n', '  }\n', '\n', '  function totalSupply() override external onlyProxy returns (uint256) {\n', '    return delegateCallUint256(msg.sender);\n', '  }\n', '\n', '  function balanceOf(address) external onlyProxy override returns (uint256) {\n', '    return delegateCallUint256(msg.sender);\n', '  }\n', '\n', '  function allowance(address, address)\n', '    override external onlyProxy returns (uint256)\n', '  {\n', '    return delegateCallUint256(msg.sender);\n', '  }\n', '\n', '  function transfer(address, address, uint256)\n', '    override external onlyProxy returns (bool status)\n', '  {\n', '    return delegateCall(msg.sender);\n', '  }\n', '\n', '  function transferFrom(address, address, address, uint256)\n', '    override external onlyProxy returns (bool status)\n', '  {\n', '    return delegateCall(msg.sender);\n', '  }\n', '\n', '  function approve(address, address, uint256)\n', '    override external onlyProxy returns (bool status)\n', '  {\n', '    return delegateCall(msg.sender);\n', '  }\n', '\n', '  function increaseApproval(address, address, uint256)\n', '    override external onlyProxy returns (bool status)\n', '  {\n', '    return delegateCall(msg.sender);\n', '  }\n', '\n', '  function decreaseApproval(address, address, uint256)\n', '    override external onlyProxy returns (bool status)\n', '  {\n', '    return delegateCall(msg.sender);\n', '  }\n', '\n', '  /***********  TOKEN DATA   ***********/\n', '  function token(address _token) override external view returns (\n', '    bool mintingFinished,\n', '    uint256 allTimeMinted,\n', '    uint256 allTimeBurned,\n', '    uint256 allTimeSeized,\n', '    address[] memory locks,\n', '    uint256 frozenUntil,\n', '    IRule[] memory rules) {\n', '    TokenData storage tokenData = tokens[_token];\n', '\n', '    mintingFinished = tokenData.mintingFinished;\n', '    allTimeMinted = tokenData.allTimeMinted;\n', '    allTimeBurned = tokenData.allTimeBurned;\n', '    allTimeSeized = tokenData.allTimeSeized;\n', '    locks = tokenData.locks;\n', '    frozenUntil = tokenData.frozenUntils[_token];\n', '    rules = tokenData.rules;\n', '  }\n', '\n', '  function lock(address _lock, address _sender, address _receiver) override external view returns (\n', '    uint64 startAt, uint64 endAt)\n', '  {\n', '    LockData storage lockData_ = locks[_lock][_sender][_receiver];\n', '    return (lockData_.startAt, lockData_.endAt);\n', '  }\n', '\n', '  function canTransfer(address, address, uint256)\n', '    override external onlyProxy returns (uint256)\n', '  {\n', '    return delegateCallUint256(msg.sender);\n', '  }\n', '\n', '  /***********  TOKEN ADMIN  ***********/\n', '  function mint(address _token, address[] calldata, uint256[] calldata)\n', '    override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  function finishMinting(address _token)\n', '    override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  function burn(address _token, uint256)\n', '    override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  function seize(address _token, address, uint256)\n', '    override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  function freezeManyAddresses(\n', '    address _token,\n', '    address[] calldata,\n', '    uint256) override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  function defineLock(address _lock, address, address, uint64, uint64)\n', '    override external onlyProxyOp(_lock) returns (bool)\n', '  {\n', '    return delegateCall(_lock);\n', '  }\n', '\n', '  function defineTokenLocks(address _token, address[] calldata)\n', '    override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  function defineRules(address _token, IRule[] calldata)\n', '    override external onlyProxyOp(_token) returns (bool)\n', '  {\n', '    return delegateCall(_token);\n', '  }\n', '\n', '  /************  CORE ADMIN  ************/\n', '  function removeProxyInternal(address _token)\n', '    internal override returns (bool)\n', '  {\n', '    super.removeProxyInternal(_token);\n', '    delete tokens[_token];\n', '    return true;\n', '  }\n', '\n', '  function defineToken(\n', '    address _token,\n', '    uint256 _delegateId,\n', '    string calldata _name,\n', '    string calldata _symbol,\n', '    uint256 _decimals)\n', '    override external onlyCoreOp returns (bool)\n', '  {\n', '    require(_token != ALL_PROXIES, "TC01");\n', '    defineProxy(_token, _delegateId);\n', '    TokenData storage tokenData = tokens[_token];\n', '    tokenData.name = _name;\n', '    tokenData.symbol = _symbol;\n', '    tokenData.decimals = _decimals;\n', '\n', '    emit TokenDefined(_token, _name, _symbol, _decimals);\n', '    return true;\n', '  }\n', '\n', '  function defineOracle(\n', '    IUserRegistry _userRegistry,\n', '    IRatesProvider _ratesProvider,\n', '    address _currency)\n', '    override external onlyCoreOp returns (bool)\n', '  {\n', '    userRegistry_ = _userRegistry;\n', '    ratesProvider_ = _ratesProvider;\n', '    currency_ = _currency;\n', '\n', '    emit OracleDefined(userRegistry_, _ratesProvider, _currency);\n', '    return true;\n', '  }\n', '\n', '  function defineTokenDelegate(\n', '    uint256 _delegateId,\n', '    address _delegate,\n', '    uint256[] calldata _auditConfigurations) override external onlyCoreOp returns (bool)\n', '  {\n', '    require(_delegate == address(0) ||\n', '      ITokenDelegate(_delegate).checkConfigurations(_auditConfigurations), "TC03");\n', '\n', '    defineDelegateInternal(_delegateId, _delegate);\n', '    if(_delegate != address(0)) {\n', '      delegatesConfigurations_[_delegateId] = _auditConfigurations;\n', '      emit TokenDelegateDefined(_delegateId, _delegate, _auditConfigurations);\n', '    } else {\n', '      delete delegatesConfigurations_[_delegateId];\n', '      emit TokenDelegateRemoved(_delegateId);\n', '    }\n', '    return true;\n', '  }\n', '\n', '  function defineAuditConfiguration(\n', '    uint256 _configurationId,\n', '    uint256 _scopeId,\n', '    AuditTriggerMode _mode,\n', '    uint256[] calldata _senderKeys,\n', '    uint256[] calldata _receiverKeys,\n', '    IRatesProvider _ratesProvider,\n', '    address _currency) override external onlyCoreOp returns (bool)\n', '  {\n', '    // Mark permanently the core audit storage with the currency to be used with\n', '    AuditStorage storage auditStorage = audits[address(this)][_scopeId];\n', '    if(auditStorage.currency == address(0)) {\n', '      auditStorage.currency = _currency;\n', '    } else {\n', '      require(auditStorage.currency == _currency, "TC04");\n', '    }\n', '\n', '    AuditConfiguration storage auditConfiguration_ = auditConfigurations[_configurationId];\n', '    auditConfiguration_.scopeId = _scopeId;\n', '    auditConfiguration_.senderKeys = _senderKeys;\n', '    auditConfiguration_.receiverKeys = _receiverKeys;\n', '    auditConfiguration_.ratesProvider = _ratesProvider;\n', '    auditConfiguration_.triggers[ANY_ADDRESSES][ANY_ADDRESSES] = _mode;\n', '\n', '    emit AuditConfigurationDefined(\n', '      _configurationId,\n', '      _scopeId,\n', '      _mode,\n', '      _senderKeys,\n', '      _receiverKeys,\n', '      _ratesProvider,\n', '      _currency);\n', '    return true;\n', '  }\n', '\n', '  function removeAudits(address _scope, uint256 _scopeId)\n', '    override external onlyCoreOp returns (bool)\n', '  {\n', '    delete audits[_scope][_scopeId];\n', '    emit AuditsRemoved(_scope, _scopeId);\n', '    return true;\n', '  }\n', '\n', '  function defineAuditTriggers(\n', '    uint256 _configurationId,\n', '    address[] calldata _senders,\n', '    address[] calldata _receivers,\n', '    AuditTriggerMode[] calldata _modes) override external onlyCoreOp returns (bool)\n', '  {\n', '    require(_senders.length == _receivers.length && _senders.length == _modes.length, "TC05");\n', '\n', '    AuditConfiguration storage auditConfiguration_ = auditConfigurations[_configurationId];\n', '    for(uint256 i=0; i < _senders.length; i++) {\n', '      auditConfiguration_.triggers[_senders[i]][_receivers[i]] = _modes[i];\n', '    }\n', '\n', '    emit AuditTriggersDefined(_configurationId, _senders, _receivers, _modes);\n', '    return true;\n', '  }\n', '\n', '  function isSelfManaged(address _owner)\n', '    override external view returns (bool)\n', '  {\n', '    return selfManaged[_owner];\n', '  }\n', '\n', '  function manageSelf(bool _active)\n', '    override external returns (bool)\n', '  {\n', '    selfManaged[msg.sender] = _active;\n', '    emit SelfManaged(msg.sender, _active);\n', '  }\n', '}\n', '\n', '// File: contracts/TokenProxy.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Token proxy\n', ' * @dev Token proxy default implementation\n', ' *\n', ' * @author Cyril Lapinte - <cyril.lapinte@openfiz.com>\n', ' */\n', 'contract TokenProxy is ITokenProxy, OperableProxy {\n', '\n', '  // solhint-disable-next-line no-empty-blocks\n', '  constructor(address _core) public OperableProxy(_core) { }\n', '\n', '  function name() override public view returns (string memory) {\n', '    return TokenCore(core).tokenName();\n', '  }\n', '\n', '  function symbol() override public view returns (string memory) {\n', '    return TokenCore(core).tokenSymbol();\n', '  }\n', '\n', '  function decimals() override public view returns (uint256) {\n', '    return staticCallUint256();\n', '  }\n', '\n', '  function totalSupply() override public view returns (uint256) {\n', '    return staticCallUint256();\n', '  }\n', '\n', '  function balanceOf(address) override public view returns (uint256) {\n', '    return staticCallUint256();\n', '  }\n', '\n', '  function allowance(address, address)\n', '    override public view returns (uint256)\n', '  {\n', '    return staticCallUint256();\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) override public returns (bool status)\n', '  {\n', '    return TokenCore(core).transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '    override public returns (bool status)\n', '  {\n', '    return TokenCore(core).transferFrom(msg.sender, _from, _to, _value);\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value)\n', '    override public returns (bool status)\n', '  {\n', '    return TokenCore(core).approve(msg.sender, _spender, _value);\n', '  }\n', '\n', '  function increaseApproval(address _spender, uint256 _addedValue)\n', '    override public returns (bool status)\n', '  {\n', '    return TokenCore(core).increaseApproval(msg.sender, _spender, _addedValue);\n', '  }\n', '\n', '  function decreaseApproval(address _spender, uint256 _subtractedValue)\n', '    override public returns (bool status)\n', '  {\n', '    return TokenCore(core).decreaseApproval(msg.sender, _spender, _subtractedValue);\n', '  }\n', '\n', '  function canTransfer(address, address, uint256)\n', '    override public view returns (uint256)\n', '  {\n', '    return staticCallUint256();\n', '  }\n', '\n', '  function emitTransfer(address _from, address _to, uint256 _value)\n', '    override public onlyCore returns (bool)\n', '  {\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function emitApproval(address _owner, address _spender, uint256 _value)\n', '    override public onlyCore returns (bool)\n', '  {\n', '    emit Approval(_owner, _spender, _value);\n', '    return true;\n', '  }\n', '}']