['pragma solidity ^0.4.24;\n', '\n', '// @author Roy Xu @dev-xu\n', '// @title A shared storage contract for platform contracts to store and retrieve data\n', '// @notice This contract holds all long-term data for smart-contract systems\n', '// @dev The bytes32 hashes are derived from keccak256(variableName, uniqueID) => value\n', '// @dec Can enable upgradeable contracts by setting a contract manager\n', 'contract Database {\n', '\n', '    // Storage Variables\n', '    mapping(bytes32 => uint) public uintStorage;\n', '    mapping(bytes32 => string) public stringStorage;\n', '    mapping(bytes32 => address) public addressStorage;\n', '    mapping(bytes32 => bytes) public bytesStorage;\n', '    mapping(bytes32 => bytes32) public bytes32Storage;\n', '    mapping(bytes32 => bool) public boolStorage;\n', '    mapping(bytes32 => int) public intStorage;\n', '\n', '\n', '\n', '    // @notice Constructor: Sets the owners of the platform\n', '    // @dev Owners must set the contract manager to add more contracts\n', '    constructor(address[] _owners, bool _upgradeable)\n', '    public {\n', '      for(uint i=0; i<_owners.length; i++){\n', '        require(_owners[i] != address(0), "Empty address");\n', '        boolStorage[keccak256(abi.encodePacked("owner", _owners[i]))] = true;\n', '        emit LogInitialized(_owners[i], _upgradeable);\n', '      }\n', '      if (_upgradeable){\n', '        boolStorage[keccak256("upgradeable")] = true;\n', '      }\n', '    }\n', '\n', '    // @notice ContractManager will be the only contract that can add/remove contracts on the platform.\n', '    // @param (address) _contractManager is the contract which can upgrade/remove contracts to platform\n', '    function enableContractManagement(address _contractManager)\n', '    external\n', '    returns (bool){\n', '        require(_contractManager != address(0), "Empty address");\n', '        require(boolStorage[keccak256(abi.encodePacked("owner", msg.sender))], "Not owner");\n', '        require(addressStorage[keccak256(abi.encodePacked("contract", "ContractManager"))] == address(0), "There is already a contract manager");\n', '        addressStorage[keccak256(abi.encodePacked("contract", "ContractManager"))] = _contractManager;\n', '        boolStorage[keccak256(abi.encodePacked("contract", _contractManager))] = true;\n', '        return true;\n', '    }\n', '\n', '    // @notice Storage functions\n', '    function setAddress(bytes32 _key, address _value)\n', '    onlyApprovedContract\n', '    external {\n', '        addressStorage[_key] = _value;\n', '    }\n', '\n', '    function setUint(bytes32 _key, uint _value)\n', '    onlyApprovedContract\n', '    external {\n', '        uintStorage[_key] = _value;\n', '    }\n', '\n', '    function setString(bytes32 _key, string _value)\n', '    onlyApprovedContract\n', '    external {\n', '        stringStorage[_key] = _value;\n', '    }\n', '\n', '    function setBytes(bytes32 _key, bytes _value)\n', '    onlyApprovedContract\n', '    external {\n', '        bytesStorage[_key] = _value;\n', '    }\n', '\n', '    function setBytes32(bytes32 _key, bytes32 _value)\n', '    onlyApprovedContract\n', '    external {\n', '        bytes32Storage[_key] = _value;\n', '    }\n', '\n', '    function setBool(bytes32 _key, bool _value)\n', '    onlyApprovedContract\n', '    external {\n', '        boolStorage[_key] = _value;\n', '    }\n', '\n', '    function setInt(bytes32 _key, int _value)\n', '    onlyApprovedContract\n', '    external {\n', '        intStorage[_key] = _value;\n', '    }\n', '\n', '\n', '    // Deletion functions: Can alternatively use setter functions and set to null value (ie. uint = 0)\n', '    function deleteAddress(bytes32 _key)\n', '    onlyApprovedContract\n', '    external {\n', '        delete addressStorage[_key];\n', '    }\n', '\n', '    function deleteUint(bytes32 _key)\n', '    onlyApprovedContract\n', '    external {\n', '        delete uintStorage[_key];\n', '    }\n', '\n', '    function deleteString(bytes32 _key)\n', '    onlyApprovedContract\n', '    external {\n', '        delete stringStorage[_key];\n', '    }\n', '\n', '    function deleteBytes(bytes32 _key)\n', '    onlyApprovedContract\n', '    external {\n', '        delete bytesStorage[_key];\n', '    }\n', '\n', '    function deleteBytes32(bytes32 _key)\n', '    onlyApprovedContract\n', '    external {\n', '        delete bytes32Storage[_key];\n', '    }\n', '\n', '    function deleteBool(bytes32 _key)\n', '    onlyApprovedContract\n', '    external {\n', '        delete boolStorage[_key];\n', '    }\n', '\n', '    function deleteInt(bytes32 _key)\n', '    onlyApprovedContract\n', '    external {\n', '        delete intStorage[_key];\n', '    }\n', '\n', '\n', '    // --------------------------------------------------------------------------------------\n', '    //                                     Modifiers\n', '    // --------------------------------------------------------------------------------------\n', '\n', '    // Caller must be registered as a contract through ContractManager.sol\n', '    modifier onlyApprovedContract() {\n', '        require(boolStorage[keccak256(abi.encodePacked("contract", msg.sender))]);\n', '        _;\n', '    }\n', '\n', '    // --------------------------------------------------------------------------------------\n', '    //                                     Events\n', '    // --------------------------------------------------------------------------------------\n', '    event LogInitialized(address _owner, bool _upgradeable);\n', '}\n', '\n', '// Database interface\n', 'interface DBInterface {\n', '\n', '  function setContractManager(address _contractManager)\n', '  external;\n', '\n', '    // --------------------Set Functions------------------------\n', '\n', '    function setAddress(bytes32 _key, address _value)\n', '    external;\n', '\n', '    function setUint(bytes32 _key, uint _value)\n', '    external;\n', '\n', '    function setString(bytes32 _key, string _value)\n', '    external;\n', '\n', '    function setBytes(bytes32 _key, bytes _value)\n', '    external;\n', '\n', '    function setBytes32(bytes32 _key, bytes32 _value)\n', '    external;\n', '\n', '    function setBool(bytes32 _key, bool _value)\n', '    external;\n', '\n', '    function setInt(bytes32 _key, int _value)\n', '    external;\n', '\n', '\n', '     // -------------- Deletion Functions ------------------\n', '\n', '    function deleteAddress(bytes32 _key)\n', '    external;\n', '\n', '    function deleteUint(bytes32 _key)\n', '    external;\n', '\n', '    function deleteString(bytes32 _key)\n', '    external;\n', '\n', '    function deleteBytes(bytes32 _key)\n', '    external;\n', '\n', '    function deleteBytes32(bytes32 _key)\n', '    external;\n', '\n', '    function deleteBool(bytes32 _key)\n', '    external;\n', '\n', '    function deleteInt(bytes32 _key)\n', '    external;\n', '\n', '    // ----------------Variable Getters---------------------\n', '\n', '    function uintStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (uint);\n', '\n', '    function stringStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (string);\n', '\n', '    function addressStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '    function bytesStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (bytes);\n', '\n', '    function bytes32Storage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (bytes32);\n', '\n', '    function boolStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (bool);\n', '\n', '    function intStorage(bytes32 _key)\n', '    external\n', '    view\n', '    returns (bool);\n', '}\n', '\n', 'contract Events {\n', '  DBInterface public database;\n', '\n', '  constructor(address _database) public{\n', '    database = DBInterface(_database);\n', '  }\n', '\n', '  function message(string _message)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogEvent(_message, keccak256(abi.encodePacked(_message)), tx.origin);\n', '  }\n', '\n', '  function transaction(string _message, address _from, address _to, uint _amount, address _token)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogTransaction(_message, keccak256(abi.encodePacked(_message)), _from, _to, _amount, _token, tx.origin);\n', '  }\n', '\n', '  function registration(string _message, address _account)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogAddress(_message, keccak256(abi.encodePacked(_message)), _account, tx.origin);\n', '  }\n', '\n', '  function contractChange(string _message, address _account, string _name)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogContractChange(_message, keccak256(abi.encodePacked(_message)), _account, _name, tx.origin);\n', '  }\n', '\n', '  function asset(string _message, string _uri, address _assetAddress, address _manager)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogAsset(_message, keccak256(abi.encodePacked(_message)), _uri, keccak256(abi.encodePacked(_uri)), _assetAddress, _manager, tx.origin);\n', '  }\n', '\n', '  function escrow(string _message, address _assetAddress, bytes32 _escrowID, address _manager, uint _amount)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogEscrow(_message, keccak256(abi.encodePacked(_message)), _assetAddress, _escrowID, _manager, _amount, tx.origin);\n', '  }\n', '\n', '  function order(string _message, bytes32 _orderID, uint _amount, uint _price)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogOrder(_message, keccak256(abi.encodePacked(_message)), _orderID, _amount, _price, tx.origin);\n', '  }\n', '\n', '  function exchange(string _message, bytes32 _orderID, address _assetAddress, address _account)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogExchange(_message, keccak256(abi.encodePacked(_message)), _orderID, _assetAddress, _account, tx.origin);\n', '  }\n', '\n', '  function operator(string _message, bytes32 _id, string _name, string _ipfs, address _account)\n', '  external\n', '  onlyApprovedContract {\n', '      emit LogOperator(_message, keccak256(abi.encodePacked(_message)), _id, _name, _ipfs, _account, tx.origin);\n', '  }\n', '\n', '  function consensus(string _message, bytes32 _executionID, bytes32 _votesID, uint _votes, uint _tokens, uint _quorum)\n', '  external\n', '  onlyApprovedContract {\n', '    emit LogConsensus(_message, keccak256(abi.encodePacked(_message)), _executionID, _votesID, _votes, _tokens, _quorum, tx.origin);\n', '  }\n', '\n', '  //Generalized events\n', '  event LogEvent(string message, bytes32 indexed messageID, address indexed origin);\n', '  event LogTransaction(string message, bytes32 indexed messageID, address indexed from, address indexed to, uint amount, address token, address origin); //amount and token will be empty on some events\n', '  event LogAddress(string message, bytes32 indexed messageID, address indexed account, address indexed origin);\n', '  event LogContractChange(string message, bytes32 indexed messageID, address indexed account, string name, address indexed origin);\n', '  event LogAsset(string message, bytes32 indexed messageID, string uri, bytes32 indexed assetID, address asset, address manager, address indexed origin);\n', '  event LogEscrow(string message, bytes32 indexed messageID, address asset, bytes32  escrowID, address indexed manager, uint amount, address indexed origin);\n', '  event LogOrder(string message, bytes32 indexed messageID, bytes32 indexed orderID, uint amount, uint price, address indexed origin);\n', '  event LogExchange(string message, bytes32 indexed messageID, bytes32 orderID, address indexed asset, address account, address indexed origin);\n', '  event LogOperator(string message, bytes32 indexed messageID, bytes32 id, string name, string ipfs, address indexed account, address indexed origin);\n', '  event LogConsensus(string message, bytes32 indexed messageID, bytes32 executionID, bytes32 votesID, uint votes, uint tokens, uint quorum, address indexed origin);\n', '\n', '\n', '  // --------------------------------------------------------------------------------------\n', '  // Caller must be registered as a contract through ContractManager.sol\n', '  // --------------------------------------------------------------------------------------\n', '  modifier onlyApprovedContract() {\n', '      require(database.boolStorage(keccak256(abi.encodePacked("contract", msg.sender))));\n', '      _;\n', '  }\n', '\n', '}\n', '\n', 'contract Platform {\n', '\n', '  Database public database;\n', '  Events public events;\n', '\n', '  // @notice initialize database\n', '  constructor(address _database, address _events)\n', '  public {\n', '    database = Database(_database);\n', '    events = Events(_events);\n', '  }\n', '\n', '  // @notice The wallet to receive payments here before initiating crowdsale\n', '  // @dev will overwrite old wallet address\n', '  function setPlatformFundsWallet(address _walletAddress)\n', '  external\n', '  onlyOwner {\n', '    database.setAddress(keccak256(abi.encodePacked("platform.wallet.funds")), _walletAddress);\n', '    //emit LogPlatformWallet(_walletAddress);\n', "    events.registration('Platform funds wallet', _walletAddress);\n", '  }\n', '\n', '  // @notice The wallet to receive asset tokens here before initiating crowdsale\n', '  // @dev will overwrite old wallet address\n', '  function setPlatformAssetsWallet(address _walletAddress)\n', '  external\n', '  onlyOwner {\n', '    database.setAddress(keccak256(abi.encodePacked("platform.wallet.assets")), _walletAddress);\n', '    //emit LogPlatformWallet(_walletAddress);\n', "    events.registration('Platform assets wallet', _walletAddress);\n", '  }\n', '\n', '  // @notice The token that the platform uses for holding collateral\n', '  function setPlatformToken(address _tokenAddress)\n', '  external\n', '  onlyOwner {\n', '    //@dev Set the address for the platform token\n', '    database.setAddress(keccak256(abi.encodePacked("platform.token")), _tokenAddress);\n', "    events.registration('Platform token', _tokenAddress);\n", '  }\n', '\n', '  // @notice The percentage of the payment that the platform receives when investors contribute\n', '  function setPlatformFee(uint _percent)\n', '  external\n', '  onlyOwner {\n', '    database.setUint(keccak256(abi.encodePacked("platform.fee")), _percent);\n', '  }\n', '\n', '  // @notice Set the token address for the platform listing fee\n', '  function setPlatformListingFeeToken(address _tokenAddress)\n', '  external\n', '  onlyOwner {\n', '    //@dev Set the token address for the platform listing fee\n', '    database.setAddress(keccak256(abi.encodePacked("platform.listingFeeToken")), _tokenAddress);\n', "    events.registration('Platform listing fee token', _tokenAddress);\n", '  }\n', '\n', '  // @notice The amount of DAI the platform receives when an asset is listed\n', '  function setPlatformListingFee(uint _amount)\n', '  external\n', '  onlyOwner {\n', '    database.setUint(keccak256(abi.encodePacked("platform.listingFee")), _amount);\n', '  }\n', '\n', '  // @notice The percentage of the asset tokens the platform receives from the crowdsale\n', '  function setPlatformPercentage(uint _percent)\n', '  external\n', '  onlyOwner {\n', '    database.setUint(keccak256(abi.encodePacked("platform.percentage")), _percent);\n', '  }\n', '\n', '  // @notice Set the address of the token factory that clones the asset tokens\n', '  function setTokenFactory(address _factory)\n', '  external\n', '  onlyOwner {\n', '    database.setAddress(keccak256(abi.encodePacked("platform.tokenFactory")), _factory);\n', '  }\n', '\n', '  /*\n', '  function setBurnrate(uint _percent)\n', '  external\n', '  onlyOwner {\n', '    require(_percent < 100 && _percent >= 0);\n', '    database.setUint(keccak256(abi.encodePacked("platform.burnRate")), _percent);\n', '  }\n', '  */\n', '\n', '  // @notice platform owners can destroy contract here\n', '  function destroy()\n', '  onlyOwner\n', '  external {\n', "    events.transaction('PlatformFunds destroyed', address(this), msg.sender, address(this).balance, address(0));\n", '    selfdestruct(msg.sender);\n', '  }\n', '\n', '  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '  //                                                Modifiers                                                                     //\n', '  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '  // @notice Sender must be a registered owner\n', '  modifier onlyOwner {\n', '    require(database.boolStorage(keccak256(abi.encodePacked("owner", msg.sender))));\n', '    _;\n', '  }\n', '\n', '\n', '\n', '\n', '\n', '\n', '}']