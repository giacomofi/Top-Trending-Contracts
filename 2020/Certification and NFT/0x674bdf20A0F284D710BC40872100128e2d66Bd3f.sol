['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2017 Loopring Technology Limited.\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/// @title Ownable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable\n', '{\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      new owner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership()\n', '        public\n', '        onlyOwner\n', '    {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library MathUint\n', '{\n', '    using MathUint for uint;\n', '\n', '    function mul(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b, "MUL_OVERFLOW");\n', '    }\n', '\n', '    function sub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        require(b <= a, "SUB_UNDERFLOW");\n', '        return a - b;\n', '    }\n', '\n', '    function add(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '\n', '    function add64(\n', '        uint64 a,\n', '        uint64 b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint64 c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'abstract contract ERC20\n', '{\n', '    function totalSupply()\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    function balanceOf(\n', '        address who\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function approve(\n', '        address spender,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Utility Functions for addresses\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library AddressUtil\n', '{\n', '    using AddressUtil for *;\n', '\n', '    function isContract(\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(addr) }\n', '        return (codehash != 0x0 &&\n', '                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n', '    }\n', '\n', '    function toPayable(\n', '        address addr\n', '        )\n', '        internal\n', '        pure\n', '        returns (address payable)\n', '    {\n', '        return payable(addr);\n', '    }\n', '\n', '    // Works like address.send but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETH(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        if (amount == 0) {\n', '            return true;\n', '        }\n', '        address payable recipient = to.toPayable();\n', '        /* solium-disable-next-line */\n', '        (success, ) = recipient.call{value: amount, gas: gasLimit}("");\n', '    }\n', '\n', '    // Works like address.transfer but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETHAndVerify(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        success = to.sendETH(amount, gasLimit);\n', '        require(success, "TRANSFER_FAILURE");\n', '    }\n', '\n', '    // Works like call but is slightly more efficient when data\n', '    // needs to be copied from memory to do the call.\n', '    function fastCall(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bool success, bytes memory returnData)\n', '    {\n', '        if (to != address(0)) {\n', '            assembly {\n', '                // Do the call\n', '                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\n', '                // Copy the return data\n', '                let size := returndatasize()\n', '                returnData := mload(0x40)\n', '                mstore(returnData, size)\n', '                returndatacopy(add(returnData, 32), 0, size)\n', '                // Update free memory pointer\n', '                mstore(0x40, add(returnData, add(32, size)))\n', '            }\n', '        }\n', '    }\n', '\n', '    // Like fastCall, but throws when the call is unsuccessful.\n', '    function fastCallAndVerify(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bytes memory returnData)\n', '    {\n', '        bool success;\n', '        (success, returnData) = fastCall(to, gasLimit, value, data);\n', '        if (!success) {\n', '            assembly {\n', '                revert(add(returnData, 32), mload(returnData))\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title Claimable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable\n', '{\n', '    address public pendingOwner;\n', '\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0) && newOwner != owner, "INVALID_ADDRESS");\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        public\n', '        onlyPendingOwner\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ERC20 safe transfer\n', '/// @dev see https://github.com/sec-bit/badERC20Fix\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library ERC20SafeTransfer\n', '{\n', '    function safeTransferAndVerify(\n', '        address token,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '    {\n', '        safeTransferWithGasLimitAndVerify(\n', '            token,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return safeTransferWithGasLimit(\n', '            token,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferWithGasLimitAndVerify(\n', '        address token,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '    {\n', '        require(\n', '            safeTransferWithGasLimit(token, to, value, gasLimit),\n', '            "TRANSFER_FAILURE"\n', '        );\n', '    }\n', '\n', '    function safeTransferWithGasLimit(\n', '        address token,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', "        // A transfer is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transfer(address,uint256)")) = 0xa9059cbb\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            bytes4(0xa9059cbb),\n', '            to,\n', '            value\n', '        );\n', '        (bool success, ) = token.call{gas: gasLimit}(callData);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function safeTransferFromAndVerify(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '    {\n', '        safeTransferFromWithGasLimitAndVerify(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return safeTransferFromWithGasLimit(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferFromWithGasLimitAndVerify(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '    {\n', '        bool result = safeTransferFromWithGasLimit(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasLimit\n', '        );\n', '        require(result, "TRANSFER_FAILURE");\n', '    }\n', '\n', '    function safeTransferFromWithGasLimit(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', "        // A transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transferFrom(address,address,uint256)")) = 0x23b872dd\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            bytes4(0x23b872dd),\n', '            from,\n', '            to,\n', '            value\n', '        );\n', '        (bool success, ) = token.call{gas: gasLimit}(callData);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function checkReturnValue(\n', '        bool success\n', '        )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', "        // A transfer/transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '        if (success) {\n', '            assembly {\n', '                switch returndatasize()\n', "                // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded\n", '                case 0 {\n', '                    success := 1\n', '                }\n', '                // Standard ERC20: a single boolean value is returned which needs to be true\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    success := mload(0)\n', '                }\n', '                // None of the above: not successful\n', '                default {\n', '                    success := 0\n', '                }\n', '            }\n', '        }\n', '        return success;\n', '    }\n', '}\n', '\n', '\n', '// Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeCast.sol\n', '\n', '\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n", ' * checks.\n', ' *\n', ' * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n', ' * easily result in undesired exploitation or bugs, since developers usually\n', ' * assume that overflows raise errors. `SafeCast` restores this intuition by\n', ' * reverting the transaction when such an operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' *\n', ' * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n', ' * all math on `uint256` and `int256` and then downcasting.\n', ' */\n', 'library SafeCast {\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint128 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint128).\n', '     *\n', "     * Counterpart to Solidity's `uint128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     */\n', '    function toUint128(uint256 value) internal pure returns (uint128) {\n', '        require(value < 2**128, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return uint128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint96 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint96).\n', '     *\n', "     * Counterpart to Solidity's `uint96` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 96 bits\n', '     */\n', '    function toUint96(uint256 value) internal pure returns (uint96) {\n', '        require(value < 2**96, "SafeCast: value doesn\\\'t fit in 96 bits");\n', '        return uint96(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint64 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint64).\n', '     *\n', "     * Counterpart to Solidity's `uint64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     */\n', '    function toUint64(uint256 value) internal pure returns (uint64) {\n', '        require(value < 2**64, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return uint64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint32 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint32).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     */\n', '    function toUint32(uint256 value) internal pure returns (uint32) {\n', '        require(value < 2**32, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return uint32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint40 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint40).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 40 bits\n', '     */\n', '    function toUint40(uint256 value) internal pure returns (uint40) {\n', '        require(value < 2**40, "SafeCast: value doesn\\\'t fit in 40 bits");\n', '        return uint40(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint16 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint16).\n', '     *\n', "     * Counterpart to Solidity's `uint16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     */\n', '    function toUint16(uint256 value) internal pure returns (uint16) {\n', '        require(value < 2**16, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return uint16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint8 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint8).\n', '     *\n', "     * Counterpart to Solidity's `uint8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     */\n', '    function toUint8(uint256 value) internal pure returns (uint8) {\n', '        require(value < 2**8, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return uint8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a signed int256 into an unsigned uint256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be greater than or equal to 0.\n', '     */\n', '    function toUint256(int256 value) internal pure returns (uint256) {\n', '        require(value >= 0, "SafeCast: value must be positive");\n', '        return uint256(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int128 from int256, reverting on\n', '     * overflow (when the input is less than smallest int128 or\n', '     * greater than largest int128).\n', '     *\n', "     * Counterpart to Solidity's `int128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt128(int256 value) internal pure returns (int128) {\n', '        require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return int128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int64 from int256, reverting on\n', '     * overflow (when the input is less than smallest int64 or\n', '     * greater than largest int64).\n', '     *\n', "     * Counterpart to Solidity's `int64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt64(int256 value) internal pure returns (int64) {\n', '        require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return int64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int32 from int256, reverting on\n', '     * overflow (when the input is less than smallest int32 or\n', '     * greater than largest int32).\n', '     *\n', "     * Counterpart to Solidity's `int32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt32(int256 value) internal pure returns (int32) {\n', '        require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return int32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int16 from int256, reverting on\n', '     * overflow (when the input is less than smallest int16 or\n', '     * greater than largest int16).\n', '     *\n', "     * Counterpart to Solidity's `int16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt16(int256 value) internal pure returns (int16) {\n', '        require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return int16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int8 from int256, reverting on\n', '     * overflow (when the input is less than smallest int8 or\n', '     * greater than largest int8).\n', '     *\n', "     * Counterpart to Solidity's `int8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt8(int256 value) internal pure returns (int8) {\n', '        require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return int8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an unsigned uint256 into a signed int256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be less than or equal to maxInt256.\n', '     */\n', '    function toInt256(uint256 value) internal pure returns (int256) {\n', '        require(value < 2**255, "SafeCast: value doesn\'t fit in an int256");\n', '        return int256(value);\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title IDepositContract.\n', '/// @dev   Contract storing and transferring funds for an exchange.\n', '///\n', '///        ERC1155 tokens can be supported by registering pseudo token addresses calculated\n', '///        as `address(keccak256(real_token_address, token_params))`. Then the custom\n', '///        deposit contract can look up the real token address and paramsters with the\n', '///        pseudo token address before doing the transfers.\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'interface IDepositContract\n', '{\n', '    /// @dev Returns if a token is suppoprted by this contract.\n', '    function isTokenSupported(address token)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Transfers tokens from a user to the exchange. This function will\n', '    ///      be called when a user deposits funds to the exchange.\n', '    ///      In a simple implementation the funds are simply stored inside the\n', '    ///      deposit contract directly. More advanced implementations may store the funds\n', '    ///      in some DeFi application to earn interest, so this function could directly\n', '    ///      call the necessary functions to store the funds there.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', '    /// @param token The address of the token to transfer (`0x0` for ETH).\n', '    /// @param amount The amount of tokens to transfer.\n', '    /// @param extraData Opaque data that can be used by the contract to handle the deposit\n', "    /// @return amountReceived The amount to deposit to the user's account in the Merkle tree\n", '    function deposit(\n', '        address from,\n', '        address token,\n', '        uint96  amount,\n', '        bytes   calldata extraData\n', '        )\n', '        external\n', '        payable\n', '        returns (uint96 amountReceived);\n', '\n', '    /// @dev Transfers tokens from the exchange to a user. This function will\n', '    ///      be called when a withdrawal is done for a user on the exchange.\n', '    ///      In the simplest implementation the funds are simply stored inside the\n', '    ///      deposit contract directly so this simply transfers the requested tokens back\n', '    ///      to the user. More advanced implementations may store the funds\n', '    ///      in some DeFi application to earn interest so the function would\n', '    ///      need to get those tokens back from the DeFi application first before they\n', '    ///      can be transferred to the user.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', "    /// @param from The address from which 'amount' tokens are transferred.\n", "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (`0x0` for ETH).\n', '    /// @param amount The amount of tokens transferred.\n', '    /// @param extraData Opaque data that can be used by the contract to handle the withdrawal\n', '    function withdraw(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount,\n', '        bytes   calldata extraData\n', '        )\n', '        external\n', '        payable;\n', '\n', '    /// @dev Transfers tokens (ETH not supported) for a user using the allowance set\n', '    ///      for the exchange. This way the approval can be used for all functionality (and\n', '    ///      extended functionality) of the exchange.\n', '    ///      Should NOT be used to deposit/withdraw user funds, `deposit`/`withdraw`\n', '    ///      should be used for that as they will contain specialised logic for those operations.\n', '    ///      This function can be called by the exchange to transfer onchain funds of users\n', '    ///      necessary for Agent functionality.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (ETH is and cannot be suppported).\n', '    /// @param amount The amount of tokens transferred.\n', '    function transfer(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '        )\n', '        external\n', '        payable;\n', '\n', '    /// @dev Checks if the given address is used for depositing ETH or not.\n', '    ///      Is used while depositing to send the correct ETH amount to the deposit contract.\n', '    ///\n', '    ///      Note that 0x0 is always registered for deposting ETH when the exchange is created!\n', '    ///      This function allows additional addresses to be used for depositing ETH, the deposit\n', '    ///      contract can implement different behaviour based on the address value.\n', '    ///\n', '    /// @param addr The address to check\n', '    /// @return True if the address is used for depositing ETH, else false.\n', '    function isETH(address addr)\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '\n', '/// @title DefaultDepositContract\n', '/// @dev   Default implementation of IDepositContract that just stores\n', '///        all funds without doing anything with them.\n', '///\n', '///        Should be able to work with proxy contracts so the contract\n', '///        can be updated easily (but with great caution and transparency!)\n', '///        when necessary.\n', '///\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'contract DefaultDepositContract is IDepositContract, Claimable\n', '{\n', '    using AddressUtil       for address;\n', '    using ERC20SafeTransfer for address;\n', '    using MathUint          for uint;\n', '    using SafeCast          for uint;\n', '\n', '    address public exchange;\n', '\n', '    mapping (address => bool) needCheckBalance;\n', '\n', '    modifier onlyExchange()\n', '    {\n', '        require(msg.sender == exchange, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    modifier ifNotZero(uint amount)\n', '    {\n', '        if (amount == 0) return;\n', '        else  _;\n', '    }\n', '\n', '    event CheckBalance(\n', '        address indexed token,\n', '        bool            checkBalance\n', '    );\n', '\n', '    function initialize(\n', '        address _exchange\n', '        )\n', '        external\n', '    {\n', '        require(\n', '            exchange == address(0) && _exchange != address(0),\n', '            "INVALID_EXCHANGE"\n', '        );\n', '        owner = msg.sender;\n', '        exchange = _exchange;\n', '    }\n', '\n', '    function setCheckBalance(\n', '        address token,\n', '        bool    checkBalance\n', '        )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(needCheckBalance[token] != checkBalance, "INVALID_VALUE");\n', '\n', '        needCheckBalance[token] = checkBalance;\n', '        emit CheckBalance(token, checkBalance);\n', '    }\n', '\n', '    function isTokenSupported(address /*token*/)\n', '        external\n', '        override\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return true;\n', '    }\n', '\n', '    function deposit(\n', '        address from,\n', '        address token,\n', '        uint96  amount,\n', '        bytes   calldata /*extraData*/\n', '        )\n', '        external\n', '        override\n', '        payable\n', '        onlyExchange\n', '        ifNotZero(amount)\n', '        returns (uint96 amountReceived)\n', '    {\n', '        uint ethToReturn = 0;\n', '\n', '        if (isETHInternal(token)) {\n', '            require(msg.value >= amount, "INVALID_ETH_DEPOSIT");\n', '            amountReceived = amount;\n', '            ethToReturn = msg.value - amount;\n', '        } else {\n', '            bool checkBalance = needCheckBalance[token];\n', '            uint balanceBefore = checkBalance ? ERC20(token).balanceOf(address(this)) : 0;\n', '\n', '            token.safeTransferFromAndVerify(from, address(this), uint(amount));\n', '\n', '            uint balanceAfter = checkBalance ? ERC20(token).balanceOf(address(this)) : amount;\n', '            uint diff = balanceAfter.sub(balanceBefore);\n', '            amountReceived = diff.toUint96();\n', '\n', '            ethToReturn = msg.value;\n', '        }\n', '\n', '        if (ethToReturn > 0) {\n', '            from.sendETHAndVerify(ethToReturn, gasleft());\n', '        }\n', '    }\n', '\n', '    function withdraw(\n', '        address /*from*/,\n', '        address to,\n', '        address token,\n', '        uint    amount,\n', '        bytes   calldata /*extraData*/\n', '        )\n', '        external\n', '        override\n', '        payable\n', '        onlyExchange\n', '        ifNotZero(amount)\n', '    {\n', '        if (isETHInternal(token)) {\n', '            to.sendETHAndVerify(amount, gasleft());\n', '        } else {\n', '            if (!token.safeTransfer(to, amount)){\n', '                uint amountPaid = ERC20(token).balanceOf(address(this));\n', '                require(amountPaid < amount, "UNEXPECTED");\n', '                token.safeTransferAndVerify(to, amountPaid);\n', '            }\n', '        }\n', '    }\n', '\n', '    function transfer(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '        )\n', '        external\n', '        override\n', '        payable\n', '        onlyExchange\n', '        ifNotZero(amount)\n', '    {\n', '        token.safeTransferFromAndVerify(from, to, amount);\n', '    }\n', '\n', '    function isETH(address addr)\n', '        external\n', '        override\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return isETHInternal(addr);\n', '    }\n', '\n', '    // -- Internal --\n', '\n', '    function isETHInternal(address addr)\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        return addr == address(0);\n', '    }\n', '}']