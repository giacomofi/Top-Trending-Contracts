['// File: contracts/libs/SafeMath.sol\n', '\n', '\n', 'pragma solidity ^0.6.8;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IERC20.sol\n', '\n', '\n', 'pragma solidity ^0.6.8;\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/libs/SafeERC20.sol\n', '\n', '\n', 'pragma solidity ^0.6.8;\n', '\n', '\n', '\n', 'library SafeERC20 {\n', '    function transfer(IERC20 _token, address _to, uint256 _val) internal returns (bool) {\n', '        (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(_token.transfer.selector, _to, _val));\n', '        return success && (data.length == 0 || abi.decode(data, (bool)));\n', '    }\n', '}\n', '\n', '// File: contracts/libs/PineUtils.sol\n', '\n', '// SPDX-License-Identifier: GPL-2.0\n', '\n', 'pragma solidity ^0.6.8;\n', '\n', '\n', '\n', '\n', 'library PineUtils {\n', '    address internal constant ETH_ADDRESS = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '\n', '    /**\n', "     * @notice Get the account's balance of token or ETH\n", '     * @param _token - Address of the token\n', '     * @param _addr - Address of the account\n', "     * @return uint256 - Account's balance of token or ETH\n", '     */\n', '    function balanceOf(IERC20 _token, address _addr) internal view returns (uint256) {\n', '        if (ETH_ADDRESS == address(_token)) {\n', '            return _addr.balance;\n', '        }\n', '\n', '        return _token.balanceOf(_addr);\n', '    }\n', '\n', '     /**\n', '     * @notice Transfer token or ETH to a destinatary\n', '     * @param _token - Address of the token\n', '     * @param _to - Address of the recipient\n', '     * @param _val - Uint256 of the amount to transfer\n', '     * @return bool - Whether the transfer was success or not\n', '     */\n', '    function transfer(IERC20 _token, address _to, uint256 _val) internal returns (bool) {\n', '        if (ETH_ADDRESS == address(_token)) {\n', '            (bool success, ) = _to.call{value:_val}("");\n', '            return success;\n', '        }\n', '\n', '        return SafeERC20.transfer(_token, _to, _val);\n', '    }\n', '}\n', '\n', '// File: contracts/commons/Order.sol\n', '\n', '\n', 'pragma solidity ^0.6.8;\n', '\n', '\n', 'contract Order {\n', '    address public constant ETH_ADDRESS = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n', '}\n', '\n', '// File: contracts/interfaces/IHandler.sol\n', '\n', 'pragma solidity ^0.6.8;\n', '\n', '\n', 'interface IHandler {\n', '    /// @notice receive ETH\n', '    receive() external payable;\n', '\n', '    /**\n', '     * @notice Handle an order execution\n', '     * @param _inputToken - Address of the input token\n', '     * @param _outputToken - Address of the output token\n', '     * @param _inputAmount - uint256 of the input token amount\n', '     * @param _minReturn - uint256 of the min return amount of output token\n', '     * @param _data - Bytes of arbitrary data\n', '     * @return bought - Amount of output token bought\n', '     */\n', '    function handle(\n', '        IERC20 _inputToken,\n', '        IERC20 _outputToken,\n', '        uint256 _inputAmount,\n', '        uint256 _minReturn,\n', '        bytes calldata _data\n', '    ) external payable returns (uint256 bought);\n', '\n', '    /**\n', '     * @notice Check whether can handle an order execution\n', '     * @param _inputToken - Address of the input token\n', '     * @param _outputToken - Address of the output token\n', '     * @param _inputAmount - uint256 of the input token amount\n', '     * @param _minReturn - uint256 of the min return amount of output token\n', '     * @param _data - Bytes of arbitrary data\n', '     * @return bool - Whether the execution can be handled or not\n', '     */\n', '    function canHandle(\n', '        IERC20 _inputToken,\n', '        IERC20 _outputToken,\n', '        uint256 _inputAmount,\n', '        uint256 _minReturn,\n', '        bytes calldata _data\n', '    ) external view returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/uniswapV1/IUniswapExchange.sol\n', '\n', '\n', 'pragma solidity ^0.6.8;\n', '\n', '\n', 'abstract contract IUniswapExchange {\n', '    // Address of ERC20 token sold on this exchange\n', '    function tokenAddress() external virtual view returns (address token);\n', '    // Address of Uniswap Factory\n', '    function factoryAddress() external virtual view returns (address factory);\n', '    // Provide Liquidity\n', '    function addLiquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external virtual payable returns (uint256);\n', '    function removeLiquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external virtual returns (uint256, uint256);\n', '    // Get Prices\n', '    function getEthToTokenInputPrice(uint256 eth_sold) external virtual view returns (uint256 tokens_bought);\n', '    function getEthToTokenOutputPrice(uint256 tokens_bought) external virtual view returns (uint256 eth_sold);\n', '    function getTokenToEthInputPrice(uint256 tokens_sold) external virtual view returns (uint256 eth_bought);\n', '    function getTokenToEthOutputPrice(uint256 eth_bought) external virtual view returns (uint256 tokens_sold);\n', '    // Trade ETH to ERC20\n', '    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external virtual payable returns (uint256  tokens_bought);\n', '    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient) external virtual payable returns (uint256  tokens_bought);\n', '    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline) external virtual payable returns (uint256  eth_sold);\n', '    function ethToTokenTransferOutput(uint256 tokens_bought, uint256 deadline, address recipient) external virtual payable returns (uint256  eth_sold);\n', '    // Trade ERC20 to ETH\n', '    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external virtual returns (uint256  eth_bought);\n', '    function tokenToEthTransferInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external virtual returns (uint256  eth_bought);\n', '    function tokenToEthSwapOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external virtual returns (uint256  tokens_sold);\n', '    function tokenToEthTransferOutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external virtual returns (uint256  tokens_sold);\n', '    // Trade ERC20 to ERC20\n', '    function tokenToTokenSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external virtual returns (uint256  tokens_bought);\n', '    function tokenToTokenTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external virtual returns (uint256  tokens_bought);\n', '    function tokenToTokenSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external virtual returns (uint256  tokens_sold);\n', '    function tokenToTokenTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external virtual returns (uint256  tokens_sold);\n', '    // Trade ERC20 to Custom Pool\n', '    function tokenToExchangeSwapInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external virtual returns (uint256  tokens_bought);\n', '    function tokenToExchangeTransferInput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external virtual returns (uint256  tokens_bought);\n', '    function tokenToExchangeSwapOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external virtual returns (uint256  tokens_sold);\n', '    function tokenToExchangeTransferOutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external virtual returns (uint256  tokens_sold);\n', '    // ERC20 comaptibility for liquidity tokens\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public decimals;\n', '    function transfer(address _to, uint256 _value) external virtual returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 value) external virtual returns (bool);\n', '    function approve(address _spender, uint256 _value) external virtual returns (bool);\n', '    function allowance(address _owner, address _spender) external virtual view returns (uint256);\n', '    function balanceOf(address _owner) external virtual view returns (uint256);\n', '    function totalSupply() external virtual view returns (uint256);\n', '    // Never use\n', '    function setup(address token_addr) external virtual;\n', '}\n', '\n', '// File: contracts/interfaces/uniswapV1/IUniswapFactory.sol\n', '\n', '\n', 'pragma solidity ^0.6.8;\n', '\n', '\n', '\n', '\n', 'abstract contract IUniswapFactory {\n', '    // Public Variables\n', '    address public exchangeTemplate;\n', '    uint256 public tokenCount;\n', '    // Create Exchange\n', '    function createExchange(address token) external virtual returns (address exchange);\n', '    // Get Exchange and Token Info\n', '    function getExchange(address token) external virtual view returns (IUniswapExchange exchange);\n', '    function getToken(address exchange) external virtual view returns (IERC20 token);\n', '    function getTokenWithId(uint256 tokenId) external virtual view returns (address token);\n', '    // Never use\n', '    function initializeFactory(address template) external virtual;\n', '}\n', '\n', '// File: contracts/handlers/UniswapV1Handler.sol\n', '\n', 'pragma solidity ^0.6.8;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @notice UniswapV1 Handler used to execute an order\n', 'contract UniswapV1Handler is IHandler, Order {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 private constant never = uint(-1);\n', '\n', '    IUniswapFactory public immutable uniswapFactory;\n', '\n', '    /**\n', '     * @notice Creates the handler\n', '     * @param _uniswapFactory - Address of the uniswap v1 factory contract\n', '     */\n', '    constructor(IUniswapFactory _uniswapFactory) public {\n', '        uniswapFactory = _uniswapFactory;\n', '    }\n', '\n', '    /// @notice receive ETH\n', '    receive() external override payable {\n', '        require(msg.sender != tx.origin, "UniswapV1Handler#receive: NO_SEND_ETH_PLEASE");\n', '    }\n', '\n', '    /**\n', '     * @notice Handle an order execution\n', '     * @param _inputToken - Address of the input token\n', '     * @param _outputToken - Address of the output token\n', '     * @param _data - Bytes of arbitrary data\n', '     * @return bought - Amount of output token bought\n', '     */\n', '    function handle(\n', '        IERC20 _inputToken,\n', '        IERC20 _outputToken,\n', '        uint256,\n', '        uint256,\n', '        bytes calldata _data\n', '    ) external payable override returns (uint256 bought) {\n', "        // Load real initial balance, don't trust provided value\n", '        uint256 inputAmount = PineUtils.balanceOf(_inputToken, address(this));\n', '\n', '        (,address payable relayer, uint256 fee) = abi.decode(_data, (address, address, uint256));\n', '\n', '        if (address(_inputToken) == ETH_ADDRESS) {\n', '            // Keep some eth for paying the fee\n', '            uint256 sell = inputAmount.sub(fee);\n', '            bought = _ethToToken(uniswapFactory, _outputToken, sell, msg.sender);\n', '        } else if (address(_outputToken) == ETH_ADDRESS) {\n', '            // Convert\n', '            bought = _tokenToEth(uniswapFactory, _inputToken, inputAmount);\n', '            bought = bought.sub(fee);\n', '\n', '            // Send amount bought\n', '            (bool successSender,) = msg.sender.call{value: bought}("");\n', '            require(successSender, "UniswapV1Handler#handle: TRANSFER_ETH_TO_CALLER_FAILED");\n', '        } else {\n', '            // Convert from fromToken to ETH\n', '            uint256 boughtEth = _tokenToEth(uniswapFactory, _inputToken, inputAmount);\n', '\n', '            // Convert from ETH to toToken\n', '            bought = _ethToToken(uniswapFactory, _outputToken, boughtEth.sub(fee), msg.sender);\n', '        }\n', '\n', '        // Send fee to relayer\n', '        (bool successRelayer,) = relayer.call{value: fee}("");\n', '        require(successRelayer, "UniswapV1Handler#handle: TRANSFER_ETH_TO_RELAYER_FAILED");\n', '    }\n', '\n', '    /**\n', '     * @notice Check whether can handle an order execution\n', '     * @param _inputToken - Address of the input token\n', '     * @param _outputToken - Address of the output token\n', '     * @param _inputAmount - uint256 of the input token amount\n', '     * @param _minReturn - uint256 of the min return amount of output token\n', '     * @param _data - Bytes of arbitrary data\n', '     * @return bool - Whether the execution can be handled or not\n', '     */\n', '    function canHandle(\n', '        IERC20 _inputToken,\n', '        IERC20 _outputToken,\n', '        uint256 _inputAmount,\n', '        uint256 _minReturn,\n', '        bytes calldata _data\n', '    ) external override view returns (bool) {\n', '        (,,uint256 fee) = abi.decode(_data, (address, address, uint256));\n', '\n', '        uint256 bought;\n', '\n', '        if (address(_inputToken) == ETH_ADDRESS) {\n', '            if (_inputAmount <= fee) {\n', '                return false;\n', '            }\n', '\n', '            uint256 sell = _inputAmount.sub(fee);\n', '            bought = _outEthToToken(uniswapFactory, _outputToken, sell);\n', '        } else if (address(_outputToken) == ETH_ADDRESS) {\n', '            bought = _outTokenToEth(uniswapFactory ,_inputToken, _inputAmount);\n', '\n', '            if (bought <= fee) {\n', '                return false;\n', '            }\n', '\n', '            bought = bought.sub(fee);\n', '        } else {\n', '            uint256 boughtEth =  _outTokenToEth(uniswapFactory, _inputToken, _inputAmount);\n', '            if (boughtEth <= fee) {\n', '                return false;\n', '            }\n', '\n', '            bought = _outEthToToken(uniswapFactory, _outputToken, boughtEth.sub(fee));\n', '        }\n', '\n', '        return bought >= _minReturn;\n', '    }\n', '\n', '    /**\n', '     * @notice Simulate an order execution\n', '     * @param _inputToken - Address of the input token\n', '     * @param _outputToken - Address of the output token\n', '     * @param _inputAmount - uint256 of the input token amount\n', '     * @param _minReturn - uint256 of the min return amount of output token\n', '     * @param _data - Bytes of arbitrary data\n', '     * @return bool - Whether the execution can be handled or not\n', '     * @return uint256 - Amount of output token bought\n', '     */\n', '    function simulate(\n', '        IERC20 _inputToken,\n', '        IERC20 _outputToken,\n', '        uint256 _inputAmount,\n', '        uint256 _minReturn,\n', '        bytes calldata _data\n', '    ) external view returns (bool, uint256) {\n', '        (,,uint256 fee) = abi.decode(_data, (address, address, uint256));\n', '\n', '        uint256 bought;\n', '\n', '        if (address(_inputToken) == ETH_ADDRESS) {\n', '            if (_inputAmount <= fee) {\n', '                return (false, 0);\n', '            }\n', '\n', '            uint256 sell = _inputAmount.sub(fee);\n', '            bought = _outEthToToken(uniswapFactory, _outputToken, sell);\n', '        } else if (address(_outputToken) == ETH_ADDRESS) {\n', '            bought = _outTokenToEth(uniswapFactory ,_inputToken, _inputAmount);\n', '\n', '            if (bought <= fee) {\n', '                return (false, 0);\n', '            }\n', '\n', '            bought = bought.sub(fee);\n', '        } else {\n', '            uint256 boughtEth =  _outTokenToEth(uniswapFactory, _inputToken, _inputAmount);\n', '            if (boughtEth <= fee) {\n', '                return (false, 0);\n', '            }\n', '\n', '            bought = _outEthToToken(uniswapFactory, _outputToken, boughtEth.sub(fee));\n', '        }\n', '\n', '        return (bought >= _minReturn, bought);\n', '    }\n', '\n', '    /**\n', '     * @notice Trade ETH to token\n', '     * @param _uniswapFactory - Address of uniswap v1 factory\n', '     * @param _token - Address of the output token\n', '     * @param _amount - uint256 of the ETH amount\n', '     * @param _dest - Address of the trade recipient\n', '     * @return bought - Amount of output token bought\n', '     */\n', '    function _ethToToken(\n', '        IUniswapFactory _uniswapFactory,\n', '        IERC20 _token,\n', '        uint256 _amount,\n', '        address _dest\n', '    ) private returns (uint256) {\n', '        IUniswapExchange uniswap = _uniswapFactory.getExchange(address(_token));\n', '\n', '        return uniswap.ethToTokenTransferInput{value: _amount}(1, never, _dest);\n', '    }\n', '\n', '    /**\n', '     * @notice Trade token to ETH\n', '     * @param _uniswapFactory - Address of uniswap v1 factory\n', '     * @param _token - Address of the input token\n', '     * @param _amount - uint256 of the input token amount\n', '     * @return bought - Amount of ETH bought\n', '     */\n', '    function _tokenToEth(\n', '        IUniswapFactory _uniswapFactory,\n', '        IERC20 _token,\n', '        uint256 _amount\n', '    ) private returns (uint256) {\n', '        IUniswapExchange uniswap = _uniswapFactory.getExchange(address(_token));\n', '        require(address(uniswap) != address(0), "UniswapV1Handler#_tokenToEth: EXCHANGE_DOES_NOT_EXIST");\n', '\n', '        // Check if previous allowance is enough and approve Uniswap if not\n', '        uint256 prevAllowance = _token.allowance(address(this), address(uniswap));\n', '        if (prevAllowance < _amount) {\n', '            if (prevAllowance != 0) {\n', '                _token.approve(address(uniswap), 0);\n', '            }\n', '\n', '            _token.approve(address(uniswap), uint(-1));\n', '        }\n', '\n', '        // Execute the trade\n', '        return uniswap.tokenToEthSwapInput(_amount, 1, never);\n', '    }\n', '\n', '    /**\n', '     * @notice Simulate a ETH to token trade\n', '     * @param _uniswapFactory - Address of uniswap v1 factory\n', '     * @param _token - Address of the output token\n', '     * @param _amount - uint256 of the ETH amount\n', '     * @return bought - Amount of output token bought\n', '     */\n', '    function _outEthToToken(IUniswapFactory _uniswapFactory, IERC20 _token, uint256 _amount) private view returns (uint256) {\n', '        return _uniswapFactory.getExchange(address(_token)).getEthToTokenInputPrice(_amount);\n', '    }\n', '\n', '    /**\n', '     * @notice Simulate a token to ETH trade\n', '     * @param _uniswapFactory - Address of uniswap v1 factory\n', '     * @param _token - Address of the input token\n', '     * @param _amount - uint256 of the input token amount\n', '     * @return bought - Amount of ETH bought\n', '     */\n', '    function _outTokenToEth(IUniswapFactory _uniswapFactory, IERC20 _token, uint256 _amount) private view returns (uint256) {\n', '        return _uniswapFactory.getExchange(address(_token)).getTokenToEthInputPrice(_amount);\n', '    }\n', '}']