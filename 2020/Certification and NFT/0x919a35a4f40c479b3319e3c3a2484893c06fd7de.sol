['// File: contracts\\modules\\Ownable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Managerable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'contract Managerable is Ownable {\n', '\n', '    address private _managerAddress;\n', '    /**\n', '     * @dev modifier, Only manager can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyManager() {\n', '        require(_managerAddress == msg.sender,"Managerable: caller is not the Manager");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev set manager by owner. \n', '     *\n', '     */\n', '    function setManager(address managerAddress)\n', '    public\n', '    onlyOwner\n', '    {\n', '        _managerAddress = managerAddress;\n', '    }\n', '    /**\n', '     * @dev get manager address. \n', '     *\n', '     */\n', '    function getManager()public view returns (address) {\n', '        return _managerAddress;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Halt.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', 'contract Halt is Ownable {\n', '    \n', '    bool private halted = false; \n', '    \n', '    modifier notHalted() {\n', '        require(!halted,"This contract is halted");\n', '        _;\n', '    }\n', '\n', '    modifier isHalted() {\n', '        require(halted,"This contract is not halted");\n', '        _;\n', '    }\n', '    \n', '    /// @notice function Emergency situation that requires \n', '    /// @notice contribution period to stop or not.\n', '    function setHalt(bool halt) \n', '        public \n', '        onlyOwner\n', '    {\n', '        halted = halt;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\whiteList.sol\n', '\n', 'pragma solidity =0.5.16;\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible uint32.\n', '     */\n', 'library whiteListUint32 {\n', '    /**\n', '     * @dev add uint32 into white list.\n', '     * @param whiteList the storage whiteList.\n', '     * @param temp input value\n', '     */\n', '\n', '    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\n', '        if (!isEligibleUint32(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    /**\n', '     * @dev remove uint32 from whitelist.\n', '     */\n', '    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible uint256.\n', '     */\n', 'library whiteListUint256 {\n', '    // add whiteList\n', '    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\n', '        if (!isEligibleUint256(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible address.\n', '     */\n', 'library whiteListAddress {\n', '    // add whiteList\n', '    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\n', '        if (!isEligibleAddress(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\AddressWhiteList.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '    /**\n', '     * @dev Implementation of a whitelist filters a eligible address.\n', '     */\n', 'contract AddressWhiteList is Halt {\n', '\n', '    using whiteListAddress for address[];\n', '    uint256 constant internal allPermission = 0xffffffff;\n', '    uint256 constant internal allowBuyOptions = 1;\n', '    uint256 constant internal allowSellOptions = 1<<1;\n', '    uint256 constant internal allowExerciseOptions = 1<<2;\n', '    uint256 constant internal allowAddCollateral = 1<<3;\n', '    uint256 constant internal allowRedeemCollateral = 1<<4;\n', '    // The eligible adress list\n', '    address[] internal whiteList;\n', '    mapping(address => uint256) internal addressPermission;\n', '    /**\n', '     * @dev Implementation of add an eligible address into the whitelist.\n', '     * @param addAddress new eligible address.\n', '     */\n', '    function addWhiteList(address addAddress)public onlyOwner{\n', '        whiteList.addWhiteListAddress(addAddress);\n', '        addressPermission[addAddress] = allPermission;\n', '    }\n', '    function modifyPermission(address addAddress,uint256 permission)public onlyOwner{\n', '        addressPermission[addAddress] = permission;\n', '    }\n', '    /**\n', '     * @dev Implementation of revoke an invalid address from the whitelist.\n', '     * @param removeAddress revoked address.\n', '     */\n', '    function removeWhiteList(address removeAddress)public onlyOwner returns (bool){\n', '        addressPermission[removeAddress] = 0;\n', '        return whiteList.removeWhiteListAddress(removeAddress);\n', '    }\n', '    /**\n', '     * @dev Implementation of getting the eligible whitelist.\n', '     */\n', '    function getWhiteList()public view returns (address[] memory){\n', '        return whiteList;\n', '    }\n', '    /**\n', '     * @dev Implementation of testing whether the input address is eligible.\n', '     * @param tmpAddress input address for testing.\n', '     */    \n', '    function isEligibleAddress(address tmpAddress) public view returns (bool){\n', '        return whiteList.isEligibleAddress(tmpAddress);\n', '    }\n', '    function checkAddressPermission(address tmpAddress,uint256 state) public view returns (bool){\n', '        return  (addressPermission[tmpAddress]&state) == state;\n', '    }\n', '}\n', '\n', '// File: contracts\\OptionsPool\\IOptionsPool.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'interface IOptionsPool {\n', '//    function getOptionBalances(address user) external view returns(uint256[]);\n', '\n', '    function getExpirationList()external view returns (uint32[] memory);\n', '    function createOptions(address from,address settlement,uint256 type_ly_expiration,\n', '        uint128 strikePrice,uint128 underlyingPrice,uint128 amount,uint128 settlePrice) external returns(uint256);\n', '    function setSharedState(uint256 newFirstOption,int256[] calldata latestNetWorth,address[] calldata whiteList) external;\n', '    function getAllTotalOccupiedCollateral() external view returns (uint256,uint256);\n', '    function getCallTotalOccupiedCollateral() external view returns (uint256);\n', '    function getPutTotalOccupiedCollateral() external view returns (uint256);\n', '    function getTotalOccupiedCollateral() external view returns (uint256);\n', '//    function buyOptionCheck(uint32 expiration,uint32 underlying)external view;\n', '    function burnOptions(address from,uint256 id,uint256 amount,uint256 optionPrice)external;\n', '    function getOptionsById(uint256 optionsId)external view returns(uint256,address,uint8,uint32,uint256,uint256,uint256);\n', '    function getExerciseWorth(uint256 optionsId,uint256 amount)external view returns(uint256);\n', '    function calculatePhaseOptionsFall(uint256 lastOption,uint256 begin,uint256 end,address[] calldata whiteList) external view returns(int256[] memory);\n', '    function getOptionInfoLength()external view returns (uint256);\n', '    function getNetWrothCalInfo(address[] calldata whiteList)external view returns(uint256,int256[] memory);\n', '    function calRangeSharedPayment(uint256 lastOption,uint256 begin,uint256 end,address[] calldata whiteList)external view returns(int256[] memory,uint256[] memory,uint256);\n', '    function getNetWrothLatestWorth(address settlement)external view returns(int256);\n', '    function getBurnedFullPay(uint256 optionID,uint256 amount) external view returns(address,uint256);\n', '\n', '}\n', 'contract ImportOptionsPool is Ownable{\n', '    IOptionsPool internal _optionsPool;\n', '    function getOptionsPoolAddress() public view returns(address){\n', '        return address(_optionsPool);\n', '    }\n', '    function setOptionsPoolAddress(address optionsPool)public onlyOwner{\n', '        _optionsPool = IOptionsPool(optionsPool);\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Operator.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * each operator can be granted exclusive access to specific functions.\n', ' *\n', ' */\n', 'contract Operator is Ownable {\n', '    using whiteListAddress for address[];\n', '    address[] private _operatorList;\n', '    /**\n', '     * @dev modifier, every operator can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyOperator() {\n', '        require(_operatorList.isEligibleAddress(msg.sender),"Managerable: caller is not the Operator");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev modifier, Only indexed operator can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyOperatorIndex(uint256 index) {\n', '        require(_operatorList.length>index && _operatorList[index] == msg.sender,"Operator: caller is not the eligible Operator");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev add a new operator by owner. \n', '     *\n', '     */\n', '    function addOperator(address addAddress)public onlyOwner{\n', '        _operatorList.addWhiteListAddress(addAddress);\n', '    }\n', '    /**\n', '     * @dev modify indexed operator by owner. \n', '     *\n', '     */\n', '    function setOperator(uint256 index,address addAddress)public onlyOwner{\n', '        _operatorList[index] = addAddress;\n', '    }\n', '    /**\n', '     * @dev remove operator by owner. \n', '     *\n', '     */\n', '    function removeOperator(address removeAddress)public onlyOwner returns (bool){\n', '        return _operatorList.removeWhiteListAddress(removeAddress);\n', '    }\n', '    /**\n', '     * @dev get all operators. \n', '     *\n', '     */\n', '    function getOperator()public view returns (address[] memory) {\n', '        return _operatorList;\n', '    }\n', '    /**\n', '     * @dev set all operators by owner. \n', '     *\n', '     */\n', '    function setOperators(address[] memory operators)public onlyOwner {\n', '        _operatorList = operators;\n', '    }\n', '}\n', '\n', '// File: contracts\\CollateralPool\\CollateralData.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title collateral pool contract with coin and necessary storage data.\n', " * @dev A smart-contract which stores user's deposited collateral.\n", ' *\n', ' */\n', 'contract CollateralData is AddressWhiteList,Managerable,Operator,ImportOptionsPool{\n', '        // The total fees accumulated in the contract\n', '    mapping (address => uint256) \tinternal feeBalances;\n', '    uint32[] internal FeeRates;\n', '     /**\n', '     * @dev Returns the rate of trasaction fee.\n', '     */   \n', '    uint256 constant internal buyFee = 0;\n', '    uint256 constant internal sellFee = 1;\n', '    uint256 constant internal exerciseFee = 2;\n', '    uint256 constant internal addColFee = 3;\n', '    uint256 constant internal redeemColFee = 4;\n', '    event RedeemFee(address indexed recieptor,address indexed settlement,uint256 payback);\n', '    event AddFee(address indexed settlement,uint256 payback);\n', '    event TransferPayback(address indexed recieptor,address indexed settlement,uint256 payback);\n', '\n', '    //token net worth balance\n', '    mapping (address => int256) internal netWorthBalances;\n', '    //total user deposited collateral balance\n', '    // map from collateral address to amount\n', '    mapping (address => uint256) internal collateralBalances;\n', '    //user total paying for collateral, priced in usd;\n', '    mapping (address => uint256) internal userCollateralPaying;\n', '    //user original deposited collateral.\n', '    //map account -> collateral -> amount\n', '    mapping (address => mapping (address => uint256)) internal userInputCollateral;\n', '}\n', '\n', '// File: contracts\\Proxy\\baseProxy.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @title  baseProxy Contract\n', '\n', ' */\n', 'contract baseProxy is Ownable {\n', '    address public implementation;\n', '    constructor(address implementation_) public {\n', '        // Creator of the contract is admin during initialization\n', '        implementation = implementation_; \n', '        (bool success,) = implementation_.delegatecall(abi.encodeWithSignature("initialize()"));\n', '        require(success);\n', '    }\n', '    function getImplementation()public view returns(address){\n', '        return implementation;\n', '    }\n', '    function setImplementation(address implementation_)public onlyOwner{\n', '        implementation = implementation_; \n', '        (bool success,) = implementation_.delegatecall(abi.encodeWithSignature("update()"));\n', '        require(success);\n', '    }\n', '\n', '    /**\n', '     * @notice Delegates execution to the implementation contract\n', '     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n', '     * @param data The raw data to delegatecall\n', '     * @return The returned bytes from the delegatecall\n', '     */\n', '    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n', '        (bool success, bytes memory returnData) = implementation.delegatecall(data);\n', '        assembly {\n', '            if eq(success, 0) {\n', '                revert(add(returnData, 0x20), returndatasize)\n', '            }\n', '        }\n', '        return returnData;\n', '    }\n', '\n', '    /**\n', '     * @notice Delegates execution to an implementation contract\n', '     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n', '     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n', '     * @param data The raw data to delegatecall\n', '     * @return The returned bytes from the delegatecall\n', '     */\n', '    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n', '        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature("delegateToImplementation(bytes)", data));\n', '        assembly {\n', '            if eq(success, 0) {\n', '                revert(add(returnData, 0x20), returndatasize)\n', '            }\n', '        }\n', '        return abi.decode(returnData, (bytes));\n', '    }\n', '\n', '    function delegateToViewAndReturn() internal view returns (bytes memory) {\n', '        (bool success, ) = address(this).staticcall(abi.encodeWithSignature("delegateToImplementation(bytes)", msg.data));\n', '\n', '        assembly {\n', '            let free_mem_ptr := mload(0x40)\n', '            returndatacopy(free_mem_ptr, 0, returndatasize)\n', '\n', '            switch success\n', '            case 0 { revert(free_mem_ptr, returndatasize) }\n', '            default { return(add(free_mem_ptr, 0x40), returndatasize) }\n', '        }\n', '    }\n', '\n', '    function delegateAndReturn() internal returns (bytes memory) {\n', '        (bool success, ) = implementation.delegatecall(msg.data);\n', '\n', '        assembly {\n', '            let free_mem_ptr := mload(0x40)\n', '            returndatacopy(free_mem_ptr, 0, returndatasize)\n', '\n', '            switch success\n', '            case 0 { revert(free_mem_ptr, returndatasize) }\n', '            default { return(free_mem_ptr, returndatasize) }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\CollateralPool\\CollateralProxy.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '/**\n', ' * @title  Erc20Delegator Contract\n', '\n', ' */\n', 'contract CollateralProxy is CollateralData,baseProxy{\n', '        /**\n', '     * @dev constructor function , setting contract address.\n', '     *  oracleAddr FNX oracle contract address\n', '     *  optionsPriceAddr options price contract address\n', '     *  ivAddress implied volatility contract address\n', '     */  \n', '\n', '    constructor(address implementation_,address optionsPool)\n', '         baseProxy(implementation_) public  {\n', '        _optionsPool = IOptionsPool(optionsPool);\n', '    }\n', '        /**\n', '     * @dev Transfer colleteral from manager contract to this contract.\n', '     *  Only manager contract can invoke this function.\n', '     */\n', '    function () external payable onlyManager{\n', '\n', '    }\n', '    function getFeeRateAll()public view returns (uint32[] memory){\n', '        delegateToViewAndReturn();\n', '    }\n', '    function getFeeRate(uint256 /*feeType*/)public view returns (uint32){\n', '        delegateToViewAndReturn();\n', '    }\n', '    /**\n', '     * @dev set the rate of trasaction fee.\n', '     *  feeType the transaction fee type\n', '     *  numerator the numerator of transaction fee .\n', '     *  denominator thedenominator of transaction fee.\n', '     * transaction fee = numerator/denominator;\n', '     */   \n', '    function setTransactionFee(uint256 /*feeType*/,uint32 /*thousandth*/)public{\n', '        delegateAndReturn();\n', '    }\n', '\n', '    function getFeeBalance(address /*settlement*/)public view returns(uint256){\n', '        delegateToViewAndReturn();\n', '    }\n', '    function getAllFeeBalances()public view returns(address[] memory,uint256[] memory){\n', '        delegateToViewAndReturn();\n', '    }\n', '    function redeem(address /*currency*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    function redeemAll()public{\n', '        delegateAndReturn();\n', '    }\n', '    function calculateFee(uint256 /*feeType*/,uint256 /*amount*/)public view returns (uint256){\n', '        delegateToViewAndReturn();\n', '    }\n', '        /**\n', '     * @dev An interface for add transaction fee.\n', '     *  Only manager contract can invoke this function.\n', '     *  collateral collateral address, also is the coin for fee.\n', '     *  amount total transaction amount.\n', '     *  feeType transaction fee type. see TransactionFee contract\n', '     */\n', '    function addTransactionFee(address /*collateral*/,uint256 /*amount*/,uint256 /*feeType*/)public returns (uint256) {\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', "     * @dev Retrieve user's cost of collateral, priced in USD.\n", '     *  user input retrieved account \n', '     */\n', '    function getUserPayingUsd(address /*user*/)public view returns (uint256){\n', '        delegateToViewAndReturn();\n', '    }\n', '    /**\n', "     * @dev Retrieve user's amount of the specified collateral.\n", '     *  user input retrieved account \n', '     *  collateral input retrieved collateral coin address \n', '     */\n', '    function getUserInputCollateral(address /*user*/,address /*collateral*/)public view returns (uint256){\n', '        delegateToViewAndReturn();\n', '    }\n', '    /**\n', '     * @dev Retrieve collateral balance data.\n', '     *  collateral input retrieved collateral coin address \n', '     */\n', '    function getCollateralBalance(address /*collateral*/)public view returns (uint256){\n', '        delegateToViewAndReturn();\n', '    }\n', '    /**\n', '     * @dev Opterator user paying data, priced in USD. Only manager contract can modify database.\n', '     *  user input user account which need add paying amount.\n', '     *  amount the input paying amount.\n', '     */\n', '    function addUserPayingUsd(address /*user*/,uint256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev Opterator user input collateral data. Only manager contract can modify database.\n', '     *  user input user account which need add input collateral.\n', '     *  collateral the collateral address.\n', '     *  amount the input collateral amount.\n', '     */\n', '    function addUserInputCollateral(address /*user*/,address /*collateral*/,uint256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev Opterator net worth balance data. Only manager contract can modify database.\n', '     *  collateral available colleteral address.\n', '     *  amount collateral net worth increase amount.\n', '     */\n', '    function addNetWorthBalance(address /*collateral*/,int256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev Opterator collateral balance data. Only manager contract can modify database.\n', '     *  collateral available colleteral address.\n', '     *  amount collateral colleteral increase amount.\n', '     */\n', '    function addCollateralBalance(address /*collateral*/,uint256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev Substract user paying data,priced in USD. Only manager contract can modify database.\n', "     *  user user's account.\n", "     *  amount user's decrease amount.\n", '     */\n', '    function subUserPayingUsd(address /*user*/,uint256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', "     * @dev Substract user's collateral balance. Only manager contract can modify database.\n", "     *  user user's account.\n", '     *  collateral collateral address.\n', "     *  amount user's decrease amount.\n", '     */\n', '    function subUserInputCollateral(address /*user*/,address /*collateral*/,uint256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev Substract net worth balance. Only manager contract can modify database.\n', '     *  collateral collateral address.\n', '     *  amount the decrease amount.\n', '     */\n', '    function subNetWorthBalance(address /*collateral*/,int256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev Substract collateral balance. Only manager contract can modify database.\n', '     *  collateral collateral address.\n', '     *  amount the decrease amount.\n', '     */\n', '    function subCollateralBalance(address /*collateral*/,uint256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev set user paying data,priced in USD. Only manager contract can modify database.\n', "     *  user user's account.\n", "     *  amount user's new amount.\n", '     */\n', '    function setUserPayingUsd(address /*user*/,uint256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', "     * @dev set user's collateral balance. Only manager contract can modify database.\n", "     *  user user's account.\n", '     *  collateral collateral address.\n', "     *  amount user's new amount.\n", '     */\n', '    function setUserInputCollateral(address /*user*/,address /*collateral*/,uint256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev set net worth balance. Only manager contract can modify database.\n', '     *  collateral collateral address.\n', '     *  amount the new amount.\n', '     */\n', '    function setNetWorthBalance(address /*collateral*/,int256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev set collateral balance. Only manager contract can modify database.\n', '     *  collateral collateral address.\n', '     *  amount the new amount.\n', '     */\n', '    function setCollateralBalance(address /*collateral*/,uint256 /*amount*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', "     * @dev Operation for transfer user's payback and deduct transaction fee. Only manager contract can invoke this function.\n", '     *  recieptor the recieptor account.\n', '     *  settlement the settlement coin address.\n', '     *  payback the payback amount\n', '     *  feeType the transaction fee type. see transactionFee contract\n', '     */\n', '    function transferPaybackAndFee(address payable /*recieptor*/,address /*settlement*/,uint256 /*payback*/,\n', '            uint256 /*feeType*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    function buyOptionsPayfor(address payable /*recieptor*/,address /*settlement*/,uint256 /*settlementAmount*/,uint256 /*allPay*/)public onlyManager{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', "     * @dev Operation for transfer user's payback. Only manager contract can invoke this function.\n", '     *  recieptor the recieptor account.\n', '     *  settlement the settlement coin address.\n', '     *  payback the payback amount\n', '     */\n', '    function transferPayback(address payable /*recieptor*/,address /*settlement*/,uint256 /*payback*/)public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', "     * @dev Operation for transfer user's payback and deduct transaction fee for multiple settlement Coin.\n", '     *       Specially used for redeem collateral.Only manager contract can invoke this function.\n', '     *  account the recieptor account.\n', '     *  redeemWorth the redeem worth, priced in USD.\n', '     *  tmpWhiteList the settlement coin white list\n', "     *  colBalances the Collateral balance based for user's input collateral.\n", "     *  PremiumBalances the premium collateral balance if redeem worth is exceeded user's input collateral.\n", '     *  prices the collateral prices list.\n', '     */\n', '    function transferPaybackBalances(address payable /*account*/,uint256 /*redeemWorth*/,\n', '            address[] memory /*tmpWhiteList*/,uint256[] memory /*colBalances*/,\n', '            uint256[] memory /*PremiumBalances*/,uint256[] memory /*prices*/)public {\n', '            delegateAndReturn();\n', '    }\n', '    /**\n', "     * @dev calculate user's input collateral balance and premium collateral balance.\n", "     *      Specially used for user's redeem collateral.\n", '     *  account the recieptor account.\n', "     *  userTotalWorth the user's total FPTCoin worth, priced in USD.\n", '     *  tmpWhiteList the settlement coin white list\n', '     *  _RealBalances the real Collateral balance.\n', '     *  prices the collateral prices list.\n', '     */\n', '    function getCollateralAndPremiumBalances(address /*account*/,uint256 /*userTotalWorth*/,address[] memory /*tmpWhiteList*/,\n', '        uint256[] memory /*_RealBalances*/,uint256[] memory /*prices*/) public view returns(uint256[] memory,uint256[] memory){\n', '            delegateToViewAndReturn();\n', '    } \n', '    function getAllRealBalance(address[] memory /*whiteList*/)public view returns(int256[] memory){\n', '        delegateToViewAndReturn();\n', '    }\n', '    function getRealBalance(address /*settlement*/)public view returns(int256){\n', '        delegateToViewAndReturn();\n', '    }\n', '    function getNetWorthBalance(address /*settlement*/)public view returns(uint256){\n', '        delegateToViewAndReturn();\n', '    }\n', '    /**\n', '     * @dev  The foundation operator want to add some coin to netbalance, which can increase the FPTCoin net worth.\n', '     *  settlement the settlement coin address which the foundation operator want to transfer in this contract address.\n', '     *  amount the amount of the settlement coin which the foundation operator want to transfer in this contract address.\n', '     */\n', '    function addNetBalance(address /*settlement*/,uint256 /*amount*/) public payable{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev Calculate the collateral pool shared worth.\n', '     * The foundation operator will invoke this function frequently\n', '     */\n', '    function calSharedPayment(address[] memory /*_whiteList*/) public{\n', '        delegateAndReturn();\n', '    }\n', '    /**\n', '     * @dev Set the calculation results of the collateral pool shared worth.\n', '     * The foundation operator will invoke this function frequently\n', "     *  newNetworth Current expired options' net worth \n", "     *  sharedBalances All unexpired options' shared balance distributed by time.\n", "     *  firstOption The new first unexpired option's index.\n", '     */\n', '    function setSharedPayment(address[] memory /*_whiteList*/,int256[] memory /*newNetworth*/,\n', '            int256[] memory /*sharedBalances*/,uint256 /*firstOption*/) public{\n', '        delegateAndReturn();\n', '    }\n', '\n', '}']