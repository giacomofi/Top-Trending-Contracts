['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.2;\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'library UniswapV2Library {\n', '    using SafeMath for uint;\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        pair = address(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n", '            ))));\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair\n', '    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n', '    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n', "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n", "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountB = amountA.mul(reserveB) / reserveA;\n', '    }\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = amountIn.mul(997);\n', '        uint numerator = amountInWithFee.mul(reserveOut);\n', '        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    // performs chained getAmountOut calculations on any number of pairs\n', '    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n', '            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', 'contract Pausable is Context {\n', '    /**\n', '     * @dev Emitted when the pause is triggered by `account`.\n', '     */\n', '    event Paused(address account);\n', '\n', '    /**\n', '     * @dev Emitted when the pause is lifted by `account`.\n', '     */\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    /**\n', '     * @dev Initializes the contract in unpaused state.\n', '     */\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the contract is paused, and false otherwise.\n', '     */\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused, "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused, "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Triggers stopped state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    function _pause() internal virtual whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(_msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Returns to normal state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    function _unpause() internal virtual whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(_msgSender());\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () internal {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/// @title LP Staking Contract\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface INodeRunnersNFT {\n', '    function getFighter(uint256 tokenId) external view returns (uint256, uint256, uint256, uint256, uint256, uint256);\n', '    function mint(address to, uint256 id, uint256 amount) external;\n', '}\n', '\n', 'interface IUniswap {\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n', '    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function WETH() external pure returns(address);\n', '    function getAmountsOut(uint amountIn, address[] memory path) external pure returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IFactory {\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n', '    function totalSupply() external view returns (uint);\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '}\n', '\n', 'contract LPStaking is ReentrancyGuard, Pausable, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /* ========== STATE VARIABLES ========== */\n', '\n', '    address payable public treasury;\n', '    address public NFT;\n', '    address public NDR;\n', '    IERC20 public rewardsToken;\n', '    IERC20 public stakingToken;\n', '    IUniswap public uniswap;\n', '    IFactory public factory;\n', '\n', '    uint256 public periodFinish = 0;\n', '    uint256 public rewardRate = 0;\n', '    uint256 public rewardsDuration = 360 days;\n', '    uint256 public lastUpdateTime;\n', '    uint256 public rewardPerTokenStored;\n', '    uint256 public interest = 10;\n', '    uint256 public minLp = 2250000000000000000;\n', '    uint256 public maxLp = 22500000000000000000;\n', '    uint256 public mulHero1;\n', '    uint256 public mulHero2;\n', '    uint256 public mulSupport1;\n', '    uint256 public mulSupport2;\n', '    uint256 public deadline = 180;\n', '    uint256 public feeRate = 50;\n', '    uint256 private _totalSupply;\n', '\n', '    mapping(address => uint256) public userRewardPerTokenPaid;\n', '    mapping(address => uint256) public rewards;\n', '    mapping(address => uint256) private _balances;\n', '\n', '    /* ========== CONSTRUCTOR ========== */\n', '\n', '    constructor(\n', '        address payable _treasury,\n', '        address _NFT,\n', '        address _NDR,\n', '        address _rewardsToken,\n', '        address _stakingToken,\n', '        address _uniswap,\n', '        address _factory\n', '    ) public {\n', '        treasury = _treasury;\n', '        NFT = _NFT;\n', '        NDR = _NDR;\n', '        rewardsToken = IERC20(_rewardsToken);\n', '        stakingToken = IERC20(_stakingToken);\n', '        uniswap = IUniswap(_uniswap);\n', '        factory = IFactory(_factory);\n', '    }\n', '\n', '    /**\n', '    * @dev Initiate the account of destinations[i] with values[i]. The function must only be called when the contract is paused. The caller must check that destinations are unique addresses.\n', '    * For a large number of destinations, separate the balances initialization in different calls to batchTransfer.\n', '    * @param destinations List of addresses to set the values\n', '    * @param values List of values to set\n', '    */\n', '    function batchTransfer(address[] memory destinations, uint256[] memory values) public onlyOwner whenPaused {\n', '        require(destinations.length == values.length);\n', '\n', '        uint256 length = destinations.length;\n', '        uint i;\n', '\n', '        for (i=0; i < length; i++) {\n', '            rewards[destinations[i]] = values[i];\n', '        }\n', '    }\n', '\n', '    /* ========== VIEWS ========== */\n', '\n', '    function totalSupply() external view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) external view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function lastTimeRewardApplicable() public view returns (uint256) {\n', '        return min(block.timestamp, periodFinish);\n', '    }\n', '\n', '    function rewardPerToken() public view returns (uint256) {\n', '        if (_totalSupply == 0) {\n', '            return rewardPerTokenStored;\n', '        }\n', '        return\n', '            rewardPerTokenStored.add(\n', '                lastTimeRewardApplicable()\n', '                    .sub(lastUpdateTime)\n', '                    .mul(rewardRate)\n', '            );\n', '    }\n', '\n', '    function earned(address account) public view returns (uint256) {\n', '        return\n', '            _balances[account]\n', '                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n', '                .div(1e18)\n', '                .add(rewards[account]);\n', '    }\n', '\n', '    function getRewardForDuration() external view returns (uint256) {\n', '        return rewardRate.mul(rewardsDuration);\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) public pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /* ========== UNISWAP FUNCTIONS ========== */\n', '\n', '    receive() payable external {\n', '        assert(msg.sender == uniswap.WETH());\n', '    }\n', '\n', '    function getAmountsOut(uint amount, address token) internal view returns (uint) {\n', '        uint[] memory amounts = uniswap.getAmountsOut(amount, getPathForTokenToEth(token));\n', '        uint256 outputTokenCount = uint256(amounts[amounts.length - 1]);\n', '        return outputTokenCount;\n', '    }\n', '\n', '    function getPathForTokenToEth(address token) internal view returns (address[] memory) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = uniswap.WETH();\n', '        path[1] = token;\n', '        return path;\n', '    }\n', '\n', '    function swapExactETHForTokens(uint amountEth) internal {\n', '        uniswap.swapExactETHForTokens.value(amountEth)(0, getPathForTokenToEth(address(NDR)), address(this), now + deadline);\n', '    }\n', '\n', '    function addLiquidityETH(uint amountTokenDesired, uint amountEth) internal {\n', '        IERC20(NDR).approve(address(uniswap), amountTokenDesired);\n', '        uint amountADesired = getAmountsOut(amountEth, NDR);\n', '        (uint amountTokenMin,) = quote(amountADesired, amountEth);\n', '        uniswap.addLiquidityETH.value(amountEth)\n', '        (address(NDR), amountTokenDesired, amountTokenMin, amountEth, address(0), now + deadline);\n', '    }\n', '\n', '    function quote(uint amountADesired, uint amountBDesired) internal view returns(uint, uint) {\n', '        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(address(factory), NDR, uniswap.WETH());\n', '        uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n', '        uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n', '        return (amountAOptimal, amountBOptimal);\n', '    }\n', '\n', '    /* ========== MUTATIVE FUNCTIONS ========== */\n', '\n', '    function pause() public onlyOwner whenNotPaused {\n', '        _pause();\n', '        emit Paused(msg.sender);\n', '    }\n', '\n', '    function unpause() public onlyOwner whenPaused {\n', '        _unpause();\n', '        emit Unpaused(msg.sender);\n', '    }\n', '\n', '    function changeAddresses(address payable _treasury, address _NFT, address _NDR, address _rewardsToken, address _stakingToken, address _uniswap, address _factory) public onlyOwner {\n', '        treasury = _treasury;\n', '        NFT = _NFT;\n', '        NDR = _NDR;\n', '        rewardsToken = IERC20(_rewardsToken);\n', '        stakingToken = IERC20(_stakingToken);\n', '        uniswap = IUniswap(_uniswap);\n', '        factory = IFactory(_factory);\n', '    }\n', '\n', '    function changeMultiplierHero(uint256 _mulHero1, uint256 _mulHero2) public onlyOwner returns(uint256, uint256) {\n', '        mulHero1 = _mulHero1;\n', '        mulHero2 = _mulHero2;\n', '        return (mulHero1, mulHero2);\n', '    }\n', '    \n', '    function changeMultiplierSupport(uint256 _mulSupport1, uint256 _mulSupport2) public onlyOwner returns(uint256, uint256) {\n', '        mulSupport1 = _mulSupport1;\n', '        mulSupport2 = _mulSupport2;\n', '        return (mulSupport1, mulSupport2);\n', '    }\n', '\n', '    function changeDeadline(uint256 _deadline) public onlyOwner returns(uint256) {\n', '        deadline = _deadline;\n', '        return deadline;\n', '    }\n', '\n', '    function changeInterest(uint256 _interest) public onlyOwner returns(uint256) {\n', '        interest = _interest;\n', '        return interest;\n', '    }\n', '\n', '    function changeLpAmount(uint256 _minLp, uint256 _maxLp) public onlyOwner returns(uint256, uint256) {\n', '        minLp = _minLp;\n', '        maxLp = _maxLp;\n', '        return (minLp, maxLp);\n', '    }\n', '\n', '    function changeFeeRate(uint256 _feeRate) public onlyOwner returns(uint256) {\n', '        feeRate = _feeRate;\n', '        return feeRate;\n', '    }\n', '\n', '    function withdrawDust(uint256 amount) public onlyOwner {\n', '        treasury.transfer(amount);\n', '    }\n', '\n', '    function stake(uint256 amount) external nonReentrant whenNotPaused updateReward(msg.sender) {\n', '        require(amount > 0, "Cannot stake 0");\n', '        require(_balances[msg.sender].add(amount) >= minLp && _balances[msg.sender].add(amount) <= maxLp, "wrong amount");\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[msg.sender] = _balances[msg.sender].add(amount);\n', '        stakingToken.transferFrom(msg.sender, address(this), amount);\n', '        emit Staked(msg.sender, amount);\n', '    }\n', '\n', '    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\n', '        require(amount > 0, "Cannot withdraw 0");\n', '        require(_balances[msg.sender].sub(amount) >= minLp || _balances[msg.sender].sub(amount) == 0, "wrong amount");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n', '        uint256 fee = amount.div(feeRate);\n', '        stakingToken.transfer(0x1111111111111111111111111111111111111111, fee);\n', '        stakingToken.transfer(msg.sender, amount.sub(fee));\n', '        emit Withdrawn(msg.sender, amount);\n', '    }\n', '\n', '    function exit() external {\n', '        withdraw(_balances[msg.sender]);\n', '    }\n', '    \n', '    function getPriceHero(uint256 rarity) public view returns (uint) {\n', '        (,uint reserves2) = UniswapV2Library.getReserves(address(factory), NDR, uniswap.WETH());\n', '        uint price = reserves2 * 1e18 / IUniswapV2Pair(address(stakingToken)).totalSupply() * 2;\n', '        return price * rarity * mulHero1 / mulHero2;\n', '    }\n', '    \n', '    function getPriceSupport(uint256 rarity) public view returns (uint) {\n', '        (,uint reserves2) = UniswapV2Library.getReserves(address(factory), NDR, uniswap.WETH());\n', '        uint price = reserves2 * 1e18 / IUniswapV2Pair(address(stakingToken)).totalSupply() * 2;\n', '        return price * rarity * mulSupport1 / mulSupport2;\n', '    }\n', '\n', '    function redeem(uint256 tokenId) public nonReentrant whenNotPaused updateReward(msg.sender) {\n', '        (,,,,uint256 hashPrice,) = INodeRunnersNFT(address(NFT)).getFighter(tokenId);\n', '        require(hashPrice > 0, "can\'t buy in hash");\n', '        uint256 reward = rewards[msg.sender];\n', '        require(reward >= hashPrice, "not enough hash");\n', '        rewards[msg.sender] = rewards[msg.sender].sub(hashPrice);\n', '        INodeRunnersNFT(NFT).mint(msg.sender, tokenId, 1);\n', '        emit RewardPaid(msg.sender, reward);\n', '    }\n', '\n', '    function buy(uint256 tokenId) public nonReentrant whenNotPaused payable {\n', '        (,,,uint256 rarity,,uint256 series) = INodeRunnersNFT(address(NFT)).getFighter(tokenId);\n', '        uint256 price;\n', '        if (series == 1) {\n', '            price = getPriceHero(rarity);\n', '        } else if (series == 2) {\n', '            price = getPriceSupport(rarity);\n', '        } else {\n', '            revert("wrong id");\n', '        }\n', '        require(msg.value >= price, "wrong value");\n', '        uint fee = msg.value / interest;\n', '        treasury.transfer(fee);\n', '        uint amountEth = (msg.value - fee) / 2;\n', '        uint amountToken = getAmountsOut(amountEth, address(NDR));\n', '        swapExactETHForTokens(amountEth);\n', '        addLiquidityETH(amountToken, amountEth * 99 / 100);\n', '        INodeRunnersNFT(NFT).mint(msg.sender, tokenId, 1);\n', '    }\n', '\n', '    /* ========== RESTRICTED FUNCTIONS ========== */\n', '\n', '    function notifyRewardAmount(uint256 reward) external onlyOwner updateReward(address(0)) {\n', '        if (block.timestamp >= periodFinish) {\n', '            rewardRate = reward.div(rewardsDuration);\n', '        } else {\n', '            uint256 remaining = periodFinish.sub(block.timestamp);\n', '            uint256 leftover = remaining.mul(rewardRate);\n', '            rewardRate = reward.add(leftover).div(rewardsDuration);\n', '        }\n', '        uint256 balance = rewardsToken.balanceOf(address(this));\n', '        require(\n', '            rewardRate <= balance.div(rewardsDuration),\n', '            "Provided reward too high"\n', '        );\n', '        lastUpdateTime = block.timestamp;\n', '        periodFinish = block.timestamp.add(rewardsDuration);\n', '        emit RewardAdded(reward);\n', '    }\n', '\n', '    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n', '        // Cannot recover the staking token or the rewards token\n', '        require(\n', '            tokenAddress != address(stakingToken) &&\n', '                tokenAddress != address(rewardsToken),\n', '            "Cannot withdraw the staking or rewards tokens"\n', '        );\n', '        IERC20(tokenAddress).transfer(this.owner(), tokenAmount);\n', '        emit Recovered(tokenAddress, tokenAmount);\n', '    }\n', '\n', '    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n', '        require(\n', '            block.timestamp > periodFinish,\n', '            "Previous rewards period must be complete before changing the duration for the new period"\n', '        );\n', '        rewardsDuration = _rewardsDuration;\n', '        emit RewardsDurationUpdated(rewardsDuration);\n', '    }\n', '\n', '    /* ========== MODIFIERS ========== */\n', '\n', '    modifier updateReward(address account) {\n', '        rewardPerTokenStored = rewardPerToken();\n', '        lastUpdateTime = lastTimeRewardApplicable();\n', '        if (account != address(0)) {\n', '            rewards[account] = earned(account);\n', '            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n', '        }\n', '        _;\n', '    }\n', '\n', '    /* ========== EVENTS ========== */\n', '\n', '    event RewardAdded(uint256 reward);\n', '    event Staked(address indexed user, uint256 amount);\n', '    event Withdrawn(address indexed user, uint256 amount);\n', '    event RewardPaid(address indexed user, uint256 reward);\n', '    event RewardsDurationUpdated(uint256 newDuration);\n', '    event Recovered(address token, uint256 amount);\n', '}']