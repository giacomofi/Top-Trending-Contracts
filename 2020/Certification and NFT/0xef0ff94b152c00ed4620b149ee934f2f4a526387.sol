['pragma solidity 0.5.17;\n', 'contract GAMMA { // Γ - mv - NFT - mkt - γ\n', '    address payable public dao = 0x057e820D740D5AAaFfa3c6De08C5c98d990dB00d;\n', '    uint256 public constant GAMMA_MAX = 5772156649015328606065120900824024310421;\n', '    uint256 public totalSupply;\n', '    string public name = "GAMMA";\n', '    string public symbol = "GAMMA";\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(uint256 => address) public getApproved;\n', '    mapping(uint256 => address) public ownerOf;\n', '    mapping(uint256 => uint256) public tokenByIndex;\n', '    mapping(uint256 => string) public tokenURI;\n', '    mapping(uint256 => Sale) public sale;\n', '    mapping(bytes4 => bool) public supportsInterface; // eip-165 \n', '    mapping(address => mapping(address => bool)) public isApprovedForAll;\n', '    mapping(address => mapping(uint256 => uint256)) public tokenOfOwnerByIndex;\n', '    event Approval(address indexed approver, address indexed spender, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event UpdateSale(uint256 indexed ethPrice, uint256 indexed tokenId, bool forSale);\n', '    struct Sale {\n', '        uint256 ethPrice;\n', '        bool forSale;\n', '    }\n', '    constructor () public {\n', '        supportsInterface[0x80ac58cd] = true; // ERC721 \n', '        supportsInterface[0x5b5e139f] = true; // METADATA\n', '        supportsInterface[0x780e9d63] = true; // ENUMERABLE\n', '    }\n', '    function approve(address spender, uint256 tokenId) external {\n', '        require(msg.sender == ownerOf[tokenId] || isApprovedForAll[ownerOf[tokenId]][msg.sender], "!owner/operator");\n', '        getApproved[tokenId] = spender;\n', '        emit Approval(msg.sender, spender, tokenId); \n', '    }\n', '    function mint(uint256 ethPrice, string calldata _tokenURI, bool forSale) external { \n', '        totalSupply++;\n', '        require(totalSupply <= GAMMA_MAX, "maxed");\n', '        uint256 tokenId = totalSupply;\n', '        balanceOf[msg.sender]++;\n', '        ownerOf[tokenId] = msg.sender;\n', '        tokenByIndex[tokenId - 1] = tokenId;\n', '        tokenURI[tokenId] = _tokenURI;\n', '        sale[tokenId].ethPrice = ethPrice;\n', '        sale[tokenId].forSale = forSale;\n', '        tokenOfOwnerByIndex[msg.sender][tokenId - 1] = tokenId;\n', '        emit Transfer(address(0), msg.sender, tokenId); \n', '        emit UpdateSale(ethPrice, tokenId, forSale);\n', '    }\n', '    function purchase(uint256 tokenId) payable external {\n', '        require(msg.value == sale[tokenId].ethPrice, "!ethPrice");\n', '        require(sale[tokenId].forSale, "!forSale");\n', '        address owner = ownerOf[tokenId];\n', '        (bool success, ) = owner.call.value(msg.value)("");\n', '        require(success, "!transfer");\n', '        _transfer(owner, msg.sender, tokenId);\n', '    }\n', '    function setApprovalForAll(address operator, bool approved) external {\n', '        isApprovedForAll[msg.sender][operator] = approved;\n', '        emit ApprovalForAll(msg.sender, operator, approved);\n', '    }\n', '    function _transfer(address from, address to, uint256 tokenId) internal {\n', '        balanceOf[from]--; \n', '        balanceOf[to]++; \n', '        getApproved[tokenId] = address(0);\n', '        ownerOf[tokenId] = to;\n', '        sale[tokenId].forSale = false;\n', '        tokenOfOwnerByIndex[from][tokenId - 1] = 0;\n', '        tokenOfOwnerByIndex[to][tokenId - 1] = tokenId;\n', '        emit Transfer(from, to, tokenId); \n', '    }\n', '    function transfer(address to, uint256 tokenId) external {\n', '        require(msg.sender == ownerOf[tokenId], "!owner");\n', '        _transfer(msg.sender, to, tokenId);\n', '    }\n', '    function transferBatch(address[] calldata to, uint256[] calldata tokenId) external {\n', '        require(to.length == tokenId.length, "!to/tokenId");\n', '        for (uint256 i = 0; i < to.length; i++) {\n', '            require(msg.sender == ownerOf[tokenId[i]], "!owner");\n', '            _transfer(msg.sender, to[i], tokenId[i]);\n', '        }\n', '    }\n', '    function transferFrom(address from, address to, uint256 tokenId) external {\n', '        require(msg.sender == ownerOf[tokenId] || getApproved[tokenId] == msg.sender || isApprovedForAll[ownerOf[tokenId]][msg.sender], "!owner/spender/operator");\n', '        _transfer(from, to, tokenId);\n', '    }\n', '    function updateDao(address payable _dao) external {\n', '        require(msg.sender == dao, "!dao");\n', '        dao = _dao;\n', '    }\n', '    function updateSale(uint256 ethPrice, uint256 tokenId, bool forSale) payable external {\n', '        require(msg.sender == ownerOf[tokenId], "!owner");\n', '        sale[tokenId].ethPrice = ethPrice;\n', '        sale[tokenId].forSale = forSale;\n', '        (bool success, ) = dao.call.value(msg.value)("");\n', '        require(success, "!transfer");\n', '        emit UpdateSale(ethPrice, tokenId, forSale);\n', '    }\n', '}']