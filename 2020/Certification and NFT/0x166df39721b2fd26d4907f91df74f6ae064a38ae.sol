['// SPDX-License-Identifier: Apache-2.0\n', '// Copyright 2017 Loopring Technology Limited.\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/// @title Ownable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable\n', '{\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      new owner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership()\n', '        public\n', '        onlyOwner\n', '    {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '/// @title AddressSet\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract AddressSet\n', '{\n', '    struct Set\n', '    {\n', '        address[] addresses;\n', '        mapping (address => uint) positions;\n', '        uint count;\n', '    }\n', '    mapping (bytes32 => Set) private sets;\n', '\n', '    function addAddressToSet(\n', '        bytes32 key,\n', '        address addr,\n', '        bool    maintainList\n', '        ) internal\n', '    {\n', '        Set storage set = sets[key];\n', '        require(set.positions[addr] == 0, "ALREADY_IN_SET");\n', '\n', '        if (maintainList) {\n', '            require(set.addresses.length == set.count, "PREVIOUSLY_NOT_MAINTAILED");\n', '            set.addresses.push(addr);\n', '        } else {\n', '            require(set.addresses.length == 0, "MUST_MAINTAIN");\n', '        }\n', '\n', '        set.count += 1;\n', '        set.positions[addr] = set.count;\n', '    }\n', '\n', '    function removeAddressFromSet(\n', '        bytes32 key,\n', '        address addr\n', '        )\n', '        internal\n', '    {\n', '        Set storage set = sets[key];\n', '        uint pos = set.positions[addr];\n', '        require(pos != 0, "NOT_IN_SET");\n', '\n', '        delete set.positions[addr];\n', '        set.count -= 1;\n', '\n', '        if (set.addresses.length > 0) {\n', '            address lastAddr = set.addresses[set.count];\n', '            if (lastAddr != addr) {\n', '                set.addresses[pos - 1] = lastAddr;\n', '                set.positions[lastAddr] = pos;\n', '            }\n', '            set.addresses.pop();\n', '        }\n', '    }\n', '\n', '    function removeSet(bytes32 key)\n', '        internal\n', '    {\n', '        delete sets[key];\n', '    }\n', '\n', '    function isAddressInSet(\n', '        bytes32 key,\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return sets[key].positions[addr] != 0;\n', '    }\n', '\n', '    function numAddressesInSet(bytes32 key)\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        Set storage set = sets[key];\n', '        return set.count;\n', '    }\n', '\n', '    function addressesInSet(bytes32 key)\n', '        internal\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        Set storage set = sets[key];\n', '        require(set.count == set.addresses.length, "NOT_MAINTAINED");\n', '        return sets[key].addresses;\n', '    }\n', '}\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '/// @title Claimable\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable\n', '{\n', '    address public pendingOwner;\n', '\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0) && newOwner != owner, "INVALID_ADDRESS");\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        public\n', '        onlyPendingOwner\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', 'contract OwnerManagable is Claimable, AddressSet\n', '{\n', '    bytes32 internal constant MANAGER = keccak256("__MANAGED__");\n', '\n', '    event ManagerAdded  (address manager);\n', '    event ManagerRemoved(address manager);\n', '\n', '    modifier onlyManager\n', '    {\n', '        require(isManager(msg.sender), "NOT_MANAGER");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrManager\n', '    {\n', '        require(msg.sender == owner || isManager(msg.sender), "NOT_OWNER_OR_MANAGER");\n', '        _;\n', '    }\n', '\n', '    constructor() Claimable() {}\n', '\n', '    /// @dev Gets the managers.\n', '    /// @return The list of managers.\n', '    function managers()\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        return addressesInSet(MANAGER);\n', '    }\n', '\n', '    /// @dev Gets the number of managers.\n', '    /// @return The numer of managers.\n', '    function numManagers()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return numAddressesInSet(MANAGER);\n', '    }\n', '\n', '    /// @dev Checks if an address is a manger.\n', '    /// @param addr The address to check.\n', '    /// @return True if the address is a manager, False otherwise.\n', '    function isManager(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return isAddressInSet(MANAGER, addr);\n', '    }\n', '\n', '    /// @dev Adds a new manager.\n', '    /// @param manager The new address to add.\n', '    function addManager(address manager)\n', '        public\n', '        onlyOwner\n', '    {\n', '        addManagerInternal(manager);\n', '    }\n', '\n', '    /// @dev Removes a manager.\n', '    /// @param manager The manager to remove.\n', '    function removeManager(address manager)\n', '        public\n', '        onlyOwner\n', '    {\n', '        removeAddressFromSet(MANAGER, manager);\n', '        emit ManagerRemoved(manager);\n', '    }\n', '\n', '    function addManagerInternal(address manager)\n', '        internal\n', '    {\n', '        addAddressToSet(MANAGER, manager, true);\n', '        emit ManagerAdded(manager);\n', '    }\n', '}\n', '\n', '\n', '/// @title DataStore\n', '/// @dev Modules share states by accessing the same storage instance.\n', '///      Using ModuleStorage will achieve better module decoupling.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'abstract contract DataStore\n', '{\n', '    modifier onlyWalletModule(address wallet)\n', '    {\n', '        require(Wallet(wallet).hasModule(msg.sender), "UNAUTHORIZED");\n', '        _;\n', '    }\n', '}\n', '// Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeCast.sol\n', '\n', '\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n", ' * checks.\n', ' *\n', ' * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n', ' * easily result in undesired exploitation or bugs, since developers usually\n', ' * assume that overflows raise errors. `SafeCast` restores this intuition by\n', ' * reverting the transaction when such an operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' *\n', ' * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n', ' * all math on `uint256` and `int256` and then downcasting.\n', ' */\n', 'library SafeCast {\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint128 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint128).\n', '     *\n', "     * Counterpart to Solidity's `uint128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     */\n', '    function toUint128(uint256 value) internal pure returns (uint128) {\n', '        require(value < 2**128, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return uint128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint64 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint64).\n', '     *\n', "     * Counterpart to Solidity's `uint64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     */\n', '    function toUint64(uint256 value) internal pure returns (uint64) {\n', '        require(value < 2**64, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return uint64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint32 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint32).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     */\n', '    function toUint32(uint256 value) internal pure returns (uint32) {\n', '        require(value < 2**32, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return uint32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint40 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint40).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 40 bits\n', '     */\n', '    function toUint40(uint256 value) internal pure returns (uint40) {\n', '        require(value < 2**40, "SafeCast: value doesn\\\'t fit in 40 bits");\n', '        return uint40(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint16 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint16).\n', '     *\n', "     * Counterpart to Solidity's `uint16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     */\n', '    function toUint16(uint256 value) internal pure returns (uint16) {\n', '        require(value < 2**16, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return uint16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint8 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint8).\n', '     *\n', "     * Counterpart to Solidity's `uint8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     */\n', '    function toUint8(uint256 value) internal pure returns (uint8) {\n', '        require(value < 2**8, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return uint8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a signed int256 into an unsigned uint256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be greater than or equal to 0.\n', '     */\n', '    function toUint256(int256 value) internal pure returns (uint256) {\n', '        require(value >= 0, "SafeCast: value must be positive");\n', '        return uint256(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int128 from int256, reverting on\n', '     * overflow (when the input is less than smallest int128 or\n', '     * greater than largest int128).\n', '     *\n', "     * Counterpart to Solidity's `int128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt128(int256 value) internal pure returns (int128) {\n', '        require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return int128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int64 from int256, reverting on\n', '     * overflow (when the input is less than smallest int64 or\n', '     * greater than largest int64).\n', '     *\n', "     * Counterpart to Solidity's `int64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt64(int256 value) internal pure returns (int64) {\n', '        require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return int64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int32 from int256, reverting on\n', '     * overflow (when the input is less than smallest int32 or\n', '     * greater than largest int32).\n', '     *\n', "     * Counterpart to Solidity's `int32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt32(int256 value) internal pure returns (int32) {\n', '        require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return int32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int16 from int256, reverting on\n', '     * overflow (when the input is less than smallest int16 or\n', '     * greater than largest int16).\n', '     *\n', "     * Counterpart to Solidity's `int16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt16(int256 value) internal pure returns (int16) {\n', '        require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return int16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int8 from int256, reverting on\n', '     * overflow (when the input is less than smallest int8 or\n', '     * greater than largest int8).\n', '     *\n', "     * Counterpart to Solidity's `int8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt8(int256 value) internal pure returns (int8) {\n', '        require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return int8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an unsigned uint256 into a signed int256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be less than or equal to maxInt256.\n', '     */\n', '    function toInt256(uint256 value) internal pure returns (int256) {\n', '        require(value < 2**255, "SafeCast: value doesn\'t fit in an int256");\n', '        return int256(value);\n', '    }\n', '}\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', 'library Data\n', '{\n', '    // Optimized to fit into 32 bytes (1 slot)\n', '    struct Guardian\n', '    {\n', '        address addr;\n', '        uint16  group;\n', '        uint40  validSince;\n', '        uint40  validUntil;\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library MathUint\n', '{\n', '    function mul(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b, "MUL_OVERFLOW");\n', '    }\n', '\n', '    function sub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        require(b <= a, "SUB_UNDERFLOW");\n', '        return a - b;\n', '    }\n', '\n', '    function add(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title WalletRegistry\n', '/// @dev A registry for wallets.\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'interface WalletRegistry\n', '{\n', '    function registerWallet(address wallet) external;\n', '    function isWalletRegistered(address addr) external view returns (bool);\n', '    function numOfWallets() external view returns (uint);\n', '}\n', '\n', '/*\n', ' * @title String & slice utility library for Solidity contracts.\n', ' * @author Nick Johnson <arachnid@notdot.net>\n', ' *\n', ' * @dev Functionality in this library is largely implemented using an\n', " *      abstraction called a 'slice'. A slice represents a part of a string -\n", ' *      anything from the entire string to a single character, or even no\n', ' *      characters at all (a 0-length slice). Since a slice only has to specify\n', ' *      an offset and a length, copying and manipulating slices is a lot less\n', ' *      expensive than copying and manipulating the strings they reference.\n', ' *\n', ' *      To further reduce gas costs, most functions on slice that need to return\n', ' *      a slice modify the original one instead of allocating a new one; for\n', ' *      instance, `s.split(".")` will return the text up to the first \'.\',\n', " *      modifying s to only contain the remainder of the string after the '.'.\n", ' *      In situations where you do not want to modify the original slice, you\n', ' *      can make a copy first with `.copy()`, for example:\n', ' *      `s.copy().split(".")`. Try and avoid using this idiom in loops; since\n', ' *      Solidity has no memory management, it will result in allocating many\n', ' *      short-lived slices that are later discarded.\n', ' *\n', ' *      Functions that return two slices come in two versions: a non-allocating\n', ' *      version that takes the second slice as an argument, modifying it in\n', ' *      place, and an allocating version that allocates and returns the second\n', ' *      slice; see `nextRune` for example.\n', ' *\n', ' *      Functions that have to copy string data will return strings rather than\n', ' *      slices; these can be cast back to slices for further processing if\n', ' *      required.\n', ' *\n', ' *      For convenience, some functions are provided with non-modifying\n', ' *      variants that create a new slice and return both; for instance,\n', " *      `s.splitNew('.')` leaves s unmodified, and returns two values\n", ' *      corresponding to the left and right parts of the string.\n', ' */\n', '\n', '\n', '\n', '/* solium-disable */\n', 'library strings {\n', '    struct slice {\n', '        uint _len;\n', '        uint _ptr;\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure {\n', '        // Copy word-length chunks while possible\n', '        for(; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire string.\n', '     * @param self The string to make a slice from.\n', '     * @return A newly allocated slice containing the entire string.\n', '     */\n', '    function toSlice(string memory self) internal pure returns (slice memory) {\n', '        uint ptr;\n', '        assembly {\n', '            ptr := add(self, 0x20)\n', '        }\n', '        return slice(bytes(self).length, ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the length of a null-terminated bytes32 string.\n', '     * @param self The value to find the length of.\n', '     * @return The length of the string, from 0 to 32.\n', '     */\n', '    function len(bytes32 self) internal pure returns (uint) {\n', '        uint ret;\n', '        if (self == 0)\n', '            return 0;\n', '        if (uint256(self) & 0xffffffffffffffffffffffffffffffff == 0) {\n', '            ret += 16;\n', '            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n', '        }\n', '        if (uint256(self) & 0xffffffffffffffff == 0) {\n', '            ret += 8;\n', '            self = bytes32(uint(self) / 0x10000000000000000);\n', '        }\n', '        if (uint256(self) & 0xffffffff == 0) {\n', '            ret += 4;\n', '            self = bytes32(uint(self) / 0x100000000);\n', '        }\n', '        if (uint256(self) & 0xffff == 0) {\n', '            ret += 2;\n', '            self = bytes32(uint(self) / 0x10000);\n', '        }\n', '        if (uint256(self) & 0xff == 0) {\n', '            ret += 1;\n', '        }\n', '        return 32 - ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire bytes32, interpreted as a\n', '     *      null-terminated utf-8 string.\n', '     * @param self The bytes32 value to convert to a slice.\n', '     * @return A new slice containing the value of the input argument up to the\n', '     *         first null.\n', '     */\n', '    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n', '        // Allocate space for `self` in memory, copy it there, and point ret at it\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(0x40, add(ptr, 0x20))\n', '            mstore(ptr, self)\n', '            mstore(add(ret, 0x20), ptr)\n', '        }\n', '        ret._len = len(self);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a new slice containing the same data as the current slice.\n', '     * @param self The slice to copy.\n', '     * @return A new slice containing the same data as `self`.\n', '     */\n', '    function copy(slice memory self) internal pure returns (slice memory) {\n', '        return slice(self._len, self._ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Copies a slice to a new string.\n', '     * @param self The slice to copy.\n', "     * @return A newly allocated string containing the slice's text.\n", '     */\n', '    function toString(slice memory self) internal pure returns (string memory) {\n', '        string memory ret = new string(self._len);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '\n', '        memcpy(retptr, self._ptr, self._len);\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the length in runes of the slice. Note that this operation\n', '     *      takes time proportional to the length of the slice; avoid using it\n', '     *      in loops, and call `slice.empty()` if you only need to kblock.timestamp whether\n', '     *      the slice is empty or not.\n', '     * @param self The slice to operate on.\n', '     * @return The length of the slice in runes.\n', '     */\n', '    function len(slice memory self) internal pure returns (uint l) {\n', '        // Starting at ptr-31 means the LSB will be the byte we care about\n', '        uint ptr = self._ptr - 31;\n', '        uint end = ptr + self._len;\n', '        for (l = 0; ptr < end; l++) {\n', '            uint8 b;\n', '            assembly { b := and(mload(ptr), 0xFF) }\n', '            if (b < 0x80) {\n', '                ptr += 1;\n', '            } else if(b < 0xE0) {\n', '                ptr += 2;\n', '            } else if(b < 0xF0) {\n', '                ptr += 3;\n', '            } else if(b < 0xF8) {\n', '                ptr += 4;\n', '            } else if(b < 0xFC) {\n', '                ptr += 5;\n', '            } else {\n', '                ptr += 6;\n', '            }\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the slice is empty (has a length of 0).\n', '     * @param self The slice to operate on.\n', '     * @return True if the slice is empty, False otherwise.\n', '     */\n', '    function empty(slice memory self) internal pure returns (bool) {\n', '        return self._len == 0;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a positive number if `other` comes lexicographically after\n', '     *      `self`, a negative number if it comes before, or zero if the\n', '     *      contents of the two slices are equal. Comparison is done per-rune,\n', '     *      on unicode codepoints.\n', '     * @param self The first slice to compare.\n', '     * @param other The second slice to compare.\n', '     * @return The result of the comparison.\n', '     */\n', '    function compare(slice memory self, slice memory other) internal pure returns (int) {\n', '        uint shortest = self._len;\n', '        if (other._len < self._len)\n', '            shortest = other._len;\n', '\n', '        uint selfptr = self._ptr;\n', '        uint otherptr = other._ptr;\n', '        for (uint idx = 0; idx < shortest; idx += 32) {\n', '            uint a;\n', '            uint b;\n', '            assembly {\n', '                a := mload(selfptr)\n', '                b := mload(otherptr)\n', '            }\n', '            if (a != b) {\n', '                // Mask out irrelevant bytes and check again\n', '                uint256 mask = uint256(-1); // 0xffff...\n', '                if(shortest < 32) {\n', '                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n', '                }\n', '                uint256 diff = (a & mask) - (b & mask);\n', '                if (diff != 0)\n', '                    return int(diff);\n', '            }\n', '            selfptr += 32;\n', '            otherptr += 32;\n', '        }\n', '        return int(self._len) - int(other._len);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the two slices contain the same text.\n', '     * @param self The first slice to compare.\n', '     * @param self The second slice to compare.\n', '     * @return True if the slices are equal, false otherwise.\n', '     */\n', '    function equals(slice memory self, slice memory other) internal pure returns (bool) {\n', '        return compare(self, other) == 0;\n', '    }\n', '\n', '    /*\n', '     * @dev Extracts the first rune in the slice into `rune`, advancing the\n', '     *      slice to point to the next rune and returning `self`.\n', '     * @param self The slice to operate on.\n', '     * @param rune The slice that will contain the first rune.\n', '     * @return `rune`.\n', '     */\n', '    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\n', '        rune._ptr = self._ptr;\n', '\n', '        if (self._len == 0) {\n', '            rune._len = 0;\n', '            return rune;\n', '        }\n', '\n', '        uint l;\n', '        uint b;\n', '        // Load the first byte of the rune into the LSBs of b\n', '        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n', '        if (b < 0x80) {\n', '            l = 1;\n', '        } else if(b < 0xE0) {\n', '            l = 2;\n', '        } else if(b < 0xF0) {\n', '            l = 3;\n', '        } else {\n', '            l = 4;\n', '        }\n', '\n', '        // Check for truncated codepoints\n', '        if (l > self._len) {\n', '            rune._len = self._len;\n', '            self._ptr += self._len;\n', '            self._len = 0;\n', '            return rune;\n', '        }\n', '\n', '        self._ptr += l;\n', '        self._len -= l;\n', '        rune._len = l;\n', '        return rune;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the first rune in the slice, advancing the slice to point\n', '     *      to the next rune.\n', '     * @param self The slice to operate on.\n', '     * @return A slice containing only the first rune from `self`.\n', '     */\n', '    function nextRune(slice memory self) internal pure returns (slice memory ret) {\n', '        nextRune(self, ret);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the number of the first codepoint in the slice.\n', '     * @param self The slice to operate on.\n', '     * @return The number of the first codepoint in the slice.\n', '     */\n', '    function ord(slice memory self) internal pure returns (uint ret) {\n', '        if (self._len == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint word;\n', '        uint length;\n', '        uint divisor = 2 ** 248;\n', '\n', '        // Load the rune into the MSBs of b\n', '        assembly { word:= mload(mload(add(self, 32))) }\n', '        uint b = word / divisor;\n', '        if (b < 0x80) {\n', '            ret = b;\n', '            length = 1;\n', '        } else if(b < 0xE0) {\n', '            ret = b & 0x1F;\n', '            length = 2;\n', '        } else if(b < 0xF0) {\n', '            ret = b & 0x0F;\n', '            length = 3;\n', '        } else {\n', '            ret = b & 0x07;\n', '            length = 4;\n', '        }\n', '\n', '        // Check for truncated codepoints\n', '        if (length > self._len) {\n', '            return 0;\n', '        }\n', '\n', '        for (uint i = 1; i < length; i++) {\n', '            divisor = divisor / 256;\n', '            b = (word / divisor) & 0xFF;\n', '            if (b & 0xC0 != 0x80) {\n', '                // Invalid UTF-8 sequence\n', '                return 0;\n', '            }\n', '            ret = (ret * 64) | (b & 0x3F);\n', '        }\n', '\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns the keccak-256 hash of the slice.\n', '     * @param self The slice to hash.\n', '     * @return The hash of the slice.\n', '     */\n', '    function keccak(slice memory self) internal pure returns (bytes32 ret) {\n', '        assembly {\n', '            ret := keccak256(mload(add(self, 32)), mload(self))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if `self` starts with `needle`.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return True if the slice starts with the provided text, false otherwise.\n', '     */\n', '    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n', '        if (self._len < needle._len) {\n', '            return false;\n', '        }\n', '\n', '        if (self._ptr == needle._ptr) {\n', '            return true;\n', '        }\n', '\n', '        bool equal;\n', '        assembly {\n', '            let length := mload(needle)\n', '            let selfptr := mload(add(self, 0x20))\n', '            let needleptr := mload(add(needle, 0x20))\n', '            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '        }\n', '        return equal;\n', '    }\n', '\n', '    /*\n', '     * @dev If `self` starts with `needle`, `needle` is removed from the\n', '     *      beginning of `self`. Otherwise, `self` is unmodified.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return `self`\n', '     */\n', '    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\n', '        if (self._len < needle._len) {\n', '            return self;\n', '        }\n', '\n', '        bool equal = true;\n', '        if (self._ptr != needle._ptr) {\n', '            assembly {\n', '                let length := mload(needle)\n', '                let selfptr := mload(add(self, 0x20))\n', '                let needleptr := mload(add(needle, 0x20))\n', '                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '            }\n', '        }\n', '\n', '        if (equal) {\n', '            self._len -= needle._len;\n', '            self._ptr += needle._len;\n', '        }\n', '\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns true if the slice ends with `needle`.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return True if the slice starts with the provided text, false otherwise.\n', '     */\n', '    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\n', '        if (self._len < needle._len) {\n', '            return false;\n', '        }\n', '\n', '        uint selfptr = self._ptr + self._len - needle._len;\n', '\n', '        if (selfptr == needle._ptr) {\n', '            return true;\n', '        }\n', '\n', '        bool equal;\n', '        assembly {\n', '            let length := mload(needle)\n', '            let needleptr := mload(add(needle, 0x20))\n', '            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '        }\n', '\n', '        return equal;\n', '    }\n', '\n', '    /*\n', '     * @dev If `self` ends with `needle`, `needle` is removed from the\n', '     *      end of `self`. Otherwise, `self` is unmodified.\n', '     * @param self The slice to operate on.\n', '     * @param needle The slice to search for.\n', '     * @return `self`\n', '     */\n', '    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\n', '        if (self._len < needle._len) {\n', '            return self;\n', '        }\n', '\n', '        uint selfptr = self._ptr + self._len - needle._len;\n', '        bool equal = true;\n', '        if (selfptr != needle._ptr) {\n', '            assembly {\n', '                let length := mload(needle)\n', '                let needleptr := mload(add(needle, 0x20))\n', '                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n', '            }\n', '        }\n', '\n', '        if (equal) {\n', '            self._len -= needle._len;\n', '        }\n', '\n', '        return self;\n', '    }\n', '\n', '    // Returns the memory address of the first byte of the first occurrence of\n', '    // `needle` in `self`, or the first byte after `self` if not found.\n', '    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n', '        uint ptr = selfptr;\n', '        uint idx;\n', '\n', '        if (needlelen <= selflen) {\n', '            if (needlelen <= 32) {\n', '                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n', '\n', '                bytes32 needledata;\n', '                assembly { needledata := and(mload(needleptr), mask) }\n', '\n', '                uint end = selfptr + selflen - needlelen;\n', '                bytes32 ptrdata;\n', '                assembly { ptrdata := and(mload(ptr), mask) }\n', '\n', '                while (ptrdata != needledata) {\n', '                    if (ptr >= end)\n', '                        return selfptr + selflen;\n', '                    ptr++;\n', '                    assembly { ptrdata := and(mload(ptr), mask) }\n', '                }\n', '                return ptr;\n', '            } else {\n', '                // For long needles, use hashing\n', '                bytes32 hash;\n', '                assembly { hash := keccak256(needleptr, needlelen) }\n', '\n', '                for (idx = 0; idx <= selflen - needlelen; idx++) {\n', '                    bytes32 testHash;\n', '                    assembly { testHash := keccak256(ptr, needlelen) }\n', '                    if (hash == testHash)\n', '                        return ptr;\n', '                    ptr += 1;\n', '                }\n', '            }\n', '        }\n', '        return selfptr + selflen;\n', '    }\n', '\n', '    // Returns the memory address of the first byte after the last occurrence of\n', '    // `needle` in `self`, or the address of `self` if not found.\n', '    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n', '        uint ptr;\n', '\n', '        if (needlelen <= selflen) {\n', '            if (needlelen <= 32) {\n', '                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n', '\n', '                bytes32 needledata;\n', '                assembly { needledata := and(mload(needleptr), mask) }\n', '\n', '                ptr = selfptr + selflen - needlelen;\n', '                bytes32 ptrdata;\n', '                assembly { ptrdata := and(mload(ptr), mask) }\n', '\n', '                while (ptrdata != needledata) {\n', '                    if (ptr <= selfptr)\n', '                        return selfptr;\n', '                    ptr--;\n', '                    assembly { ptrdata := and(mload(ptr), mask) }\n', '                }\n', '                return ptr + needlelen;\n', '            } else {\n', '                // For long needles, use hashing\n', '                bytes32 hash;\n', '                assembly { hash := keccak256(needleptr, needlelen) }\n', '                ptr = selfptr + (selflen - needlelen);\n', '                while (ptr >= selfptr) {\n', '                    bytes32 testHash;\n', '                    assembly { testHash := keccak256(ptr, needlelen) }\n', '                    if (hash == testHash)\n', '                        return ptr + needlelen;\n', '                    ptr -= 1;\n', '                }\n', '            }\n', '        }\n', '        return selfptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Modifies `self` to contain everything from the first occurrence of\n', '     *      `needle` to the end of the slice. `self` is set to the empty slice\n', '     *      if `needle` is not found.\n', '     * @param self The slice to search and modify.\n', '     * @param needle The text to search for.\n', '     * @return `self`.\n', '     */\n', '    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        self._len -= ptr - self._ptr;\n', '        self._ptr = ptr;\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Modifies `self` to contain the part of the string from the start of\n', '     *      `self` to the end of the first occurrence of `needle`. If `needle`\n', '     *      is not found, `self` is set to the empty slice.\n', '     * @param self The slice to search and modify.\n', '     * @param needle The text to search for.\n', '     * @return `self`.\n', '     */\n', '    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\n', '        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        self._len = ptr - self._ptr;\n', '        return self;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything after the first\n', '     *      occurrence of `needle`, and `token` to everything before it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and `token` is set to the entirety of `self`.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @param token An output parameter to which the first token is written.\n', '     * @return `token`.\n', '     */\n', '    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        token._ptr = self._ptr;\n', '        token._len = ptr - self._ptr;\n', '        if (ptr == self._ptr + self._len) {\n', '            // Not found\n', '            self._len = 0;\n', '        } else {\n', '            self._len -= token._len + needle._len;\n', '            self._ptr = ptr + needle._len;\n', '        }\n', '        return token;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything after the first\n', '     *      occurrence of `needle`, and returning everything before it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and the entirety of `self` is returned.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The part of `self` up to the first occurrence of `delim`.\n', '     */\n', '    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n', '        split(self, needle, token);\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything before the last\n', '     *      occurrence of `needle`, and `token` to everything after it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and `token` is set to the entirety of `self`.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @param token An output parameter to which the first token is written.\n', '     * @return `token`.\n', '     */\n', '    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\n', '        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n', '        token._ptr = ptr;\n', '        token._len = self._len - (ptr - self._ptr);\n', '        if (ptr == self._ptr) {\n', '            // Not found\n', '            self._len = 0;\n', '        } else {\n', '            self._len -= token._len + needle._len;\n', '        }\n', '        return token;\n', '    }\n', '\n', '    /*\n', '     * @dev Splits the slice, setting `self` to everything before the last\n', '     *      occurrence of `needle`, and returning everything after it. If\n', '     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n', '     *      and the entirety of `self` is returned.\n', '     * @param self The slice to split.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The part of `self` after the last occurrence of `delim`.\n', '     */\n', '    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\n', '        rsplit(self, needle, token);\n', '    }\n', '\n', '    /*\n', '     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n', '     * @param self The slice to search.\n', '     * @param needle The text to search for in `self`.\n', '     * @return The number of occurrences of `needle` found in `self`.\n', '     */\n', '    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\n', '        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n', '        while (ptr <= self._ptr + self._len) {\n', '            cnt++;\n', '            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns True if `self` contains `needle`.\n', '     * @param self The slice to search.\n', '     * @param needle The text to search for in `self`.\n', '     * @return True if `needle` is found in `self`, false otherwise.\n', '     */\n', '    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\n', '        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a newly allocated string containing the concatenation of\n', '     *      `self` and `other`.\n', '     * @param self The first slice to concatenate.\n', '     * @param other The second slice to concatenate.\n', '     * @return The concatenation of the two strings.\n', '     */\n', '    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n', '        string memory ret = new string(self._len + other._len);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '        memcpy(retptr, self._ptr, self._len);\n', '        memcpy(retptr + self._len, other._ptr, other._len);\n', '        return ret;\n', '    }\n', '\n', '    /*\n', '     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n', '     *      newly allocated string.\n', '     * @param self The delimiter to use.\n', '     * @param parts A list of slices to join.\n', '     * @return A newly allocated string containing all the slices in `parts`,\n', '     *         joined with `self`.\n', '     */\n', '    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\n', '        if (parts.length == 0)\n', '            return "";\n', '\n', '        uint length = self._len * (parts.length - 1);\n', '        for(uint i = 0; i < parts.length; i++)\n', '            length += parts[i]._len;\n', '\n', '        string memory ret = new string(length);\n', '        uint retptr;\n', '        assembly { retptr := add(ret, 32) }\n', '\n', '        for(uint i = 0; i < parts.length; i++) {\n', '            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n', '            retptr += parts[i]._len;\n', '            if (i < parts.length - 1) {\n', '                memcpy(retptr, self._ptr, self._len);\n', '                retptr += self._len;\n', '            }\n', '        }\n', '\n', '        return ret;\n', '    }\n', '}\n', '\n', "// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ENS.sol\n", '// with few modifications.\n', '\n', '\n', '\n', '/**\n', ' * ENS Registry interface.\n', ' */\n', 'interface ENSRegistry {\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n', '    function setResolver(bytes32 node, address resolver) external;\n', '    function setOwner(bytes32 node, address owner) external;\n', '    function setTTL(bytes32 node, uint64 ttl) external;\n', '    function owner(bytes32 node) external view returns (address);\n', '    function resolver(bytes32 node) external view returns (address);\n', '    function ttl(bytes32 node) external view returns (uint64);\n', '}\n', '\n', '\n', '/**\n', ' * ENS Resolver interface.\n', ' */\n', 'abstract contract ENSResolver {\n', '    function addr(bytes32 _node) public view virtual returns (address);\n', '    function setAddr(bytes32 _node, address _addr) public virtual;\n', '    function name(bytes32 _node) public view virtual returns (string memory);\n', '    function setName(bytes32 _node, string memory _name) public virtual;\n', '}\n', '\n', '/**\n', ' * ENS Reverse Registrar interface.\n', ' */\n', 'abstract contract ENSReverseRegistrar {\n', '    function claim(address _owner) public virtual returns (bytes32 _node);\n', '    function claimWithResolver(address _owner, address _resolver) public virtual returns (bytes32);\n', '    function setName(string memory _name) public virtual returns (bytes32);\n', '    function node(address _addr) public view virtual returns (bytes32);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', "// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ENSConsumer.sol\n", '// with few modifications.\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ENSConsumer\n', ' * @dev Helper contract to resolve ENS names.\n', ' * @author Julien Niset - <julien@argent.im>\n', ' */\n', 'contract ENSConsumer {\n', '\n', '    using strings for *;\n', '\n', "    // namehash('addr.reverse')\n", '    bytes32 constant public ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n', '\n', '    // the address of the ENS registry\n', '    address ensRegistry;\n', '\n', '    /**\n', '    * @dev No address should be provided when deploying on Mainnet to avoid storage cost. The\n', '    * contract will use the hardcoded value.\n', '    */\n', '    constructor(address _ensRegistry) {\n', '        ensRegistry = _ensRegistry;\n', '    }\n', '\n', '    /**\n', '    * @dev Resolves an ENS name to an address.\n', '    * @param _node The namehash of the ENS name.\n', '    */\n', '    function resolveEns(bytes32 _node) public view returns (address) {\n', '        address resolver = getENSRegistry().resolver(_node);\n', '        return ENSResolver(resolver).addr(_node);\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the official ENS registry.\n', '    */\n', '    function getENSRegistry() public view returns (ENSRegistry) {\n', '        return ENSRegistry(ensRegistry);\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the official ENS reverse registrar.\n', '    */\n', '    function getENSReverseRegistrar() public view returns (ENSReverseRegistrar) {\n', '        return ENSReverseRegistrar(getENSRegistry().owner(ADDR_REVERSE_NODE));\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ModuleRegistry\n', '/// @dev A registry for modules.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'interface ModuleRegistry\n', '{\n', '    /// @dev Registers and enables a new module.\n', '    function registerModule(address module) external;\n', '\n', '    /// @dev Disables a module\n', '    function disableModule(address module) external;\n', '\n', '    /// @dev Returns true if the module is registered and enabled.\n', '    function isModuleEnabled(address module) external view returns (bool);\n', '\n', '    /// @dev Returns the list of enabled modules.\n', '    function enabledModules() external view returns (address[] memory _modules);\n', '\n', '    /// @dev Returns the number of enbaled modules.\n', '    function numOfEnabledModules() external view returns (uint);\n', '\n', '    /// @dev Returns true if the module is ever registered.\n', '    function isModuleRegistered(address module) external view returns (bool);\n', '}\n', '\n', '\n', '\n', '\n', '/// @title Controller\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'abstract contract Controller\n', '{\n', '    ModuleRegistry public moduleRegistry;\n', '    WalletRegistry public walletRegistry;\n', '    address        public walletFactory;\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ReentrancyGuard\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @dev Exposes a modifier that guards a function against reentrancy\n', '///      Changing the value of the same storage value multiple times in a transaction\n', '///      is cheap (starting from Istanbul) so there is no need to minimize\n', '///      the number of times the value is changed\n', 'contract ReentrancyGuard\n', '{\n', '    //The default value must be 0 in order to work behind a proxy.\n', '    uint private _guardValue;\n', '\n', '    modifier nonReentrant()\n', '    {\n', '        require(_guardValue == 0, "REENTRANCY");\n', '        _guardValue = 1;\n', '        _;\n', '        _guardValue = 0;\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'abstract contract ERC20\n', '{\n', '    function totalSupply()\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint);\n', '\n', '    function balanceOf(\n', '        address who\n', '        )\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '        )\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function approve(\n', '        address spender,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Wallet\n', '/// @dev Base contract for smart wallets.\n', '///      Sub-contracts must NOT use non-default constructor to initialize\n', '///      wallet states, instead, `init` shall be used. This is to enable\n', '///      proxies to be deployed in front of the real wallet contract for\n', '///      saving gas.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'interface Wallet\n', '{\n', '    function version() external pure returns (string memory);\n', '\n', '    function owner() external view returns (address);\n', '\n', '    /// @dev Set a new owner.\n', '    function setOwner(address newOwner) external;\n', '\n', '    /// @dev Adds a new module. The `init` method of the module\n', '    ///      will be called with `address(this)` as the parameter.\n', '    ///      This method must throw if the module has already been added.\n', "    /// @param _module The module's address.\n", '    function addModule(address _module) external;\n', '\n', '    /// @dev Removes an existing module. This method must throw if the module\n', "    ///      has NOT been added or the module is the wallet's only module.\n", "    /// @param _module The module's address.\n", '    function removeModule(address _module) external;\n', '\n', '    /// @dev Checks if a module has been added to this wallet.\n', '    /// @param _module The module to check.\n', '    /// @return True if the module exists; False otherwise.\n', '    function hasModule(address _module) external view returns (bool);\n', '\n', '    /// @dev Binds a method from the given module to this\n', "    ///      wallet so the method can be invoked using this wallet's default\n", '    ///      function.\n', '    ///      Note that this method must throw when the given module has\n', '    ///      not been added to this wallet.\n', "    /// @param _method The method's 4-byte selector.\n", "    /// @param _module The module's address. Use address(0) to unbind the method.\n", '    function bindMethod(bytes4 _method, address _module) external;\n', '\n', '    /// @dev Returns the module the given method has been bound to.\n', "    /// @param _method The method's 4-byte selector.\n", '    /// @return _module The address of the bound module. If no binding exists,\n', '    ///                 returns address(0) instead.\n', '    function boundMethodModule(bytes4 _method) external view returns (address _module);\n', '\n', '    /// @dev Performs generic transactions. Any module that has been added to this\n', '    ///      wallet can use this method to transact on any third-party contract with\n', '    ///      msg.sender as this wallet itself.\n', '    ///\n', "    ///      This method will emit `Transacted` event if it doesn't throw.\n", '    ///\n', '    ///      Note: this method must ONLY allow invocations from a module that has\n', '    ///      been added to this wallet. The wallet owner shall NOT be permitted\n', '    ///      to call this method directly.\n', '    ///\n', '    /// @param mode The transaction mode, 1 for CALL, 2 for DELEGATECALL.\n', '    /// @param to The desitination address.\n', '    /// @param value The amount of Ether to transfer.\n', '    /// @param data The data to send over using `to.call{value: value}(data)`\n', "    /// @return returnData The transaction's return value.\n", '    function transact(\n', '        uint8    mode,\n', '        address  to,\n', '        uint     value,\n', '        bytes    calldata data\n', '        )\n', '        external\n', '        returns (bytes memory returnData);\n', '}\n', '\n', "// Taken from Argent's code base - https://github.com/argentlabs/argent-contracts/blob/develop/contracts/ens/ArgentENSManager.sol\n", '// with few modifications.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface for an ENS Mananger.\n', ' */\n', 'interface IENSManager {\n', '    function changeRootnodeOwner(address _newOwner) external;\n', '\n', '    function isAvailable(bytes32 _subnode) external view returns (bool);\n', '\n', '    function resolveName(address _wallet) external view returns (string memory);\n', '\n', '    function register(\n', '        address _wallet,\n', '        address _owner,\n', '        string  calldata _label,\n', '        bytes   calldata _approval\n', '    ) external;\n', '}\n', '\n', '/**\n', ' * @title BaseENSManager\n', ' * @dev Implementation of an ENS manager that orchestrates the complete\n', ' * registration of subdomains for a single root (e.g. argent.eth).\n', ' * The contract defines a manager role who is the only role that can trigger the registration of\n', ' * a new subdomain.\n', ' * @author Julien Niset - <julien@argent.im>\n', ' */\n', 'contract BaseENSManager is IENSManager, OwnerManagable, ENSConsumer {\n', '\n', '    using strings for *;\n', '    using BytesUtil     for bytes;\n', '    using MathUint      for uint;\n', '\n', '    // The managed root name\n', '    string public rootName;\n', '    // The managed root node\n', '    bytes32 public rootNode;\n', '    // The address of the ENS resolver\n', '    address public ensResolver;\n', '\n', '    // *************** Events *************************** //\n', '\n', '    event RootnodeOwnerChange(bytes32 indexed _rootnode, address indexed _newOwner);\n', '    event ENSResolverChanged(address addr);\n', '    event Registered(address indexed _wallet, address _owner, string _ens);\n', '    event Unregistered(string _ens);\n', '\n', '    // *************** Constructor ********************** //\n', '\n', '    /**\n', '     * @dev Constructor that sets the ENS root name and root node to manage.\n', '     * @param _rootName The root name (e.g. argentx.eth).\n', '     * @param _rootNode The node of the root name (e.g. namehash(argentx.eth)).\n', '     */\n', '    constructor(string memory _rootName, bytes32 _rootNode, address _ensRegistry, address _ensResolver)\n', '        ENSConsumer(_ensRegistry)\n', '    {\n', '        rootName = _rootName;\n', '        rootNode = _rootNode;\n', '        ensResolver = _ensResolver;\n', '    }\n', '\n', '    // *************** External Functions ********************* //\n', '\n', '    /**\n', '     * @dev This function must be called when the ENS Manager contract is replaced\n', '     * and the address of the new Manager should be provided.\n', '     * @param _newOwner The address of the new ENS manager that will manage the root node.\n', '     */\n', '    function changeRootnodeOwner(address _newOwner) external override onlyOwner {\n', '        getENSRegistry().setOwner(rootNode, _newOwner);\n', '        emit RootnodeOwnerChange(rootNode, _newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Lets the owner change the address of the ENS resolver contract.\n', '     * @param _ensResolver The address of the ENS resolver contract.\n', '     */\n', '    function changeENSResolver(address _ensResolver) external onlyOwner {\n', '        require(_ensResolver != address(0), "WF: address cannot be null");\n', '        ensResolver = _ensResolver;\n', '        emit ENSResolverChanged(_ensResolver);\n', '    }\n', '\n', '    /**\n', '    * @dev Lets the manager assign an ENS subdomain of the root node to a target address.\n', '    * Registers both the forward and reverse ENS.\n', '    * @param _wallet The wallet which owns the subdomain.\n', "    * @param _owner The wallet's owner.\n", '    * @param _label The subdomain label.\n', '    * @param _approval The signature of _wallet, _owner and _label by a manager.\n', '    */\n', '    function register(\n', '        address _wallet,\n', '        address _owner,\n', '        string  calldata _label,\n', '        bytes   calldata _approval\n', '        )\n', '        external\n', '        override\n', '        onlyManager\n', '    {\n', '        verifyApproval(_wallet, _owner, _label, _approval);\n', '\n', '        bytes32 labelNode = keccak256(abi.encodePacked(_label));\n', '        bytes32 node = keccak256(abi.encodePacked(rootNode, labelNode));\n', '        address currentOwner = getENSRegistry().owner(node);\n', '        require(currentOwner == address(0), "AEM: _label is alrealdy owned");\n', '\n', '        // Forward ENS\n', '        getENSRegistry().setSubnodeOwner(rootNode, labelNode, address(this));\n', '        getENSRegistry().setResolver(node, ensResolver);\n', '        getENSRegistry().setOwner(node, _wallet);\n', '        ENSResolver(ensResolver).setAddr(node, _wallet);\n', '\n', '        // Reverse ENS\n', '        strings.slice[] memory parts = new strings.slice[](2);\n', '        parts[0] = _label.toSlice();\n', '        parts[1] = rootName.toSlice();\n', '        string memory name = ".".toSlice().join(parts);\n', '        bytes32 reverseNode = getENSReverseRegistrar().node(_wallet);\n', '        ENSResolver(ensResolver).setName(reverseNode, name);\n', '\n', '        emit Registered(_wallet, _owner, name);\n', '    }\n', '\n', '    // *************** Public Functions ********************* //\n', '\n', '    /**\n', '    * @dev Resolves an address to an ENS name\n', '    * @param _wallet The ENS owner address\n', '    */\n', '    function resolveName(address _wallet) public view override returns (string memory) {\n', '        bytes32 reverseNode = getENSReverseRegistrar().node(_wallet);\n', '        return ENSResolver(ensResolver).name(reverseNode);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true is a given subnode is available.\n', '     * @param _subnode The target subnode.\n', '     * @return true if the subnode is available.\n', '     */\n', '    function isAvailable(bytes32 _subnode) public view override returns (bool) {\n', '        bytes32 node = keccak256(abi.encodePacked(rootNode, _subnode));\n', '        address currentOwner = getENSRegistry().owner(node);\n', '        if(currentOwner == address(0)) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function verifyApproval(\n', '        address _wallet,\n', '        address _owner,\n', '        string  memory _label,\n', '        bytes   memory _approval\n', '        )\n', '        internal\n', '        view\n', '    {\n', '        bytes32 messageHash = keccak256(\n', '            abi.encodePacked(\n', '                _wallet,\n', '                _owner,\n', '                _label\n', '            )\n', '        );\n', '\n', '        bytes32 hash = keccak256(\n', '            abi.encodePacked(\n', '                "\\x19Ethereum Signed Message:\\n32",\n', '                messageHash\n', '            )\n', '        );\n', '\n', '        address signer = SignatureUtil.recoverECDSASigner(hash, _approval);\n', '        require(isManager(signer), "UNAUTHORIZED");\n', '    }\n', '\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title PriceOracle\n', 'interface PriceOracle\n', '{\n', "    // @dev Return's the token's value in ETH\n", '    function tokenValue(address token, uint amount)\n', '        external\n', '        view\n', '        returns (uint value);\n', '}\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title DappAddressStore\n', '/// @dev This store maintains global whitelist dapps.\n', 'contract DappAddressStore is DataStore, OwnerManagable\n', '{\n', '    bytes32 internal constant DAPPS = keccak256("__DAPPS__");\n', '\n', '    event Whitelisted(\n', '        address addr,\n', '        bool    whitelisted\n', '    );\n', '\n', '    constructor() DataStore() {}\n', '\n', '    function addDapp(address addr)\n', '        public\n', '        onlyManager\n', '    {\n', '        addAddressToSet(DAPPS, addr, true);\n', '        emit Whitelisted(addr, true);\n', '    }\n', '\n', '    function removeDapp(address addr)\n', '        public\n', '        onlyManager\n', '    {\n', '        removeAddressFromSet(DAPPS, addr);\n', '        emit Whitelisted(addr, false);\n', '    }\n', '\n', '    function dapps()\n', '        public\n', '        view\n', '        returns (\n', '            address[] memory addresses\n', '        )\n', '    {\n', '        return addressesInSet(DAPPS);\n', '    }\n', '\n', '    function isDapp(\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return isAddressInSet(DAPPS, addr);\n', '    }\n', '\n', '    function numDapps()\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return numAddressesInSet(DAPPS);\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title HashStore\n', '/// @dev This store maintains all hashes for SignedRequest.\n', 'contract HashStore is DataStore\n', '{\n', '    // wallet => hash => consumed\n', '    mapping(address => mapping(bytes32 => bool)) public hashes;\n', '\n', '    constructor() {}\n', '\n', '    function verifyAndUpdate(address wallet, bytes32 hash)\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        require(!hashes[wallet][hash], "HASH_EXIST");\n', '        hashes[wallet][hash] = true;\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title NonceStore\n', '/// @dev This store maintains all nonces for metaTx\n', 'contract NonceStore is DataStore\n', '{\n', '    mapping(address => uint) public nonces;\n', '\n', '    constructor() DataStore() {}\n', '\n', '    function lastNonce(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return nonces[wallet];\n', '    }\n', '\n', '    function isNonceValid(address wallet, uint nonce)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return nonce > nonces[wallet] && (nonce >> 128) <= block.number;\n', '    }\n', '\n', '    function verifyAndUpdate(address wallet, uint nonce)\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        require(isNonceValid(wallet, nonce), "INVALID_NONCE");\n', '        nonces[wallet] = nonce;\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title QuotaStore\n', '/// @dev This store maintains daily spending quota for each wallet.\n', '///      A rolling daily limit is used.\n', 'contract QuotaStore is DataStore, Claimable\n', '{\n', '    using MathUint for uint;\n', '    using SafeCast for uint;\n', '\n', '    uint128 public defaultQuota;\n', '\n', '    // Optimized to fit into 64 bytes (2 slots)\n', '    struct Quota\n', '    {\n', '        uint128 currentQuota; // 0 indicates default\n', '        uint128 pendingQuota;\n', '        uint128 spentAmount;\n', '        uint64  spentTimestamp;\n', '        uint64  pendingUntil;\n', '    }\n', '\n', '    mapping (address => Quota) public quotas;\n', '\n', '    event DefaultQuotaChanged(\n', '        uint prevValue,\n', '        uint currentValue\n', '    );\n', '\n', '    event QuotaScheduled(\n', '        address wallet,\n', '        uint    pendingQuota,\n', '        uint64  pendingUntil\n', '    );\n', '\n', '    constructor(uint128 _defaultQuota)\n', '        DataStore()\n', '    {\n', '        defaultQuota = _defaultQuota;\n', '    }\n', '\n', '    function changeDefaultQuota(uint128 _defaultQuota)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            _defaultQuota != defaultQuota &&\n', '            _defaultQuota >= 1 ether &&\n', '            _defaultQuota <= 100 ether,\n', '            "INVALID_DEFAULT_QUOTA"\n', '        );\n', '        emit DefaultQuotaChanged(defaultQuota, _defaultQuota);\n', '        defaultQuota = _defaultQuota;\n', '    }\n', '\n', '    function changeQuota(\n', '        address wallet,\n', '        uint    newQuota,\n', '        uint    effectiveTime\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        quotas[wallet].currentQuota = currentQuota(wallet).toUint128();\n', '        quotas[wallet].pendingQuota = newQuota.toUint128();\n', '        quotas[wallet].pendingUntil = effectiveTime.toUint64();\n', '\n', '        emit QuotaScheduled(\n', '            wallet,\n', '            newQuota,\n', '            quotas[wallet].pendingUntil\n', '        );\n', '    }\n', '\n', '    function checkAndAddToSpent(\n', '        address wallet,\n', '        uint    amount\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        require(hasEnoughQuota(wallet, amount), "QUOTA_EXCEEDED");\n', '        addToSpent(wallet, amount);\n', '    }\n', '\n', '    function addToSpent(\n', '        address wallet,\n', '        uint    amount\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        Quota storage q = quotas[wallet];\n', '        q.spentAmount = spentQuota(wallet).add(amount).toUint128();\n', '        q.spentTimestamp = uint64(block.timestamp);\n', '    }\n', '\n', '    function currentQuota(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        Quota storage q = quotas[wallet];\n', '        uint value = q.pendingUntil <= block.timestamp ?\n', '            q.pendingQuota : q.currentQuota;\n', '\n', '        return value == 0 ? defaultQuota : value;\n', '    }\n', '\n', '    function pendingQuota(address wallet)\n', '        public\n', '        view\n', '        returns (\n', '            uint _pendingQuota,\n', '            uint _pendingUntil\n', '        )\n', '    {\n', '        Quota storage q = quotas[wallet];\n', '        if (q.pendingUntil > 0 && q.pendingUntil > block.timestamp) {\n', '            _pendingQuota = q.pendingQuota > 0 ? q.pendingQuota : defaultQuota;\n', '            _pendingUntil = q.pendingUntil;\n', '        }\n', '    }\n', '\n', '    function spentQuota(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        Quota storage q = quotas[wallet];\n', '        uint timeSinceLastSpent = block.timestamp.sub(q.spentTimestamp);\n', '        if (timeSinceLastSpent < 1 days) {\n', '            return uint(q.spentAmount).sub(timeSinceLastSpent.mul(q.spentAmount) / 1 days);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function availableQuota(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        uint quota = currentQuota(wallet);\n', '        uint spent = spentQuota(wallet);\n', '        return quota > spent ? quota - spent : 0;\n', '    }\n', '\n', '    function hasEnoughQuota(\n', '        address wallet,\n', '        uint    requiredAmount\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return availableQuota(wallet) >= requiredAmount;\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title SecurityStore\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'contract SecurityStore is DataStore\n', '{\n', '    using MathUint for uint;\n', '    using SafeCast for uint;\n', '\n', '    struct Wallet\n', '    {\n', '        address    inheritor;\n', '        uint64     lastActive; // the latest timestamp the owner is considered to be active\n', '        address    lockedBy;   // the module that locked the wallet.\n', '        uint64     lock;\n', '\n', '        Data.Guardian[]            guardians;\n', '        mapping (address => uint)  guardianIdx;\n', '    }\n', '\n', '    mapping (address => Wallet) public wallets;\n', '\n', '    constructor() DataStore() {}\n', '\n', '    function isGuardian(\n', '        address wallet,\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        Data.Guardian memory guardian = getGuardian(wallet, addr);\n', '        return guardian.addr != address(0) && isGuardianActive(guardian);\n', '    }\n', '\n', '    function isGuardianOrPendingAddition(\n', '        address wallet,\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        Data.Guardian memory guardian = getGuardian(wallet, addr);\n', '        return guardian.addr != address(0) &&\n', '            (isGuardianActive(guardian) || isGuardianPendingAddition(guardian));\n', '    }\n', '\n', '    function getGuardian(\n', '        address wallet,\n', '        address guardianAddr\n', '        )\n', '        public\n', '        view\n', '        returns (Data.Guardian memory)\n', '    {\n', '        uint index = wallets[wallet].guardianIdx[guardianAddr];\n', '        if (index > 0) {\n', '            return wallets[wallet].guardians[index-1];\n', '        }\n', '    }\n', '\n', '    // @dev Returns active guardians.\n', '    function guardians(address wallet)\n', '        public\n', '        view\n', '        returns (Data.Guardian[] memory _guardians)\n', '    {\n', '        Wallet storage w = wallets[wallet];\n', '        _guardians = new Data.Guardian[](w.guardians.length);\n', '        uint index = 0;\n', '        for (uint i = 0; i < w.guardians.length; i++) {\n', '            Data.Guardian memory g = w.guardians[i];\n', '            if (isGuardianActive(g)) {\n', '                _guardians[index] = g;\n', '                index ++;\n', '            }\n', '        }\n', '        assembly { mstore(_guardians, index) }\n', '    }\n', '\n', '    // @dev Returns the number of active guardians.\n', '    function numGuardians(address wallet)\n', '        public\n', '        view\n', '        returns (uint count)\n', '    {\n', '        Wallet storage w = wallets[wallet];\n', '        for (uint i = 0; i < w.guardians.length; i++) {\n', '            if (isGuardianActive(w.guardians[i])) {\n', '                count ++;\n', '            }\n', '        }\n', '    }\n', '\n', '    // @dev Returns guardians who are either active or pending addition.\n', '    function guardiansWithPending(address wallet)\n', '        public\n', '        view\n', '        returns (Data.Guardian[] memory _guardians)\n', '    {\n', '        Wallet storage w = wallets[wallet];\n', '        _guardians = new Data.Guardian[](w.guardians.length);\n', '        uint index = 0;\n', '        for (uint i = 0; i < w.guardians.length; i++) {\n', '            Data.Guardian memory g = w.guardians[i];\n', '            if (isGuardianActive(g) || isGuardianPendingAddition(g)) {\n', '                _guardians[index] = g;\n', '                index ++;\n', '            }\n', '        }\n', '        assembly { mstore(_guardians, index) }\n', '    }\n', '\n', '    // @dev Returns the number of guardians who are active or pending addition.\n', '    function numGuardiansWithPending(address wallet)\n', '        public\n', '        view\n', '        returns (uint count)\n', '    {\n', '        Wallet storage w = wallets[wallet];\n', '        for (uint i = 0; i < w.guardians.length; i++) {\n', '            Data.Guardian memory g = w.guardians[i];\n', '            if (isGuardianActive(g) || isGuardianPendingAddition(g)) {\n', '                count ++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function addGuardian(\n', '        address wallet,\n', '        address guardianAddr,\n', '        uint    group,\n', '        uint    validSince\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        cleanRemovedGuardians(wallet);\n', '\n', '        require(guardianAddr != address(0), "ZERO_ADDRESS");\n', '        Wallet storage w = wallets[wallet];\n', '\n', '        uint pos = w.guardianIdx[guardianAddr];\n', '        require(pos == 0, "GUARDIAN_EXISTS");\n', '\n', '        // Add the new guardian\n', '        Data.Guardian memory g = Data.Guardian(\n', '            guardianAddr,\n', '            group.toUint16(),\n', '            validSince.toUint40(),\n', '            uint40(0)\n', '        );\n', '        w.guardians.push(g);\n', '        w.guardianIdx[guardianAddr] = w.guardians.length;\n', '    }\n', '\n', '    function cancelGuardianAddition(\n', '        address wallet,\n', '        address guardianAddr\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        cleanRemovedGuardians(wallet);\n', '\n', '        Wallet storage w = wallets[wallet];\n', '        uint idx = w.guardianIdx[guardianAddr];\n', '        require(idx > 0, "GUARDIAN_NOT_EXISTS");\n', '        require(\n', '            isGuardianPendingAddition(w.guardians[idx - 1]),\n', '            "NOT_PENDING_ADDITION"\n', '        );\n', '\n', '        Data.Guardian memory lastGuardian = w.guardians[w.guardians.length - 1];\n', '        if (guardianAddr != lastGuardian.addr) {\n', '            w.guardians[idx - 1] = lastGuardian;\n', '            w.guardianIdx[lastGuardian.addr] = idx;\n', '        }\n', '        w.guardians.pop();\n', '        delete w.guardianIdx[guardianAddr];\n', '    }\n', '\n', '    function removeGuardian(\n', '        address wallet,\n', '        address guardianAddr,\n', '        uint    validUntil\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        cleanRemovedGuardians(wallet);\n', '\n', '        Wallet storage w = wallets[wallet];\n', '        uint idx = w.guardianIdx[guardianAddr];\n', '        require(idx > 0, "GUARDIAN_NOT_EXISTS");\n', '\n', '        w.guardians[idx - 1].validUntil = validUntil.toUint40();\n', '    }\n', '\n', '    function removeAllGuardians(address wallet)\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        Wallet storage w = wallets[wallet];\n', '        for (uint i = 0; i < w.guardians.length; i++) {\n', '            delete w.guardianIdx[w.guardians[i].addr];\n', '        }\n', '        delete w.guardians;\n', '    }\n', '\n', '    function cancelGuardianRemoval(\n', '        address wallet,\n', '        address guardianAddr\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        cleanRemovedGuardians(wallet);\n', '\n', '        Wallet storage w = wallets[wallet];\n', '        uint idx = w.guardianIdx[guardianAddr];\n', '        require(idx > 0, "GUARDIAN_NOT_EXISTS");\n', '\n', '        require(\n', '            isGuardianPendingRemoval(w.guardians[idx - 1]),\n', '            "NOT_PENDING_REMOVAL"\n', '        );\n', '\n', '        w.guardians[idx - 1].validUntil = 0;\n', '    }\n', '\n', '    function getLock(address wallet)\n', '        public\n', '        view\n', '        returns (uint _lock, address _lockedBy)\n', '    {\n', '        _lock = wallets[wallet].lock;\n', '        _lockedBy = wallets[wallet].lockedBy;\n', '    }\n', '\n', '    function setLock(\n', '        address wallet,\n', '        uint    lock\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        require(lock == 0 || lock > block.timestamp, "INVALID_LOCK_TIME");\n', '\n', '        wallets[wallet].lock = lock.toUint64();\n', '        wallets[wallet].lockedBy = msg.sender;\n', '    }\n', '\n', '    function lastActive(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return wallets[wallet].lastActive;\n', '    }\n', '\n', '    function touchLastActive(address wallet)\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        wallets[wallet].lastActive = uint64(block.timestamp);\n', '    }\n', '\n', '    function inheritor(address wallet)\n', '        public\n', '        view\n', '        returns (\n', '            address _who,\n', '            uint    _lastActive\n', '        )\n', '    {\n', '        _who = wallets[wallet].inheritor;\n', '        _lastActive = wallets[wallet].lastActive;\n', '    }\n', '\n', '    function setInheritor(address wallet, address who)\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        wallets[wallet].inheritor = who;\n', '        wallets[wallet].lastActive = uint64(block.timestamp);\n', '    }\n', '\n', '    function cleanRemovedGuardians(address wallet)\n', '        private\n', '    {\n', '        Wallet storage w = wallets[wallet];\n', '\n', '        for (int i = int(w.guardians.length) - 1; i >= 0; i--) {\n', '            Data.Guardian memory g = w.guardians[uint(i)];\n', '            if (isGuardianExpired(g)) {\n', '                Data.Guardian memory lastGuardian = w.guardians[w.guardians.length - 1];\n', '\n', '                if (g.addr != lastGuardian.addr) {\n', '                    w.guardians[uint(i)] = lastGuardian;\n', '                    w.guardianIdx[lastGuardian.addr] = uint(i) + 1;\n', '                }\n', '                w.guardians.pop();\n', '                delete w.guardianIdx[g.addr];\n', '            }\n', '        }\n', '    }\n', '\n', '    function isGuardianActive(Data.Guardian memory guardian)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        return guardian.validSince > 0 && guardian.validSince <= block.timestamp &&\n', '            !isGuardianExpired(guardian);\n', '    }\n', '\n', '    function isGuardianPendingAddition(Data.Guardian memory guardian)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        return guardian.validSince > block.timestamp;\n', '    }\n', '\n', '    function isGuardianPendingRemoval(Data.Guardian memory guardian)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        return guardian.validUntil > block.timestamp;\n', '    }\n', '\n', '    function isGuardianExpired(Data.Guardian memory guardian)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        return guardian.validUntil > 0 &&\n', '            guardian.validUntil <= block.timestamp;\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title WhitelistStore\n', "/// @dev This store maintains a wallet's whitelisted addresses.\n", 'contract WhitelistStore is DataStore, AddressSet\n', '{\n', '    // wallet => whitelisted_addr => effective_since\n', '    mapping(address => mapping(address => uint)) public effectiveTimeMap;\n', '\n', '    event Whitelisted(\n', '        address wallet,\n', '        address addr,\n', '        bool    whitelisted,\n', '        uint    effectiveTime\n', '    );\n', '\n', '    constructor() DataStore() {}\n', '\n', '    function addToWhitelist(\n', '        address wallet,\n', '        address addr,\n', '        uint    effectiveTime\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        addAddressToSet(walletKey(wallet), addr, true);\n', '        uint effective = effectiveTime >= block.timestamp ? effectiveTime : block.timestamp;\n', '        effectiveTimeMap[wallet][addr] = effective;\n', '        emit Whitelisted(wallet, addr, true, effective);\n', '    }\n', '\n', '    function removeFromWhitelist(\n', '        address wallet,\n', '        address addr\n', '        )\n', '        public\n', '        onlyWalletModule(wallet)\n', '    {\n', '        removeAddressFromSet(walletKey(wallet), addr);\n', '        delete effectiveTimeMap[wallet][addr];\n', '        emit Whitelisted(wallet, addr, false, 0);\n', '    }\n', '\n', '    function whitelist(address wallet)\n', '        public\n', '        view\n', '        returns (\n', '            address[] memory addresses,\n', '            uint[]    memory effectiveTimes\n', '        )\n', '    {\n', '        addresses = addressesInSet(walletKey(wallet));\n', '        effectiveTimes = new uint[](addresses.length);\n', '        for (uint i = 0; i < addresses.length; i++) {\n', '            effectiveTimes[i] = effectiveTimeMap[wallet][addresses[i]];\n', '        }\n', '    }\n', '\n', '    function isWhitelisted(\n', '        address wallet,\n', '        address addr\n', '        )\n', '        public\n', '        view\n', '        returns (\n', '            bool isWhitelistedAndEffective,\n', '            uint effectiveTime\n', '        )\n', '    {\n', '        effectiveTime = effectiveTimeMap[wallet][addr];\n', '        isWhitelistedAndEffective = effectiveTime > 0 && effectiveTime <= block.timestamp;\n', '    }\n', '\n', '    function whitelistSize(address wallet)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return numAddressesInSet(walletKey(wallet));\n', '    }\n', '\n', '    function walletKey(address addr)\n', '        public\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(abi.encodePacked("__WHITELIST__", addr));\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/// @title ControllerImpl\n', '/// @dev Basic implementation of a Controller.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract ControllerImpl is Claimable, Controller\n', '{\n', '    address             public collectTo;\n', '    uint                public defaultLockPeriod;\n', '    BaseENSManager      public ensManager;\n', '    PriceOracle         public priceOracle;\n', '    DappAddressStore    public dappAddressStore;\n', '    HashStore           public hashStore;\n', '    NonceStore          public nonceStore;\n', '    QuotaStore          public quotaStore;\n', '    SecurityStore       public securityStore;\n', '    WhitelistStore      public whitelistStore;\n', '\n', '    // Make sure this value if false in production env.\n', '    // Ideally we can use chainid(), but there is a bug in truffle so testing is buggy:\n', '    // https://github.com/trufflesuite/ganache/issues/1643\n', '    bool                public allowChangingWalletFactory;\n', '\n', '    event AddressChanged(\n', '        string   name,\n', '        address  addr\n', '    );\n', '\n', '    constructor(\n', '        ModuleRegistry    _moduleRegistry,\n', '        WalletRegistry    _walletRegistry,\n', '        uint              _defaultLockPeriod,\n', '        address           _collectTo,\n', '        BaseENSManager    _ensManager,\n', '        PriceOracle       _priceOracle,\n', '        bool              _allowChangingWalletFactory\n', '        )\n', '    {\n', '        moduleRegistry = _moduleRegistry;\n', '        walletRegistry = _walletRegistry;\n', '\n', '        defaultLockPeriod = _defaultLockPeriod;\n', '\n', '        require(_collectTo != address(0), "ZERO_ADDRESS");\n', '        collectTo = _collectTo;\n', '\n', '        ensManager = _ensManager;\n', '        priceOracle = _priceOracle;\n', '        allowChangingWalletFactory = _allowChangingWalletFactory;\n', '    }\n', '\n', '    function initStores(\n', '        DappAddressStore  _dappAddressStore,\n', '        HashStore         _hashStore,\n', '        NonceStore        _nonceStore,\n', '        QuotaStore        _quotaStore,\n', '        SecurityStore     _securityStore,\n', '        WhitelistStore    _whitelistStore\n', '        )\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            address(_dappAddressStore) != address(0),\n', '            "ZERO_ADDRESS"\n', '        );\n', '\n', '        // Make sure this function can only invoked once.\n', '        require(\n', '            address(dappAddressStore) == address(0),\n', '            "INITIALIZED_ALREADY"\n', '        );\n', '\n', '        dappAddressStore = _dappAddressStore;\n', '        hashStore = _hashStore;\n', '        nonceStore = _nonceStore;\n', '        quotaStore = _quotaStore;\n', '        securityStore = _securityStore;\n', '        whitelistStore = _whitelistStore;\n', '    }\n', '\n', '    function initWalletFactory(address _walletFactory)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            allowChangingWalletFactory || walletFactory == address(0),\n', '            "INITIALIZED_ALREADY"\n', '        );\n', '        require(_walletFactory != address(0), "ZERO_ADDRESS");\n', '        walletFactory = _walletFactory;\n', '        emit AddressChanged("WalletFactory", walletFactory);\n', '    }\n', '\n', '    function setCollectTo(address _collectTo)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(_collectTo != address(0), "ZERO_ADDRESS");\n', '        collectTo = _collectTo;\n', '        emit AddressChanged("CollectTo", collectTo);\n', '    }\n', '\n', '    function setPriceOracle(PriceOracle _priceOracle)\n', '        external\n', '        onlyOwner\n', '    {\n', '        priceOracle = _priceOracle;\n', '        emit AddressChanged("PriceOracle", address(priceOracle));\n', '    }\n', '\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', 'library EIP712\n', '{\n', '    struct Domain {\n', '        string  name;\n', '        string  version;\n', '        address verifyingContract;\n', '    }\n', '\n', '    bytes32 constant internal EIP712_DOMAIN_TYPEHASH = keccak256(\n', '        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n', '    );\n', '\n', '    string constant internal EIP191_HEADER = "\\x19\\x01";\n', '\n', '    function hash(Domain memory domain)\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        uint _chainid;\n', '        assembly { _chainid := chainid() }\n', '\n', '        return keccak256(\n', '            abi.encode(\n', '                EIP712_DOMAIN_TYPEHASH,\n', '                keccak256(bytes(domain.name)),\n', '                keccak256(bytes(domain.version)),\n', '                _chainid,\n', '                domain.verifyingContract\n', '            )\n', '        );\n', '    }\n', '\n', '    function hashPacked(\n', '        bytes32 domainSeperator,\n', '        bytes   memory encodedData\n', '        )\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(EIP191_HEADER, domainSeperator, keccak256(encodedData))\n', '        );\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Utility Functions for addresses\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', 'library AddressUtil\n', '{\n', '    using AddressUtil for *;\n', '\n', '    function isContract(\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(addr) }\n', '        return (codehash != 0x0 &&\n', '                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n', '    }\n', '\n', '    function toPayable(\n', '        address addr\n', '        )\n', '        internal\n', '        pure\n', '        returns (address payable)\n', '    {\n', '        return address(uint160(addr));\n', '    }\n', '\n', '    // Works like address.send but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETH(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        if (amount == 0) {\n', '            return true;\n', '        }\n', '        address payable recipient = to.toPayable();\n', '        /* solium-disable-next-line */\n', '        (success,) = recipient.call{value: amount, gas: gasLimit}("");\n', '    }\n', '\n', '    // Works like address.transfer but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETHAndVerify(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        success = to.sendETH(amount, gasLimit);\n', '        require(success, "TRANSFER_FAILURE");\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Module\n', '/// @dev Base contract for all smart wallet modules.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'interface Module\n', '{\n', '    /// @dev Activates the module for the given wallet (msg.sender) after the module is added.\n', '    ///      Warning: this method shall ONLY be callable by a wallet.\n', '    function activate() external;\n', '\n', '    /// @dev Deactivates the module for the given wallet (msg.sender) before the module is removed.\n', '    ///      Warning: this method shall ONLY be callable by a wallet.\n', '    function deactivate() external;\n', '}\n', '\n', '//Mainly taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n', '\n', '\n', 'library BytesUtil {\n', '    function slice(\n', '        bytes memory _bytes,\n', '        uint _start,\n', '        uint _length\n', '    )\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        require(_bytes.length >= (_start + _length));\n', '\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            switch iszero(_length)\n', '            case 0 {\n', '                // Get a location of some free memory and store it in tempBytes as\n', '                // Solidity does for memory variables.\n', '                tempBytes := mload(0x40)\n', '\n', '                // The first word of the slice result is potentially a partial\n', '                // word read from the original array. To read it, we calculate\n', '                // the length of that partial word and start copying that many\n', '                // bytes into the array. The first word we copy will start with\n', "                // data we don't care about, but the last `lengthmod` bytes will\n", '                // land at the beginning of the contents of the new array. When\n', "                // we're done copying, we overwrite the full first word with\n", '                // the actual length of the slice.\n', '                let lengthmod := and(_length, 31)\n', '\n', '                // The multiplication in the next line is necessary\n', '                // because when slicing multiples of 32 bytes (lengthmod == 0)\n', "                // the following copy loop was copying the origin's length\n", '                // and then ending prematurely not copying everything it should.\n', '                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                let end := add(mc, _length)\n', '\n', '                for {\n', '                    // The multiplication in the next line has the same exact purpose\n', '                    // as the one above.\n', '                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                } lt(mc, end) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    mstore(mc, mload(cc))\n', '                }\n', '\n', '                mstore(tempBytes, _length)\n', '\n', '                //update free-memory pointer\n', '                //allocating the array padded to 32 bytes like the compiler does now\n', '                mstore(0x40, and(add(mc, 31), not(31)))\n', '            }\n', "            //if we want a zero-length slice let's just return a zero-length array\n", '            default {\n', '                tempBytes := mload(0x40)\n', '\n', '                mstore(0x40, add(tempBytes, 0x20))\n', '            }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n', '        require(_bytes.length >= (_start + 20));\n', '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n', '        require(_bytes.length >= (_start + 1));\n', '        uint8 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x1), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\n', '        require(_bytes.length >= (_start + 2));\n', '        uint16 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x2), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\n', '        require(_bytes.length >= (_start + 3));\n', '        uint24 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x3), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\n', '        require(_bytes.length >= (_start + 4));\n', '        uint32 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x4), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\n', '        require(_bytes.length >= (_start + 8));\n', '        uint64 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x8), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\n', '        require(_bytes.length >= (_start + 12));\n', '        uint96 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0xc), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\n', '        require(_bytes.length >= (_start + 16));\n', '        uint128 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x10), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n', '        require(_bytes.length >= (_start + 32));\n', '        uint256 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\n', '        require(_bytes.length >= (_start + 4));\n', '        bytes4 tempBytes4;\n', '\n', '        assembly {\n', '            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes4;\n', '    }\n', '\n', '    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\n', '        require(_bytes.length >= (_start + 32));\n', '        bytes32 tempBytes32;\n', '\n', '        assembly {\n', '            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes32;\n', '    }\n', '\n', '    function fastSHA256(\n', '        bytes memory data\n', '        )\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        bytes32[] memory result = new bytes32[](1);\n', '        bool success;\n', '        assembly {\n', '             let ptr := add(data, 32)\n', '             success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)\n', '        }\n', '        require(success, "SHA256_FAILED");\n', '        return result[0];\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title SignatureUtil\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', "/// @dev This method supports multihash standard. Each signature's first byte indicates\n", "///      the signature's type, the second byte indicates the signature's length, therefore,\n", '///      each signature will have 2 extra bytes prefix. Mulitple signatures are concatenated\n', '///      together.\n', 'library SignatureUtil\n', '{\n', '    using BytesUtil     for bytes;\n', '    using MathUint      for uint;\n', '    using AddressUtil   for address;\n', '\n', '    enum SignatureType {\n', '        ILLEGAL,\n', '        INVALID,\n', '        EIP_712,\n', '        ETH_SIGN,\n', '        WALLET   // deprecated\n', '    }\n', '\n', '    bytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\n', '\n', '    bytes4 constant internal ERC1271_FUNCTION_WITH_BYTES_SELECTOR = bytes4(\n', '        keccak256(bytes("isValidSignature(bytes,bytes)"))\n', '    );\n', '\n', '    bytes4 constant internal ERC1271_FUNCTION_WITH_BYTES32_SELECTOR = bytes4(\n', '        keccak256(bytes("isValidSignature(bytes32,bytes)"))\n', '    );\n', '\n', '    function verifySignatures(\n', '        bytes32          signHash,\n', '        address[] memory signers,\n', '        bytes[]   memory signatures\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return verifySignatures(abi.encodePacked(signHash), signers, signatures);\n', '    }\n', '\n', '    function verifySignatures(\n', '        bytes     memory data,\n', '        address[] memory signers,\n', '        bytes[]   memory signatures\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        require(signers.length == signatures.length, "BAD_SIGNATURE_DATA");\n', '        address lastSigner;\n', '        for (uint i = 0; i < signers.length; i++) {\n', '            require(signers[i] > lastSigner, "INVALID_SIGNERS_ORDER");\n', '            lastSigner = signers[i];\n', '            if (!verifySignature(data, signers[i], signatures[i])) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function verifySignature(\n', '        bytes   memory data,\n', '        address        signer,\n', '        bytes   memory signature\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return signer.isContract() ?\n', '            verifyERC1271Signature(data, signer, signature) :\n', '            verifyEOASignature(data, signer, signature);\n', '    }\n', '\n', '    function verifySignature(\n', '        bytes32        signHash,\n', '        address        signer,\n', '        bytes   memory signature\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return verifySignature(abi.encodePacked(signHash), signer, signature);\n', '    }\n', '\n', '    function recoverECDSASigner(\n', '        bytes32      signHash,\n', '        bytes memory signature\n', '        )\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        if (signature.length != 65) {\n', '            return address(0);\n', '        }\n', '\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8   v;\n', '        // we jump 32 (0x20) as the first slot of bytes contains the length\n', '        // we jump 65 (0x41) per signature\n', '        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := and(mload(add(signature, 0x41)), 0xff)\n', '        }\n', '        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\n', '        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n', '            return address(0);\n', '        }\n', '        if (v == 27 || v == 28) {\n', '            return ecrecover(signHash, v, r, s);\n', '        } else {\n', '            return address(0);\n', '        }\n', '    }\n', '\n', '    function recoverECDSASigner(\n', '        bytes memory data,\n', '        bytes memory signature\n', '        )\n', '        internal\n', '        pure\n', '        returns (address addr1, address addr2)\n', '    {\n', '        if (data.length == 32) {\n', '            addr1 = recoverECDSASigner(data.toBytes32(0), signature);\n', '        }\n', '        addr2 = recoverECDSASigner(keccak256(data), signature);\n', '    }\n', '\n', '    function verifyEOASignature(\n', '        bytes   memory data,\n', '        address        signer,\n', '        bytes   memory signature\n', '        )\n', '        private\n', '        pure\n', '        returns (bool)\n', '    {\n', '        if (signer == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        uint signatureTypeOffset = signature.length.sub(1);\n', '        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\n', '\n', '        bytes memory stripped = signature.slice(0, signatureTypeOffset);\n', '\n', '        if (signatureType == SignatureType.EIP_712) {\n', '            (address addr1, address addr2) = recoverECDSASigner(data, stripped);\n', '            return addr1 == signer || addr2 == signer;\n', '        } else if (signatureType == SignatureType.ETH_SIGN) {\n', '            if (data.length == 32) {\n', '                bytes32 hash = keccak256(\n', '                    abi.encodePacked("\\x19Ethereum Signed Message:\\n32", data.toBytes32(0))\n', '                );\n', '                if (recoverECDSASigner(hash, stripped) == signer) {\n', '                    return true;\n', '                }\n', '            }\n', '            bytes32 hash = keccak256(\n', '                abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(data))\n', '            );\n', '            return recoverECDSASigner(hash, stripped) == signer;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function verifyERC1271Signature(\n', '        bytes   memory data,\n', '        address signer,\n', '        bytes   memory signature\n', '        )\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        return data.length == 32 &&\n', '            verifyERC1271WithBytes32(data.toBytes32(0), signer, signature) ||\n', '            verifyERC1271WithBytes(data, signer, signature);\n', '    }\n', '\n', '    function verifyERC1271WithBytes(\n', '        bytes   memory data,\n', '        address signer,\n', '        bytes   memory signature\n', '        )\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            ERC1271_FUNCTION_WITH_BYTES_SELECTOR,\n', '            data,\n', '            signature\n', '        );\n', '        (bool success, bytes memory result) = signer.staticcall(callData);\n', '        return (\n', '            success &&\n', '            result.length == 32 &&\n', '            result.toBytes4(0) == ERC1271_MAGICVALUE\n', '        );\n', '    }\n', '\n', '    function verifyERC1271WithBytes32(\n', '        bytes32 hash,\n', '        address signer,\n', '        bytes   memory signature\n', '        )\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            ERC1271_FUNCTION_WITH_BYTES32_SELECTOR,\n', '            hash,\n', '            signature\n', '        );\n', '        (bool success, bytes memory result) = signer.staticcall(callData);\n', '        return (\n', '            success &&\n', '            result.length == 32 &&\n', '            result.toBytes4(0) == ERC1271_MAGICVALUE\n', '        );\n', '    }\n', '}\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', 'abstract contract ERC1271 {\n', '    // bytes4(keccak256("isValidSignature(bytes,bytes)")\n', '    bytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\n', '\n', '    bytes4 constant internal ERC1271_FUNCTION_WITH_BYTES_SELECTOR = bytes4(\n', '        keccak256(bytes("isValidSignature(bytes,bytes)"))\n', '    );\n', '\n', '    bytes4 constant internal ERC1271_FUNCTION_WITH_BYTES32_SELECTOR = bytes4(\n', '        keccak256(bytes("isValidSignature(bytes32,bytes)"))\n', '    );\n', '\n', '    /**\n', '     * @dev Should return whether the signature provided is valid for the provided data\n', '     * @param _data Arbitrary length data signed on the behalf of address(this)\n', '     * @param _signature Signature byte array associated with _data\n', '     *\n', '     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n', '     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n', '     * MUST allow external calls\n', '     */\n', '    function isValidSignature(\n', '        bytes memory _data,\n', '        bytes memory _signature)\n', '        public\n', '        view\n', '        virtual\n', '        returns (bytes4 magicValue);\n', '\n', '    function isValidSignature(\n', '        bytes32      _hash,\n', '        bytes memory _signature)\n', '        public\n', '        view\n', '        virtual\n', '        returns (bytes4 magicValue)\n', '    {\n', '        return isValidSignature(abi.encodePacked(_hash), _signature);\n', '    }\n', '}\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title BaseModule\n', '/// @dev This contract implements some common functions that are likely\n', '///      be useful for all modules.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'abstract contract BaseModule is ReentrancyGuard, Module\n', '{\n', '    using MathUint      for uint;\n', '    using AddressUtil   for address;\n', '\n', '    event Activated   (address wallet);\n', '    event Deactivated (address wallet);\n', '\n', '    function logicalSender()\n', '        internal\n', '        view\n', '        virtual\n', '        returns (address payable)\n', '    {\n', '        return msg.sender;\n', '    }\n', '\n', '    modifier onlyWalletOwner(address wallet, address addr)\n', '        virtual\n', '    {\n', '        require(Wallet(wallet).owner() == addr, "NOT_WALLET_OWNER");\n', '        _;\n', '    }\n', '\n', '    modifier notWalletOwner(address wallet, address addr)\n', '        virtual\n', '    {\n', '        require(Wallet(wallet).owner() != addr, "IS_WALLET_OWNER");\n', '        _;\n', '    }\n', '\n', '    modifier eligibleWalletOwner(address addr)\n', '    {\n', '        require(addr != address(0) && !addr.isContract(), "INVALID_OWNER");\n', '        _;\n', '    }\n', '\n', '    function controller()\n', '        internal\n', '        view\n', '        virtual\n', '        returns(ControllerImpl);\n', '\n', '    /// @dev This method will cause an re-entry to the same module contract.\n', '    function activate()\n', '        external\n', '        override\n', '        virtual\n', '    {\n', '        address wallet = logicalSender();\n', '        bindMethods(wallet);\n', '        emit Activated(wallet);\n', '    }\n', '\n', '    /// @dev This method will cause an re-entry to the same module contract.\n', '    function deactivate()\n', '        external\n', '        override\n', '        virtual\n', '    {\n', '        address wallet = logicalSender();\n', '        unbindMethods(wallet);\n', '        emit Deactivated(wallet);\n', '    }\n', '\n', '    ///.@dev Gets the list of methods for binding to wallets.\n', '    ///      Sub-contracts should override this method to provide methods for\n', '    ///      wallet binding.\n', '    /// @return methods A list of method selectors for binding to the wallet\n', '    ///         when this module is activated for the wallet.\n', '    function bindableMethods()\n', '        public\n', '        pure\n', '        virtual\n', '        returns (bytes4[] memory methods);\n', '\n', '    // ===== internal & private methods =====\n', '\n', '    /// @dev Binds all methods to the given wallet.\n', '    function bindMethods(address wallet)\n', '        internal\n', '    {\n', '        Wallet w = Wallet(wallet);\n', '        bytes4[] memory methods = bindableMethods();\n', '        for (uint i = 0; i < methods.length; i++) {\n', '            w.bindMethod(methods[i], address(this));\n', '        }\n', '    }\n', '\n', '    /// @dev Unbinds all methods from the given wallet.\n', '    function unbindMethods(address wallet)\n', '        internal\n', '    {\n', '        Wallet w = Wallet(wallet);\n', '        bytes4[] memory methods = bindableMethods();\n', '        for (uint i = 0; i < methods.length; i++) {\n', '            w.bindMethod(methods[i], address(0));\n', '        }\n', '    }\n', '\n', '    function transactCall(\n', '        address wallet,\n', '        address to,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bytes memory)\n', '    {\n', '        return Wallet(wallet).transact(uint8(1), to, value, data);\n', '    }\n', '\n', '    // Special case for transactCall to support transfers on "bad" ERC20 tokens\n', '    function transactTokenTransfer(\n', '        address wallet,\n', '        address token,\n', '        address to,\n', '        uint    amount\n', '        )\n', '        internal\n', '    {\n', '        if (token == address(0)) {\n', '            transactCall(wallet, to, amount, "");\n', '            return;\n', '        }\n', '\n', '        bytes memory txData = abi.encodeWithSelector(\n', '            ERC20.transfer.selector,\n', '            to,\n', '            amount\n', '        );\n', '        bytes memory returnData = transactCall(wallet, token, 0, txData);\n', '        // `transactCall` will revert if the call was unsuccessful.\n', '        // The only extra check we have to do is verify if the return value (if there is any) is correct.\n', '        bool success = returnData.length == 0 ? true :  abi.decode(returnData, (bool));\n', '        require(success, "ERC20_TRANSFER_FAILED");\n', '    }\n', '\n', '    // Special case for transactCall to support approvals on "bad" ERC20 tokens\n', '    function transactTokenApprove(\n', '        address wallet,\n', '        address token,\n', '        address spender,\n', '        uint    amount\n', '        )\n', '        internal\n', '    {\n', '        require(token != address(0), "INVALID_TOKEN");\n', '        bytes memory txData = abi.encodeWithSelector(\n', '            ERC20.approve.selector,\n', '            spender,\n', '            amount\n', '        );\n', '        bytes memory returnData = transactCall(wallet, token, 0, txData);\n', '        // `transactCall` will revert if the call was unsuccessful.\n', '        // The only extra check we have to do is verify if the return value (if there is any) is correct.\n', '        bool success = returnData.length == 0 ? true :  abi.decode(returnData, (bool));\n', '        require(success, "ERC20_APPROVE_FAILED");\n', '    }\n', '\n', '    function transactDelegateCall(\n', '        address wallet,\n', '        address to,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bytes memory)\n', '    {\n', '        return Wallet(wallet).transact(uint8(2), to, value, data);\n', '    }\n', '\n', '    function transactStaticCall(\n', '        address wallet,\n', '        address to,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bytes memory)\n', '    {\n', '        return Wallet(wallet).transact(uint8(3), to, 0, data);\n', '    }\n', '\n', '    function reimburseGasFee(\n', '        address     wallet,\n', '        address     recipient,\n', '        address     gasToken,\n', '        uint        gasPrice,\n', '        uint        gasAmount,\n', '        bool        skipQuota\n', '        )\n', '        internal\n', '    {\n', '        uint gasCost = gasAmount.mul(gasPrice);\n', '\n', '        if (!skipQuota) {\n', '            uint value = controller().priceOracle().tokenValue(gasToken, gasCost);\n', '            if (value > 0) {\n', '              controller().quotaStore().checkAndAddToSpent(wallet, value);\n', '            }\n', '        }\n', '\n', '        transactTokenTransfer(wallet, gasToken, recipient, gasCost);\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title ERC1271Module\n', '/// @dev This module enables our smart wallets to message signers.\n', '/// @author Brecht Devos - <brecht@loopring.org>\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'abstract contract ERC1271Module is ERC1271, BaseModule\n', '{\n', '    using SignatureUtil for bytes;\n', '    using SignatureUtil for bytes32;\n', '    using AddressUtil   for address;\n', '\n', '    function bindableMethodsForERC1271()\n', '        internal\n', '        pure\n', '        returns (bytes4[] memory methods)\n', '    {\n', '        methods = new bytes4[](2);\n', '        methods[0] = ERC1271_FUNCTION_WITH_BYTES_SELECTOR;\n', '        methods[1] = ERC1271_FUNCTION_WITH_BYTES32_SELECTOR;\n', '    }\n', '\n', '    // Will use msg.sender to detect the wallet, so this function should be called through\n', '    // the bounded method on the wallet itself, not directly on this module.\n', '    //\n', '    // Note that we allow chained wallet ownership:\n', '    // Wallet1 owned by Wallet2, Wallet2 owned by Wallet3, ..., WaleltN owned by an EOA.\n', "    // The verificaiton of Wallet1's signature will succeed if the final EOA's signature is\n", '    // valid.\n', '    function isValidSignature(\n', '        bytes memory _data,\n', '        bytes memory _signature\n', '        )\n', '        public\n', '        view\n', '        override\n', '        returns (bytes4)\n', '    {\n', '        address wallet = msg.sender;\n', '        (uint _lock,) = controller().securityStore().getLock(wallet);\n', '        if (_lock > block.timestamp) { // wallet locked\n', '            return 0;\n', '        }\n', '\n', '        if (_data.verifySignature(Wallet(wallet).owner(), _signature)) {\n', '            return ERC1271_MAGICVALUE;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title BaseWallet\n', '/// @dev This contract provides basic implementation for a Wallet.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'abstract contract BaseWallet is ReentrancyGuard, Wallet\n', '{\n', '    // WARNING: do not delete wallet state data to make this implementation\n', '    // compatible with early versions.\n', '    //\n', '    //  ----- DATA LAYOUT BEGINS -----\n', '    address internal _owner;\n', '\n', '    mapping (address => bool) private modules;\n', '\n', '    Controller public controller;\n', '\n', '    mapping (bytes4  => address) internal methodToModule;\n', '    //  ----- DATA LAYOUT ENDS -----\n', '\n', '    event OwnerChanged          (address newOwner);\n', '    event ControllerChanged     (address newController);\n', '    event ModuleAdded           (address module);\n', '    event ModuleRemoved         (address module);\n', '    event MethodBound           (bytes4  method, address module);\n', '    event WalletSetup           (address owner);\n', '\n', '    event Transacted(\n', '        address module,\n', '        address to,\n', '        uint    value,\n', '        bytes   data\n', '    );\n', '\n', '    modifier onlyFromModule\n', '    {\n', '        require(modules[msg.sender], "MODULE_UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    modifier onlyFromFactory\n', '    {\n', '        require(\n', '            msg.sender == controller.walletFactory(),\n', '            "UNAUTHORIZED"\n', '        );\n', '        _;\n', '    }\n', '\n', "    /// @dev We need to make sure the Factory address cannot be changed without wallet owner's\n", '    ///      explicit authorization.\n', '    modifier onlyFromFactoryOrModule\n', '    {\n', '        require(\n', '            modules[msg.sender] || msg.sender == controller.walletFactory(),\n', '            "UNAUTHORIZED"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @dev Set up this wallet by assigning an original owner\n', '    ///\n', '    ///      Note that calling this method more than once will throw.\n', '    ///\n', '    /// @param _initialOwner The owner of this wallet, must not be address(0).\n', '    function initOwner(\n', '        address _initialOwner\n', '        )\n', '        external\n', '        onlyFromFactory\n', '        nonReentrant\n', '    {\n', '        require(controller != Controller(0), "NO_CONTROLLER");\n', '        require(_owner == address(0), "INITIALIZED_ALREADY");\n', '        require(_initialOwner != address(0), "ZERO_ADDRESS");\n', '\n', '        _owner = _initialOwner;\n', '        emit WalletSetup(_initialOwner);\n', '    }\n', '\n', '    /// @dev Set up this wallet by assigning an controller.\n', '    ///\n', '    ///      Note that calling this method more than once will throw.\n', '    ///      And this method must be invoked before owner is initialized\n', '    ///\n', '    /// @param _controller The Controller instance.\n', '    function initController(\n', '        Controller _controller\n', '        )\n', '        external\n', '        nonReentrant\n', '    {\n', '        require(\n', '            _owner == address(0) &&\n', '            controller == Controller(0) &&\n', '            _controller != Controller(0),\n', '            "CONTROLLER_INIT_FAILED"\n', '        );\n', '\n', '        controller = _controller;\n', '    }\n', '\n', '    function owner()\n', '        override\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return _owner;\n', '    }\n', '\n', '    function setOwner(address newOwner)\n', '        external\n', '        override\n', '        nonReentrant\n', '        onlyFromModule\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        require(newOwner != address(this), "PROHIBITED");\n', '        require(newOwner != _owner, "SAME_ADDRESS");\n', '        _owner = newOwner;\n', '        emit OwnerChanged(newOwner);\n', '    }\n', '\n', '    function setController(Controller newController)\n', '        external\n', '        nonReentrant\n', '        onlyFromModule\n', '    {\n', '        require(newController != controller, "SAME_CONTROLLER");\n', '        require(newController != Controller(0), "INVALID_CONTROLLER");\n', '        controller = newController;\n', '        emit ControllerChanged(address(newController));\n', '    }\n', '\n', '    function addModule(address _module)\n', '        external\n', '        override\n', '        onlyFromFactoryOrModule\n', '    {\n', '        addModuleInternal(_module);\n', '    }\n', '\n', '    function removeModule(address _module)\n', '        external\n', '        override\n', '        onlyFromModule\n', '    {\n', '        // Allow deactivate to fail to make sure the module can be removed\n', '        require(modules[_module], "MODULE_NOT_EXISTS");\n', '        try Module(_module).deactivate() {} catch {}\n', '        delete modules[_module];\n', '        emit ModuleRemoved(_module);\n', '    }\n', '\n', '    function hasModule(address _module)\n', '        external\n', '        view\n', '        override\n', '        returns (bool)\n', '    {\n', '        return modules[_module];\n', '    }\n', '\n', '    function bindMethod(bytes4 _method, address _module)\n', '        external\n', '        override\n', '        onlyFromModule\n', '    {\n', '        require(_method != bytes4(0), "BAD_METHOD");\n', '        if (_module != address(0)) {\n', '            require(modules[_module], "MODULE_UNAUTHORIZED");\n', '        }\n', '\n', '        methodToModule[_method] = _module;\n', '        emit MethodBound(_method, _module);\n', '    }\n', '\n', '    function boundMethodModule(bytes4 _method)\n', '        external\n', '        view\n', '        override\n', '        returns (address)\n', '    {\n', '        return methodToModule[_method];\n', '    }\n', '\n', '    function transact(\n', '        uint8    mode,\n', '        address  to,\n', '        uint     value,\n', '        bytes    calldata data\n', '        )\n', '        external\n', '        override\n', '        onlyFromFactoryOrModule\n', '        returns (bytes memory returnData)\n', '    {\n', '        require(\n', '            !controller.moduleRegistry().isModuleRegistered(to),\n', '            "TRANSACT_ON_MODULE_DISALLOWED"\n', '        );\n', '\n', '        bool success;\n', '        (success, returnData) = nonReentrantCall(mode, to, value, data);\n', '\n', '        if (!success) {\n', '            assembly {\n', '                returndatacopy(0, 0, returndatasize())\n', '                revert(0, returndatasize())\n', '            }\n', '        }\n', '        emit Transacted(msg.sender, to, value, data);\n', '    }\n', '\n', '    function addModuleInternal(address _module)\n', '        internal\n', '    {\n', '        require(_module != address(0), "NULL_MODULE");\n', '        require(modules[_module] == false, "MODULE_EXISTS");\n', '        require(\n', '            controller.moduleRegistry().isModuleEnabled(_module),\n', '            "INVALID_MODULE"\n', '        );\n', '        modules[_module] = true;\n', '        emit ModuleAdded(_module);\n', '        Module(_module).activate();\n', '    }\n', '\n', '    receive()\n', '        external\n', '        payable\n', '    {\n', '    }\n', '\n', '    /// @dev This default function can receive Ether or perform queries to modules\n', '    ///      using bound methods.\n', '    fallback()\n', '        external\n', '        payable\n', '    {\n', '        address module = methodToModule[msg.sig];\n', '        require(modules[module], "MODULE_UNAUTHORIZED");\n', '\n', '        (bool success, bytes memory returnData) = module.call{value: msg.value}(msg.data);\n', '        assembly {\n', '            switch success\n', '            case 0 { revert(add(returnData, 32), mload(returnData)) }\n', '            default { return(add(returnData, 32), mload(returnData)) }\n', '        }\n', '    }\n', '\n', '    // This call is introduced to support reentrany check.\n', '    // The caller shall NOT have the nonReentrant modifier.\n', '    function nonReentrantCall(\n', '        uint8        mode,\n', '        address      target,\n', '        uint         value,\n', '        bytes memory data\n', '        )\n', '        private\n', '        nonReentrant\n', '        returns (\n', '            bool success,\n', '            bytes memory returnData\n', '        )\n', '    {\n', '        if (mode == 1) {\n', '            // solium-disable-next-line security/no-call-value\n', '            (success, returnData) = target.call{value: value}(data);\n', '        } else if (mode == 2) {\n', '            // solium-disable-next-line security/no-call-value\n', '            (success, returnData) = target.delegatecall(data);\n', '        } else if (mode == 3) {\n', '            require(value == 0, "INVALID_VALUE");\n', '            // solium-disable-next-line security/no-call-value\n', '            (success, returnData) = target.staticcall(data);\n', '        } else {\n', '            revert("UNSUPPORTED_MODE");\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '// This code is taken from https://github.com/OpenZeppelin/openzeppelin-labs\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Gives the possibility to delegate any call to a foreign implementation.\n', ' */\n', 'abstract contract Proxy {\n', '  /**\n', '  * @dev Tells the address of the implementation where every call will be delegated.\n', '  * @return address of the implementation to which it will be delegated\n', '  */\n', '  function implementation() public view virtual returns (address);\n', '\n', '  /**\n', '  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n', '  * This function will return whatever the implementation call returns\n', '  */\n', '  fallback() payable external {\n', '    address _impl = implementation();\n', '    require(_impl != address(0));\n', '\n', '    assembly {\n', '      let ptr := mload(0x40)\n', '      calldatacopy(ptr, 0, calldatasize())\n', '      let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n', '      let size := returndatasize()\n', '      returndatacopy(ptr, 0, size)\n', '\n', '      switch result\n', '      case 0 { revert(ptr, size) }\n', '      default { return(ptr, size) }\n', '    }\n', '  }\n', '\n', '  receive() payable external {}\n', '}\n', '\n', '\n', '\n', '/// @title SimpleProxy\n', '/// @author Daniel Wang  - <daniel@loopring.org>\n', 'contract SimpleProxy is Proxy\n', '{\n', '    bytes32 private constant implementationPosition = keccak256(\n', '        "org.loopring.protocol.simple.proxy"\n', '    );\n', '\n', '    function setImplementation(address _implementation)\n', '        public\n', '    {\n', '        address _impl = implementation();\n', '        require(_impl == address(0), "INITIALIZED_ALREADY");\n', '\n', '        bytes32 position = implementationPosition;\n', '        assembly {sstore(position, _implementation) }\n', '    }\n', '\n', '    function implementation()\n', '        public\n', '        override\n', '        view\n', '        returns (address)\n', '    {\n', '        address impl;\n', '        bytes32 position = implementationPosition;\n', '        assembly { impl := sload(position) }\n', '        return impl;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '// Taken from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/970f687f04d20e01138a3e8ccf9278b1d4b3997b/contracts/utils/Create2.sol\n', '\n', '\n', '\n', '/**\n', ' * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n', ' * `CREATE2` can be used to compute in advance the address where a smart\n', ' * contract will be deployed, which allows for interesting new mechanisms known\n', " * as 'counterfactual interactions'.\n", ' *\n', ' * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n', ' * information.\n', ' */\n', 'library Create2 {\n', '    /**\n', '     * @dev Deploys a contract using `CREATE2`. The address where the contract\n', '     * will be deployed can be known in advance via {computeAddress}. Note that\n', '     * a contract cannot be deployed twice using the same salt.\n', '     */\n', '    function deploy(bytes32 salt, bytes memory bytecode) internal returns (address payable) {\n', '        address payable addr;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n', '        }\n', '        require(addr != address(0), "CREATE2_FAILED");\n', '        return addr;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the `bytecode`\n', '     * or `salt` will result in a new destination address.\n', '     */\n', '    function computeAddress(bytes32 salt, bytes memory bytecode) internal view returns (address) {\n', '        return computeAddress(salt, bytecode, address(this));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n', "     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n", '     */\n', '    function computeAddress(bytes32 salt, bytes memory bytecodeHash, address deployer) internal pure returns (address) {\n', '        bytes32 bytecodeHashHash = keccak256(bytecodeHash);\n', '        bytes32 _data = keccak256(\n', '            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHashHash)\n', '        );\n', '        return address(bytes20(_data << 96));\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title WalletFactory\n', '/// @dev A factory contract to create a new wallet by deploying a proxy\n', '///      in front of a real wallet.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', '///\n', "/// The design of this contract is inspired by Argent's contract codebase:\n", '/// https://github.com/argentlabs/argent-contracts\n', 'contract WalletFactory is ReentrancyGuard\n', '{\n', '    using AddressUtil for address;\n', '    using SignatureUtil for bytes32;\n', '\n', '    event BlankDeployed (address blank,  bytes32 version);\n', '    event BlankConsumed (address blank);\n', '    event WalletCreated (address wallet, string ensLabel, address owner, bool blankUsed);\n', '\n', '    string constant public WALLET_CREATION = "WALLET_CREATION";\n', '\n', '    bytes32 public constant CREATE_WALLET_TYPEHASH = keccak256(\n', '        "createWallet(address owner,uint256 salt,string ensLabel,bytes ensApproval,bool ensRegisterReverse,address[] modules)"\n', '    );\n', '\n', '    mapping(address => bytes32) blanks;\n', '\n', '    address        public walletImplementation;\n', '    bool           public allowEmptyENS; // MUST be false in production\n', '    ControllerImpl public controller;\n', '    bytes32        public DOMAIN_SEPERATOR;\n', '\n', '    constructor(\n', '        ControllerImpl _controller,\n', '        address        _walletImplementation,\n', '        bool           _allowEmptyENS\n', '        )\n', '    {\n', '        DOMAIN_SEPERATOR = EIP712.hash(\n', '            EIP712.Domain("WalletFactory", "1.1.0", address(this))\n', '        );\n', '        controller = _controller;\n', '        walletImplementation = _walletImplementation;\n', '        allowEmptyENS = _allowEmptyENS;\n', '    }\n', '\n', '    /// @dev Create a set of new wallet blanks to be used in the future.\n', "    /// @param modules The wallet's modules.\n", '    /// @param salts The salts that can be used to generate nice addresses.\n', '    function createBlanks(\n', '        address[] calldata modules,\n', '        uint[]    calldata salts\n', '        )\n', '        external\n', '    {\n', '        for (uint i = 0; i < salts.length; i++) {\n', '            createBlank_(modules, salts[i]);\n', '        }\n', '    }\n', '\n', '    /// @dev Create a new wallet by deploying a proxy.\n', "    /// @param _owner The wallet's owner.\n", '    /// @param _salt A salt to adjust address.\n', '    /// @param _ensLabel The ENS subdomain to register, use "" to skip.\n', '    /// @param _ensApproval The signature for ENS subdomain approval.\n', '    /// @param _ensRegisterReverse True to register reverse ENS.\n', "    /// @param _modules The wallet's modules.\n", "    /// @param _signature The wallet owner's signature.\n", '    /// @return _wallet The new wallet address\n', '    function createWallet(\n', '        address            _owner,\n', '        uint               _salt,\n', '        string    calldata _ensLabel,\n', '        bytes     calldata _ensApproval,\n', '        bool               _ensRegisterReverse,\n', '        address[] calldata _modules,\n', '        bytes     calldata _signature\n', '        )\n', '        external\n', '        payable\n', '        returns (address _wallet)\n', '    {\n', '        validateRequest_(\n', '            _owner,\n', '            _salt,\n', '            _ensLabel,\n', '            _ensApproval,\n', '            _ensRegisterReverse,\n', '            _modules,\n', '            _signature\n', '        );\n', '\n', '        _wallet = createWallet_(_owner, _salt, _modules);\n', '\n', '        initializeWallet_(\n', '            _wallet,\n', '            _owner,\n', '            _ensLabel,\n', '            _ensApproval,\n', '            _ensRegisterReverse,\n', '            false\n', '        );\n', '    }\n', '\n', '    /// @dev Create a new wallet by using a pre-deployed blank.\n', "    /// @param _owner The wallet's owner.\n", '    /// @param _blank The address of the blank to use.\n', '    /// @param _ensLabel The ENS subdomain to register, use "" to skip.\n', '    /// @param _ensApproval The signature for ENS subdomain approval.\n', '    /// @param _ensRegisterReverse True to register reverse ENS.\n', "    /// @param _modules The wallet's modules.\n", "    /// @param _signature The wallet owner's signature.\n", '    /// @return _wallet The new wallet address\n', '    function createWallet2(\n', '        address            _owner,\n', '        address            _blank,\n', '        string    calldata _ensLabel,\n', '        bytes     calldata _ensApproval,\n', '        bool               _ensRegisterReverse,\n', '        address[] calldata _modules,\n', '        bytes     calldata _signature\n', '        )\n', '        external\n', '        payable\n', '        returns (address _wallet)\n', '    {\n', '        validateRequest_(\n', '            _owner,\n', '            uint(_blank),\n', '            _ensLabel,\n', '            _ensApproval,\n', '            _ensRegisterReverse,\n', '            _modules,\n', '            _signature\n', '        );\n', '\n', '        _wallet = consumeBlank_(_blank, _modules);\n', '\n', '        initializeWallet_(\n', '            _wallet,\n', '            _owner,\n', '            _ensLabel,\n', '            _ensApproval,\n', '            _ensRegisterReverse,\n', '            true\n', '        );\n', '    }\n', '\n', '    function registerENS(\n', '        address         _wallet,\n', '        address         _owner,\n', '        string calldata _ensLabel,\n', '        bytes  calldata _ensApproval,\n', '        bool            _ensRegisterReverse\n', '        )\n', '        external\n', '    {\n', '        registerENS_(_wallet, _owner, _ensLabel, _ensApproval, _ensRegisterReverse);\n', '    }\n', '\n', '    function computeWalletAddress(address owner, uint salt)\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return computeAddress_(owner, salt);\n', '    }\n', '\n', '    function computeBlankAddress(uint salt)\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return computeAddress_(address(0), salt);\n', '    }\n', '\n', '    // ---- internal functions ---\n', '\n', '    function consumeBlank_(\n', '        address blank,\n', '        address[] calldata modules\n', '        )\n', '        internal\n', '        returns (address)\n', '    {\n', '        bytes32 version = keccak256(abi.encode(modules));\n', '        require(blanks[blank] == version, "INVALID_ADOBE");\n', '        delete blanks[blank];\n', '        emit BlankConsumed(blank);\n', '        return blank;\n', '    }\n', '\n', '    function createBlank_(\n', '        address[] calldata modules,\n', '        uint      salt\n', '        )\n', '        internal\n', '        returns (address blank)\n', '    {\n', '        blank = deploy_(modules, address(0), salt);\n', '        bytes32 version = keccak256(abi.encode(modules));\n', '        blanks[blank] = version;\n', '\n', '        emit BlankDeployed(blank, version);\n', '    }\n', '\n', '    function createWallet_(\n', '        address   owner,\n', '        uint      salt,\n', '        address[] calldata modules\n', '        )\n', '        internal\n', '        returns (address wallet)\n', '    {\n', '        return deploy_(modules, owner, salt);\n', '    }\n', '\n', '    function deploy_(\n', '        address[] calldata modules,\n', '        address            owner,\n', '        uint               salt\n', '        )\n', '        internal\n', '        returns (address payable wallet)\n', '    {\n', '        wallet = Create2.deploy(\n', '            keccak256(abi.encodePacked(WALLET_CREATION, owner, salt)),\n', '            type(SimpleProxy).creationCode\n', '        );\n', '\n', '        SimpleProxy proxy = SimpleProxy(wallet);\n', '        proxy.setImplementation(walletImplementation);\n', '\n', '        BaseWallet w = BaseWallet(wallet);\n', '        w.initController(controller);\n', '        for (uint i = 0; i < modules.length; i++) {\n', '            w.addModule(modules[i]);\n', '        }\n', '    }\n', '\n', '    function validateRequest_(\n', '        address            _owner,\n', '        uint               _blankOrSalt,\n', '        string    memory   _ensLabel,\n', '        bytes     memory   _ensApproval,\n', '        bool               _ensRegisterReverse,\n', '        address[] memory   _modules,\n', '        bytes     memory   _signature\n', '        )\n', '        private\n', '        view\n', '    {\n', '        require(_owner != address(0) && !_owner.isContract(), "INVALID_OWNER");\n', '        require(_modules.length > 0, "EMPTY_MODULES");\n', '\n', '        bytes memory encodedRequest = abi.encode(\n', '            CREATE_WALLET_TYPEHASH,\n', '            _owner,\n', '            uint(_blankOrSalt),\n', '            keccak256(bytes(_ensLabel)),\n', '            keccak256(_ensApproval),\n', '            _ensRegisterReverse,\n', '            keccak256(abi.encode(_modules))\n', '        );\n', '\n', '        require(\n', '            EIP712.hashPacked(DOMAIN_SEPERATOR, encodedRequest)\n', '                .verifySignature(_owner, _signature),\n', '            "INVALID_SIGNATURE"\n', '        );\n', '    }\n', '\n', '    function initializeWallet_(\n', '        address       _wallet,\n', '        address       _owner,\n', '        string memory _ensLabel,\n', '        bytes  memory _ensApproval,\n', '        bool          _ensRegisterReverse,\n', '        bool          _blankUsed\n', '        )\n', '        private\n', '    {\n', '        BaseWallet(_wallet.toPayable()).initOwner(_owner);\n', '        controller.walletRegistry().registerWallet(_wallet);\n', '\n', '        if (bytes(_ensLabel).length > 0) {\n', '            registerENS_(_wallet, _owner, _ensLabel, _ensApproval, _ensRegisterReverse);\n', '        } else {\n', '            require(allowEmptyENS, "EMPTY_ENS_NOT_ALLOWED");\n', '        }\n', '\n', '        emit WalletCreated(_wallet, _ensLabel, _owner, _blankUsed);\n', '    }\n', '\n', '    function computeAddress_(\n', '        address owner,\n', '        uint    salt\n', '        )\n', '        internal\n', '        view\n', '        returns (address)\n', '    {\n', '        return Create2.computeAddress(\n', '            keccak256(abi.encodePacked(WALLET_CREATION, owner, salt)),\n', '            type(SimpleProxy).creationCode\n', '        );\n', '    }\n', '\n', '    function getCreationCode()\n', '        external\n', '        view\n', '        returns (bytes memory)\n', '    {\n', '        return type(SimpleProxy).creationCode;\n', '    }\n', '\n', '    function registerENS_(\n', '        address       wallet,\n', '        address       owner,\n', '        string memory ensLabel,\n', '        bytes  memory ensApproval,\n', '        bool          ensRegisterReverse\n', '        )\n', '        internal\n', '    {\n', '        require(\n', '            bytes(ensLabel).length > 0 &&\n', '            bytes(ensApproval).length > 0,\n', '            "INVALID_LABEL_OR_SIGNATURE"\n', '        );\n', '\n', '        BaseENSManager ensManager = controller.ensManager();\n', '        ensManager.register(wallet, owner, ensLabel, ensApproval);\n', '\n', '        if (ensRegisterReverse) {\n', '            bytes memory data = abi.encodeWithSelector(\n', '                ENSReverseRegistrar.claimWithResolver.selector,\n', '                address(0), // the owner of the reverse record\n', '                ensManager.ensResolver()\n', '            );\n', '\n', '            Wallet(wallet).transact(\n', '                uint8(1),\n', '                address(ensManager.getENSReverseRegistrar()),\n', '                0, // value\n', '                data\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/// @title ForwarderModule\n', '/// @dev A module to support wallet meta-transactions.\n', '///\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'abstract contract ForwarderModule is BaseModule\n', '{\n', '    using BytesUtil     for bytes;\n', '    using MathUint      for uint;\n', '    using SignatureUtil for bytes32;\n', '\n', '    uint    public constant GAS_OVERHEAD = 100000;\n', '    bytes32 public FORWARDER_DOMAIN_SEPARATOR;\n', '\n', '    event MetaTxExecuted(\n', '        address relayer,\n', '        address from,\n', '        uint    nonce,\n', '        bytes32 txAwareHash,\n', '        bool    success,\n', '        uint    gasUsed\n', '    );\n', '\n', '    struct MetaTx {\n', '        address from; // the wallet\n', '        address to;\n', '        uint    nonce;\n', '        bytes32 txAwareHash;\n', '        address gasToken;\n', '        uint    gasPrice;\n', '        uint    gasLimit;\n', '        bytes   data;\n', '    }\n', '\n', '    bytes32 constant public META_TX_TYPEHASH = keccak256(\n', '        "MetaTx(address from,address to,uint256 nonce,bytes32 txAwareHash,address gasToken,uint256 gasPrice,uint256 gasLimit,bytes data)"\n', '    );\n', '\n', '    function validateMetaTx(\n', '        address from, // the wallet\n', '        address to,\n', '        uint    nonce,\n', '        bytes32 txAwareHash,\n', '        address gasToken,\n', '        uint    gasPrice,\n', '        uint    gasLimit,\n', '        bytes   memory data,\n', '        bytes   memory signature\n', '        )\n', '        public\n', '        view\n', '    {\n', '        // Since this contract is a module, we need to prevent wallet from interacting with\n', "        // Stores via this module. Therefore, we must carefully check the 'to' address as follows,\n", "        // so no Store can be used as 'to'.\n", '        require(\n', '            (to != address(this)) &&\n', '            controller().moduleRegistry().isModuleRegistered(to) ||\n', '\n', '            // We only allow the wallet to call itself to addModule\n', '            (to == from) &&\n', '            data.toBytes4(0) == Wallet.addModule.selector &&\n', '            controller().walletRegistry().isWalletRegistered(from) ||\n', '\n', '            to == controller().walletFactory(),\n', '            "INVALID_DESTINATION_OR_METHOD"\n', '        );\n', '        require(\n', '            nonce == 0 && txAwareHash != 0 ||\n', '            nonce != 0 && txAwareHash == 0,\n', '            "INVALID_NONCE"\n', '        );\n', '\n', '        bytes memory data_ = txAwareHash == 0 ? data : data.slice(0, 4); // function selector\n', '\n', '        bytes memory encoded = abi.encode(\n', '            META_TX_TYPEHASH,\n', '            from,\n', '            to,\n', '            nonce,\n', '            txAwareHash,\n', '            gasToken,\n', '            gasPrice,\n', '            gasLimit,\n', '            keccak256(data_)\n', '        );\n', '\n', '        bytes32 metaTxHash = EIP712.hashPacked(FORWARDER_DOMAIN_SEPARATOR, encoded);\n', '        require(metaTxHash.verifySignature(from, signature), "INVALID_SIGNATURE");\n', '    }\n', '\n', '    function executeMetaTx(\n', '        MetaTx calldata metaTx,\n', '        bytes  calldata signature\n', '        )\n', '        external\n', '        nonReentrant\n', '        returns (\n', '            bool         success,\n', '            bytes memory ret\n', '        )\n', '    {\n', '        uint gasLeft = gasleft();\n', '        checkSufficientGas(metaTx);\n', '\n', '        // The trick is to append the really logical message sender and the\n', '        // transaction-aware hash to the end of the call data.\n', '        (success, ret) = metaTx.to.call{gas : metaTx.gasLimit, value : 0}(\n', '            abi.encodePacked(metaTx.data, metaTx.from, metaTx.txAwareHash)\n', '        );\n', '\n', "        // It's ok to do the validation after the 'call'. This is also necessary\n", '        // in the case of creating the wallet, otherwise, wallet signature validation\n', '        // will fail before the wallet is created.\n', '        validateMetaTx(\n', '            metaTx.from,\n', '            metaTx.to,\n', '            metaTx.nonce,\n', '            metaTx.txAwareHash,\n', '            metaTx.gasToken,\n', '            metaTx.gasPrice,\n', '            metaTx.gasLimit,\n', '            metaTx.data,\n', '            signature\n', '        );\n', '\n', '        // Nonce update must come after the real transaction in case of new wallet creation.\n', '        if (metaTx.nonce != 0) {\n', '            controller().nonceStore().verifyAndUpdate(metaTx.from, metaTx.nonce);\n', '        }\n', '\n', '        uint gasUsed = gasLeft - gasleft();\n', '\n', '        emit MetaTxExecuted(\n', '            msg.sender,\n', '            metaTx.from,\n', '            metaTx.nonce,\n', '            metaTx.txAwareHash,\n', '            success,\n', '            gasUsed\n', '        );\n', '\n', '        // Fees are not to be charged by a relayer if the transaction fails with a\n', "        // non-zero txAwareHash. The reason is that relayer can pick arbitrary 'data'\n", '        // to make the transaction fail. Charging fees for such failures can drain\n', '        // wallet funds.\n', '        if (metaTx.gasPrice > 0 && (metaTx.txAwareHash == 0 || success)) {\n', '            uint gasAmount = gasUsed < metaTx.gasLimit ? gasUsed : metaTx.gasLimit;\n', '\n', "            // Do not consume quota when call factory's createWallet function or\n", "            // when a successful meta-tx's txAwareHash is non-zero (which means it will\n", "            // be signed by at least a guardian). Therefor, even if the owner's\n", "            // private key is leaked, the hacker won't be able to deplete ether/tokens\n", '            // as high meta-tx fees.\n', '            bool skipQuota = success && (\n', '                metaTx.txAwareHash != 0 || (\n', '                    metaTx.data.toBytes4(0) == WalletFactory.createWallet.selector ||\n', '                    metaTx.data.toBytes4(0) == WalletFactory.createWallet2.selector) &&\n', '                metaTx.to == controller().walletFactory()\n', '            );\n', '\n', '            reimburseGasFee(\n', '                metaTx.from,\n', '                controller().collectTo(),\n', '                metaTx.gasToken,\n', '                metaTx.gasPrice,\n', '                gasAmount.add(GAS_OVERHEAD),\n', '                skipQuota\n', '            );\n', '        }\n', '    }\n', '\n', '    function checkSufficientGas(\n', '        MetaTx calldata metaTx\n', '        )\n', '        private\n', '        view\n', '    {\n', '        // Check the relayer has enough Ether gas\n', '        uint gasLimit = (metaTx.gasLimit.mul(64) / 63).add(GAS_OVERHEAD);\n', '        require(gasleft() >= gasLimit, "OPERATOR_INSUFFICIENT_GAS");\n', '\n', '        // Check the wallet has enough meta tx gas\n', '        if (metaTx.gasPrice  == 0) return;\n', '\n', '        uint gasCost = gasLimit.mul(metaTx.gasPrice);\n', '\n', '        if (metaTx.gasToken == address(0)) {\n', '            require(\n', '                metaTx.from.balance >= gasCost,\n', '                "WALLET_INSUFFICIENT_ETH_GAS"\n', '            );\n', '        } else {\n', '            require(\n', '                ERC20(metaTx.gasToken).balanceOf(metaTx.from) >= gasCost,\n', '                "WALLET_INSUFFICIENT_TOKEN_GAS"\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '/// @title FinalCoreModule\n', '/// @dev This module combines multiple small modules to\n', '///      minimize the number of modules to reduce gas used\n', '///      by wallet creation.\n', 'contract FinalCoreModule is\n', '    ERC1271Module,\n', '    ForwarderModule\n', '{\n', '    ControllerImpl private controller_;\n', '\n', '    constructor(ControllerImpl _controller)\n', '    {\n', '        FORWARDER_DOMAIN_SEPARATOR = EIP712.hash(\n', '            EIP712.Domain("ForwarderModule", "1.1.0", address(this))\n', '        );\n', '\n', '        controller_ = _controller;\n', '    }\n', '\n', '    function controller()\n', '        internal\n', '        view\n', '        override\n', '        returns(ControllerImpl)\n', '    {\n', '        return ControllerImpl(controller_);\n', '    }\n', '\n', '    function bindableMethods()\n', '        public\n', '        pure\n', '        override\n', '        returns (bytes4[] memory)\n', '    {\n', '        return bindableMethodsForERC1271();\n', '    }\n', '}']