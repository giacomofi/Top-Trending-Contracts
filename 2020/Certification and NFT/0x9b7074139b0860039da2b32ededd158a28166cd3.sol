['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IKeep3rV1 {\n', '    function isKeeper(address) external returns (bool);\n', '    function worked(address keeper) external;\n', '}\n', '\n', 'interface ISushiswapV2Factory {\n', '    function allPairsLength() external view returns (uint);\n', '    function allPairs(uint) external view returns (address pair);\n', '}\n', '\n', 'interface ISushiswapV2Pair {\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function balanceOf(address account) external view returns (uint);\n', '}\n', '\n', 'interface ISushiswapV2Maker {\n', '    function convert(address token0, address token1) external;\n', '}\n', '\n', 'contract SushiswapV2Keep3r {\n', '    \n', '    modifier upkeep() {\n', '        require(KP3R.isKeeper(msg.sender), "SushiswapV2Keep3r::isKeeper: keeper is not registered");\n', '        _;\n', '        KP3R.worked(msg.sender);\n', '    }\n', '    \n', '    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n', '    ISushiswapV2Factory public constant SV2F = ISushiswapV2Factory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\n', '    ISushiswapV2Maker public constant SV2M = ISushiswapV2Maker(0x6684977bBED67e101BB80Fc07fCcfba655c0a64F);\n', '    \n', '    function count() public view returns (uint) {\n', '        uint _count = 0;\n', '        for (uint i = 0; i < SV2F.allPairsLength(); i++) {\n', '            if (haveBalance(SV2F.allPairs(i))) {\n', '                _count++;\n', '            }\n', '        }\n', '        return _count;\n', '    }\n', '    \n', '    function workableAll(uint _count) external view returns (address[] memory) {\n', '        return (workable(_count, 0, SV2F.allPairsLength()));\n', '    }\n', '    \n', '    function workable(uint _count, uint start, uint end) public view returns (address[] memory) {\n', '        address[] memory _workable = new address[](_count);\n', '        uint index = 0;\n', '        for (uint i = start; i < end; i++) {\n', '            if (haveBalance(SV2F.allPairs(i))) {\n', '                _workable[index] = SV2F.allPairs(i);\n', '                index++;\n', '            }\n', '        }\n', '        return _workable;\n', '    }\n', '    \n', '    function haveBalance(address pair) public view returns (bool) {\n', '        return ISushiswapV2Pair(pair).balanceOf(address(SV2M)) > 0;\n', '    }\n', '    \n', '    function batch(ISushiswapV2Pair[] memory pair) external upkeep {\n', '        bool _worked = true;\n', '        for (uint i = 0; i < pair.length; i++) {\n', '            if (haveBalance(address(pair[i]))) {\n', '                SV2M.convert(pair[i].token0(), pair[i].token1());\n', '            } else {\n', '                _worked = false;\n', '            }\n', '        }\n', '        require(_worked, "SushiswapV2Keep3r::batch: job(s) failed");\n', '    }\n', '    \n', '    function work(ISushiswapV2Pair pair) external upkeep {\n', '        require(haveBalance(address(pair)), "SushiswapV2Keep3r::work: invalid pair");\n', '        SV2M.convert(pair.token0(), pair.token1());\n', '    }\n', '}']