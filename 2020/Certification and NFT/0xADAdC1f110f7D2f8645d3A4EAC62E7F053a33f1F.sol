['// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/spec_interfaces/ISubscriptions.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title Subscriptions contract interface\n', 'interface ISubscriptions {\n', '    event SubscriptionChanged(uint256 indexed vcId, address owner, string name, uint256 genRefTime, string tier, uint256 rate, uint256 expiresAt, bool isCertified, string deploymentSubset);\n', '    event Payment(uint256 indexed vcId, address by, uint256 amount, string tier, uint256 rate);\n', '    event VcConfigRecordChanged(uint256 indexed vcId, string key, string value);\n', '    event VcCreated(uint256 indexed vcId);\n', '    event VcOwnerChanged(uint256 indexed vcId, address previousOwner, address newOwner);\n', '\n', '    /*\n', '     *   External functions\n', '     */\n', '\n', '    /// Creates a new virtual chain\n', '    /// @dev Called only by: an authorized subscription plan contract\n', '    /// @dev the initial amount paid for the virtual chain must be large than minimumInitialVcPayment\n', '    /// @param name is the virtual chain name\n', '    /// @param tier is the virtual chain tier\n', '    /// @param rate is the virtual chain tier rate as determined by the subscription plan\n', '    /// @param amount is the amount paid for the virtual chain initial subscription\n', '    /// @param owner is the virtual chain owner. The owner may change virtual chain properties or ser config records\n', '    /// @param isCertified indicates the virtual is run by the certified committee\n', '    /// @param deploymentSubset indicates the code deployment subset the virtual chain uses such as main or canary\n', '    /// @return vcId is the virtual chain ID allocated to the new virtual chain\n', '    /// @return genRefTime is the virtual chain genesis reference time that determines the first block committee\n', '    function createVC(string calldata name, string calldata tier, uint256 rate, uint256 amount, address owner, bool isCertified, string calldata deploymentSubset) external returns (uint vcId, uint genRefTime);\n', '\n', '    /// Extends the subscription of an existing virtual chain.\n', '    /// @dev Called only by: an authorized subscription plan contract\n', '    /// @dev assumes that the msg.sender approved the amount prior to the call\n', '    /// @param vcId is the virtual chain ID\n', '    /// @param amount is the amount paid for the virtual chain subscription extension\n', '    /// @param tier is the virtual chain tier, must match the tier selected in the virtual creation\n', '    /// @param rate is the virtual chain tier rate as determined by the subscription plan\n', '    /// @param payer is the address paying for the subscription extension\n', '    function extendSubscription(uint256 vcId, uint256 amount, string calldata tier, uint256 rate, address payer) external;\n', '\n', '    /// Sets a virtual chain config record\n', '    /// @dev may be called only by the virtual chain owner\n', '    /// @param vcId is the virtual chain ID\n', '    /// @param key is the name of the config record to update\n', '    /// @param value is the config record value\n', '    function setVcConfigRecord(uint256 vcId, string calldata key, string calldata value) external /* onlyVcOwner */;\n', '\n', '    /// Returns the value of a virtual chain config record\n', '    /// @param vcId is the virtual chain ID\n', '    /// @param key is the name of the config record to query\n', '    /// @return value is the config record value\n', '    function getVcConfigRecord(uint256 vcId, string calldata key) external view returns (string memory);\n', '\n', '    /// Transfers a virtual chain ownership to a new owner \n', '    /// @dev may be called only by the current virtual chain owner\n', '    /// @param vcId is the virtual chain ID\n', '    /// @param owner is the address of the new owner\n', '    function setVcOwner(uint256 vcId, address owner) external /* onlyVcOwner */;\n', '\n', '    /// Returns the data of a virtual chain\n', '    /// @dev does not include config records data\n', '    /// @param vcId is the virtual chain ID\n', '    /// @return name is the virtual chain name\n', '    /// @return tier is the virtual chain tier\n', '    /// @return rate is the virtual chain tier rate\n', '    /// @return expiresAt the virtual chain subscription expiration time\n', '    /// @return genRefTime is the virtual chain genesis reference time\n', '    /// @return owner is the virtual chain owner. The owner may change virtual chain properties or ser config records\n', '    /// @return deploymentSubset indicates the code deployment subset the virtual chain uses such as main or canary\n', '    /// @return isCertified indicates the virtual is run by the certified committee\n', '    function getVcData(uint256 vcId) external view returns (\n', '        string memory name,\n', '        string memory tier,\n', '        uint256 rate,\n', '        uint expiresAt,\n', '        uint256 genRefTime,\n', '        address owner,\n', '        string memory deploymentSubset,\n', '        bool isCertified\n', '    );\n', '\n', '    /*\n', '     *   Governance functions\n', '     */\n', '\n', '    event SubscriberAdded(address subscriber);\n', '    event SubscriberRemoved(address subscriber);\n', '    event GenesisRefTimeDelayChanged(uint256 newGenesisRefTimeDelay);\n', '    event MinimumInitialVcPaymentChanged(uint256 newMinimumInitialVcPayment);\n', '\n', '    /// Adds a subscription plan contract to the authorized subscribers list\n', '    /// @dev governance function called only by the functional manager\n', '    /// @param addr is the address of the subscription plan contract\n', '    function addSubscriber(address addr) external /* onlyFunctionalManager */;\n', '\n', '    /// Removes a subscription plan contract to the authorized subscribers list\n', '    /// @dev governance function called only by the functional manager\n', '    /// @param addr is the address of the subscription plan contract\n', '    function removeSubscriber(address addr) external /* onlyFunctionalManager */;\n', '\n', '    /// Sets the delay between a virtual chain genesis reference time and the virtual chain creation time\n', '    /// @dev governance function called only by the functional manager\n', '    /// @dev the reference time delay allows the guardian to be ready with the virtual chain resources for the first block consensus\n', '    /// @param newGenesisRefTimeDelay is the delay time in seconds\n', '    function setGenesisRefTimeDelay(uint256 newGenesisRefTimeDelay) external /* onlyFunctionalManager */;\n', '\n', '    /// Returns the genesis reference time delay\n', '    /// @return genesisRefTimeDelay is the delay time in seconds\n', '    function getGenesisRefTimeDelay() external view returns (uint256);\n', '\n', '    /// Sets the minimum initial virtual chain payment \n', '    /// @dev Prevents abuse of the guardian nodes resources\n', '    /// @param newMinimumInitialVcPayment is the minimum payment required for the initial subscription\n', '    function setMinimumInitialVcPayment(uint256 newMinimumInitialVcPayment) external /* onlyFunctionalManager */;\n', '\n', '    /// Returns the minimum initial virtual chain payment \n', '    /// @return minimumInitialVcPayment is the minimum payment required for the initial subscription\n', '    function getMinimumInitialVcPayment() external view returns (uint256);\n', '\n', '    /// Returns the settings of this contract\n', '    /// @return genesisRefTimeDelay is the delay time in seconds\n', '    /// @return minimumInitialVcPayment is the minimum payment required for the initial subscription\n', '    function getSettings() external view returns(\n', '        uint genesisRefTimeDelay,\n', '        uint256 minimumInitialVcPayment\n', '    );\n', '\n', '    /// Imports virtual chain subscription from a previous subscriptions contract\n', '    /// @dev governance function called only by the initialization admin during migration\n', '    /// @dev if the migrated vcId is larger or equal to the next virtual chain ID to allocate, increment the next virtual chain ID\n', '    /// @param vcId is the virtual chain ID to migrate\n', '    /// @param previousSubscriptionsContract is the address of the previous subscription contract\n', '    function importSubscription(uint vcId, ISubscriptions previousSubscriptionsContract) external /* onlyInitializationAdmin */;\n', '\n', '}\n', '\n', '// File: contracts/spec_interfaces/IProtocol.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title Protocol upgrades contract interface\n', 'interface IProtocol {\n', '    event ProtocolVersionChanged(string deploymentSubset, uint256 currentVersion, uint256 nextVersion, uint256 fromTimestamp);\n', '\n', '    /*\n', '     *   External functions\n', '     */\n', '\n', '    /// Checks whether a deployment subset exists \n', '    /// @param deploymentSubset is the name of the deployment subset to query\n', '    /// @return exists is a bool indicating the deployment subset exists\n', '    function deploymentSubsetExists(string calldata deploymentSubset) external view returns (bool);\n', '\n', '    /// Returns the current protocol version for a given deployment subset to query\n', '    /// @dev an unexisting deployment subset returns protocol version 0\n', '    /// @param deploymentSubset is the name of the deployment subset\n', '    /// @return currentVersion is the current protocol version of the deployment subset\n', '    function getProtocolVersion(string calldata deploymentSubset) external view returns (uint256 currentVersion);\n', '\n', '    /*\n', '     *   Governance functions\n', '     */\n', '\n', '    /// Creates a new deployment subset\n', '    /// @dev governance function called only by the functional manager\n', '    /// @param deploymentSubset is the name of the new deployment subset\n', '    /// @param initialProtocolVersion is the initial protocol version of the deployment subset\n', '    function createDeploymentSubset(string calldata deploymentSubset, uint256 initialProtocolVersion) external /* onlyFunctionalManager */;\n', '\n', '\n', '    /// Schedules a protocol version upgrade for the given deployment subset\n', '    /// @dev governance function called only by the functional manager\n', '    /// @param deploymentSubset is the name of the deployment subset\n', '    /// @param nextVersion is the new protocol version to upgrade to, must be greater or equal to current version\n', '    /// @param fromTimestamp is the time the new protocol version takes effect, must be in the future\n', '    function setProtocolVersion(string calldata deploymentSubset, uint256 nextVersion, uint256 fromTimestamp) external /* onlyFunctionalManager */;\n', '}\n', '\n', '// File: contracts/spec_interfaces/IMigratableFeesWallet.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title An interface for Fee wallets that support bucket migration.\n', 'interface IMigratableFeesWallet {\n', '\n', '    /// Accepts a bucket fees from a old fees wallet as part of a migration\n', '    /// @dev Called by the old FeesWallet contract.\n', '    /// @dev Part of the IMigratableFeesWallet interface.\n', '    /// @dev assumes the caller approved the transfer of the amount prior to calling\n', "    /// @param bucketStartTime is the start time of the bucket to migration, must be a bucket's valid start time\n", '    /// @param amount is the amount to migrate (transfer) to the bucket\n', '    function acceptBucketMigration(uint256 bucketStartTime, uint256 amount) external;\n', '}\n', '\n', '// File: contracts/spec_interfaces/IFeesWallet.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/// @title Fees Wallet contract interface, manages the fee buckets\n', 'interface IFeesWallet {\n', '\n', '    event FeesWithdrawnFromBucket(uint256 bucketId, uint256 withdrawn, uint256 total);\n', '    event FeesAddedToBucket(uint256 bucketId, uint256 added, uint256 total);\n', '\n', '    /*\n', '     *   External methods\n', '     */\n', '\n', '    /// Top-ups the fee pool with the given amount at the given rate\n', '    /// @dev Called by: subscriptions contract. (not enforced)\n', '    /// @dev fills the rewards in 30 days buckets based on the monthlyRate\n', '    /// @param amount is the amount to fill\n', '    /// @param monthlyRate is the monthly rate\n', '    /// @param fromTimestamp is the to start fill the buckets, determines the first bucket to fill and the amount filled in the first bucket.\n', '    function fillFeeBuckets(uint256 amount, uint256 monthlyRate, uint256 fromTimestamp) external;\n', '\n', '    /// Collect fees from the buckets since the last call and transfers the amount back.\n', '    /// @dev Called by: only FeesAndBootstrapRewards contract\n', '    /// @dev The amount to collect may be queried before collect by calling getOutstandingFees\n', '    /// @return collectedFees the amount of fees collected and transferred\n', '    function collectFees() external returns (uint256 collectedFees) /* onlyRewardsContract */;\n', '\n', '    /// Returns the amount of fees that are currently available for withdrawal\n', '    /// @param currentTime is the time to check the pending fees for\n', '    /// @return outstandingFees is the amount of pending fees to collect at time currentTime\n', '    function getOutstandingFees(uint256 currentTime) external view returns (uint256 outstandingFees);\n', '\n', '    /*\n', '     * General governance\n', '     */\n', '\n', '    event EmergencyWithdrawal(address addr, address token);\n', '\n', '    /// Migrates the fees of a bucket starting at startTimestamp.\n', '    /// @dev governance function called only by the migration manager\n', '    /// @dev Calls acceptBucketMigration in the destination contract.\n', '    /// @param destination is the address of the new FeesWallet contract\n', "    /// @param bucketStartTime is the start time of the bucket to migration, must be a bucket's valid start time\n", '    function migrateBucket(IMigratableFeesWallet destination, uint256 bucketStartTime) external /* onlyMigrationManager */;\n', '\n', '    /// Accepts a fees bucket balance from a old fees wallet as part of the fees wallet migration\n', '    /// @dev Called by the old FeesWallet contract.\n', '    /// @dev Part of the IMigratableFeesWallet interface.\n', '    /// @dev assumes the caller approved the amount prior to calling\n', "    /// @param bucketStartTime is the start time of the bucket to migration, must be a bucket's valid start time\n", '    /// @param amount is the amount to migrate (transfer) to the bucket\n', '    function acceptBucketMigration(uint256 bucketStartTime, uint256 amount) external;\n', '\n', '    /// Emergency withdraw the contract funds\n', '    /// @dev governance function called only by the migration manager\n', '    /// @dev used in emergencies only, where migrateBucket is not a suitable solution\n', '    /// @param erc20 is the erc20 address of the token to withdraw\n', '    function emergencyWithdraw(address erc20) external /* onlyMigrationManager */;\n', '\n', '}\n', '\n', '// File: contracts/spec_interfaces/IManagedContract.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title managed contract interface, used by the contracts registry to notify the contract on updates\n', 'interface IManagedContract /* is ILockable, IContractRegistryAccessor, Initializable */ {\n', '\n', '    /// Refreshes the address of the other contracts the contract interacts with\n', '    /// @dev called by the registry contract upon an update of a contract in the registry\n', '    function refreshContracts() external;\n', '\n', '}\n', '\n', '// File: contracts/spec_interfaces/IContractRegistry.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title Contract registry contract interface\n', '/// @dev The contract registry holds Orbs PoS contracts and managers lists\n', '/// @dev The contract registry updates the managed contracts on changes in the contract list\n', '/// @dev Governance functions restricted to managers access the registry to retrieve the manager address \n', '/// @dev The contract registry represents the source of truth for Orbs Ethereum contracts \n', '/// @dev By tracking the registry events or query before interaction, one can access the up to date contracts \n', 'interface IContractRegistry {\n', '\n', '\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\n', '\tevent ManagerChanged(string role, address newManager);\n', '\tevent ContractRegistryUpdated(address newContractRegistry);\n', '\n', '\t/*\n', '\t* External functions\n', '\t*/\n', '\n', '    /// Updates the contracts address and emits a corresponding event\n', '    /// @dev governance function called only by the migrationManager or registryAdmin\n', '    /// @param contractName is the contract name, used to identify it\n', '    /// @param addr is the contract updated address\n', '    /// @param managedContract indicates whether the contract is managed by the registry and notified on changes\n', '\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdminOrMigrationManager */;\n', '\n', '    /// Returns the current address of the given contracts\n', '    /// @param contractName is the contract name, used to identify it\n', '    /// @return addr is the contract updated address\n', '\tfunction getContract(string calldata contractName) external view returns (address);\n', '\n', '    /// Returns the list of contract addresses managed by the registry\n', '    /// @dev Managed contracts are updated on changes in the registry contracts addresses \n', '    /// @return addrs is the list of managed contracts\n', '\tfunction getManagedContracts() external view returns (address[] memory);\n', '\n', '    /// Locks all the managed contracts \n', '    /// @dev governance function called only by the migrationManager or registryAdmin\n', '    /// @dev When set all onlyWhenActive functions will revert\n', '\tfunction lockContracts() external /* onlyAdminOrMigrationManager */;\n', '\n', '    /// Unlocks all the managed contracts \n', '    /// @dev governance function called only by the migrationManager or registryAdmin\n', '\tfunction unlockContracts() external /* onlyAdminOrMigrationManager */;\n', '\t\n', '    /// Updates a manager address and emits a corresponding event\n', '    /// @dev governance function called only by the registryAdmin\n', "    /// @dev the managers list is a flexible list of role to the manager's address\n", '    /// @param role is the managers\' role name, for example "functionalManager"\n', '    /// @param manager is the manager updated address\n', '\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\n', '\n', '    /// Returns the current address of the given manager\n', '    /// @param role is the manager name, used to identify it\n', '    /// @return addr is the manager updated address\n', '\tfunction getManager(string calldata role) external view returns (address);\n', '\n', '    /// Sets a new contract registry to migrate to\n', '    /// @dev governance function called only by the registryAdmin\n', '    /// @dev updates the registry address record in all the managed contracts\n', '    /// @dev by tracking the emitted ContractRegistryUpdated, tools can track the up to date contracts\n', '    /// @param newRegistry is the new registry contract \n', '\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\n', '\n', '    /// Returns the previous contract registry address \n', '    /// @dev used when the setting the contract as a new registry to assure a valid registry\n', '    /// @return previousContractRegistry is the previous contract registry\n', '\tfunction getPreviousContractRegistry() external view returns (address);\n', '}\n', '\n', '// File: contracts/spec_interfaces/IContractRegistryAccessor.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'interface IContractRegistryAccessor {\n', '\n', '    /// Sets the contract registry address\n', '    /// @dev governance function called only by an admin\n', '    /// @param newRegistry is the new registry contract \n', '    function setContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\n', '\n', '    /// Returns the contract registry address\n', '    /// @return contractRegistry is the contract registry address\n', '    function getContractRegistry() external view returns (IContractRegistry contractRegistry);\n', '\n', '    function setRegistryAdmin(address _registryAdmin) external /* onlyInitializationAdmin */;\n', '\n', '}\n', '\n', '// File: @openzeppelin/contracts/GSN/Context.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: contracts/WithClaimableRegistryManagement.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract WithClaimableRegistryManagement is Context {\n', '    address private _registryAdmin;\n', '    address private _pendingRegistryAdmin;\n', '\n', '    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _registryAdmin = msgSender;\n', '        emit RegistryManagementTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current registryAdmin.\n', '     */\n', '    function registryAdmin() public view returns (address) {\n', '        return _registryAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the registryAdmin.\n', '     */\n', '    modifier onlyRegistryAdmin() {\n', '        require(isRegistryAdmin(), "WithClaimableRegistryManagement: caller is not the registryAdmin");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current registryAdmin.\n', '     */\n', '    function isRegistryAdmin() public view returns (bool) {\n', '        return _msgSender() == _registryAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without registryAdmin. It will not be possible to call\n', '     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\n', '     *\n', '     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\n', '     * thereby removing any functionality that is only available to the registryAdmin.\n', '     */\n', '    function renounceRegistryManagement() public onlyRegistryAdmin {\n', '        emit RegistryManagementTransferred(_registryAdmin, address(0));\n', '        _registryAdmin = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\n', '     */\n', '    function _transferRegistryManagement(address newRegistryAdmin) internal {\n', '        require(newRegistryAdmin != address(0), "RegistryAdmin: new registryAdmin is the zero address");\n', '        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\n', '        _registryAdmin = newRegistryAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier throws if called by any account other than the pendingManager.\n', '     */\n', '    modifier onlyPendingRegistryAdmin() {\n', '        require(msg.sender == _pendingRegistryAdmin, "Caller is not the pending registryAdmin");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev Allows the current registryAdmin to set the pendingManager address.\n', '     * @param newRegistryAdmin The address to transfer registryManagement to.\n', '     */\n', '    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\n', '        _pendingRegistryAdmin = newRegistryAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\n', '     */\n', '    function claimRegistryManagement() external onlyPendingRegistryAdmin {\n', '        _transferRegistryManagement(_pendingRegistryAdmin);\n', '        _pendingRegistryAdmin = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current pendingRegistryAdmin\n', '    */\n', '    function pendingRegistryAdmin() public view returns (address) {\n', '       return _pendingRegistryAdmin;  \n', '    }\n', '}\n', '\n', '// File: contracts/Initializable.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'contract Initializable {\n', '\n', '    address private _initializationAdmin;\n', '\n', '    event InitializationComplete();\n', '\n', '    /// Constructor\n', '    /// Sets the initializationAdmin to the contract deployer\n', '    /// The initialization admin may call any manager only function until initializationComplete\n', '    constructor() public{\n', '        _initializationAdmin = msg.sender;\n', '    }\n', '\n', '    modifier onlyInitializationAdmin() {\n', '        require(msg.sender == initializationAdmin(), "sender is not the initialization admin");\n', '\n', '        _;\n', '    }\n', '\n', '    /*\n', '    * External functions\n', '    */\n', '\n', '    /// Returns the initializationAdmin address\n', '    function initializationAdmin() public view returns (address) {\n', '        return _initializationAdmin;\n', '    }\n', '\n', '    /// Finalizes the initialization and revokes the initializationAdmin role \n', '    function initializationComplete() external onlyInitializationAdmin {\n', '        _initializationAdmin = address(0);\n', '        emit InitializationComplete();\n', '    }\n', '\n', '    /// Checks if the initialization was completed\n', '    function isInitializationComplete() public view returns (bool) {\n', '        return _initializationAdmin == address(0);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/ContractRegistryAccessor.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', 'contract ContractRegistryAccessor is IContractRegistryAccessor, WithClaimableRegistryManagement, Initializable {\n', '\n', '    IContractRegistry private contractRegistry;\n', '\n', '    /// Constructor\n', '    /// @param _contractRegistry is the contract registry address\n', '    /// @param _registryAdmin is the registry admin address\n', '    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {\n', '        require(address(_contractRegistry) != address(0), "_contractRegistry cannot be 0");\n', '        setContractRegistry(_contractRegistry);\n', '        _transferRegistryManagement(_registryAdmin);\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(isAdmin(), "sender is not an admin (registryManger or initializationAdmin)");\n', '\n', '        _;\n', '    }\n', '\n', '    modifier onlyMigrationManager {\n', '        require(isMigrationManager(), "sender is not the migration manager");\n', '\n', '        _;\n', '    }\n', '\n', '    modifier onlyFunctionalManager {\n', '        require(isFunctionalManager(), "sender is not the functional manager");\n', '\n', '        _;\n', '    }\n', '\n', '    /// Checks whether the caller is Admin: either the contract registry, the registry admin, or the initialization admin\n', '    function isAdmin() internal view returns (bool) {\n', '        return msg.sender == address(contractRegistry) || msg.sender == registryAdmin() || msg.sender == initializationAdmin();\n', '    }\n', '\n', '    /// Checks whether the caller is a specific manager role or and Admin\n', '    /// @dev queries the registry contract for the up to date manager assignment\n', '    function isManager(string memory role) internal view returns (bool) {\n', '        IContractRegistry _contractRegistry = contractRegistry;\n', '        return isAdmin() || _contractRegistry != IContractRegistry(0) && contractRegistry.getManager(role) == msg.sender;\n', '    }\n', '\n', '    /// Checks whether the caller is the migration manager\n', '    function isMigrationManager() internal view returns (bool) {\n', "        return isManager('migrationManager');\n", '    }\n', '\n', '    /// Checks whether the caller is the functional manager\n', '    function isFunctionalManager() internal view returns (bool) {\n', "        return isManager('functionalManager');\n", '    }\n', '\n', '    /* \n', '     * Contract getters, return the address of a contract by calling the contract registry \n', '     */ \n', '\n', '    function getProtocolContract() internal view returns (address) {\n', '        return contractRegistry.getContract("protocol");\n', '    }\n', '\n', '    function getStakingRewardsContract() internal view returns (address) {\n', '        return contractRegistry.getContract("stakingRewards");\n', '    }\n', '\n', '    function getFeesAndBootstrapRewardsContract() internal view returns (address) {\n', '        return contractRegistry.getContract("feesAndBootstrapRewards");\n', '    }\n', '\n', '    function getCommitteeContract() internal view returns (address) {\n', '        return contractRegistry.getContract("committee");\n', '    }\n', '\n', '    function getElectionsContract() internal view returns (address) {\n', '        return contractRegistry.getContract("elections");\n', '    }\n', '\n', '    function getDelegationsContract() internal view returns (address) {\n', '        return contractRegistry.getContract("delegations");\n', '    }\n', '\n', '    function getGuardiansRegistrationContract() internal view returns (address) {\n', '        return contractRegistry.getContract("guardiansRegistration");\n', '    }\n', '\n', '    function getCertificationContract() internal view returns (address) {\n', '        return contractRegistry.getContract("certification");\n', '    }\n', '\n', '    function getStakingContract() internal view returns (address) {\n', '        return contractRegistry.getContract("staking");\n', '    }\n', '\n', '    function getSubscriptionsContract() internal view returns (address) {\n', '        return contractRegistry.getContract("subscriptions");\n', '    }\n', '\n', '    function getStakingRewardsWallet() internal view returns (address) {\n', '        return contractRegistry.getContract("stakingRewardsWallet");\n', '    }\n', '\n', '    function getBootstrapRewardsWallet() internal view returns (address) {\n', '        return contractRegistry.getContract("bootstrapRewardsWallet");\n', '    }\n', '\n', '    function getGeneralFeesWallet() internal view returns (address) {\n', '        return contractRegistry.getContract("generalFeesWallet");\n', '    }\n', '\n', '    function getCertifiedFeesWallet() internal view returns (address) {\n', '        return contractRegistry.getContract("certifiedFeesWallet");\n', '    }\n', '\n', '    function getStakingContractHandler() internal view returns (address) {\n', '        return contractRegistry.getContract("stakingContractHandler");\n', '    }\n', '\n', '    /*\n', '    * Governance functions\n', '    */\n', '\n', '    event ContractRegistryAddressUpdated(address addr);\n', '\n', '    /// Sets the contract registry address\n', '    /// @dev governance function called only by an admin\n', '    /// @param newContractRegistry is the new registry contract \n', '    function setContractRegistry(IContractRegistry newContractRegistry) public override onlyAdmin {\n', '        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), "new contract registry must provide the previous contract registry");\n', '        contractRegistry = newContractRegistry;\n', '        emit ContractRegistryAddressUpdated(address(newContractRegistry));\n', '    }\n', '\n', '    /// Returns the contract registry that the contract is set to use\n', '    /// @return contractRegistry is the registry contract address\n', '    function getContractRegistry() public override view returns (IContractRegistry) {\n', '        return contractRegistry;\n', '    }\n', '\n', '    function setRegistryAdmin(address _registryAdmin) external override onlyInitializationAdmin {\n', '        _transferRegistryManagement(_registryAdmin);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/spec_interfaces/ILockable.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title lockable contract interface, allows to lock a contract\n', 'interface ILockable {\n', '\n', '    event Locked();\n', '    event Unlocked();\n', '\n', '    /// Locks the contract to external non-governance function calls\n', '    /// @dev governance function called only by the migration manager or an admin\n', '    /// @dev typically called by the registry contract upon locking all managed contracts\n', '    /// @dev getters and migration functions remain active also for locked contracts\n', '    /// @dev checked by the onlyWhenActive modifier\n', '    function lock() external /* onlyMigrationManager */;\n', '\n', '    /// Unlocks the contract \n', '    /// @dev governance function called only by the migration manager or an admin\n', '    /// @dev typically called by the registry contract upon unlocking all managed contracts\n', '    function unlock() external /* onlyMigrationManager */;\n', '\n', '    /// Returns the contract locking status\n', '    /// @return isLocked is a bool indicating the contract is locked \n', '    function isLocked() view external returns (bool);\n', '\n', '}\n', '\n', '// File: contracts/Lockable.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '/// @title lockable contract\n', 'contract Lockable is ILockable, ContractRegistryAccessor {\n', '\n', '    bool public locked;\n', '\n', '    /// Constructor\n', '    /// @param _contractRegistry is the contract registry address\n', '    /// @param _registryAdmin is the registry admin address\n', '    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}\n', '\n', '    /// Locks the contract to external non-governance function calls\n', '    /// @dev governance function called only by the migration manager or an admin\n', '    /// @dev typically called by the registry contract upon locking all managed contracts\n', '    /// @dev getters and migration functions remain active also for locked contracts\n', '    /// @dev checked by the onlyWhenActive modifier\n', '    function lock() external override onlyMigrationManager {\n', '        locked = true;\n', '        emit Locked();\n', '    }\n', '\n', '    /// Unlocks the contract \n', '    /// @dev governance function called only by the migration manager or an admin\n', '    /// @dev typically called by the registry contract upon unlocking all managed contracts\n', '    function unlock() external override onlyMigrationManager {\n', '        locked = false;\n', '        emit Unlocked();\n', '    }\n', '\n', '    /// Returns the contract locking status\n', '    /// @return isLocked is a bool indicating the contract is locked \n', '    function isLocked() external override view returns (bool) {\n', '        return locked;\n', '    }\n', '\n', '    modifier onlyWhenActive() {\n', '        require(!locked, "contract is locked for this operation");\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/ManagedContract.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '/// @title managed contract\n', 'contract ManagedContract is IManagedContract, Lockable {\n', '\n', '    /// @param _contractRegistry is the contract registry address\n', '    /// @param _registryAdmin is the registry admin address\n', '    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}\n', '\n', '    /// Refreshes the address of the other contracts the contract interacts with\n', '    /// @dev called by the registry contract upon an update of a contract in the registry\n', '    function refreshContracts() virtual override external {}\n', '\n', '}\n', '\n', '// File: contracts/Subscriptions.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Subscriptions contract\n', 'contract Subscriptions is ISubscriptions, ManagedContract {\n', '    using SafeMath for uint256;\n', '\n', '    struct VirtualChain {\n', '        string name;\n', '        string tier;\n', '        uint256 rate;\n', '        uint expiresAt;\n', '        uint256 genRefTime;\n', '        address owner;\n', '        string deploymentSubset;\n', '        bool isCertified;\n', '    }\n', '\n', '    mapping(uint => mapping(string => string)) configRecords;\n', '    mapping(address => bool) public authorizedSubscribers;\n', '    mapping(uint => VirtualChain) virtualChains;\n', '\n', '    uint public nextVcId;\n', '\n', '    struct Settings {\n', '        uint genesisRefTimeDelay;\n', '        uint256 minimumInitialVcPayment;\n', '    }\n', '    Settings settings;\n', '\n', '    IERC20 public erc20;\n', '\n', '    /// Constructor\n', '    /// @dev the next allocated virtual chain id on createVC is the next ID after the maximum between the migrated virtual chains and the initialNextVcId\n', '    /// @param _contractRegistry is the contract registry address\n', '    /// @param _registryAdmin is the registry admin address\n', '    /// @param _erc20 is the token used for virtual chains fees\n', '    /// @param _genesisRefTimeDelay is the initial genesis virtual chain reference time delay from the creation time\n', '    /// @param _minimumInitialVcPayment is the minimum payment required for the initial subscription\n', '    /// @param vcIds is a list of virtual chain ids to migrate from the previous subscription contract\n', '    /// @param initialNextVcId is the initial virtual chain id\n', '    /// @param previousSubscriptionsContract is the previous subscription contract to migrate virtual chains from\n', '    constructor (IContractRegistry _contractRegistry, address _registryAdmin, IERC20 _erc20, uint256 _genesisRefTimeDelay, uint256 _minimumInitialVcPayment, uint[] memory vcIds, uint256 initialNextVcId, ISubscriptions previousSubscriptionsContract) ManagedContract(_contractRegistry, _registryAdmin) public {\n', '        require(address(_erc20) != address(0), "erc20 must not be 0");\n', '\n', '        erc20 = _erc20;\n', '        nextVcId = initialNextVcId;\n', '\n', '        setGenesisRefTimeDelay(_genesisRefTimeDelay);\n', '        setMinimumInitialVcPayment(_minimumInitialVcPayment);\n', '\n', '        for (uint i = 0; i < vcIds.length; i++) {\n', '            importSubscription(vcIds[i], previousSubscriptionsContract);\n', '        }\n', '    }\n', '\n', '    modifier onlySubscriber {\n', '        require(authorizedSubscribers[msg.sender], "sender must be an authorized subscriber");\n', '\n', '        _;\n', '    }\n', '\n', '    /*\n', '     *   External functions\n', '     */\n', '\n', '    /// Creates a new virtual chain\n', '    /// @dev Called only by: an authorized subscription plan contract\n', '    /// @dev the initial amount paid for the virtual chain must be large than minimumInitialVcPayment\n', '    /// @param name is the virtual chain name\n', '    /// @param tier is the virtual chain tier\n', '    /// @param rate is the virtual chain tier rate as determined by the subscription plan\n', '    /// @param amount is the amount paid for the virtual chain initial subscription\n', '    /// @param owner is the virtual chain owner. The owner may change virtual chain properties or ser config records\n', '    /// @param isCertified indicates the virtual is run by the certified committee\n', '    /// @param deploymentSubset indicates the code deployment subset the virtual chain uses such as main or canary\n', '    /// @return vcId is the virtual chain ID allocated to the new virtual chain\n', '    /// @return genRefTime is the virtual chain genesis reference time that determines the first block committee\n', '    function createVC(string calldata name, string calldata tier, uint256 rate, uint256 amount, address owner, bool isCertified, string calldata deploymentSubset) external override onlySubscriber onlyWhenActive returns (uint vcId, uint genRefTime) {\n', '        require(owner != address(0), "vc owner cannot be the zero address");\n', '        require(protocolContract.deploymentSubsetExists(deploymentSubset) == true, "No such deployment subset");\n', '        require(amount >= settings.minimumInitialVcPayment, "initial VC payment must be at least minimumInitialVcPayment");\n', '\n', '        vcId = nextVcId++;\n', '        genRefTime = now + settings.genesisRefTimeDelay;\n', '        VirtualChain memory vc = VirtualChain({\n', '            name: name,\n', '            expiresAt: block.timestamp,\n', '            genRefTime: genRefTime,\n', '            owner: owner,\n', '            tier: tier,\n', '            rate: rate,\n', '            deploymentSubset: deploymentSubset,\n', '            isCertified: isCertified\n', '            });\n', '        virtualChains[vcId] = vc;\n', '\n', '        emit VcCreated(vcId);\n', '\n', '        _extendSubscription(vcId, amount, tier, rate, owner);\n', '    }\n', '\n', '    /// Extends the subscription of an existing virtual chain.\n', '    /// @dev Called only by: an authorized subscription plan contract\n', '    /// @param vcId is the virtual chain ID\n', '    /// @param amount is the amount paid for the virtual chain subscription extension\n', '    /// @param tier is the virtual chain tier, must match the tier selected in the virtual creation\n', '    /// @param rate is the virtual chain tier rate as determined by the subscription plan\n', '    /// @param payer is the address paying for the subscription extension\n', '    function extendSubscription(uint256 vcId, uint256 amount, string calldata tier, uint256 rate, address payer) external override onlySubscriber onlyWhenActive {\n', '        _extendSubscription(vcId, amount, tier, rate, payer);\n', '    }\n', '\n', '    /// Sets a virtual chain config record\n', '    /// @dev may be called only by the virtual chain owner\n', '    /// @param vcId is the virtual chain ID\n', '    /// @param key is the name of the config record to update\n', '    /// @param value is the config record value\n', '    function setVcConfigRecord(uint256 vcId, string calldata key, string calldata value) external override onlyWhenActive {\n', '        require(msg.sender == virtualChains[vcId].owner, "only vc owner can set a vc config record");\n', '        configRecords[vcId][key] = value;\n', '        emit VcConfigRecordChanged(vcId, key, value);\n', '    }\n', '\n', '    /// Returns the value of a virtual chain config record\n', '    /// @param vcId is the virtual chain ID\n', '    /// @param key is the name of the config record to query\n', '    /// @return value is the config record value\n', '    function getVcConfigRecord(uint256 vcId, string calldata key) external override view returns (string memory) {\n', '        return configRecords[vcId][key];\n', '    }\n', '\n', '    /// Transfers a virtual chain ownership to a new owner\n', '    /// @dev may be called only by the current virtual chain owner\n', '    /// @param vcId is the virtual chain ID\n', '    /// @param owner is the address of the new owner\n', '    function setVcOwner(uint256 vcId, address owner) external override onlyWhenActive {\n', '        require(msg.sender == virtualChains[vcId].owner, "only the vc owner can transfer ownership");\n', '        require(owner != address(0), "cannot transfer ownership to the zero address");\n', '\n', '        virtualChains[vcId].owner = owner;\n', '        emit VcOwnerChanged(vcId, msg.sender, owner);\n', '    }\n', '\n', '    /// Returns the data of a virtual chain\n', '    /// @dev does not include config records data\n', '    /// @param vcId is the virtual chain ID\n', '    /// @return name is the virtual chain name\n', '    /// @return tier is the virtual chain tier\n', '    /// @return rate is the virtual chain tier rate\n', '    /// @return expiresAt the virtual chain subscription expiration time\n', '    /// @return genRefTime is the virtual chain genesis reference time\n', '    /// @return owner is the virtual chain owner. The owner may change virtual chain properties or ser config records\n', '    /// @return deploymentSubset indicates the code deployment subset the virtual chain uses such as main or canary\n', '    /// @return isCertified indicates the virtual is run by the certified committee\n', '    function getVcData(uint256 vcId) external override view returns (\n', '        string memory name,\n', '        string memory tier,\n', '        uint256 rate,\n', '        uint expiresAt,\n', '        uint256 genRefTime,\n', '        address owner,\n', '        string memory deploymentSubset,\n', '        bool isCertified\n', '    ) {\n', '        VirtualChain memory vc = virtualChains[vcId];\n', '        name = vc.name;\n', '        tier = vc.tier;\n', '        rate = vc.rate;\n', '        expiresAt = vc.expiresAt;\n', '        genRefTime = vc.genRefTime;\n', '        owner = vc.owner;\n', '        deploymentSubset = vc.deploymentSubset;\n', '        isCertified = vc.isCertified;\n', '    }\n', '\n', '    /*\n', '     *   Governance functions\n', '     */\n', '\n', '    /// Adds a subscription plan contract to the authorized subscribers list\n', '    /// @dev governance function called only by the functional manager\n', '    /// @param addr is the address of the subscription plan contract\n', '    function addSubscriber(address addr) external override onlyFunctionalManager {\n', '        authorizedSubscribers[addr] = true;\n', '        emit SubscriberAdded(addr);\n', '    }\n', '\n', '    /// Removes a subscription plan contract to the authorized subscribers list\n', '    /// @dev governance function called only by the functional manager\n', '    /// @param addr is the address of the subscription plan contract\n', '    function removeSubscriber(address addr) external override onlyFunctionalManager {\n', '        require(authorizedSubscribers[addr], "given add is not an authorized subscriber");\n', '\n', '        authorizedSubscribers[addr] = false;\n', '        emit SubscriberRemoved(addr);\n', '    }\n', '\n', '    /// Sets the delay between a virtual chain genesis reference time and the virtual chain creation time\n', '    /// @dev governance function called only by the functional manager\n', '    /// @dev the reference time delay allows the guardian to be ready with the virtual chain resources for the first block consensus\n', '    /// @param newGenesisRefTimeDelay is the delay time in seconds\n', '    function setGenesisRefTimeDelay(uint256 newGenesisRefTimeDelay) public override onlyFunctionalManager {\n', '        settings.genesisRefTimeDelay = newGenesisRefTimeDelay;\n', '        emit GenesisRefTimeDelayChanged(newGenesisRefTimeDelay);\n', '    }\n', '\n', '    /// Returns the genesis reference time delay\n', '    /// @return genesisRefTimeDelay is the delay time in seconds\n', '    function getGenesisRefTimeDelay() external override view returns (uint) {\n', '        return settings.genesisRefTimeDelay;\n', '    }\n', '\n', '    /// Sets the minimum initial virtual chain payment\n', '    /// @dev Prevents abuse of the guardian nodes resources\n', '    /// @param newMinimumInitialVcPayment is the minimum payment required for the initial subscription\n', '    function setMinimumInitialVcPayment(uint256 newMinimumInitialVcPayment) public override onlyFunctionalManager {\n', '        settings.minimumInitialVcPayment = newMinimumInitialVcPayment;\n', '        emit MinimumInitialVcPaymentChanged(newMinimumInitialVcPayment);\n', '    }\n', '\n', '    /// Returns the minimum initial virtual chain payment\n', '    /// @return minimumInitialVcPayment is the minimum payment required for the initial subscription\n', '    function getMinimumInitialVcPayment() external override view returns (uint) {\n', '        return settings.minimumInitialVcPayment;\n', '    }\n', '\n', '    /// Returns the settings of this contract\n', '    /// @return genesisRefTimeDelay is the delay time in seconds\n', '    /// @return minimumInitialVcPayment is the minimum payment required for the initial subscription\n', '    function getSettings() external override view returns(\n', '        uint genesisRefTimeDelay,\n', '        uint256 minimumInitialVcPayment\n', '    ) {\n', '        Settings memory _settings = settings;\n', '        genesisRefTimeDelay = _settings.genesisRefTimeDelay;\n', '        minimumInitialVcPayment = _settings.minimumInitialVcPayment;\n', '    }\n', '\n', '    /// Imports virtual chain subscription from a previous subscriptions contract\n', '    /// @dev governance function called only by the initialization admin during migration\n', '    /// @dev if the migrated vcId is larger or equal to the next virtual chain ID to allocate, increment the next virtual chain ID\n', '    /// @param vcId is the virtual chain ID to migrate\n', '    /// @param previousSubscriptionsContract is the address of the previous subscription contract\n', '    function importSubscription(uint vcId, ISubscriptions previousSubscriptionsContract) public override onlyInitializationAdmin {\n', '        require(virtualChains[vcId].owner == address(0), "the vcId already exists");\n', '\n', '        (string memory name,\n', '        string memory tier,\n', '        uint256 rate,\n', '        uint expiresAt,\n', '        uint256 genRefTime,\n', '        address owner,\n', '        string memory deploymentSubset,\n', '        bool isCertified) = previousSubscriptionsContract.getVcData(vcId);\n', '\n', '        virtualChains[vcId] = VirtualChain({\n', '            name: name,\n', '            tier: tier,\n', '            rate: rate,\n', '            expiresAt: expiresAt,\n', '            genRefTime: genRefTime,\n', '            owner: owner,\n', '            deploymentSubset: deploymentSubset,\n', '            isCertified: isCertified\n', '            });\n', '\n', '        if (vcId >= nextVcId) {\n', '            nextVcId = vcId + 1;\n', '        }\n', '\n', '        emit SubscriptionChanged(vcId, owner, name, genRefTime, tier, rate, expiresAt, isCertified, deploymentSubset);\n', '    }\n', '\n', '    /*\n', '    * Private functions\n', '    */\n', '\n', '    /// Extends the subscription of an existing virtual chain.\n', '    /// @dev used by createVC and extendSubscription functions for subscription payment\n', '    /// @dev assumes that the msg.sender approved the amount prior to the call\n', '    /// @param vcId is the virtual chain ID\n', '    /// @param amount is the amount paid for the virtual chain subscription extension\n', '    /// @param tier is the virtual chain tier, must match the tier selected in the virtual creation\n', '    /// @param rate is the virtual chain tier rate as determined by the subscription plan\n', '    /// @param payer is the address paying for the subscription extension\n', '    function _extendSubscription(uint256 vcId, uint256 amount, string memory tier, uint256 rate, address payer) private {\n', '        VirtualChain memory vc = virtualChains[vcId];\n', '        require(vc.genRefTime != 0, "vc does not exist");\n', '        require(keccak256(bytes(tier)) == keccak256(bytes(virtualChains[vcId].tier)), "given tier must match the VC tier");\n', '\n', '        IFeesWallet feesWallet = vc.isCertified ? certifiedFeesWallet : generalFeesWallet;\n', '        require(erc20.transferFrom(msg.sender, address(this), amount), "failed to transfer subscription fees from subscriber to subscriptions");\n', '        require(erc20.approve(address(feesWallet), amount), "failed to approve rewards to acquire subscription fees");\n', '\n', '        uint fromTimestamp = vc.expiresAt > now ? vc.expiresAt : now;\n', '        feesWallet.fillFeeBuckets(amount, rate, fromTimestamp);\n', '\n', '        vc.expiresAt = fromTimestamp.add(amount.mul(30 days).div(rate));\n', '        vc.rate = rate;\n', '\n', '        // commit new expiration timestamp to storage\n', '        virtualChains[vcId].expiresAt = vc.expiresAt;\n', '        virtualChains[vcId].rate = vc.rate;\n', '\n', '        emit SubscriptionChanged(vcId, vc.owner, vc.name, vc.genRefTime, vc.tier, vc.rate, vc.expiresAt, vc.isCertified, vc.deploymentSubset);\n', '        emit Payment(vcId, payer, amount, vc.tier, vc.rate);\n', '    }\n', '\n', '    /*\n', '     * Contracts topology / registry interface\n', '     */\n', '\n', '    IFeesWallet generalFeesWallet;\n', '    IFeesWallet certifiedFeesWallet;\n', '    IProtocol protocolContract;\n', '\n', '    /// Refreshes the address of the other contracts the contract interacts with\n', '    /// @dev called by the registry contract upon an update of a contract in the registry\n', '    function refreshContracts() external override {\n', '        generalFeesWallet = IFeesWallet(getGeneralFeesWallet());\n', '        certifiedFeesWallet = IFeesWallet(getCertifiedFeesWallet());\n', '        protocolContract = IProtocol(getProtocolContract());\n', '    }\n', '}\n', '\n', '// File: contracts/ContractRegistry.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Contract registry\n', '/// @dev The contract registry holds Orbs PoS contracts and managers lists\n', '/// @dev The contract registry updates the managed contracts on changes in the contract list\n', '/// @dev Governance functions restricted to managers access the registry to retrieve the manager address \n', '/// @dev The contract registry represents the source of truth for Orbs Ethereum contracts \n', '/// @dev By tracking the registry events or query before interaction, one can access the up to date contracts \n', 'contract ContractRegistry is IContractRegistry, Initializable, WithClaimableRegistryManagement {\n', '\n', '\taddress previousContractRegistry;\n', '\tmapping(string => address) contracts;\n', '\taddress[] managedContractAddresses;\n', '\tmapping(string => address) managers;\n', '\n', '    /// Constructor\n', '    /// @param _previousContractRegistry is the previous contract registry address\n', '    /// @param registryAdmin is the registry contract admin address\n', '\tconstructor(address _previousContractRegistry, address registryAdmin) public {\n', '\t\tpreviousContractRegistry = _previousContractRegistry;\n', '\t\t_transferRegistryManagement(registryAdmin);\n', '\t}\n', '\n', '\tmodifier onlyAdmin {\n', '\t\trequire(msg.sender == registryAdmin() || msg.sender == initializationAdmin(), "sender is not an admin (registryAdmin or initializationAdmin when initialization in progress)");\n', '\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyAdminOrMigrationManager {\n', '\t\trequire(msg.sender == registryAdmin() || msg.sender == initializationAdmin() || msg.sender == managers["migrationManager"], "sender is not an admin (registryAdmin or initializationAdmin when initialization in progress) and not the migration manager");\n', '\n', '\t\t_;\n', '\t}\n', '\n', '\t/*\n', '\t* External functions\n', '\t*/\n', '\n', '    /// Updates the contracts address and emits a corresponding event\n', '    /// @dev governance function called only by the migrationManager or registryAdmin\n', '    /// @param contractName is the contract name, used to identify it\n', '    /// @param addr is the contract updated address\n', '    /// @param managedContract indicates whether the contract is managed by the registry and notified on changes\n', '\tfunction setContract(string calldata contractName, address addr, bool managedContract) external override onlyAdminOrMigrationManager {\n', '\t\trequire(!managedContract || addr != address(0), "managed contract may not have address(0)");\n', '\t\tremoveManagedContract(contracts[contractName]);\n', '\t\tcontracts[contractName] = addr;\n', '\t\tif (managedContract) {\n', '\t\t\taddManagedContract(addr);\n', '\t\t}\n', '\t\temit ContractAddressUpdated(contractName, addr, managedContract);\n', '\t\tnotifyOnContractsChange();\n', '\t}\n', '\n', '    /// Returns the current address of the given contracts\n', '    /// @param contractName is the contract name, used to identify it\n', '    /// @return addr is the contract updated address\n', '\tfunction getContract(string calldata contractName) external override view returns (address) {\n', '\t\treturn contracts[contractName];\n', '\t}\n', '\n', '    /// Returns the list of contract addresses managed by the registry\n', '    /// @dev Managed contracts are updated on changes in the registry contracts addresses \n', '    /// @return addrs is the list of managed contracts\n', '\tfunction getManagedContracts() external override view returns (address[] memory) {\n', '\t\treturn managedContractAddresses;\n', '\t}\n', '\n', '    /// Locks all the managed contracts \n', '    /// @dev governance function called only by the migrationManager or registryAdmin\n', '    /// @dev When set all onlyWhenActive functions will revert\n', '\tfunction lockContracts() external override onlyAdminOrMigrationManager {\n', '\t\tfor (uint i = 0; i < managedContractAddresses.length; i++) {\n', '\t\t\tILockable(managedContractAddresses[i]).lock();\n', '\t\t}\n', '\t}\n', '\n', '    /// Unlocks all the managed contracts \n', '    /// @dev governance function called only by the migrationManager or registryAdmin\n', '\tfunction unlockContracts() external override onlyAdminOrMigrationManager {\n', '\t\tfor (uint i = 0; i < managedContractAddresses.length; i++) {\n', '\t\t\tILockable(managedContractAddresses[i]).unlock();\n', '\t\t}\n', '\t}\n', '\n', '    /// Updates a manager address and emits a corresponding event\n', '    /// @dev governance function called only by the registryAdmin\n', "    /// @dev the managers list is a flexible list of role to the manager's address\n", '    /// @param role is the managers\' role name, for example "functionalManager"\n', '    /// @param manager is the manager updated address\n', '\tfunction setManager(string calldata role, address manager) external override onlyAdmin {\n', '\t\tmanagers[role] = manager;\n', '\t\temit ManagerChanged(role, manager);\n', '\t}\n', '\n', '    /// Returns the current address of the given manager\n', '    /// @param role is the manager name, used to identify it\n', '    /// @return addr is the manager updated address\n', '\tfunction getManager(string calldata role) external override view returns (address) {\n', '\t\treturn managers[role];\n', '\t}\n', '\n', '    /// Sets a new contract registry to migrate to\n', '    /// @dev governance function called only by the registryAdmin\n', '    /// @dev updates the registry address record in all the managed contracts\n', '    /// @dev by tracking the emitted ContractRegistryUpdated, tools can track the up to date contracts\n', '    /// @param newRegistry is the new registry contract \n', '\tfunction setNewContractRegistry(IContractRegistry newRegistry) external override onlyAdmin {\n', '\t\tfor (uint i = 0; i < managedContractAddresses.length; i++) {\n', '\t\t\tIContractRegistryAccessor(managedContractAddresses[i]).setContractRegistry(newRegistry);\n', '\t\t\tIManagedContract(managedContractAddresses[i]).refreshContracts();\n', '\t\t}\n', '\t\temit ContractRegistryUpdated(address(newRegistry));\n', '\t}\n', '\n', '    /// Returns the previous contract registry address \n', '    /// @dev used when the setting the contract as a new registry to assure a valid registry\n', '    /// @return previousContractRegistry is the previous contract registry\n', '\tfunction getPreviousContractRegistry() external override view returns (address) {\n', '\t\treturn previousContractRegistry;\n', '\t}\n', '\n', '\t/*\n', '\t* Private methods\n', '\t*/\n', '\n', '    /// Notifies the managed contracts on a change in a contract address\n', '    /// @dev invokes the refreshContracts() function in each contract that queries the relevant contract addresses\n', '\tfunction notifyOnContractsChange() private {\n', '\t\tfor (uint i = 0; i < managedContractAddresses.length; i++) {\n', '\t\t\tIManagedContract(managedContractAddresses[i]).refreshContracts();\n', '\t\t}\n', '\t}\n', '\n', '    /// Adds a new managed contract address to the managed contracts list\n', '\tfunction addManagedContract(address addr) private {\n', '\t\tmanagedContractAddresses.push(addr);\n', '\t}\n', '\n', '    /// Removes a managed contract address from the managed contracts list\n', '\tfunction removeManagedContract(address addr) private {\n', '\t\tuint length = managedContractAddresses.length;\n', '\t\tfor (uint i = 0; i < length; i++) {\n', '\t\t\tif (managedContractAddresses[i] == addr) {\n', '\t\t\t\tif (i != length - 1) {\n', '\t\t\t\t\tmanagedContractAddresses[i] = managedContractAddresses[length-1];\n', '\t\t\t\t}\n', '\t\t\t\tmanagedContractAddresses.pop();\n', '\t\t\t\tlength--;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '}\n', '\n', '// File: contracts/MonthlySubscriptionPlan.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '/// @title monthly subscription plan contract\n', 'contract MonthlySubscriptionPlan is ContractRegistryAccessor {\n', '\n', '    string public tier;\n', '    uint256 public monthlyRate;\n', '\n', '    IERC20 public erc20;\n', '\n', '    /// Constructor\n', '    /// @param _contractRegistry is the contract registry address\n', '    /// @param _registryAdmin is the registry admin address\n', '    /// @param _erc20 is the token used for virtual chains fees\n', '    /// @param _tier is the virtual chain tier for the monthly subscription plan\n', '    /// @param _monthlyRate is the virtual chain tier rate\n', '    constructor(IContractRegistry _contractRegistry, address _registryAdmin, IERC20 _erc20, string memory _tier, uint256 _monthlyRate) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {\n', '        require(bytes(_tier).length > 0, "must specify a valid tier label");\n', '\n', '        tier = _tier;\n', '        erc20 = _erc20;\n', '        monthlyRate = _monthlyRate;\n', '    }\n', '\n', '    /*\n', '     *   External functions\n', '     */\n', '\n', '    /// Creates a new virtual chain\n', '    /// @dev the virtual chain tier and rate are determined by the contract\n', '    /// @dev the contract calls the subscription contract that stores the virtual chain data and allocates a virtual chain ID\n', '    /// @dev the msg.sender that created the virtual chain is set as the initial virtual chain owner\n', '    /// @dev the initial amount paid for the virtual chain must be large than minimumInitialVcPayment\n', '    /// @param name is the virtual chain name\n', '    /// @param amount is the amount paid for the virtual chain initial subscription\n', '    /// @param isCertified indicates the virtual is run by the certified committee\n', '    /// @param deploymentSubset indicates the code deployment subset the virtual chain uses such as main or canary  \n', '    function createVC(string calldata name, uint256 amount, bool isCertified, string calldata deploymentSubset) external {\n', '        require(amount > 0, "must include funds");\n', '\n', '        ISubscriptions subs = ISubscriptions(getSubscriptionsContract());\n', '        require(erc20.transferFrom(msg.sender, address(this), amount), "failed to transfer subscription fees");\n', '        require(erc20.approve(address(subs), amount), "failed to transfer subscription fees");\n', '        subs.createVC(name, tier, monthlyRate, amount, msg.sender, isCertified, deploymentSubset);\n', '    }\n', '\n', '    /// Extends the subscription of an existing virtual chain.\n', '    /// @dev may be called by anyone, not only the virtual chain owner\n', '    /// @dev assumes that the amount has been approved by the msg.sender prior to calling the function \n', '    /// @param vcId is the virtual chain ID\n', '    /// @param amount is the amount paid for the virtual chain subscription extension\n', '    function extendSubscription(uint256 vcId, uint256 amount) external {\n', '        require(amount > 0, "must include funds");\n', '\n', '        ISubscriptions subs = ISubscriptions(getSubscriptionsContract());\n', '        require(erc20.transferFrom(msg.sender, address(this), amount), "failed to transfer subscription fees from vc payer to subscriber");\n', '        require(erc20.approve(address(subs), amount), "failed to approve subscription fees to subscriptions by subscriber");\n', '        subs.extendSubscription(vcId, amount, tier, monthlyRate, msg.sender);\n', '    }\n', '\n', '}']