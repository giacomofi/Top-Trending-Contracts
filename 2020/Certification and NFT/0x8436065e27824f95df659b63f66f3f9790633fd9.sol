['pragma solidity ^0.5.16;\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', 'contract MultiOwnable is\n', '    Initializable\n', '{\n', '\n', '    uint public constant GRACE_PERIOD = 14 days;\n', '    uint public constant MINIMUM_DELAY = 1 hours;\n', '    uint public constant MAXIMUM_DELAY = 30 days;\n', '\n', '    struct VoteInfo {\n', '        uint32 timelockFrom;\n', '        uint32 votesCounter;\n', '        uint64 curVote;\n', '        mapping(uint => mapping (address => bool)) isVoted; // [curVote][owner]\n', '    }\n', '    mapping(bytes => VoteInfo) public votes;\n', '\n', '    mapping(address => bool) public  multiOwners;\n', '\n', '    uint public multiOwnersCounter;\n', '\n', '    uint public minVotes = 2;           // initial value\n', '\n', '    uint public delay = MINIMUM_DELAY;  // initial value\n', '\n', '    event QueueVote(address indexed owner, bytes data);\n', '    event TxTimelockStart(bytes data, uint32 start);\n', '    event CancelVote(address indexed owner, bytes data);\n', '    event ExecuteVote(bytes data);\n', '    event NewMinVotes(uint newMinVotes);\n', '    event NewDelay(uint newDelay);\n', '    event MultiOwnerAdded(address indexed newMultiOwner);\n', '    event MultiOwnerRemoved(address indexed exMultiOwner);\n', '\n', '    modifier onlyMultiOwners {\n', '        // hook instead of using huge main modifier\n', '        if (_onlyMultiOwnersCall()) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    modifier _onlyMultiOwnersHelper {\n', '        address account = msg.sender;\n', '        bytes memory data = msg.data;\n', '        require(multiOwners[account], "Permission denied");\n', '\n', '        uint curVote = votes[data].curVote;\n', '        uint32 curTimestamp = uint32(block.timestamp);\n', '\n', '        // vote for current call\n', '        if (!votes[data].isVoted[curVote][account]) {\n', '            votes[data].isVoted[curVote][account] = true;\n', '            votes[data].votesCounter++;\n', '            emit QueueVote(account, data);\n', '\n', '            if (votes[data].votesCounter == min(minVotes, multiOwnersCounter)) {\n', '                votes[data].timelockFrom = curTimestamp;\n', '                emit TxTimelockStart(data, curTimestamp);\n', '            }\n', '        }\n', '\n', '        // execute tx\n', '        if (votes[data].votesCounter >= min(minVotes, multiOwnersCounter) &&\n', '            votes[data].timelockFrom + delay <= curTimestamp &&\n', '            votes[data].timelockFrom + delay + GRACE_PERIOD >= curTimestamp\n', '        ){\n', '            // iterate to new vote for this msg.data\n', '            votes[data].votesCounter = 0;\n', '            votes[data].timelockFrom = 0;\n', '            votes[data].curVote++;\n', '            emit ExecuteVote(data);\n', '            _;  // tx execution\n', '        }\n', '    }\n', '\n', '    // ** INITIALIZERS **\n', '\n', '    function initialize() public initializer {\n', '        _addMultiOwner(msg.sender);\n', '    }\n', '\n', '    function initialize(address[] memory _newMultiOwners) public initializer {\n', '        require(_newMultiOwners.length > 0, "Array lengths have to be greater than zero");\n', '\n', '        for (uint i = 0; i < _newMultiOwners.length; i++) {\n', '            _addMultiOwner(_newMultiOwners[i]);\n', '        }\n', '    }\n', '\n', '    // ** ONLY_MULTI_OWNERS functions **\n', '\n', '    function addMultiOwner(address _newMultiOwner) public onlyMultiOwners {\n', '        _addMultiOwner(_newMultiOwner);\n', '    }\n', '\n', '    function addMultiOwners(address[] memory _newMultiOwners) public onlyMultiOwners {\n', '        require(_newMultiOwners.length > 0, "Array lengths have to be greater than zero");\n', '\n', '        for (uint i = 0; i < _newMultiOwners.length; i++) {\n', '            _addMultiOwner(_newMultiOwners[i]);\n', '        }\n', '    }\n', '\n', '    function removeMultiOwner(address _exMultiOwner) public onlyMultiOwners {\n', '        _removeMultiOwner(_exMultiOwner);\n', '    }\n', '\n', '    function removeMultiOwners(address[] memory _exMultiOwners) public onlyMultiOwners {\n', '        require(_exMultiOwners.length > 0, "Array lengths have to be greater than zero");\n', '\n', '        for (uint i = 0; i < _exMultiOwners.length; i++) {\n', '            _removeMultiOwner(_exMultiOwners[i]);\n', '        }\n', '    }\n', '\n', '    function setMinVotes(uint _minVotes) public onlyMultiOwners {\n', '        require(_minVotes > 0, "MinVotes have to be greater than zero");\n', '        minVotes = _minVotes;\n', '        emit NewMinVotes(_minVotes);\n', '    }\n', '\n', '    function setDelay(uint _delay) public onlyMultiOwners {\n', '        require(_delay >= MINIMUM_DELAY, "Delay must exceed minimum delay.");\n', '        require(_delay <= MAXIMUM_DELAY, "Delay must not exceed maximum delay.");\n', '        delay = _delay;\n', '\n', '        emit NewDelay(_delay);\n', '    }\n', '\n', '    function cancelVote(bytes memory _data) public {\n', '        address account = msg.sender;\n', '        require(multiOwners[account], "Permission denied");\n', '\n', '        // check vote data\n', '        uint curVote = votes[_data].curVote;\n', '        require(votes[_data].isVoted[curVote][account] && votes[_data].votesCounter > 0, "Incorrect vote data");\n', '\n', '        // cancel current vote\n', '        votes[_data].isVoted[curVote][account] = false;\n', '        votes[_data].votesCounter--;    // safe\n', '        emit CancelVote(account, _data);\n', '    }\n', '\n', '    // ** INTERNAL functions **\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function _onlyMultiOwnersCall() internal _onlyMultiOwnersHelper returns (bool success) {\n', '        success = true;\n', '    }\n', '\n', '    function _addMultiOwner(address _newMultiOwner) internal {\n', '        require(!multiOwners[_newMultiOwner], "The owner has already been added");\n', '\n', '        // UPD states\n', '        multiOwners[_newMultiOwner] = true;\n', '        multiOwnersCounter++;\n', '\n', '        emit MultiOwnerAdded(_newMultiOwner);\n', '    }\n', '\n', '    function _removeMultiOwner(address _exMultiOwner) internal {\n', '        require(multiOwners[_exMultiOwner], "This address is not the owner");\n', '        require(multiOwnersCounter > 1, "At least one owner required");\n', '\n', '        // UPD states\n', '        multiOwners[_exMultiOwner] = false;\n', '        multiOwnersCounter--;   // safe\n', '\n', '        emit MultiOwnerRemoved(_exMultiOwner);\n', '    }\n', '\n', '}\n', '\n', '// **INTERFACES**\n', '\n', 'interface IAdminUpgradeabilityProxy {\n', '    function changeAdmin(address newAdmin) external;\n', '    function upgradeTo(address newImplementation) external;\n', '    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;\n', '}\n', '\n', '/**\n', ' * @title ProxyAdminMultisig\n', ' * @dev This contract is the admin of a proxy, and is in charge\n', ' * of upgrading it as well as transferring it to another admin.\n', ' */\n', 'contract ProxyAdminMultisig is MultiOwnable {\n', '\n', '    constructor() public {\n', '        address[] memory newOwners = new address[](1);\n', '        newOwners[0] = 0xdAE0aca4B9B38199408ffaB32562Bf7B3B0495fE;\n', '        initialize(newOwners);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current implementation of a proxy.\n', '     * This is needed because only the proxy admin can query it.\n', '     * @return The address of the current implementation of the proxy.\n', '     */\n', '    function getProxyImplementation(IAdminUpgradeabilityProxy proxy) public view returns (address) {\n', '        // We need to manually run the static call since the getter cannot be flagged as view\n', '        // bytes4(keccak256("implementation()")) == 0x5c60da1b\n', '        (bool success, bytes memory returndata) = address(proxy).staticcall(hex"5c60da1b");\n', '        require(success);\n', '        return abi.decode(returndata, (address));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the admin of a proxy. Only the admin can query it.\n', '     * @return The address of the current admin of the proxy.\n', '     */\n', '    function getProxyAdmin(IAdminUpgradeabilityProxy proxy) public view returns (address) {\n', '        // We need to manually run the static call since the getter cannot be flagged as view\n', '        // bytes4(keccak256("admin()")) == 0xf851a440\n', '        (bool success, bytes memory returndata) = address(proxy).staticcall(hex"f851a440");\n', '        require(success);\n', '        return abi.decode(returndata, (address));\n', '    }\n', '\n', '    /**\n', '     * @dev Changes the admin of a proxy.\n', '     * @param proxy Proxy to change admin.\n', '     * @param newAdmin Address to transfer proxy administration to.\n', '     */\n', '    function changeProxyAdmin(IAdminUpgradeabilityProxy proxy, address newAdmin) public onlyMultiOwners {\n', '        proxy.changeAdmin(newAdmin);\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrades a proxy to the newest implementation of a contract.\n', '     * @param proxy Proxy to be upgraded.\n', '     * @param implementation the address of the Implementation.\n', '     */\n', '    function upgrade(IAdminUpgradeabilityProxy proxy, address implementation) public onlyMultiOwners {\n', '        proxy.upgradeTo(implementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.\n', '     * This is useful to initialize the proxied contract.\n', '     * @param proxy Proxy to be upgraded.\n', '     * @param implementation Address of the Implementation.\n', '     * @param data Data to send as msg.data in the low level call.\n', '     * It should include the signature and the parameters of the function to be called, as described in\n', '     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '     */\n', '    function upgradeAndCall(IAdminUpgradeabilityProxy proxy, address implementation, bytes memory data) public payable  onlyMultiOwners {\n', '        proxy.upgradeToAndCall.value(msg.value)(implementation, data);\n', '    }\n', '}']