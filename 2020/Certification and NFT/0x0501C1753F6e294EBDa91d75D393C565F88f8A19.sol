['// File: contracts/collateralSplits/ICollateralSplit.sol\n', '\n', 'pragma solidity >=0.4.21 <0.7.0;\n', '\n', '/// @title Collateral Split interface\n', '/// @notice Contains mathematical functions used to calculate relative claim\n', '/// on collateral of primary and complement assets after settlement.\n', '/// @dev Created independently from specification and published to the CollateralSplitRegistry\n', 'interface ICollateralSplit {\n', '\n', '    /// @notice Proof of collateral split contract\n', '    /// @dev Verifies that contract is a collateral split contract\n', '    /// @return true if contract is a collateral split contract\n', '    function isCollateralSplit() external pure returns(bool);\n', '\n', '    /// @notice Symbol of the collateral split\n', '    /// @dev Should be resolved through CollateralSplitRegistry contract\n', '    /// @return collateral split specification symbol\n', '    function symbol() external view returns (string memory);\n', '\n', "    /// @notice Calcs primary asset class' share of collateral at settlement.\n", '    /// @dev Returns ranged value between 0 and 1 multiplied by 10 ^ 12\n', '    /// @param _underlyingStartRoundHints specify for each oracle round of the start of Live period\n', '    /// @param _underlyingEndRoundHints specify for each oracle round of the end of Live period\n', "    /// @return _split primary asset class' share of collateral at settlement\n", '    /// @return _underlyingStarts underlying values in the start of Live period\n', '    /// @return _underlyingEnds underlying values in the end of Live period\n', '    function split(\n', '        address[] memory _oracles,\n', '        address[] memory _oracleIterators,\n', '        uint _liveTime,\n', '        uint _settleTime,\n', '        uint[] memory _underlyingStartRoundHints,\n', '        uint[] memory _underlyingEndRoundHints)\n', '    external view returns(uint _split, int[] memory _underlyingStarts, int[] memory _underlyingEnds);\n', '}\n', '\n', '// File: contracts/oracleIterators/IOracleIterator.sol\n', '\n', 'pragma solidity >=0.4.21 <0.7.0;\n', '\n', 'interface IOracleIterator {\n', '    /// @notice Proof of oracle iterator contract\n', '    /// @dev Verifies that contract is a oracle iterator contract\n', '    /// @return true if contract is a oracle iterator contract\n', '    function isOracleIterator() external pure returns(bool);\n', '\n', '    /// @notice Symbol of the oracle iterator\n', '    /// @dev Should be resolved through OracleIteratorRegistry contract\n', '    /// @return oracle iterator symbol\n', '    function symbol() external view returns (string memory);\n', '\n', '    /// @notice Algorithm that, for the type of oracle used by the derivative,\n', '    //  finds the value closest to a given timestamp\n', '    /// @param _oracle iteratable oracle through\n', '    /// @param _timestamp a given timestamp\n', '    /// @param _roundHints specified rounds for a given timestamp\n', '    /// @return the value closest to a given timestamp\n', '    function getUnderlingValue(address _oracle, uint _timestamp, uint[] memory _roundHints) external view returns(int);\n', '}\n', '\n', '// File: contracts/collateralSplits/CollateralSplitParent.sol\n', '\n', 'pragma solidity >=0.4.21 <0.7.0;\n', '\n', '\n', '\n', 'abstract contract CollateralSplitParent is ICollateralSplit {\n', '    int public constant FRACTION_MULTIPLIER = 10**12;\n', '    int public constant NEGATIVE_INFINITY = type(int256).min;\n', '\n', '    function isCollateralSplit() external override pure returns(bool) {\n', '        return true;\n', '    }\n', '\n', '    function split(\n', '        address[] memory _oracles,\n', '        address[] memory _oracleIterators,\n', '        uint _liveTime,\n', '        uint _settleTime,\n', '        uint[] memory _underlyingStartRoundHints,\n', '        uint[] memory _underlyingEndRoundHints)\n', '    external override virtual view returns(uint _split, int[] memory _underlyingStarts, int[] memory _underlyingEnds) {\n', '        require(_oracles.length == 1, "More than one oracle");\n', '        require(_oracles[0] != address(0), "Oracle is empty");\n', '        require(_oracleIterators[0] != address(0), "Oracle iterator is empty");\n', '\n', '        _underlyingStarts = new int[](1);\n', '        _underlyingEnds = new int[](1);\n', '\n', '        IOracleIterator iterator = IOracleIterator(_oracleIterators[0]);\n', '        require(iterator.isOracleIterator(), "Not oracle iterator");\n', '\n', '        _underlyingStarts[0] = iterator.getUnderlingValue(_oracles[0], _liveTime, _underlyingStartRoundHints);\n', '        _underlyingEnds[0] = iterator.getUnderlingValue(_oracles[0], _settleTime, _underlyingEndRoundHints);\n', '\n', '        _split = range(\n', '            splitNominalValue(\n', '                normalize( _underlyingStarts[0], _underlyingEnds[0] )\n', '            )\n', '        );\n', '    }\n', '\n', '    function splitNominalValue(int _normalizedValue) public virtual pure returns(int);\n', '\n', '    function normalize(int _u_0, int _u_T) public virtual pure returns(int){\n', '        require(_u_0 != NEGATIVE_INFINITY, "u_0 is absent");\n', '        require(_u_T != NEGATIVE_INFINITY, "u_T is absent");\n', '        require(_u_0 > 0, "u_0 is less or equal zero");\n', '\n', '        if(_u_T < 0) {\n', '            _u_T = 0;\n', '        }\n', '\n', '        return (_u_T - _u_0) * FRACTION_MULTIPLIER / _u_0;\n', '    }\n', '\n', '    function range(int _split) public pure returns(uint) {\n', '        if(_split >= FRACTION_MULTIPLIER) {\n', '            return uint(FRACTION_MULTIPLIER);\n', '        }\n', '        if(_split <= 0) {\n', '            return 0;\n', '        }\n', '        return uint(_split);\n', '    }\n', '}\n', '\n', '// File: contracts/collateralSplits/CallOptionSplit.sol\n', '\n', '// "SPDX-License-Identifier: GNU General Public License v3.0"\n', '\n', 'pragma solidity >=0.4.21 <0.7.0;\n', '\n', '\n', 'contract CallOptionSplit is CollateralSplitParent{\n', '\n', '    function symbol() external override view returns (string memory) {\n', "        return 'CallOption';\n", '    }\n', '\n', '    function splitNominalValue(int _normalizedValue) public override pure returns(int){\n', '        if(_normalizedValue < 0) { // < 0\n', '            return 0; // 0%\n', '        }\n', '\n', '        if(_normalizedValue >= 0) { // >= 0\n', '            return FRACTION_MULTIPLIER * _normalizedValue / (FRACTION_MULTIPLIER + _normalizedValue );  // U/(1+U)\n', '        }\n', '        return 0;\n', '    }\n', '}']