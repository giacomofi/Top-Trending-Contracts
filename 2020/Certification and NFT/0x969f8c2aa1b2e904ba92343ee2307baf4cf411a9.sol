['pragma solidity ^0.6.8;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'contract OrganizationDeployer {\n', '\n', '    address public immutable tokenImplementation;\n', '    address public immutable timelockImplementation;\n', '    address public immutable governanceImplementation;\n', '    \n', '    struct OrgData {\n', '        /// @notice Name of the organisation\n', '        string organisationName;\n', '\n', '        /// @notice Token Symbol\n', '        string symbol;\n', '\n', '        /// @notice Initial supply of the token\n', '        uint256 initialSupply;\n', '\n', '        /// @notice Address to receive the initial supply\n', '        address tokenOwner;\n', '\n', '        /// @notice Timestamp at which minting more tokens is allowed\n', '        uint256 mintingAllowedAfter;\n', '\n', '        /// @notice Cap for miniting everytime\n', '        uint8 mintCap;\n', '\n', '        /// @notice Minimun time to minting the tokens again \n', '        uint32 minimumTimeBetweenMints;\n', '\n', '        /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. Should be lower than initial supply\n', '        uint256 quorumVotes;\n', '\n', '        /// @notice The number of votes required in order for a voter to become a proposer\n', '        uint256 proposalThreshold;\n', '\n', '        /// @notice The delay before voting on a proposal may take place, once proposed. In number of blocks\n', '        uint256 votingDelay;\n', '\n', '        /// @notice The duration of voting on a proposal, in number blocks\n', '        uint256 votingPeriod;\n', '\n', '        /// @notice Delay in the timelock contract\n', '        uint256 delay;\n', '\n', '        /// @notice Minimum delay in the timelock contract\n', '        uint256 minDelay;\n', '\n', '        /// @notice Maximum delay in the timelock contract\n', '        uint256 maxDelay;\n', '    }\n', '\n', '    event LogDeployedOrg(\n', '        address indexed token_,\n', '        address indexed timelock_,\n', '        address indexed governance_\n', '    );\n', '\n', '    constructor(address token_, address timelock_, address governance_) public {\n', '        tokenImplementation = token_;\n', '        timelockImplementation = timelock_;\n', '        governanceImplementation = governance_;\n', '    }\n', '\n', '    function _deployer() private returns (address token, address timelock, address governance) {\n', '        uint timestamp_ = now;\n', '\n', '        token = _deployLogic(timestamp_, tokenImplementation);\n', '        timelock = _deployLogic(timestamp_, timelockImplementation);\n', '        governance = _deployLogic(timestamp_, governanceImplementation);\n', '    }\n', '\n', '    function _deployLogic(uint timestamp_, address logic) private returns (address proxy) {\n', '        bytes32 salt = keccak256(abi.encodePacked(timestamp_)); // TODO : change salt to something that we can control\n', '        bytes20 targetBytes = bytes20(logic);\n', '        assembly {\n', '            let clone := mload(0x40)\n', '            mstore(\n', '                clone,\n', '                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n', '            )\n', '            mstore(add(clone, 0x14), targetBytes)\n', '            mstore(\n', '                add(clone, 0x28),\n', '                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n', '            )\n', '            proxy := create2(0, clone, 0x37, salt)\n', '        }\n', '    }\n', '\n', '    function createOrg(OrgData calldata d) external returns (address token, address timelock, address governance) {\n', '\n', '        require(d.initialSupply > d.quorumVotes, "Initial Supply should be greater than quoroum");\n', '        require(d.initialSupply > d.proposalThreshold, "Initial Supply should be greater than proposal threshold");\n', '        \n', '        (token, timelock, governance) = _deployer();\n', '\n', '        bytes memory initData = abi.encodeWithSignature(\n', '            "initialize(string,string,uint256,address,address,uint256,uint8,uint32)",\n', '            d.organisationName,\n', '            d.symbol,\n', '            d.initialSupply,\n', '            d.tokenOwner,\n', '            timelock,\n', '            d.mintingAllowedAfter,\n', '            d.mintCap,\n', '            d.minimumTimeBetweenMints\n', '        );\n', '\n', '        (bool success,) = token.call(initData);\n', '        require(success, "Failed to initialize token");\n', '\n', '        initData = abi.encodeWithSignature(\n', '            "initialize(address,uint256,uint256,uint256)",\n', '            governance,\n', '            d.delay,\n', '            d.minDelay,\n', '            d.maxDelay\n', '        );\n', '\n', '        (success,) = timelock.call(initData);\n', '        require(success, "Failed to initialize timelock");\n', '\n', '        initData = abi.encodeWithSignature(\n', '            "initialize(string,address,address,uint256,uint256,uint256,uint256)",\n', '            string(abi.encodePacked(d.organisationName, " Governor Alpha")),\n', '            token,\n', '            timelock,\n', '            d.quorumVotes,\n', '            d.proposalThreshold,\n', '            d.votingDelay,\n', '            d.votingPeriod\n', '        );\n', '\n', '        (success,) = governance.call(initData);\n', '        require(success, "Failed to initialize governance");\n', '\n', '        emit LogDeployedOrg(token, timelock, governance);\n', '    }\n', '}']