['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) { return 0; }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address account) external view returns (uint256);\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '  function approve(address spender, uint256 amount) external returns (bool);\n', '  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this;\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract UnilayerStake is Ownable {\n', '    using SafeMath for uint;\n', '    \n', '    address public stakeCreator = address(0x80eD730B453C1c3d5e89326eb1b04BeA8125dbd1);\n', '    uint public ethToNextStake = 0;\n', '    uint stakeNum = 0;\n', '    uint constant CAP = 1000000000000000000; //smallest currency unit\n', '    bool isPaused = false;\n', '    \n', '    enum WithdrawType {Leave, Next}\n', '    \n', '    struct Stake {\n', '       uint start;\n', '       uint end;\n', '       uint unilayerLocked;\n', '       uint rewardPayment;\n', '    }\n', '    \n', '    struct StakeHolder {\n', '        uint amountLocked;\n', '        uint reward;\n', '    }\n', '    \n', '    event logLockedTokens(address holder, uint amountLocked, uint stakeId);\n', '    event logUnlockedTokens(address holder, uint amountUnlocked, uint stakeId);\n', '    event logNewStakePayment(uint id, uint amount);\n', '    event logWithdraw(address holder, uint amount, uint allEarning, uint stakeId);\n', '    \n', '    modifier paused {\n', '        require(isPaused == false, "This contract was paused by the owner!");\n', '        _;\n', '    }\n', '          \n', '    modifier exist (uint index) {\n', "        require(index <= stakeNum, 'This stake does not exist.');\n", '        _;        \n', '    }\n', '    \n', '    mapping (address => mapping (uint => StakeHolder)) public stakeHolders;\n', '    mapping (uint => Stake) public stakes;\n', '    \n', '    IERC20 UNILAYER = IERC20(0x0fF6ffcFDa92c53F615a4A75D982f399C989366b);\n', '    \n', '    function setNewStakeCreator(address _stakeCreator) external onlyOwner {\n', "        require(_stakeCreator != address(0), 'Do not use 0 address');\n", '        stakeCreator = _stakeCreator;\n', '    }\n', '    \n', '    function lock(uint payment) external paused {\n', "        require(payment > 0, 'Payment must be greater than 0.');\n", "        require(UNILAYER.balanceOf(msg.sender) >= payment, 'Holder does not have enough tokens.');\n", '        UNILAYER.transferFrom(msg.sender, address(this), payment);\n', '        \n', '        StakeHolder memory holder = stakeHolders[msg.sender][stakeNum];\n', '        holder.amountLocked = holder.amountLocked.add(payment);\n', '        \n', '        Stake memory stake = stakes[stakeNum];\n', '        stake.unilayerLocked = stake.unilayerLocked.add(payment);\n', '        \n', '        stakeHolders[msg.sender][stakeNum] = holder;\n', '        stakes[stakeNum] = stake;\n', '        \n', '        emit logLockedTokens(msg.sender, payment, stakeNum);\n', '    }\n', '    \n', '    function unlock(uint index) external paused exist(index) {\n', '        StakeHolder memory holder = stakeHolders[msg.sender][index]; \n', '        uint amt = holder.amountLocked;\n', "        require(amt > 0, 'You do not have locked tokens.');\n", '        \n', '        UNILAYER.transfer(msg.sender, amt);\n', '        \n', '        Stake memory stake = stakes[stakeNum];\n', '        \n', "        require(stake.end > block.timestamp, 'Invalid date for unlock, please use withdraw.');\n", '        \n', '        stake.unilayerLocked = stake.unilayerLocked.sub(amt);\n', '    \n', '        holder.amountLocked = 0;\n', '        \n', '        stakes[stakeNum] = stake;\n', '        stakeHolders[msg.sender][index] = holder;\n', '        \n', '        emit logUnlockedTokens(msg.sender, amt, index);\n', '    }\n', '    \n', '    function addStakePayment() external {\n', "        require(msg.sender == stakeCreator, 'You cannot call this function');\n", '        Stake memory stake = stakes[stakeNum]; \n', '        stake.end = block.timestamp;\n', '        stake.rewardPayment = stake.rewardPayment.add(ethToNextStake);\n', '        ethToNextStake = 0;\n', '        stakes[stakeNum] = stake;\n', '        emit logNewStakePayment(stakeNum, ethToNextStake);    \n', '        stakeNum++;\n', '        stakes[stakeNum] = Stake(block.timestamp, 0, 0, 0);\n', '    }\n', '    \n', '    function withdraw(uint index, WithdrawType wtype) external paused exist(index) {\n', '        StakeHolder memory holder = stakeHolders[msg.sender][index];\n', '        Stake memory stake = stakes[index];\n', '        \n', "        require(stake.end <= block.timestamp, 'Invalid date for withdrawal.');\n", "        require(holder.amountLocked > 0, 'You do not have locked tokens.');\n", "        require(stake.rewardPayment > 0, 'There is no value to distribute.');\n", '   \n', '        uint rate = holder.amountLocked.mul(CAP).div(stake.unilayerLocked);\n', '        \n', '        uint reward_temp = stake.rewardPayment.mul(rate).div(CAP).sub(holder.reward);\n', '        \n', "        require(reward_temp > 0, 'You have no value to be withdrawn.');\n", '\n', '        msg.sender.transfer(reward_temp); \n', '        holder.reward = holder.reward.add(reward_temp);\n', '        \n', '        emit logWithdraw(msg.sender, reward_temp, holder.reward, index);\n', '        \n', '        stakeHolders[msg.sender][index] = StakeHolder(0, holder.reward);\n', '        \n', '        if(wtype == WithdrawType.Leave) { \n', '            UNILAYER.transfer(msg.sender, holder.amountLocked); \n', '        }\n', '        else {\n', '            uint stakeI = 0;\n', '            if(index < stakeNum) { stakeI = stakeNum; }\n', '            else { stakeI = stakeNum + 1; }\n', '            \n', '            holder.reward = 0;\n', '            stakeHolders[msg.sender][stakeI] = holder;  \n', '            \n', '            Stake memory stakeNext = stakes[stakeI];\n', '            stakeNext.unilayerLocked = stakeNext.unilayerLocked.add(holder.amountLocked);\n', '            stakes[stakeI] = stakeNext;\n', '        } \n', '\n', '    }\n', '    \n', '    receive() external payable {\n', '        ethToNextStake = ethToNextStake.add(msg.value); \n', '    }\n', '\n', '    \n', '}']