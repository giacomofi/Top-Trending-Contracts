['pragma solidity ^0.6.12;// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', '\n', '\n', '/**\n', ' * @title Owned\n', ' * @notice Basic contract to define an owner.\n', ' * @author Julien Niset - <julien@argent.xyz>\n', ' */\n', 'contract Owned {\n', '\n', '    // The owner\n', '    address public owner;\n', '\n', '    event OwnerChanged(address indexed _newOwner);\n', '\n', '    /**\n', '     * @notice Throws if the sender is not the owner.\n', '     */\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Must be owner");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @notice Lets the owner transfer ownership of the contract to a new owner.\n', '     * @param _newOwner The new owner.\n', '     */\n', '    function changeOwner(address _newOwner) external onlyOwner {\n', '        require(_newOwner != address(0), "Address must not be null");\n', '        owner = _newOwner;\n', '        emit OwnerChanged(_newOwner);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title IArgentProxy\n', ' * @notice Interface for all Argent Proxy contracts exposing the target implementation.\n', ' */\n', 'interface IArgentProxy {\n', '    function implementation() external view returns (address);\n', '}\n', '\n', '/**\n', ' * @title ArgentWalletDetector\n', ' * @notice Simple contract to detect if a given address represents an Argent wallet.\n', ' * The `isArgentWallet` method returns true if the codehash matches one of the deployed Proxy\n', ' * and if the target implementation matches one of the deployed BaseWallet.\n', ' * Only the owner of the contract can add code hash ad implementations.\n', ' * @author Julien Niset - <julien@argent.xyz>\n', ' */\n', 'contract ArgentWalletDetector is Owned {\n', '\t\n', '\t// The accepeted code hash\n', '\tbytes32[] private codes;\n', '\t// The accepted implementations\n', '\taddress[] private implementations;\n', '\t// mapping to efficiently check if a code is accepeted\n', '    mapping (bytes32 => Info) public acceptedCodes;\n', '\t// mapping to efficiently check is an implementation is accepeted\n', '\tmapping (address => Info) public acceptedImplementations;\n', '\n', '\tstruct Info {\n', '        bool exists;\n', '        uint128 index;\n', '    }\n', '\n', '\t// emits when a new accepeted code is added\n', '\tevent CodeAdded(bytes32 indexed code);\n', '\t// emits when a new accepeted implementation is added \n', '\tevent ImplementationAdded(address indexed implementation);\n', '\n', '\tconstructor(bytes32[] memory _codes, address[] memory _implementations) public {\n', '\t\tfor(uint i = 0; i < codes.length; i++) {\n', '\t\t\taddCode(_codes[i]);\n', '\t\t}\n', '\t\tfor(uint j = 0; j < _implementations.length; j++) {\n', '\t\t\taddImplementation(_implementations[j]);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '    * @notice Adds a new acceted code hash.\n', '    * @param _code The new code hash.\n', '    */\n', '\tfunction addCode(bytes32 _code) public onlyOwner {\n', '        require(_code != bytes32(0), "AWR: empty _code");\n', '        Info storage code = acceptedCodes[_code];\n', '\t\tif(!code.exists) {\n', '\t\t\tcodes.push(_code);\n', '\t\t\tcode.exists = true;\n', '        \tcode.index = uint128(codes.length - 1);\n', '\t\t\temit CodeAdded(_code);\n', '\t\t}\n', '    }\n', '\t\n', '\t/**\n', '    * @notice Adds a new acceted implementation.\n', '    * @param _impl The new implementation.\n', '    */\n', '\tfunction addImplementation(address _impl) public onlyOwner {\n', '        require(_impl != address(0), "AWR: empty _impl");\n', '        Info storage impl = acceptedImplementations[_impl];\n', '\t\tif(!impl.exists) {\n', '\t\t\timplementations.push(_impl);\n', '\t\t\timpl.exists = true;\n', '        \timpl.index = uint128(implementations.length - 1);\n', '\t\t\temit ImplementationAdded(_impl);\n', '\t\t}\n', '    }\n', '\n', '\t/**\n', '    * @notice Adds a new acceted code hash and implementation from a deployed Argent wallet.\n', '    * @param _argentWallet The deployed Argent wallet.\n', '    */\n', '    function addCodeAndImplementationFromWallet(address _argentWallet) external onlyOwner {\n', '        bytes32 codeHash;   \n', '    \tassembly { codeHash := extcodehash(_argentWallet) }\n', '        addCode(codeHash);\n', '        address implementation = IArgentProxy(_argentWallet).implementation(); \n', '        addImplementation(implementation);\n', '    }\n', '\n', '\t/**\n', '    * @notice Gets the list of accepted implementations.\n', '    */\n', '\tfunction getImplementations() public view returns (address[] memory) {\n', '\t\treturn implementations;\n', '\t}\n', '\n', '\t/**\n', '    * @notice Gets the list of accepted code hash.\n', '    */\n', '\tfunction getCodes() public view returns (bytes32[] memory) {\n', '\t\treturn codes;\n', '\t}\n', '\n', '\t/**\n', '    * @notice Checks if an address is an Argent wallet\n', '\t* @param _wallet The target wallet\n', '    */\n', '\tfunction isArgentWallet(address _wallet) external view returns (bool) {\n', '\t\tbytes32 codeHash;    \n', '    \tassembly { codeHash := extcodehash(_wallet) }\n', '\t\treturn acceptedCodes[codeHash].exists && acceptedImplementations[IArgentProxy(_wallet).implementation()].exists;\n', '\t}\n', '}']