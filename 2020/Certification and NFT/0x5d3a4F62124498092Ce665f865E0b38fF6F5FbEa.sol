['//SPDX-License-Identifier: UNLICENSE\n', 'pragma solidity 0.7.0;\n', '\n', '//SafeMath library for calculations.\n', 'contract SafeMath {\n', '    function safeAdd(uint a, uint b) internal pure returns (uint c){\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function safeSub(uint a, uint b) internal pure returns (uint c){\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) internal pure returns (uint c){\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function safeDiv(uint a, uint b) internal pure returns (uint c){\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '//ideaology main contract code.\n', 'contract ideaology is SafeMath{\n', '    \n', '    string public symbol;\n', '    string public name;\n', '    uint8 public decimals;\n', '    uint public sale_token; //need function\n', '    uint public total_sold_token;\n', '    uint public totalSupply; //need function\n', '    address public owner;\n', '    uint[] public salesAmount;\n', '    \n', '    //sale struct declare\n', '    struct sale{\n', '        uint startDate;\n', '        uint endDate;\n', '        uint256 saletoken;\n', '        uint256 price;\n', '        uint256 softcap;\n', '        uint256 hardcap;\n', '        uint256 total_sold;\n', '    }\n', '    \n', '    sale[] public sale_detail;\n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping (address => uint256)) internal allowed;\n', '    mapping(string => uint256) internal allSupplies;\n', '    mapping(string => uint256) internal RewardDestribution;\n', '    mapping(string => uint256) internal token_sale;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '    \n', '    //constructor to define all fields\n', '    constructor(){\n', '        symbol = "IDEA";\n', '        name = "IDEAOLOGY";\n', '        decimals = 18;\n', '        totalSupply = 500000000 * 10 ** uint256(18);\n', '        sale_token =  219160000 * 10 ** uint256(18);\n', '        owner = msg.sender;\n', '        \n', '        //sale data\n', '         salesAmount = [0, 6000000 * 10 ** uint256(18), 19160000 * 10 ** uint256(18), 194000000 * 10 ** uint256(18)];\n', '        \n', '        //initialize supplies\n', "        allSupplies['operation'] = 10000000 * 10 ** uint256(18);\n", "        allSupplies['plateform_developement'] = 150000000 * 10 ** uint256(18);\n", "        allSupplies['marketing'] = 25000000 * 10 ** uint256(18);\n", "        allSupplies['team'] = 15000000 * 10 ** uint256(18);\n", '        \n', '        //initialize RewardDestribution\n', "    \tRewardDestribution['twitter'] = 2990000 * 10 ** uint256(18);\n", "        RewardDestribution['facebook'] = 3450000 * 10 ** uint256(18);\n", "        RewardDestribution['content'] = 6900000 * 10 ** uint256(18);\n", "        RewardDestribution['youtube'] = 2760000 * 10 ** uint256(18);\n", "        RewardDestribution['telegram'] = 4600000 * 10 ** uint256(18);\n", "        RewardDestribution['instagram'] = 2300000 * 10 ** uint256(18);\n", "        RewardDestribution['event'] = 1000000 * 10 ** uint256(18);\n", "        RewardDestribution['quiz'] = 500000 * 10 ** uint256(18);\n", "        RewardDestribution['partnership'] = 5500000 * 10 ** uint256(18);\n", '        \n', '        //initialize balance\n', '        balances[owner] = totalSupply - sale_token - (200000000 * 10 ** uint256(18)) - (30000000 * 10 ** uint256(18));\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(msg.sender == owner,"Only Access By Admin!!");\n', '        _;\n', '    }\n', '    \n', '    //Fucntion to Get Owner Address\n', '    function getOwnerAddress() public view returns(address ownerAddress){\n', '        return owner;\n', '    }\n', '    \n', '    //Function to Transfer the Ownership\n', '    function transferOwnership(address newOwner) public onlyOwner{\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        uint _value = balances[msg.sender];\n', '        balances[msg.sender] = safeSub(balances[msg.sender],_value);\n', '        balances[newOwner] = safeAdd(balances[newOwner], _value);\n', '        emit Transfer(msg.sender, newOwner, _value);\n', '    }\n', '    \n', '    //Fucntion to Start Pre-Sale.\n', '    function start_sale(uint _startdate, uint _enddate, uint _price, uint _softcap, uint _hardcap) public onlyOwner returns (bool status){\n', '        uint chck = sale_detail.length;\n', '        if( chck == 3) {\n', '            revert("All private sale is set");\n', '        }\n', '        uint _softcapToken = safeDiv(_softcap, _price);\n', '        uint _hardcapToken = safeDiv(_hardcap, _price); \n', '        \n', '        \n', '        if(_startdate < _enddate && _startdate > block.timestamp && _softcap < _hardcap && _softcapToken < salesAmount[chck + 1] && _hardcapToken < salesAmount[chck + 1]){\n', '            \n', '            sale memory p1= sale(_startdate, _enddate, salesAmount[chck + 1], _price, _softcap, _hardcap, 0);\n', '            sale_detail.push(p1);\n', '            sale_token = safeSub(sale_token, salesAmount[chck + 1]);\n', '        }\n', '        else{\n', '            revert("Invalid data provided to start presale");\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    //Function to transfer token from different supply    \n', '    function transferFromAllSupplies(address receiver, uint numTokens, string memory _supply) public onlyOwner returns (bool status) {\n', '        require(numTokens <= allSupplies[_supply], "Token amount is larger than token distribution allocation");\n', '        allSupplies[_supply] = safeSub(allSupplies[_supply], numTokens);\n', '        balances[receiver] = safeAdd(balances[receiver],numTokens);\n', '        emit Transfer(msg.sender, receiver, numTokens);\n', '        return true;\n', '    }\n', '     \n', '    //Function to transfer token from reward   \n', '    function transferRewards(address receiver, uint numTokens, string memory community) public onlyOwner returns (bool status) {\n', '        require(numTokens <= RewardDestribution[community], "Token amount is larger than token distribution allocation");\n', '        RewardDestribution[community] = safeSub(RewardDestribution[community], numTokens);\n', '        balances[receiver] = safeAdd(balances[receiver],numTokens);\n', '        emit Transfer(msg.sender, receiver, numTokens);\n', '        return true;\n', '    }\n', '    \n', '    //Function to purchase token.\n', '    function purchase (address _account,uint _token) onlyOwner public returns (bool status){\n', '        bool isSend = false;\n', '        for (uint i=0; i < sale_detail.length; i++){\n', '            if (block.timestamp >= sale_detail[i].startDate && block.timestamp <=sale_detail[i].endDate){\n', '                if(_token <= sale_detail[i].saletoken){\n', '                    sale_detail[i].saletoken = safeSub(sale_detail[i].saletoken, _token);\n', '                    balances[_account] = safeAdd(balances[_account], _token);\n', '                    total_sold_token = safeAdd(total_sold_token, _token);\n', '                    sale_detail[i].total_sold = safeAdd(sale_detail[i].total_sold,_token);\n', '                    emit Transfer(msg.sender, _account, _token);\n', '                    isSend = true;\n', '                    return true;\n', '                }\n', '                else{\n', '                    revert("Check available token balances");\n', '                }\n', '            }\n', '        }\n', '        if(!isSend){\n', '            require (balances[msg.sender] >= _token,"All Token Sold!");\n', '            balances[msg.sender] = safeSub(balances[msg.sender], _token);\n', '            balances[_account] = safeAdd(balances[_account], _token);\n', '            total_sold_token = safeAdd(total_sold_token, _token);\n', '            emit Transfer(msg.sender, _account, _token);\n', '            return true;\n', '        }\n', '    }\n', '    \n', '    //Function to burn the token from his account.\n', '    function burn(uint256 value) onlyOwner public returns (bool success){\n', '        require(balances[owner] >= value);\n', '        balances[owner] =safeSub(balances[owner], value);\n', '        emit Transfer(msg.sender, address(0), value); //solhint-disable-line indent, no-unused-vars\n', '        return true;\n', '    }\n', '    \n', '    //Function to transfer token by owner.\n', '    function transfer(address to, uint tokens) public returns (bool success){\n', '        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '        total_sold_token = safeAdd(total_sold_token, tokens);\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '    \n', '    //Function to Approve user to spend token.\n', '    function approve(address spender, uint tokens) public returns (bool success){\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '    \n', '    //Fucntion to transfer token from address.\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success){\n', '        balances[from] = safeSub(balances[from], tokens);\n', '        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '    \n', '    //Fucntion to stop reciving ETH\n', '    fallback() external {\n', "       revert('contract does not accept ether'); // Reject any accidental Ether transfer\n", '    }\n', '\n', '    //Function for Allowance.\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining){\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '    \n', '    //Function to get presale length\n', '    function getsaleDetails() public view returns (uint presalelength) {\n', '        return sale_detail.length;\n', '    }\n', '    \n', '    //Function to check balance.\n', '    function balanceOf(address tokenOwner) public view returns (uint balance){\n', '        return balances[tokenOwner];\n', '    }\n', '    \n', '    //Function to display reward balance\n', '    function viewReward() public view returns (uint twitterToken, uint facebookToken, uint contentToken, uint youtubeToken, uint telegramToken, uint instagramToken, uint quizToken, uint partnershipToken){\n', "        return (RewardDestribution['twitter'],RewardDestribution['facebook'], RewardDestribution['content'], RewardDestribution['youtube'], RewardDestribution['telegram'], RewardDestribution['instagram'], RewardDestribution['quiz'], RewardDestribution['partnership']);\n", '    }\n', '    \n', '    //Function to display supplies balance\n', '    function viewSupplies() public view returns (uint operationToken, uint plateform_developementToken, uint marketingToken, uint teamToken){\n', "        return (allSupplies['operation'],allSupplies['plateform_developement'], allSupplies['marketing'], allSupplies['team']);\n", '    }\n', '    \n', '    //Function to get presale length\n', '    function countTotalSales() public view returns (uint count) {\n', '        return sale_detail.length;\n', '    }\n', '}']