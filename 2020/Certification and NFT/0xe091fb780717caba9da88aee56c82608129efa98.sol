['/**\n', ' *Submitted for verification at Etherscan.io on 2020-08-22\n', '*/\n', '\n', 'pragma solidity 0.6.0;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () public {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Keep is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    modifier validRecipient(address account) {\n', '        //require(account != address(0x0));\n', '        require(account != address(this));\n', '        _;\n', '    }\n', '\n', '    struct keeper {\n', '        uint256 snapshotPeriod;\n', '        uint256 snapshotBalance;\n', '    }\n', '\n', '    // events\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event LogWhitelisted(address indexed addr);\n', '    event LogUnlocked(uint256 timestamp);\n', '    event Logstopinflations(uint256 totalSupply);\n', '    event Logkeep(uint256 indexed period, uint256 candidatesLength, uint256 estimatedkeepers, uint256 keepedToken, uint256 availableUnits);\n', '\n', '    // public constants\n', '    string public constant name = "Keepstake.finance";\n', '    string public constant symbol = "KEEP";\n', '    uint256 public constant decimals = 9;\n', '\n', '    // private constants\n', '    uint256 private constant MAX_UINT256 = ~uint256(0);\n', '    uint256 private constant INITIAL_TOKENS = 21 * 10**6;\n', '    uint256 private constant INITIAL_SUPPLY = INITIAL_TOKENS * 10**decimals;\n', '    uint256 private constant TOTAL_UNITS = MAX_UINT256 - (MAX_UINT256 % INITIAL_SUPPLY);\n', '    uint256 private constant POOL_SIZE = 50; // 50%\n', '    uint256 private constant INIT_POOL_FACTOR = 60;\n', '    uint256 private constant keep_MIN_BALANCE = 1000 * 10**decimals;\n', '    uint256 private constant keep_ADDRESS_LIMIT = 1000;\n', '    uint256 private constant TIMELOCK_TIME = 72 hours;\n', '    uint256 private constant HALVING_PERIOD = 30;\n', '\n', '    // mappings\n', '    mapping(address => uint256) private _balances;\n', '    mapping(address => mapping (address => uint256)) private _allowances;\n', '    mapping(address => bool) private _whitelist;\n', '    mapping(address => keeper) private _keepers;\n', '    mapping(address => bool) private _knownAddresses;\n', '    mapping(uint256 => address) private _addresses;\n', '    uint256 _addressesLength;\n', '\n', '    // ints\n', '    uint256 private _totalSupply;\n', '    uint256 private _unitsPerToken;\n', '    uint256 private _initialPoolToken;\n', '    uint256 private _poolBalance;\n', '    uint256 private _poolFactor;\n', '\n', '    uint256 private _period;\n', '    uint256 private _timelockkeeping;\n', '    uint256 private _timelockstopinflations;\n', '\n', '    // bools\n', '    bool private _lockTransfer;\n', '    bool private _lockkeeping;\n', '\n', '\n', '    constructor() public override {\n', '        _owner = msg.sender;\n', '\n', '        // set toal supply = initial supply\n', '        _totalSupply = INITIAL_SUPPLY;\n', '        // set units per token based on total supply\n', '        _unitsPerToken = TOTAL_UNITS.div(_totalSupply);\n', '\n', '        // set pool balance = TOTAL_UNITS / 100 * POOL_SIZE\n', '        _poolBalance = TOTAL_UNITS / 100 * POOL_SIZE;\n', '        // set initial pool token balance\n', '        _initialPoolToken = _poolBalance.div(_unitsPerToken);\n', '        // set initial pool factor\n', '        _poolFactor = INIT_POOL_FACTOR;\n', '\n', '        // set owner balance\n', '        _balances[_owner] = TOTAL_UNITS - _poolBalance;\n', '\n', '        // init locks & set defaults\n', '        _lockTransfer = true;\n', '        _lockkeeping = true;\n', '\n', '        emit Transfer(address(0x0), _owner, _totalSupply.sub(_initialPoolToken));\n', '    }\n', '\n', '\n', '    function whitelistAdd(address addr) external onlyOwner {\n', '        _whitelist[addr] = true;\n', '        emit LogWhitelisted(addr);\n', '    }\n', '\n', '    // main unlock function\n', '    // 1. set period\n', '    // 2. set timelocks\n', '    // 3. allow token transfer\n', '    function unlock() external onlyOwner {\n', '        require(_period == 0, "contract is unlocked");\n', '        _period = 1;\n', '        _timelockkeeping = now.add(TIMELOCK_TIME);\n', '        _timelockstopinflations = now.add(TIMELOCK_TIME);\n', '        _lockTransfer = false;\n', '        _lockkeeping = false;\n', '        emit LogUnlocked(block.timestamp);\n', '    }\n', '\n', '\n', '    // stopinflations stuff\n', '    function stopinflations() external onlyOwner {\n', '        require(_lockTransfer == false, "contract is locked");\n', '        require(_timelockstopinflations < now, "also stopinflations need time to rest");\n', '        _timelockstopinflations = now.add(TIMELOCK_TIME);\n', '        _totalSupply = _totalSupply.sub(_totalSupply.div(100));\n', '        _unitsPerToken = TOTAL_UNITS.div(_totalSupply);\n', '        emit Logstopinflations(_totalSupply);\n', '    }\n', '\n', '    function getSnapshotBalance(address addr) private view returns (uint256) {\n', '        if (_keepers[addr].snapshotPeriod < _period) {\n', '            return _balances[addr];\n', '        }\n', '        return  _keepers[addr].snapshotBalance;\n', '    }\n', '\n', '    // keep\n', '    function keep() external onlyOwner {\n', '        require(_lockTransfer == false, "contract is locked");\n', '        require(_timelockkeeping < now, "timelock is active");\n', '        _timelockkeeping = now.add(TIMELOCK_TIME);\n', '\n', '        // need the sum of all keeper balances to calculate share in keep\n', '        uint256 totalkeepersBalance = 0;\n', '\n', '        // check if address is candidate\n', '        address[] memory candidates = new address[](_addressesLength);\n', '        uint256 candidatesLength = 0;\n', '        for (uint256 i = 0; i < _addressesLength; i++) {\n', '            address addr = _addresses[i];\n', '            if(addr == address(0x0)) {\n', '                continue;\n', '            }\n', '            uint256 snapbalance = getSnapshotBalance(addr);\n', '            // dont put it on the list if too low\n', '            if (snapbalance < keep_MIN_BALANCE.mul(_unitsPerToken)) {\n', '                continue;\n', '            }\n', '            // put it on the list if on of both conditions are true\n', '            // 1. snapshot is old [no coins moved]\n', '            // 2. balance >= snapshot balance [no tokens out]\n', '            if ((_keepers[addr].snapshotPeriod < _period) || (_balances[addr] >= snapbalance)) {\n', '                candidates[candidatesLength] = addr;\n', '                candidatesLength++;\n', '            }\n', '        }\n', '\n', '        uint256 estimatedkeepers = 0;\n', '        uint256 keepedUnits = 0;\n', '        uint256 availableUnits = _initialPoolToken.div(_poolFactor).mul(_unitsPerToken);\n', '        if(candidatesLength > 0) {\n', '            estimatedkeepers = 1;\n', '            // get lucky candidates keepers\n', '            uint256 randomNumber = uint256(keccak256(abi.encodePacked((_addressesLength + _poolBalance + _period), now, blockhash(block.number))));\n', '            uint256 randomIndex = randomNumber % 10;\n', '            uint256 randomOffset = 0;\n', '            if (candidatesLength >= 10) {\n', '                estimatedkeepers = (candidatesLength - randomIndex - 1) / 10 + 1;\n', '            }\n', '            if (estimatedkeepers > keep_ADDRESS_LIMIT) {\n', '                randomOffset = (randomNumber / 100) % estimatedkeepers;\n', '                estimatedkeepers = keep_ADDRESS_LIMIT;\n', '            }\n', '            address[] memory keepers = new address[](estimatedkeepers);\n', '            uint256 keepersLength = 0;\n', '            for (uint256 i = 0; i < estimatedkeepers; i++) {\n', '                address addr = candidates[(randomIndex + (i + randomOffset) * 10) % candidatesLength];\n', '                keepers[keepersLength] = addr;\n', '                keepersLength++;\n', '                totalkeepersBalance = totalkeepersBalance.add(getSnapshotBalance(addr).div(_unitsPerToken));\n', '            }\n', '\n', '\n', '            for (uint256 i = 0; i < keepersLength; i++) {\n', '                address addr = keepers[i];\n', '                uint256 snapbalance = getSnapshotBalance(addr);\n', '                uint256 tokensToAdd = availableUnits.div(_unitsPerToken).mul(snapbalance.div(_unitsPerToken)).div(totalkeepersBalance);\n', '                uint256 unitsToAdd = tokensToAdd.mul(_unitsPerToken);\n', '                _balances[addr] = _balances[addr].add(unitsToAdd);\n', '                keepedUnits = keepedUnits.add(unitsToAdd);\n', '            }\n', '\n', '            if ((keepedUnits < availableUnits) && (keepersLength > 0)) {\n', '                address addr = keepers[keepersLength-1];\n', '                uint256 rest = availableUnits.sub(keepedUnits);\n', '                _balances[addr] = _balances[addr].add(rest);\n', '                keepedUnits = keepedUnits.add(rest);\n', '            }\n', '            if (keepedUnits > 0) {\n', '                _poolBalance = _poolBalance.sub(keepedUnits);\n', '            }\n', '        }\n', '\n', '        uint256 keepedTokens = 0;\n', '        if(keepedUnits > 0) {\n', '            keepedTokens = keepedUnits.div(_unitsPerToken);\n', '        }\n', '        emit Logkeep(_period, candidatesLength, estimatedkeepers, keepedTokens, availableUnits);\n', '\n', '        if(_period % HALVING_PERIOD == 0) {\n', '            _poolFactor = _poolFactor.add(_poolFactor);\n', '        }\n', '        _period = _period.add(1);\n', '    }\n', '\n', '\n', '    function calcShareInTokens(uint256 snapshotToken, uint256 totalkeepersToken, uint256 availableToken) private pure returns(uint256) {\n', '        return availableToken.mul(snapshotToken).div(totalkeepersToken);\n', '    }\n', '\n', '    function isOwnerOrWhitelisted(address addr) private view returns (bool) {\n', '        if (addr == _owner) {\n', '            return true;\n', '        }\n', '        return _whitelist[addr];\n', '    }\n', '\n', '    function acquaintAddress(address candidate) private returns (bool) {\n', '        if((_knownAddresses[candidate] != true) && (candidate != _owner)) {\n', '            _knownAddresses[candidate] = true;\n', '            _addresses[_addressesLength] = candidate;\n', '            _addressesLength++;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '\n', '    function period() public view returns (uint256) {\n', '        return _period;\n', '    }\n', '\n', '    function poolBalance() public view returns (uint256) {\n', '        return _poolBalance.div(_unitsPerToken);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account].div(_unitsPerToken);\n', '    }\n', '\n', '    function processkeepersBeforeTransfer(address from, address to, uint256 units) private {\n', '\n', '        // process sender\n', '        // if we have no current snapshot, make it\n', '        // snapshot is balance before sending\n', '        if(_keepers[from].snapshotPeriod < _period) {\n', '            _keepers[from].snapshotBalance = _balances[from];\n', '            _keepers[from].snapshotPeriod = _period;\n', '        } else {\n', '            // snapshot is same period, set balance reduced by units (= current balance)\n', '            _keepers[from].snapshotBalance = _balances[from].sub(units);\n', '        }\n', '\n', '        // process receiver\n', '        // if we have no current snapshot, make it\n', '        // snapshot is balance before receiving\n', '        if(_keepers[to].snapshotPeriod < _period) {\n', '            _keepers[to].snapshotBalance = _balances[to];\n', '            _keepers[to].snapshotPeriod = _period;\n', '        } else {\n', '            // snapshot is same period, nothing to do -> new tokens have to rest at least 1 period\n', '            // later in keeping we have also to check the snapshort period and update the balance if < to take care of no transfer/no updated snapshot balance situation\n', '        }\n', '    }\n', '\n', '    function transfer(address recipient, uint256 value) public validRecipient(recipient) returns (bool) {\n', "        require(((_lockTransfer == false) || isOwnerOrWhitelisted(msg.sender)), 'token transfer is locked');\n", '        uint256 units = value.mul(_unitsPerToken);\n', '        uint256 newSenderBalance = _balances[msg.sender].sub(units);\n', '        processkeepersBeforeTransfer(msg.sender, recipient, units);\n', '        _balances[msg.sender] = newSenderBalance;\n', '        _balances[recipient] = _balances[recipient].add(units);\n', '        acquaintAddress(recipient);\n', '        emit Transfer(msg.sender, recipient, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value) public validRecipient(to) returns (bool) {\n', "        require(((_lockTransfer == false) || isOwnerOrWhitelisted(msg.sender)), 'token transfer is locked');\n", '        _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);\n', '        uint256 units = value.mul(_unitsPerToken);\n', '        processkeepersBeforeTransfer(from, to, units);\n', '        uint256 newSenderBalance = _balances[from].sub(units);\n', '        _balances[from] = newSenderBalance;\n', '        _balances[to] = _balances[to].add(units);\n', '        acquaintAddress(to);\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _allowances[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _allowances[msg.sender][spender] = _allowances[msg.sender][spender].add(addedValue);\n', '        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        uint256 oldValue = _allowances[msg.sender][spender];\n', '        if (subtractedValue >= oldValue) {\n', '            _allowances[msg.sender][spender] = 0;\n', '        } else {\n', '            _allowances[msg.sender][spender] = oldValue.sub(subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '}']