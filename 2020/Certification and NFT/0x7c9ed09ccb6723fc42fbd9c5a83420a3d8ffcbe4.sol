['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-23\n', '*/\n', '\n', 'pragma solidity ^0.5.1;\n', '\n', 'contract Earth {\n', '\n', "    // Look again at that dot. That's here. That's home. That's us.\n", '    // On it everyone you love, everyone you know, everyone you ever\n', '    // heard of, every human being who ever was, lived out their lives.\n', '    // The aggregate of our joy and suffering, thousands of confident\n', '    // religions, ideologies, and economic doctrines, every hunter and\n', '    // forager, every hero and coward, every creator and destroyer of\n', '    // civilization, every king and peasant, every young couple in love,\n', '    // every mother and father, hopeful child, inventor and explorer,\n', '    // every teacher of morals, every corrupt politician, every "superstar",\n', '    // every "supreme leader", every saint and sinner in the history of\n', '    // our species lived there — on a mote of dust suspended in a sunbeam.\n', '    // — Carl Sagan\n', '\n', '\n', '    constructor() public {}\n', '\n', '    event CreateID(\n', '        bytes32 indexed name,\n', '        address primary,\n', '        address recovery,\n', '        uint64 number\n', '    );\n', '\n', '    event SetPrimary(\n', '        bytes32 indexed name,\n', '        address primary\n', '    );\n', '\n', '    event SetRecovery(\n', '        bytes32 indexed name,\n', '        address recovery\n', '    );\n', '\n', '    event Recover(\n', '        bytes32 indexed name,\n', '        address primary,\n', '        address recovery\n', '    );\n', '\n', '    struct ID {\n', '        address primary;\n', '        address recovery;\n', '        uint64 joined;\n', '        uint64 number;\n', '    }\n', '\n', '\n', '    /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */\n', '    \n', '\n', '    mapping(address => bytes32) public associate;\n', '\n', '    mapping(address => bytes32) public directory;\n', '\n', '    mapping(uint64 => bytes32) public index;\n', '\n', '    mapping(bytes32 => ID) public citizens;\n', '\n', '    uint64 public population;\n', '\n', '\n', '    /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */\n', '\n', '\n', '    function getPrimary(bytes32 name) public view returns (address) {\n', '        return citizens[name].primary;\n', '    }\n', '\n', '    function getRecovery(bytes32 name) public view returns (address) {\n', '        return citizens[name].recovery;\n', '    }\n', '\n', '    function getJoined(bytes32 name) public view returns (uint64) {\n', '        return citizens[name].joined;\n', '    }\n', '\n', '    function getNumber(bytes32 name) public view returns (uint64) {\n', '        return citizens[name].number;\n', '    }\n', '\n', '    function addressAvailable(address addr) public view returns (bool) {\n', '        return associate[addr] == bytes32(0x0);\n', '    }\n', '\n', '    function nameAvailable(bytes32 name) public view returns (bool) {\n', '        return getPrimary(name) == address(0x0);\n', '    }\n', '\n', '    function lookupNumber(uint64 number) public view returns (address, address, uint64, bytes32) {\n', '        bytes32 name = index[number];\n', '        ID storage id = citizens[name];\n', '        return (id.primary, id.recovery, id.joined, name);\n', '    }\n', '\n', '    function authorize() public view returns (bytes32) {\n', '\n', '        // Get the name linked to the sender address\n', '        bytes32 name = directory[msg.sender];\n', '\n', '        // Revert if not linked to any name\n', '        require(name != bytes32(0x0));\n', '\n', '        // Return authorized name\n', '        return name;\n', '    }\n', '\n', '\n', '    /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */\n', '    \n', '\n', '    function createID(bytes32 name, address recovery) public {\n', '        \n', '        // Ensure that name was provided\n', '        require(name != bytes32(0x0));\n', '\n', '        // Ensure that name is available\n', '        require(nameAvailable(name));\n', '\n', '        // Ensure sender has never been linked\n', '        require(addressAvailable(msg.sender));\n', '\n', '        // Primary and recovery cannot be the same\n', '        require(recovery != msg.sender);\n', '\n', '        // If a valid recovery address was provided,\n', '        // check available and associate with name\n', '        if (recovery != address(0x0)) { \n', '            require(addressAvailable(recovery));\n', '            associate[recovery] = name;\n', '        }\n', '\n', '        // Associate sender address with name\n', '        // and create new directory entry\n', '        associate[msg.sender] = name;\n', '        directory[msg.sender] = name;\n', '\n', '        // Increment the population size\n', '        population += 1;\n', '\n', '        // Create the ID model\n', '        citizens[name] = ID({\n', '            primary: msg.sender,\n', '            recovery: recovery,\n', '            joined: uint64(now),\n', '            number: population\n', '        });\n', '\n', '        // Map number to name\n', '        index[population] = name;\n', '\n', '        emit CreateID(name, msg.sender, recovery, population);\n', '    }\n', '\n', '    function setPrimary(bytes32 name, address primary) public {\n', '        \n', '        // Get the ID model\n', '        ID storage id = citizens[name];\n', '\n', '        // Ensure id belongs to sender\n', '        require(id.primary == msg.sender);\n', '\n', '        // Ensure new address provided\n', '        require(primary != address(0x0));\n', '\n', '        // Ensure new address available\n', '        require(addressAvailable(primary));\n', '\n', '        // Associate new address with name\n', '        // and create new directory entry\n', '        associate[primary] = name;\n', '        directory[primary] = name;\n', '\n', '        // Old address no longer points to name\n', '        directory[msg.sender] = bytes32(0x0);\n', '\n', '        // Update ID model\n', '        id.primary = primary;\n', '        \n', '        emit SetPrimary(name, primary);\n', '    }\n', '\n', '    function setRecovery(bytes32 name, address recovery) public {\n', '        \n', '        // Get the ID model\n', '        ID storage id = citizens[name];\n', '        \n', '        // Ensure ID belongs to sender\n', '        require(id.primary == msg.sender);\n', '\n', '        // Ensure recovery address provided\n', '        require(recovery != address(0x0));\n', '        \n', '        // Ensure recovery not already set\n', '        require(id.recovery == address(0x0));\n', '\n', '        // Ensure recovery address available\n', '        require(addressAvailable(recovery));\n', '        \n', '        // Associate recovery with name\n', '        associate[recovery] = name;\n', '        \n', '        // Update ID model\n', '        id.recovery = recovery;\n', '\n', '        emit SetRecovery(name, recovery);\n', '    }\n', '\n', '    function recover(bytes32 name, address newRecovery) public {\n', '\n', '        // Get the ID model\n', '        ID storage id = citizens[name];\n', '\n', '        // Ensure recovery address is sender\n', '        require(id.recovery == msg.sender);\n', '        \n', '        // If a new recovery address was provided\n', '        // and is available, associate with name\n', '        if (newRecovery != address(0x0)) {\n', '            require(addressAvailable(newRecovery));\n', '            associate[newRecovery] = name;\n', '        }\n', '\n', '        // Set new recovery address (may be zero)\n', '        id.recovery = newRecovery;\n', '\n', '        // Existing primary no longer points to anything\n', '        directory[id.primary] = bytes32(0x0);\n', '\n', '        // Current recovery address now points to\n', '        // name, replacing former primary address\n', '        directory[msg.sender] = name;\n', '        id.primary = msg.sender;\n', '\n', '        emit Recover(name, msg.sender, newRecovery);\n', '    }\n', '}']