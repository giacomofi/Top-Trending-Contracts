['pragma solidity 0.5.15;\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Owner {\n', '\n', '    address public OwnerAddress;\n', '\n', '    modifier isOwner(){\n', '        require( msg.sender == OwnerAddress);\n', '        _;\n', '    }\n', '\n', '    function changeOwner ( address _newAddress )\n', '        isOwner\n', '        public\n', '        returns ( bool )\n', '    {\n', '        OwnerAddress = _newAddress;\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'contract ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    string public desc;\n', '    uint8 public decimals;\n', '\n', '    mapping (address => uint256) _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) _allowances;\n', '\n', '    uint256 _totalSupply;\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `TokenOwner` is set by\n', '     * a call to `approve`. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed TokenOwner, address indexed spender, uint256 value);\n', '\n', '    /**\n', '     * @dev See `IERC20.totalSupply`.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.balanceOf`.\n', '     */\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.transfer`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.allowance`.\n', '     */\n', '    function allowance(address TokenOwner, address spender) public view returns (uint256) {\n', '        return _allowances[TokenOwner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.approve`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See `IERC20.transferFrom`.\n', '     *\n', '     * Emits an `Approval` event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of `ERC20`;\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `value`.\n', "     * - the caller must have allowance for `sender`'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        require(_allowances[sender][msg.sender] >= amount, "ERC20: Not enough in deligation");\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to `approve` that can be used as a mitigation for\n', '     * problems described in `IERC20.approve`.\n', '     *\n', '     * Emits an `Approval` event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to `approve` that can be used as a mitigation for\n', '     * problems described in `IERC20.approve`.\n', '     *\n', '     * Emits an `Approval` event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to `transfer`, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a `Transfer` event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        require(_balances[sender] >= amount, "ERC20: Not Enough balance");\n', '\n', '        _balances[sender] = _balances[sender].sub(amount);\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a `Transfer` event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Destroys `amount` tokens from `account`, reducing the\n', '    * total supply.\n', '    *\n', '    * Emits a `Transfer` event with `to` set to the zero address.\n', '    *\n', '    * Requirements\n', '    *\n', '    * - `account` cannot be the zero address.\n', '    * - `account` must have at least `amount` tokens.\n', '    */\n', '    function _burn(address account, uint256 value) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _totalSupply = _totalSupply.sub(value);\n', '        _balances[account] = _balances[account].sub(value);\n', '        emit Transfer(account, address(0), value);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `TokenOwner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an `Approval` event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `TokenOwner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address TokenOwner, address spender, uint256 value) internal {\n', '        require(TokenOwner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[TokenOwner][spender] = value;\n', '        emit Approval(TokenOwner, spender, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n', "     * from the caller's allowance.\n", '     *\n', '     * See `_burn` and `_approve`.\n', '     */\n', '    function _burnFrom(address account, uint256 amount) internal {\n', '        _burn(account, amount);\n', '        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n', '    }\n', '}\n', '\n', '\n', 'contract IBTCToken is ERC20 , Owner{\n', '\n', '    address public TAddr;\n', '\n', '    modifier isTreasury(){\n', '        require(msg.sender == TAddr);\n', '        _;\n', '    }\n', '\n', '    constructor(  )\n', '        public\n', '    {\n', '        name = "IBTC Blockchain";\n', '        symbol = "IBTC";\n', '        desc = "IBTC Blockchain";\n', '        decimals = 18;\n', '        OwnerAddress = msg.sender;\n', '    }\n', '\n', '    function setTreasury ( address _TAddres)\n', '        isOwner\n', '        public\n', '        returns ( bool )\n', '    {\n', '        TAddr = _TAddres;\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function mint(address recipient, uint256 amount)\n', '        isTreasury\n', '        public\n', '        returns (bool result )\n', '    {\n', '        _mint( recipient , amount );\n', '        result = true;\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount)\n', '        public\n', '        returns (bool result )\n', '    {\n', '        _transfer(msg.sender, recipient , amount );\n', '        result = true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        require(_allowances[sender][msg.sender] >= amount, "ERC20: Not enough in deligation");\n', '        _transfer(msg.sender, recipient , amount );\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n', '        return true;\n', '    }\n', '\n', '\n', '    function allowance(address TokenOwner, address spender) public view returns (uint256) {\n', '        return _allowances[TokenOwner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Treasury_ds is Owner {\n', '    using SafeMath for uint256;\n', '\n', '    bool public contractState;\n', '\n', '    IBTCToken Token;\n', '\n', '    address public TokenAddr;\n', '\n', '    address payable public Owner1;\n', '\n', '    address payable public Owner2;\n', '\n', '    address masterAddr;\n', '\n', '    uint256 public Rate;\n', '\n', '    bool public enabled;\n', '\n', '    mapping ( uint256 => LLimit ) public Levels;\n', '\n', '    struct LLimit{\n', '        uint256 percent;\n', '        uint256 salesLimit;\n', '        uint256 bonus;\n', '    }\n', '\n', '    uint256 public MaxLevel;\n', '\n', '//    Child -> Parent Mapping\n', '    mapping ( address => address ) public PCTree;\n', '\n', '    mapping ( address => userData ) public userLevel;\n', '\n', '    struct userData{\n', '        uint256 level;\n', '        uint256 sales;\n', '        uint256 share;\n', '        uint256 bonus;\n', '    }\n', '\n', '    modifier isInActive(){\n', '        require(contractState == false);\n', '        _;\n', '    }\n', '\n', '    modifier isActive(){\n', '        require(contractState == true);\n', '        _;\n', '    }\n', '\n', '    modifier isSameLength ( uint256 _s1 , uint256 _s2 ){\n', '        require(_s1 == _s2);\n', '        _;\n', '    }\n', '\n', '    modifier isVaildClaim( uint256 _amt ){\n', '        require( userLevel[msg.sender].share >= _amt );\n', '        _;\n', '    }\n', '\n', '    modifier isVaildReferer( address _ref ){\n', '        require( userLevel[_ref].level != 0 );\n', '        _;\n', '    }\n', '\n', '    modifier isSaleClose ( uint256 _amt ){\n', '        require( enabled == true );\n', '        _;\n', '    }\n', '\n', '    modifier isValidTOwner(){\n', '        require(( Owner1 == msg.sender ) || (Owner2 == msg.sender));\n', '        _;\n', '    }\n', '\n', '    event puchaseEvent( address indexed _buyer , address indexed _referer , uint256 _value , uint256 _tokens );\n', '\n', '    event claimEvent( address indexed _buyer ,  uint256 _value , uint256 _pendingShare );\n', '\n', '}\n', '\n', 'contract Treasury is Treasury_ds{\n', '\n', '\n', '    constructor( address _TAddr )\n', '        public\n', '    {\n', '        Token = IBTCToken( _TAddr );\n', '        TokenAddr = _TAddr;\n', '        OwnerAddress = msg.sender;\n', '        contractState = false;\n', '    }\n', '\n', '    function setLevels( uint256[] memory _percent , uint256[] memory _salesLimit , uint256[] memory _bonus )\n', '        isSameLength( _salesLimit.length , _percent.length )\n', '        internal\n', '    {\n', '        for (uint i=0; i<_salesLimit.length; i++) {\n', '            Levels[i+1] = LLimit( _percent[i] ,_salesLimit[i] , _bonus[i] );\n', '        }\n', '    }\n', '\n', '    function setAccount ( address _child , address _parent , uint256 _level , uint256 _sales , uint256 _share , uint256 _bonus , uint256 _amt )\n', '        isInActive\n', '        isOwner\n', '        public\n', '        returns ( bool )\n', '    {\n', '        userLevel[_child] = userData(_level , _sales , _share , _bonus );\n', '        PCTree[_child] = _parent;\n', '        Token.mint( _child , _amt );\n', '        return true;\n', '    }\n', '\n', '    function setupTreasury ( uint256 _rate , uint256[] memory _percent ,uint256[] memory _salesLimit , uint256[] memory _bonus , address payable _owner1 , address payable _owner2 )\n', '        isInActive\n', '        isOwner\n', '        public\n', '        returns ( bool )\n', '    {\n', '        enabled = true;\n', '        Rate = _rate;\n', '        MaxLevel = _salesLimit.length;\n', '        setLevels( _percent , _salesLimit , _bonus );\n', '        masterAddr = address(this);\n', '        PCTree[masterAddr] = address(0);\n', '        Owner1 = _owner1;\n', '        Owner2 = _owner2;\n', '        userLevel[masterAddr].level = MaxLevel;\n', '        contractState = true;\n', '        return true;\n', '    }\n', '\n', '    function calcRate ( uint256 _value )\n', '        public\n', '        view\n', '        returns ( uint256 )\n', '    {\n', '        return _value.mul( 10**18 ).div( Rate );\n', '    }\n', '\n', '    function LoopFx ( address _addr , uint256 _token ,  uint256 _value , uint256 _shareRatio )\n', '        internal\n', '        returns ( uint256 value )\n', '    {\n', '        userLevel[ _addr ].sales = userLevel[ _addr ].sales.add( _token );\n', '        if( _shareRatio < Levels[ userLevel[ _addr ].level ].percent ){\n', '            uint256 diff = Levels[ userLevel[ _addr ].level ].percent.sub(_shareRatio);\n', '            userLevel[ _addr ].share = userLevel[ _addr ].share.add( _value.mul(diff).div(10000) );\n', '            value = Levels[ userLevel[ _addr ].level ].percent;\n', '        }else if( _shareRatio == Levels[ userLevel[ _addr ].level ].percent ){\n', '            value = Levels[ userLevel[ _addr ].level ].percent;\n', '        }\n', '        return value;\n', '    }\n', '\n', '    function LevelChange ( address _addr )\n', '        internal\n', '    {\n', '        uint256 curLevel = userLevel[_addr ].level;\n', '        while( curLevel <= MaxLevel){\n', '            if( ( userLevel[ _addr ].sales < Levels[ curLevel ].salesLimit ) ){\n', '                break;\n', '            }else{\n', '                userLevel[_addr].bonus = userLevel[_addr].bonus.add(Levels[ curLevel ].bonus);\n', '                userLevel[_addr ].level = curLevel;\n', '            }\n', '            curLevel = curLevel.add(1);\n', '        }\n', '    }\n', '\n', '    function purchase ( address _referer )\n', '        isActive\n', '        isVaildReferer( _referer )\n', '        payable\n', '        public\n', '        returns ( bool )\n', '    {\n', '        address Parent;\n', '        uint256 cut = 0;\n', '        uint256 tokens = calcRate(msg.value);\n', '        uint256 lx = 0;\n', '        bool overflow = false;\n', '        iMint( msg.sender , tokens);\n', '        if( userLevel[ msg.sender ].level == 0 ){\n', '            userLevel[ msg.sender ].level = 1;\n', '        }\n', '        if( PCTree[msg.sender] == address(0)){\n', '            Parent = _referer;\n', '            PCTree[msg.sender] = Parent;\n', '        }else{\n', '            Parent = PCTree[msg.sender];\n', '        }\n', '        while( lx < 100 ){\n', '            lx = lx.add(1);\n', '            cut = LoopFx( Parent , tokens , msg.value , cut );\n', '            LevelChange( Parent );\n', '            if( PCTree[ Parent ] == address(0)){\n', '                break;\n', '            }\n', '            Parent = PCTree[ Parent ];\n', '            if( lx == 100){\n', '                overflow = true;\n', '            }\n', '        }\n', '        if( overflow ){\n', '            cut = LoopFx( masterAddr , tokens , msg.value , cut );\n', '        }\n', '        emit puchaseEvent( msg.sender , PCTree[msg.sender] , msg.value , tokens );\n', '        return true;\n', '    }\n', '\n', '    function iMint ( address _addr , uint256 _value )\n', '        isSaleClose( _value )\n', '        internal\n', '    {\n', '        Token.mint( _addr , _value );\n', '    }\n', '\n', '    function claim (uint256 _amt)\n', '        isActive\n', '        isVaildClaim( _amt )\n', '        payable\n', '        public\n', '        returns ( bool )\n', '    {\n', '        userLevel[ msg.sender ].share = userLevel[ msg.sender ].share.sub( _amt );\n', '        Token.mint( msg.sender , userLevel[ msg.sender ].bonus );\n', '        userLevel[ msg.sender ].bonus = 0;\n', '        msg.sender.transfer( _amt );\n', '        emit claimEvent( msg.sender , _amt , userLevel[ msg.sender ].share );\n', '        return true;\n', '    }\n', '\n', '    function claimOwner ()\n', '        isActive\n', '        isValidTOwner\n', '        public\n', '        payable\n', '        returns ( bool )\n', '    {\n', '        uint256 _amt  = userLevel[ address(this) ].share.div(2);\n', '        userLevel[ address(this) ].share = 0;\n', '        Owner1.transfer( _amt );\n', '        Owner2.transfer( _amt );\n', '        emit claimEvent( Owner1 , _amt , userLevel[ address(this) ].share );\n', '        emit claimEvent( Owner2 , _amt , userLevel[ address(this) ].share );\n', '        return true;\n', '    }\n', '\n', '    function setRate ( uint256 _rate )\n', '        isOwner\n', '        public\n', '        returns ( bool )\n', '    {\n', '        Rate = _rate;\n', '        return true;\n', '    }\n', '\n', '    function enableSales ( )\n', '        isOwner\n', '        public\n', '        returns ( bool )\n', '    {\n', '        enabled = true;\n', '        return true;\n', '    }\n', '    function disableSales ( )\n', '        isOwner\n', '        public\n', '        returns ( bool )\n', '    {\n', '        enabled = false;\n', '        return true;\n', '    }\n', '\n', '    function viewStatus( address _addr )\n', '        view\n', '        public\n', '        returns ( uint256 _level , uint256 _sales , uint256 _claim , uint256 _bonus )\n', '    {\n', '        _level = userLevel[ _addr ].level;\n', '        _sales = userLevel[ _addr ].sales;\n', '        _claim = userLevel[ _addr ].share;\n', '        _bonus = userLevel[ _addr ].bonus;\n', '    }\n', '\n', '    function checkRef ( address _ref)\n', '        public\n', '        view\n', '        returns ( bool )\n', '    {\n', '        return ( userLevel[_ref].level != 0 );\n', '    }\n', '\n', '}']