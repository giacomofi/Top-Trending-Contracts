['// File: contracts/interfaces/IERC20.sol\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' * From https://github.com/OpenZeppelin/openzeppelin-contracts\n', ' */\n', 'interface IERC20 {\n', '  /**\n', '   * @dev Returns the amount of tokens in existence.\n', '   */\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the amount of tokens owned by `account`.\n', '   */\n', '  function balanceOf(address account) external view returns (uint256);\n', '\n', '  /**\n', "   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '   *\n', '   * Returns a boolean value indicating whether the operation succeeded.\n', '   *\n', '   * Emits a {Transfer} event.\n', '   */\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '  /**\n', '   * @dev Returns the remaining number of tokens that `spender` will be\n', '   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '   * zero by default.\n', '   *\n', '   * This value changes when {approve} or {transferFrom} are called.\n', '   */\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '  /**\n', "   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '   *\n', '   * Returns a boolean value indicating whether the operation succeeded.\n', '   *\n', '   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '   * that someone may use both the old and the new allowance by unfortunate\n', '   * transaction ordering. One possible solution to mitigate this race\n', "   * condition is to first reduce the spender's allowance to 0 and set the\n", '   * desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   *\n', '   * Emits an {Approval} event.\n', '   */\n', '  function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '  /**\n', '   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "   * allowance mechanism. `amount` is then deducted from the caller's\n", '   * allowance.\n', '   *\n', '   * Returns a boolean value indicating whether the operation succeeded.\n', '   *\n', '   * Emits a {Transfer} event.\n', '   */\n', '  function transferFrom(\n', '    address sender,\n', '    address recipient,\n', '    uint256 amount\n', '  ) external returns (bool);\n', '\n', '  /**\n', '   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '   * another (`to`).\n', '   *\n', '   * Note that `value` may be zero.\n', '   */\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  /**\n', '   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '   * a call to {approve}. `value` is the new allowance.\n', '   */\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/interfaces/IStakedAave.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IStakedAave {\n', '  function stake(address to, uint256 amount) external;\n', '\n', '  function redeem(address to, uint256 amount) external;\n', '\n', '  function cooldown() external;\n', '\n', '  function claimRewards(address to, uint256 amount) external;\n', '}\n', '\n', '// File: contracts/interfaces/ITransferHook.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface ITransferHook {\n', '    function onTransfer(address from, address to, uint256 amount) external;\n', '}\n', '\n', '// File: contracts/lib/Context.sol\n', '\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', ' * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\n', ' * Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal virtual view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal virtual view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IERC20Detailed.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/**\n', ' * @dev Interface for ERC20 including metadata\n', ' **/\n', 'interface IERC20Detailed is IERC20 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts/lib/SafeMath.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', ' * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\n', " * Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', "        require(c >= a, 'SafeMath: addition overflow');\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        return sub(a, b, 'SafeMath: subtraction overflow');\n", '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', "        require(c / a == b, 'SafeMath: multiplication overflow');\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        return div(a, b, 'SafeMath: division by zero');\n", '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        return mod(a, b, 'SafeMath: modulo by zero');\n", '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ERC20.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20\n', ' * @notice Basic ERC20 implementation\n', ' * @author Aave\n', ' **/\n', 'contract ERC20 is Context, IERC20, IERC20Detailed {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) private _balances;\n', '  mapping(address => mapping(address => uint256)) private _allowances;\n', '  uint256 private _totalSupply;\n', '  string private _name;\n', '  string private _symbol;\n', '  uint8 private _decimals;\n', '\n', '  constructor(\n', '    string memory name,\n', '    string memory symbol,\n', '    uint8 decimals\n', '  ) public {\n', '    _name = name;\n', '    _symbol = symbol;\n', '    _decimals = decimals;\n', '  }\n', '\n', '  /**\n', '   * @return the name of the token\n', '   **/\n', '  function name() public override view returns (string memory) {\n', '    return _name;\n', '  }\n', '\n', '  /**\n', '   * @return the symbol of the token\n', '   **/\n', '  function symbol() public override view returns (string memory) {\n', '    return _symbol;\n', '  }\n', '\n', '  /**\n', '   * @return the decimals of the token\n', '   **/\n', '  function decimals() public override view returns (uint8) {\n', '    return _decimals;\n', '  }\n', '\n', '  /**\n', '   * @return the total supply of the token\n', '   **/\n', '  function totalSupply() public override view returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '\n', '  /**\n', '   * @return the balance of the token\n', '   **/\n', '  function balanceOf(address account) public override view returns (uint256) {\n', '    return _balances[account];\n', '  }\n', '\n', '  /**\n', '   * @dev executes a transfer of tokens from msg.sender to recipient\n', '   * @param recipient the recipient of the tokens\n', '   * @param amount the amount of tokens being transferred\n', '   * @return true if the transfer succeeds, false otherwise\n', '   **/\n', '  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '    _transfer(_msgSender(), recipient, amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev returns the allowance of spender on the tokens owned by owner\n', '   * @param owner the owner of the tokens\n', "   * @param spender the user allowed to spend the owner's tokens\n", "   * @return the amount of owner's tokens spender is allowed to spend\n", '   **/\n', '  function allowance(address owner, address spender)\n', '    public\n', '    virtual\n', '    override\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return _allowances[owner][spender];\n', '  }\n', '\n', '  /**\n', '   * @dev allows spender to spend the tokens owned by msg.sender\n', '   * @param spender the user allowed to spend msg.sender tokens\n', '   * @return true\n', '   **/\n', '  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '    _approve(_msgSender(), spender, amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev executes a transfer of token from sender to recipient, if msg.sender is allowed to do so\n', '   * @param sender the owner of the tokens\n', '   * @param recipient the recipient of the tokens\n', '   * @param amount the amount of tokens being transferred\n', '   * @return true if the transfer succeeds, false otherwise\n', '   **/\n', '  function transferFrom(\n', '    address sender,\n', '    address recipient,\n', '    uint256 amount\n', '  ) public virtual override returns (bool) {\n', '    _transfer(sender, recipient, amount);\n', '    _approve(\n', '      sender,\n', '      _msgSender(),\n', "      _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance')\n", '    );\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev increases the allowance of spender to spend msg.sender tokens\n', '   * @param spender the user allowed to spend on behalf of msg.sender\n', '   * @param addedValue the amount being added to the allowance\n', '   * @return true\n', '   **/\n', '  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev decreases the allowance of spender to spend msg.sender tokens\n', '   * @param spender the user allowed to spend on behalf of msg.sender\n', '   * @param subtractedValue the amount being subtracted to the allowance\n', '   * @return true\n', '   **/\n', '  function decreaseAllowance(address spender, uint256 subtractedValue)\n', '    public\n', '    virtual\n', '    returns (bool)\n', '  {\n', '    _approve(\n', '      _msgSender(),\n', '      spender,\n', '      _allowances[_msgSender()][spender].sub(\n', '        subtractedValue,\n', "        'ERC20: decreased allowance below zero'\n", '      )\n', '    );\n', '    return true;\n', '  }\n', '\n', '  function _transfer(\n', '    address sender,\n', '    address recipient,\n', '    uint256 amount\n', '  ) internal virtual {\n', "    require(sender != address(0), 'ERC20: transfer from the zero address');\n", "    require(recipient != address(0), 'ERC20: transfer to the zero address');\n", '\n', '    _beforeTokenTransfer(sender, recipient, amount);\n', '\n', "    _balances[sender] = _balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance');\n", '    _balances[recipient] = _balances[recipient].add(amount);\n', '    emit Transfer(sender, recipient, amount);\n', '  }\n', '\n', '  function _mint(address account, uint256 amount) internal virtual {\n', "    require(account != address(0), 'ERC20: mint to the zero address');\n", '\n', '    _beforeTokenTransfer(address(0), account, amount);\n', '\n', '    _totalSupply = _totalSupply.add(amount);\n', '    _balances[account] = _balances[account].add(amount);\n', '    emit Transfer(address(0), account, amount);\n', '  }\n', '\n', '  function _burn(address account, uint256 amount) internal virtual {\n', "    require(account != address(0), 'ERC20: burn from the zero address');\n", '\n', '    _beforeTokenTransfer(account, address(0), amount);\n', '\n', "    _balances[account] = _balances[account].sub(amount, 'ERC20: burn amount exceeds balance');\n", '    _totalSupply = _totalSupply.sub(amount);\n', '    emit Transfer(account, address(0), amount);\n', '  }\n', '\n', '  function _approve(\n', '    address owner,\n', '    address spender,\n', '    uint256 amount\n', '  ) internal virtual {\n', "    require(owner != address(0), 'ERC20: approve from the zero address');\n", "    require(spender != address(0), 'ERC20: approve to the zero address');\n", '\n', '    _allowances[owner][spender] = amount;\n', '    emit Approval(owner, spender, amount);\n', '  }\n', '\n', '  function _setName(string memory newName) internal {\n', '    _name = newName;\n', '  }\n', '\n', '  function _setSymbol(string memory newSymbol) internal {\n', '    _symbol = newSymbol;\n', '  }\n', '\n', '  function _setDecimals(uint8 newDecimals) internal {\n', '    _decimals = newDecimals;\n', '  }\n', '\n', '  function _beforeTokenTransfer(\n', '    address from,\n', '    address to,\n', '    uint256 amount\n', '  ) internal virtual {}\n', '}\n', '\n', '// File: contracts/lib/ERC20WithSnapshot.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20WithSnapshot\n', ' * @notice ERC20 including snapshots of balances on transfer-related actions\n', ' * @author Aave\n', ' **/\n', 'contract ERC20WithSnapshot is ERC20 {\n', '\n', '    /// @dev snapshot of a value on a specific block, used for balances\n', '    struct Snapshot {\n', '        uint128 blockNumber;\n', '        uint128 value;\n', '    }\n', '\n', '    mapping (address => mapping (uint256 => Snapshot)) public _snapshots;\n', '    mapping (address => uint256) public _countsSnapshots;\n', '    /// @dev reference to the Aave governance contract to call (if initialized) on _beforeTokenTransfer\n', '    /// !!! IMPORTANT The Aave governance is considered a trustable contract, being its responsibility\n', '    /// to control all potential reentrancies by calling back the this contract\n', '    ITransferHook public _aaveGovernance;\n', '\n', '    event SnapshotDone(address owner, uint128 oldValue, uint128 newValue);\n', '\n', '    constructor(string memory name, string memory symbol, uint8 decimals) public ERC20(name, symbol, decimals) {}\n', '\n', '    function _setAaveGovernance(ITransferHook aaveGovernance) internal virtual {\n', '        _aaveGovernance = aaveGovernance;\n', '    }\n', '\n', '    /**\n', '    * @dev Writes a snapshot for an owner of tokens\n', '    * @param owner The owner of the tokens\n', '    * @param oldValue The value before the operation that is gonna be executed after the snapshot\n', '    * @param newValue The value after the operation\n', '    */\n', '    function _writeSnapshot(address owner, uint128 oldValue, uint128 newValue) internal virtual {\n', '        uint128 currentBlock = uint128(block.number);\n', '\n', '        uint256 ownerCountOfSnapshots = _countsSnapshots[owner];\n', '        mapping (uint256 => Snapshot) storage snapshotsOwner = _snapshots[owner];\n', '\n', '        // Doing multiple operations in the same block\n', '        if (ownerCountOfSnapshots != 0 && snapshotsOwner[ownerCountOfSnapshots.sub(1)].blockNumber == currentBlock) {\n', '            snapshotsOwner[ownerCountOfSnapshots.sub(1)].value = newValue;\n', '        } else {\n', '            snapshotsOwner[ownerCountOfSnapshots] = Snapshot(currentBlock, newValue);\n', '            _countsSnapshots[owner] = ownerCountOfSnapshots.add(1);\n', '        }\n', '\n', '        emit SnapshotDone(owner, oldValue, newValue);\n', '    }\n', '\n', '    /**\n', '    * @dev Writes a snapshot before any operation involving transfer of value: _transfer, _mint and _burn\n', '    * - On _transfer, it writes snapshots for both "from" and "to"\n', '    * - On _mint, only for _to\n', '    * - On _burn, only for _from\n', '    * @param from the from address\n', '    * @param to the to address\n', '    * @param amount the amount to transfer\n', '    */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n', '        if (from == to) {\n', '            return;\n', '        }\n', '\n', '        if (from != address(0)) {\n', '            uint256 fromBalance = balanceOf(from);\n', '            _writeSnapshot(from, uint128(fromBalance), uint128(fromBalance.sub(amount)));\n', '        }\n', '        if (to != address(0)) {\n', '            uint256 toBalance = balanceOf(to);\n', '            _writeSnapshot(to, uint128(toBalance), uint128(toBalance.add(amount)));\n', '        }\n', '\n', '        // caching the aave governance address to avoid multiple state loads\n', '        ITransferHook aaveGovernance = _aaveGovernance;\n', '        if (aaveGovernance != ITransferHook(0)) {\n', '            aaveGovernance.onTransfer(from, to, amount);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Address.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' * From https://github.com/OpenZeppelin/openzeppelin-contracts\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            codehash := extcodehash(account)\n', '        }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', "        require(address(this).balance >= amount, 'Address: insufficient balance');\n", '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', "        (bool success, ) = recipient.call{value: amount}('');\n", "        require(success, 'Address: unable to send value, recipient may have reverted');\n", '    }\n', '}\n', '\n', '// File: contracts/lib/SafeERC20.sol\n', '\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev From https://github.com/OpenZeppelin/openzeppelin-contracts\n', ' * Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '    \n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/utils/VersionedInitializable.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', ' * @title VersionedInitializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' *\n', ' * @author Aave, inspired by the OpenZeppelin Initializable contract\n', ' */\n', 'abstract contract VersionedInitializable {\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    uint256 internal lastInitializedRevision = 0;\n', '\n', '    /**\n', '     * @dev Modifier to use in the initializer function of a contract.\n', '     */\n', '    modifier initializer() {\n', '        uint256 revision = getRevision();\n', '        require(\n', '            revision > lastInitializedRevision,\n', "            'Contract instance has already been initialized'\n", '        );\n', '\n', '        lastInitializedRevision = revision;\n', '\n', '        _;\n', '    }\n', '\n', '    /// @dev returns the revision number of the contract.\n', '    /// Needs to be defined in the inherited class as a constant.\n', '    function getRevision() internal virtual pure returns (uint256);\n', '\n', '    // Reserved storage space to allow for layout changes in the future.\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: contracts/lib/DistributionTypes.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'library DistributionTypes {\n', '  struct AssetConfigInput {\n', '    uint128 emissionPerSecond;\n', '    uint256 totalStaked;\n', '    address underlyingAsset;\n', '  }\n', '\n', '  struct UserStakeInput {\n', '    address underlyingAsset;\n', '    uint256 stakedByUser;\n', '    uint256 totalStaked;\n', '  }\n', '}\n', '\n', '// File: contracts/interfaces/IAaveDistributionManager.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', 'interface IAaveDistributionManager {\n', '  function configureAssets(DistributionTypes.AssetConfigInput[] calldata assetsConfigInput) external;\n', '}\n', '\n', '// File: contracts/stake/AaveDistributionManager.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title AaveDistributionManager\n', ' * @notice Accounting contract to manage multiple staking distributions\n', ' * @author Aave\n', ' **/\n', 'contract AaveDistributionManager is IAaveDistributionManager {\n', '  using SafeMath for uint256;\n', '\n', '  struct AssetData {\n', '    uint128 emissionPerSecond;\n', '    uint128 lastUpdateTimestamp;\n', '    uint256 index;\n', '    mapping(address => uint256) users;\n', '  }\n', '\n', '  uint256 public immutable DISTRIBUTION_END;\n', '\n', '  address public immutable EMISSION_MANAGER;\n', '\n', '  uint8 public constant PRECISION = 18;\n', '\n', '  mapping(address => AssetData) public assets;\n', '\n', '  event AssetConfigUpdated(address indexed asset, uint256 emission);\n', '  event AssetIndexUpdated(address indexed asset, uint256 index);\n', '  event UserIndexUpdated(address indexed user, address indexed asset, uint256 index);\n', '\n', '  constructor(address emissionManager, uint256 distributionDuration) public {\n', '    DISTRIBUTION_END = block.timestamp.add(distributionDuration);\n', '    EMISSION_MANAGER = emissionManager;\n', '  }\n', '\n', '  /**\n', '   * @dev Configures the distribution of rewards for a list of assets\n', '   * @param assetsConfigInput The list of configurations to apply\n', '   **/\n', '  function configureAssets(DistributionTypes.AssetConfigInput[] calldata assetsConfigInput) external override {\n', "    require(msg.sender == EMISSION_MANAGER, 'ONLY_EMISSION_MANAGER');\n", '\n', '    for (uint256 i = 0; i < assetsConfigInput.length; i++) {\n', '      AssetData storage assetConfig = assets[assetsConfigInput[i].underlyingAsset];\n', '\n', '      _updateAssetStateInternal(\n', '        assetsConfigInput[i].underlyingAsset,\n', '        assetConfig,\n', '        assetsConfigInput[i].totalStaked\n', '      );\n', '\n', '      assetConfig.emissionPerSecond = assetsConfigInput[i].emissionPerSecond;\n', '\n', '      emit AssetConfigUpdated(\n', '        assetsConfigInput[i].underlyingAsset,\n', '        assetsConfigInput[i].emissionPerSecond\n', '      );\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Updates the state of one distribution, mainly rewards index and timestamp\n', '   * @param underlyingAsset The address used as key in the distribution, for example sAAVE or the aTokens addresses on Aave\n', "   * @param assetConfig Storage pointer to the distribution's config\n", '   * @param totalStaked Current total of staked assets for this distribution\n', '   * @return The new distribution index\n', '   **/\n', '  function _updateAssetStateInternal(\n', '    address underlyingAsset,\n', '    AssetData storage assetConfig,\n', '    uint256 totalStaked\n', '  ) internal returns (uint256) {\n', '    uint256 oldIndex = assetConfig.index;\n', '    uint128 lastUpdateTimestamp = assetConfig.lastUpdateTimestamp;\n', '\n', '    if (block.timestamp == lastUpdateTimestamp) {\n', '      return oldIndex;\n', '    }\n', '\n', '    uint256 newIndex = _getAssetIndex(\n', '      oldIndex,\n', '      assetConfig.emissionPerSecond,\n', '      lastUpdateTimestamp,\n', '      totalStaked\n', '    );\n', '\n', '    if (newIndex != oldIndex) {\n', '      assetConfig.index = newIndex;\n', '      emit AssetIndexUpdated(underlyingAsset, newIndex);\n', '    }\n', '\n', '    assetConfig.lastUpdateTimestamp = uint128(block.timestamp);\n', '\n', '    return newIndex;\n', '  }\n', '\n', '  /**\n', '   * @dev Updates the state of an user in a distribution\n', "   * @param user The user's address\n", '   * @param asset The address of the reference asset of the distribution\n', '   * @param stakedByUser Amount of tokens staked by the user in the distribution at the moment\n', '   * @param totalStaked Total tokens staked in the distribution\n', '   * @return The accrued rewards for the user until the moment\n', '   **/\n', '  function _updateUserAssetInternal(\n', '    address user,\n', '    address asset,\n', '    uint256 stakedByUser,\n', '    uint256 totalStaked\n', '  ) internal returns (uint256) {\n', '    AssetData storage assetData = assets[asset];\n', '    uint256 userIndex = assetData.users[user];\n', '    uint256 accruedRewards = 0;\n', '\n', '    uint256 newIndex = _updateAssetStateInternal(asset, assetData, totalStaked);\n', '\n', '    if (userIndex != newIndex) {\n', '      if (stakedByUser != 0) {\n', '        accruedRewards = _getRewards(stakedByUser, newIndex, userIndex);\n', '      }\n', '\n', '      assetData.users[user] = newIndex;\n', '      emit UserIndexUpdated(user, asset, newIndex);\n', '    }\n', '\n', '    return accruedRewards;\n', '  }\n', '\n', '  /**\n', '   * @dev Used by "frontend" stake contracts to update the data of an user when claiming rewards from there\n', '   * @param user The address of the user\n', '   * @param stakes List of structs of the user data related with his stake\n', '   * @return The accrued rewards for the user until the moment\n', '   **/\n', '  function _claimRewards(address user, DistributionTypes.UserStakeInput[] memory stakes)\n', '    internal\n', '    returns (uint256)\n', '  {\n', '    uint256 accruedRewards = 0;\n', '\n', '    for (uint256 i = 0; i < stakes.length; i++) {\n', '      accruedRewards = accruedRewards.add(\n', '        _updateUserAssetInternal(\n', '          user,\n', '          stakes[i].underlyingAsset,\n', '          stakes[i].stakedByUser,\n', '          stakes[i].totalStaked\n', '        )\n', '      );\n', '    }\n', '\n', '    return accruedRewards;\n', '  }\n', '\n', '  /**\n', '   * @dev Return the accrued rewards for an user over a list of distribution\n', '   * @param user The address of the user\n', '   * @param stakes List of structs of the user data related with his stake\n', '   * @return The accrued rewards for the user until the moment\n', '   **/\n', '  function _getUnclaimedRewards(address user, DistributionTypes.UserStakeInput[] memory stakes)\n', '    internal\n', '    view\n', '    returns (uint256)\n', '  {\n', '    uint256 accruedRewards = 0;\n', '\n', '    for (uint256 i = 0; i < stakes.length; i++) {\n', '      AssetData storage assetConfig = assets[stakes[i].underlyingAsset];\n', '      uint256 assetIndex = _getAssetIndex(\n', '        assetConfig.index,\n', '        assetConfig.emissionPerSecond,\n', '        assetConfig.lastUpdateTimestamp,\n', '        stakes[i].totalStaked\n', '      );\n', '\n', '      accruedRewards = accruedRewards.add(\n', '        _getRewards(stakes[i].stakedByUser, assetIndex, assetConfig.users[user])\n', '      );\n', '    }\n', '    return accruedRewards;\n', '  }\n', '\n', '  /**\n', "   * @dev Internal function for the calculation of user's rewards on a distribution\n", '   * @param principalUserBalance Amount staked by the user on a distribution\n', '   * @param reserveIndex Current index of the distribution\n', '   * @param userIndex Index stored for the user, representation his staking moment\n', '   * @return The rewards\n', '   **/\n', '  function _getRewards(\n', '    uint256 principalUserBalance,\n', '    uint256 reserveIndex,\n', '    uint256 userIndex\n', '  ) internal pure returns (uint256) {\n', '    return principalUserBalance.mul(reserveIndex.sub(userIndex)).div(10**uint256(PRECISION));\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the next value of an specific distribution index, with validations\n', '   * @param currentIndex Current index of the distribution\n', '   * @param emissionPerSecond Representing the total rewards distributed per second per asset unit, on the distribution\n', '   * @param lastUpdateTimestamp Last moment this distribution was updated\n', '   * @param totalBalance of tokens considered for the distribution\n', '   * @return The new index.\n', '   **/\n', '  function _getAssetIndex(\n', '    uint256 currentIndex,\n', '    uint256 emissionPerSecond,\n', '    uint128 lastUpdateTimestamp,\n', '    uint256 totalBalance\n', '  ) internal view returns (uint256) {\n', '    if (\n', '      emissionPerSecond == 0 ||\n', '      totalBalance == 0 ||\n', '      lastUpdateTimestamp == block.timestamp ||\n', '      lastUpdateTimestamp >= DISTRIBUTION_END\n', '    ) {\n', '      return currentIndex;\n', '    }\n', '\n', '    uint256 currentTimestamp = block.timestamp > DISTRIBUTION_END\n', '      ? DISTRIBUTION_END\n', '      : block.timestamp;\n', '    uint256 timeDelta = currentTimestamp.sub(lastUpdateTimestamp);\n', '    return\n', '      emissionPerSecond.mul(timeDelta).mul(10**uint256(PRECISION)).div(totalBalance).add(\n', '        currentIndex\n', '      );\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the data of an user on a distribution\n', '   * @param user Address of the user\n', '   * @param asset The address of the reference asset of the distribution\n', '   * @return The new index\n', '   **/\n', '  function getUserAssetData(address user, address asset) public view returns (uint256) {\n', '    return assets[asset].users[user];\n', '  }\n', '}\n', '\n', '// File: contracts/stake/StakedToken.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title StakedToken\n', ' * @notice Contract to stake Aave token, tokenize the position and get rewards, inheriting from a distribution manager contract\n', ' * @author Aave\n', ' **/\n', 'contract StakedToken is IStakedAave, ERC20WithSnapshot, VersionedInitializable, AaveDistributionManager {\n', '  using SafeERC20 for IERC20;\n', '\n', '  uint256 public constant REVISION = 1;\n', '\n', '  IERC20 public immutable STAKED_TOKEN;\n', '  IERC20 public immutable REWARD_TOKEN;\n', '  uint256 public immutable COOLDOWN_SECONDS;\n', '\n', '  /// @notice Seconds available to redeem once the cooldown period is fullfilled\n', '  uint256 public immutable UNSTAKE_WINDOW;\n', '\n', '  /// @notice Address to pull from the rewards, needs to have approved this contract\n', '  address public immutable REWARDS_VAULT;\n', '\n', '  mapping(address => uint256) public stakerRewardsToClaim;\n', '  mapping(address => uint256) public stakersCooldowns;\n', '\n', '  event Staked(address indexed from, address indexed onBehalfOf, uint256 amount);\n', '  event Redeem(address indexed from, address indexed to, uint256 amount);\n', '\n', '  event RewardsAccrued(address user, uint256 amount);\n', '  event RewardsClaimed(address indexed from, address indexed to, uint256 amount);\n', '\n', '  event Cooldown(address indexed user);\n', '\n', '  constructor(\n', '    IERC20 stakedToken,\n', '    IERC20 rewardToken,\n', '    uint256 cooldownSeconds,\n', '    uint256 unstakeWindow,\n', '    address rewardsVault,\n', '    address emissionManager,\n', '    uint128 distributionDuration,\n', '    string memory name,\n', '    string memory symbol,\n', '    uint8 decimals\n', '  ) public ERC20WithSnapshot(name, symbol, decimals) AaveDistributionManager(emissionManager, distributionDuration) {\n', '    STAKED_TOKEN = stakedToken;\n', '    REWARD_TOKEN = rewardToken;\n', '    COOLDOWN_SECONDS = cooldownSeconds;\n', '    UNSTAKE_WINDOW = unstakeWindow;\n', '    REWARDS_VAULT = rewardsVault;\n', '  }\n', '\n', '  /**\n', '   * @dev Called by the proxy contract\n', '   **/\n', '  function initialize(ITransferHook aaveGovernance, string calldata name, string calldata symbol, uint8 decimals) external initializer {\n', '    _setName(name);\n', '    _setSymbol(symbol);\n', '    _setDecimals(decimals);\n', '    _setAaveGovernance(aaveGovernance);\n', '  }\n', '\n', '  function stake(address onBehalfOf, uint256 amount) external override {\n', "    require(amount != 0, 'INVALID_ZERO_AMOUNT');\n", '    uint256 balanceOfUser = balanceOf(onBehalfOf);\n', '\n', '    uint256 accruedRewards = _updateUserAssetInternal(\n', '      onBehalfOf,\n', '      address(this),\n', '      balanceOfUser,\n', '      totalSupply()\n', '    );\n', '    if (accruedRewards != 0) {\n', '      emit RewardsAccrued(onBehalfOf, accruedRewards);\n', '      stakerRewardsToClaim[onBehalfOf] = stakerRewardsToClaim[onBehalfOf].add(accruedRewards);\n', '    }\n', '\n', '    stakersCooldowns[onBehalfOf] = getNextCooldownTimestamp(0, amount, onBehalfOf, balanceOfUser);\n', '\n', '    _mint(onBehalfOf, amount);\n', '    IERC20(STAKED_TOKEN).safeTransferFrom(msg.sender, address(this), amount);\n', '\n', '    emit Staked(msg.sender, onBehalfOf, amount);\n', '  }\n', '\n', '  /**\n', '   * @dev Redeems staked tokens, and stop earning rewards\n', '   * @param to Address to redeem to\n', '   * @param amount Amount to redeem\n', '   **/\n', '  function redeem(address to, uint256 amount) external override {\n', "    require(amount != 0, 'INVALID_ZERO_AMOUNT');\n", '    //solium-disable-next-line\n', '    uint256 cooldownStartTimestamp = stakersCooldowns[msg.sender];\n', '    require(\n', '      block.timestamp > cooldownStartTimestamp.add(COOLDOWN_SECONDS),\n', "      'INSUFFICIENT_COOLDOWN'\n", '    );\n', '    require(\n', '      block.timestamp.sub(cooldownStartTimestamp.add(COOLDOWN_SECONDS)) <= UNSTAKE_WINDOW,\n', "      'UNSTAKE_WINDOW_FINISHED'\n", '    );\n', '    uint256 balanceOfMessageSender = balanceOf(msg.sender);\n', '\n', '    uint256 amountToRedeem = (amount > balanceOfMessageSender) ? balanceOfMessageSender : amount;\n', '\n', '    _updateCurrentUnclaimedRewards(msg.sender, balanceOfMessageSender, true);\n', '\n', '    _burn(msg.sender, amountToRedeem);\n', '\n', '    if (balanceOfMessageSender.sub(amountToRedeem) == 0) {\n', '      stakersCooldowns[msg.sender] = 0;\n', '    }\n', '\n', '    IERC20(STAKED_TOKEN).safeTransfer(to, amountToRedeem);\n', '\n', '    emit Redeem(msg.sender, to, amountToRedeem);\n', '  }\n', '\n', '  /**\n', '   * @dev Activates the cooldown period to unstake\n', "   * - It can't be called if the user is not staking\n", '   **/\n', '  function cooldown() external override {\n', '    require(balanceOf(msg.sender) != 0, "INVALID_BALANCE_ON_COOLDOWN");\n', '    //solium-disable-next-line\n', '    stakersCooldowns[msg.sender] = block.timestamp;\n', '\n', '    emit Cooldown(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Claims an `amount` of `REWARD_TOKEN` to the address `to`\n', '   * @param to Address to stake for\n', '   * @param amount Amount to stake\n', '   **/\n', '  function claimRewards(address to, uint256 amount) external override {\n', '    uint256 newTotalRewards = _updateCurrentUnclaimedRewards(\n', '      msg.sender,\n', '      balanceOf(msg.sender),\n', '      false\n', '    );\n', '    uint256 amountToClaim = (amount == type(uint256).max) ? newTotalRewards : amount;\n', '\n', '    stakerRewardsToClaim[msg.sender] = newTotalRewards.sub(amountToClaim, "INVALID_AMOUNT");\n', '\n', '    REWARD_TOKEN.safeTransferFrom(REWARDS_VAULT, to, amountToClaim);\n', '\n', '    emit RewardsClaimed(msg.sender, to, amountToClaim);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal ERC20 _transfer of the tokenized staked tokens\n', '   * @param from Address to transfer from\n', '   * @param to Address to transfer to\n', '   * @param amount Amount to transfer\n', '   **/\n', '  function _transfer(\n', '    address from,\n', '    address to,\n', '    uint256 amount\n', '  ) internal override {\n', '    uint256 balanceOfFrom = balanceOf(from);\n', '    // Sender\n', '    _updateCurrentUnclaimedRewards(from, balanceOfFrom, true);\n', '\n', '    // Recipient\n', '    if (from != to) {\n', '      uint256 balanceOfTo = balanceOf(to);\n', '      _updateCurrentUnclaimedRewards(to, balanceOfTo, true);\n', '\n', '      uint256 previousSenderCooldown = stakersCooldowns[from];\n', '      stakersCooldowns[to] = getNextCooldownTimestamp(previousSenderCooldown, amount, to, balanceOfTo);\n', '      // if cooldown was set and whole balance of sender was transferred - clear cooldown\n', '      if (balanceOfFrom == amount && previousSenderCooldown != 0) {\n', '        stakersCooldowns[from] = 0;\n', '      }\n', '    }\n', '\n', '    super._transfer(from, to, amount);\n', '  }\n', '\n', '  /**\n', '   * @dev Updates the user state related with his accrued rewards\n', '   * @param user Address of the user\n', '   * @param userBalance The current balance of the user\n', '   * @param updateStorage Boolean flag used to update or not the stakerRewardsToClaim of the user\n', '   * @return The unclaimed rewards that were added to the total accrued\n', '   **/\n', '  function _updateCurrentUnclaimedRewards(\n', '    address user,\n', '    uint256 userBalance,\n', '    bool updateStorage\n', '  ) internal returns (uint256) {\n', '    uint256 accruedRewards = _updateUserAssetInternal(\n', '      user,\n', '      address(this),\n', '      userBalance,\n', '      totalSupply()\n', '    );\n', '    uint256 unclaimedRewards = stakerRewardsToClaim[user].add(accruedRewards);\n', '\n', '    if (accruedRewards != 0) {\n', '      if (updateStorage) {\n', '        stakerRewardsToClaim[user] = unclaimedRewards;\n', '      }\n', '      emit RewardsAccrued(user, accruedRewards);\n', '    }\n', '\n', '    return unclaimedRewards;\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the how is gonna be a new cooldown timestamp depending on the sender/receiver situation\n', '   *  - If the timestamp of the sender is "better" or the timestamp of the recipient is 0, we take the one of the recipient\n', '   *  - Weighted average of from/to cooldown timestamps if:\n', "   *    # The sender doesn't have the cooldown activated (timestamp 0).\n", '   *    # The sender timestamp is expired\n', '   *    # The sender has a "worse" timestamp\n', "   *  - If the receiver's cooldown timestamp expired (too old), the next is 0\n", '   * @param fromCooldownTimestamp Cooldown timestamp of the sender\n', '   * @param amountToReceive Amount\n', '   * @param toAddress Address of the recipient\n', '   * @param toBalance Current balance of the receiver\n', '   * @return The new cooldown timestamp\n', '   **/\n', '  function getNextCooldownTimestamp(\n', '    uint256 fromCooldownTimestamp,\n', '    uint256 amountToReceive,\n', '    address toAddress,\n', '    uint256 toBalance\n', '  ) public returns (uint256) {\n', '    uint256 toCooldownTimestamp = stakersCooldowns[toAddress];\n', '    if (toCooldownTimestamp == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 minimalValidCooldownTimestamp = block.timestamp.sub(COOLDOWN_SECONDS).sub(\n', '      UNSTAKE_WINDOW\n', '    );\n', '\n', '    if (minimalValidCooldownTimestamp > toCooldownTimestamp) {\n', '      toCooldownTimestamp = 0;\n', '    } else {\n', '      uint256 fromCooldownTimestamp = (minimalValidCooldownTimestamp > fromCooldownTimestamp)\n', '        ? block.timestamp\n', '        : fromCooldownTimestamp;\n', '\n', '      if (fromCooldownTimestamp < toCooldownTimestamp) {\n', '        return toCooldownTimestamp;\n', '      } else {\n', '        toCooldownTimestamp = (\n', '          amountToReceive.mul(fromCooldownTimestamp).add(toBalance.mul(toCooldownTimestamp))\n', '        )\n', '          .div(amountToReceive.add(toBalance));\n', '      }\n', '    }\n', '    stakersCooldowns[toAddress] = toCooldownTimestamp;\n', '\n', '    return toCooldownTimestamp;\n', '  }\n', '\n', '  /**\n', '   * @dev Return the total rewards pending to claim by an staker\n', '   * @param staker The staker address\n', '   * @return The rewards\n', '   */\n', '  function getTotalRewardsBalance(address staker) external view returns (uint256) {\n', '\n', '      DistributionTypes.UserStakeInput[] memory userStakeInputs\n', '     = new DistributionTypes.UserStakeInput[](1);\n', '    userStakeInputs[0] = DistributionTypes.UserStakeInput({\n', '      underlyingAsset: address(this),\n', '      stakedByUser: balanceOf(staker),\n', '      totalStaked: totalSupply()\n', '    });\n', '    return stakerRewardsToClaim[staker].add(_getUnclaimedRewards(staker, userStakeInputs));\n', '  }\n', '\n', '  /**\n', '   * @dev returns the revision of the implementation contract\n', '   * @return The revision\n', '   */\n', '  function getRevision() internal override pure returns (uint256) {\n', '    return REVISION;\n', '  }\n', '}\n', '\n', '// File: contracts/stake/StakedAave.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title StakedAave\n', ' * @notice StakedToken with AAVE token as staked token\n', ' * @author Aave\n', ' **/\n', 'contract StakedAave is StakedToken {\n', "  string internal constant NAME = 'Staked Aave';\n", "  string internal constant SYMBOL = 'stkAAVE';\n", '  uint8 internal constant DECIMALS = 18;\n', '  \n', '  constructor(\n', '    IERC20 stakedToken,\n', '    IERC20 rewardToken,\n', '    uint256 cooldownSeconds,\n', '    uint256 unstakeWindow,\n', '    address rewardsVault,\n', '    address emissionManager,\n', '    uint128 distributionDuration\n', '  ) public StakedToken(\n', '    stakedToken,\n', '    rewardToken,\n', '    cooldownSeconds,\n', '    unstakeWindow,\n', '    rewardsVault,\n', '    emissionManager,\n', '    distributionDuration,\n', '    NAME,\n', '    SYMBOL,\n', '    DECIMALS) {}\n', '}']