['// File: @openzeppelin/upgrades/contracts/Initializable.sol\n', '\n', 'pragma solidity >=0.4.24 <0.7.0;\n', '\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', '// File: @openzeppelin/upgrades/contracts/cryptography/ECDSA.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Elliptic curve signature operations\n', ' * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n', ' * TODO Remove this library once solidity supports passing a signature to ecrecover.\n', ' * See https://github.com/ethereum/solidity/issues/864\n', ' *\n', ' * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/79dd498b16b957399f84b9aa7e720f98f9eb83e3/contracts/cryptography/ECDSA.sol\n', ' * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n', ' * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n', ' * build/artifacts folder) as well as the vanilla implementation from an openzeppelin version.\n', ' */\n', '\n', 'library OpenZeppelinUpgradesECDSA {\n', '    /**\n', '     * @dev Recover signer address from a message by using their signature\n', '     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '     * @param signature bytes signature, the signature is generated using web3.eth.sign()\n', '     */\n', '    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n', '        // Check the signature length\n', '        if (signature.length != 65) {\n', '            return (address(0));\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '\n', '        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n', '        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n', '        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n', '        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n', '        //\n', '        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n', '        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n', '        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n', '        // these malleable signatures as well.\n', '        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n', '            return address(0);\n', '        }\n', '\n', '        if (v != 27 && v != 28) {\n', '            return address(0);\n', '        }\n', '\n', '        // If the signature is valid (and not malleable), return the signer address\n', '        return ecrecover(hash, v, r, s);\n', '    }\n', '\n', '    /**\n', '     * toEthSignedMessageHash\n', '     * @dev prefix a bytes32 value with "\\x19Ethereum Signed Message:"\n', '     * and hash the result\n', '     */\n', '    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n', '        // 32 is the length in bytes of hash,\n', '        // enforced by the type signature above\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context is Initializable {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev Give an account access to this role.\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(!has(role, account), "Roles: account already has role");\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev Remove an account's access to this role.\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(has(role, account), "Roles: account does not have role");\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if an account has this role.\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0), "Roles: account is the zero address");\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/access/roles/WhitelistAdminRole.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title WhitelistAdminRole\n', ' * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\n', ' */\n', 'contract WhitelistAdminRole is Initializable, Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistAdminAdded(address indexed account);\n', '    event WhitelistAdminRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelistAdmins;\n', '\n', '    function initialize(address sender) public initializer {\n', '        if (!isWhitelistAdmin(sender)) {\n', '            _addWhitelistAdmin(sender);\n', '        }\n', '    }\n', '\n', '    modifier onlyWhitelistAdmin() {\n', '        require(isWhitelistAdmin(_msgSender()), "WhitelistAdminRole: caller does not have the WhitelistAdmin role");\n', '        _;\n', '    }\n', '\n', '    function isWhitelistAdmin(address account) public view returns (bool) {\n', '        return _whitelistAdmins.has(account);\n', '    }\n', '\n', '    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\n', '        _addWhitelistAdmin(account);\n', '    }\n', '\n', '    function renounceWhitelistAdmin() public {\n', '        _removeWhitelistAdmin(_msgSender());\n', '    }\n', '\n', '    function _addWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.add(account);\n', '        emit WhitelistAdminAdded(account);\n', '    }\n', '\n', '    function _removeWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.remove(account);\n', '        emit WhitelistAdminRemoved(account);\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/access/roles/WhitelistedRole.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title WhitelistedRole\n', ' * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a\n', ' * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove\n', ' * it), and not Whitelisteds themselves.\n', ' */\n', 'contract WhitelistedRole is Initializable, Context, WhitelistAdminRole {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistedAdded(address indexed account);\n', '    event WhitelistedRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelisteds;\n', '\n', '    modifier onlyWhitelisted() {\n', '        require(isWhitelisted(_msgSender()), "WhitelistedRole: caller does not have the Whitelisted role");\n', '        _;\n', '    }\n', '\n', '    function initialize(address sender) public initializer {\n', '        WhitelistAdminRole.initialize(sender);\n', '    }\n', '\n', '    function isWhitelisted(address account) public view returns (bool) {\n', '        return _whitelisteds.has(account);\n', '    }\n', '\n', '    function addWhitelisted(address account) public onlyWhitelistAdmin {\n', '        _addWhitelisted(account);\n', '    }\n', '\n', '    function removeWhitelisted(address account) public onlyWhitelistAdmin {\n', '        _removeWhitelisted(account);\n', '    }\n', '\n', '    function renounceWhitelisted() public {\n', '        _removeWhitelisted(_msgSender());\n', '    }\n', '\n', '    function _addWhitelisted(address account) internal {\n', '        _whitelisteds.add(account);\n', '        emit WhitelistedAdded(account);\n', '    }\n', '\n', '    function _removeWhitelisted(address account) internal {\n', '        _whitelisteds.remove(account);\n', '        emit WhitelistedRemoved(account);\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: contracts/access/roles/WhitelistedRoleMeta.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title WhitelistedRoleMeta\n', ' * @dev Add meta transaction capabilities to the WhitelistedRole contract.\n', ' */\n', 'contract WhitelistedRoleMeta is WhitelistedRole {\n', '\n', '    function initialize(address sender) public initializer {\n', '        WhitelistAdminRole.initialize(sender);\n', '    }\n', '\n', '    function addSignedWhitelisted(address account, bytes memory signature) public {\n', "        address signer = getWhitelistedRoleActionSigner('addSignedWhitelisted', account, signature);\n", '        require(signer != address(0), "Invalid signature");\n', '        require(isWhitelistAdmin(signer), "signer is not an admin");\n', '        _addWhitelisted(account);\n', '    }\n', '\n', '    function addSignedWhitelistAdmin(address account, bytes memory signature) public {\n', "        address signer = getWhitelistedRoleActionSigner('addSignedWhitelistAdmin', account, signature);\n", '        require(signer != address(0), "Invalid signature");\n', '        require(isWhitelistAdmin(signer), "signer is not an admin");\n', '        _addWhitelistAdmin(account);\n', '    }\n', '\n', '    function getWhitelistedRoleActionSigner(string memory action, address account, bytes memory _signature) private view returns (address) {\n', '      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(\n', '      keccak256(\n', '          abi.encodePacked(\n', '            action,\n', '            account,\n', '            address(this)\n', '          )\n', '        )\n', '      );\n', '      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);\n', '    }\n', '}\n', '\n', '// File: contracts/utils/ReentrancyGuardEmber.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * This is the exact same contract implemented by the openzeppelin team here:\n', ' * https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/master/contracts/utils/ReentrancyGuard.sol\n', ' * The contract name clashes with the version used in the set protocol dependency\n', ' * and had to be renamed to be used in this project.\n', ' */\n', 'contract ReentrancyGuardEmber is Initializable {\n', '    // counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    function initialize() public initializer {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: set-protocol-contract-utils/contracts/lib/CommonMath.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', 'library CommonMath {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public constant SCALE_FACTOR = 10 ** 18;\n', '    uint256 public constant MAX_UINT_256 = 2 ** 256 - 1;\n', '\n', '    /**\n', '     * Returns scale factor equal to 10 ** 18\n', '     *\n', '     * @return  10 ** 18\n', '     */\n', '    function scaleFactor()\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return SCALE_FACTOR;\n', '    }\n', '\n', '    /**\n', '     * Calculates and returns the maximum value for a uint256\n', '     *\n', '     * @return  The maximum value for uint256\n', '     */\n', '    function maxUInt256()\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return MAX_UINT_256;\n', '    }\n', '\n', '    /**\n', '     * Increases a value by the scale factor to allow for additional precision\n', '     * during mathematical operations\n', '     */\n', '    function scale(\n', '        uint256 a\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a.mul(SCALE_FACTOR);\n', '    }\n', '\n', '    /**\n', '     * Divides a value by the scale factor to allow for additional precision\n', '     * during mathematical operations\n', '    */\n', '    function deScale(\n', '        uint256 a\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a.div(SCALE_FACTOR);\n', '    }\n', '\n', '    /**\n', '    * @dev Performs the power on a specified value, reverts on overflow.\n', '    */\n', '    function safePower(\n', '        uint256 a,\n', '        uint256 pow\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(a > 0);\n', '\n', '        uint256 result = 1;\n', '        for (uint256 i = 0; i < pow; i++){\n', '            uint256 previousResult = result;\n', '\n', '            // Using safemath multiplication prevents overflows\n', '            result = previousResult.mul(a);\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '    * @dev Performs division where if there is a modulo, the value is rounded up\n', '    */\n', '    function divCeil(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        return a.mod(b) > 0 ? a.div(b).add(1) : a.div(b);\n', '    }\n', '\n', '    /**\n', '     * Checks for rounding errors and returns value of potential partial amounts of a principal\n', '     *\n', '     * @param  _principal       Number fractional amount is derived from\n', '     * @param  _numerator       Numerator of fraction\n', '     * @param  _denominator     Denominator of fraction\n', '     * @return uint256          Fractional amount of principal calculated\n', '     */\n', '    function getPartialAmount(\n', '        uint256 _principal,\n', '        uint256 _numerator,\n', '        uint256 _denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // Get remainder of partial amount (if 0 not a partial amount)\n', '        uint256 remainder = mulmod(_principal, _numerator, _denominator);\n', '\n', '        // Return if not a partial amount\n', '        if (remainder == 0) {\n', '            return _principal.mul(_numerator).div(_denominator);\n', '        }\n', '\n', '        // Calculate error percentage\n', '        uint256 errPercentageTimes1000000 = remainder.mul(1000000).div(_numerator.mul(_principal));\n', '\n', '        // Require error percentage is less than 0.1%.\n', '        require(\n', '            errPercentageTimes1000000 < 1000,\n', '            "CommonMath.getPartialAmount: Rounding error exceeds bounds"\n', '        );\n', '\n', '        return _principal.mul(_numerator).div(_denominator);\n', '    }\n', '\n', '    /*\n', '     * Gets the rounded up log10 of passed value\n', '     *\n', '     * @param  _value         Value to calculate ceil(log()) on\n', '     * @return uint256        Output value\n', '     */\n', '    function ceilLog10(\n', '        uint256 _value\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // Make sure passed value is greater than 0\n', '        require (\n', '            _value > 0,\n', '            "CommonMath.ceilLog10: Value must be greater than zero."\n', '        );\n', '\n', '        // Since log10(1) = 0, if _value = 1 return 0\n', '        if (_value == 1) return 0;\n', '\n', '        // Calcualte ceil(log10())\n', '        uint256 x = _value - 1;\n', '\n', '        uint256 result = 0;\n', '\n', '        if (x >= 10 ** 64) {\n', '            x /= 10 ** 64;\n', '            result += 64;\n', '        }\n', '        if (x >= 10 ** 32) {\n', '            x /= 10 ** 32;\n', '            result += 32;\n', '        }\n', '        if (x >= 10 ** 16) {\n', '            x /= 10 ** 16;\n', '            result += 16;\n', '        }\n', '        if (x >= 10 ** 8) {\n', '            x /= 10 ** 8;\n', '            result += 8;\n', '        }\n', '        if (x >= 10 ** 4) {\n', '            x /= 10 ** 4;\n', '            result += 4;\n', '        }\n', '        if (x >= 100) {\n', '            x /= 100;\n', '            result += 2;\n', '        }\n', '        if (x >= 10) {\n', '            result += 1;\n', '        }\n', '\n', '        return result + 1;\n', '    }\n', '}\n', '\n', '// File: set-protocol-contracts/contracts/lib/IERC20.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title IERC20\n', ' * @author Set Protocol\n', ' *\n', ' * Interface for using ERC20 Tokens. This interface is needed to interact with tokens that are not\n', ' * fully ERC20 compliant and return something other than true on successful transfers.\n', ' */\n', 'interface IERC20 {\n', '    function balanceOf(\n', '        address _owner\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transfer(\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external;\n', '\n', '    function approve(\n', '        address _spender,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '        returns (bool);\n', '\n', '    function totalSupply()\n', '        external\n', '        returns (uint256);\n', '}\n', '\n', '// File: set-protocol-contracts/contracts/lib/ERC20Wrapper.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Wrapper\n', ' * @author Set Protocol\n', ' *\n', ' * This library contains functions for interacting wtih ERC20 tokens, even those not fully compliant.\n', ' * For all functions we will only accept tokens that return a null or true value, any other values will\n', ' * cause the operation to revert.\n', ' */\n', 'library ERC20Wrapper {\n', '\n', '    // ============ Internal Functions ============\n', '\n', '    /**\n', "     * Check balance owner's balance of ERC20 token\n", '     *\n', '     * @param  _token          The address of the ERC20 token\n', "     * @param  _owner          The owner who's balance is being checked\n", "     * @return  uint256        The _owner's amount of tokens\n", '     */\n', '    function balanceOf(\n', '        address _token,\n', '        address _owner\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return IERC20(_token).balanceOf(_owner);\n', '    }\n', '\n', '    /**\n', "     * Checks spender's allowance to use token's on owner's behalf.\n", '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _owner          The token owner address\n', '     * @param  _spender        The address the allowance is being checked on\n', "     * @return  uint256        The spender's allowance on behalf of owner\n", '     */\n', '    function allowance(\n', '        address _token,\n', '        address _owner,\n', '        address _spender\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return IERC20(_token).allowance(_owner, _spender);\n', '    }\n', '\n', '    /**\n', "     * Transfers tokens from an address. Handle's tokens that return true or null.\n", '     * If other value returned, reverts.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _to             The address to transfer to\n', '     * @param  _quantity       The amount of tokens to transfer\n', '     */\n', '    function transfer(\n', '        address _token,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '    {\n', '        IERC20(_token).transfer(_to, _quantity);\n', '\n', '        // Check that transfer returns true or null\n', '        require(\n', '            checkSuccess(),\n', '            "ERC20Wrapper.transfer: Bad return value"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Transfers tokens from an address (that has set allowance on the proxy).\n', "     * Handle's tokens that return true or null. If other value returned, reverts.\n", '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _from           The address to transfer from\n', '     * @param  _to             The address to transfer to\n', '     * @param  _quantity       The number of tokens to transfer\n', '     */\n', '    function transferFrom(\n', '        address _token,\n', '        address _from,\n', '        address _to,\n', '        uint256 _quantity\n', '    )\n', '        external\n', '    {\n', '        IERC20(_token).transferFrom(_from, _to, _quantity);\n', '\n', '        // Check that transferFrom returns true or null\n', '        require(\n', '            checkSuccess(),\n', '            "ERC20Wrapper.transferFrom: Bad return value"\n', '        );\n', '    }\n', '\n', '    /**\n', "     * Grants spender ability to spend on owner's behalf.\n", "     * Handle's tokens that return true or null. If other value returned, reverts.\n", '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _spender        The address to approve for transfer\n', '     * @param  _quantity       The amount of tokens to approve spender for\n', '     */\n', '    function approve(\n', '        address _token,\n', '        address _spender,\n', '        uint256 _quantity\n', '    )\n', '        internal\n', '    {\n', '        IERC20(_token).approve(_spender, _quantity);\n', '\n', '        // Check that approve returns true or null\n', '        require(\n', '            checkSuccess(),\n', '            "ERC20Wrapper.approve: Bad return value"\n', '        );\n', '    }\n', '\n', '    /**\n', "     * Ensure's the owner has granted enough allowance for system to\n", '     * transfer tokens.\n', '     *\n', '     * @param  _token          The address of the ERC20 token\n', '     * @param  _owner          The address of the token owner\n', '     * @param  _spender        The address to grant/check allowance for\n', '     * @param  _quantity       The amount to see if allowed for\n', '     */\n', '    function ensureAllowance(\n', '        address _token,\n', '        address _owner,\n', '        address _spender,\n', '        uint256 _quantity\n', '    )\n', '        internal\n', '    {\n', '        uint256 currentAllowance = allowance(_token, _owner, _spender);\n', '        if (currentAllowance < _quantity) {\n', '            approve(\n', '                _token,\n', '                _spender,\n', '                CommonMath.maxUInt256()\n', '            );\n', '        }\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    /**\n', '     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n', '     * function returned 0 bytes or 1.\n', '     */\n', '    function checkSuccess(\n', '    )\n', '        private\n', '        pure\n', '        returns (bool)\n', '    {\n', '        // default to failure\n', '        uint256 returnValue = 0;\n', '\n', '        assembly {\n', '            // check number of bytes returned from last function call\n', '            switch returndatasize\n', '\n', '            // no bytes returned: assume success\n', '            case 0x0 {\n', '                returnValue := 1\n', '            }\n', '\n', '            // 32 bytes returned\n', '            case 0x20 {\n', '                // copy 32 bytes into scratch space\n', '                returndatacopy(0x0, 0x0, 0x20)\n', '\n', '                // load those bytes into returnValue\n', '                returnValue := mload(0x0)\n', '            }\n', '\n', '            // not sure what was returned: dont mark as success\n', '            default { }\n', '        }\n', '\n', '        // check if returned value is one or nothing\n', '        return returnValue == 1;\n', '    }\n', '}\n', '\n', '// File: interfaces/IWETH.sol\n', '\n', '/*\n', '    Copyright 2018 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title IWETH\n', ' * @author Set Protocol\n', ' *\n', " * Interface for Wrapped Ether. This interface allows for interaction for wrapped ether's deposit and withdrawal\n", ' * functionality.\n', ' */\n', 'interface IWETH {\n', '    function deposit()\n', '        external\n', '        payable;\n', '\n', '    function withdraw(\n', '        uint256 wad\n', '    )\n', '        external;\n', '}\n', '\n', '// File: interfaces/IVault.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title IVault\n', ' * @author Ember Fund\n', ' *\n', " * Interface for Vaults. This interface allows for interaction for Vault's deposit and withdrawal\n", ' * functionality.\n', ' */\n', 'interface IVault {\n', '\n', '    function deposit(uint amount)\n', '        external;\n', '\n', '    function withdraw(uint shares)\n', '        external;\n', '}\n', '\n', '// File: contracts/utils/ChiGasSaver.sol\n', '\n', 'pragma solidity ^0.5.7;\n', '\n', 'interface ChiGasSaver {\n', '    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function allowance(address _owner, address _spender) view external returns (uint256 remaining);\n', '}\n', '\n', '// File: contracts/SmartWalletVault.sol\n', '\n', '/*\n', '    Copyright 2018 Ember Fund Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SmartWallet\n', ' * @author Ember Fund\n', ' *\n', ' * Implementation of the Ember Fund smart wallet adding meta transaction capabilities for issuing and redeeming rebalancing sets.\n', ' * The smart wallet is owned by an EOA that can white list accounts facilitating the management of any ERC20 tokens stored in the smart wallet.\n', ' */\n', 'contract SmartWalletVault is Initializable, ReentrancyGuardEmber, WhitelistedRoleMeta {\n', '    using SafeMath for uint256;\n', '\n', '    // Nonces to prevent replay attacks\n', '    mapping(uint256 => bool) private nonces;\n', '\n', '    uint16 public constant version = 3;\n', '\n', '    // Gas token saver\n', '    ChiGasSaver public constant chiGasSaver = ChiGasSaver(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n', '\n', '    modifier discountChiGasSaver {\n', '      uint256 gasStart = gasleft();\n', '      _;\n', '      uint256 gasSpent = 21000 + gasStart - gasleft() + 16 *\n', '                         msg.data.length;\n', '      uint256 allowance = chiGasSaver.allowance(msg.sender, address(this));\n', '      uint256 chiTokensToSpend = (gasSpent + 14154) / 41947;\n', '      if (allowance < chiTokensToSpend) {\n', '        chiGasSaver.approve(address(this), chiTokensToSpend);\n', '      }\n', '      chiGasSaver.freeFromUpTo(msg.sender, chiTokensToSpend);\n', '    }\n', '\n', '    mapping(address => address) public depositTokenAddressToYVault;\n', '    mapping(address => address) public yVaultToDepositTokenAddress;\n', '\n', '    /**\n', '     * Initialize the smart contract with an owner.\n', '     */\n', '    function initialize(address _owner) public initializer {\n', '      WhitelistedRoleMeta.initialize(_owner);\n', '      ReentrancyGuardEmber.initialize();\n', '\n', '      // Add more deposit to vault mapping to support more vaults\n', '      // USDT 0xdAC17F958D2ee523a2206206994597C13D831ec7\n', '      // yEarn USDT 0x2f08119C6f07c006695E079AAFc638b8789FAf18\n', '      depositTokenAddressToYVault[0xdAC17F958D2ee523a2206206994597C13D831ec7] = 0x2f08119C6f07c006695E079AAFc638b8789FAf18;\n', '      yVaultToDepositTokenAddress[0x2f08119C6f07c006695E079AAFc638b8789FAf18] = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '    }\n', '\n', '    function() external payable { }\n', '\n', '    // Prod addresses\n', '    // address constant public transfersProxy = 0x882d80D3a191859d64477eb78Cca46599307ec1C;\n', '    // address payable constant public rebalancingSetExchangeIssuanceModule = 0xde697AC56b1bD9C0987c08911020f2341e274813;\n', '    // address payable constant public rebalancingSetIssuanceModule = 0xDA6786379FF88729264d31d472FA917f5E561443;\n', '    // address payable constant public cTokenaddressToAddressWhiteList = 0x5BA020a8835ed40936941562bdF42D66F65fc00f;\n', '\n', '    function getTransfersProxy() public view returns (address) {\n', '      return 0x882d80D3a191859d64477eb78Cca46599307ec1C;\n', '    }\n', '\n', '    function getRebalancingSetExchangeIssuanceModule() public view returns (address payable) {\n', '      return 0xde697AC56b1bD9C0987c08911020f2341e274813;\n', '    }\n', '\n', '    function getRebalancingSetIssuanceModule() public view returns (address payable) {\n', '      return 0xDA6786379FF88729264d31d472FA917f5E561443;\n', '    }\n', '\n', '    function getCTokenaddressToAddressWhiteList() public view returns (address payable) {\n', '      return 0x5BA020a8835ed40936941562bdF42D66F65fc00f;\n', '    }\n', '\n', '    function getWrappedEthInstance() public view returns (IWETH) {\n', '      return IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '    }\n', '\n', '    /**\n', '     * Withdraw all ERC20 tokens from this contract to the caller address. Only callable by the smart contract owner.\n', '     */\n', '    function withdrawAllAdmin(address [] calldata _tokenAddresses)\n', '      external\n', '      nonReentrant\n', '      onlyWhitelistAdmin\n', '    {\n', '      for (uint i=0; i<_tokenAddresses.length; i++) {\n', '          uint256 tokenBalance = ERC20Wrapper.balanceOf(_tokenAddresses[i], address(this));\n', '          ERC20Wrapper.transfer(\n', '              _tokenAddresses[i],\n', '              msg.sender,\n', '              tokenBalance\n', '          );\n', '      }\n', '    }\n', '\n', '    /**\n', "     * Withdraw an ERC20 token to the owner's account.\n", '     */\n', '    function withdrawERC20(address _tokenAddress, address _to, uint256 _withdrawalAmount)\n', '      external\n', '      nonReentrant\n', '      onlyWhitelisted\n', '    {\n', '      uint256 tokenBalance = ERC20Wrapper.balanceOf(_tokenAddress, address(this));\n', '      require(tokenBalance >= _withdrawalAmount, "Withdrawal amount is too high");\n', '      require(this.isWhitelistAdmin(_to), "You can only withdraw to an owner address");\n', '      ERC20Wrapper.transfer(\n', '          _tokenAddress,\n', '          _to,\n', '          _withdrawalAmount\n', '      );\n', '    }\n', '\n', '    /**\n', "     * Withdraw ETH to the owner's account.\n", '     */\n', '    function withdrawETH(address payable _to, uint256 _withdrawalAmount)\n', '      external\n', '      nonReentrant\n', '      onlyWhitelisted\n', '    {\n', '      uint256 ethBalance = address(this).balance;\n', '      require(ethBalance >= _withdrawalAmount, "Withdrawal amount is too high");\n', '      require(this.isWhitelistAdmin(_to), "You can only withdraw to an owner address");\n', '      _to.transfer(_withdrawalAmount);\n', '    }\n', '\n', '    function _checkReplayAttack(\n', '       uint256 _nonce\n', '    )\n', '      private\n', '      nonReentrant\n', '    {\n', '      require(!nonces[_nonce], "Replay attack detected.");\n', '      nonces[_nonce] = true;\n', '    }\n', '\n', '    /**\n', '     * Get the signer of vault deposit.\n', '     */\n', '    function getVaultDepositSigner(address _vaultAddress, address _tokenDepositAddress, uint256 _nonce, bytes memory _signature) private view returns (address) {\n', '      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(\n', '      keccak256(\n', '          abi.encodePacked(\n', '            _vaultAddress,\n', '            _tokenDepositAddress,\n', '            _nonce,\n', '            address(this)\n', '          )\n', '        )\n', '      );\n', '      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);\n', '    }\n', '\n', '    function vaultDeposit(\n', '      address _vaultAddress,\n', '      address _tokenDepositAddress,\n', '      uint256 _amount,\n', '      uint256 _nonce,\n', '      bytes memory _signature\n', '    )\n', '        public\n', '        nonReentrant\n', '        discountChiGasSaver\n', '    {\n', '\n', '      _checkReplayAttack(_nonce);\n', '      require(depositTokenAddressToYVault[_tokenDepositAddress] == _vaultAddress, "Deposit token and vault not supported");\n', '      address signer = getVaultDepositSigner(_vaultAddress, _tokenDepositAddress, _nonce, _signature);\n', '      require(signer != address(0), "Invalid signature");\n', '      require(isWhitelistAdmin(signer), "signer is not an admin");\n', '\n', '      uint256 tokenDepositBalance = ERC20Wrapper.balanceOf(_tokenDepositAddress, address(this));\n', '      require(tokenDepositBalance >= _amount, "Token deposit balance is too low");\n', '\n', "      // Approve the vault to spend the SMA's owner's deposit token's\n", '      ERC20Wrapper.approve(_tokenDepositAddress, _vaultAddress, _amount);\n', '      // Deposit tokens to the vault\n', '      IVault(_vaultAddress).deposit(_amount);\n', '    }\n', '\n', '\n', '    /**\n', '     * Get the signer of a vault withdrawal.\n', '     */\n', '    function getVaultWithdrawalSigner(address _vaultAddress, address payable _to, uint256 _nonce, bytes memory _signature) private view returns (address) {\n', '      bytes32 msgHash = OpenZeppelinUpgradesECDSA.toEthSignedMessageHash(\n', '      keccak256(\n', '          abi.encodePacked(\n', '            _vaultAddress,\n', '            _to,\n', '            _nonce,\n', '            address(this)\n', '          )\n', '        )\n', '      );\n', '      return OpenZeppelinUpgradesECDSA.recover(msgHash, _signature);\n', '    }\n', '\n', '    function vaultWithdraw(\n', '      address _vaultAddress,\n', '      uint shares,\n', '      address payable _to,\n', '      uint256 _nonce,\n', '      bytes memory _signature\n', '    )\n', '        public\n', '        nonReentrant\n', '        discountChiGasSaver\n', '    {\n', '\n', '      _checkReplayAttack(_nonce);\n', '      address depositTokenAddress = yVaultToDepositTokenAddress[_vaultAddress];\n', '      require(depositTokenAddress != address(0), "Vault not supported");\n', '\n', '      address signer = getVaultWithdrawalSigner(_vaultAddress, _to, _nonce, _signature);\n', '      require(signer != address(0), "Invalid signature");\n', '      require(isWhitelistAdmin(signer), "signer is not an admin");\n', '\n', '      // Get current balance of the deposit token before withdrawal\n', '      uint256 depositTokenBalanceBeforeWithdrawal = ERC20Wrapper.balanceOf(depositTokenAddress, address(this));\n', '      // Withdraw shares of the vault to deposit token\n', '      IVault(_vaultAddress).withdraw(shares);\n', '\n', '      // Compute how many deposit tokens were withdrawn\n', '      uint256 depositTokenWithdrawn = ERC20Wrapper.balanceOf(depositTokenAddress, address(this)).sub(depositTokenBalanceBeforeWithdrawal);\n', '      require(depositTokenWithdrawn > 0, "No token withdrawn");\n', '\n', '      // Transfer withdrawn tokens to address passed as parameter\n', '      ERC20Wrapper.transfer(\n', '          depositTokenAddress,\n', '          _to,\n', '          depositTokenWithdrawn\n', '      );\n', '\n', '    }\n', '\n', '}']