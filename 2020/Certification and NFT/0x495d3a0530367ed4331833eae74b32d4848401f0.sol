['// File: contracts/external/openzeppelin-solidity/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library SafeMath64 {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        uint64 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint64 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\n', '        require(b <= a, errorMessage);\n', '        uint64 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint64 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint64 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/external/govblocks-protocol/interfaces/IGovernance.sol\n', '\n', '/* Copyright (C) 2017 GovBlocks.io\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'contract IGovernance { \n', '\n', '    event Proposal(\n', '        address indexed proposalOwner,\n', '        uint256 indexed proposalId,\n', '        uint256 dateAdd,\n', '        string proposalTitle,\n', '        string proposalSD,\n', '        string proposalDescHash\n', '    );\n', '\n', '    event Solution(\n', '        uint256 indexed proposalId,\n', '        address indexed solutionOwner,\n', '        uint256 indexed solutionId,\n', '        string solutionDescHash,\n', '        uint256 dateAdd\n', '    );\n', '\n', '    event Vote(\n', '        address indexed from,\n', '        uint256 indexed proposalId,\n', '        uint256 indexed voteId,\n', '        uint256 dateAdd,\n', '        uint256 solutionChosen\n', '    );\n', '\n', '    event RewardClaimed(\n', '        address indexed member,\n', '        uint gbtReward\n', '    );\n', '\n', '    /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal. \n', '    event VoteCast (uint256 proposalId);\n', '\n', '    /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can \n', '    ///      call any offchain actions\n', '    event ProposalAccepted (uint256 proposalId);\n', '\n', '    /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\n', '    event CloseProposalOnTime (\n', '        uint256 indexed proposalId,\n', '        uint256 time\n', '    );\n', '\n', '    /// @dev ActionSuccess event is called whenever an onchain action is executed.\n', '    event ActionSuccess (\n', '        uint256 proposalId\n', '    );\n', '\n', '    /// @dev Creates a new proposal\n', '    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\n', "    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\n", '    function createProposal(\n', '        string calldata _proposalTitle,\n', '        string calldata _proposalSD,\n', '        string calldata _proposalDescHash,\n', '        uint _categoryId\n', '    ) \n', '        external;\n', '\n', '    /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\n', '    function categorizeProposal(\n', '        uint _proposalId, \n', '        uint _categoryId,\n', '        uint _incentives\n', '    ) \n', '        external;\n', '\n', '    /// @dev Submit proposal with solution\n', '    /// @param _proposalId Proposal id\n', '    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\n', '    function submitProposalWithSolution(\n', '        uint _proposalId, \n', '        string calldata _solutionHash, \n', '        bytes calldata _action\n', '    ) \n', '        external;\n', '\n', '    /// @dev Creates a new proposal with solution and votes for the solution\n', '    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\n', "    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\n", '    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\n', '    function createProposalwithSolution(\n', '        string calldata _proposalTitle, \n', '        string calldata _proposalSD, \n', '        string calldata _proposalDescHash,\n', '        uint _categoryId, \n', '        string calldata _solutionHash, \n', '        bytes calldata _action\n', '    ) \n', '        external;\n', '\n', '    /// @dev Casts vote\n', '    /// @param _proposalId Proposal id\n', '    /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\n', '    function submitVote(uint _proposalId, uint _solutionChosen) external;\n', '\n', '    function closeProposal(uint _proposalId) external;\n', '\n', '    function claimReward(address _memberAddress, uint _maxRecords) external returns(uint pendingDAppReward); \n', '\n', '    function proposal(uint _proposalId)\n', '        external\n', '        view\n', '        returns(\n', '            uint proposalId,\n', '            uint category,\n', '            uint status,\n', '            uint finalVerdict,\n', '            uint totalReward\n', '        );\n', '\n', '    function canCloseProposal(uint _proposalId) public view returns(uint closeValue);\n', '\n', '    function allowedToCatgorize() public view returns(uint roleId);\n', '\n', '    /**\n', '     * @dev Gets length of propsal\n', '     * @return length of propsal\n', '     */\n', '    function getProposalLength() external view returns(uint);\n', '\n', '}\n', '\n', '// File: contracts/external/govblocks-protocol/Governed.sol\n', '\n', '/* Copyright (C) 2017 GovBlocks.io\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'contract IMaster {\n', '    mapping(address => bool) public whitelistedSponsor;\n', '    function dAppToken() public view returns(address);\n', '    function isInternal(address _address) public view returns(bool);\n', '    function getLatestAddress(bytes2 _module) public view returns(address);\n', '    function isAuthorizedToGovern(address _toCheck) public view returns(bool);\n', '}\n', '\n', '\n', 'contract Governed {\n', '\n', '    address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\n', '\n', '    /// @dev modifier that allows only the authorized addresses to execute the function\n', '    modifier onlyAuthorizedToGovern() {\n', '        IMaster ms = IMaster(masterAddress);\n', '        require(ms.getLatestAddress("GV") == msg.sender, "Not authorized");\n', '        _;\n', '    }\n', '\n', '    /// @dev checks if an address is authorized to govern\n', '    function isAuthorizedToGovern(address _toCheck) public view returns(bool) {\n', '        IMaster ms = IMaster(masterAddress);\n', '        return (ms.getLatestAddress("GV") == _toCheck);\n', '    } \n', '\n', '}\n', '\n', '// File: contracts/external/proxy/Proxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Gives the possibility to delegate any call to a foreign implementation.\n', ' */\n', 'contract Proxy {\n', '    /**\n', '    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n', '    * This function will return whatever the implementation call returns\n', '    */\n', '    function () external payable {\n', '        address _impl = implementation();\n', '        require(_impl != address(0));\n', '\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            calldatacopy(ptr, 0, calldatasize)\n', '            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n', '            let size := returndatasize\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            switch result\n', '            case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '            }\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the implementation where every call will be delegated.\n', '    * @return address of the implementation to which it will be delegated\n', '    */\n', '    function implementation() public view returns (address);\n', '}\n', '\n', '// File: contracts/external/proxy/UpgradeabilityProxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n', ' */\n', 'contract UpgradeabilityProxy is Proxy {\n', '    /**\n', '    * @dev This event will be emitted every time the implementation gets upgraded\n', '    * @param implementation representing the address of the upgraded implementation\n', '    */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    // Storage position of the address of the current implementation\n', '    bytes32 private constant IMPLEMENTATION_POSITION = keccak256("org.govblocks.proxy.implementation");\n', '\n', '    /**\n', '    * @dev Constructor function\n', '    */\n', '    constructor() public {}\n', '\n', '    /**\n', '    * @dev Tells the address of the current implementation\n', '    * @return address of the current implementation\n', '    */\n', '    function implementation() public view returns (address impl) {\n', '        bytes32 position = IMPLEMENTATION_POSITION;\n', '        assembly {\n', '            impl := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Sets the address of the current implementation\n', '    * @param _newImplementation address representing the new implementation to be set\n', '    */\n', '    function _setImplementation(address _newImplementation) internal {\n', '        bytes32 position = IMPLEMENTATION_POSITION;\n', '        assembly {\n', '        sstore(position, _newImplementation)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Upgrades the implementation address\n', '    * @param _newImplementation representing the address of the new implementation to be set\n', '    */\n', '    function _upgradeTo(address _newImplementation) internal {\n', '        address currentImplementation = implementation();\n', '        require(currentImplementation != _newImplementation);\n', '        _setImplementation(_newImplementation);\n', '        emit Upgraded(_newImplementation);\n', '    }\n', '}\n', '\n', '// File: contracts/external/proxy/OwnedUpgradeabilityProxy.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title OwnedUpgradeabilityProxy\n', ' * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n', ' */\n', 'contract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\n', '    /**\n', '    * @dev Event to show ownership has been transferred\n', '    * @param previousOwner representing the address of the previous owner\n', '    * @param newOwner representing the address of the new owner\n', '    */\n', '    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n', '\n', '    // Storage position of the owner of the contract\n', '    bytes32 private constant PROXY_OWNER_POSITION = keccak256("org.govblocks.proxy.owner");\n', '\n', '    /**\n', '    * @dev the constructor sets the original owner of the contract to the sender account.\n', '    */\n', '    constructor(address _implementation) public {\n', '        _setUpgradeabilityOwner(msg.sender);\n', '        _upgradeTo(_implementation);\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyProxyOwner() {\n', '        require(msg.sender == proxyOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the owner\n', '    * @return the address of the owner\n', '    */\n', '    function proxyOwner() public view returns (address owner) {\n', '        bytes32 position = PROXY_OWNER_POSITION;\n', '        assembly {\n', '            owner := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\n', '        require(_newOwner != address(0));\n', '        _setUpgradeabilityOwner(_newOwner);\n', '        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the proxy owner to upgrade the current version of the proxy.\n', '    * @param _implementation representing the address of the new implementation to be set.\n', '    */\n', '    function upgradeTo(address _implementation) public onlyProxyOwner {\n', '        _upgradeTo(_implementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the owner\n', '    */\n', '    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\n', '        bytes32 position = PROXY_OWNER_POSITION;\n', '        assembly {\n', '            sstore(position, _newProxyOwner)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IToken.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract IToken {\n', '\n', '    function decimals() external view returns(uint8);\n', '\n', '    /**\n', '    * @dev Total number of tokens in existence\n', '    */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address.\n', '    * @param account The address to query the balance of.\n', '    * @return An uint256 representing the amount owned by the passed address.\n', '    */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', '    * @dev Transfer token for a specified address\n', '    * @param recipient The address to transfer to.\n', '    * @param amount The amount to be transferred.\n', '    */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '    * @dev function that mints an amount of the token and assigns it to\n', '    * an account.\n', '    * @param account The account that will receive the created tokens.\n', '    * @param amount The amount that will be created.\n', '    */\n', '    function mint(address account, uint256 amount) external returns (bool);\n', '    \n', '     /**\n', '    * @dev burns an amount of the tokens of the message sender\n', '    * account.\n', '    * @param amount The amount that will be burnt.\n', '    */\n', '    function burn(uint256 amount) external;\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     * Returns a boolean value indicating whether the operation succeeded.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '    * @dev Transfer tokens from one address to another\n', '    * @param sender address The address which you want to send tokens from\n', '    * @param recipient address The address which you want to transfer to\n', '    * @param amount uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '}\n', '\n', '// File: contracts/interfaces/IMarket.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract IMarket {\n', '\n', '    enum PredictionStatus {\n', '      Live,\n', '      InSettlement,\n', '      Cooling,\n', '      InDispute,\n', '      Settled\n', '    }\n', '\n', '    struct MarketData {\n', '      uint64 startTime;\n', '      uint64 predictionTime;\n', '      uint64 neutralMinValue;\n', '      uint64 neutralMaxValue;\n', '    }\n', '\n', '    struct MarketSettleData {\n', '      uint64 WinningOption;\n', '      uint64 settleTime;\n', '    }\n', '\n', '    MarketSettleData public marketSettleData;\n', '\n', '    MarketData public marketData;\n', '\n', '    function WinningOption() public view returns(uint256);\n', '\n', '    function marketCurrency() public view returns(bytes32);\n', '\n', '    function getMarketFeedData() public view returns(uint8, bytes32, address);\n', '\n', '    function settleMarket() external;\n', '    \n', '    function getTotalStakedValueInPLOT() external view returns(uint256);\n', '\n', '    /**\n', '    * @dev Initialize the market.\n', '    * @param _startTime The time at which market will create.\n', '    * @param _predictionTime The time duration of market.\n', '    * @param _minValue The minimum value of middle option range.\n', '    * @param _maxValue The maximum value of middle option range.\n', '    */\n', '    function initiate(uint64 _startTime, uint64 _predictionTime, uint64 _minValue, uint64 _maxValue) public payable;\n', '\n', '    /**\n', '    * @dev Resolve the dispute if wrong value passed at the time of market result declaration.\n', '    * @param accepted The flag defining that the dispute raised is accepted or not \n', '    * @param finalResult The final correct value of market currency.\n', '    */\n', '    function resolveDispute(bool accepted, uint256 finalResult) external payable;\n', '\n', '    /**\n', '    * @dev Gets the market data.\n', '    * @return _marketCurrency bytes32 representing the currency or stock name of the market.\n', '    * @return minvalue uint[] memory representing the minimum range of all the options of the market.\n', '    * @return maxvalue uint[] memory representing the maximum range of all the options of the market.\n', '    * @return _optionPrice uint[] memory representing the option price of each option ranges of the market.\n', '    * @return _ethStaked uint[] memory representing the ether staked on each option ranges of the market.\n', '    * @return _plotStaked uint[] memory representing the plot staked on each option ranges of the market.\n', '    * @return _predictionType uint representing the type of market.\n', '    * @return _expireTime uint representing the expire time of the market.\n', '    * @return _predictionStatus uint representing the status of the market.\n', '    */\n', '    function getData() external view \n', '    \treturns (\n', '    \t\tbytes32 _marketCurrency,uint[] memory minvalue,uint[] memory maxvalue,\n', '        \tuint[] memory _optionPrice, uint[] memory _ethStaked, uint[] memory _plotStaked,uint _predictionType,\n', '        \tuint _expireTime, uint _predictionStatus\n', '        );\n', '\n', '    // /**\n', '    // * @dev Gets the pending return.\n', '    // * @param _user The address to specify the return of.\n', '    // * @return uint representing the pending return amount.\n', '    // */\n', '    // function getPendingReturn(address _user) external view returns(uint[] memory returnAmount, address[] memory _predictionAssets, uint[] memory incentive, address[] memory _incentiveTokens);\n', '\n', '    /**\n', '    * @dev Claim the return amount of the specified address.\n', '    * @param _user The address to query the claim return amount of.\n', '    * @return Flag, if 0:cannot claim, 1: Already Claimed, 2: Claimed\n', '    */\n', '    function claimReturn(address payable _user) public returns(uint256);\n', '\n', '}\n', '\n', '// File: contracts/interfaces/Iupgradable.sol\n', '\n', 'pragma solidity 0.5.7;\n', '\n', 'contract Iupgradable {\n', '\n', '    /**\n', '     * @dev change master address\n', '     */\n', '    function setMasterAddress() public;\n', '}\n', '\n', '// File: contracts/interfaces/IMarketUtility.sol\n', '\n', 'pragma solidity 0.5.7;\n', 'contract IMarketUtility {\n', '\n', '    function initialize(address payable[] calldata _addressParams, address _initiater) external;\n', '\n', '\t/**\n', '     * @dev to Set authorized address to update parameters \n', '     */\n', '    function setAuthorizedAddres() public;\n', '\n', '\t/**\n', '     * @dev to update uint parameters in Market Config \n', '     */\n', '    function updateUintParameters(bytes8 code, uint256 value) external;\n', '\n', '    /**\n', '     * @dev to Update address parameters in Market Config \n', '     */\n', '    function updateAddressParameters(bytes8 code, address payable value) external;\n', ' \n', '     /**\n', '    * @dev Get Parameters required to initiate market\n', '    * @return Addresses of tokens to be distributed as incentives\n', '    * @return Cool down time for market\n', '    * @return Rate\n', '    * @return Commission percent for predictions with ETH\n', '    * @return Commission percent for predictions with PLOT\n', '    **/\n', '    function getMarketInitialParams() public view returns(address[] memory, uint , uint, uint, uint);\n', '\n', '    function getAssetPriceUSD(address _currencyAddress) external view returns(uint latestAnswer);\n', '    \n', '    function getPriceFeedDecimals(address _priceFeed) public view returns(uint8);\n', '\n', '    function getValueAndMultiplierParameters(address _asset, uint256 _amount)\n', '        public\n', '        view\n', '        returns (uint256, uint256);\n', '\n', '    function update() external;\n', '    \n', '    function calculatePredictionValue(uint[] memory params, address asset, address user, address marketFeedAddress, bool _checkMultiplier) public view returns(uint _predictionValue, bool _multiplierApplied);\n', '    \n', '    /**\n', '     * @dev Get basic market details\n', '     * @return Minimum amount required to predict in market\n', '     * @return Percentage of users leveraged amount to deduct when placed in wrong prediction\n', '     * @return Decimal points for prediction positions\n', '     **/\n', '    function getBasicMarketDetails()\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function getDisputeResolutionParams() public view returns (uint256);\n', '    function calculateOptionPrice(uint[] memory params, address marketFeedAddress) public view returns(uint _optionPrice);\n', '\n', '    /**\n', '     * @dev Get price of provided feed address\n', '     * @param _currencyFeedAddress  Feed Address of currency on which market options are based on\n', '     * @return Current price of the market currency\n', '     **/\n', '    function getSettlemetPrice(\n', '        address _currencyFeedAddress,\n', '        uint256 _settleTime\n', '    ) public view returns (uint256 latestAnswer, uint256 roundId);\n', '}\n', '\n', '// File: contracts/MarketRegistry.sol\n', '\n', '/* Copyright (C) 2020 PlotX.io\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see http://www.gnu.org/licenses/ */\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract MarketRegistry is Governed, Iupgradable {\n', '\n', '    using SafeMath for *; \n', '\n', '    enum MarketType {\n', '      HourlyMarket,\n', '      DailyMarket,\n', '      WeeklyMarket\n', '    }\n', '\n', '    struct MarketTypeData {\n', '      uint64 predictionTime;\n', '      uint64 optionRangePerc;\n', '    }\n', '\n', '    struct MarketCurrency {\n', '      address marketImplementation;\n', '      uint8 decimals;\n', '    }\n', '\n', '    struct MarketCreationData {\n', '      uint64 initialStartTime;\n', '      address marketAddress;\n', '      address penultimateMarket;\n', '    }\n', '\n', '    struct DisputeStake {\n', '      uint64 proposalId;\n', '      address staker;\n', '      uint256 stakeAmount;\n', '      uint256 ethDeposited;\n', '      uint256 tokenDeposited;\n', '    }\n', '\n', '    struct MarketData {\n', '      bool isMarket;\n', '      DisputeStake disputeStakes;\n', '    }\n', '\n', '    struct UserData {\n', '      uint256 lastClaimedIndex;\n', '      uint256 marketsCreated;\n', '      uint256 totalEthStaked;\n', '      uint256 totalPlotStaked;\n', '      address[] marketsParticipated;\n', '      mapping(address => bool) marketsParticipatedFlag;\n', '    }\n', '\n', '    uint internal marketCreationIncentive;\n', '    \n', '    mapping(address => MarketData) marketData;\n', '    mapping(address => UserData) userData;\n', '    mapping(uint256 => mapping(uint256 => MarketCreationData)) public marketCreationData;\n', '    mapping(uint64 => address) disputeProposalId;\n', '\n', '    address constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    address internal marketInitiater;\n', '    address public tokenController;\n', '\n', '    MarketCurrency[] marketCurrencies;\n', '    MarketTypeData[] marketTypes;\n', '\n', '    bool public marketCreationPaused;\n', '\n', '    IToken public plotToken;\n', '    IMarketUtility public marketUtility;\n', '    IGovernance internal governance;\n', '    IMaster ms;\n', '\n', '\n', '    event MarketQuestion(address indexed marketAdd, bytes32 stockName, uint256 indexed predictionType, uint256 startTime);\n', '    event PlacePrediction(address indexed user,uint256 value, uint256 predictionPoints, address predictionAsset,uint256 prediction,address indexed marketAdd,uint256 _leverage);\n', '    event MarketResult(address indexed marketAdd, uint256[] totalReward, uint256 winningOption, uint256 closeValue, uint256 roundId);\n', '    event Claimed(address indexed marketAdd, address indexed user, uint256[] reward, address[] _predictionAssets, uint256 incentive, address incentiveToken);\n', '    event MarketTypes(uint256 indexed index, uint64 predictionTime, uint64 optionRangePerc);\n', '    event MarketCurrencies(uint256 indexed index, address marketImplementation,  address feedAddress, bytes32 currencyName);\n', '    event DisputeRaised(address indexed marketAdd, address raisedBy, uint64 proposalId, uint256 proposedValue);\n', '    event DisputeResolved(address indexed marketAdd, bool status);\n', '\n', '    /**\n', '    * @dev Checks if given addres is valid market address.\n', '    */\n', '    function isMarket(address _address) public view returns(bool) {\n', '      return marketData[_address].isMarket;\n', '    }\n', '\n', '    function isWhitelistedSponsor(address _address) public view returns(bool) {\n', '      return ms.whitelistedSponsor(_address);\n', '    }\n', '\n', '    /**\n', '    * @dev Initialize the PlotX MarketRegistry.\n', '    * @param _defaultAddress Address authorized to start initial markets\n', '    * @param _marketUtility The address of market config.\n', '    * @param _plotToken The instance of PlotX token.\n', '    */\n', '    function initiate(address _defaultAddress, address _marketUtility, address _plotToken, address payable[] memory _configParams) public {\n', '      require(address(ms) == msg.sender);\n', '      marketCreationIncentive = 50 ether;\n', '      plotToken = IToken(_plotToken);\n', '      address tcAddress = ms.getLatestAddress("TC");\n', '      tokenController = tcAddress;\n', '      marketUtility = IMarketUtility(_generateProxy(_marketUtility));\n', '      marketUtility.initialize(_configParams, _defaultAddress);\n', '      marketInitiater = _defaultAddress;\n', '    }\n', '\n', '    /**\n', '    * @dev Start the initial market.\n', '    */\n', '    function addInitialMarketTypesAndStart(uint64 _marketStartTime, address _ethMarketImplementation, address _btcMarketImplementation) external {\n', '      require(marketInitiater == msg.sender);\n', '      require(marketTypes.length == 0);\n', '      _addNewMarketCurrency(_ethMarketImplementation);\n', '      _addNewMarketCurrency(_btcMarketImplementation);\n', '      _addMarket(1 hours, 50);\n', '      _addMarket(24 hours, 200);\n', '      _addMarket(7 days, 500);\n', '\n', '      for(uint256 i = 0;i < marketTypes.length; i++) {\n', '          marketCreationData[i][0].initialStartTime = _marketStartTime;\n', '          marketCreationData[i][1].initialStartTime = _marketStartTime;\n', '          createMarket(i, 0);\n', '          createMarket(i, 1);\n', '      }\n', '    }\n', '\n', '    /**\n', '    * @dev Add new market type.\n', '    * @param _predictionTime The time duration of market.\n', '    * @param _marketStartTime The time at which market will create.\n', '    * @param _optionRangePerc Option range percent of neutral min, max options (raised by 2 decimals)\n', '    */\n', '    function addNewMarketType(uint64 _predictionTime, uint64 _marketStartTime, uint64 _optionRangePerc) external onlyAuthorizedToGovern {\n', '      require(_marketStartTime > now);\n', '      uint256 _marketType = marketTypes.length;\n', '      _addMarket(_predictionTime, _optionRangePerc);\n', '      for(uint256 j = 0;j < marketCurrencies.length; j++) {\n', '        marketCreationData[_marketType][j].initialStartTime = _marketStartTime;\n', '        createMarket(_marketType, j);\n', '      }\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to add market type\n', '    * @param _predictionTime The time duration of market.\n', '    * @param _optionRangePerc Option range percent of neutral min, max options (raised by 2 decimals)\n', '    */\n', '    function _addMarket(uint64 _predictionTime, uint64 _optionRangePerc) internal {\n', '      uint256 _marketType = marketTypes.length;\n', '      marketTypes.push(MarketTypeData(_predictionTime, _optionRangePerc));\n', '      emit MarketTypes(_marketType, _predictionTime, _optionRangePerc);\n', '    }\n', '\n', '    /**\n', '    * @dev Add new market currency.\n', '    */\n', '    function addNewMarketCurrency(address _marketImplementation, uint64 _marketStartTime) external onlyAuthorizedToGovern {\n', '      uint256 _marketCurrencyIndex = marketCurrencies.length;\n', '      _addNewMarketCurrency(_marketImplementation);\n', '      for(uint256 j = 0;j < marketTypes.length; j++) {\n', '        marketCreationData[j][_marketCurrencyIndex].initialStartTime = _marketStartTime;\n', '        createMarket(j, _marketCurrencyIndex);\n', '      }\n', '    }\n', '\n', '    function _addNewMarketCurrency(address _marketImplementation) internal {\n', '      uint256 _marketCurrencyIndex = marketCurrencies.length;\n', '      (, bytes32 _currencyName, address _priceFeed) = IMarket(_marketImplementation).getMarketFeedData();\n', '      uint8 _decimals = marketUtility.getPriceFeedDecimals(_priceFeed);\n', '      marketCurrencies.push(MarketCurrency(_marketImplementation, _decimals));\n', '      emit MarketCurrencies(_marketCurrencyIndex, _marketImplementation, _priceFeed, _currencyName);\n', '    }\n', '\n', '    /**\n', '    * @dev Update the implementations of the market.\n', '    */\n', '    function updateMarketImplementations(uint256[] calldata _currencyIndexes, address[] calldata _marketImplementations) external onlyAuthorizedToGovern {\n', '      require(_currencyIndexes.length == _marketImplementations.length);\n', '      for(uint256 i = 0;i< _currencyIndexes.length; i++) {\n', '        (, , address _priceFeed) = IMarket(_marketImplementations[i]).getMarketFeedData();\n', '        uint8 _decimals = marketUtility.getPriceFeedDecimals(_priceFeed);\n', '        marketCurrencies[_currencyIndexes[i]] = MarketCurrency(_marketImplementations[i], _decimals);\n', '      }\n', '    }\n', '\n', '    /**\n', '    * @dev Upgrade the implementations of the contract.\n', '    * @param _proxyAddress the proxy address.\n', '    * @param _newImplementation Address of new implementation contract\n', '    */\n', '    function upgradeContractImplementation(address payable _proxyAddress, address _newImplementation) \n', '        external onlyAuthorizedToGovern\n', '    {\n', '      require(_newImplementation != address(0));\n', '      OwnedUpgradeabilityProxy tempInstance \n', '          = OwnedUpgradeabilityProxy(_proxyAddress);\n', '      tempInstance.upgradeTo(_newImplementation);\n', '    }\n', '\n', '    /**\n', "     * @dev Changes the master address and update it's instance\n", '     */\n', '    function setMasterAddress() public {\n', '      OwnedUpgradeabilityProxy proxy =  OwnedUpgradeabilityProxy(address(uint160(address(this))));\n', '      require(msg.sender == proxy.proxyOwner(),"Sender is not proxy owner.");\n', '      ms = IMaster(msg.sender);\n', '      masterAddress = msg.sender;\n', '      governance = IGovernance(ms.getLatestAddress("GV"));\n', '    }\n', '\n', '    /**\n', '    * @dev Creates the new market.\n', '    * @param _marketType The type of the market.\n', '    * @param _marketCurrencyIndex the index of market currency.\n', '    */\n', '    function _createMarket(uint256 _marketType, uint256 _marketCurrencyIndex, uint64 _minValue, uint64 _maxValue, uint64 _marketStartTime, bytes32 _currencyName) internal {\n', '      require(!marketCreationPaused);\n', '      MarketTypeData memory _marketTypeData = marketTypes[_marketType];\n', '      address payable _market = _generateProxy(marketCurrencies[_marketCurrencyIndex].marketImplementation);\n', '      marketData[_market].isMarket = true;\n', '      IMarket(_market).initiate(_marketStartTime, _marketTypeData.predictionTime, _minValue, _maxValue);\n', '      emit MarketQuestion(_market, _currencyName, _marketType, _marketStartTime);\n', '      (marketCreationData[_marketType][_marketCurrencyIndex].penultimateMarket, marketCreationData[_marketType][_marketCurrencyIndex].marketAddress) =\n', '       (marketCreationData[_marketType][_marketCurrencyIndex].marketAddress, _market);\n', '    }\n', '\n', '    /**\n', '    * @dev Creates the new market\n', '    * @param _marketType The type of the market.\n', '    * @param _marketCurrencyIndex the index of market currency.\n', '    */\n', '    function createMarket(uint256 _marketType, uint256 _marketCurrencyIndex) public payable{\n', '      address penultimateMarket = marketCreationData[_marketType][_marketCurrencyIndex].penultimateMarket;\n', '      if(penultimateMarket != address(0)) {\n', '        IMarket(penultimateMarket).settleMarket();\n', '      }\n', '      if(marketCreationData[_marketType][_marketCurrencyIndex].marketAddress != address(0)) {\n', '        (,,,,,,,, uint _status) = getMarketDetails(marketCreationData[_marketType][_marketCurrencyIndex].marketAddress);\n', '        require(_status >= uint(IMarket.PredictionStatus.InSettlement));\n', '      }\n', '      (uint8 _roundOfToNearest, bytes32 _currencyName, address _priceFeed) = IMarket(marketCurrencies[_marketCurrencyIndex].marketImplementation).getMarketFeedData();\n', '      marketUtility.update();\n', '      uint64 _marketStartTime = calculateStartTimeForMarket(_marketType, _marketCurrencyIndex);\n', '      uint64 _optionRangePerc = marketTypes[_marketType].optionRangePerc;\n', '      uint currentPrice = marketUtility.getAssetPriceUSD(_priceFeed);\n', '      _optionRangePerc = uint64(currentPrice.mul(_optionRangePerc.div(2)).div(10000));\n', '      uint64 _decimals = marketCurrencies[_marketCurrencyIndex].decimals;\n', '      uint64 _minValue = uint64((ceil(currentPrice.sub(_optionRangePerc).div(_roundOfToNearest), 10**_decimals)).mul(_roundOfToNearest));\n', '      uint64 _maxValue = uint64((ceil(currentPrice.add(_optionRangePerc).div(_roundOfToNearest), 10**_decimals)).mul(_roundOfToNearest));\n', '      _createMarket(_marketType, _marketCurrencyIndex, _minValue, _maxValue, _marketStartTime, _currencyName);\n', '      userData[msg.sender].marketsCreated++;\n', '    }\n', '\n', '    /**\n', '    * @dev function to reward user for initiating market creation calls\n', '    */\n', '    function claimCreationReward() external {\n', '      require(userData[msg.sender].marketsCreated > 0);\n', '      uint256 pendingReward = marketCreationIncentive.mul(userData[msg.sender].marketsCreated);\n', '      require(plotToken.balanceOf(address(this)) > pendingReward);\n', '      delete userData[msg.sender].marketsCreated;\n', '      _transferAsset(address(plotToken), msg.sender, pendingReward);\n', '    }\n', '\n', '    function calculateStartTimeForMarket(uint256 _marketType, uint256 _marketCurrencyIndex) public view returns(uint64 _marketStartTime) {\n', '      address previousMarket = marketCreationData[_marketType][_marketCurrencyIndex].marketAddress;\n', '      if(previousMarket != address(0)) {\n', '        (_marketStartTime, , , ) = IMarket(previousMarket).marketData();\n', '      } else {\n', '        _marketStartTime = marketCreationData[_marketType][_marketCurrencyIndex].initialStartTime;\n', '      }\n', '      uint predictionTime = marketTypes[_marketType].predictionTime;\n', '      if(now > _marketStartTime.add(predictionTime)) {\n', '        uint noOfMarketsSkipped = ((now).sub(_marketStartTime)).div(predictionTime);\n', '       _marketStartTime = uint64(_marketStartTime.add(noOfMarketsSkipped.mul(predictionTime)));\n', '      }\n', '    }\n', '\n', '    /**\n', '    * @dev Updates Flag to pause creation of market.\n', '    */\n', '    function pauseMarketCreation() external onlyAuthorizedToGovern {\n', '      require(!marketCreationPaused);\n', '        marketCreationPaused = true;\n', '    }\n', '\n', '    /**\n', '    * @dev Updates Flag to resume creation of market.\n', '    */\n', '    function resumeMarketCreation() external onlyAuthorizedToGovern {\n', '      require(marketCreationPaused);\n', '        marketCreationPaused = false;\n', '    }\n', '\n', '    /**\n', '    * @dev Create proposal if user wants to raise the dispute.\n', '    * @param proposalTitle The title of proposal created by user.\n', '    * @param description The description of dispute.\n', '    * @param solutionHash The ipfs solution hash.\n', '    * @param action The encoded action for solution.\n', '    * @param _stakeForDispute The token staked to raise the diospute.\n', '    * @param _user The address who raises the dispute.\n', '    */\n', '    function createGovernanceProposal(string memory proposalTitle, string memory description, string memory solutionHash, bytes memory action, uint256 _stakeForDispute, address _user, uint256 _ethSentToPool, uint256 _tokenSentToPool, uint256 _proposedValue) public {\n', '      require(isMarket(msg.sender));\n', '      uint64 proposalId = uint64(governance.getProposalLength());\n', '      marketData[msg.sender].disputeStakes = DisputeStake(proposalId, _user, _stakeForDispute, _ethSentToPool, _tokenSentToPool);\n', '      disputeProposalId[proposalId] = msg.sender;\n', '      governance.createProposalwithSolution(proposalTitle, proposalTitle, description, 10, solutionHash, action);\n', '      emit DisputeRaised(msg.sender, _user, proposalId, _proposedValue);\n', '    }\n', '\n', '    /**\n', '    * @dev Resolve the dispute if wrong value passed at the time of market result declaration.\n', '    * @param _marketAddress The address specify the market.\n', '    * @param _result The final result of the market.\n', '    */\n', '    function resolveDispute(address payable _marketAddress, uint256 _result) external onlyAuthorizedToGovern {\n', '      uint256 ethDepositedInPool = marketData[_marketAddress].disputeStakes.ethDeposited;\n', '      uint256 plotDepositedInPool = marketData[_marketAddress].disputeStakes.tokenDeposited;\n', '      uint256 stakedAmount = marketData[_marketAddress].disputeStakes.stakeAmount;\n', '      address payable staker = address(uint160(marketData[_marketAddress].disputeStakes.staker));\n', '      address plotTokenAddress = address(plotToken);\n', '      _transferAsset(plotTokenAddress, _marketAddress, plotDepositedInPool);\n', '      IMarket(_marketAddress).resolveDispute.value(ethDepositedInPool)(true, _result);\n', '      emit DisputeResolved(_marketAddress, true);\n', '      _transferAsset(plotTokenAddress, staker, stakedAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Burns the tokens of member who raised the dispute, if dispute is rejected.\n', '    * @param _proposalId Id of dispute resolution proposal\n', '    */\n', '    function burnDisputedProposalTokens(uint _proposalId) external onlyAuthorizedToGovern {\n', '      address disputedMarket = disputeProposalId[uint64(_proposalId)];\n', '      IMarket(disputedMarket).resolveDispute(false, 0);\n', '      emit DisputeResolved(disputedMarket, false);\n', '      uint _stakedAmount = marketData[disputedMarket].disputeStakes.stakeAmount;\n', '      plotToken.burn(_stakedAmount);\n', '    }\n', '\n', '    /**\n', '    * @dev Claim the pending return of the market.\n', '    * @param maxRecords Maximum number of records to claim reward for\n', '    */\n', '    function claimPendingReturn(uint256 maxRecords) external {\n', '      uint256 i;\n', '      uint len = userData[msg.sender].marketsParticipated.length;\n', '      uint lastClaimed = len;\n', '      uint count;\n', '      for(i = userData[msg.sender].lastClaimedIndex; i < len && count < maxRecords; i++) {\n', '        if(IMarket(userData[msg.sender].marketsParticipated[i]).claimReturn(msg.sender) > 0) {\n', '          count++;\n', '        } else {\n', '          if(lastClaimed == len) {\n', '            lastClaimed = i;\n', '          }\n', '        }\n', '      }\n', '      if(lastClaimed == len) {\n', '        lastClaimed = i;\n', '      }\n', '      userData[msg.sender].lastClaimedIndex = lastClaimed;\n', '    }\n', '\n', '    function () external payable {\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Transfer `_amount` number of market registry assets contract to `_to` address\n', '    */\n', '    function transferAssets(address _asset, address payable _to, uint _amount) external onlyAuthorizedToGovern {\n', '      _transferAsset(_asset, _to, _amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Transfer the assets to specified address.\n', '    * @param _asset The asset transfer to the specific address.\n', '    * @param _recipient The address to transfer the asset of\n', '    * @param _amount The amount which is transfer.\n', '    */\n', '    function _transferAsset(address _asset, address payable _recipient, uint256 _amount) internal {\n', '      if(_amount > 0) { \n', '        if(_asset == ETH_ADDRESS) {\n', '          _recipient.transfer(_amount);\n', '        } else {\n', '          require(IToken(_asset).transfer(_recipient, _amount));\n', '        }\n', '      }\n', '    }\n', '\n', '    function updateUintParameters(bytes8 code, uint256 value) external onlyAuthorizedToGovern {\n', '      if(code == "MCRINC") { // Incentive to be distributed to user for market creation\n', '        marketCreationIncentive = value;\n', '      } else {\n', '        marketUtility.updateUintParameters(code, value);\n', '      }\n', '    }\n', '\n', '    function updateConfigAddressParameters(bytes8 code, address payable value) external onlyAuthorizedToGovern {\n', '      marketUtility.updateAddressParameters(code, value);\n', '    }\n', '\n', '    /**\n', '     * @dev to generater proxy \n', '     * @param _contractAddress of the proxy\n', '     */\n', '    function _generateProxy(address _contractAddress) internal returns(address payable) {\n', '        OwnedUpgradeabilityProxy tempInstance = new OwnedUpgradeabilityProxy(_contractAddress);\n', '        return address(tempInstance);\n', '    }\n', '\n', '    /**\n', '    * @dev Emits the MarketResult event.\n', '    * @param _totalReward The amount of reward to be distribute.\n', '    * @param winningOption The winning option of the market.\n', '    * @param closeValue The closing value of the market currency.\n', '    */\n', '    function callMarketResultEvent(uint256[] calldata _totalReward, uint256 winningOption, uint256 closeValue, uint _roundId) external {\n', '      require(isMarket(msg.sender));\n', '      emit MarketResult(msg.sender, _totalReward, winningOption, closeValue, _roundId);\n', '    }\n', '    \n', '    /**\n', '    * @dev Emits the PlacePrediction event and sets the user data.\n', '    * @param _user The address who placed prediction.\n', '    * @param _value The amount of ether user staked.\n', '    * @param _predictionPoints The positions user will get.\n', '    * @param _predictionAsset The prediction assets user will get.\n', '    * @param _prediction The option range on which user placed prediction.\n', '    * @param _leverage The leverage selected by user at the time of place prediction.\n', '    */\n', '    function setUserGlobalPredictionData(address _user,uint256 _value, uint256 _predictionPoints, address _predictionAsset, uint256 _prediction, uint256 _leverage) external {\n', '      require(isMarket(msg.sender));\n', '      if(_predictionAsset == ETH_ADDRESS) {\n', '        userData[_user].totalEthStaked = userData[_user].totalEthStaked.add(_value);\n', '      } else {\n', '        userData[_user].totalPlotStaked = userData[_user].totalPlotStaked.add(_value);\n', '      }\n', '      if(!userData[_user].marketsParticipatedFlag[msg.sender]) {\n', '        userData[_user].marketsParticipated.push(msg.sender);\n', '        userData[_user].marketsParticipatedFlag[msg.sender] = true;\n', '      }\n', '      emit PlacePrediction(_user, _value, _predictionPoints, _predictionAsset, _prediction, msg.sender,_leverage);\n', '    }\n', '\n', '    /**\n', '    * @dev Emits the claimed event.\n', '    * @param _user The address who claim their reward.\n', '    * @param _reward The reward which is claimed by user.\n', '    * @param predictionAssets The prediction assets of user.\n', '    * @param incentives The incentives of user.\n', '    * @param incentiveToken The incentive tokens of user.\n', '    */\n', '    function callClaimedEvent(address _user ,uint[] calldata _reward, address[] calldata predictionAssets, uint incentives, address incentiveToken) external {\n', '      require(isMarket(msg.sender));\n', '      emit Claimed(msg.sender, _user, _reward, predictionAssets, incentives, incentiveToken);\n', '    }\n', '\n', '    /**\n', '    * @dev Get uint config parameters\n', '    */\n', '    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint256 value) {\n', '      if(code == "MCRINC") {\n', '        codeVal = code;\n', '        value = marketCreationIncentive;\n', '      }\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the market details of the specified address.\n', '    * @param _marketAdd The market address to query the details of market.\n', '    * @return _feedsource bytes32 representing the currency or stock name of the market.\n', '    * @return minvalue uint[] memory representing the minimum range of all the options of the market.\n', '    * @return maxvalue uint[] memory representing the maximum range of all the options of the market.\n', '    * @return optionprice uint[] memory representing the option price of each option ranges of the market.\n', '    * @return _ethStaked uint[] memory representing the ether staked on each option ranges of the market.\n', '    * @return _plotStaked uint[] memory representing the plot staked on each option ranges of the market.\n', '    * @return _predictionType uint representing the type of market.\n', '    * @return _expireTime uint representing the expire time of the market.\n', '    * @return _predictionStatus uint representing the status of the market.\n', '    */\n', '    function getMarketDetails(address _marketAdd)public view returns\n', '    (bytes32 _feedsource,uint256[] memory minvalue,uint256[] memory maxvalue,\n', '      uint256[] memory optionprice,uint256[] memory _ethStaked, uint256[] memory _plotStaked,uint256 _predictionType,uint256 _expireTime, uint256 _predictionStatus){\n', '      return IMarket(_marketAdd).getData();\n', '    }\n', '\n', '    /**\n', '    * @dev Get total assets staked by user in PlotX platform\n', '    * @return _plotStaked Total PLOT staked by user\n', '    * @return _ethStaked Total ETH staked by user\n', '    */\n', '    function getTotalAssetStakedByUser(address _user) external view returns(uint256 _plotStaked, uint256 _ethStaked) {\n', '      return (userData[_user].totalPlotStaked, userData[_user].totalEthStaked);\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the market details of the specified user address.\n', '    * @param user The address to query the details of market.\n', '    * @param fromIndex The index to query the details from.\n', '    * @param toIndex The index to query the details to\n', '    * @return _market address[] memory representing the address of the market.\n', '    * @return _winnigOption uint256[] memory representing the winning option range of the market.\n', '    */\n', '    function getMarketDetailsUser(address user, uint256 fromIndex, uint256 toIndex) external view returns\n', '    (address[] memory _market, uint256[] memory _winnigOption){\n', '      uint256 totalMarketParticipated = userData[user].marketsParticipated.length;\n', '      if(totalMarketParticipated > 0 && fromIndex < totalMarketParticipated) {\n', '        uint256 _toIndex = toIndex;\n', '        if(_toIndex >= totalMarketParticipated) {\n', '          _toIndex = totalMarketParticipated - 1;\n', '        }\n', '        _market = new address[](_toIndex.sub(fromIndex).add(1));\n', '        _winnigOption = new uint256[](_toIndex.sub(fromIndex).add(1));\n', '        for(uint256 i = fromIndex; i <= _toIndex; i++) {\n', '          _market[i] = userData[user].marketsParticipated[i];\n', '          (_winnigOption[i], ) = IMarket(_market[i]).marketSettleData();\n', '        }\n', '      }\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the addresses of open markets.\n', '    * @return _openMarkets address[] memory representing the open market addresses.\n', '    * @return _marketTypes uint256[] memory representing the open market types.\n', '    */\n', '    function getOpenMarkets() external view returns(address[] memory _openMarkets, uint256[] memory _marketTypes, bytes32[] memory _marketCurrencies) {\n', '      uint256  count = 0;\n', '      uint256 marketTypeLength = marketTypes.length;\n', '      uint256 marketCurrencyLength = marketCurrencies.length;\n', '      _openMarkets = new address[]((marketTypeLength).mul(marketCurrencyLength));\n', '      _marketTypes = new uint256[]((marketTypeLength).mul(marketCurrencyLength));\n', '      _marketCurrencies = new bytes32[]((marketTypeLength).mul(marketCurrencyLength));\n', '      for(uint256 i = 0; i< marketTypeLength; i++) {\n', '        for(uint256 j = 0; j< marketCurrencyLength; j++) {\n', '          _openMarkets[count] = marketCreationData[i][j].marketAddress;\n', '          _marketTypes[count] = i;\n', '          _marketCurrencies[count] = IMarket(marketCurrencies[j].marketImplementation).marketCurrency();\n', '          count++;\n', '        }\n', '      }\n', '    }\n', '\n', '    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n', '        return ((a + m - 1) / m) * m;\n', '    }\n', '\n', '    // /**\n', '    // * @dev Calculates the user pending return amount.\n', '    // * @param _user The address to query the pending return amount of.\n', '    // * @return pendingReturn uint256 representing the pending return amount of user.\n', '    // * @return incentive uint256 representing the incentive.\n', '    // */\n', '    // function calculateUserPendingReturn(address _user) external view returns(uint[] memory returnAmount, address[] memory _predictionAssets, uint[] memory incentive, address[] memory _incentiveTokens) {\n', '    //   uint256 _return;\n', '    //   uint256 _incentive;\n', '    //   for(uint256 i = lastClaimedIndex[_user]; i < marketsParticipated[_user].length; i++) {\n', '    //     // pendingReturn = pendingReturn.add(marketsParticipated[_user][i].call(abi.encodeWithSignature("getPendingReturn(uint256)", _user)));\n', '    //     (_return, _incentive) = IMarket(marketsParticipated[_user][i]).getPendingReturn(_user);\n', '    //     pendingReturn = pendingReturn.add(_return);\n', '    //     incentive = incentive.add(_incentive);\n', '    //   }\n', '    // }\n', '\n', '}']