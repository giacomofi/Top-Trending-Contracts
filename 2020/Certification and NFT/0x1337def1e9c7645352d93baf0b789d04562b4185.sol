['pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', 'contract Context {\n', '    constructor () internal { }\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', '\n', 'interface IERC165 {\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', 'contract ERC165 is IERC165 {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor () internal {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', 'contract IERC721Receiver {\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n', '    public returns (bytes4);\n', '}\n', '\n', 'contract ERC721 is Context, ERC165, IERC721 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '    mapping (uint256 => address) private _tokenOwner;\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '    uint256 internal _totalSupply;\n', '\n', '    /**\n', '     * @dev Enumerable takes care of this.\n', '    **/\n', '    //mapping (address => Counters.Counter) private _ownedTokensCount;\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '\n', '    constructor () public {\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '      return _totalSupply;\n', '    }\n', '    \n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        address owner = _tokenOwner[tokenId];\n', '        require(owner != address(0), "ERC721: owner query for nonexistent token");\n', '\n', '        return owner;\n', '    }\n', '    function approve(address to, uint256 tokenId) public {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner, "ERC721: approval to current owner");\n', '\n', '        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n', '            "ERC721: approve caller is not owner nor approved for all"\n', '        );\n', '\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(owner, to, tokenId);\n', '    }\n', '    function getApproved(uint256 tokenId) public view returns (address) {\n', '        require(_exists(tokenId), "ERC721: approved query for nonexistent token");\n', '\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '    function setApprovalForAll(address to, bool approved) public {\n', '        require(to != _msgSender(), "ERC721: approve to caller");\n', '\n', '        _operatorApprovals[_msgSender()][to] = approved;\n', '        emit ApprovalForAll(_msgSender(), to, approved);\n', '    }\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', '        //solhint-disable-next-line max-line-length\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");\n', '\n', '        _transferFrom(from, to, tokenId);\n', '    }\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");\n', '        _safeTransferFrom(from, to, tokenId, _data);\n', '    }\n', '    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\n', '        _transferFrom(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        address owner = _tokenOwner[tokenId];\n', '        return owner != address(0);\n', '    }\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        require(_exists(tokenId), "ERC721: operator query for nonexistent token");\n', '        address owner = ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '    function _safeMint(address to, uint256 tokenId) internal {\n', '        _safeMint(to, tokenId, "");\n', '    }\n', '    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n', '        _mint(to, tokenId);\n', '        require(_checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        require(to != address(0), "ERC721: mint to the zero address");\n', '        require(!_exists(tokenId), "ERC721: token already minted");\n', '\n', '        _tokenOwner[tokenId] = to;\n', '        _totalSupply = _totalSupply.add(1);\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == owner, "ERC721: burn of token that is not own");\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _tokenOwner[tokenId] = address(0);\n', '        _totalSupply = _totalSupply.sub(1);\n', '\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '    function _burn(uint256 tokenId) internal {\n', '        _burn(ownerOf(tokenId), tokenId);\n', '    }\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");\n', '        require(to != address(0), "ERC721: transfer to the zero address");\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _tokenOwner[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        internal returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\n', '            IERC721Receiver(to).onERC721Received.selector,\n', '            _msgSender(),\n', '            from,\n', '            tokenId,\n', '            _data\n', '        ));\n', '        if (!success) {\n', '            if (returndata.length > 0) {\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert("ERC721: transfer to non ERC721Receiver implementer");\n', '            }\n', '        } else {\n', '            bytes4 retval = abi.decode(returndata, (bytes4));\n', '            return (retval == _ERC721_RECEIVED);\n', '        }\n', '    }\n', '    function _clearApproval(uint256 tokenId) private {\n', '        if (_tokenApprovals[tokenId] != address(0)) {\n', '            _tokenApprovals[tokenId] = address(0);\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract IERC721Enumerable is IERC721 {\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n', '}\n', '\n', 'contract ERC721Enumerable is Context, ERC165, ERC721, IERC721Enumerable {\n', '    mapping(address => uint256[]) private _ownedTokens;\n', '    mapping(uint256 => uint256) private _ownedTokensIndex;\n', '    /**\n', "     * @dev We've removed allTokens functionality.\n", '    **/\n', '    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n', '\n', '    constructor () public {\n', '        // register the supported interface to conform to ERC721Enumerable via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n', '    }\n', '    \n', '    /**\n', '     * @dev Added for arNFT (removed from ERC721 basic).\n', '    **/\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        require(owner != address(0), "ERC721: balance query for the zero address");\n', '\n', '        return _ownedTokens[owner].length;\n', '    }\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n', '        require(index < balanceOf(owner), "ERC721Enumerable: owner index out of bounds");\n', '        return _ownedTokens[owner][index];\n', '    }\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        super._transferFrom(from, to, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(from, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '    }\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        super._mint(to, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '    }\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        super._burn(owner, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(owner, tokenId);\n', '        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n', '        _ownedTokensIndex[tokenId] = 0;\n', '    }\n', '    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n', '        return _ownedTokens[owner];\n', '    }\n', '    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n', '        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n', '        _ownedTokens[to].push(tokenId);\n', '    }\n', '    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n', '        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n', '        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n', '\n', '            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '        }\n', '        _ownedTokens[from].length--;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract IERC721Metadata is IERC721 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', 'contract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\n', '    string private _name;\n', '    string private _symbol;\n', '    string private _baseURI;\n', '    mapping(uint256 => string) private _tokenURIs;\n', '    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n', '\n', '    constructor (string memory name, string memory symbol) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n', '    }\n', '    function name() external view returns (string memory) {\n', '        return _name;\n', '    }\n', '    function symbol() external view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '    function tokenURI(uint256 tokenId) external view returns (string memory) {\n', '        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n', '\n', '        string memory _tokenURI = _tokenURIs[tokenId];\n', '\n', '        // Even if there is a base URI, it is only appended to non-empty token-specific URIs\n', '        if (bytes(_tokenURI).length == 0) {\n', '            return "";\n', '        } else {\n', '            // abi.encodePacked is being used to concatenate strings\n', '            return string(abi.encodePacked(_baseURI, _tokenURI));\n', '        }\n', '    }\n', '    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {\n', '        require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");\n', '        _tokenURIs[tokenId] = _tokenURI;\n', '    }\n', '    function _setBaseURI(string memory baseURI) internal {\n', '        _baseURI = baseURI;\n', '    }\n', '    function baseURI() external view returns (string memory) {\n', '        return _baseURI;\n', '    }\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        super._burn(owner, tokenId);\n', '\n', '        // Clear metadata (if any)\n', '        if (bytes(_tokenURIs[tokenId]).length != 0) {\n', '            delete _tokenURIs[tokenId];\n', '        }\n', '    }\n', '}\n', '\n', 'contract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n', '    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n', '        // solhint-disable-previous-line no-empty-blocks\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '    bool private _notEntered;\n', '\n', '    constructor () internal {\n', '        _notEntered = true;\n', '    }\n', '    modifier nonReentrant() {\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '        _notEntered = false;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '}\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    function decimals() external returns (uint8);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        // disabled require for making usages simple\n', '        //require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '        //    "SafeERC20: approve from non-zero to non-zero allowance"\n', '        //);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'interface IClaims {\n', '    function getClaimbyIndex(uint _claimId) external view returns (\n', '        uint claimId,\n', '        uint status,\n', '        int8 finalVerdict,\n', '        address claimOwner,\n', '        uint coverId\n', '    );\n', '    function submitClaim(uint coverId) external;\n', '}\n', '\n', 'interface IClaimsData {\n', '    function actualClaimLength() external view returns(uint);\n', '}\n', '\n', 'interface IDSValue {\n', '    function peek() external view returns (bytes32, bool);\n', '    function read() external view returns (bytes32);\n', '}\n', '\n', '\n', 'interface INXMMaster {\n', '    function tokenAddress() external view returns(address);\n', '    function owner() external view returns(address);\n', '    function pauseTime() external view returns(uint);\n', '    function masterInitialized() external view returns(bool);\n', '    function isPause() external view returns(bool check);\n', '    function isMember(address _add) external view returns(bool);\n', '    function getLatestAddress(bytes2 _contractName) external view returns(address payable contractAddress);\n', '}\n', '\n', 'interface IMemberRoles {\n', '    function switchMembership(address) external;\n', '}\n', '\n', 'interface INXMToken {\n', '    function balanceOf(address owner) external view returns (uint256);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '}\n', '\n', 'interface IPool1  {\n', '    function changeDependentContractAddress() external;\n', '    function makeCoverBegin(\n', '        address smartCAdd,\n', '        bytes4 coverCurr,\n', '        uint[] calldata coverDetails,\n', '        uint16 coverPeriod,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external\n', '        payable;\n', '    function makeCoverUsingCA(\n', '        address smartCAdd,\n', '        bytes4 coverCurr,\n', '        uint[] calldata coverDetails,\n', '        uint16 coverPeriod,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    )\n', '        external;\n', '    function getWei(uint amount) external view returns(uint);\n', '    function sellNXMTokens(uint _amount) external  returns (bool);\n', '}\n', '\n', '\n', 'interface IPoolData {\n', '\n', '    struct ApiId {\n', '        bytes4 typeOf;\n', '        bytes4 currency;\n', '        uint id;\n', '        uint64 dateAdd;\n', '        uint64 dateUpd;\n', '    }\n', '\n', '    struct CurrencyAssets {\n', '        address currAddress;\n', '        uint baseMin;\n', '        uint varMin;\n', '    }\n', '\n', '    struct InvestmentAssets {\n', '        address currAddress;\n', '        bool status;\n', '        uint64 minHoldingPercX100;\n', '        uint64 maxHoldingPercX100;\n', '        uint8 decimals;\n', '    }\n', '\n', '    struct IARankDetails {\n', '        bytes4 maxIACurr;\n', '        uint64 maxRate;\n', '        bytes4 minIACurr;\n', '        uint64 minRate;\n', '    }\n', '\n', '    struct McrData {\n', '        uint mcrPercx100;\n', '        uint mcrEther;\n', '        uint vFull; //Pool funds\n', '        uint64 date;\n', '    }\n', '\n', '    function setCapReached(uint val) external;\n', '    function getInvestmentAssetDecimals(bytes4 curr) external returns(uint8 decimal);\n', '    function getCurrencyAssetAddress(bytes4 curr) external view returns(address);\n', '    function getInvestmentAssetAddress(bytes4 curr) external view returns(address);\n', '    function getInvestmentAssetStatus(bytes4 curr) external view returns(bool status);\n', '}\n', '\n', 'interface IQuotationData {\n', '\n', '    enum HCIDStatus { NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover }\n', '    enum CoverStatus { Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested }\n', '\n', '    struct Cover {\n', '        address payable memberAddress;\n', '        bytes4 currencyCode;\n', '        uint sumAssured;\n', '        uint16 coverPeriod;\n', '        uint validUntil;\n', '        address scAddress;\n', '        uint premiumNXM;\n', '    }\n', '\n', '    struct HoldCover {\n', '        uint holdCoverId;\n', '        address payable userAddress;\n', '        address scAddress;\n', '        bytes4 coverCurr;\n', '        uint[] coverDetails;\n', '        uint16 coverPeriod;\n', '    }\n', '\n', '    function getCoverLength() external returns(uint len);\n', '    function getAuthQuoteEngine() external returns(address _add);\n', '    function getAllCoversOfUser(address _add) external returns(uint[] memory allCover);\n', '    function getUserCoverLength(address _add) external returns(uint len);\n', '    function getCoverStatusNo(uint _cid) external returns(uint8);\n', '    function getCoverPeriod(uint _cid) external returns(uint32 cp);\n', '    function getCoverSumAssured(uint _cid) external returns(uint sa);\n', '    function getCurrencyOfCover(uint _cid) external returns(bytes4 curr);\n', '    function getValidityOfCover(uint _cid) external returns(uint date);\n', '    function getscAddressOfCover(uint _cid) external returns(uint, address);\n', '    function getCoverMemberAddress(uint _cid) external returns(address payable _add);\n', '    function getCoverPremiumNXM(uint _cid) external returns(uint _premiumNXM);\n', '    function getCoverDetailsByCoverID1(\n', '        uint _cid\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            uint cid,\n', '            address _memberAddress,\n', '            address _scAddress,\n', '            bytes4 _currencyCode,\n', '            uint _sumAssured,\n', '            uint premiumNXM\n', '        );\n', '    function getCoverDetailsByCoverID2(\n', '        uint _cid\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            uint cid,\n', '            uint8 status,\n', '            uint sumAssured,\n', '            uint16 coverPeriod,\n', '            uint validUntil\n', '        );\n', '    function getHoldedCoverDetailsByID1(\n', '        uint _hcid\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            uint hcid,\n', '            address scAddress,\n', '            bytes4 coverCurr,\n', '            uint16 coverPeriod\n', '        );\n', '    function getUserHoldedCoverLength(address _add) external returns (uint);\n', '    function getUserHoldedCoverByIndex(address _add, uint index) external returns (uint);\n', '    function getHoldedCoverDetailsByID2(\n', '        uint _hcid\n', '    )\n', '        external\n', '        returns (\n', '            uint hcid,\n', '            address payable memberAddress,\n', '            uint[] memory coverDetails\n', '        );\n', '    function getTotalSumAssuredSC(address _add, bytes4 _curr) external returns(uint amount);\n', '\n', '}\n', '\n', 'interface ITokenData {\n', '    function lockTokenTimeAfterCoverExp() external returns (uint);\n', '}\n', '\n', '\n', 'interface IyInsure {\n', '    struct Token {\n', '        uint expirationTimestamp;\n', '        bytes4 coverCurrency;\n', '        uint coverAmount;\n', '        uint coverPrice;\n', '        uint coverPriceNXM;\n', '        uint expireTime;\n', '        uint generationTime;\n', '        uint coverId;\n', '        bool claimInProgress;\n', '        uint claimId;\n', '    }\n', '    \n', '    function transferFrom(address sender, address recipient, uint256 amount) external;\n', '    function submitClaim(uint256 tokenId) external;\n', '    function tokens(uint256 tokenId) external returns (uint, bytes4, uint, uint, uint, uint, uint, uint, bool, uint);\n', '}\n', '\n', '/** \n', '    @title Armor NFT\n', '    @dev Armor NFT allows users to purchase Nexus Mutual cover and convert it into \n', '         a transferable token. It also allows users to swap their Yearn yNFT for Armor arNFT.\n', '    @author ArmorFi -- Robert M.C. Forster, Taek Lee\n', '**/\n', 'contract arNFT is\n', '    ERC721Full("ArmorNFT", "arNFT"),\n', '    Ownable,\n', '    ReentrancyGuard {\n', '    \n', '    using SafeMath for uint;\n', '    using SafeERC20 for IERC20;\n', '    \n', '    bytes4 internal constant ethCurrency = "ETH";\n', '    \n', '    // cover Id => claim Id\n', '    mapping (uint256 => uint256) public claimIds;\n', '    \n', '    // cover Id => cover price\n', '    mapping (uint256 => uint256) public coverPrices;\n', '    \n', '    // cover Id => yNFT token Id.\n', '    // Used to route yNFT submits through their contract.\n', '    // if zero, it is not swapped from yInsure\n', '    mapping (uint256 => uint256) public swapIds;\n', '\n', '    // Mapping ("NAME" => smart contract address) of allowed cover currencies.\n', '    mapping (bytes4 => address) public coverCurrencies;\n', '\n', '    // indicates if swap for yInsure is available\n', '    // cannot go back to false\n', '    bool public swapActivated;\n', '\n', '    // Nexus Mutual master contract.\n', '    INXMMaster public nxMaster;\n', '\n', "    // yNFT contract that we're swapping tokens from.\n", '    IyInsure public ynft;\n', '\n', '    // NXM token.\n', '    IERC20 public nxmToken;\n', '    \n', '    enum CoverStatus {\n', '        Active,\n', '        ClaimAccepted,\n', '        ClaimDenied,\n', '        CoverExpired,\n', '        ClaimSubmitted,\n', '        Requested\n', '    }\n', '    \n', '    enum ClaimStatus {\n', '        PendingClaimAssessorVote, // 0\n', '        PendingClaimAssessorVoteDenied, // 1\n', '        PendingClaimAssessorVoteThresholdNotReachedAccept, // 2\n', '        PendingClaimAssessorVoteThresholdNotReachedDeny, // 3\n', '        PendingClaimAssessorConsensusNotReachedAccept, // 4\n', '        PendingClaimAssessorConsensusNotReachedDeny, // 5\n', '        FinalClaimAssessorVoteDenied, // 6\n', '        FinalClaimAssessorVoteAccepted, // 7\n', '        FinalClaimAssessorVoteDeniedMVAccepted, // 8\n', '        FinalClaimAssessorVoteDeniedMVDenied, // 9\n', '        FinalClaimAssessorVotAcceptedMVNoDecision, // 10\n', '        FinalClaimAssessorVoteDeniedMVNoDecision, // 11\n', '        ClaimAcceptedPayoutPending, // 12\n', '        ClaimAcceptedNoPayout, // 13\n', '        ClaimAcceptedPayoutDone // 14\n', '    }\n', '\n', '    event SwappedYInsure (\n', '        uint256 indexed yInsureTokenId,\n', '        uint256 indexed coverId\n', '    );\n', '\n', '    event ClaimSubmitted (\n', '        uint256 indexed coverId,\n', '        uint256 indexed claimId\n', '    );\n', '    \n', '    event ClaimRedeemed (\n', '        address indexed receiver,\n', '        bytes4 indexed currency,\n', '        uint256 value\n', '    );\n', '\n', '    event BuyCover (\n', '        uint indexed coverId,\n', '        address indexed buyer,\n', '        address indexed coveredContract,\n', '        bytes4 currency,\n', '        uint256 coverAmount,\n', '        uint256 coverPrice,\n', '        uint256 startTime,\n', '        uint16 coverPeriod\n', '    );\n', '\n', '    \n', '    /**\n', '     * @dev Make sure only the owner of a token or someone approved to transfer it can call.\n', '     * @param _tokenId Id of the token being checked.\n', '    **/\n', '    modifier onlyTokenApprovedOrOwner(uint256 _tokenId) {\n', '        require(_isApprovedOrOwner(msg.sender, _tokenId), "Not approved or owner");\n', '        _;\n', '    }\n', '\n', '    constructor(address _nxMaster, address _ynft, address _nxmToken) public {\n', '        nxMaster = INXMMaster(_nxMaster);\n', '        ynft = IyInsure(_ynft);\n', '        nxmToken = IERC20(_nxmToken);\n', '    }\n', '    \n', '    function () payable external {}\n', '    \n', '    // Arguments to be passed as coverDetails, from the quote api:\n', '    //    coverDetails[0] = coverAmount;\n', '    //    coverDetails[1] = coverPrice;\n', '    //    coverDetails[2] = coverPriceNXM;\n', '    //    coverDetails[3] = expireTime;\n', '    //    coverDetails[4] = generationTime;\n', '    /**\n', '     * @dev Main function to buy a cover.\n', '     * @param _coveredContractAddress Address of the protocol to buy cover for.\n', '     * @param _coverCurrency bytes4 currency name to buy coverage for.\n', '     * @param _coverPeriod Amount of time to buy cover for.\n', '     * @param _v , _r, _s Signature of the Nexus Mutual API.\n', '    **/\n', '    function buyCover(\n', '        address _coveredContractAddress,\n', '        bytes4 _coverCurrency,\n', '        uint[] calldata _coverDetails,\n', '        uint16 _coverPeriod,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) external payable {\n', '        uint256 coverPrice = _coverDetails[1];\n', '\n', '        if (_coverCurrency == "ETH") {\n', '            require(msg.value == coverPrice, "Incorrect value sent");\n', '        } else {\n', '            IERC20 erc20 = IERC20( coverCurrencies[_coverCurrency] );\n', '            require(erc20 != IERC20( address(0) ), "Cover currency is not allowed.");\n', '\n', '            require(msg.value == 0, "Eth not required when buying with erc20");\n', '            erc20.safeTransferFrom(msg.sender, address(this), coverPrice);\n', '        }\n', '        \n', '        uint256 coverId = _buyCover(_coveredContractAddress, _coverCurrency, _coverDetails, _coverPeriod, _v, _r, _s);\n', '        _mint(msg.sender, coverId);\n', '        \n', '        emit BuyCover(coverId, msg.sender, _coveredContractAddress, _coverCurrency, _coverDetails[0], _coverDetails[1], \n', '                      block.timestamp, _coverPeriod);\n', '    }\n', '    \n', '    /**\n', '     * @dev Submit a claim for the NFT after a hack has happened on its protocol.\n', '     * @param _tokenId ID of the token a claim is being submitted for.\n', '    **/\n', '    function submitClaim(uint256 _tokenId) external onlyTokenApprovedOrOwner(_tokenId) {\n', '        // If this was a yNFT swap, we must route the submit through them.\n', '        if (swapIds[_tokenId] != 0) {\n', '            _submitYnftClaim(_tokenId);\n', '            return;\n', '        }\n', '        \n', '        (uint256 coverId, /*uint8 coverStatus*/, /*sumAssured*/, /*coverPeriod*/, /*uint256 validUntil*/) = _getCover2(_tokenId);\n', '\n', '        uint256 claimId = _submitClaim(coverId);\n', '        claimIds[_tokenId] = claimId;\n', '        \n', '        emit ClaimSubmitted(coverId, claimId);\n', '    }\n', '    \n', '    /**\n', '     * @dev Redeem a claim that has been accepted and paid out.\n', '     * @param _tokenId Id of the token to redeem claim for.\n', '    **/\n', '    function redeemClaim(uint256 _tokenId) public onlyTokenApprovedOrOwner(_tokenId)  nonReentrant {\n', '        require(claimIds[_tokenId] != 0, "No claim is in progress.");\n', '        \n', '        (/*cid*/, /*memberAddress*/, /*scAddress*/, bytes4 currencyCode, /*sumAssured*/, /*premiumNXM*/) = _getCover1(_tokenId);\n', '        ( , /*uint8 coverStatus*/, uint256 sumAssured, , ) = _getCover2(_tokenId);\n', '        \n', '        require(_payoutIsCompleted(claimIds[_tokenId]), "Claim accepted but payout not completed");\n', '       \n', '        // this will prevent duplicate redeem \n', '        _burn(_tokenId);\n', '        _sendAssuredSum(currencyCode, sumAssured);\n', '        \n', '        emit ClaimRedeemed(msg.sender, currencyCode, sumAssured);\n', '    }\n', '    \n', '    function activateSwap()\n', '      public\n', '      onlyOwner\n', '    {\n', '        require(!swapActivated, "Already Activated");\n', '        swapActivated = true;\n', '    }\n', '\n', '    /**\n', '     * @dev External swap yNFT token for our own. Simple process because we do not need to create cover.\n', "     * @param _ynftTokenId The ID of the token on yNFT's contract.\n", '    **/\n', '    function swapYnft(uint256 _ynftTokenId)\n', '      public\n', '    {\n', '        require(swapActivated, "Swap is not activated yet");\n', '        //this does not returns bool\n', '        ynft.transferFrom(msg.sender, address(this), _ynftTokenId);\n', '        \n', '        (uint256 coverPrice, uint256 coverId, uint256 claimId) = _getCoverAndClaim(_ynftTokenId);\n', '\n', '        _mint(msg.sender, coverId);\n', '\n', '        swapIds[coverId] = _ynftTokenId;\n', '        claimIds[coverId] = claimId;\n', '        coverPrices[coverId] = coverPrice;\n', '        \n', '        emit SwappedYInsure(_ynftTokenId, coverId);\n', '    }\n', '    \n', '    /**\n', '     * @dev Swaps a batch of yNFT tokens for our own.\n', "     * @param _tokenIds An array of the IDs of the tokens on yNFT's contract.\n", '    **/\n', '    function batchSwapYnft(uint256[] calldata _tokenIds)\n', '      external\n', '    {\n', '        for (uint256 i = 0; i < _tokenIds.length; i++) {\n', '            swapYnft(_tokenIds[i]);\n', '        }\n', '    }\n', '    \n', '   /**\n', "     * @dev Owner can approve the contract for any new ERC20 (so we don't need to in every buy).\n", '     * @param _tokenAddress Address of the ERC20 that we want approved.\n', '    **/\n', '    function approveToken(address _tokenAddress)\n', '      external\n', '    {\n', '        IPool1 pool1 = IPool1(nxMaster.getLatestAddress("P1"));\n', '        address payable pool1Address = address(uint160(address(pool1)));\n', '        IERC20 erc20 = IERC20(_tokenAddress);\n', '        erc20.safeApprove( pool1Address, uint256(-1) );\n', '    }\n', '    \n', '    /**\n', '     * @dev Getter for all token info from Nexus Mutual.\n', '     * @param _tokenId of the token to get cover info for (also NXM cover ID).\n', '     * @return All info from NXM about the cover.\n', '    **/\n', '    function getToken(uint256 _tokenId)\n', '      external\n', '      view\n', '    returns (uint256 cid, \n', '             uint8 status, \n', '             uint256 sumAssured,\n', '             uint16 coverPeriod, \n', '             uint256 validUntil, \n', '             address scAddress, \n', '             bytes4 currencyCode, \n', '             uint256 premiumNXM,\n', '             uint256 coverPrice,\n', '             uint256 claimId)\n', '    {\n', '        (/*cid*/, /*memberAddress*/, scAddress, currencyCode, /*sumAssured*/, premiumNXM) = _getCover1(_tokenId);\n', '        (cid, status, sumAssured, coverPeriod, validUntil) = _getCover2(_tokenId);\n', '        coverPrice = coverPrices[_tokenId];\n', '        claimId = claimIds[_tokenId];\n', '    }\n', '    \n', '    /**\n', '     * @dev Get status of a cover claim.\n', "     * @param _tokenId Id of the token we're checking.\n", '     * @return Status of the claim being made on the token.\n', '    **/\n', '    function getCoverStatus(uint256 _tokenId) external view returns (uint8 coverStatus, bool payoutCompleted) {\n', '        (, coverStatus, , , ) = _getCover2(_tokenId);\n', '        payoutCompleted = _payoutIsCompleted(claimIds[_tokenId]);\n', '    }\n', '    \n', '    /**\n', '     * @dev Get address of the NXM Member Roles contract.\n', '     * @return Address of the current Member Roles contract.\n', '    **/\n', '    function getMemberRoles() public view returns (address) {\n', '        return nxMaster.getLatestAddress("MR");\n', '    }\n', '    \n', '    /**\n', '     * @dev Change membership to new address.\n', '     * @param _newMembership Membership address to change to.\n', '    **/\n', '    function switchMembership(address _newMembership) external onlyOwner {\n', '        nxmToken.safeApprove(getMemberRoles(),uint(-1));\n', '        IMemberRoles(getMemberRoles()).switchMembership(_newMembership);\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function for buying cover--params are same as eponymous external function.\n', '     * @return coverId ID of the new cover that has been bought.\n', '    **/\n', '    function _buyCover(\n', '        address _coveredContractAddress,\n', '        bytes4 _coverCurrency,\n', '        uint[] memory _coverDetails,\n', '        uint16 _coverPeriod,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) internal returns (uint256 coverId) {\n', '    \n', '        uint256 coverPrice = _coverDetails[1];\n', '        IPool1 pool1 = IPool1(nxMaster.getLatestAddress("P1"));\n', '\n', '        if (_coverCurrency == "ETH") {\n', '            pool1.makeCoverBegin.value(coverPrice)(_coveredContractAddress, _coverCurrency, _coverDetails, _coverPeriod, _v, _r, _s);\n', '        } else {\n', '            pool1.makeCoverUsingCA(_coveredContractAddress, _coverCurrency, _coverDetails, _coverPeriod, _v, _r, _s);\n', '        }\n', '    \n', '        IQuotationData quotationData = IQuotationData(nxMaster.getLatestAddress("QD"));\n', '        // *assumes* the newly created claim is appended at the end of the list covers\n', '        coverId = quotationData.getCoverLength().sub(1);\n', '        \n', '        // Keep track of how much was paid for this cover.\n', '        coverPrices[coverId] = coverPrice;\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal submit claim function.\n', '     * @param _coverId on the NXM contract (same as our token ID).\n', '     * @return claimId of the new claim.\n', '    **/\n', '    function _submitClaim(uint256 _coverId) internal returns (uint256) {\n', '        IClaims claims = IClaims(nxMaster.getLatestAddress("CL"));\n', '        claims.submitClaim(_coverId);\n', '    \n', '        IClaimsData claimsData = IClaimsData(nxMaster.getLatestAddress("CD"));\n', '        uint256 claimId = claimsData.actualClaimLength() - 1;\n', '        return claimId;\n', '    }\n', '    \n', '    /**\n', '     * Submits a claim through yNFT if this was a swapped token.\n', '     * @param _tokenId ID of the token on the arNFT contract.\n', '    **/\n', '    function _submitYnftClaim(uint256 _tokenId)\n', '      internal\n', '    {\n', '        uint256 ynftTokenId = swapIds[_tokenId];\n', '        ynft.submitClaim(ynftTokenId);\n', '        \n', '        (/*coverPrice*/, /*coverId*/, uint256 claimId) = _getCoverAndClaim(ynftTokenId);\n', '        claimIds[_tokenId] = claimId;\n', '    }\n', '\n', '    /**\n', '     * @dev Check whether the payout of a claim has occurred.\n', '     * @param _claimId ID of the claim we are checking.\n', '     * @return True if claim has been paid out, false if not.\n', '    **/\n', '    function _payoutIsCompleted(uint256 _claimId) internal view returns (bool) {\n', '        uint256 status;\n', '        IClaims claims = IClaims(nxMaster.getLatestAddress("CL"));\n', '        (, status, , , ) = claims.getClaimbyIndex(_claimId);\n', '        return status == uint256(ClaimStatus.ClaimAcceptedPayoutDone);\n', '    }\n', '\n', '    /**\n', '     * @dev Send tokens after a successful redeem claim.\n', '     * @param _coverCurrency bytes4 of the currency being used.\n', '     * @param _sumAssured The amount of the currency to send.\n', '    **/\n', '    function _sendAssuredSum(bytes4 _coverCurrency, uint256 _sumAssured) internal {\n', '        uint256 claimReward;\n', '\n', '        if (_coverCurrency == ethCurrency) {\n', '            claimReward = _sumAssured * (10 ** 18);\n', '            msg.sender.transfer(claimReward);\n', '        } else {\n', '            IERC20 erc20 = IERC20( coverCurrencies[_coverCurrency] );\n', '            require (erc20 != IERC20( address(0) ), "Cover currency is not allowed.");\n', '\n', '            uint256 decimals = uint256(erc20.decimals());\n', '            claimReward = _sumAssured * (10 ** decimals);\n', '            erc20.safeTransfer(msg.sender, claimReward);\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Get the cover Id and claim Id of the token from the ynft contract.\n', '     * @param _ynftTokenId The Id of the token on the ynft contract.\n', '    **/\n', '    function _getCoverAndClaim(uint256 _ynftTokenId)\n', '      internal\n', '    returns (uint256 coverPrice, uint256 coverId, uint256 claimId)\n', '    {\n', '       ( , , , coverPrice, , , , coverId, , claimId) = ynft.tokens(_ynftTokenId);\n', '    }\n', '    \n', '    /**\n', '     * @dev Get (some) cover details from the NXM contracts.\n', '     * @param _coverId ID of the cover to get--same as our token ID.\n', '     * @return Details about the token.\n', '    **/\n', '    function _getCover1 (\n', '        uint256 _coverId\n', '    ) internal view returns (\n', '        uint256 cid,\n', '        address memberAddress,\n', '        address scAddress,\n', '        bytes4 currencyCode,\n', '        uint256 sumAssured,\n', '        uint256 premiumNXM\n', '    ) {\n', '        IQuotationData quotationData = IQuotationData(nxMaster.getLatestAddress("QD"));\n', '        return quotationData.getCoverDetailsByCoverID1(_coverId);\n', '    }\n', '    \n', '    /**\n', '     * @dev Get the rest of the cover details from NXM contracts.\n', '     * @param _coverId ID of the cover to get--same as our token ID.\n', '     * @return 2nd set of details about the token.\n', '    **/\n', '    function _getCover2 (\n', '        uint256 _coverId\n', '    ) internal view returns (\n', '        uint256 cid,\n', '        uint8 status,\n', '        uint256 sumAssured,\n', '        uint16 coverPeriod,\n', '        uint256 validUntil\n', '    ) {\n', '        IQuotationData quotationData = IQuotationData(nxMaster.getLatestAddress("QD"));\n', '        return quotationData.getCoverDetailsByCoverID2(_coverId);\n', '    }\n', '    \n', '    /**\n', '     * @dev Approve an address to spend NXM tokens from the contract.\n', '     * @param _spender Address to be approved.\n', '     * @param _value The amount of NXM to be approved.\n', '    **/\n', '    function nxmTokenApprove(address _spender, uint256 _value) public onlyOwner {\n', '        nxmToken.safeApprove(_spender, _value);\n', '    }\n', '\n', '    /**\n', '     * @dev Add an allowed cover currency to the arNFT system if one is added to Nexus Mutual.\n', '     * @param _coverCurrency Address of the cover currency to add.\n', '    **/\n', '    function addCurrency(bytes4 _coverCurrency, address _coverCurrencyAddress) public onlyOwner {\n', '        require(coverCurrencies[_coverCurrency] == address(0), "Cover currency already exists.");\n', '        coverCurrencies[_coverCurrency] = _coverCurrencyAddress;\n', '    }\n', '\n', '}']