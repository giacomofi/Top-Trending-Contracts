['pragma solidity ^0.6.0;\n', '\n', '\n', '// SPDX-License-Identifier: MIT\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * This source code belongs to Augur\n', ' */\n', '/**\n', ' * @title SafeMathInt256\n', ' * @dev Int256 math operations with safety checks that throw on error\n', ' */\n', 'library SafeMathInt256 {\n', '    // Signed ints with n bits can range from -2**(n-1) to (2**(n-1) - 1)\n', '    int256 private constant INT256_MIN = -2**(255);\n', '    int256 private constant INT256_MAX = (2**(255) - 1);\n', '\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        // No need to check for dividing by 0 -- Solidity automatically throws on division by 0\n', '        int256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        require(((a >= 0) && (b >= a - INT256_MAX)) || ((a < 0) && (b <= a - INT256_MIN)));\n', '        return a - b;\n', '    }\n', '\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        require(((a >= 0) && (b <= INT256_MAX - a)) || ((a < 0) && (b >= INT256_MIN - a)));\n', '        return a + b;\n', '    }\n', '\n', '    function min(int256 a, int256 b) internal pure returns (int256) {\n', '        if (a <= b) {\n', '            return a;\n', '        } else {\n', '            return b;\n', '        }\n', '    }\n', '\n', '    function max(int256 a, int256 b) internal pure returns (int256) {\n', '        if (a >= b) {\n', '            return a;\n', '        } else {\n', '            return b;\n', '        }\n', '    }\n', '\n', '    function abs(int256 a) internal pure returns (int256) {\n', '        if (a < 0) {\n', '            return -a;\n', '        }\n', '        return a;\n', '    }\n', '\n', '    function getInt256Min() internal pure returns (int256) {\n', '        return INT256_MIN;\n', '    }\n', '\n', '    function getInt256Max() internal pure returns (int256) {\n', '        return INT256_MAX;\n', '    }\n', '\n', '    // Float [fixed point] Operations\n', '    function fxpMul(int256 a, int256 b, int256 base) internal pure returns (int256) {\n', '        return div(mul(a, b), base);\n', '    }\n', '\n', '    function fxpDiv(int256 a, int256 b, int256 base) internal pure returns (int256) {\n', '        return div(mul(a, base), b);\n', '    }\n', '}\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract FinalBondingCurve {\n', '    using SafeMath for uint;\n', '    using SafeMathInt256 for int;\n', '\n', '    uint constant private MAX_INT = 2**255-1;\n', '    uint constant private bisectionPrecision = 0.01 ether; \n', '    int constant private displacement = 2e15;\n', '    int constant private B = 4*3.2000e40;\n', '    int constant private A = 1250000;\n', '    \n', '    uint public cap;\n', '\n', '    constructor(uint _cap) public {\n', '        cap = _cap;\n', '    }\n', '\n', '    function computeSaleParameters(\n', '        uint a, // Tokens sold up to now\n', '        uint R // Reserve currency amount that you are willing to spend\n', '    ) \n', '        public   \n', '        view\n', '        returns (\n', '            uint T, // T = b - a, amount of tokens\n', '            uint finalExpenditure\n', '        )\n', '    {\n', '        \n', '        uint b_cap = cap;\n', '        uint b = b_cap;\n', '        uint best_b;\n', '        uint lower = a;\n', '        uint iterations;\n', '\n', '        uint Rr;  // R(sub)r stands for required reserve currency: amount that is needed to purchase b - a tokens\n', '\n', '        while(iterations < 20) {\n', '            Rr = evaluateIntegral(safeCastUintToInt(b), safeCastUintToInt(a));\n', '            if(Rr > R) {\n', '                // If the required value is more than what is attached, \n', '                // we need to find a lower value than R\n', '                b_cap = b;\n', '                b = ((b.sub(lower)).div(2)).add(lower); // b = lower + [b - lower] / 2\n', '            } else {\n', '                finalExpenditure = Rr;\n', '                best_b = b;\n', '                lower = best_b;\n', '\n', '                if(R.sub(Rr) > bisectionPrecision) {\n', '                    if(b == b_cap) {\n', '                        break;\n', '                    }\n', '                    b = ((b_cap.sub(b)).div(2)).add(b);\n', '                } else {\n', '                    break;\n', '                }\n', '            }\n', '            iterations++;\n', '        }\n', '\n', '        require(\n', '            finalExpenditure <= R, \n', '            "FinalBondingCurve.computeSaleParameters() - Not enough ether"\n', '        );\n', '\n', '        if(finalExpenditure > 0) {\n', '            T = best_b.sub(a);\n', '        }\n', '        require(T > 0, "FinalBondingCurve.computeSaleParameters() - Returned 0 tokens");\n', '    }\n', '\n', '    function evaluateIntegral(int b, int a) public pure returns (uint) {\n', '        int _displacement = displacement;\n', '\n', '        int _b;\n', '        int _a;\n', '\n', '        int b_delta = b.sub(_displacement);\n', '        int a_delta = a.sub(_displacement);\n', '\n', '        int _b_fourthComponent = power(uint(SafeMathInt256.abs(b_delta)), uint32(4), false).div(B);\n', '        int _b_firstComponent = A.mul(b_delta);\n', '\n', '        _b = _b_fourthComponent.add(_b_firstComponent);\n', '\n', '        _a = power(uint(SafeMathInt256.abs(a_delta)), uint32(4), false).div(B)\n', '            .add(A.mul(a_delta));\n', '\n', '        require(\n', '            _b > _a, \n', '            "FinalBondingCurve.evaluateIntegral() - Negative price computed"\n', '        );\n', '\n', '        int result = _b.sub(_a);\n', '        return uint(result);\n', '        \n', '    }\n', '\n', '    function power(\n', '        uint256 base,\n', '        uint32 exp,\n', '        bool negativeBase // true if base is negative\n', '    ) \n', '        public\n', '        pure\n', '        returns (int) \n', '    {\n', '        // (uint result, uint8 precision) = Power.power(base, 1, exp, 1);\n', '        // result = result.div(2**uint(precision));\n', '\n', '        uint result = u_pow(base, uint(exp));\n', '        if(negativeBase) {\n', '            return safeCastUintToInt(result) * int(-1);\n', '        } else {\n', '            return safeCastUintToInt(result);\n', '        }\n', '    }\n', '\n', '    function u_pow(uint a, uint b) public pure returns (uint r) {\n', '        r = 1;\n', '        while(true) {\n', '            if(b % 2 == 1) r = r.mul(a);\n', '            \n', '            b /= 2;\n', '            if(b == 0) break;\n', '            a = a.mul(a);\n', '        }\n', '    }\n', '    \n', '    function safeCastUintToInt(uint value) public pure returns (int) {\n', '        require(value <= 2**255-1, "FinalBondingCurve.castUintToInt - Overflow");\n', '        return int(value);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n', ' *\n', ' * Accounts can be notified of {IERC777} tokens being sent to them by having a\n', ' * contract implement this interface (contract holders can be their own\n', ' * implementer) and registering it on the\n', ' * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n', ' *\n', ' * See {IERC1820Registry} and {ERC1820Implementer}.\n', ' */\n', 'interface IERC777Recipient {\n', '    /**\n', '     * @dev Called by an {IERC777} token contract whenever tokens are being\n', '     * moved or created into a registered account (`to`). The type of operation\n', '     * is conveyed by `from` being the zero address or not.\n', '     *\n', "     * This call occurs _after_ the token contract's state is updated, so\n", '     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n', '     *\n', '     * This function may revert to prevent the operation from being executed.\n', '     */\n', '    function tokensReceived(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        bytes calldata userData,\n', '        bytes calldata operatorData\n', '    ) external;\n', '}\n', '\n', '/**\n', ' * @dev Interface of the global ERC1820 Registry, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n', ' * implementers for interfaces in this registry, as well as query support.\n', ' *\n', ' * Implementers may be shared by multiple accounts, and can also implement more\n', ' * than a single interface for each account. Contracts can implement interfaces\n', ' * for themselves, but externally-owned accounts (EOA) must delegate this to a\n', ' * contract.\n', ' *\n', ' * {IERC165} interfaces can also be queried via the registry.\n', ' *\n', ' * For an in-depth explanation and source code analysis, see the EIP text.\n', ' */\n', 'interface IERC1820Registry {\n', '    /**\n', '     * @dev Sets `newManager` as the manager for `account`. A manager of an\n', '     * account is able to set interface implementers for it.\n', '     *\n', '     * By default, each account is its own manager. Passing a value of `0x0` in\n', '     * `newManager` will reset the manager to this initial state.\n', '     *\n', '     * Emits a {ManagerChanged} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be the current manager for `account`.\n', '     */\n', '    function setManager(address account, address newManager) external;\n', '\n', '    /**\n', '     * @dev Returns the manager for `account`.\n', '     *\n', '     * See {setManager}.\n', '     */\n', '    function getManager(address account) external view returns (address);\n', '\n', '    /**\n', "     * @dev Sets the `implementer` contract as ``account``'s implementer for\n", '     * `interfaceHash`.\n', '     *\n', "     * `account` being the zero address is an alias for the caller's address.\n", '     * The zero address can also be used in `implementer` to remove an old one.\n', '     *\n', '     * See {interfaceHash} to learn how these are created.\n', '     *\n', '     * Emits an {InterfaceImplementerSet} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be the current manager for `account`.\n', '     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n', '     * end in 28 zeroes).\n', '     * - `implementer` must implement {IERC1820Implementer} and return true when\n', '     * queried for support, unless `implementer` is the caller. See\n', '     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n', '     */\n', '    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n', '\n', '    /**\n', '     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n', '     * implementer is registered, returns the zero address.\n', '     *\n', '     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n', '     * zeroes), `account` will be queried for support of it.\n', '     *\n', "     * `account` being the zero address is an alias for the caller's address.\n", '     */\n', '    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n', '     * corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n', '     */\n', '    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n', '\n', '    /**\n', '     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n', '     *  @param account Address of the contract for which to update the cache.\n', '     *  @param interfaceId ERC165 interface for which to update the cache.\n', '     */\n', '    function updateERC165Cache(address account, bytes4 interfaceId) external;\n', '\n', '    /**\n', '     *  @notice Checks whether a contract implements an ERC165 interface or not.\n', '     *  If the result is not cached a direct lookup on the contract address is performed.\n', '     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n', '     *  {updateERC165Cache} with the contract address.\n', '     *  @param account Address of the contract to check.\n', '     *  @param interfaceId ERC165 interface to check.\n', '     *  @return True if `account` implements `interfaceId`, false otherwise.\n', '     */\n', '    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n', '\n', '    /**\n', '     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n', '     *  @param account Address of the contract to check.\n', '     *  @param interfaceId ERC165 interface to check.\n', '     *  @return True if `account` implements `interfaceId`, false otherwise.\n', '     */\n', '    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n', '\n', '    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n', '\n', '    event ManagerChanged(address indexed account, address indexed newManager);\n', '}\n', '\n', 'abstract contract ERC777Receiver is IERC777Recipient {\n', '\n', '    // Needed constants to accept ERC777 tokens in deposit\n', '    IERC1820Registry constant private _erc1820 = // See EIP1820\n', '        IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n', '    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = // See EIP777\n', '        keccak256("ERC777TokensRecipient");\n', '\n', '    constructor() public {\n', '        // Register as a token receiver\n', '        _erc1820.setInterfaceImplementer(\n', '            address(this), \n', '            TOKENS_RECIPIENT_INTERFACE_HASH, \n', '            address(this)\n', '        );\n', '    }\n', '\n', '    address private token;\n', '\n', '    //  @dev: This hook is called when the contract receives GeoTokens.\n', '    //  The contract can only receive GeoTokens from the owner\n', '    function tokensReceived(\n', '        address /*operator*/,\n', '        address from,\n', '        address /*to*/,\n', '        uint256 ,\n', '        bytes calldata /*userData*/,\n', '        bytes calldata /*operatorData*/\n', '    ) external override {\n', '        require(msg.sender == getToken(), "GeoPreSale.tokensReceived() - Wrong token");\n', '        require(from == getOwner(), "GeoPreSale.tokensReceived() - Only owner");\n', '    }\n', '\n', '    function getOwner() virtual public view returns(address);\n', '\n', '    function getToken() virtual public view returns(address);\n', '}\n', '\n', 'contract Withdrawable is Ownable {\n', '\n', '    event EtherWithdrawn(\n', '        address sender,\n', '        uint amount\n', '    );\n', '\n', '    receive() external virtual payable {}\n', '\n', '    // @dev: allows the owner to withdraw the eth that has been deposited in the contract\n', '    function withdrawEth() external onlyOwner {\n', '        address payable to = payable(msg.sender);\n', '        uint bal;\n', '        assembly {\n', '            bal := selfbalance()\n', '        }\n', '        require(\n', '            bal > 0, \n', '            "Withdrawable withdrawEth() - No ether balance in the contract"\n', '        );\n', '        (bool success, ) = to.call{value: bal}("");\n', '        require(\n', '            success,\n', '            "Withdrawable withdrawEth() - Could not withdraw eth"\n', '        );\n', '\n', '        emit EtherWithdrawn(\n', '            msg.sender,\n', '            bal\n', '        );\n', '    }\n', '}\n', '\n', 'contract GeoSale is \n', '    ERC777Receiver,\n', '    Withdrawable,\n', '    FinalBondingCurve {\n', '\n', '    uint constant private PEAK_PRICE = 1500000; // WEI / GAGEO\n', '\n', '    address public token;\n', '\n', '    uint public startSaleTimestamp; // Unix timestamp\n', '    uint public duration; // Seconds\n', '    uint public price = 1000000; // WEI / GAGEO\n', '    uint public tokensSold; // in nanoGeos (gaGeos)\n', '\n', '    event PurchasedGeoTokens(\n', '        address indexed sender,\n', '        uint ethAmount,\n', '        uint geoAmount,\n', '        uint returnedEth\n', '    );\n', '\n', '    constructor(\n', '        uint _startSaleTimestamp,\n', '        uint _duration,\n', '        uint _cap,\n', '        address _token\n', '    )\n', '        FinalBondingCurve(_cap)\n', '        public \n', '    {\n', '        require(cap > 0);\n', '        require(_token != address(0));\n', '        require(_duration > 0);\n', '        startSaleTimestamp = _startSaleTimestamp;\n', '        duration = _duration;\n', '        token = _token;\n', '    }\n', '\n', '    fallback() external {\n', '        revert("GeoPreSale - Fallback function called");\n', '    }\n', '\n', '    receive() external payable override {\n', '        swapEtherForGeo();\n', '    }\n', '\n', '    function setStartSaleTimestamp(uint timestamp) external onlyOwner {\n', '        startSaleTimestamp = timestamp;\n', '    }\n', '\n', '    function setDuration(uint _duration) external onlyOwner {\n', '        require(_duration > 0);\n', '        duration = _duration;\n', '    }\n', '\n', '    function setToken(address _token) external onlyOwner {\n', '        require(_token != address(0));\n', '        token = _token;\n', '    }\n', '\n', '    function setCap(uint _cap) external onlyOwner {\n', '        require(_cap > 0);\n', '        FinalBondingCurve.cap = _cap;\n', '    }\n', '\n', '    function swapEtherForGeo() public payable returns (bool) {\n', '        require(saleStarted(), "GeoSale.swapEtherForGeo() - Sale has not started");\n', '        require(!saleIsOver(), "GeoSale.swapEtherForGeo() - Sale is over");\n', '\n', '        uint _tokensSold = tokensSold;\n', '        uint _cap = cap;\n', '        uint tokensBought;\n', '        uint finalExpenditure;\n', '\n', '        if(_tokensSold < _cap) {\n', '            (tokensBought, finalExpenditure) = computeSaleParameters(_tokensSold, msg.value);\n', '            _tokensSold = _tokensSold.add(tokensBought);\n', '\n', '            if(_tokensSold >= _cap && msg.value > finalExpenditure) {\n', '                uint tokensBoughtAtFixexRate = purchaseAtFixedRate(msg.value.sub(finalExpenditure));\n', '                finalExpenditure = finalExpenditure.add(tokensBoughtAtFixexRate.mul(PEAK_PRICE));\n', '                tokensBought = tokensBought.add(tokensBoughtAtFixexRate);\n', '                _tokensSold = _tokensSold.add(tokensBoughtAtFixexRate);\n', '            }\n', '        } else {\n', '            tokensBought = purchaseAtFixedRate(msg.value);\n', '            finalExpenditure = tokensBought.mul(PEAK_PRICE);\n', '            _tokensSold = _tokensSold.add(tokensBought);\n', '        }\n', '\n', '        price = finalExpenditure.div(tokensBought);\n', '        tokensSold = _tokensSold;\n', '        uint returnedEth = msg.value.sub(finalExpenditure);\n', '\n', '        // Up to this moment, computations were done in nanoGeos.\n', '        // So we perform a conversion to attoGeos by multiplying by 10^9\n', '        tokensBought = tokensBought.mul(10**9);\n', '        require(IERC20(getToken()).transfer(msg.sender, tokensBought));\n', '        address payable to = payable(msg.sender);\n', '        (bool success, ) = to.call{value: returnedEth}("");\n', '        require(\n', '            success,\n', '            "GeoSale.swapEtherForGeo - Could not return eth"\n', '        );\n', '\n', '        emit PurchasedGeoTokens(\n', '            msg.sender,\n', '            finalExpenditure,\n', '            tokensBought,\n', '            returnedEth\n', '        );\n', '        return true;\n', '    }\n', '\n', '    function precomputePurchase(uint value) \n', '        external \n', '        view \n', '        returns(uint tokensBought, uint finalExpenditure, uint _price) \n', '    {\n', '        if(!saleStarted()) {\n', '            return (0,0,0);\n', '        }\n', '\n', '        if(saleIsOver()) {\n', '            return (0,0,0);\n', '        }\n', '\n', '        uint _tokensSold = tokensSold;\n', '        uint _cap = cap;\n', '\n', '        if(_tokensSold < _cap) {\n', '            (tokensBought, finalExpenditure) = computeSaleParameters(_tokensSold, value);\n', '            _tokensSold = _tokensSold.add(tokensBought);\n', '\n', '            if(_tokensSold >= _cap && value > finalExpenditure) {\n', '                uint tokensBoughtAtFixexRate = purchaseAtFixedRate(value.sub(finalExpenditure));\n', '                finalExpenditure = finalExpenditure.add(tokensBoughtAtFixexRate.mul(PEAK_PRICE));\n', '                tokensBought = tokensBought.add(tokensBoughtAtFixexRate);\n', '                _tokensSold = _tokensSold.add(tokensBoughtAtFixexRate);\n', '            }\n', '        } else {\n', '            tokensBought = purchaseAtFixedRate(value);\n', '            finalExpenditure = tokensBought.mul(PEAK_PRICE);\n', '            _tokensSold = _tokensSold.add(tokensBought);\n', '        }\n', '\n', '        // Up to this moment, computations were done in nanoGeos.\n', '        // So we perform a conversion to attoGeos by multiplying by 10^9\n', '        tokensBought = tokensBought.mul(10**9);\n', '        \n', '        _price = finalExpenditure.div(tokensBought);\n', '    }\n', '\n', '    function purchaseAtFixedRate(uint value) internal pure returns (uint) {\n', '        return value.div(PEAK_PRICE);\n', '    }\n', '\n', '    function getToken() public view override returns (address) {\n', '        return token;\n', '    }\n', '\n', '    function getOwner() public view override returns (address) {\n', '        return Ownable.owner();\n', '    }\n', '\n', '    function getPrice() public view returns (uint) {\n', '        return price;\n', '    }\n', '\n', '    function getTokensSold() public view returns (uint) {\n', '        return tokensSold;\n', '    }\n', '\n', '    function getStartSaleTimestamp() public view returns (uint) {\n', '        return startSaleTimestamp;\n', '    }\n', '\n', '    function endSaleTimestamp() public view returns (uint) {\n', '        return now + duration;\n', '    }\n', '\n', '    function getEndSaletimestamp() public view returns (uint) {\n', '        return now + duration;\n', '    }\n', '\n', '    function saleStarted() public view returns (bool) {\n', '        return now > startSaleTimestamp;\n', '    }\n', '\n', '    function saleIsOver() public view returns (bool) {\n', '        return now > startSaleTimestamp + duration;\n', '    }\n', '    \n', '}']