['pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract COwnable {\n', '    address private __owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        __owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return __owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner() {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '     /*\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(__owner, address(0));\n', '        __owner = address(0);\n', '    }\n', '    */\n', '    \n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function _isOwner() internal view returns (bool) {\n', '        return msg.sender == __owner;\n', '    }\n', '\n', '    \n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(__owner, newOwner);\n', '        __owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title AirDrop\n', ' * @dev Airdrop program. https://github.com/0x20bf/0xBlock\n', ' */\n', '\n', 'contract AirDrop is COwnable {\n', '    mapping (address => uint256) public whitelist;\n', '    address public token_address;\n', '    uint256 private _decimals;\n', '\n', '    constructor(address token, uint256 decimals) public{ \n', '        token_address = token;\n', '        _decimals = decimals;\n', '    }\n', '\n', '    function redeem() public returns(bool res) {\n', '        require (whitelist[msg.sender] > 0 );\n', '        IERC20 token = IERC20(token_address);\n', '        token.transfer(msg.sender, whitelist[msg.sender]);\n', '        whitelist[msg.sender] = 0;\n', '        return true;\n', '    }\n', '\n', '    function setWhitelist(address[] memory accounts, uint256[] memory amounts) public onlyOwner() returns(bool res) {\n', '        require (accounts.length == amounts.length);\n', '        for(uint256 i=0; i<accounts.length; i++){\n', '            if (accounts[i]!=address(0)){\n', '                whitelist[accounts[i]] = amounts[i]*(10**_decimals);\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function withdraw(address token_addr) public onlyOwner() returns(bool res) {\n', '        IERC20 token = IERC20(token_addr);\n', '        token.transfer(msg.sender, token.balanceOf(address(this)));\n', '        return true;\n', '    }\n', '    \n', '    function kill() public onlyOwner() {\n', '        address payable addr = address(uint160(owner()));\n', '        selfdestruct(addr);\n', '    }\n', '\n', '}']