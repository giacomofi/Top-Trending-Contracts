['/**\n', ' * Copyright (C) Virtue Fintech FZ-LLC, Dubai\n', ' * All rights reserved.\n', ' * Author: <span class="__cf_email__" data-cfemail="5b3633321b2d32292f2e3e753d32353a35383e">[email&#160;protected]</span>\n', ' *\n', ' * This code is adapted from OpenZeppelin Project.\n', ' * more at http://openzeppelin.org.\n', ' *\n', ' * MIT License\n', ' *\n', ' * Permission is hereby granted, free of charge, to any person obtaining a copy \n', ' * of this software and associated documentation files (the ""Software""), to \n', ' * deal in the Software without restriction, including without limitation the \n', ' * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or \n', ' * sell copies of the Software, and to permit persons to whom the Software is \n', ' * furnished to do so, subject to the following conditions: \n', ' *  The above copyright notice and this permission notice shall be included in \n', ' *  all copies or substantial portions of the Software.\n', ' *\n', ' * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n', ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n', ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n', ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n', ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n', ' * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \n', ' * THE SOFTWARE.\n', ' *\n', ' */\n', 'pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Guarded {\n', '\n', '    modifier isValidAmount(uint256 _amount) { \n', '        require(_amount > 0); \n', '        _; \n', '    }\n', '\n', '    // ensure address not null, and not this contract address\n', '    modifier isValidAddress(address _address) {\n', '        require(_address != 0x0 && _address != address(this));\n', '        _;\n', '    }\n', '\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    /** \n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner. \n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to. \n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '    address public pendingOwner;\n', '\n', '    /**\n', '     * @dev Modifier throws if called by any account other than the pendingOwner. \n', '     */\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to set the pendingOwner address. \n', '     * @param newOwner The address to transfer ownership to. \n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the pendingOwner address to finalize the transfer.\n', '     */\n', '    function claimOwnership() onlyPendingOwner {\n', '        owner = pendingOwner;\n', '        pendingOwner = 0x0;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    \n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', 'contract ERC20Token is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    string public standard = &#39;Cryptoken 0.1.1&#39;;\n', '\n', '    string public name = &#39;&#39;;            // the token name\n', '    string public symbol = &#39;&#39;;          // the token symbol\n', '    uint8 public decimals = 0;          // the number of decimals\n', '\n', '    // mapping of our users to balance\n', '    mapping (address => uint256) public balances;\n', '    mapping (address => mapping (address => uint256)) public allowed;\n', '\n', '    // our constructor. We have fixed everything above, and not as \n', '    // parameters in the constructor.\n', '    function ERC20Token(string _name, string _symbol, uint8 _decimals) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    // get token balance\n', '    function balanceOf(address _owner) \n', '        public constant \n', '        returns (uint256 balance) \n', '    {\n', '        return balances[_owner];\n', '    }    \n', '\n', '    /**\n', '     * make a transfer. This can be called from the token holder.\n', '     * e.g. Token holder Alice, can issue somethign like this to Bob\n', '     *      Alice.transfer(Bob, 200);     // to transfer 200 to Bob\n', '     */\n', '    /// Initiate a transfer to `_to` with value `_value`?\n', '    function transfer(address _to, uint256 _value) \n', '        public returns (bool success) \n', '    {\n', '        // sanity check\n', '        require(_to != address(this));\n', '\n', '        // // check for overflows\n', '        // require(_value > 0 &&\n', '        //   balances[msg.sender] < _value &&\n', '        //   balances[_to] + _value < balances[_to]);\n', '\n', '        // \n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        \n', '        // emit transfer event\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * make an approved transfer to another account from vault. This operation\n', '     * should be called after approved operation below.\n', '     * .e.g Alice allow Bob to spend 30 by doing:\n', '     *      Alice.approve(Bob, 30);                 // allow 30 to Bob\n', '     *\n', '     * and Bob can claim, say 10, from that by doing\n', '     *      Bob.transferFrom(Alice, Bob, 10);       // spend only 10\n', '     * and Bob&#39;s balance shall be 20 in the allowance.\n', '     */\n', '    /// Initiate a transfer of `_value` from `_from` to `_to`\n', '    function transferFrom(address _from, address _to, uint256 _value)         \n', '        public returns (bool success) \n', '    {    \n', '        // sanity check\n', '        require(_to != 0x0 && _from != 0x0);\n', '        require(_from != _to && _to != address(this));\n', '\n', '        // check for overflows\n', '        // require(_value > 0 &&\n', '        //   balances[_from] >= _value &&\n', '        //   allowed[_from][_to] <= _value &&\n', '        //   balances[_to] + _value < balances[_to]);\n', '\n', '        // update public balance\n', '        allowed[_from][_to] = allowed[_from][_to].sub(_value);        \n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        // emit transfer event\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * This method is explained further in https://goo.gl/iaqxBa on the\n', '     * possible attacks. As such, we have to make sure the value is\n', '     * drained, before any Alice/Bob can approve each other to\n', '     * transfer on their behalf.\n', '     * @param _spender  - the recipient of the value\n', '     * @param _value    - the value allowed to be spent \n', '     *\n', '     * This can be called by the token holder\n', '     * e.g. Alice can allow Bob to spend 30 on her behalf\n', '     *      Alice.approve(Bob, 30);     // gives 30 to Bob.\n', '     */\n', '    /// Approve `_spender` to claim/spend `_value`?\n', '    function approve(address _spender, uint256 _value)          \n', '        public returns (bool success) \n', '    {\n', '        // sanity check\n', '        require(_spender != 0x0 && _spender != address(this));            \n', '\n', '        // if the allowance isn&#39;t 0, it can only be updated to 0 to prevent \n', '        // an allowance change immediately after withdrawal\n', '        require(allowed[msg.sender][_spender] == 0);\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Check the allowance that has been approved previously by owner.\n', '     */\n', '    /// check allowance approved from `_owner` to `_spender`?\n', '    function allowance(address _owner, address _spender)          \n', '        public constant returns (uint remaining) \n', '    {\n', '        // sanity check\n', '        require(_spender != 0x0 && _owner != 0x0);\n', '        require(_owner != _spender && _spender != address(this));            \n', '\n', '        // constant op. Just return the balance.\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', 'contract FaradCryptoken is ERC20Token, Guarded, Claimable {\n', '\n', '    uint256 public SUPPLY = 1600000000 ether;   // 1.6b ether;\n', '\n', '    // our constructor, just supply the total supply.\n', '    function FaradCryptoken() \n', '        ERC20Token(&#39;FARAD&#39;, &#39;FRD&#39;, 18) \n', '    {\n', '        totalSupply = SUPPLY;\n', '        balances[msg.sender] = SUPPLY;\n', '    }\n', '\n', '}']