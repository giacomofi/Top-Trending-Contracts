['pragma solidity ^0.4.8;\n', '\n', 'contract ENS {\n', '    function owner(bytes32 node) constant returns(address);\n', '    function resolver(bytes32 node) constant returns(address);\n', '    function ttl(bytes32 node) constant returns(uint64);\n', '    function setOwner(bytes32 node, address owner);\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner);\n', '    function setResolver(bytes32 node, address resolver);\n', '    function setTTL(bytes32 node, uint64 ttl);\n', '\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '}\n', '\n', 'contract ReverseRegistrar {\n', '    function setName(string name) returns (bytes32 node);\n', '    function claimWithResolver(address owner, address resolver) returns (bytes32 node);\n', '}\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        //Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract ShibbolethToken is StandardToken {\n', '    ENS ens;    \n', '\n', '    string public name;\n', '    string public symbol;\n', '    address public issuer;\n', '\n', '    function version() constant returns(string) { return "S0.1"; }\n', '    function decimals() constant returns(uint8) { return 0; }\n', '    function name(bytes32 node) constant returns(string) { return name; }\n', '    \n', '    modifier issuer_only {\n', '        require(msg.sender == issuer);\n', '        _;\n', '    }\n', '    \n', '    function ShibbolethToken(ENS _ens, string _name, string _symbol, address _issuer) {\n', '        ens = _ens;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        issuer = _issuer;\n', '        \n', '        var rr = ReverseRegistrar(ens.owner(0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2));\n', '        rr.claimWithResolver(this, this);\n', '    }\n', '    \n', '    function issue(uint _value) issuer_only {\n', '        require(totalSupply + _value >= _value);\n', '        balances[issuer] += _value;\n', '        totalSupply += _value;\n', '        Transfer(0, issuer, _value);\n', '    }\n', '    \n', '    function burn(uint _value) issuer_only {\n', '        require(_value <= balances[issuer]);\n', '        balances[issuer] -= _value;\n', '        totalSupply -= _value;\n', '        Transfer(issuer, 0, _value);\n', '    }\n', '    \n', '    function setIssuer(address _issuer) issuer_only {\n', '        issuer = _issuer;\n', '    }\n', '}\n', '\n', 'library StringUtils {\n', '    function strcpy(string dest, uint off, string src) private {\n', '        var len = bytes(src).length;\n', '        assembly {\n', '            dest := add(add(dest, off), 32)\n', '            src := add(src, 32)\n', '        }\n', '        \n', '        // Copy word-length chunks while possible\n', '        for(; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(add(dest, off), mload(src))\n', '                dest := add(dest, 32)\n', '                src := add(src, 32)\n', '            }\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '    \n', '    function concat(string a, string b) internal returns(string ret) {\n', '        ret = new string(bytes(a).length + bytes(b).length);\n', '        strcpy(ret, 0, a);\n', '        strcpy(ret, bytes(a).length, b);\n', '    }\n', '}\n', '\n', 'contract ShibbolethTokenFactory {\n', '    using StringUtils for *;\n', '    \n', '    ENS ens;\n', '    // namehash(&#39;myshibbol.eth&#39;)\n', '    bytes32 constant rootNode = 0x2952863bce80be8e995bbf003c7a1901dd801bb90c09327da9d029d0496c7010;\n', '    mapping(bytes32=>address) public addr;\n', '    \n', '    event NewToken(string indexed symbol, string _symbol, string name, address addr);\n', '    \n', '    function ShibbolethTokenFactory(ENS _ens) {\n', '        ens = _ens;\n', '    }\n', '    \n', '    function create(string symbol) returns(address) {\n', '        var name = symbol.concat(".myshibbol.eth");\n', '        var subnode = sha3(rootNode, sha3(symbol));\n', '        require(ens.owner(subnode) == 0);\n', '\n', '        var token = create(symbol, name);\n', '\n', '        ens.setSubnodeOwner(rootNode, sha3(symbol), this);\n', '        ens.setResolver(subnode, this);\n', '        addr[subnode] = token;\n', '\n', '        return token;\n', '    }\n', '    \n', '    function create(string symbol, string name) returns(address) {\n', '        var token = new ShibbolethToken(ens, name, symbol, msg.sender);\n', '        NewToken(symbol, symbol, name, token);\n', '        return token;\n', '    }\n', '    \n', '    function abi(bytes32 node) constant returns (uint256, bytes) {\n', '        return (1, &#39;[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"issuer","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"success","type":"bool"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"}],"name":"addr","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_value","type":"uint256"}],"name":"burn","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"version","outputs":[{"name":"","type":"string"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_issuer","type":"address"}],"name":"setIssuer","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"}],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"success","type":"bool"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_value","type":"uint256"}],"name":"issue","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"payable":false,"type":"function"},{"inputs":[{"name":"_ens","type":"address"},{"name":"_name","type":"string"},{"name":"_symbol","type":"string"},{"name":"_issuer","type":"address"}],"payable":false,"type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_owner","type":"address"},{"indexed":true,"name":"_spender","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"Approval","type":"event"}]&#39;);\n', '    }\n', '}']
['pragma solidity ^0.4.8;\n', '\n', 'contract ENS {\n', '    function owner(bytes32 node) constant returns(address);\n', '    function resolver(bytes32 node) constant returns(address);\n', '    function ttl(bytes32 node) constant returns(uint64);\n', '    function setOwner(bytes32 node, address owner);\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner);\n', '    function setResolver(bytes32 node, address resolver);\n', '    function setTTL(bytes32 node, uint64 ttl);\n', '\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '}\n', '\n', 'contract ReverseRegistrar {\n', '    function setName(string name) returns (bytes32 node);\n', '    function claimWithResolver(address owner, address resolver) returns (bytes32 node);\n', '}\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', "        //Default assumes totalSupply can't be over max (2^256 - 1).\n", "        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract ShibbolethToken is StandardToken {\n', '    ENS ens;    \n', '\n', '    string public name;\n', '    string public symbol;\n', '    address public issuer;\n', '\n', '    function version() constant returns(string) { return "S0.1"; }\n', '    function decimals() constant returns(uint8) { return 0; }\n', '    function name(bytes32 node) constant returns(string) { return name; }\n', '    \n', '    modifier issuer_only {\n', '        require(msg.sender == issuer);\n', '        _;\n', '    }\n', '    \n', '    function ShibbolethToken(ENS _ens, string _name, string _symbol, address _issuer) {\n', '        ens = _ens;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        issuer = _issuer;\n', '        \n', '        var rr = ReverseRegistrar(ens.owner(0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2));\n', '        rr.claimWithResolver(this, this);\n', '    }\n', '    \n', '    function issue(uint _value) issuer_only {\n', '        require(totalSupply + _value >= _value);\n', '        balances[issuer] += _value;\n', '        totalSupply += _value;\n', '        Transfer(0, issuer, _value);\n', '    }\n', '    \n', '    function burn(uint _value) issuer_only {\n', '        require(_value <= balances[issuer]);\n', '        balances[issuer] -= _value;\n', '        totalSupply -= _value;\n', '        Transfer(issuer, 0, _value);\n', '    }\n', '    \n', '    function setIssuer(address _issuer) issuer_only {\n', '        issuer = _issuer;\n', '    }\n', '}\n', '\n', 'library StringUtils {\n', '    function strcpy(string dest, uint off, string src) private {\n', '        var len = bytes(src).length;\n', '        assembly {\n', '            dest := add(add(dest, off), 32)\n', '            src := add(src, 32)\n', '        }\n', '        \n', '        // Copy word-length chunks while possible\n', '        for(; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(add(dest, off), mload(src))\n', '                dest := add(dest, 32)\n', '                src := add(src, 32)\n', '            }\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '    \n', '    function concat(string a, string b) internal returns(string ret) {\n', '        ret = new string(bytes(a).length + bytes(b).length);\n', '        strcpy(ret, 0, a);\n', '        strcpy(ret, bytes(a).length, b);\n', '    }\n', '}\n', '\n', 'contract ShibbolethTokenFactory {\n', '    using StringUtils for *;\n', '    \n', '    ENS ens;\n', "    // namehash('myshibbol.eth')\n", '    bytes32 constant rootNode = 0x2952863bce80be8e995bbf003c7a1901dd801bb90c09327da9d029d0496c7010;\n', '    mapping(bytes32=>address) public addr;\n', '    \n', '    event NewToken(string indexed symbol, string _symbol, string name, address addr);\n', '    \n', '    function ShibbolethTokenFactory(ENS _ens) {\n', '        ens = _ens;\n', '    }\n', '    \n', '    function create(string symbol) returns(address) {\n', '        var name = symbol.concat(".myshibbol.eth");\n', '        var subnode = sha3(rootNode, sha3(symbol));\n', '        require(ens.owner(subnode) == 0);\n', '\n', '        var token = create(symbol, name);\n', '\n', '        ens.setSubnodeOwner(rootNode, sha3(symbol), this);\n', '        ens.setResolver(subnode, this);\n', '        addr[subnode] = token;\n', '\n', '        return token;\n', '    }\n', '    \n', '    function create(string symbol, string name) returns(address) {\n', '        var token = new ShibbolethToken(ens, name, symbol, msg.sender);\n', '        NewToken(symbol, symbol, name, token);\n', '        return token;\n', '    }\n', '    \n', '    function abi(bytes32 node) constant returns (uint256, bytes) {\n', '        return (1, \'[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"issuer","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"success","type":"bool"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"}],"name":"addr","outputs":[{"name":"","type":"address"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_value","type":"uint256"}],"name":"burn","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"version","outputs":[{"name":"","type":"string"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_issuer","type":"address"}],"name":"setIssuer","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"node","type":"bytes32"}],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":false,"type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"success","type":"bool"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"_value","type":"uint256"}],"name":"issue","outputs":[],"payable":false,"type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"payable":false,"type":"function"},{"inputs":[{"name":"_ens","type":"address"},{"name":"_name","type":"string"},{"name":"_symbol","type":"string"},{"name":"_issuer","type":"address"}],"payable":false,"type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_owner","type":"address"},{"indexed":true,"name":"_spender","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"Approval","type":"event"}]\');\n', '    }\n', '}']
