['pragma solidity ^0.4.13;\n', '\n', '/* \n', '`* is owned\n', '*/\n', 'contract owned {\n', '\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) revert();\n', '        _;\n', '    }\n', '\n', '    function ownerTransferOwnership(address newOwner)\n', '        onlyOwner\n', '    {\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/* \n', '* safe math\n', '*/\n', 'contract DSSafeAddSub {\n', '\n', '    function safeToAdd(uint a, uint b) internal returns (bool) {\n', '        return (a + b >= a);\n', '    }\n', '    \n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        if (!safeToAdd(a, b)) revert();\n', '        return a + b;\n', '    }\n', '\n', '    function safeToSubtract(uint a, uint b) internal returns (bool) {\n', '        return (b <= a);\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        if (!safeToSubtract(a, b)) revert();\n', '        return a - b;\n', '    } \n', '\n', '}\n', '\n', '\n', '/**\n', ' *\n', ' * @title  DoneToken\n', ' * \n', ' * The official token powering Donation Efficiency.\n', ' * DoneToken is a ERC.20 standard token with some custom functionality\n', ' *\n', ' */ \n', '\n', '\n', 'contract DoneToken is owned, DSSafeAddSub {\n', '\n', '    /* check address */\n', '    modifier onlyBy(address _account) {\n', '        if (msg.sender != _account) revert();\n', '        _;\n', '    }    \n', '\n', '    /* vars */\n', '    string public standard = &#39;Token 1.0&#39;;\n', '    string public name = "DONE";\n', '    string public symbol = "DET";\n', '    uint8 public decimals = 16;\n', '    uint public totalSupply = 150000000000000000000000; \n', '\n', '    address public priviledgedAddress;  \n', '    bool public tokensFrozen;\n', '    uint public crowdfundDeadline = now + 1 hours;       \n', '    uint public nextFreeze = now + 2 hours;\n', '    uint public nextThaw = now + 3 hours;\n', '   \n', '\n', '    /* map balances */\n', '    mapping (address => uint) public balanceOf;\n', '    mapping (address => mapping (address => uint)) public allowance;  \n', '\n', '    /* events */\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event LogTokensFrozen(bool indexed Frozen);    \n', '\n', '    /*\n', '    *  @notice sends all tokens to msg.sender on init    \n', '    */  \n', '    function DoneToken(){\n', '        /* send creator all initial tokens 25,000,000 */\n', '        balanceOf[msg.sender] = 150000000000000000000000;\n', '        /* tokens are not frozen */  \n', '        tokensFrozen = false;                                      \n', '\n', '    }  \n', '\n', '    /*\n', '    *  @notice public function    \n', '    *  @param _to address to send tokens to   \n', '    *  @param _value number of tokens to transfer \n', '    *  @returns boolean success         \n', '    */     \n', '    function transfer(address _to, uint _value) public\n', '        returns (bool success)    \n', '    {\n', '        if(tokensFrozen && msg.sender != priviledgedAddress) return false;  /* transfer only by priviledgedAddress during crowdfund or reward phases */\n', '        if (balanceOf[msg.sender] < _value) return false;                   /* check if the sender has enough */\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) return false;         /* check for overflows */              \n', '        balanceOf[msg.sender] -=  _value;                                   /* subtract from the sender */\n', '        balanceOf[_to] += _value;                                           /* add the same to the recipient */\n', '        Transfer(msg.sender, _to, _value);                                  /* notify anyone listening that this transfer took place */\n', '        return true;\n', '    }      \n', '\n', '    /*\n', '    *  @notice public function    \n', '    *  @param _from address to send tokens from \n', '    *  @param _to address to send tokens to   \n', '    *  @param _value number of tokens to transfer     \n', '    *  @returns boolean success      \n', '    *  another contract attempts to spend tokens on your behalf\n', '    */       \n', '    function transferFrom(address _from, address _to, uint _value) public\n', '        returns (bool success) \n', '    {                \n', '        if(tokensFrozen && msg.sender != priviledgedAddress) return false;  /* transfer only by priviledgedAddress during crowdfund or reward phases */\n', '        if (balanceOf[_from] < _value) return false;                        /* check if the sender has enough */\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) return false;         /* check for overflows */                \n', '        if (_value > allowance[_from][msg.sender]) return false;            /* check allowance */\n', '        balanceOf[_from] -= _value;                                         /* subtract from the sender */\n', '        balanceOf[_to] += _value;                                           /* add the same to the recipient */\n', '        allowance[_from][msg.sender] -= _value;                             /* reduce allowance */\n', '        Transfer(_from, _to, _value);                                       /* notify anyone listening that this transfer took place */\n', '        return true;\n', '    }        \n', ' \n', '    /*\n', '    *  @notice public function    \n', '    *  @param _spender address being granted approval to spend on behalf of msg.sender\n', '    *  @param _value number of tokens granted approval for _spender to spend on behalf of msg.sender    \n', '    *  @returns boolean success      \n', '    *  approves another contract to spend some tokens on your behalf\n', '    */      \n', '    function approve(address _spender, uint _value) public\n', '        returns (bool success)\n', '    {\n', '        /* set allowance for _spender on behalf of msg.sender */\n', '        allowance[msg.sender][_spender] = _value;\n', '\n', '        /* log event about transaction */\n', '        Approval(msg.sender, _spender, _value);        \n', '        return true;\n', '    } \n', '  \n', '    /*\n', '    *  @notice address restricted function \n', '    *  crowdfund contract calls this to burn its unsold coins \n', '    */     \n', '    function priviledgedAddressBurnUnsoldCoins() public\n', '        /* only crowdfund contract can call this */\n', '        onlyBy(priviledgedAddress)\n', '    {\n', '        /* totalSupply should equal total tokens in circulation */\n', '        totalSupply = safeSub(totalSupply, balanceOf[priviledgedAddress]); \n', '        /* burns unsold tokens from crowdfund address */\n', '        balanceOf[priviledgedAddress] = 0;\n', '    }\n', '\n', '    /*\n', '    *  @notice public function \n', '    *  locks/unlocks tokens on a recurring cycle\n', '    */         \n', '    function updateTokenStatus() public\n', '    {\n', '        \n', '        /* locks tokens during initial crowdfund period */\n', '        if(now < crowdfundDeadline){                       \n', '            tokensFrozen = true;         \n', '            LogTokensFrozen(tokensFrozen);  \n', '        }  \n', '\n', '        /* locks tokens */\n', '        if(now >= nextFreeze){          \n', '            tokensFrozen = true;\n', '            LogTokensFrozen(tokensFrozen);  \n', '        }\n', '\n', '        /* unlocks tokens */\n', '        if(now >= nextThaw){         \n', '            tokensFrozen = false;\n', '            nextFreeze = now + 2 hours;\n', '            nextThaw = now + 3 hours;              \n', '            LogTokensFrozen(tokensFrozen);  \n', '        }        \n', '      \n', '    }                              \n', '\n', '    /*\n', '    *  @notice owner restricted function\n', '    *  @param _newPriviledgedAddress the address\n', '    *  only this address can burn unsold tokens\n', '    *  transfer tokens only by priviledgedAddress during crowdfund or reward phases\n', '    */      \n', '    function ownerSetPriviledgedAddress(address _newPriviledgedAddress) public \n', '        onlyOwner\n', '    {\n', '        priviledgedAddress = _newPriviledgedAddress;\n', '    }   \n', '                    \n', '    \n', '}']