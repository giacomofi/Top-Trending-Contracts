['pragma solidity 0.4.11;\n', '\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint256 totalSupply) {}\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '    function transfer(address _recipient, uint256 _value) returns (bool success) {}\n', '    function transferFrom(address _from, address _recipient, uint256 _value) returns (bool success) {}\n', '    function approve(address _spender, uint256 _value) returns (bool success) {}\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _recipient, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is ERC20 {\n', '\n', '\tuint256 public totalSupply;\n', '\tmapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    \n', '    modifier when_can_transfer(address _from, uint256 _value) {\n', '        if (balances[_from] >= _value) _;\n', '    }\n', '\n', '    modifier when_can_receive(address _recipient, uint256 _value) {\n', '        if (balances[_recipient] + _value > balances[_recipient]) _;\n', '    }\n', '\n', '    modifier when_is_allowed(address _from, address _delegate, uint256 _value) {\n', '        if (allowed[_from][_delegate] >= _value) _;\n', '    }\n', '\n', '    function transfer(address _recipient, uint256 _value)\n', '        when_can_transfer(msg.sender, _value)\n', '        when_can_receive(_recipient, _value)\n', '        returns (bool o_success)\n', '    {\n', '        balances[msg.sender] -= _value;\n', '        balances[_recipient] += _value;\n', '        Transfer(msg.sender, _recipient, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _recipient, uint256 _value)\n', '        when_can_transfer(_from, _value)\n', '        when_can_receive(_recipient, _value)\n', '        when_is_allowed(_from, msg.sender, _value)\n', '        returns (bool o_success)\n', '    {\n', '        allowed[_from][msg.sender] -= _value;\n', '        balances[_from] -= _value;\n', '        balances[_recipient] += _value;\n', '        Transfer(_from, _recipient, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool o_success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 o_remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract GECToken is StandardToken {\n', '\n', '\t//FIELDS\n', '\tstring public name = "GECoin";\n', '    string public symbol = "GEC";\n', '    uint public decimals = 3;\n', '\n', '\t//INITIALIZATION\n', '\taddress public minter; //address that able to mint new tokens\n', '\tuint public icoEndTime; \n', '\n', '\tuint illiquidBalance_amount;\n', '\tmapping (uint => address) illiquidBalance_index;\n', '\tmapping (address => uint) public illiquidBalance; //Balance of &#39;Frozen funds&#39;\n', '\n', '\t// called by crowdsale contract\n', '\tmodifier only_minter {\n', '\t\tif (msg.sender != minter) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\t// Token can be transferred immediately after crowdsale.\n', '\tmodifier when_transferable {\n', '\t\tif (now <= icoEndTime) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\t// Can only be called if the `crowdfunder` is allowed to mint tokens. Any\n', '\t// time before `endMintingTime`.\n', '\tmodifier when_mintable {\n', '\t\tif (now > icoEndTime + 5 days) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\t// Initialization contract assigns address of crowdfund contract and end time.\n', '\tfunction GECToken (address _minter, uint _icoEndTime) {\n', '\t\tminter = _minter;\n', '\t\ticoEndTime = _icoEndTime;\n', '\t}\n', '\n', '\t// Create new tokens when called by the crowdfund contract.\n', '\t// Only callable before the end time.\n', '\tfunction createToken(address _recipient, uint _value)\n', '\t\twhen_mintable\n', '\t\tonly_minter\n', '\t\treturns (bool o_success)\n', '\t{\n', '\t\tbalances[_recipient] += _value;\n', '\t\ttotalSupply += _value;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Create an illiquidBalance which cannot be traded until admin make it liquid.\n', '\t// Can only be called by crowdfund contract before the end time.\n', '\tfunction createIlliquidToken(address _recipient, uint _value)\n', '\t\twhen_mintable\n', '\t\tonly_minter\n', '\t\treturns (bool o_success)\n', '\t{\n', '\t\tilliquidBalance_index[illiquidBalance_amount] = _recipient;\n', '\t\tilliquidBalance[_recipient] += _value;\n', '\t\tilliquidBalance_amount++;\n', '\n', '\t\ttotalSupply += _value;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t// Make sender&#39;s illiquid balance liquid when called after lockout period.\n', '\tfunction makeLiquid()\n', '\t\tonly_minter\n', '\t{\n', '\t\tfor (uint i=0; i<illiquidBalance_amount; i++) {\n', '\t\t\taddress investor = illiquidBalance_index[i];\n', '\t\t\tbalances[investor] += illiquidBalance[investor];\n', '\t\t\tilliquidBalance[investor] = 0;\n', '\t\t}\n', '\t}\n', '\n', '\t// Transfer amount of tokens from sender account to recipient.\n', '\t// Only callable after the crowd fund end date.\n', '\tfunction transfer(address _recipient, uint _amount)\n', '\t\twhen_transferable\n', '\t\treturns (bool o_success)\n', '\t{\n', '\t\treturn super.transfer(_recipient, _amount);\n', '\t}\n', '\n', '\t// Transfer amount of tokens from a specified address to a recipient.\n', '\t// Only callable after the crowd fund end date.\n', '\tfunction transferFrom(address _from, address _recipient, uint _amount)\n', '\t\twhen_transferable\n', '\t\treturns (bool o_success)\n', '\t{\n', '\t\treturn super.transferFrom(_from, _recipient, _amount);\n', '\t}\n', '}']