['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', ' library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/*\n', 'file:   ReentryProtection.sol\n', 'ver:    0.3.0\n', 'updated:6-April-2016\n', 'author: Darryl Morris\n', 'email:  o0ragman0o AT gmail.com\n', '\n', 'Mutex based reentry protection protect.\n', '\n', 'This software is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', 'GNU lesser General Public License for more details.\n', '<http://www.gnu.org/licenses/>.\n', '*/\n', '\n', 'contract ReentryProtected\n', '{\n', '  // The reentry protection state mutex.\n', '  bool __reMutex;\n', '\n', '  // This modifier can be used on functions with external calls to\n', '  // prevent reentry attacks.\n', '  // Constraints:\n', '  //   Protected functions must have only one point of exit.\n', '  //   Protected functions cannot use the `return` keyword\n', '  //   Protected functions return values must be through return parameters.\n', '  modifier preventReentry() {\n', '    require(!__reMutex);\n', '    __reMutex = true;\n', '    _;\n', '    delete __reMutex;\n', '    return;\n', '  }\n', '\n', '  // This modifier can be applied to public access state mutation functions\n', '  // to protect against reentry if a `preventReentry` function has already\n', '  // set the mutex. This prevents the contract from being reenter under a\n', '  // different memory context which can break state variable integrity.\n', '  modifier noReentry() {\n', '    require(!__reMutex);\n', '    _;\n', '  }\n', '}\n', '\n', '/*\n', 'file:   ERC20.sol\n', 'ver:    0.4.4-o0ragman0o\n', 'updated:26-July-2017\n', 'author: Darryl Morris\n', 'email:  o0ragman0o AT gmail.com\n', '\n', 'An ERC20 compliant token with reentry protection and safe math.\n', '\n', 'This software is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \n', 'See MIT Licence for further details.\n', '<https://opensource.org/licenses/MIT>.\n', '\n', 'Release Notes\n', '-------------\n', '0.4.4-o0ragman0o\n', '* removed state from interface\n', '* added abstract functions of public state to interface.\n', '* included state into contract implimentation\n', '*/\n', '\n', '\n', '// ERC20 Standard Token Interface with safe maths and reentry protection\n', 'contract ERC20Interface\n', '{\n', '  /* Structs */\n', '\n', '  /* State Valiables */\n', '\n', '  /* Events */\n', '  // Triggered when tokens are transferred.\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 _value);\n', '\n', '  // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _spender,\n', '    uint256 _value);\n', '\n', '  /* Modifiers */\n', '\n', '  /* Function Abstracts */\n', '\n', '  /// @return The total supply of tokens\n', '  function totalSupply() public constant returns (uint256);\n', '\n', '  /// @param _addr The address of a token holder\n', '  /// @return The amount of tokens held by `_addr`\n', '  function balanceOf(address _addr) public constant returns (uint256);\n', '\n', '  /// @param _owner The address of a token holder\n', '  /// @param _spender the address of a third-party\n', '  /// @return The amount of tokens the `_spender` is allowed to transfer\n', '  function allowance(address _owner, address _spender) public constant\n', '  returns (uint256);\n', '\n', '  /// @notice Send `_amount` of tokens from `msg.sender` to `_to`\n', '  /// @param _to The address of the recipient\n', '  /// @param _amount The amount of tokens to transfer\n', '  function transfer(address _to, uint256 _amount) public returns (bool);\n', '\n', '  /// @notice Send `_amount` of tokens from `_from` to `_to` on the condition\n', '  /// it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _amount The amount of tokens to transfer\n', '  function transferFrom(address _from, address _to, uint256 _amount)\n', '  public returns (bool);\n', '\n', '  /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n', '  /// its behalf\n', '  /// @param _spender The address of the approved spender\n', '  /// @param _amount The amount of tokens to transfer\n', '  function approve(address _spender, uint256 _amount) public returns (bool);\n', '}\n', '\n', 'contract ERC20Token is ReentryProtected, ERC20Interface\n', '{\n', '\n', '  using SafeMath for uint256;\n', '\n', '  /* State */\n', '  // The Total supply of tokens\n', '  uint256 totSupply;\n', '\n', '  \n', '  // Token ownership mapping\n', '  mapping (address => uint256) balance;\n', '\n', '  // Allowances mapping\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '  /* Funtions Public */\n', '\n', '  function ERC20Token()\n', '  {\n', '    // Supply limited to 2^128 rather than 2^256 to prevent potential \n', '    // multiplication overflow\n', '    \n', '    totSupply = 0;\n', '    balance[msg.sender] = totSupply;\n', '  }\n', '\n', '  // Using an explicit getter allows for function overloading    \n', '  function totalSupply()\n', '  public\n', '  constant\n', '  returns (uint256)\n', '  {\n', '    return totSupply;\n', '  }\n', '\n', '\n', '  // Using an explicit getter allows for function overloading    \n', '  function balanceOf(address _addr)\n', '  public\n', '  constant\n', '  returns (uint256)\n', '  {\n', '    return balance[_addr];\n', '  }\n', '\n', '  // Using an explicit getter allows for function overloading    \n', '  function allowance(address _owner, address _spender)\n', '  public\n', '  constant\n', '  returns (uint256 remaining_)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '\n', '  // Send _value amount of tokens to address _to\n', '  // Reentry protection prevents attacks upon the state\n', '  function transfer(address _to, uint256 _value)\n', '  public\n', '  noReentry\n', '  returns (bool)\n', '  {\n', '    return xfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  // Send _value amount of tokens from address _from to address _to\n', '  // Reentry protection prevents attacks upon the state\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '  public\n', '  noReentry\n', '  returns (bool)\n', '  {\n', '    require(_value <= allowed[_from][msg.sender]);\n', '    allowed[_from][msg.sender] -= _value;\n', '    return xfer(_from, _to, _value);\n', '  }\n', '\n', '  // Process a transfer internally.\n', '  function xfer(address _from, address _to, uint256 _value)\n', '  internal\n', '  returns (bool)\n', '  {\n', '    require(_value > 0 && _value <= balance[_from]);\n', '    balance[_from] -= _value;\n', '    balance[_to] += _value;\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  // Approves a third-party spender\n', '  // Reentry protection prevents attacks upon the state\n', '  function approve(address _spender, uint256 _value)\n', '  public\n', '  noReentry\n', '  returns (bool)\n', '  {\n', '    require(balance[msg.sender] != 0);\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '}\n', '\n', '  /**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', ' contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '   function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '   modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '   function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Mintable token\n', ' * @dev Simple ERC20 Token example, with mintable token creation\n', ' * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n', ' * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n', ' */\n', '\n', ' contract MintableToken is ERC20Token, Ownable {\n', '  using SafeMath for uint256;\n', '  event Mint(address indexed to, uint256 amount);\n', '  event MintFinished();\n', '\n', '  bool public mintingFinished = false;\n', '\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to mint tokens\n', '   * @param _to The address that will recieve the minted tokens.\n', '   * @param _amount The amount of tokens to mint.\n', '   * @return A boolean that indicates if the operation was successful.\n', '   */\n', '   function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\n', '    totSupply = totSupply.add(_amount);\n', '    balance[_to] = balance[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    Transfer(0x0, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '    /**\n', '   * @dev Function to stop minting new tokens.\n', '   * @return True if the operation was successful.\n', '   */\n', '   function finishMinting() onlyOwner returns (bool) {\n', '    mintingFinished = true;\n', '    MintFinished();\n', '    return true;\n', '  }\n', '}\n', '/**\n', ' * @title SimpleToken\n', ' * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator. \n', ' * Note they can later distribute these tokens as they wish using `transfer` and other\n', ' * `StandardToken` functions.\n', ' */\n', ' contract TriaToken_v2 is MintableToken {\n', '\n', '  string public constant name = "TriaToken";\n', '  string public constant symbol = "TRIA";\n', '  uint256 public constant decimals = 10;\n', '}']