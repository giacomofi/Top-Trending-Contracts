['pragma solidity ^0.4.9;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', '/**\n', '\t * @title ERC20Basic\n', '\t * @dev Simpler version of ERC20 interface\n', '\t * @dev see https://github.com/ethereum/EIPs/issues/20\n', '\t */\n', 'contract ERC20Basic {\n', '\t  uint256 public totalSupply;\n', '\t  function balanceOf(address who) constant returns (uint256);\n', '\t  function transfer(address to, uint256 value);\n', '\t  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value);\n', '  function approve(address spender, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '   * @dev Fix for the ERC20 short address attack.\n', '   */\n', '  modifier onlyPayloadSize(uint256 size) {\n', '     require(!(msg.data.length < size + 4));\n', '     _;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implemantation of the basic standart token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)) );\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract Pixiu is StandardToken {\n', '\n', '    uint public decimals = 6;\n', '    bool public isPayable = true;\n', '    bool public isWithdrawable = true;\n', '    bool public isRequireData = false;\n', '\t\n', '    struct exchangeRate {\n', '        \n', '        uint time1;                                      \n', '        uint time2;                                     \n', '        uint value;\n', '        \n', '    }\n', '    \n', '    struct Member {\n', '         \n', '        bool isExists;                                      \n', '        bool isDividend;                                    \n', '        bool isWithdraw;                                     \n', '        uint256 dividend;                                   \n', '        uint256 withdraw;\n', '        \n', '    }\n', '    \n', '    exchangeRate[] public exchangeRateArray;  \n', '\n', '\tmapping (address => Member) public members; \n', '    address[] public adminArray;   \n', '    address[] public memberArray;\n', '    \n', '\t \n', '    address public deposit_address;\n', '    uint256 public tokenExchangeRateInWei = 300*10**6;\n', '\t\n', '\t/*\n', '    *虛擬帳號   共20碼\n', '    *1-4 固定 0xFFFFFFFF \n', '    *5-8 繳費期限\n', '    *9-11 流水號 商家代碼 0x000000-0xFFFFFF\n', '    *12-16 商家自訂 4碼=8位 0-F\n', '    *17-18 金額\n', '    *19 :0x20 +4bit候補零\n', '    * 當 BYTE19 = 00  12-18 為商家自訂\n', '    *20 檢查碼 \n', '    */\n', '    mapping (address => uint) public shopStoreId; \n', '    mapping (uint => address) public shopStoreAddress; \n', '    uint256 public shopStorePrice = 1*10**6;\n', '    uint256 public shopStoreNextId = 0;\n', '    address public shopStoreRegister;\n', '\n', '\t//不歸零\n', '\t\n', '\tuint256 public total_tokenwei = 0; \n', '\tuint256 public min_pay_wei = 0;\n', '\t// admin_withdraw_all 歸零\n', '\tuint256 public total_devidend = 0; //member\n', '\tuint256 public total_withdraw = 0; //member\n', '    uint256 public deposit_amount = 0;  //deposit\n', '    uint256 public withdraw_amount = 0; //deposit\n', '    uint256 public dividend_amount = 0; //admin   \n', '    \n', '    event Paydata(address indexed payer, uint256 value, bytes data, uint256 thisTokenWei);\n', '    \n', '    function Pixiu() {\n', '        totalSupply = 21000000000000; \n', '        adminArray.push(msg.sender);\n', '        admin_set_deposit(msg.sender);\n', '        admin_set_shopStoreRegister(msg.sender);\n', '         \n', '    }\n', '    \n', '    function get_orderAddress(address _address,uint _expire_day,uint _userdata,uint _amount ,uint _zero) constant returns (uint256){\n', '        uint256 storeid = shopStoreId[_address];\n', '        uint160 result = uint152(0xffffffff<<120) + uint120((_expire_day * 86400 + now)<<88) + uint88(storeid<<64); \n', '        \n', '            _userdata = _userdata<<16;\n', '            _userdata += _amount;\n', '        \n', '        result += uint64(_userdata<<8);\n', '        result += uint8(0x20+_zero);\n', '        uint8 crc = uint8(sha256(uint152(result) ));\n', '        return (result << 8) + crc;\n', '    }\n', '    \n', '    function isLeading4FF(address _sender ) private  returns(bool){\n', '        uint32 ff4= uint32(uint256(_sender) >> 128);\n', '        return (ff4 == 0xffffffff);\n', '    }\n', '\n', '    modifier onlyDeposit() {\n', '        \n', '        require(msg.sender == deposit_address);\n', '        _;\n', '        \n', '    }\n', '    \n', '    modifier onlyAdmin() {\n', '        \n', '        bool ok = admin_check(msg.sender);\n', '        require(ok);\n', '        _;\n', '        \n', '    }\n', '    \n', '    modifier adminExists(address admin) {\n', '\n', '        bool ok = false;\n', '        if(admin != msg.sender){\n', '            \n', '            ok = admin_check(admin);\n', '        \n', '        }\n', '        require(ok);\n', '        _; \n', '        \n', '    }\n', '    \n', '    modifier adminDoesNotExist(address admin) {\n', '\n', '        bool ok = admin_check(admin);\n', '        require(!ok);\n', '        _;\n', '        \n', '    }\n', '    \n', '    function admin_check(address admin) private constant returns(bool){\n', '        \n', '        bool ok = false;\n', '        \n', '        for (uint i = 0; i < adminArray.length; i++) {\n', '            if (admin == adminArray[i]) {\n', '                ok = true;\n', '                break;\n', '            }\n', '        }\n', '        \n', '        return ok;\n', '        \n', '    }\n', '    \n', '    modifier memberExists(address member) {\n', '\n', '        bool ok = false;\n', '        if (members[member].isExists == true) {\n', '            \n', '            ok = true;\n', '            \n', '        }\n', '        require(ok);\n', '        _;\n', '        \n', '    }\n', '    \n', '    modifier isMember() {\n', '\n', '        bool ok = false;\n', '        if (members[msg.sender].isExists == true) {            \n', '            ok = true;            \n', '        }\n', '        require(ok);\n', '        _;\n', '        \n', '    }\n', '    \n', '    function admin_deposit(uint xEth) onlyAdmin{\n', '        \n', '        uint256 xwei = xEth * 10**18;\n', '        deposit_amount += xwei;\n', '        \n', '    }\n', '    \n', '    /**\t*\t管理員發放股息\t*\t每個會員股息依 \t*\t*/\n', '    function admin_dividend(uint xEth) onlyAdmin{\n', '        \n', '\t\tuint256 xwei = xEth * 10**18;\n', '\t\trequire(xwei <= (deposit_amount-dividend_amount) ); \n', '\n', '\t\tdividend_amount += xwei;\n', '        uint256 len = memberArray.length;\t\n', '        uint i = 0;\n', '        address _member;\n', '        \n', '\t\tuint total_balance_dividened=0;\n', '        for( i = 0; i < len; i++){            \n', '            _member = memberArray[i];\n', '\t\t\tif(members[_member].isDividend){\n', '\t\t\t\ttotal_balance_dividened = balances[_member]; \n', '\t\t\t}            \n', '        }\n', '\t\tuint256 perTokenWei = xwei / (total_balance_dividened / 10 ** 6);\n', '            \n', '        for( i = 0; i < len; i++){            \n', '            _member = memberArray[i];\n', '\t\t\tif(members[_member].isDividend){\n', '\t\t\t\tuint256 thisWei = (balances[_member] / 10 ** 6) * perTokenWei;\n', '\t\t\t\tmembers[_member].dividend += thisWei; \n', '\t\t\t\ttotal_devidend += thisWei;\n', '\t\t\t}            \n', '        }\n', '    \n', '    }\n', '    \n', '    function admin_set_exchange_rate(uint[] exchangeRates) onlyAdmin{\n', '         \n', '        uint len = exchangeRates.length;\n', '        exchangeRateArray.length = 0;\n', '        \n', '        for(uint i = 0; i < len; i += 3){\n', '            \n', '            uint time1 = exchangeRates[i];\n', '            uint time2 = exchangeRates[i + 1];\n', '            uint value = exchangeRates[i + 2]*1000;\n', '            exchangeRateArray.push(exchangeRate(time1, time2, value));      \n', '            \n', '        }\n', '        \n', '    }\n', '    \n', '    \n', '    \n', '    function admin_set_shopStoreRegister(address _address) onlyAdmin{\n', '        \n', '        shopStoreRegister = _address;\n', '        \n', '    }\n', '    \n', '    function admin_set_exchange_rate(uint256 exchangeRates) onlyAdmin{\n', '        \n', '        tokenExchangeRateInWei = exchangeRates;\n', '        \n', '    }\n', '\n', '\tfunction get_exchange_wei() constant returns(uint256){\n', '\n', '\t\tuint len = exchangeRateArray.length;  \n', '\t\tuint nowTime = block.timestamp;\n', '        for(uint i = 0; i < len; i += 3){\n', '            \n', '\t\t\texchangeRate memory rate = exchangeRateArray[i];\n', '            uint time1 = rate.time1;\n', '            uint time2 = rate.time2;\n', '            uint value = rate.value;\n', '\t\t\tif (nowTime>= time1 && nowTime<=time2) {\n', '\t\t\t\ttokenExchangeRateInWei = value;\n', '\t\t\t\treturn value;\n', '\t\t\t}\n', '            \n', '        }\n', '\t\treturn tokenExchangeRateInWei;\n', '\t}\n', '\t\n', '\tfunction admin_set_min_pay(uint256 _min_pay) onlyAdmin{\n', '\t    \n', '\t    require(_min_pay >= 0);\n', '\t    min_pay_wei = _min_pay * 10 ** 18;\n', '\t    \n', '\t}\n', '    \n', '    function get_admin_list() constant returns(address[] _adminArray){\n', '        \n', '        _adminArray = adminArray;\n', '        \n', '    }\n', '    \n', '    function admin_add(address admin) onlyAdmin adminDoesNotExist(admin){\n', '        \n', '        adminArray.push(admin);\n', '        \n', '    }\n', '    \n', '    function admin_del(address admin) onlyAdmin adminExists(admin){\n', '        \n', '        for (uint i = 0; i < adminArray.length - 1; i++)\n', '            if (adminArray[i] == admin) {\n', '                adminArray[i] = adminArray[adminArray.length - 1];\n', '                break;\n', '            }\n', '            \n', '        adminArray.length -= 1;\n', '        \n', '    }\n', '    \n', '    function admin_set_deposit(address addr) onlyAdmin{\n', '        \n', '        deposit_address = addr;\n', '        \n', '    }\n', '    \n', '    function admin_set_shopStorePrice(uint256 _shopStorePrice) onlyAdmin{\n', '        \n', '        shopStorePrice = _shopStorePrice;\n', '        \n', '    }\n', '    \n', '    function admin_set_isRequireData(bool _requireData) onlyAdmin{\n', '    \n', '        isRequireData = _requireData;\n', '        \n', '    }\n', '    \n', '    function admin_active_payable() onlyAdmin{\n', '    \n', '        isPayable = true;\n', '        \n', '    }\n', '    \n', '    function admin_inactive_payable() onlyAdmin{\n', '        \n', '        isPayable = false;\n', '        \n', '    }\n', '    \n', '    function admin_active_withdrawable() onlyAdmin{\n', '        \n', '        isWithdrawable = true;\n', '        \n', '    }\n', '    \n', '    function admin_inactive_withdrawable() onlyAdmin{\n', '        \n', '        isWithdrawable = false;\n', '        \n', '    }\n', '    \n', '    function admin_active_dividend(address _member) onlyAdmin memberExists(_member){\n', '        \n', '        members[_member].isDividend = true;\n', '        \n', '    }\n', '    \n', '    function admin_inactive_dividend(address _member) onlyAdmin memberExists(_member){\n', '        \n', '        members[_member].isDividend = false;\n', '        \n', '    }\n', '    \n', '    function admin_active_withdraw(address _member) onlyAdmin memberExists(_member){\n', '        \n', '        members[_member].isWithdraw = true;\n', '        \n', '    }\n', '    \n', '    function admin_inactive_withdraw(address _member) onlyAdmin memberExists(_member){\n', '        \n', '        members[_member].isWithdraw = false;\n', '        \n', '    }\n', '    \n', '    function get_total_info() constant returns(uint256 _deposit_amount, uint256 _total_devidend, uint256 _total_remain, uint256 _total_withdraw){\n', '\n', '        _total_remain = total_devidend - total_withdraw;\n', '        _deposit_amount = deposit_amount;\n', '        _total_devidend = total_devidend;\n', '        _total_withdraw = total_withdraw;\n', '        \n', '    }\n', '    \n', '    function get_info(address _member) constant returns (uint256 _balance, uint256 _devidend, uint256 _remain, uint256 _withdraw){\n', '        \n', '        _devidend = members[_member].dividend;\n', '        _withdraw = members[_member].withdraw;\n', '        _remain = _devidend - _withdraw;\n', '        _balance = balances[_member];\n', '        \n', '    }\n', '    \n', '    function withdraw() isMember {\n', '        \n', '        uint256 _remain = members[msg.sender].dividend - members[msg.sender].withdraw;\n', '        require(_remain > 0);\n', '        require(isWithdrawable);\n', '        require(members[msg.sender].isWithdraw);\n', '        msg.sender.transfer(_remain);\n', '        members[msg.sender].withdraw += _remain; \n', '        total_withdraw += _remain;          \n', '\n', '    }\n', '\n', '    function admin_withdraw(uint xEth) onlyDeposit{\n', '\n', '        uint256 _withdraw = xEth * 10**18;\n', '\t\trequire( msg.sender == deposit_address );\n', '\n', '\t\trequire(this.balance > _withdraw);\n', '\t\tmsg.sender.transfer(_withdraw);\n', '\n', '        withdraw_amount += _withdraw;  \n', '        \n', '    }\n', '    \n', '    function admin_withdraw_all(address _deposit) onlyAdmin {\n', '        \n', '\t\trequire( _deposit == deposit_address ); \n', '\n', '\t\t_deposit.transfer(this.balance);\n', '\n', '\t\ttotal_devidend = 0; //member\n', '\t\ttotal_withdraw = 0; //member\n', '\t\tdeposit_amount = 0;  //deposit\n', '\t\twithdraw_amount = 0; //deposit\n', '\t\tdividend_amount = 0; //admin   \n', '        \n', '    }\n', '    \n', '    function admin_transfer(address _to, uint256 _value) onlyAdmin onlyPayloadSize(2 * 32)     {\n', '        \n', '        require(_to != deposit_address);\n', '        require(total_tokenwei <= totalSupply - _value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        \n', '        total_tokenwei += _value;\n', '    \n', '        if (members[_to].isExists != true) {  \n', '            members[_to].isExists = true;\n', '            members[_to].isDividend = true;\n', '            members[_to].isWithdraw = true; \n', '            memberArray.push(_to);  \n', '        }\n', '        \n', '    }\n', ' \n', '\tfunction transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32)     {\n', '\t\trequire(_to != msg.sender);\n', '        require(isPayable);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\t\n', '\t\tif(_to == deposit_address){\n', '\t\t    require(_value == shopStorePrice);\n', '\t\t    shopStoreNextId++;\n', '\t\t    shopStoreId[msg.sender] = shopStoreNextId;\n', '\t\t    shopStoreAddress[shopStoreNextId] = msg.sender;\n', '\t\t\n', '\t\t} else if(isLeading4FF(_to)){\n', '\t\t    uint256 to256 = uint256(_to);\n', '            uint32 expire = uint32(to256>>96);\n', '            uint32 storeid = uint24(to256>>72);\n', '            uint8 crc8 = uint8(to256);\n', '            require(uint32(now)<expire || expire==0);\n', '            \n', '            uint8 crc20 = uint8(sha256(uint152(to256>>8)));\n', '            require(crc20==crc8);\n', '            \n', '            _to = shopStoreAddress[uint(storeid)];\n', '            require(uint(_to)>0);\n', '\n', '            uint56 userdata = uint56(to256>>96);\n', '    \t\t\n', '    \t\tbalances[_to] = balances[_to].add(_value);\n', '    \t\tif (members[_to].isExists != true) {\t\t\n', '    \t\t\tmembers[_to].isExists = true;\n', '    \t\t\tmembers[_to].isDividend = true;\n', '    \t\t\tmembers[_to].isWithdraw = true; \n', '    \t\t\tmemberArray.push(_to);\t\t\n', '    \t\t}  \n', '\t\t\n', '\t\t} else { \n', '    \t\tbalances[_to] = balances[_to].add(_value);\n', '    \t\tif (members[_to].isExists != true) {\t\t\n', '    \t\t\tmembers[_to].isExists = true;\n', '    \t\t\tmembers[_to].isDividend = true;\n', '    \t\t\tmembers[_to].isWithdraw = true; \n', '    \t\t\tmemberArray.push(_to);\t\t\n', '    \t\t}  \n', '\n', '        }\n', '\n', '\t\tTransfer(msg.sender, _to, _value);\n', '\t}\n', '\t\n', '\tfunction transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32)     {\n', '\t\trequire(_to != deposit_address);\n', '\t\trequire(_from != deposit_address);\n', '        require(isPayable);\n', '\t\tvar _allowance = allowed[_from][msg.sender]; \n', '\t\trequire(_allowance >= _value);\n', '\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tbalances[_from] = balances[_from].sub(_value);\n', '\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\n', '\t\t\n', '\t\tif (members[_to].isExists != true) {\t\t\n', '\t\t\tmembers[_to].isExists = true;\n', '\t\t\tmembers[_to].isDividend = true;\n', '\t\t\tmembers[_to].isWithdraw = true; \n', '\t\t\tmemberArray.push(_to);\t\t\n', '\t\t}  \n', '\n', '\t\tTransfer(_from, _to, _value);\n', '\t}\n', '\n', '    function () payable {\n', '        \n', '        pay();\n', '        \n', '    }\n', '  \n', '    function pay() public payable  returns (bool) {\n', '        \n', '        require(!isLeading4FF(msg.sender));\n', '        require(msg.value > min_pay_wei);\n', '        require(isPayable);\n', '        \n', '        if(msg.sender == deposit_address){\n', '             deposit_amount += msg.value;\n', '        }else{\n', '            \n', '            if(isRequireData){\n', '                require(uint32(msg.data[0]) == uint32(0xFFFFFFFF));   \n', '            }\n', '        \n', '    \t\tuint256 exchangeWei = get_exchange_wei();\n', '    \t\tuint256 thisTokenWei = exchangeWei * msg.value / 10**18 ;\n', '    \t\t\n', '    \t\trequire(total_tokenwei <= totalSupply - thisTokenWei);\n', '        \n', '            if (members[msg.sender].isExists != true) {\n', '                \n', '                members[msg.sender].isExists = true;\n', '                members[msg.sender].isDividend = true;\n', '                members[msg.sender].isWithdraw = true; \n', '                memberArray.push(msg.sender);\n', '                \n', '            }  \n', '    \t\tbalances[msg.sender] += thisTokenWei;\n', '    \t\ttotal_tokenwei += thisTokenWei;\n', '    \t\t\n', '    \t\tPaydata(msg.sender, msg.value, msg.data, thisTokenWei);\n', '    \t\tTransfer(this, msg.sender, thisTokenWei);\n', '\t\t\n', '        }\n', '        \n', '        return true;\n', '    \n', '    }\n', '            \n', '    function get_this_balance() constant returns(uint256){\n', '      \n', '        return this.balance;\n', '      \n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.9;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', '/**\n', '\t * @title ERC20Basic\n', '\t * @dev Simpler version of ERC20 interface\n', '\t * @dev see https://github.com/ethereum/EIPs/issues/20\n', '\t */\n', 'contract ERC20Basic {\n', '\t  uint256 public totalSupply;\n', '\t  function balanceOf(address who) constant returns (uint256);\n', '\t  function transfer(address to, uint256 value);\n', '\t  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value);\n', '  function approve(address spender, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '   * @dev Fix for the ERC20 short address attack.\n', '   */\n', '  modifier onlyPayloadSize(uint256 size) {\n', '     require(!(msg.data.length < size + 4));\n', '     _;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implemantation of the basic standart token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)) );\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract Pixiu is StandardToken {\n', '\n', '    uint public decimals = 6;\n', '    bool public isPayable = true;\n', '    bool public isWithdrawable = true;\n', '    bool public isRequireData = false;\n', '\t\n', '    struct exchangeRate {\n', '        \n', '        uint time1;                                      \n', '        uint time2;                                     \n', '        uint value;\n', '        \n', '    }\n', '    \n', '    struct Member {\n', '         \n', '        bool isExists;                                      \n', '        bool isDividend;                                    \n', '        bool isWithdraw;                                     \n', '        uint256 dividend;                                   \n', '        uint256 withdraw;\n', '        \n', '    }\n', '    \n', '    exchangeRate[] public exchangeRateArray;  \n', '\n', '\tmapping (address => Member) public members; \n', '    address[] public adminArray;   \n', '    address[] public memberArray;\n', '    \n', '\t \n', '    address public deposit_address;\n', '    uint256 public tokenExchangeRateInWei = 300*10**6;\n', '\t\n', '\t/*\n', '    *虛擬帳號   共20碼\n', '    *1-4 固定 0xFFFFFFFF \n', '    *5-8 繳費期限\n', '    *9-11 流水號 商家代碼 0x000000-0xFFFFFF\n', '    *12-16 商家自訂 4碼=8位 0-F\n', '    *17-18 金額\n', '    *19 :0x20 +4bit候補零\n', '    * 當 BYTE19 = 00  12-18 為商家自訂\n', '    *20 檢查碼 \n', '    */\n', '    mapping (address => uint) public shopStoreId; \n', '    mapping (uint => address) public shopStoreAddress; \n', '    uint256 public shopStorePrice = 1*10**6;\n', '    uint256 public shopStoreNextId = 0;\n', '    address public shopStoreRegister;\n', '\n', '\t//不歸零\n', '\t\n', '\tuint256 public total_tokenwei = 0; \n', '\tuint256 public min_pay_wei = 0;\n', '\t// admin_withdraw_all 歸零\n', '\tuint256 public total_devidend = 0; //member\n', '\tuint256 public total_withdraw = 0; //member\n', '    uint256 public deposit_amount = 0;  //deposit\n', '    uint256 public withdraw_amount = 0; //deposit\n', '    uint256 public dividend_amount = 0; //admin   \n', '    \n', '    event Paydata(address indexed payer, uint256 value, bytes data, uint256 thisTokenWei);\n', '    \n', '    function Pixiu() {\n', '        totalSupply = 21000000000000; \n', '        adminArray.push(msg.sender);\n', '        admin_set_deposit(msg.sender);\n', '        admin_set_shopStoreRegister(msg.sender);\n', '         \n', '    }\n', '    \n', '    function get_orderAddress(address _address,uint _expire_day,uint _userdata,uint _amount ,uint _zero) constant returns (uint256){\n', '        uint256 storeid = shopStoreId[_address];\n', '        uint160 result = uint152(0xffffffff<<120) + uint120((_expire_day * 86400 + now)<<88) + uint88(storeid<<64); \n', '        \n', '            _userdata = _userdata<<16;\n', '            _userdata += _amount;\n', '        \n', '        result += uint64(_userdata<<8);\n', '        result += uint8(0x20+_zero);\n', '        uint8 crc = uint8(sha256(uint152(result) ));\n', '        return (result << 8) + crc;\n', '    }\n', '    \n', '    function isLeading4FF(address _sender ) private  returns(bool){\n', '        uint32 ff4= uint32(uint256(_sender) >> 128);\n', '        return (ff4 == 0xffffffff);\n', '    }\n', '\n', '    modifier onlyDeposit() {\n', '        \n', '        require(msg.sender == deposit_address);\n', '        _;\n', '        \n', '    }\n', '    \n', '    modifier onlyAdmin() {\n', '        \n', '        bool ok = admin_check(msg.sender);\n', '        require(ok);\n', '        _;\n', '        \n', '    }\n', '    \n', '    modifier adminExists(address admin) {\n', '\n', '        bool ok = false;\n', '        if(admin != msg.sender){\n', '            \n', '            ok = admin_check(admin);\n', '        \n', '        }\n', '        require(ok);\n', '        _; \n', '        \n', '    }\n', '    \n', '    modifier adminDoesNotExist(address admin) {\n', '\n', '        bool ok = admin_check(admin);\n', '        require(!ok);\n', '        _;\n', '        \n', '    }\n', '    \n', '    function admin_check(address admin) private constant returns(bool){\n', '        \n', '        bool ok = false;\n', '        \n', '        for (uint i = 0; i < adminArray.length; i++) {\n', '            if (admin == adminArray[i]) {\n', '                ok = true;\n', '                break;\n', '            }\n', '        }\n', '        \n', '        return ok;\n', '        \n', '    }\n', '    \n', '    modifier memberExists(address member) {\n', '\n', '        bool ok = false;\n', '        if (members[member].isExists == true) {\n', '            \n', '            ok = true;\n', '            \n', '        }\n', '        require(ok);\n', '        _;\n', '        \n', '    }\n', '    \n', '    modifier isMember() {\n', '\n', '        bool ok = false;\n', '        if (members[msg.sender].isExists == true) {            \n', '            ok = true;            \n', '        }\n', '        require(ok);\n', '        _;\n', '        \n', '    }\n', '    \n', '    function admin_deposit(uint xEth) onlyAdmin{\n', '        \n', '        uint256 xwei = xEth * 10**18;\n', '        deposit_amount += xwei;\n', '        \n', '    }\n', '    \n', '    /**\t*\t管理員發放股息\t*\t每個會員股息依 \t*\t*/\n', '    function admin_dividend(uint xEth) onlyAdmin{\n', '        \n', '\t\tuint256 xwei = xEth * 10**18;\n', '\t\trequire(xwei <= (deposit_amount-dividend_amount) ); \n', '\n', '\t\tdividend_amount += xwei;\n', '        uint256 len = memberArray.length;\t\n', '        uint i = 0;\n', '        address _member;\n', '        \n', '\t\tuint total_balance_dividened=0;\n', '        for( i = 0; i < len; i++){            \n', '            _member = memberArray[i];\n', '\t\t\tif(members[_member].isDividend){\n', '\t\t\t\ttotal_balance_dividened = balances[_member]; \n', '\t\t\t}            \n', '        }\n', '\t\tuint256 perTokenWei = xwei / (total_balance_dividened / 10 ** 6);\n', '            \n', '        for( i = 0; i < len; i++){            \n', '            _member = memberArray[i];\n', '\t\t\tif(members[_member].isDividend){\n', '\t\t\t\tuint256 thisWei = (balances[_member] / 10 ** 6) * perTokenWei;\n', '\t\t\t\tmembers[_member].dividend += thisWei; \n', '\t\t\t\ttotal_devidend += thisWei;\n', '\t\t\t}            \n', '        }\n', '    \n', '    }\n', '    \n', '    function admin_set_exchange_rate(uint[] exchangeRates) onlyAdmin{\n', '         \n', '        uint len = exchangeRates.length;\n', '        exchangeRateArray.length = 0;\n', '        \n', '        for(uint i = 0; i < len; i += 3){\n', '            \n', '            uint time1 = exchangeRates[i];\n', '            uint time2 = exchangeRates[i + 1];\n', '            uint value = exchangeRates[i + 2]*1000;\n', '            exchangeRateArray.push(exchangeRate(time1, time2, value));      \n', '            \n', '        }\n', '        \n', '    }\n', '    \n', '    \n', '    \n', '    function admin_set_shopStoreRegister(address _address) onlyAdmin{\n', '        \n', '        shopStoreRegister = _address;\n', '        \n', '    }\n', '    \n', '    function admin_set_exchange_rate(uint256 exchangeRates) onlyAdmin{\n', '        \n', '        tokenExchangeRateInWei = exchangeRates;\n', '        \n', '    }\n', '\n', '\tfunction get_exchange_wei() constant returns(uint256){\n', '\n', '\t\tuint len = exchangeRateArray.length;  \n', '\t\tuint nowTime = block.timestamp;\n', '        for(uint i = 0; i < len; i += 3){\n', '            \n', '\t\t\texchangeRate memory rate = exchangeRateArray[i];\n', '            uint time1 = rate.time1;\n', '            uint time2 = rate.time2;\n', '            uint value = rate.value;\n', '\t\t\tif (nowTime>= time1 && nowTime<=time2) {\n', '\t\t\t\ttokenExchangeRateInWei = value;\n', '\t\t\t\treturn value;\n', '\t\t\t}\n', '            \n', '        }\n', '\t\treturn tokenExchangeRateInWei;\n', '\t}\n', '\t\n', '\tfunction admin_set_min_pay(uint256 _min_pay) onlyAdmin{\n', '\t    \n', '\t    require(_min_pay >= 0);\n', '\t    min_pay_wei = _min_pay * 10 ** 18;\n', '\t    \n', '\t}\n', '    \n', '    function get_admin_list() constant returns(address[] _adminArray){\n', '        \n', '        _adminArray = adminArray;\n', '        \n', '    }\n', '    \n', '    function admin_add(address admin) onlyAdmin adminDoesNotExist(admin){\n', '        \n', '        adminArray.push(admin);\n', '        \n', '    }\n', '    \n', '    function admin_del(address admin) onlyAdmin adminExists(admin){\n', '        \n', '        for (uint i = 0; i < adminArray.length - 1; i++)\n', '            if (adminArray[i] == admin) {\n', '                adminArray[i] = adminArray[adminArray.length - 1];\n', '                break;\n', '            }\n', '            \n', '        adminArray.length -= 1;\n', '        \n', '    }\n', '    \n', '    function admin_set_deposit(address addr) onlyAdmin{\n', '        \n', '        deposit_address = addr;\n', '        \n', '    }\n', '    \n', '    function admin_set_shopStorePrice(uint256 _shopStorePrice) onlyAdmin{\n', '        \n', '        shopStorePrice = _shopStorePrice;\n', '        \n', '    }\n', '    \n', '    function admin_set_isRequireData(bool _requireData) onlyAdmin{\n', '    \n', '        isRequireData = _requireData;\n', '        \n', '    }\n', '    \n', '    function admin_active_payable() onlyAdmin{\n', '    \n', '        isPayable = true;\n', '        \n', '    }\n', '    \n', '    function admin_inactive_payable() onlyAdmin{\n', '        \n', '        isPayable = false;\n', '        \n', '    }\n', '    \n', '    function admin_active_withdrawable() onlyAdmin{\n', '        \n', '        isWithdrawable = true;\n', '        \n', '    }\n', '    \n', '    function admin_inactive_withdrawable() onlyAdmin{\n', '        \n', '        isWithdrawable = false;\n', '        \n', '    }\n', '    \n', '    function admin_active_dividend(address _member) onlyAdmin memberExists(_member){\n', '        \n', '        members[_member].isDividend = true;\n', '        \n', '    }\n', '    \n', '    function admin_inactive_dividend(address _member) onlyAdmin memberExists(_member){\n', '        \n', '        members[_member].isDividend = false;\n', '        \n', '    }\n', '    \n', '    function admin_active_withdraw(address _member) onlyAdmin memberExists(_member){\n', '        \n', '        members[_member].isWithdraw = true;\n', '        \n', '    }\n', '    \n', '    function admin_inactive_withdraw(address _member) onlyAdmin memberExists(_member){\n', '        \n', '        members[_member].isWithdraw = false;\n', '        \n', '    }\n', '    \n', '    function get_total_info() constant returns(uint256 _deposit_amount, uint256 _total_devidend, uint256 _total_remain, uint256 _total_withdraw){\n', '\n', '        _total_remain = total_devidend - total_withdraw;\n', '        _deposit_amount = deposit_amount;\n', '        _total_devidend = total_devidend;\n', '        _total_withdraw = total_withdraw;\n', '        \n', '    }\n', '    \n', '    function get_info(address _member) constant returns (uint256 _balance, uint256 _devidend, uint256 _remain, uint256 _withdraw){\n', '        \n', '        _devidend = members[_member].dividend;\n', '        _withdraw = members[_member].withdraw;\n', '        _remain = _devidend - _withdraw;\n', '        _balance = balances[_member];\n', '        \n', '    }\n', '    \n', '    function withdraw() isMember {\n', '        \n', '        uint256 _remain = members[msg.sender].dividend - members[msg.sender].withdraw;\n', '        require(_remain > 0);\n', '        require(isWithdrawable);\n', '        require(members[msg.sender].isWithdraw);\n', '        msg.sender.transfer(_remain);\n', '        members[msg.sender].withdraw += _remain; \n', '        total_withdraw += _remain;          \n', '\n', '    }\n', '\n', '    function admin_withdraw(uint xEth) onlyDeposit{\n', '\n', '        uint256 _withdraw = xEth * 10**18;\n', '\t\trequire( msg.sender == deposit_address );\n', '\n', '\t\trequire(this.balance > _withdraw);\n', '\t\tmsg.sender.transfer(_withdraw);\n', '\n', '        withdraw_amount += _withdraw;  \n', '        \n', '    }\n', '    \n', '    function admin_withdraw_all(address _deposit) onlyAdmin {\n', '        \n', '\t\trequire( _deposit == deposit_address ); \n', '\n', '\t\t_deposit.transfer(this.balance);\n', '\n', '\t\ttotal_devidend = 0; //member\n', '\t\ttotal_withdraw = 0; //member\n', '\t\tdeposit_amount = 0;  //deposit\n', '\t\twithdraw_amount = 0; //deposit\n', '\t\tdividend_amount = 0; //admin   \n', '        \n', '    }\n', '    \n', '    function admin_transfer(address _to, uint256 _value) onlyAdmin onlyPayloadSize(2 * 32)     {\n', '        \n', '        require(_to != deposit_address);\n', '        require(total_tokenwei <= totalSupply - _value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        \n', '        total_tokenwei += _value;\n', '    \n', '        if (members[_to].isExists != true) {  \n', '            members[_to].isExists = true;\n', '            members[_to].isDividend = true;\n', '            members[_to].isWithdraw = true; \n', '            memberArray.push(_to);  \n', '        }\n', '        \n', '    }\n', ' \n', '\tfunction transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32)     {\n', '\t\trequire(_to != msg.sender);\n', '        require(isPayable);\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\t\n', '\t\tif(_to == deposit_address){\n', '\t\t    require(_value == shopStorePrice);\n', '\t\t    shopStoreNextId++;\n', '\t\t    shopStoreId[msg.sender] = shopStoreNextId;\n', '\t\t    shopStoreAddress[shopStoreNextId] = msg.sender;\n', '\t\t\n', '\t\t} else if(isLeading4FF(_to)){\n', '\t\t    uint256 to256 = uint256(_to);\n', '            uint32 expire = uint32(to256>>96);\n', '            uint32 storeid = uint24(to256>>72);\n', '            uint8 crc8 = uint8(to256);\n', '            require(uint32(now)<expire || expire==0);\n', '            \n', '            uint8 crc20 = uint8(sha256(uint152(to256>>8)));\n', '            require(crc20==crc8);\n', '            \n', '            _to = shopStoreAddress[uint(storeid)];\n', '            require(uint(_to)>0);\n', '\n', '            uint56 userdata = uint56(to256>>96);\n', '    \t\t\n', '    \t\tbalances[_to] = balances[_to].add(_value);\n', '    \t\tif (members[_to].isExists != true) {\t\t\n', '    \t\t\tmembers[_to].isExists = true;\n', '    \t\t\tmembers[_to].isDividend = true;\n', '    \t\t\tmembers[_to].isWithdraw = true; \n', '    \t\t\tmemberArray.push(_to);\t\t\n', '    \t\t}  \n', '\t\t\n', '\t\t} else { \n', '    \t\tbalances[_to] = balances[_to].add(_value);\n', '    \t\tif (members[_to].isExists != true) {\t\t\n', '    \t\t\tmembers[_to].isExists = true;\n', '    \t\t\tmembers[_to].isDividend = true;\n', '    \t\t\tmembers[_to].isWithdraw = true; \n', '    \t\t\tmemberArray.push(_to);\t\t\n', '    \t\t}  \n', '\n', '        }\n', '\n', '\t\tTransfer(msg.sender, _to, _value);\n', '\t}\n', '\t\n', '\tfunction transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32)     {\n', '\t\trequire(_to != deposit_address);\n', '\t\trequire(_from != deposit_address);\n', '        require(isPayable);\n', '\t\tvar _allowance = allowed[_from][msg.sender]; \n', '\t\trequire(_allowance >= _value);\n', '\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tbalances[_from] = balances[_from].sub(_value);\n', '\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\n', '\t\t\n', '\t\tif (members[_to].isExists != true) {\t\t\n', '\t\t\tmembers[_to].isExists = true;\n', '\t\t\tmembers[_to].isDividend = true;\n', '\t\t\tmembers[_to].isWithdraw = true; \n', '\t\t\tmemberArray.push(_to);\t\t\n', '\t\t}  \n', '\n', '\t\tTransfer(_from, _to, _value);\n', '\t}\n', '\n', '    function () payable {\n', '        \n', '        pay();\n', '        \n', '    }\n', '  \n', '    function pay() public payable  returns (bool) {\n', '        \n', '        require(!isLeading4FF(msg.sender));\n', '        require(msg.value > min_pay_wei);\n', '        require(isPayable);\n', '        \n', '        if(msg.sender == deposit_address){\n', '             deposit_amount += msg.value;\n', '        }else{\n', '            \n', '            if(isRequireData){\n', '                require(uint32(msg.data[0]) == uint32(0xFFFFFFFF));   \n', '            }\n', '        \n', '    \t\tuint256 exchangeWei = get_exchange_wei();\n', '    \t\tuint256 thisTokenWei = exchangeWei * msg.value / 10**18 ;\n', '    \t\t\n', '    \t\trequire(total_tokenwei <= totalSupply - thisTokenWei);\n', '        \n', '            if (members[msg.sender].isExists != true) {\n', '                \n', '                members[msg.sender].isExists = true;\n', '                members[msg.sender].isDividend = true;\n', '                members[msg.sender].isWithdraw = true; \n', '                memberArray.push(msg.sender);\n', '                \n', '            }  \n', '    \t\tbalances[msg.sender] += thisTokenWei;\n', '    \t\ttotal_tokenwei += thisTokenWei;\n', '    \t\t\n', '    \t\tPaydata(msg.sender, msg.value, msg.data, thisTokenWei);\n', '    \t\tTransfer(this, msg.sender, thisTokenWei);\n', '\t\t\n', '        }\n', '        \n', '        return true;\n', '    \n', '    }\n', '            \n', '    function get_this_balance() constant returns(uint256){\n', '      \n', '        return this.balance;\n', '      \n', '    }\n', '    \n', '}']
