['pragma solidity ^0.4.16;\n', '//User interface at http://www.staticoin.com\n', '//Full source code at https://github.com/genkifs/staticoin\n', '\n', '/** @title owned. */\n', 'contract owned  {\n', '  address owner;\n', '  function owned() {\n', '    owner = msg.sender;\n', '  }\n', '  function changeOwner(address newOwner) onlyOwner {\n', '    owner = newOwner;\n', '  }\n', '  modifier onlyOwner() {\n', '    if (msg.sender==owner) \n', '    _;\n', '  }\n', '}\n', '\n', '/** @title mortal. */\n', 'contract mortal is owned() {\n', '  function kill() onlyOwner {\n', '    if (msg.sender == owner) selfdestruct(owner);\n', '  }\n', '}\n', '\n', '/** @title DSMath. */\n', 'contract DSMath {\n', '\n', '\t// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n', '\n', '\t// Licensed under the Apache License, Version 2.0 (the "License").\n', '\t// You may not use this file except in compliance with the License.\n', '\n', '\t// Unless required by applicable law or agreed to in writing, software\n', '\t// distributed under the License is distributed on an "AS IS" BASIS,\n', '\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied).\n', '    \n', '\t// /*\n', '    // uint128 functions (h is for half)\n', '    //  */\n', '\n', '    function hmore(uint128 x, uint128 y) constant internal returns (bool) {\n', '        return x>y;\n', '    }\n', '\n', '    function hless(uint128 x, uint128 y) constant internal returns (bool) {\n', '        return x<y;\n', '    }\n', '\n', '    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        require(y == 0 ||(z = x * y)/ y == x);\n', '    }\n', '\n', '    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '\n', '    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    // /*\n', '    // int256 functions\n', '    //  */\n', '\n', '    /*\n', '    WAD math\n', '     */\n', '    uint64 constant WAD_Dec=18;\n', '    uint128 constant WAD = 10 ** 18;\n', '\n', '    function wmore(uint128 x, uint128 y) constant internal returns (bool) {\n', '        return hmore(x, y);\n', '    }\n', '\n', '    function wless(uint128 x, uint128 y) constant internal returns (bool) {\n', '        return hless(x, y);\n', '    }\n', '\n', '    function wadd(uint128 x, uint128 y) constant  returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function wsub(uint128 x, uint128 y) constant   returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function wmul(uint128 x, uint128 y) constant returns (uint128 z) {\n', '        z = cast((uint256(x) * y + WAD / 2) / WAD);\n', '    }\n', '\n', '    function wdiv(uint128 x, uint128 y) constant internal  returns (uint128 z) {\n', '        z = cast((uint256(x) * WAD + y / 2) / y);\n', '    }\n', '\n', '    function wmin(uint128 x, uint128 y) constant internal  returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '\n', '    function wmax(uint128 x, uint128 y) constant internal  returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    function cast(uint256 x) constant internal returns (uint128 z) {\n', '        assert((z = uint128(x)) == x);\n', '    }\n', '\t\n', '}\n', ' \n', '/** @title I_minter. */\n', 'contract I_minter { \n', '    event EventCreateStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \n', '    event EventRedeemStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \n', '    event EventCreateRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \n', '    event EventRedeemRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \n', '    event EventBankrupt();\n', '\n', '    function Leverage() constant returns (uint128)  {}\n', '    function RiskPrice(uint128 _currentPrice,uint128 _StaticTotal,uint128 _RiskTotal, uint128 _ETHTotal) constant returns (uint128 price)  {}\n', '    function RiskPrice(uint128 _currentPrice) constant returns (uint128 price)  {}     \n', '    function PriceReturn(uint _TransID,uint128 _Price) {}\n', '    function NewStatic() external payable returns (uint _TransID)  {}\n', '    function NewStaticAdr(address _Risk) external payable returns (uint _TransID)  {}\n', '    function NewRisk() external payable returns (uint _TransID)  {}\n', '    function NewRiskAdr(address _Risk) external payable returns (uint _TransID)  {}\n', '    function RetRisk(uint128 _Quantity) external payable returns (uint _TransID)  {}\n', '    function RetStatic(uint128 _Quantity) external payable returns (uint _TransID)  {}\n', '    function Strike() constant returns (uint128)  {}\n', '}\n', '\n', '/** @title I_Pricer. */\n', 'contract I_Pricer {\n', '    uint128 public lastPrice;\n', '    I_minter public mint;\n', '    string public sURL;\n', '    mapping (bytes32 => uint) RevTransaction;\n', '\n', '    function setMinter(address _newAddress) {}\n', '    function __callback(bytes32 myid, string result) {}\n', '    function queryCost() constant returns (uint128 _value) {}\n', '    function QuickPrice() payable {}\n', '    function requestPrice(uint _actionID) payable returns (uint _TrasID) {}\n', '    function collectFee() returns(bool) {}\n', '    function () {\n', '        //if ether is sent to this address, send it back.\n', '        revert();\n', '    }\n', '}\n', '\n', '/** @title I_coin. */\n', 'contract I_coin is mortal {\n', '\n', '    event EventClear();\n', '\n', '\tI_minter public mint;\n', '    string public name;                   //fancy name: eg Simon Bucks\n', "    uint8 public decimals=18;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n", '    string public symbol;                 //An identifier: eg SBX\n', "    string public version = '';       //human 0.1 standard. Just an arbitrary versioning scheme.\n", '\t\n', '    function mintCoin(address target, uint256 mintedAmount) returns (bool success) {}\n', '    function meltCoin(address target, uint256 meltedAmount) returns (bool success) {}\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData){}\n', '\n', '    function setMinter(address _minter) {}   \n', '\tfunction increaseApproval (address _spender, uint256 _addedValue) returns (bool success) {}    \n', '\tfunction decreaseApproval (address _spender, uint256 _subtractedValue) \treturns (bool success) {} \n', '\n', '    // @param _owner The address from which the balance will be retrieved\n', '    // @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {}    \n', '\n', '\n', '    // @notice send `_value` token to `_to` from `msg.sender`\n', '    // @param _to The address of the recipient\n', '    // @param _value The amount of token to be transferred\n', '    // @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success) {}\n', '\n', '\n', '    // @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    // @param _from The address of the sender\n', '    // @param _to The address of the recipient\n', '    // @param _value The amount of token to be transferred\n', '    // @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '\n', '    // @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    // @param _spender The address of the account able to transfer the tokens\n', '    // @param _value The amount of wei to be approved for transfer\n', '    // @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\t\n', '\t// @param _owner The address of the account owning tokens\n', '    // @param _spender The address of the account able to transfer the tokens\n', '    // @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\t\n', '\tmapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\t// @return total amount of tokens\n', '    uint256 public totalSupply;\n', '}\n', '\n', '/** @title DSBaseActor. */\n', 'contract DSBaseActor {\n', '   /*\n', '   Copyright 2016 Nexus Development, LLC\n', '\n', '   Licensed under the Apache License, Version 2.0 (the "License");\n', '   you may not use this file except in compliance with the License.\n', '   You may obtain a copy of the License at\n', '\n', '       http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '   Unless required by applicable law or agreed to in writing, software\n', '   distributed under the License is distributed on an "AS IS" BASIS,\n', '   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '   See the License for the specific language governing permissions and\n', '   limitations under the License.\n', '   */\n', '\n', '    bool _ds_mutex;\n', '    modifier mutex() {\n', '        assert(!_ds_mutex);\n', '        _ds_mutex = true;\n', '        _;\n', '        _ds_mutex = false;\n', '    }\n', '\t\n', '    function tryExec( address target, bytes calldata, uint256 value)\n', '\t\t\tmutex()\n', '            internal\n', '            returns (bool call_ret)\n', '    {\n', '\t\t/** @dev Requests new StatiCoins be made for a given address\n', '          * @param target where the ETH is sent to.\n', '          * @param calldata\n', '          * @param value\n', '          * @return True if ETH is transfered\n', '        */\n', '        return target.call.value(value)(calldata);\n', '    }\n', '\t\n', '    function exec( address target, bytes calldata, uint256 value)\n', '             internal\n', '    {\n', '        assert(tryExec(target, calldata, value));\n', '    }\n', '}\n', '\n', '/** @title canFreeze. */\n', 'contract canFreeze is owned { \n', '\t//Copyright (c) 2017 GenkiFS\n', '\t//Basically a "break glass in case of emergency"\n', '    bool public frozen=false;\n', '    modifier LockIfFrozen() {\n', '        if (!frozen){\n', '            _;\n', '        }\n', '    }\n', '    function Freeze() onlyOwner {\n', '        // fixes the price and allows everyone to redeem their coins at the current value\n', '\t\t// only becomes false when all ETH has been claimed or the pricer contract is changed\n', '        frozen=true;\n', '    }\n', '}\n', '\n', '/** @title oneWrite. */\n', 'contract oneWrite {  \n', '\t//  Adds modifies that allow one function to be called only once\n', '\t//Copyright (c) 2017 GenkiFS\n', '  bool written = false;\n', '  function oneWrite() {\n', '\t/** @dev Constuctor, make sure written=false initally\n', '\t*/\n', '    written = false;\n', '  }\n', '  modifier LockIfUnwritten() {\n', '    if (written){\n', '        _;\n', '    }\n', '  }\n', '  modifier writeOnce() {\n', '    if (!written){\n', '        written=true;\n', '        _;\n', '    }\n', '  }\n', '}\n', '\n', '/** @title pricerControl. */\n', 'contract pricerControl is canFreeze {\n', '\t//  Copyright (c) 2017 GenkiFS\n', '\t//  Controls the Pricer contract for minter.  Allows updates to be made in the future by swapping the pricer contract\n', "\t//  Although this is not expected, web addresses, API's, new oracles could require adjusments to the pricer contract\n", '\t//  A delay of 2 days is implemented to allow coinholders to redeem their coins if they do not agree with the new contract\n', '\t//  A new pricer contract unfreezes the minter (allowing a live price to be used)\n', '    I_Pricer public pricer;\n', '    address public future;\n', '    uint256 public releaseTime;\n', '    uint public PRICER_DELAY = 2; // days updated when coins are set\n', '    event EventAddressChange(address indexed _from, address indexed _to, uint _timeChange);\n', '\n', '    function setPricer(address newAddress) onlyOwner {\n', '\t\t/** @dev Changes the Pricer contract, after a certain delay\n', '          * @param newAddress Allows coins to be created and sent to other people\n', '          * @return transaction ID which can be viewed in the pending mapping\n', '        */\n', '        releaseTime = now + PRICER_DELAY;\n', '        future = newAddress;\n', '        EventAddressChange(pricer, future, releaseTime);\n', '    }  \n', '\n', '    modifier updates() {\n', '        if (now > releaseTime  && pricer != future){\n', '            update();\n', "            //log0('Updating');\n", '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyPricer() {\n', '      if (msg.sender==address(pricer))\n', '      _;\n', '    }\n', '\n', '    function update() internal {\n', '        pricer =  I_Pricer(future);\n', '\t\tfrozen = false;\n', '    }\n', '}\n', '\n', '/** @title minter. */\t\n', 'contract minter is I_minter, DSBaseActor, oneWrite, pricerControl, DSMath{ //\n', '\t// Copyright (c) 2017 GenkiFS\n', '\t// This contract is the controller for the StatiCoin contracts.  \n', '\t// Users have 4(+2) functions they can call to mint/melt Static/Risk coins which then calls the Pricer contract\n', '\t// after a delay the Pricer contract will call back to the PriceReturn() function\n', '\t// this will then call one of the functions ActionNewStatic, ActionNewRisk, ActionRetStatic, ActionRetRisk\n', '\t// which will then call the Static or Risk ERC20 contracts to mint/melt new tokens\n', '\t// Transfer of tokens is handled by the ERC20 contracts, ETH is stored here.  \n', '    enum Action {NewStatic, RetStatic, NewRisk, RetRisk} // Enum of what users can do\n', '    struct Trans { // Struct\n', '        uint128 amount; // Amount sent by the user (Can be either ETH or number of returned coins)\n', '        address holder; // Address of the user\n', '        Action action;  // Type of action requested (mint/melt a Risk/StatiCoin)\n', '\t\tuint pricerID;  // ID for the pricer function\n', '    }\n', '    uint128 public lastPrice; //Storage of the last price returned by the Pricer contract\n', '    uint public TransID=0; // An increasing counter to keep track of transactions requested\n', '    string public Currency; // Name of underlying base currency\n', '    I_coin public Static;  // ERC20 token interface for the StatiCoin\n', '    I_coin public Risk;  // ERC20 token interface for the Risk coin\n', '    uint128 public Multiplier;//=15*10**(17); // default ratio for Risk price\n', '    uint128 public levToll=5*10**(18-1);//0.5  // this plus the multiplier defines the maximum leverage\n', '    uint128 public mintFee = 2*10**(18-3); //0.002 Used to pay oricalize and for marketing contract which is in both parties interest.\n', '    mapping (uint => Trans[]) public pending; // A mapping of pending transactions\n', '\n', '    event EventCreateStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \n', '    event EventRedeemStatic(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \n', '    event EventCreateRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \n', '    event EventRedeemRisk(address indexed _from, uint128 _value, uint _transactionID, uint _Price); \n', '    event EventBankrupt();\t//Called when no more ETH is in the contract and everything needs to be manually reset.  \n', '\t\n', '\tfunction minter(string _currency, uint128 _Multiplier) { //,uint8 _DecimalPlaces\n', '        // CONSTRUCTOR  \n', '        Currency=_currency;\n', '        Multiplier = _Multiplier;\n', "        // can't add new contracts here as it gives out of gas messages.  Too much code.\n", '    }\t\n', '\n', '\tfunction () {\n', "        //if ETH is just sent to this address then we cannot determine if it's for StatiCoins or RiskCoins, so send it back.\n", '        revert();\n', '    }\n', '\n', '\tfunction Bailout() \n', '\t\t\texternal \n', '\t\t\tpayable \n', '\t\t\t{\n', '        /** @dev Allows extra ETH to be added to the benefit of both types of coin holders\n', '          * @return nothing\n', '        */\n', '    }\n', '\t\t\n', '    function NewStatic() \n', '\t\t\texternal \n', '\t\t\tpayable \n', '\t\t\treturns (uint _TransID) {\n', '        /** @dev Requests new StatiCoins be made for the sender.  \n', '\t\t  * This cannot be called by a contract.  Only a simple wallet (with 0 codesize).\n', '\t\t  * Contracts must use the Approve, transferFrom pattern and move coins from wallets\n', '          * @return transaction ID which can be viewed in the pending mapping\n', '        */\n', '\t\t_TransID=NewCoinInternal(msg.sender,cast(msg.value),Action.NewStatic);\n', "\t\t//log0('NewStatic');\n", '    }\n', '\t\n', '    function NewStaticAdr(address _user) \n', '\t\t\texternal \n', '\t\t\tpayable \n', '\t\t\treturns (uint _TransID)  {  \n', '        /** @dev Requests new StatiCoins be made for a given address.  \n', '\t\t  * The address cannot be a contract, only a simple wallet (with 0 codesize).\n', '\t\t  * Contracts must use the Approve, transferFrom pattern and move coins from wallets\n', '          * @param _user Allows coins to be created and sent to other people\n', '          * @return transaction ID which can be viewed in the pending mapping\n', '        */\n', '\t\t_TransID=NewCoinInternal(_user,cast(msg.value),Action.NewStatic);\n', "\t\t//log0('NewStatic');\n", '    }\n', '\t\n', '    function NewRisk() \n', '\t\t\texternal \n', '\t\t\tpayable \n', '\t\t\treturns (uint _TransID)  {\n', '        /** @dev Requests new Riskcoins be made for the sender.  \n', '\t\t  * This cannot be called by a contract, only a simple wallet (with 0 codesize).\n', '\t\t  * Contracts must use the Approve, transferFrom pattern and move coins from wallets\n', '          * @return transaction ID which can be viewed in the pending mapping\n', '          */\n', '\t\t_TransID=NewCoinInternal(msg.sender,cast(msg.value),Action.NewRisk);\n', "        //log0('NewRisk');\n", '    }\n', '\n', '    function NewRiskAdr(address _user) \n', '\t\t\texternal \n', '\t\t\tpayable \n', '\t\t\treturns (uint _TransID)  {\n', '        /** @dev Requests new Riskcoins be made for a given address.  \n', '\t\t  * The address cannot be a contract, only a simple wallet (with 0 codesize).\n', '\t\t  * Contracts must use the Approve, transferFrom pattern and move coins from wallets\n', '          * @param _user Allows coins to be created and sent to other people\n', '          * @return transaction ID which can be viewed in the pending mapping\n', '          */\n', '\t\t_TransID=NewCoinInternal(_user,cast(msg.value),Action.NewRisk);\n', "        //log0('NewRisk');\n", '    }\n', '\n', '    function RetRisk(uint128 _Quantity) \n', '\t\t\texternal \n', '\t\t\tpayable \n', '\t\t\tLockIfUnwritten  \n', '\t\t\treturns (uint _TransID)  {\n', '        /** @dev Returns Riskcoins.  Needs a bit of eth sent to pay the pricer contract and the excess is returned.  \n', '\t\t  * The address cannot be a contract, only a simple wallet (with 0 codesize).\n', '          * @param _Quantity Amount of coins being returned\n', '\t\t  * @return transaction ID which can be viewed in the pending mapping\n', '        */\n', '        if(frozen){\n', '            //Skip the pricer contract\n', '            TransID++;\n', '\t\t\tActionRetRisk(Trans(_Quantity,msg.sender,Action.RetRisk,0),TransID,lastPrice);\n', '\t\t\t_TransID=TransID;\n', '        } else {\n', '            //Only returned when Risk price is positive\n', '\t\t\t_TransID=RetCoinInternal(_Quantity,cast(msg.value),msg.sender,Action.RetRisk);\n', '        }\n', "\t\t//log0('RetRisk');\n", '    }\n', '\n', '    function RetStatic(uint128 _Quantity) \n', '\t\t\texternal \n', '\t\t\tpayable \n', '\t\t\tLockIfUnwritten  \n', '\t\t\treturns (uint _TransID)  {\n', '        /** @dev Returns StatiCoins,  Needs a bit of eth sent to pay the pricer contract\n', '          * @param _Quantity Amount of coins being returned\n', '\t\t  * @return transaction ID which can be viewed in the pending mapping\n', '        */\n', '        if(frozen){\n', '            //Skip the pricer contract\n', '\t\t\tTransID++;\n', '            ActionRetStatic(Trans(_Quantity,msg.sender,Action.RetStatic,0),TransID,lastPrice);\n', '\t\t\t_TransID=TransID;\n', '        } else {\n', '            //Static can be returned at any time\n', '\t\t\t_TransID=RetCoinInternal(_Quantity,cast(msg.value),msg.sender,Action.RetStatic);\n', '        }\n', "\t\t//log0('RetStatic');\n", '    }\n', '\t\n', '\t//****************************//\n', "\t// Constant functions (Ones that don't write to the blockchain)\n", '    function StaticEthAvailable() \n', '\t\t\tconstant \n', '\t\t\treturns (uint128)  {\n', '\t\t/** @dev Returns the total amount of eth that can be sent to buy StatiCoins\n', '\t\t  * @return amount of Eth\n', '        */\n', '\t\treturn StaticEthAvailable(cast(Risk.totalSupply()), cast(this.balance));\n', '    }\n', '\n', '\tfunction StaticEthAvailable(uint128 _RiskTotal, uint128 _TotalETH) \n', '\t\t\tconstant \n', '\t\t\treturns (uint128)  {\n', '\t\t/** @dev Returns the total amount of eth that can be sent to buy StatiCoins allows users to test arbitrary amounts of RiskTotal and ETH contained in the contract\n', '\t\t  * @param _RiskTotal Quantity of \n', '          * @param  _TotalETH Total value of ETH in the contract\n', '\t\t  * @return amount of Eth\n', '        */\n', '\t\t// (Multiplier+levToll)*_RiskTotal - _TotalETH\n', '\t\tuint128 temp = wmul(wadd(Multiplier,levToll),_RiskTotal);\n', '\t\tif(wless(_TotalETH,temp)){\n', '\t\t\treturn wsub(temp ,_TotalETH);\n', '\t\t} else {\n', '\t\t\treturn 0;\n', '\t\t}\n', '    }\n', '\n', '\tfunction RiskPrice(uint128 _currentPrice,uint128 _StaticTotal,uint128 _RiskTotal, uint128 _ETHTotal) \n', '\t\t\tconstant \n', '\t\t\treturns (uint128 price)  {\n', '\t    /** @dev Allows users to query various hypothetical prices of RiskCoins in terms of base currency\n', '          * @param _currentPrice Current price of ETH in Base currency.\n', '          * @param _StaticTotal Total quantity of StatiCoins issued.\n', '          * @param _RiskTotal Total quantity of invetor coins issued.\n', '          * @param _ETHTotal Total quantity of ETH in the contract.\n', '          * @return price of RiskCoins \n', '        */\n', '        if(_ETHTotal == 0 || _RiskTotal==0){\n', '\t\t\t//Return the default price of _currentPrice * Multiplier\n', '            return wmul( _currentPrice , Multiplier); \n', '        } else {\n', '            if(hmore( wmul(_ETHTotal , _currentPrice),_StaticTotal)){ //_ETHTotal*_currentPrice>_StaticTotal\n', '\t\t\t\t//Risk price is positive\n', '                return wdiv(wsub(wmul(_ETHTotal , _currentPrice) , _StaticTotal) , _RiskTotal); // (_ETHTotal * _currentPrice) - _StaticTotal) / _RiskTotal\n', '            } else  {\n', '\t\t\t\t//RiskPrice is negative\n', '                return 0;\n', '            }\n', '        }       \n', '    }\n', '\n', '    function RiskPrice() \n', '\t\t\tconstant \n', '\t\t\treturns (uint128 price)  {\n', '\t    /** @dev Allows users to query the last price of RiskCoins in terms of base currency\n', '        *   @return price of RiskCoins \n', '        */\n', '        return RiskPrice(lastPrice);\n', '    }     \t\n', '\t\n', '    function RiskPrice(uint128 _currentPrice) \n', '\t\t\tconstant \n', '\t\t\treturns (uint128 price)  {\n', '\t    /** @dev Allows users to query price of RiskCoins in terms of base currency, using current quantities of coins\n', '          * @param _currentPrice Current price of ETH in Base currency.\n', '\t      * @return price of RiskCoins \n', '        */\n', '        return RiskPrice(_currentPrice,cast(Static.totalSupply()),cast(Risk.totalSupply()),cast(this.balance));\n', '    }     \n', '\n', '\tfunction Leverage() public \n', '\t\t\tconstant \n', '\t\t\treturns (uint128)  {\n', '\t\t/** @dev Returns the ratio at which Riskcoin grows in value for the equivalent growth in ETH price\n', '\t\t* @return ratio\n', '        */\n', '        if(Risk.totalSupply()>0){\n', '            return wdiv(cast(this.balance) , cast(Risk.totalSupply())); //  this.balance/Risk.totalSupply\n', '        }else{\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function Strike() public \n', '\t\t\tconstant \n', '\t\t\treturns (uint128)  {\n', '\t\t/** @dev Returns the current price at which the Risk price goes negative\n', '\t\t* @return Risk price in underlying per ETH\n', '        */ \n', '        if(this.balance>0){\n', '            return wdiv(cast(Static.totalSupply()) , cast(this.balance)); //Static.totalSupply / this.balance\n', '        }else{\n', '            return 0;            \n', '        }\n', '    }\n', '\n', '\t//****************************//\n', '\t// Only owner can access the following functions\n', '    function setFee(uint128 _newFee) \n', '\t\t\tonlyOwner {\n', '        /** @dev Allows the minting fee to be changed, only owner can modify\n', '\t\t  * Fee is only charged on coin creation\n', '          * @param _newFee Size of new fee\n', '          * return nothing \n', '        */\n', '        mintFee=_newFee;\n', '    }\n', '\n', '    function setCoins(address newRisk,address newStatic) \n', '\t\t\tupdates \n', '\t\t\tonlyOwner \n', '\t\t\twriteOnce {\n', '        /** @dev only owner can modify once, Triggers the pricer to be updated \n', '          * @param newRisk Address of Riskcoin contract\n', '          * @param newStatic Address of StatiCoin contract\n', '          * return nothing \n', '        */\n', '        Risk=I_coin(newRisk);\n', '        Static=I_coin(newStatic);\n', '\t\tPRICER_DELAY = 2 days;\n', '    }\n', '\t\n', '\t//****************************//\t\n', '\t// Only Pricer can access the following function\n', '    function PriceReturn(uint _TransID,uint128 _Price) \n', '\t\t\tonlyPricer {\n', '\t    /** @dev Return function for the Pricer contract only.  Controls melting and minting of new coins.\n', '          * @param _TransID Tranasction ID issued by the minter.\n', '          * @param _Price Quantity of Base currency per ETH delivered by the Pricer contract\n', '          * Nothing returned.  One of 4 functions is implemented\n', '        */\n', '\t    Trans memory details=pending[_TransID][0];//Get the details for this transaction. \n', '        if(0==_Price||frozen){ //If there is an error in pricing or contract is frozen, use the old price\n', '            _Price=lastPrice;\n', '        } else {\n', '\t\t\tif(Static.totalSupply()>0 && Risk.totalSupply()>0) {// dont update if there are coins missing\n', '\t\t\t\tlastPrice=_Price; // otherwise update the last price\n', '\t\t\t}\n', '        }\n', '\t\t//Mint some new StatiCoins\n', '        if(Action.NewStatic==details.action){\n', '            ActionNewStatic(details,_TransID, _Price);\n', '        }\n', '\t\t//Melt some old StatiCoins\n', '        if(Action.RetStatic==details.action){\n', '            ActionRetStatic(details,_TransID, _Price);\n', '        }\n', '\t\t//Mint some new Riskcoins\n', '        if(Action.NewRisk==details.action){\n', '            ActionNewRisk(details,_TransID, _Price);\n', '        }\n', '\t\t//Melt some old Riskcoins\n', '        if(Action.RetRisk==details.action){\n', '            ActionRetRisk(details,_TransID, _Price);\n', '        }\n', '\t\t//Remove the transaction from the blockchain (saving some gas)\n', '\t\tdelete pending[_TransID];\n', '    }\n', '\t\n', '\t//****************************//\n', '    // Only internal functions now\n', '    function ActionNewStatic(Trans _details, uint _TransID, uint128 _Price) \n', '\t\t\tinternal {\n', '\t\t/** @dev Internal function to create new StatiCoins based on transaction data in the Pending queue.  If not enough spare StatiCoins are available then some ETH is refunded.\n', '          * @param _details Structure holding the amount sent (in ETH), the address of the person to sent to, and the type of request.\n', '          * @param _TransID ID of the transaction (as stored in this contract).\n', '          * @param _Price Current 24 hour average price as returned by the oracle in the pricer contract.\n', '          * @return function returns nothing, but adds StatiCoins to the users address and events are created\n', '        */\n', "\t\t//log0('NewStatic');\n", '            \n', '            //if(Action.NewStatic<>_details.action){revert();}  //already checked\n', '\t\t\t\n', '\t\t\tuint128 CurRiskPrice=RiskPrice(_Price);\n', '\t\t\tuint128 AmountReturn;\n', '\t\t\tuint128 AmountMint;\n', '\t\t\t\n', '\t\t\t//Calculates the amount of ETH that can be added to create StatiCoins (excluding the amount already sent and stored in the contract)\n', '\t\t\tuint128 StaticAvail = StaticEthAvailable(cast(Risk.totalSupply()), wsub(cast(this.balance),_details.amount)); \n', '\t\t\t\t\t\t\n', '\t\t\t// If the amount sent is less than the Static amount available, everything is fine.  Nothing needs to be returned.  \n', '\t\t\tif (wless(_details.amount,StaticAvail)) {\n', '\t\t\t\t// restrictions do not hamper the creation of a StatiCoin\n', '\t\t\t\tAmountMint = _details.amount;\n', '\t\t\t\tAmountReturn = 0;\n', '\t\t\t} else {\n', '\t\t\t\t// Amount of Static is less than amount requested.  \n', '\t\t\t\t// Take all the StatiCoins available.\n', '\t\t\t\t// Maybe there is zero Static available, so all will be returned.\n', '\t\t\t\tAmountMint = StaticAvail;\n', '\t\t\t\tAmountReturn = wsub(_details.amount , StaticAvail) ;\n', '\t\t\t}\t\n', '\t\t\t\n', '\t\t\tif(0 == CurRiskPrice){\n', '\t\t\t\t// return all the ETH\n', '\t\t\t\tAmountReturn = _details.amount;\n', '\t\t\t\t//AmountMint = 0; //not required as Risk price = 0\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\t//Static can be added when Risk price is positive and leverage is below the limit\n', '            if(CurRiskPrice > 0  && StaticAvail>0 ){\n', '                // Dont create if CurRiskPrice is 0 or there is no Static available (leverage is too high)\n', "\t\t\t\t//log0('leverageOK');\n", '                Static.mintCoin(_details.holder, uint256(wmul(AmountMint , _Price))); //request coins from the Static creator contract\n', '                EventCreateStatic(_details.holder, wmul(AmountMint , _Price), _TransID, _Price); // Event giving the holder address, coins created, transaction id, and price \n', '            } \n', '\n', '\t\t\tif (AmountReturn>0) {\n', '                // return some money because not enough StatiCoins are available\n', '\t\t\t\tbytes memory calldata; // define a blank `bytes`\n', '                exec(_details.holder,calldata, AmountReturn);  //Refund ETH from this contract\n', '\t\t\t}\t\n', '    }\n', '\n', '    function ActionNewRisk(Trans _details, uint _TransID,uint128 _Price) \n', '\t\t\tinternal {\n', '\t\t/** @dev Internal function to create new Risk coins based on transaction data in the Pending queue.  Risk coins can only be created if the price is above zero\n', '          * @param _details Structure holding the amount sent (in ETH), the address of the person to sent to, and the type of request.\n', '          * @param _TransID ID of the transaction (as stored in this contract).\n', '          * @param _Price Current 24 hour average price as returned by the oracle in the pricer contract.\n', '          * @return function returns nothing, but adds Riskcoins to the users address and events are created\n', '        */\n', "        //log0('NewRisk');\n", '        //if(Action.NewRisk<>_details.action){revert();}  //already checked\n', '\t\t// Get the Risk price using the amount of ETH in the contract before this transaction existed\n', '\t\tuint128 CurRiskPrice;\n', '\t\tif(wless(cast(this.balance),_details.amount)){\n', '\t\t\tCurRiskPrice=RiskPrice(_Price,cast(Static.totalSupply()),cast(Risk.totalSupply()),0);\n', '\t\t} else {\n', '\t\t\tCurRiskPrice=RiskPrice(_Price,cast(Static.totalSupply()),cast(Risk.totalSupply()),wsub(cast(this.balance),_details.amount));\n', '\t\t}\n', '        if(CurRiskPrice>0){\n', '            uint128 quantity=wdiv(wmul(_details.amount , _Price),CurRiskPrice);  // No of Riskcoins =  _details.amount * _Price / CurRiskPrice\n', '            Risk.mintCoin(_details.holder, uint256(quantity) );  //request coins from the Riskcoin creator contract\n', '            EventCreateRisk(_details.holder, quantity, _TransID, _Price); // Event giving the holder address, coins created, transaction id, and price \n', '        } else {\n', "            // Don't create if CurRiskPrice is 0, Return all the ETH originally sent\n", '            bytes memory calldata; // define a blank `bytes`\n', '            exec(_details.holder,calldata, _details.amount);\n', '        }\n', '    }\n', '\n', '    function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) \n', '\t\t\tinternal {\n', '\t\t/** @dev Internal function to Return StatiCoins based on transaction data in the Pending queue.  Static can be returned at any time.\n', '          * @param _details Structure holding the amount sent (in ETH), the address of the person to sent to, and the type of request.\n', '          * @param _TransID ID of the transaction (as stored in this contract).\n', '          * @param _Price Current 24 hour average price as returned by the oracle in the pricer contract.\n', "          * @return function returns nothing, but removes StatiCoins from the user's address, sends ETH and events are created\n", '        */\n', '\t\t//if(Action.RetStatic<>_details.action){revert();}  //already checked\n', "\t\t//log0('RetStatic');\n", '\t\tuint128 _ETHReturned;\n', '\t\tif(0==Risk.totalSupply()){_Price=lastPrice;} //No Risk coins for balance so use fixed price\n', '        _ETHReturned = wdiv(_details.amount , _Price); //_details.amount / _Price\n', '        if (Static.meltCoin(_details.holder,_details.amount)){\n', '            // deducted first, will add back if Returning ETH goes wrong.\n', '            EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);\n', '            if (wless(cast(this.balance),_ETHReturned)) {\n', '                 _ETHReturned=cast(this.balance);//Not enough ETH available.  Return all Eth in the contract\n', '            }\n', '\t\t\tbytes memory calldata; // define a blank `bytes`\n', '            if (tryExec(_details.holder, calldata, _ETHReturned)) { \n', '\t\t\t\t//ETH returned successfully\n', '\t\t\t} else {\n', '\t\t\t\t// there was an error, so add back the amount previously deducted\n', '\t\t\t\tStatic.mintCoin(_details.holder,_details.amount); //Add back the amount requested\n', '\t\t\t\tEventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);  //redo the creation event\n', '\t\t\t}\n', '\t\t\tif ( 0==this.balance) {\n', '\t\t\t\tBankrupt();\n', '\t\t\t}\n', '        }        \n', '    }\n', '\n', '    function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) \n', '\t\t\tinternal {\n', '\t\t/** @dev Internal function to Return Riskcoins based on transaction data in the Pending queue.  Riskcoins can be returned so long as the Risk price is greater than 0.\n', '          * @param _details Structure holding the amount sent (in ETH), the address of the person to sent to, and the type of request.\n', '          * @param _TransID ID of the transaction (as stored in this contract).\n', '          * @param _Price Current 24 hour average price as returned by the oracle in the Pricer contract.\n', '          * @return function returns nothing, but removes RiskCoins from the users address, sends ETH and events are created\n', '        */        \n', '\t\t//if(Action.RetRisk<>_details.action){revert();}  //already checked\n', "\t\t//log0('RetRisk');\n", '        uint128 _ETHReturned;\n', '\t\tuint128 CurRiskPrice;\n', '\t\t// no StatiCoins, so all Risk coins are worth the same, so _ETHReturned = _details.amount / _RiskTotal * _ETHTotal\n', '\t\tCurRiskPrice=RiskPrice(_Price);\n', '        if(CurRiskPrice>0){\n', '            _ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price); // _details.amount * CurRiskPrice / _Price\n', '            if (Risk.meltCoin(_details.holder,_details.amount )){\n', '                // Coins are deducted first, will add back if returning ETH goes wrong.\n', '                EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);\n', '                if ( wless(cast(this.balance),_ETHReturned)) { // should never happen, but just in case\n', '                     _ETHReturned=cast(this.balance);\n', '                }\n', '\t\t\t\tbytes memory calldata; // define a blank `bytes`\n', '                if (tryExec(_details.holder, calldata, _ETHReturned)) { \n', '\t\t\t\t\t//Returning ETH went ok.  \n', '                } else {\n', '                    // there was an error, so add back the amount previously deducted from the Riskcoin contract\n', '                    Risk.mintCoin(_details.holder,_details.amount);\n', '                    EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);\n', '                }\n', '            } \n', '        }  else {\n', "            // Risk price is zero so can't do anything.  Call back and delete the transaction from the contract\n", '        }\n', '    }\n', '\n', '\tfunction IsWallet(address _address) \n', '\t\t\tinternal \n', '\t\t\treturns(bool){\n', '\t\t/**\n', '\t\t* @dev checks that _address is not a contract.  \n', '\t\t* @param _address to check \n', '\t\t* @return True if not a contract, \n', '\t\t*/\t\t\n', '\t\tuint codeLength;\n', '\t\tassembly {\n', '            // Retrieve the size of the code on target address, this needs assembly .\n', '            codeLength := extcodesize(_address)\n', '        }\n', '\t\treturn(0==codeLength);\t\t\n', '    } \n', '\n', '\tfunction RetCoinInternal(uint128 _Quantity, uint128 _AmountETH, address _user, Action _action) \n', '\t\t\tinternal \n', '\t\t\tupdates \n', '\t\t\treturns (uint _TransID)  {\n', '        /** @dev Requests coins be melted and ETH returned\n', '\t\t  * @param _Quantity of Static or Risk coins to be melted\n', '\t\t  * @param _AmountETH Amount of ETH sent to this contract to cover oracle fee.  Excess is returned.\n', '          * @param _user Address to whom the returned ETH will be sent.\n', '\t\t  * @param _action Allows Static or Risk coins to be returned\n', '\t\t  * @return transaction ID which can be viewed in the Pending mapping\n', '        */\n', '\t\trequire(IsWallet(_user));\n', '\t\tuint128 refund;\n', '        uint128 Fee=pricer.queryCost();  //Get the cost of querying the pricer contract\n', '\t\tif(wless(_AmountETH,Fee)){\n', "\t\t\trevert();  //log0('Not enough ETH to mint');\n", '\t\t\t} else {\n', '\t\t\trefund=wsub(_AmountETH,Fee);//Returning coins has had too much ETH sent, so return it.\n', '\t\t}\n', '\t\tif(0==_Quantity){revert();}// quantity has to be non zero\n', '\t\tTransID++;\n', '        \n', '        uint PricerID = pricer.requestPrice.value(uint256(Fee))(TransID);  //Ask the pricer to get the price.  The Fee also cover calling the function PriceReturn at a later time.\n', '\t\tpending[TransID].push(Trans(_Quantity,_user,_action,PricerID));  //Add a transaction to the Pending queue.\n', '        _TransID=TransID;  //return the transaction ID to the user \n', '        _user.transfer(uint256(refund)); //Return ETH if too much has been sent to cover the pricer\n', '    }\n', '\t\t\n', '\tfunction NewCoinInternal(address _user, uint128 _amount, Action _action) \n', '\t\t\tinternal \n', '\t\t\tupdates \n', '\t\t\tLockIfUnwritten \n', '\t\t\tLockIfFrozen  \n', '\t\t\treturns (uint _TransID)  {\n', '\t\t/** @dev Requests new coins be made\n', '          * @param _user Address for whom the coins are to be created\n', '          * @param _amount Amount of eth sent to this contract\n', '\t\t  * @param _action Allows Static or Risk coins to be minted\n', '\t\t  * @return transaction ID which can be viewed in the pending mapping\n', '        */\n', '\t\trequire(IsWallet(_user));\n', '        uint128 Fee=wmax(wmul(_amount,mintFee),pricer.queryCost()); // fee is the maxium of the pricer query cost and a mintFee% of value sent\n', "        if(wless(_amount,Fee)) revert(); //log0('Not enough ETH to mint');\n", '\t\tTransID++;\n', '        uint PricerID = pricer.requestPrice.value(uint256(Fee))(TransID); //Ask the pricer to return the price\n', '\t\tpending[TransID].push(Trans(wsub(_amount,Fee),_user,_action,PricerID)); //Store the transaction ID and data ready for later recall\n', '        _TransID=TransID;//return the transaction ID for this contract to the user \t\t\n', '\t} \n', '\n', '    function Bankrupt() \n', '\t\t\tinternal {\n', '\t\t\tEventBankrupt();\n', '\t\t\t// Reset the contract\n', '\t\t\tStatic.kill();  //delete all current Static tokens\n', '\t\t\tRisk.kill();  //delete all current Risk tokens\n', '\t\t\t//need to create new coins externally, too much gas is used if done here.  \n', '\t\t\tfrozen=false;\n', '\t\t\twritten=false;  // Reset the writeOnce and LockIfUnwritten modifiers\n', '    }\n', '}']