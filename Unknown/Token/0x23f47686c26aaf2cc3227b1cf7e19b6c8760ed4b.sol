['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title ETHCON Early Bird Donation Contract\n', ' * @author majoolr.io\n', ' *\n', ' * Accepts donations and issues ETHCON token if at or above 3.9604 ETH.\n', ' * See ETHCON.org for further information.\n', ' * ETHCONEarlyBirdToken contract at 0x2d9498d0fd6f40760d53a847eb64eaf51c9b8e74\n', ' */\n', '\n', 'contract ETHCONEarlyBirdDonation {\n', '  address majoolr;\n', '  ETHCONEarlyBirdToken token;\n', '\n', '  uint256 public donations;\n', '  mapping (address => uint256) public donationMap;\n', '  mapping (address => uint256) public failedDonations;\n', '  uint256 public minimum = 3960400000000000000;\n', '\n', '  event ErrMsg(address indexed _from, string _msg);\n', '  event ThxMsg(address indexed _from, string _msg);\n', '\n', '  modifier andIsMajoolr {\n', '    require(msg.sender == majoolr);\n', '    _;\n', '  }\n', '\n', '  function(){ ErrMsg(msg.sender, &#39;No function called&#39;); }\n', '\n', '  function ETHCONEarlyBirdDonation(address _token){\n', '    token = ETHCONEarlyBirdToken(_token);\n', '    majoolr = msg.sender;\n', '  }\n', '\n', '  function donate() payable returns (bool){\n', '    uint256 totalDonation = donationMap[msg.sender] + msg.value;\n', '    if(totalDonation < minimum){\n', '      failedDonations[msg.sender] += msg.value;\n', '      ErrMsg(msg.sender, "Donation too low, call withdrawDonation()");\n', '      return false;\n', '    }\n', '\n', '    bool success = token.transferFrom(majoolr,msg.sender,1);\n', '    if(!success){\n', '      failedDonations[msg.sender] += msg.value;\n', '      ErrMsg(msg.sender, "Transer failed, call withdrawDonation()");\n', '      return false;\n', '    }\n', '\n', '    donationMap[msg.sender] += msg.value;\n', '    donations += msg.value;\n', '    ThxMsg(msg.sender, "Thank you for your donation!");\n', '    return true;\n', '  }\n', '\n', '  function generousDonation() payable returns (bool){\n', '    uint256 tokensLeft = token.allowance(majoolr, this);\n', '    if(tokensLeft == 0){\n', '      failedDonations[msg.sender] += msg.value;\n', '      ErrMsg(msg.sender, "No more donations here check Majoolr.io, call withdrawDonation()");\n', '      return false;\n', '    }\n', '\n', '    donationMap[msg.sender] += msg.value;\n', '    donations += msg.value;\n', '    ThxMsg(msg.sender, "Thank you for your donation!");\n', '    return true;\n', '  }\n', '\n', '  function withdraw() andIsMajoolr {\n', '    uint256 amount = donations;\n', '    donations = 0;\n', '    msg.sender.transfer(amount);\n', '  }\n', '\n', '  function withdrawDonation(){\n', '    uint256 amount = failedDonations[msg.sender];\n', '    failedDonations[msg.sender] = 0;\n', '    msg.sender.transfer(amount);\n', '  }\n', '}\n', '\n', 'contract ETHCONEarlyBirdToken {\n', '   using ERC20Lib for ERC20Lib.TokenStorage;\n', '\n', '   ERC20Lib.TokenStorage token;\n', '\n', '   string public name = "ETHCON-Early-Bird";\n', '   string public symbol = "THX";\n', '   uint public decimals = 0;\n', '   uint public INITIAL_SUPPLY = 600;\n', '\n', '   event ErrorMsg(string msg);\n', '\n', '   function ETHCONEarlyBirdToken() {\n', '     token.init(INITIAL_SUPPLY);\n', '   }\n', '\n', '   function totalSupply() constant returns (uint) {\n', '     return token.totalSupply;\n', '   }\n', '\n', '   function balanceOf(address who) constant returns (uint) {\n', '     return token.balanceOf(who);\n', '   }\n', '\n', '   function allowance(address owner, address spender) constant returns (uint) {\n', '     return token.allowance(owner, spender);\n', '   }\n', '\n', '   function transfer(address to, uint value) returns (bool ok) {\n', '     if(token.balanceOf(to) == 0){\n', '       return token.transfer(to, value);\n', '     } else {\n', '       ErrorMsg("Recipient already has token");\n', '       return false;\n', '     }\n', '\n', '   }\n', '\n', '   function transferFrom(address from, address to, uint value) returns (bool ok) {\n', '     if(token.balanceOf(to) == 0){\n', '       return token.transferFrom(from, to, value);\n', '     } else {\n', '       ErrorMsg("Recipient already has token");\n', '       return false;\n', '     }\n', '   }\n', '\n', '   function approve(address spender, uint value) returns (bool ok) {\n', '     return token.approve(spender, value);\n', '   }\n', '\n', '   event Transfer(address indexed from, address indexed to, uint value);\n', '   event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'library ERC20Lib {\n', '  using BasicMathLib for uint256;\n', '\n', '  struct TokenStorage {\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint totalSupply;\n', '  }\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event ErrorMsg(string msg);\n', '\n', '  /// @dev Called by the Standard Token upon creation.\n', '  /// @param self Stored token from token contract\n', '  /// @param _initial_supply The initial token supply\n', '  function init(TokenStorage storage self, uint256 _initial_supply) {\n', '    self.totalSupply = _initial_supply;\n', '    self.balances[msg.sender] = _initial_supply;\n', '  }\n', '\n', '  /// @dev Transfer tokens from caller&#39;s account to another account.\n', '  /// @param self Stored token from token contract\n', '  /// @param _to Address to send tokens\n', '  /// @param _value Number of tokens to send\n', '  /// @return success True if completed, false otherwise\n', '  function transfer(TokenStorage storage self, address _to, uint256 _value) returns (bool success) {\n', '    bool err;\n', '    uint256 balance;\n', '\n', '    (err,balance) = self.balances[msg.sender].minus(_value);\n', '    if(err) {\n', '      ErrorMsg("Balance too low for transfer");\n', '      return false;\n', '    }\n', '    self.balances[msg.sender] = balance;\n', '    //It&#39;s not possible to overflow token supply\n', '    self.balances[_to] = self.balances[_to] + _value;\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Authorized caller transfers tokens from one account to another\n', '  /// @param self Stored token from token contract\n', '  /// @param _from Address to send tokens from\n', '  /// @param _to Address to send tokens to\n', '  /// @param _value Number of tokens to send\n', '  /// @return success True if completed, false otherwise\n', '  function transferFrom(TokenStorage storage self,\n', '                        address _from,\n', '                        address _to,\n', '                        uint256 _value)\n', '                        returns (bool success) {\n', '    var _allowance = self.allowed[_from][msg.sender];\n', '    bool err;\n', '    uint256 balanceOwner;\n', '    uint256 balanceSpender;\n', '\n', '    (err,balanceOwner) = self.balances[_from].minus(_value);\n', '    if(err) {\n', '      ErrorMsg("Balance too low for transfer");\n', '      return false;\n', '    }\n', '\n', '    (err,balanceSpender) = _allowance.minus(_value);\n', '    if(err) {\n', '      ErrorMsg("Transfer exceeds allowance");\n', '      return false;\n', '    }\n', '    self.balances[_from] = balanceOwner;\n', '    self.allowed[_from][msg.sender] = balanceSpender;\n', '    self.balances[_to] = self.balances[_to] + _value;\n', '\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Retrieve token balance for an account\n', '  /// @param self Stored token from token contract\n', '  /// @param _owner Address to retrieve balance of\n', '  /// @return balance The number of tokens in the subject account\n', '  function balanceOf(TokenStorage storage self, address _owner) constant returns (uint256 balance) {\n', '    return self.balances[_owner];\n', '  }\n', '\n', '  /// @dev Authorize an account to send tokens on caller&#39;s behalf\n', '  /// @param self Stored token from token contract\n', '  /// @param _spender Address to authorize\n', '  /// @param _value Number of tokens authorized account may send\n', '  /// @return success True if completed, false otherwise\n', '  function approve(TokenStorage storage self, address _spender, uint256 _value) returns (bool success) {\n', '    self.allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Remaining tokens third party spender has to send\n', '  /// @param self Stored token from token contract\n', '  /// @param _owner Address of token holder\n', '  /// @param _spender Address of authorized spender\n', '  /// @return remaining Number of tokens spender has left in owner&#39;s account\n', '  function allowance(TokenStorage storage self, address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return self.allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', 'library BasicMathLib {\n', '  event Err(string typeErr);\n', '\n', '  /// @dev Multiplies two numbers and checks for overflow before returning.\n', '  /// Does not throw but rather logs an Err event if there is overflow.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is overflow\n', '  /// @return res The product of a and b, or 0 if there is overflow\n', '  function times(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\n', '    assembly{\n', '      res := mul(a,b)\n', '      jumpi(allGood, or(iszero(b), eq(div(res,b), a)))\n', '      err := 1\n', '      res := 0\n', '      allGood:\n', '    }\n', '    if (err)\n', '      Err("times func overflow");\n', '  }\n', '\n', '  /// @dev Divides two numbers but checks for 0 in the divisor first.\n', '  /// Does not throw but rather logs an Err event if 0 is in the divisor.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if `b` is 0\n', '  /// @return res The quotient of a and b, or 0 if `b` is 0\n', '  function dividedBy(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\n', '    assembly{\n', '      jumpi(e, iszero(b))\n', '      res := div(a,b)\n', '      mstore(add(mload(0x40),0x20),res)\n', '      return(mload(0x40),0x40)\n', '      e:\n', '    }\n', '    Err("tried to divide by zero");\n', '    return (true, 0);\n', '  }\n', '\n', '  /// @dev Adds two numbers and checks for overflow before returning.\n', '  /// Does not throw but rather logs an Err event if there is overflow.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is overflow\n', '  /// @return res The sum of a and b, or 0 if there is overflow\n', '  function plus(uint256 a, uint256 b) constant returns (bool err, uint256 res) {\n', '    assembly{\n', '      res := add(a,b)\n', '      jumpi(allGood, and(eq(sub(res,b), a), gt(res,b)))\n', '      err := 1\n', '      res := 0\n', '      allGood:\n', '    }\n', '    if (err)\n', '      Err("plus func overflow");\n', '  }\n', '\n', '  /// @dev Subtracts two numbers and checks for underflow before returning.\n', '  /// Does not throw but rather logs an Err event if there is underflow.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is underflow\n', '  /// @return res The difference between a and b, or 0 if there is underflow\n', '  function minus(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\n', '    assembly{\n', '      res := sub(a,b)\n', '      jumpi(allGood, eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1))\n', '      err := 1\n', '      res := 0\n', '      allGood:\n', '    }\n', '    if (err)\n', '      Err("minus func underflow");\n', '  }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title ETHCON Early Bird Donation Contract\n', ' * @author majoolr.io\n', ' *\n', ' * Accepts donations and issues ETHCON token if at or above 3.9604 ETH.\n', ' * See ETHCON.org for further information.\n', ' * ETHCONEarlyBirdToken contract at 0x2d9498d0fd6f40760d53a847eb64eaf51c9b8e74\n', ' */\n', '\n', 'contract ETHCONEarlyBirdDonation {\n', '  address majoolr;\n', '  ETHCONEarlyBirdToken token;\n', '\n', '  uint256 public donations;\n', '  mapping (address => uint256) public donationMap;\n', '  mapping (address => uint256) public failedDonations;\n', '  uint256 public minimum = 3960400000000000000;\n', '\n', '  event ErrMsg(address indexed _from, string _msg);\n', '  event ThxMsg(address indexed _from, string _msg);\n', '\n', '  modifier andIsMajoolr {\n', '    require(msg.sender == majoolr);\n', '    _;\n', '  }\n', '\n', "  function(){ ErrMsg(msg.sender, 'No function called'); }\n", '\n', '  function ETHCONEarlyBirdDonation(address _token){\n', '    token = ETHCONEarlyBirdToken(_token);\n', '    majoolr = msg.sender;\n', '  }\n', '\n', '  function donate() payable returns (bool){\n', '    uint256 totalDonation = donationMap[msg.sender] + msg.value;\n', '    if(totalDonation < minimum){\n', '      failedDonations[msg.sender] += msg.value;\n', '      ErrMsg(msg.sender, "Donation too low, call withdrawDonation()");\n', '      return false;\n', '    }\n', '\n', '    bool success = token.transferFrom(majoolr,msg.sender,1);\n', '    if(!success){\n', '      failedDonations[msg.sender] += msg.value;\n', '      ErrMsg(msg.sender, "Transer failed, call withdrawDonation()");\n', '      return false;\n', '    }\n', '\n', '    donationMap[msg.sender] += msg.value;\n', '    donations += msg.value;\n', '    ThxMsg(msg.sender, "Thank you for your donation!");\n', '    return true;\n', '  }\n', '\n', '  function generousDonation() payable returns (bool){\n', '    uint256 tokensLeft = token.allowance(majoolr, this);\n', '    if(tokensLeft == 0){\n', '      failedDonations[msg.sender] += msg.value;\n', '      ErrMsg(msg.sender, "No more donations here check Majoolr.io, call withdrawDonation()");\n', '      return false;\n', '    }\n', '\n', '    donationMap[msg.sender] += msg.value;\n', '    donations += msg.value;\n', '    ThxMsg(msg.sender, "Thank you for your donation!");\n', '    return true;\n', '  }\n', '\n', '  function withdraw() andIsMajoolr {\n', '    uint256 amount = donations;\n', '    donations = 0;\n', '    msg.sender.transfer(amount);\n', '  }\n', '\n', '  function withdrawDonation(){\n', '    uint256 amount = failedDonations[msg.sender];\n', '    failedDonations[msg.sender] = 0;\n', '    msg.sender.transfer(amount);\n', '  }\n', '}\n', '\n', 'contract ETHCONEarlyBirdToken {\n', '   using ERC20Lib for ERC20Lib.TokenStorage;\n', '\n', '   ERC20Lib.TokenStorage token;\n', '\n', '   string public name = "ETHCON-Early-Bird";\n', '   string public symbol = "THX";\n', '   uint public decimals = 0;\n', '   uint public INITIAL_SUPPLY = 600;\n', '\n', '   event ErrorMsg(string msg);\n', '\n', '   function ETHCONEarlyBirdToken() {\n', '     token.init(INITIAL_SUPPLY);\n', '   }\n', '\n', '   function totalSupply() constant returns (uint) {\n', '     return token.totalSupply;\n', '   }\n', '\n', '   function balanceOf(address who) constant returns (uint) {\n', '     return token.balanceOf(who);\n', '   }\n', '\n', '   function allowance(address owner, address spender) constant returns (uint) {\n', '     return token.allowance(owner, spender);\n', '   }\n', '\n', '   function transfer(address to, uint value) returns (bool ok) {\n', '     if(token.balanceOf(to) == 0){\n', '       return token.transfer(to, value);\n', '     } else {\n', '       ErrorMsg("Recipient already has token");\n', '       return false;\n', '     }\n', '\n', '   }\n', '\n', '   function transferFrom(address from, address to, uint value) returns (bool ok) {\n', '     if(token.balanceOf(to) == 0){\n', '       return token.transferFrom(from, to, value);\n', '     } else {\n', '       ErrorMsg("Recipient already has token");\n', '       return false;\n', '     }\n', '   }\n', '\n', '   function approve(address spender, uint value) returns (bool ok) {\n', '     return token.approve(spender, value);\n', '   }\n', '\n', '   event Transfer(address indexed from, address indexed to, uint value);\n', '   event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'library ERC20Lib {\n', '  using BasicMathLib for uint256;\n', '\n', '  struct TokenStorage {\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint totalSupply;\n', '  }\n', '\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event ErrorMsg(string msg);\n', '\n', '  /// @dev Called by the Standard Token upon creation.\n', '  /// @param self Stored token from token contract\n', '  /// @param _initial_supply The initial token supply\n', '  function init(TokenStorage storage self, uint256 _initial_supply) {\n', '    self.totalSupply = _initial_supply;\n', '    self.balances[msg.sender] = _initial_supply;\n', '  }\n', '\n', "  /// @dev Transfer tokens from caller's account to another account.\n", '  /// @param self Stored token from token contract\n', '  /// @param _to Address to send tokens\n', '  /// @param _value Number of tokens to send\n', '  /// @return success True if completed, false otherwise\n', '  function transfer(TokenStorage storage self, address _to, uint256 _value) returns (bool success) {\n', '    bool err;\n', '    uint256 balance;\n', '\n', '    (err,balance) = self.balances[msg.sender].minus(_value);\n', '    if(err) {\n', '      ErrorMsg("Balance too low for transfer");\n', '      return false;\n', '    }\n', '    self.balances[msg.sender] = balance;\n', "    //It's not possible to overflow token supply\n", '    self.balances[_to] = self.balances[_to] + _value;\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Authorized caller transfers tokens from one account to another\n', '  /// @param self Stored token from token contract\n', '  /// @param _from Address to send tokens from\n', '  /// @param _to Address to send tokens to\n', '  /// @param _value Number of tokens to send\n', '  /// @return success True if completed, false otherwise\n', '  function transferFrom(TokenStorage storage self,\n', '                        address _from,\n', '                        address _to,\n', '                        uint256 _value)\n', '                        returns (bool success) {\n', '    var _allowance = self.allowed[_from][msg.sender];\n', '    bool err;\n', '    uint256 balanceOwner;\n', '    uint256 balanceSpender;\n', '\n', '    (err,balanceOwner) = self.balances[_from].minus(_value);\n', '    if(err) {\n', '      ErrorMsg("Balance too low for transfer");\n', '      return false;\n', '    }\n', '\n', '    (err,balanceSpender) = _allowance.minus(_value);\n', '    if(err) {\n', '      ErrorMsg("Transfer exceeds allowance");\n', '      return false;\n', '    }\n', '    self.balances[_from] = balanceOwner;\n', '    self.allowed[_from][msg.sender] = balanceSpender;\n', '    self.balances[_to] = self.balances[_to] + _value;\n', '\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Retrieve token balance for an account\n', '  /// @param self Stored token from token contract\n', '  /// @param _owner Address to retrieve balance of\n', '  /// @return balance The number of tokens in the subject account\n', '  function balanceOf(TokenStorage storage self, address _owner) constant returns (uint256 balance) {\n', '    return self.balances[_owner];\n', '  }\n', '\n', "  /// @dev Authorize an account to send tokens on caller's behalf\n", '  /// @param self Stored token from token contract\n', '  /// @param _spender Address to authorize\n', '  /// @param _value Number of tokens authorized account may send\n', '  /// @return success True if completed, false otherwise\n', '  function approve(TokenStorage storage self, address _spender, uint256 _value) returns (bool success) {\n', '    self.allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Remaining tokens third party spender has to send\n', '  /// @param self Stored token from token contract\n', '  /// @param _owner Address of token holder\n', '  /// @param _spender Address of authorized spender\n', "  /// @return remaining Number of tokens spender has left in owner's account\n", '  function allowance(TokenStorage storage self, address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return self.allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', 'library BasicMathLib {\n', '  event Err(string typeErr);\n', '\n', '  /// @dev Multiplies two numbers and checks for overflow before returning.\n', '  /// Does not throw but rather logs an Err event if there is overflow.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is overflow\n', '  /// @return res The product of a and b, or 0 if there is overflow\n', '  function times(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\n', '    assembly{\n', '      res := mul(a,b)\n', '      jumpi(allGood, or(iszero(b), eq(div(res,b), a)))\n', '      err := 1\n', '      res := 0\n', '      allGood:\n', '    }\n', '    if (err)\n', '      Err("times func overflow");\n', '  }\n', '\n', '  /// @dev Divides two numbers but checks for 0 in the divisor first.\n', '  /// Does not throw but rather logs an Err event if 0 is in the divisor.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if `b` is 0\n', '  /// @return res The quotient of a and b, or 0 if `b` is 0\n', '  function dividedBy(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\n', '    assembly{\n', '      jumpi(e, iszero(b))\n', '      res := div(a,b)\n', '      mstore(add(mload(0x40),0x20),res)\n', '      return(mload(0x40),0x40)\n', '      e:\n', '    }\n', '    Err("tried to divide by zero");\n', '    return (true, 0);\n', '  }\n', '\n', '  /// @dev Adds two numbers and checks for overflow before returning.\n', '  /// Does not throw but rather logs an Err event if there is overflow.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is overflow\n', '  /// @return res The sum of a and b, or 0 if there is overflow\n', '  function plus(uint256 a, uint256 b) constant returns (bool err, uint256 res) {\n', '    assembly{\n', '      res := add(a,b)\n', '      jumpi(allGood, and(eq(sub(res,b), a), gt(res,b)))\n', '      err := 1\n', '      res := 0\n', '      allGood:\n', '    }\n', '    if (err)\n', '      Err("plus func overflow");\n', '  }\n', '\n', '  /// @dev Subtracts two numbers and checks for underflow before returning.\n', '  /// Does not throw but rather logs an Err event if there is underflow.\n', '  /// @param a First number\n', '  /// @param b Second number\n', '  /// @return err False normally, or true if there is underflow\n', '  /// @return res The difference between a and b, or 0 if there is underflow\n', '  function minus(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\n', '    assembly{\n', '      res := sub(a,b)\n', '      jumpi(allGood, eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1))\n', '      err := 1\n', '      res := 0\n', '      allGood:\n', '    }\n', '    if (err)\n', '      Err("minus func underflow");\n', '  }\n', '}']
