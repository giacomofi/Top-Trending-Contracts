['pragma solidity 0.4.16;\n', '\n', '// implement safemath as a library\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    require(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// Used for function invoke restriction\n', 'contract Owned {\n', '\n', '    address public owner; // temporary address\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender != owner)\n', '            revert();\n', '        _; // function code inserted here\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) onlyOwner returns (bool success) {\n', '        if (msg.sender != owner)\n', '            revert();\n', '        owner = _newOwner;\n', '        return true;\n', '        \n', '    }\n', '}\n', '\n', 'contract Vezt is Owned {\n', '    using SafeMath for uint256;\n', '\n', '    address[]   public  veztUsers;\n', '    uint256     public  totalSupply;\n', '    uint8       public  decimals;\n', '    string      public  name;\n', '    string      public  symbol;\n', '    bool        public  tokenTransfersFrozen;\n', '    bool        public  tokenMintingEnabled;\n', '    bool        public  contractLaunched;\n', '\n', '    mapping (address => mapping (address => uint256))   public allowance;\n', '    mapping (address => uint256)                        public balances;\n', '    mapping (address => uint256)                        public royaltyTracking;\n', '    mapping (address => uint256)                        public icoBalances;\n', '    mapping (address => uint256)                        public veztUserArrayIdentifier;\n', '    mapping (address => bool)                           public veztUserRegistered;\n', '\n', '    event Transfer(address indexed _sender, address indexed _recipient, uint256 _amount);\n', '    event Approve(address indexed _owner, address indexed _spender, uint256 _amount);\n', '    event LaunchContract(address indexed _launcher, bool _launched);\n', '    event FreezeTokenTransfers(address indexed _invoker, bool _frozen);\n', '    event ThawTokenTransfers(address indexed _invoker, bool _thawed);\n', '    event MintTokens(address indexed _minter, uint256 _amount, bool indexed _minted);\n', '    event TokenMintingDisabled(address indexed _invoker, bool indexed _disabled);\n', '    event TokenMintingEnabled(address indexed _invoker, bool indexed _enabled);\n', '\n', '    function Vezt() {\n', '        name = "Vezt";\n', '        symbol = "VZT";\n', '        decimals = 18;\n', '        //125 million in wei \n', '        totalSupply = 125000000000000000000000000;\n', '        balances[msg.sender] = balances[msg.sender].add(totalSupply);\n', '        tokenTransfersFrozen = true;\n', '        tokenMintingEnabled = false;\n', '        contractLaunched = false;\n', '    }\n', '\n', '    /// @notice Used to log royalties\n', '    /// @param _receiver The eth address of person to receive VZT Tokens\n', '    /// @param _amount The amount of VZT Tokens in wei to send\n', '    function logRoyalty(address _receiver, uint256 _amount)\n', '        onlyOwner\n', '        public \n', '        returns (bool logged)\n', '    {\n', '        require(transferCheck(msg.sender, _receiver, _amount));\n', '        if (!veztUserRegistered[_receiver]) {\n', '            veztUsers.push(_receiver);\n', '            veztUserRegistered[_receiver] = true;\n', '        }\n', '        require(royaltyTracking[_receiver].add(_amount) > 0);\n', '        require(royaltyTracking[_receiver].add(_amount) > royaltyTracking[_receiver]);\n', '        royaltyTracking[_receiver] = royaltyTracking[_receiver].add(_amount);\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_receiver] = balances[_receiver].add(_amount);\n', '        Transfer(owner, _receiver, _amount);\n', '        return true;\n', '    }\n', '\n', '    function transactionReplay(address _receiver, uint256 _amount)\n', '        onlyOwner\n', '        public\n', '        returns (bool replayed)\n', '    {\n', '        require(transferCheck(msg.sender, _receiver, _amount));\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_receiver] = balances[_receiver].add(_amount);\n', '        Transfer(msg.sender, _receiver, _amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Used to launch the contract, and enabled token minting\n', '    function launchContract() onlyOwner {\n', '        require(!contractLaunched);\n', '        tokenTransfersFrozen = false;\n', '        tokenMintingEnabled = true;\n', '        contractLaunched = true;\n', '        LaunchContract(msg.sender, true);\n', '    }\n', '\n', '    function disableTokenMinting() onlyOwner returns (bool disabled) {\n', '        tokenMintingEnabled = false;\n', '        TokenMintingDisabled(msg.sender, true);\n', '        return true;\n', '    }\n', '\n', '    function enableTokenMinting() onlyOwner returns (bool enabled) {\n', '        tokenMintingEnabled = true;\n', '        TokenMintingEnabled(msg.sender, true);\n', '        return true;\n', '    }\n', '\n', '    function freezeTokenTransfers() onlyOwner returns (bool success) {\n', '        tokenTransfersFrozen = true;\n', '        FreezeTokenTransfers(msg.sender, true);\n', '        return true;\n', '    }\n', '\n', '    function thawTokenTransfers() onlyOwner returns (bool success) {\n', '        tokenTransfersFrozen = false;\n', '        ThawTokenTransfers(msg.sender, true);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Used to transfer funds\n', '    /// @param _receiver Eth address to send VZT tokens too\n', '    /// @param _amount The amount of VZT tokens in wei to send\n', '    function transfer(address _receiver, uint256 _amount)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(transferCheck(msg.sender, _receiver, _amount));\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_receiver] = balances[_receiver].add(_amount);\n', '        Transfer(msg.sender, _receiver, _amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Used to transfer funds on behalf of owner to receiver\n', '    /// @param _owner The person you are allowed to sends funds on bhhalf of\n', '    /// @param _receiver The person to receive the funds\n', '    /// @param _amount The amount of VZT tokens in wei to send\n', '    function transferFrom(address _owner, address _receiver, uint256 _amount) \n', '        public \n', '        returns (bool success)\n', '    {\n', '        require(allowance[_owner][msg.sender] >= _amount);\n', '        require(transferCheck(_owner, _receiver, _amount));\n', '        allowance[_owner][msg.sender] = allowance[_owner][msg.sender].sub(_amount);\n', '        balances[_owner] =  balances[_owner].sub(_amount);\n', '        balances[_receiver] = balances[_receiver].add(_amount);\n', '        Transfer(_owner, _receiver, _amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Used to approve someone to send funds on your behalf\n', '    /// @param _spender The eth address of the person you are approving\n', '    /// @param _amount The amount of VZT tokens _spender is allowed to send (in wei)\n', '    function approve(address _spender, uint256 _amount)\n', '        public\n', '        returns (bool approved)\n', '    {\n', '        require(_amount > 0);\n', '        require(balances[msg.sender] >= _amount);\n', '        allowance[msg.sender][_spender] = allowance[msg.sender][_spender].add(_amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Used to burn tokens and decrease total supply\n', '    /// @param _amount The amount of VZT tokens in wei to burn\n', '    function tokenBurner(uint256 _amount)\n', '        onlyOwner\n', '        returns (bool burned)\n', '    {\n', '        require(_amount > 0);\n', '        require(totalSupply.sub(_amount) > 0);\n', '        require(balances[msg.sender] > _amount);\n', '        require(balances[msg.sender].sub(_amount) > 0);\n', '        totalSupply = totalSupply.sub(_amount);\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        Transfer(msg.sender, 0, _amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Low level function Used to create new tokens and increase total supply\n', '    /// @param _amount The amount of VZT tokens in wei to create\n', '    function tokenMinter(uint256 _amount)\n', '        private\n', '        returns (bool minted)\n', '    {\n', '        require(tokenMintingEnabled);\n', '        require(_amount > 0);\n', '        require(totalSupply.add(_amount) > 0);\n', '        require(totalSupply.add(_amount) > totalSupply);\n', '        require(balances[owner].add(_amount) > 0);\n', '        require(balances[owner].add(_amount) > balances[owner]);\n', '        return true;\n', '    }\n', '    /// @notice Used to create new tokens and increase total supply\n', '    /// @param _amount The amount of VZT tokens in wei to create\n', '    function tokenFactory(uint256 _amount) \n', '        onlyOwner\n', '        returns (bool success)\n', '    {\n', '        require(tokenMinter(_amount));\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[msg.sender] = balances[msg.sender].add(_amount);\n', '        Transfer(0, msg.sender, _amount);\n', '        return true;\n', '    }\n', '\n', '    // GETTER //\n', '\n', '    function lookupRoyalty(address _veztUser)\n', '        public\n', '        constant\n', '        returns (uint256 royalties)\n', '    {\n', '        return royaltyTracking[_veztUser];\n', '    }\n', '\n', '    /// @notice Reusable code to do sanity check of transfer variables\n', '    function transferCheck(address _sender, address _receiver, uint256 _amount)\n', '        private\n', '        constant\n', '        returns (bool success)\n', '    {\n', '        require(!tokenTransfersFrozen);\n', '        require(_amount > 0);\n', '        require(_receiver != address(0));\n', '        require(balances[_sender].sub(_amount) >= 0);\n', '        require(balances[_receiver].add(_amount) > 0);\n', '        require(balances[_receiver].add(_amount) > balances[_receiver]);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Used to retrieve total supply\n', '    function totalSupply() \n', '        public\n', '        constant\n', '        returns (uint256 _totalSupply)\n', '    {\n', '        return totalSupply;\n', '    }\n', '\n', '    /// @notice Used to look up balance of a person\n', '    function balanceOf(address _person)\n', '        public\n', '        constant\n', '        returns (uint256 _balance)\n', '    {\n', '        return balances[_person];\n', '    }\n', '\n', '    /// @notice Used to look up the allowance of someone\n', '    function allowance(address _owner, address _spender)\n', '        public\n', '        constant \n', '        returns (uint256 _amount)\n', '    {\n', '        return allowance[_owner][_spender];\n', '    }\n', '}']