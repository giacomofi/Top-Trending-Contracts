['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    modifier onlyOwner() { require(msg.sender == owner); _; }\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '    bool public paused = false;\n', '\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    modifier whenNotPaused() { require(!paused); _; }\n', '    modifier whenPaused() { require(paused); _; }\n', '\n', '    function pause() onlyOwner whenNotPaused {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '    \n', '    function unpause() onlyOwner whenPaused {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function balanceOf(address who) constant returns (uint256);\n', '    function transfer(address to, uint256 value) returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) returns (bool);\n', '    function allowance(address owner, address spender) constant returns (uint256);\n', '    function approve(address spender, uint256 value) returns (bool);\n', '}\n', '\n', 'contract StandardToken is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    function balanceOf(address _owner) constant returns(uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns(bool success) {\n', '        require(_to != address(0));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n', '        require(_to != address(0));\n', '\n', '        var _allowance = allowed[_from][msg.sender];\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns(bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) returns(bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) returns(bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '\n', '        if(_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        \n', '        return true;\n', '    }\n', '}\n', '\n', 'contract BurnableToken is StandardToken {\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    function burn(uint256 _value) public {\n', '        require(_value > 0);\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Burn(burner, _value);\n', '    }\n', '}\n', '\n', 'contract OKFToken is BurnableToken, Ownable {\n', '    string public name = "KickingOff Cinema Token";\n', '    string public symbol = "OKF";\n', '    uint256 public decimals = 18;\n', '    \n', '    uint256 public INITIAL_SUPPLY = 11000000 * 1 ether;                                // Amount tokens\n', '\n', '    function OKFToken() {\n', '        totalSupply = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '    }\n', '}\n', '\n', 'contract OKFCrowdsale is Pausable {\n', '    using SafeMath for uint;\n', '\n', '    OKFToken public token;\n', '    address public beneficiary = 0x97F795fbdEf69ee530d54e7Dc4eCDCc0244aAf00;        // Beneficiary 90%\n', '    address public command = 0xEe7410eCf01988A61Ba2C3f66283c08859414F6B;            // Command 10%\n', '\n', '    uint public collectedWei;\n', '    uint public collectedUSD;\n', '    uint public tokensSold;\n', '\n', '    uint public tokensForSale = 10000000 * 1 ether;                                 // Amount tokens for sale\n', '    uint public priceETHUSD = 250;                                                  // Ether price USD\n', '    uint public softCapUSD = 1500000;                                               // Soft cap USD\n', '    uint public hardCapUSD = 2500000;                                               // Hard cap USD\n', '    uint public softCapWei = softCapUSD * 1 ether / priceETHUSD;\n', '    uint public hardCapWei = hardCapUSD * 1 ether / priceETHUSD;\n', '    uint public priceTokenWei = 1 ether / 1000;\n', '\n', '    uint public startTime = 1507032000;                                             // Date start 03.10.2017 12:00 +0\n', '    uint public endTime = 1517659200;                                               // Date end 03.02.2018 12:00 +0\n', '    bool public crowdsaleFinished = false;\n', '\n', '    event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount);\n', '    event SoftCapReached(uint256 etherAmount);\n', '    event HardCapReached(uint256 etherAmount);\n', '    event Withdraw();\n', '\n', '    function OKFCrowdsale() {\n', '        token = new OKFToken();\n', '        require(token.transfer(0x915c517cB57fAB7C532262cB9f109C875bEd7d18, 1000000 * 1 ether));    // Bounty tokens\n', '    }\n', '\n', '    function() payable {\n', '        purchase();\n', '    }\n', '    \n', '    function purchase() whenNotPaused payable {\n', '        require(!crowdsaleFinished);\n', '        require(now >= startTime && now < endTime);\n', '        require(tokensSold < tokensForSale);\n', '        require(msg.value >= 0.001 * 1 ether);\n', '        require(msg.value <= 50 * 1 ether);\n', '\n', '        uint sum = msg.value;\n', '        uint amount = sum.div(priceTokenWei).mul(1 ether);\n', '        \n', '        if(tokensSold.add(amount) > tokensForSale) {\n', '            uint retAmount = tokensSold.add(amount).sub(tokensForSale);\n', '            uint retSum = retAmount.mul(priceTokenWei).div(1 ether);\n', '\n', '            amount = amount.sub(retAmount);\n', '            sum = sum.sub(retSum);\n', '\n', '            require(msg.sender.send(retSum));\n', '        }\n', '\n', '        require(token.transfer(msg.sender, amount));\n', '        require(beneficiary.send(sum.div(100).mul(90)));\n', '        require(command.send(sum.sub(sum.div(100).mul(90))));\n', '\n', '        if(collectedWei < softCapWei && collectedWei.add(sum) >= softCapWei) {\n', '            SoftCapReached(collectedWei);\n', '        }\n', '\n', '        if(collectedWei < hardCapWei && collectedWei.add(sum) >= hardCapWei) {\n', '            HardCapReached(collectedWei);\n', '        }\n', '\n', '        tokensSold = tokensSold.add(amount);\n', '        collectedWei = collectedWei.add(sum);\n', '        collectedUSD = collectedWei * priceETHUSD / 1 ether;\n', '\n', '        NewContribution(msg.sender, amount, sum);\n', '    }\n', '\n', '    function withdraw() onlyOwner {\n', '        require(!crowdsaleFinished);\n', '\n', '        token.transfer(beneficiary, token.balanceOf(this));\n', '        token.transferOwnership(beneficiary);\n', '        crowdsaleFinished = true;\n', '\n', '        Withdraw();\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    modifier onlyOwner() { require(msg.sender == owner); _; }\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        require(newOwner != address(0));\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '    bool public paused = false;\n', '\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    modifier whenNotPaused() { require(!paused); _; }\n', '    modifier whenPaused() { require(paused); _; }\n', '\n', '    function pause() onlyOwner whenNotPaused {\n', '        paused = true;\n', '        Pause();\n', '    }\n', '    \n', '    function unpause() onlyOwner whenPaused {\n', '        paused = false;\n', '        Unpause();\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function balanceOf(address who) constant returns (uint256);\n', '    function transfer(address to, uint256 value) returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) returns (bool);\n', '    function allowance(address owner, address spender) constant returns (uint256);\n', '    function approve(address spender, uint256 value) returns (bool);\n', '}\n', '\n', 'contract StandardToken is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    function balanceOf(address _owner) constant returns(uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns(bool success) {\n', '        require(_to != address(0));\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n', '        require(_to != address(0));\n', '\n', '        var _allowance = allowed[_from][msg.sender];\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns(bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) returns(bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) returns(bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '\n', '        if(_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        \n', '        return true;\n', '    }\n', '}\n', '\n', 'contract BurnableToken is StandardToken {\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    function burn(uint256 _value) public {\n', '        require(_value > 0);\n', '\n', '        address burner = msg.sender;\n', '        balances[burner] = balances[burner].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Burn(burner, _value);\n', '    }\n', '}\n', '\n', 'contract OKFToken is BurnableToken, Ownable {\n', '    string public name = "KickingOff Cinema Token";\n', '    string public symbol = "OKF";\n', '    uint256 public decimals = 18;\n', '    \n', '    uint256 public INITIAL_SUPPLY = 11000000 * 1 ether;                                // Amount tokens\n', '\n', '    function OKFToken() {\n', '        totalSupply = INITIAL_SUPPLY;\n', '        balances[msg.sender] = INITIAL_SUPPLY;\n', '    }\n', '}\n', '\n', 'contract OKFCrowdsale is Pausable {\n', '    using SafeMath for uint;\n', '\n', '    OKFToken public token;\n', '    address public beneficiary = 0x97F795fbdEf69ee530d54e7Dc4eCDCc0244aAf00;        // Beneficiary 90%\n', '    address public command = 0xEe7410eCf01988A61Ba2C3f66283c08859414F6B;            // Command 10%\n', '\n', '    uint public collectedWei;\n', '    uint public collectedUSD;\n', '    uint public tokensSold;\n', '\n', '    uint public tokensForSale = 10000000 * 1 ether;                                 // Amount tokens for sale\n', '    uint public priceETHUSD = 250;                                                  // Ether price USD\n', '    uint public softCapUSD = 1500000;                                               // Soft cap USD\n', '    uint public hardCapUSD = 2500000;                                               // Hard cap USD\n', '    uint public softCapWei = softCapUSD * 1 ether / priceETHUSD;\n', '    uint public hardCapWei = hardCapUSD * 1 ether / priceETHUSD;\n', '    uint public priceTokenWei = 1 ether / 1000;\n', '\n', '    uint public startTime = 1507032000;                                             // Date start 03.10.2017 12:00 +0\n', '    uint public endTime = 1517659200;                                               // Date end 03.02.2018 12:00 +0\n', '    bool public crowdsaleFinished = false;\n', '\n', '    event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount);\n', '    event SoftCapReached(uint256 etherAmount);\n', '    event HardCapReached(uint256 etherAmount);\n', '    event Withdraw();\n', '\n', '    function OKFCrowdsale() {\n', '        token = new OKFToken();\n', '        require(token.transfer(0x915c517cB57fAB7C532262cB9f109C875bEd7d18, 1000000 * 1 ether));    // Bounty tokens\n', '    }\n', '\n', '    function() payable {\n', '        purchase();\n', '    }\n', '    \n', '    function purchase() whenNotPaused payable {\n', '        require(!crowdsaleFinished);\n', '        require(now >= startTime && now < endTime);\n', '        require(tokensSold < tokensForSale);\n', '        require(msg.value >= 0.001 * 1 ether);\n', '        require(msg.value <= 50 * 1 ether);\n', '\n', '        uint sum = msg.value;\n', '        uint amount = sum.div(priceTokenWei).mul(1 ether);\n', '        \n', '        if(tokensSold.add(amount) > tokensForSale) {\n', '            uint retAmount = tokensSold.add(amount).sub(tokensForSale);\n', '            uint retSum = retAmount.mul(priceTokenWei).div(1 ether);\n', '\n', '            amount = amount.sub(retAmount);\n', '            sum = sum.sub(retSum);\n', '\n', '            require(msg.sender.send(retSum));\n', '        }\n', '\n', '        require(token.transfer(msg.sender, amount));\n', '        require(beneficiary.send(sum.div(100).mul(90)));\n', '        require(command.send(sum.sub(sum.div(100).mul(90))));\n', '\n', '        if(collectedWei < softCapWei && collectedWei.add(sum) >= softCapWei) {\n', '            SoftCapReached(collectedWei);\n', '        }\n', '\n', '        if(collectedWei < hardCapWei && collectedWei.add(sum) >= hardCapWei) {\n', '            HardCapReached(collectedWei);\n', '        }\n', '\n', '        tokensSold = tokensSold.add(amount);\n', '        collectedWei = collectedWei.add(sum);\n', '        collectedUSD = collectedWei * priceETHUSD / 1 ether;\n', '\n', '        NewContribution(msg.sender, amount, sum);\n', '    }\n', '\n', '    function withdraw() onlyOwner {\n', '        require(!crowdsaleFinished);\n', '\n', '        token.transfer(beneficiary, token.balanceOf(this));\n', '        token.transferOwnership(beneficiary);\n', '        crowdsaleFinished = true;\n', '\n', '        Withdraw();\n', '    }\n', '}']
