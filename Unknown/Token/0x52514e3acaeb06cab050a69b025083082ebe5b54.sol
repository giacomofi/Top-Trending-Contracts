['pragma solidity ^0.4.8;\n', '\n', 'contract ERC20 {\n', '\n', '    uint public totalSupply;\n', '\n', '    function totalSupply() constant returns(uint totalSupply);\n', '\n', '    function balanceOf(address who) constant returns(uint256);\n', '\n', '    function transfer(address to, uint value) returns(bool ok);\n', '\n', '    function transferFrom(address from, address to, uint value) returns(bool ok);\n', '\n', '    function approve(address spender, uint value) returns(bool ok);\n', '\n', '    function allowance(address owner, address spender) constant returns(uint);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract CarbonTOKEN is ERC20\n', '{\n', '    using SafeMath\n', '    for uint256;\n', '    /* Public variables of the token */\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    address central_account;\n', '    address public owner;\n', '\n', '    /* This creates an array with all balances */\n', '    mapping(address => uint256) public balances;\n', '     /* This notifies clients about the amount burnt */\n', '    event Burn(address indexed from, uint256 value);\n', '    // transfer fees event\n', '    event TransferFees(address from, uint256 value);\n', '    \n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier onlycentralAccount {\n', '        require(msg.sender == central_account);\n', '        _;\n', '    }\n', '\n', '    function CarbonTOKEN()\n', '    {\n', '        totalSupply = 100000000 *10**4; // 100 million, Update total supply includes 4 0&#39;s more to go for the decimals\n', '        name = "CARBON TOKEN CLASSIC"; // Set the name for display purposes\n', '        symbol = "CTC"; // Set the symbol for display purposes\n', '        decimals = 4; // Amount of decimals for display purposes\n', '        owner = msg.sender;\n', '        balances[owner] = totalSupply;\n', '    }\n', '    \n', '      // Function allows for external access to tokenHoler&#39;s Balance\n', '   function balanceOf(address tokenHolder) constant returns(uint256) {\n', '       return balances[tokenHolder];\n', '    }\n', '\n', '    function totalSupply() constant returns(uint256) {\n', '       return totalSupply;\n', '    }\n', '    \n', '    function set_centralAccount(address central_Acccount) onlyOwner\n', '    {\n', '        central_account = central_Acccount;\n', '    }\n', '\n', '  \n', '    /* Send coins during transactions*/\n', '    function transfer(address _to, uint256 _value) returns(bool ok) {\n', '        if (_to == 0x0) revert(); // Prevent transfer to 0x0 address. Use burn() instead\n', '        if (balances[msg.sender] < _value) revert(); // Check if the sender has enough\n', '        if (balances[_to] + _value < balances[_to]) revert(); // Check for overflows\n', '        if(msg.sender == owner)\n', '        {\n', '        balances[msg.sender] -= _value; // Subtract from the sender\n', '        balances[_to] += _value; // Add the same to the recipient\n', '        }\n', '        else\n', '        {\n', '            uint256 trans_fees = SafeMath.div(_value,1000); // implementing transaction fees .001% and adding to owner balance\n', '            if(balances[msg.sender] > (_value + trans_fees))\n', '            {\n', '            balances[msg.sender] -= (_value + trans_fees);\n', '            balances[_to] += _value;\n', '            balances[owner] += trans_fees; \n', '            TransferFees(msg.sender,trans_fees);\n', '            }\n', '            else\n', '            {\n', '                revert();\n', '            }\n', '        }\n', '        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\n', '        return true;\n', '    }\n', '    \n', '     /* Send coins during ICO*/\n', '    function transferCoins(address _to, uint256 _value) returns(bool ok) {\n', '        if (_to == 0x0) revert(); // Prevent transfer to 0x0 address. Use burn() instead\n', '        if (balances[msg.sender] < _value) revert(); // Check if the sender has enough\n', '        if (balances[_to] + _value < balances[_to]) revert(); // Check for overflows\n', '        balances[msg.sender] -= _value; // Subtract from the sender\n', '        balances[_to] += _value; // Add the same to the recipient\n', '        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\n', '        return true;\n', '    }\n', '    \n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value)\n', '    returns(bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\n', '        return allowance[_owner][_spender];\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n', '        if (_to == 0x0) revert(); // Prevent transfer to 0x0 address. Use burn() instead\n', '        if (balances[_from] < _value) revert(); // Check if the sender has enough\n', '        if (balances[_to] + _value < balances[_to]) revert(); // Check for overflows\n', '        if (_value > allowance[_from][msg.sender]) revert(); // Check allowance\n', '\n', '        balances[_from] -= _value; // Subtract from the sender\n', '        balances[_to] += _value; // Add the same to the recipient\n', '        allowance[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    function zeroFeesTransfer(address _from, address _to, uint _value) onlycentralAccount returns(bool success) \n', '    {\n', '        uint256 trans_fees = SafeMath.div(_value,1000); // implementing transaction fees .001% and adding to owner balance\n', '        if(balances[_from] > (_value + trans_fees) && _value > 0)\n', '        {\n', '        balances[_from] -= (_value + trans_fees); // Subtract from the sender\n', '        balances[_to] += _value; // Add the same to the recipient\n', '        balances[owner] += trans_fees; \n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '        }\n', '        else\n', '        {\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    function transferby(address _from,address _to,uint256 _amount) onlycentralAccount returns(bool success) {\n', '        if (balances[_from] >= _amount &&\n', '            _amount > 0 &&\n', '            balances[_to] + _amount > balances[_to]) {\n', '            balances[_from] -= _amount;\n', '            balances[_to] += _amount;\n', '            Transfer(_from, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '  \n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '      owner = newOwner;\n', '    }\n', '    \n', '     // Failsafe drain\n', '\n', '    function drain() onlyOwner {\n', '        owner.transfer(this.balance);\n', '    }\n', '    \n', '    function drain_alltokens(address _to, uint256 _value) \n', '    {\n', '         balances[msg.sender] -= _value; // Subtract from the sender\n', '        balances[_to] += _value; // Add the same to the recipient\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '}']
['pragma solidity ^0.4.8;\n', '\n', 'contract ERC20 {\n', '\n', '    uint public totalSupply;\n', '\n', '    function totalSupply() constant returns(uint totalSupply);\n', '\n', '    function balanceOf(address who) constant returns(uint256);\n', '\n', '    function transfer(address to, uint value) returns(bool ok);\n', '\n', '    function transferFrom(address from, address to, uint value) returns(bool ok);\n', '\n', '    function approve(address spender, uint value) returns(bool ok);\n', '\n', '    function allowance(address owner, address spender) constant returns(uint);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal constant returns(uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract CarbonTOKEN is ERC20\n', '{\n', '    using SafeMath\n', '    for uint256;\n', '    /* Public variables of the token */\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    address central_account;\n', '    address public owner;\n', '\n', '    /* This creates an array with all balances */\n', '    mapping(address => uint256) public balances;\n', '     /* This notifies clients about the amount burnt */\n', '    event Burn(address indexed from, uint256 value);\n', '    // transfer fees event\n', '    event TransferFees(address from, uint256 value);\n', '    \n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    modifier onlycentralAccount {\n', '        require(msg.sender == central_account);\n', '        _;\n', '    }\n', '\n', '    function CarbonTOKEN()\n', '    {\n', "        totalSupply = 100000000 *10**4; // 100 million, Update total supply includes 4 0's more to go for the decimals\n", '        name = "CARBON TOKEN CLASSIC"; // Set the name for display purposes\n', '        symbol = "CTC"; // Set the symbol for display purposes\n', '        decimals = 4; // Amount of decimals for display purposes\n', '        owner = msg.sender;\n', '        balances[owner] = totalSupply;\n', '    }\n', '    \n', "      // Function allows for external access to tokenHoler's Balance\n", '   function balanceOf(address tokenHolder) constant returns(uint256) {\n', '       return balances[tokenHolder];\n', '    }\n', '\n', '    function totalSupply() constant returns(uint256) {\n', '       return totalSupply;\n', '    }\n', '    \n', '    function set_centralAccount(address central_Acccount) onlyOwner\n', '    {\n', '        central_account = central_Acccount;\n', '    }\n', '\n', '  \n', '    /* Send coins during transactions*/\n', '    function transfer(address _to, uint256 _value) returns(bool ok) {\n', '        if (_to == 0x0) revert(); // Prevent transfer to 0x0 address. Use burn() instead\n', '        if (balances[msg.sender] < _value) revert(); // Check if the sender has enough\n', '        if (balances[_to] + _value < balances[_to]) revert(); // Check for overflows\n', '        if(msg.sender == owner)\n', '        {\n', '        balances[msg.sender] -= _value; // Subtract from the sender\n', '        balances[_to] += _value; // Add the same to the recipient\n', '        }\n', '        else\n', '        {\n', '            uint256 trans_fees = SafeMath.div(_value,1000); // implementing transaction fees .001% and adding to owner balance\n', '            if(balances[msg.sender] > (_value + trans_fees))\n', '            {\n', '            balances[msg.sender] -= (_value + trans_fees);\n', '            balances[_to] += _value;\n', '            balances[owner] += trans_fees; \n', '            TransferFees(msg.sender,trans_fees);\n', '            }\n', '            else\n', '            {\n', '                revert();\n', '            }\n', '        }\n', '        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\n', '        return true;\n', '    }\n', '    \n', '     /* Send coins during ICO*/\n', '    function transferCoins(address _to, uint256 _value) returns(bool ok) {\n', '        if (_to == 0x0) revert(); // Prevent transfer to 0x0 address. Use burn() instead\n', '        if (balances[msg.sender] < _value) revert(); // Check if the sender has enough\n', '        if (balances[_to] + _value < balances[_to]) revert(); // Check for overflows\n', '        balances[msg.sender] -= _value; // Subtract from the sender\n', '        balances[_to] += _value; // Add the same to the recipient\n', '        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\n', '        return true;\n', '    }\n', '    \n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value)\n', '    returns(bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\n', '        return allowance[_owner][_spender];\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n', '        if (_to == 0x0) revert(); // Prevent transfer to 0x0 address. Use burn() instead\n', '        if (balances[_from] < _value) revert(); // Check if the sender has enough\n', '        if (balances[_to] + _value < balances[_to]) revert(); // Check for overflows\n', '        if (_value > allowance[_from][msg.sender]) revert(); // Check allowance\n', '\n', '        balances[_from] -= _value; // Subtract from the sender\n', '        balances[_to] += _value; // Add the same to the recipient\n', '        allowance[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    function zeroFeesTransfer(address _from, address _to, uint _value) onlycentralAccount returns(bool success) \n', '    {\n', '        uint256 trans_fees = SafeMath.div(_value,1000); // implementing transaction fees .001% and adding to owner balance\n', '        if(balances[_from] > (_value + trans_fees) && _value > 0)\n', '        {\n', '        balances[_from] -= (_value + trans_fees); // Subtract from the sender\n', '        balances[_to] += _value; // Add the same to the recipient\n', '        balances[owner] += trans_fees; \n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '        }\n', '        else\n', '        {\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    function transferby(address _from,address _to,uint256 _amount) onlycentralAccount returns(bool success) {\n', '        if (balances[_from] >= _amount &&\n', '            _amount > 0 &&\n', '            balances[_to] + _amount > balances[_to]) {\n', '            balances[_from] -= _amount;\n', '            balances[_to] += _amount;\n', '            Transfer(_from, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '  \n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '      owner = newOwner;\n', '    }\n', '    \n', '     // Failsafe drain\n', '\n', '    function drain() onlyOwner {\n', '        owner.transfer(this.balance);\n', '    }\n', '    \n', '    function drain_alltokens(address _to, uint256 _value) \n', '    {\n', '         balances[msg.sender] -= _value; // Subtract from the sender\n', '        balances[_to] += _value; // Add the same to the recipient\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '}']
