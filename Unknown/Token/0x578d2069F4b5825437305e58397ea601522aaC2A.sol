['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract OwOToken {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    string public constant symbol = "OWO";\n', '    string public constant name = "OwO.World Token";\n', '    uint public constant decimals = 18;\n', '    address public _multiSigWallet;  // The address to hold the funds donated\n', '    address public owner;\n', '    uint public totalSupply;\n', '    \n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    // Crowdsale end time has been changed\n', '    event EndsAtChanged(uint endsAt);\n', '    event changed(address a);\n', '    \n', '    function () payable{\n', '        //\n', '    }\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function OwOToken() {\n', '        \n', '        owner = msg.sender;\n', '        totalSupply = 100000000 * 10 ** decimals;\n', '        balanceOf[msg.sender] = totalSupply;              // Give the creator all initial tokens\n', '        _multiSigWallet = 0x6c5140f605a9Add003B3626Aae4f08F41E6c6FfF;\n', '\n', '    }\n', '\n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) returns(bool success){\n', '      require((balanceOf[msg.sender] >= _value) && (balanceOf[_to].add(_value)>balanceOf[_to]));\n', '        balanceOf[msg.sender].sub(_value);                     // Subtract from the sender\n', '        balanceOf[_to].add(_value);                            // Add the same to the recipient\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '\n', '    }\n', '\n', '    modifier onlyOwner(){\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function setMultiSigWallet(address w) onlyOwner {\n', '        require(w != 0 );\n', '\n', '          _multiSigWallet = w;\n', '\n', '        changed(msg.sender);\n', '    }\n', '    function getMultiSigWallet() constant returns (address){\n', '\n', '        return _multiSigWallet;\n', '\n', '    }\n', '    function getMultiSigBalance() constant returns (uint){\n', '\n', '        return balanceOf[_multiSigWallet];\n', '\n', '    }\n', '    function getTotalSupply() constant returns (uint){\n', '\n', '        return totalSupply;\n', '\n', '    }\n', '    \n', '    function withdraw() onlyOwner payable{\n', '\n', '         assert(_multiSigWallet.send(this.balance));\n', '\n', '     }\n', '\n', '\n', '}']