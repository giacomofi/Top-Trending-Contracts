['pragma solidity >=0.4.4;\n', '\n', '//from Zeppelin\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '\n', '    function assert(bool assertion) internal {\n', '        if (!assertion) throw;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender != owner) throw;\n', '        _;\n', '    }\n', '\n', '    address newOwner;\n', '\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract Finalizable is Owned {\n', '    bool public finalized;\n', '\n', '    function finalize() onlyOwner {\n', '        finalized = true;\n', '    }\n', '\n', '    modifier notFinalized() {\n', '        if (finalized) throw;\n', '        _;\n', '    }\n', '}\n', '\n', 'contract IToken {\n', '    function transfer(address _to, uint _value) returns (bool);\n', '    function balanceOf(address owner) returns(uint);\n', '}\n', '\n', 'contract TokenReceivable is Owned {\n', '    event logTokenTransfer(address token, address to, uint amount);\n', '\n', '    function claimTokens(address _token, address _to) onlyOwner returns (bool) {\n', '        IToken token = IToken(_token);\n', '        uint balance = token.balanceOf(this);\n', '        if (token.transfer(_to, balance)) {\n', '            logTokenTransfer(_token, _to, balance);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '}\n', '\n', 'contract EventDefinitions {\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract Token is Finalizable, TokenReceivable, SafeMath, EventDefinitions {\n', '\n', '    string public name = "FunFair";\n', '    uint8 public decimals = 8;\n', '    string public symbol = "FUN";\n', '\n', '    Controller controller;\n', '    address owner;\n', '\n', '    function setController(address _c) onlyOwner notFinalized {\n', '        controller = Controller(_c);\n', '    }\n', '\n', '    function balanceOf(address a) constant returns (uint) {\n', '        return controller.balanceOf(a);\n', '    }\n', '\n', '    function totalSupply() constant returns (uint) {\n', '        return controller.totalSupply();\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint) {\n', '        return controller.allowance(_owner, _spender);\n', '    }\n', '\n', '    function transfer(address _to, uint _value)\n', '    onlyPayloadSize(2)\n', '    returns (bool success) {\n', '       success = controller.transfer(msg.sender, _to, _value);\n', '        if (success) {\n', '            Transfer(msg.sender, _to, _value);\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value)\n', '    onlyPayloadSize(3)\n', '    returns (bool success) {\n', '       success = controller.transferFrom(msg.sender, _from, _to, _value);\n', '        if (success) {\n', '            Transfer(_from, _to, _value);\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint _value)\n', '    onlyPayloadSize(2)\n', '    returns (bool success) {\n', '        //promote safe user behavior\n', '        if (controller.allowance(msg.sender, _spender) > 0) throw;\n', '\n', '        success = controller.approve(msg.sender, _spender, _value);\n', '        if (success) {\n', '            Approval(msg.sender, _spender, _value);\n', '        }\n', '    }\n', '\n', '    function increaseApproval (address _spender, uint _addedValue)\n', '    onlyPayloadSize(2)\n', '    returns (bool success) {\n', '        success = controller.increaseApproval(msg.sender, _spender, _addedValue);\n', '        if (success) {\n', '            uint newval = controller.allowance(msg.sender, _spender);\n', '            Approval(msg.sender, _spender, newval);\n', '        }\n', '    }\n', '\n', '    function decreaseApproval (address _spender, uint _subtractedValue)\n', '    onlyPayloadSize(2)\n', '    returns (bool success) {\n', '        success = controller.decreaseApproval(msg.sender, _spender, _subtractedValue);\n', '        if (success) {\n', '            uint newval = controller.allowance(msg.sender, _spender);\n', '            Approval(msg.sender, _spender, newval);\n', '        }\n', '    }\n', '\n', '    modifier onlyPayloadSize(uint numwords) {\n', '    assert(msg.data.length == numwords * 32 + 4);\n', '        _;\n', '    }\n', '\n', '    function burn(uint _amount) {\n', '        controller.burn(msg.sender, _amount);\n', '        Transfer(msg.sender, 0x0, _amount);\n', '    }\n', '}\n', '\n', 'contract Controller is Owned, Finalizable {\n', '    Ledger public ledger;\n', '    address public token;\n', '\n', '    function setToken(address _token) onlyOwner {\n', '        token = _token;\n', '    }\n', '\n', '    function setLedger(address _ledger) onlyOwner {\n', '        ledger = Ledger(_ledger);\n', '    }\n', '\n', '    modifier onlyToken() {\n', '        if (msg.sender != token) throw;\n', '        _;\n', '    }\n', '\n', '    function totalSupply() constant returns (uint) {\n', '        return ledger.totalSupply();\n', '    }\n', '\n', '    function balanceOf(address _a) onlyToken constant returns (uint) {\n', '        return Ledger(ledger).balanceOf(_a);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender)\n', '    onlyToken constant returns (uint) {\n', '        return ledger.allowance(_owner, _spender);\n', '    }\n', '\n', '    function transfer(address _from, address _to, uint _value)\n', '    onlyToken\n', '    returns (bool success) {\n', '        return ledger.transfer(_from, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _spender, address _from, address _to, uint _value)\n', '    onlyToken\n', '    returns (bool success) {\n', '        return ledger.transferFrom(_spender, _from, _to, _value);\n', '    }\n', '\n', '    function approve(address _owner, address _spender, uint _value)\n', '    onlyToken\n', '    returns (bool success) {\n', '        return ledger.approve(_owner, _spender, _value);\n', '    }\n', '\n', '    function increaseApproval (address _owner, address _spender, uint _addedValue)\n', '    onlyToken\n', '    returns (bool success) {\n', '        return ledger.increaseApproval(_owner, _spender, _addedValue);\n', '    }\n', '\n', '    function decreaseApproval (address _owner, address _spender, uint _subtractedValue)\n', '    onlyToken\n', '    returns (bool success) {\n', '        return ledger.decreaseApproval(_owner, _spender, _subtractedValue);\n', '    }\n', '\n', '\n', '    function burn(address _owner, uint _amount) onlyToken {\n', '        ledger.burn(_owner, _amount);\n', '    }\n', '}\n', '\n', 'contract Ledger is Owned, SafeMath, Finalizable {\n', '    address public controller;\n', '    mapping(address => uint) public balanceOf;\n', '    mapping (address => mapping (address => uint)) public allowance;\n', '    uint public totalSupply;\n', '\n', '    function setController(address _controller) onlyOwner notFinalized {\n', '        controller = _controller;\n', '    }\n', '\n', '    modifier onlyController() {\n', '        if (msg.sender != controller) throw;\n', '        _;\n', '    }\n', '\n', '    function transfer(address _from, address _to, uint _value)\n', '    onlyController\n', '    returns (bool success) {\n', '        if (balanceOf[_from] < _value) return false;\n', '\n', '        balanceOf[_from] = safeSub(balanceOf[_from], _value);\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _spender, address _from, address _to, uint _value)\n', '    onlyController\n', '    returns (bool success) {\n', '        if (balanceOf[_from] < _value) return false;\n', '\n', '        var allowed = allowance[_from][_spender];\n', '        if (allowed < _value) return false;\n', '\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '        balanceOf[_from] = safeSub(balanceOf[_from], _value);\n', '        allowance[_from][_spender] = safeSub(allowed, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _owner, address _spender, uint _value)\n', '    onlyController\n', '    returns (bool success) {\n', '        //require user to set to zero before resetting to nonzero\n', '        if ((_value != 0) && (allowance[_owner][_spender] != 0)) {\n', '            return false;\n', '        }\n', '\n', '        allowance[_owner][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval (address _owner, address _spender, uint _addedValue)\n', '    onlyController\n', '    returns (bool success) {\n', '        uint oldValue = allowance[_owner][_spender];\n', '        allowance[_owner][_spender] = safeAdd(oldValue, _addedValue);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval (address _owner, address _spender, uint _subtractedValue)\n', '    onlyController\n', '    returns (bool success) {\n', '        uint oldValue = allowance[_owner][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowance[_owner][_spender] = 0;\n', '        } else {\n', '            allowance[_owner][_spender] = safeSub(oldValue, _subtractedValue);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    event LogMint(address indexed owner, uint amount);\n', '    event LogMintingStopped();\n', '\n', '    function mint(address _a, uint _amount) onlyOwner mintingActive {\n', '        balanceOf[_a] += _amount;\n', '        totalSupply += _amount;\n', '        LogMint(_a, _amount);\n', '    }\n', '\n', '    function multiMint(uint[] bits) onlyOwner mintingActive {\n', '        for (uint i=0; i<bits.length; i++) {\n', '\t    address a = address(bits[i]>>96);\n', '\t    uint amount = bits[i]&((1<<96) - 1);\n', '\t    mint(a, amount);\n', '        }\n', '    }\n', '\n', '    bool public mintingStopped;\n', '\n', '    function stopMinting() onlyOwner {\n', '        mintingStopped = true;\n', '        LogMintingStopped();\n', '    }\n', '\n', '    modifier mintingActive() {\n', '        if (mintingStopped) throw;\n', '        _;\n', '    }\n', '\n', '    function burn(address _owner, uint _amount) onlyController {\n', '        balanceOf[_owner] = safeSub(balanceOf[_owner], _amount);\n', '        totalSupply = safeSub(totalSupply, _amount);\n', '    }\n', '}']