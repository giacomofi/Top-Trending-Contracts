['pragma solidity ^0.4.4;\n', '\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) throw;\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) throw;\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract StandardToken is ERC20, SafeMath {\n', '\n', '  mapping(address => uint) balances;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transfer(address _to, uint _value) returns (bool success) {\n', '    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '    \n', '    balances[_to] = safeAdd(balances[_to], _value);\n', '    balances[_from] = safeSub(balances[_from], _value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract Lockable is Ownable {\n', '    bool donationLock;\n', '\n', '    function Lockable() {\n', '        donationLock = false;\n', '    }\n', '\n', '    modifier onlyWhenDonationOpen {\n', '        if (donationLock) throw;\n', '        _;\n', '    }\n', '\n', '    function stopAcceptingDonation() onlyOwner {\n', '        if (donationLock) throw;\n', '        donationLock = true;\n', '    }\n', '\n', '    function startAcceptingDonation() onlyOwner {\n', '        if (!donationLock) throw;\n', '        donationLock = false;\n', '    }\n', '}\n', '\n', 'contract SmartPoolToken is StandardToken, Lockable {\n', '    string public name = "SmartPool";\n', '    string public symbol = "SPT";\n', '    uint public decimals = 0;\n', '\n', '    address public beneficial;\n', '    mapping(address => uint) public donationAmountInWei;\n', '    mapping(uint => address) public donors;\n', '    uint public donorCount;\n', '    uint public totalFundRaised;\n', '    uint _rate;\n', '\n', '    uint ETHER = 1 ether;\n', '\n', '    event TokenMint(address newTokenHolder, uint tokensAmount);\n', '    event Donated(address indexed from, uint amount, uint tokensAmount, uint blockNumber);\n', '\n', '    function SmartPoolToken(uint preminedTokens, address wallet) {\n', '        totalSupply = 0;\n', '        _rate = 100;\n', '        beneficial = wallet;\n', '        totalFundRaised = 0;\n', '        mintTokens(owner, safeMul(preminedTokens, ETHER / _rate));\n', '    }\n', '\n', '    function mintTokens(address newTokenHolder, uint weiAmount) internal returns (uint){\n', '        uint tokensAmount = safeMul(_rate, weiAmount) / ETHER;\n', '\n', '        if (tokensAmount >= 1) {\n', '            balances[newTokenHolder] = safeAdd(\n', '                balances[newTokenHolder], tokensAmount);\n', '            totalSupply = safeAdd(totalSupply, tokensAmount);\n', '\n', '            TokenMint(newTokenHolder, tokensAmount);\n', '            return tokensAmount;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function () payable onlyWhenDonationOpen {\n', '        uint weiAmount = msg.value;\n', '        if (weiAmount <= 0) throw;\n', '\n', '        if (donationAmountInWei[msg.sender] == 0) {\n', '            donors[donorCount] = msg.sender;\n', '            donorCount += 1;\n', '        }\n', '\n', '        donationAmountInWei[msg.sender] = safeAdd(\n', '            donationAmountInWei[msg.sender], weiAmount);\n', '        totalFundRaised = safeAdd(\n', '            totalFundRaised, weiAmount);\n', '        uint tokensCreated = mintTokens(msg.sender, weiAmount);\n', '        Donated(msg.sender, weiAmount, tokensCreated, block.number);\n', '    }\n', '\n', '    function getDonationAmount() constant returns (uint donation) {\n', '        return donationAmountInWei[msg.sender];\n', '    }\n', '\n', '    function getTokenBalance() constant returns (uint tokens) {\n', '        return balances[msg.sender];\n', '    }\n', '\n', '    function tokenRate() constant returns (uint tokenRate) {\n', '        return _rate;\n', '    }\n', '\n', '    function changeRate(uint newRate) onlyOwner returns (bool success) {\n', '        _rate = newRate;\n', '        return true;\n', '    }\n', '\n', '    function withdraw() onlyOwner {\n', '        if (!beneficial.send(this.balance)) {\n', '            throw;\n', '        }\n', '    }\n', '}']