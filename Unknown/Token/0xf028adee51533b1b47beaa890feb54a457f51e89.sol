['pragma solidity ^0.4.16;\n', '\n', 'contract BMToken {\n', '    string  public  name = "BMChain Token";\n', '    string  public  symbol = "BMT";\n', '    uint256  public  decimals = 18;\n', '\n', '    uint256 _supply = 0;\n', '    mapping (address => uint256) _balances;\n', '    mapping (address => mapping (address => uint256)) _approvals;\n', '\n', '    event Transfer( address indexed from, address indexed to, uint value);\n', '    event Approval( address indexed owner, address indexed spender, uint value);\n', '\n', '    address ico_contract;\n', '    address public owner;\n', '\n', '    function BMToken(){\n', '        ico_contract = address(0x0);\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier isOwner()\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address new_owner) isOwner\n', '    {\n', '        assert(new_owner!=address(0x0));\n', '        assert(new_owner!=address(this));\n', '        owner = new_owner;\n', '    }\n', '\n', '    function setICOContract(address new_address) isOwner\n', '    {\n', '        assert(ico_contract==address(0x0));\n', '        assert(new_address!=address(0x0));\n', '        assert(new_address!=address(this));\n', '        ico_contract = new_address;\n', '    }\n', '\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function totalSupply() constant external returns (uint256) {\n', '        return _supply;\n', '    }\n', '\n', '    function balanceOf(address src) constant external returns (uint256) {\n', '        return _balances[src];\n', '    }\n', '\n', '    function allowance(address src, address where) constant external returns (uint256) {\n', '        return _approvals[src][where];\n', '    }\n', '\n', '    function transfer(address where, uint amount) external returns (bool) {\n', '        assert(where != address(this));\n', '        assert(where != address(0));\n', '        assert(_balances[msg.sender] >= amount);\n', '\n', '        _balances[msg.sender] = sub(_balances[msg.sender], amount);\n', '        _balances[where] = add(_balances[where], amount);\n', '\n', '        Transfer(msg.sender, where, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address src, address where, uint amount) external returns (bool) {\n', '        assert(where != address(this));\n', '        assert(where != address(0));\n', '        assert(_balances[src] >= amount);\n', '        assert(_approvals[src][msg.sender] >= amount);\n', '\n', '        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], amount);\n', '        _balances[src] = sub(_balances[src], amount);\n', '        _balances[where] = add(_balances[where], amount);\n', '\n', '        Transfer(src, where, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address where, uint256 amount) external returns (bool) {\n', '        assert(where != address(this));\n', '        assert(where != address(0));\n', '        _approvals[msg.sender][where] = amount;\n', '\n', '        Approval(msg.sender, where, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function mintTokens(address holder, uint256 amount) external\n', '    {\n', '        assert(msg.sender == ico_contract);\n', '        _balances[holder] = add(_balances[holder], amount);\n', '        _supply = add(_supply, amount);\n', '        Transfer(address(0x0), holder, amount);\n', '    }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', 'contract BMToken {\n', '    string  public  name = "BMChain Token";\n', '    string  public  symbol = "BMT";\n', '    uint256  public  decimals = 18;\n', '\n', '    uint256 _supply = 0;\n', '    mapping (address => uint256) _balances;\n', '    mapping (address => mapping (address => uint256)) _approvals;\n', '\n', '    event Transfer( address indexed from, address indexed to, uint value);\n', '    event Approval( address indexed owner, address indexed spender, uint value);\n', '\n', '    address ico_contract;\n', '    address public owner;\n', '\n', '    function BMToken(){\n', '        ico_contract = address(0x0);\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier isOwner()\n', '    {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address new_owner) isOwner\n', '    {\n', '        assert(new_owner!=address(0x0));\n', '        assert(new_owner!=address(this));\n', '        owner = new_owner;\n', '    }\n', '\n', '    function setICOContract(address new_address) isOwner\n', '    {\n', '        assert(ico_contract==address(0x0));\n', '        assert(new_address!=address(0x0));\n', '        assert(new_address!=address(this));\n', '        ico_contract = new_address;\n', '    }\n', '\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function totalSupply() constant external returns (uint256) {\n', '        return _supply;\n', '    }\n', '\n', '    function balanceOf(address src) constant external returns (uint256) {\n', '        return _balances[src];\n', '    }\n', '\n', '    function allowance(address src, address where) constant external returns (uint256) {\n', '        return _approvals[src][where];\n', '    }\n', '\n', '    function transfer(address where, uint amount) external returns (bool) {\n', '        assert(where != address(this));\n', '        assert(where != address(0));\n', '        assert(_balances[msg.sender] >= amount);\n', '\n', '        _balances[msg.sender] = sub(_balances[msg.sender], amount);\n', '        _balances[where] = add(_balances[where], amount);\n', '\n', '        Transfer(msg.sender, where, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address src, address where, uint amount) external returns (bool) {\n', '        assert(where != address(this));\n', '        assert(where != address(0));\n', '        assert(_balances[src] >= amount);\n', '        assert(_approvals[src][msg.sender] >= amount);\n', '\n', '        _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], amount);\n', '        _balances[src] = sub(_balances[src], amount);\n', '        _balances[where] = add(_balances[where], amount);\n', '\n', '        Transfer(src, where, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address where, uint256 amount) external returns (bool) {\n', '        assert(where != address(this));\n', '        assert(where != address(0));\n', '        _approvals[msg.sender][where] = amount;\n', '\n', '        Approval(msg.sender, where, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function mintTokens(address holder, uint256 amount) external\n', '    {\n', '        assert(msg.sender == ico_contract);\n', '        _balances[holder] = add(_balances[holder], amount);\n', '        _supply = add(_supply, amount);\n', '        Transfer(address(0x0), holder, amount);\n', '    }\n', '}']
