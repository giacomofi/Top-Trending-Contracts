['pragma solidity ^0.4.11;\n', 'contract owned {\n', '    address public owner;\n', '    address public authorisedContract;\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    modifier onlyAuthorisedAddress{\n', '        require(msg.sender == authorisedContract);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '    modifier onlyPayloadSize(uint size) {\n', '     assert(msg.data.length == size + 4);\n', '     _;\n', '    }\n', '}\n', '\n', 'contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n', '\n', 'contract MyToken is owned {\n', '    /* Public variables of the token */\n', '    string public name = "DankToken";\n', '    string public symbol = "DANK";\n', '    uint8 public decimals = 18;\n', '    uint256 _totalSupply;\n', '    uint256 public amountRaised = 0;\n', '    uint256 public amountOfTokensPerEther = 500;\n', '        /* this makes an array with all frozen accounts. This is needed so voters can not send their funds while the vote is going on and they have already voted      */\n', '    mapping (address => bool) public frozenAccounts;\n', '        /* This creates an array with all balances */ \n', '    mapping (address => uint256) _balanceOf;\n', '    mapping (address => mapping (address => uint256)) _allowance;\n', '    bool public crowdsaleClosed = false;\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event FrozenFunds(address target, bool frozen);\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function MyToken() {\n', '        _balanceOf[msg.sender] = 4000000000000000000000;              \n', '        _totalSupply = 4000000000000000000000;                 \n', '        Transfer(this, msg.sender,4000000000000000000000);\n', '    }\n', '    function changeAuthorisedContract(address target) onlyOwner\n', '    {\n', '        authorisedContract = target;\n', '    }\n', '    function() payable{\n', '        require(!crowdsaleClosed);\n', '        uint amount = msg.value;\n', '        amountRaised += amount;\n', '        uint256 totalTokens = amount * amountOfTokensPerEther;\n', '        _balanceOf[msg.sender] += totalTokens;\n', '        _totalSupply += totalTokens;\n', '        Transfer(this,msg.sender, totalTokens);\n', '    }\n', '     function totalSupply() constant returns (uint TotalSupply){\n', '        TotalSupply = _totalSupply;\n', '     }\n', '      function balanceOf(address _owner) constant returns (uint balance) {\n', '        return _balanceOf[_owner];\n', '     }\n', '     function closeCrowdsale() onlyOwner{\n', '         crowdsaleClosed = true;\n', '     }\n', '     function openCrowdsale() onlyOwner{\n', '         crowdsaleClosed = false;\n', '     }\n', '     function changePrice(uint newAmountOfTokensPerEther) onlyOwner{\n', '         require(newAmountOfTokensPerEther <= 500);\n', '         amountOfTokensPerEther = newAmountOfTokensPerEther;\n', '     }\n', '     function withdrawal(uint256 amountOfWei) onlyOwner{\n', '         if(owner.send(amountOfWei)){}\n', '     }\n', '     function freezeAccount(address target, bool freeze) onlyAuthorisedAddress\n', '     {\n', '         frozenAccounts[target] = freeze;\n', '         FrozenFunds(target, freeze);\n', '     } \n', '     \n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2*32) {\n', '        require(!frozenAccounts[msg.sender]);\n', '        require(_balanceOf[msg.sender] > _value);          // Check if the sender has enough\n', '        require(_balanceOf[_to] + _value > _balanceOf[_to]); // Check for overflows\n', '        _balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n', '        _balanceOf[_to] += _value;                            // Add the same to the recipient\n', '        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n', '    }\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value)onlyPayloadSize(2*32)\n', '        returns (bool success)  {\n', '        _allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    } \n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success)  {\n', '        require(!frozenAccounts[_from]);\n', '        require(_balanceOf[_from] > _value);                 // Check if the sender has enough\n', '        require(_balanceOf[_to] + _value > _balanceOf[_to]);  // Check for overflows\n', '        require(_allowance[_from][msg.sender] >= _value);     // Check allowance\n', '        _balanceOf[_from] -= _value;                           // Subtract from the sender\n', '        _balanceOf[_to] += _value;                             // Add the same to the recipient\n', '        _allowance[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '        return _allowance[_owner][_spender];\n', '    }\n', '}']