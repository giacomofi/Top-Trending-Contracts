['pragma solidity ^0.4.11;\n', '\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) constant returns (uint256);\n', '    function transfer(address to, uint256 value) returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) returns (bool success);\n', '    function approve(address spender, uint256 value) returns (bool success);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @notice Transfer ownership from `owner` to `newOwner`\n', '    /// @param _newOwner The new contract owner\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        if (_newOwner != address(0)) {\n', '            newOwner = _newOwner;\n', '        }\n', '    }\n', '\n', '    /// @notice accept ownership of the contract\n', '    function acceptOwnership() {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract Administrable is Ownable {\n', '\n', '    event AdminstratorAdded(address adminAddress);\n', '    event AdminstratorRemoved(address adminAddress);\n', '\n', '    mapping (address => bool) public administrators;\n', '\n', '    modifier onlyAdministrator() {\n', '        require(administrators[msg.sender] || owner == msg.sender); // owner is an admin by default\n', '        _;\n', '    }\n', '\n', '    /// @notice Add an administrator\n', '    /// @param _adminAddress The new administrator address\n', '    function addAdministrators(address _adminAddress) onlyOwner {\n', '        administrators[_adminAddress] = true;\n', '        AdminstratorAdded(_adminAddress);\n', '    }\n', '\n', '    /// @notice Remove an administrator\n', '    /// @param _adminAddress The administrator address to remove\n', '    function removeAdministrators(address _adminAddress) onlyOwner {\n', '        delete administrators[_adminAddress];\n', '        AdminstratorRemoved(_adminAddress);\n', '    }\n', '}\n', '\n', '/// @title Gimli Token Contract.\n', 'contract GimliToken is ERC20, SafeMath, Ownable {\n', '\n', '\n', '    /*************************\n', '    **** Global variables ****\n', '    *************************/\n', '\n', '    uint8 public constant decimals = 8;\n', '    string public constant name = "Gimli Token";\n', '    string public constant symbol = "GIM";\n', '    string public constant version = &#39;v1&#39;;\n', '\n', '    /// total amount of tokens\n', '    uint256 public constant UNIT = 10**uint256(decimals);\n', '    uint256 constant MILLION_GML = 10**6 * UNIT; // can&#39;t use `safeMul` with constant\n', '    /// Should include CROWDSALE_AMOUNT and VESTING_X_AMOUNT\n', '    uint256 public constant TOTAL_SUPPLY = 150 * MILLION_GML; // can&#39;t use `safeMul` with constant;\n', '\n', '    /// balances indexed by address\n', '    mapping (address => uint256) balances;\n', '\n', '    /// allowances indexed by owner and spender\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    bool public transferable = false;\n', '\n', '    /*********************\n', '    **** Transactions ****\n', '    *********************/\n', '\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        require(transferable);\n', '\n', '        require(balances[msg.sender] >= _value && _value >=0);\n', '\n', '\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        require(transferable);\n', '\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value >= 0);\n', '\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /****************\n', '    **** Getters ****\n', '    ****************/\n', '\n', '    /// @notice Get balance of an address\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /// @notice Get tokens allowed to spent by `_spender`\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '/// @title Gimli Crowdsale Contract.\n', 'contract GimliCrowdsale is SafeMath, GimliToken {\n', '\n', '    address public constant MULTISIG_WALLET_ADDRESS = 0xc79ab28c5c03f1e7fbef056167364e6782f9ff4f;\n', '    address public constant LOCKED_ADDRESS = 0xABcdEFABcdEFabcdEfAbCdefabcdeFABcDEFabCD;\n', '\n', '    // crowdsale\n', '    uint256 public constant CROWDSALE_AMOUNT = 80 * MILLION_GML; // Should not include vested amount\n', '    uint256 public constant START_DATE = 1505736000; //  (epoch timestamp)\n', '    uint256 public constant END_DATE = 1508500800; // TODO (epoch timestamp)\n', '    uint256 public constant CROWDSALE_PRICE = 700; // 700 GML / ETH\n', '    uint256 public constant VESTING_1_AMOUNT = 10 * MILLION_GML; // GIM reserve fund\n', '    uint256 public constant VESTING_1_DATE = 1537272000; // TODO (epoch timestamp)\n', '    uint256 public constant VESTING_2_AMOUNT = 30 * MILLION_GML; // Team\n', '    uint256 public constant VESTING_2_DATE = 1568808000; // TODO (epoch timestamp)\n', '    bool public vesting1Withdrawn = false;\n', '    bool public vesting2Withdrawn = false;\n', '    bool public crowdsaleCanceled = false;\n', '    uint256 public soldAmount; // GIM\n', '    uint256 public paidAmount; // ETH\n', '\n', '    /// @notice `msg.sender` invest `msg.value`\n', '    function() payable {\n', '        require(!crowdsaleCanceled);\n', '\n', '        require(msg.value > 0);\n', '        // check date\n', '        require(block.timestamp >= START_DATE && block.timestamp <= END_DATE);\n', '\n', '        // calculate and check quantity\n', '        uint256 quantity = safeDiv(safeMul(msg.value, CROWDSALE_PRICE), 10**(18-uint256(decimals)));\n', '        require(safeSub(balances[this], quantity) >= 0);\n', '\n', '        require(MULTISIG_WALLET_ADDRESS.send(msg.value));\n', '\n', '        // update balances\n', '        balances[this] = safeSub(balances[this], quantity);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], quantity);\n', '        soldAmount = safeAdd(soldAmount, quantity);\n', '        paidAmount = safeAdd(paidAmount, msg.value);\n', '\n', '        Transfer(this, msg.sender, quantity);\n', '    }\n', '\n', '    /// @notice returns non-sold tokens to owner\n', '    function  closeCrowdsale() onlyOwner {\n', '        // check if closable\n', '        require(block.timestamp > END_DATE || crowdsaleCanceled || balances[this] == 0);\n', '\n', '        // enable token transfer\n', '        transferable = true;\n', '\n', '        // update balances\n', '        if (balances[this] > 0) {\n', '            uint256 amount = balances[this];\n', '            balances[MULTISIG_WALLET_ADDRESS] = safeAdd(balances[MULTISIG_WALLET_ADDRESS], amount);\n', '            balances[this] = 0;\n', '            Transfer(this, MULTISIG_WALLET_ADDRESS, amount);\n', '        }\n', '    }\n', '\n', '    /// @notice Terminate the crowdsale before END_DATE\n', '    function cancelCrowdsale() onlyOwner {\n', '        crowdsaleCanceled = true;\n', '    }\n', '\n', '    /// @notice Pre-allocate tokens to advisor or partner\n', '    /// @param _to The pre-allocation destination\n', '    /// @param _value The amount of token to be allocated\n', '    /// @param _price ETH paid for these tokens\n', '    function preAllocate(address _to, uint256 _value, uint256 _price) onlyOwner {\n', '        require(block.timestamp < START_DATE);\n', '\n', '        balances[this] = safeSub(balances[this], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        soldAmount = safeAdd(soldAmount, _value);\n', '        paidAmount = safeAdd(paidAmount, _price);\n', '\n', '        Transfer(this, _to, _value);\n', '    }\n', '\n', '    /// @notice Send vested amount to _destination\n', '    /// @param _destination The address of the recipient\n', '    /// @return Whether the release was successful or not\n', '    function releaseVesting(address _destination) onlyOwner returns (bool success) {\n', '        if (block.timestamp > VESTING_1_DATE && vesting1Withdrawn == false) {\n', '            balances[LOCKED_ADDRESS] = safeSub(balances[LOCKED_ADDRESS], VESTING_1_AMOUNT);\n', '            balances[_destination] = safeAdd(balances[_destination], VESTING_1_AMOUNT);\n', '            vesting1Withdrawn = true;\n', '            Transfer(LOCKED_ADDRESS, _destination, VESTING_1_AMOUNT);\n', '            return true;\n', '        }\n', '        if (block.timestamp > VESTING_2_DATE && vesting2Withdrawn == false) {\n', '            balances[LOCKED_ADDRESS] = safeSub(balances[LOCKED_ADDRESS], VESTING_2_AMOUNT);\n', '            balances[_destination] = safeAdd(balances[_destination], VESTING_2_AMOUNT);\n', '            vesting2Withdrawn = true;\n', '            Transfer(LOCKED_ADDRESS, _destination, VESTING_2_AMOUNT);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @notice transfer out any accidentally sent ERC20 tokens\n', '    /// @param tokenAddress Address of the ERC20 contract\n', '    /// @param amount The amount of token to be transfered\n', '    function transferOtherERC20Token(address tokenAddress, uint256 amount)\n', '      onlyOwner returns (bool success)\n', '    {\n', '        // can&#39;t be used for GIM token\n', '        require(tokenAddress != address(this) || transferable);\n', '        return ERC20(tokenAddress).transfer(owner, amount);\n', '    }\n', '}\n', '\n', '/// @title Main Gimli contract.\n', 'contract Gimli is GimliCrowdsale, Administrable {\n', '\n', '    address public streamerContract;\n', '    uint256 public streamerContractMaxAmount;\n', '\n', '    event StreamerContractChanged(address newContractAddress, uint256 newMaxAmount);\n', '\n', '    /// @notice Gimli Contract constructor. `msg.sender` is the owner.\n', '    function Gimli() {\n', '        // Give the multisig wallet initial tokens\n', '        balances[MULTISIG_WALLET_ADDRESS] = safeAdd(balances[MULTISIG_WALLET_ADDRESS], TOTAL_SUPPLY - CROWDSALE_AMOUNT - VESTING_1_AMOUNT - VESTING_2_AMOUNT);\n', '        // Give the contract crowdsale amount\n', '        balances[this] = CROWDSALE_AMOUNT;\n', '        // Locked address\n', '        balances[LOCKED_ADDRESS] = VESTING_1_AMOUNT + VESTING_2_AMOUNT;\n', '        // For ERC20 compatibility\n', '        totalSupply = TOTAL_SUPPLY;\n', '    }\n', '\n', '    /// @notice authorize an address to transfer GIM on behalf an user\n', '    /// @param _contractAddress Address of GimliStreamer contract\n', '    /// @param _maxAmount The maximum amount that can be transfered by the contract\n', '    function setStreamerContract(\n', '        address _contractAddress,\n', '        uint256 _maxAmount) onlyAdministrator\n', '    {\n', '        // To change the maximum amount you first have to reduce it to 0`\n', '        require(_maxAmount == 0 || streamerContractMaxAmount == 0);\n', '\n', '        streamerContract = _contractAddress;\n', '        streamerContractMaxAmount = _maxAmount;\n', '\n', '        StreamerContractChanged(streamerContract, streamerContractMaxAmount);\n', '    }\n', '\n', '    /// @notice Called by a Gimli contract to transfer GIM\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferGIM(address _from, address _to, uint256 _amount) returns (bool success) {\n', '        require(msg.sender == streamerContract);\n', '        require(tx.origin == _from);\n', '        require(_amount <= streamerContractMaxAmount);\n', '\n', '        if (balances[_from] < _amount || _amount <= 0)\n', '            return false;\n', '\n', '        balances[_from] = safeSub(balances[_from], _amount);\n', '        balances[_to] = safeAdd(balances[_to], _amount);\n', '\n', '        Transfer(_from, _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) constant returns (uint256);\n', '    function transfer(address to, uint256 value) returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender) constant returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) returns (bool success);\n', '    function approve(address spender, uint256 value) returns (bool success);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @notice Transfer ownership from `owner` to `newOwner`\n', '    /// @param _newOwner The new contract owner\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        if (_newOwner != address(0)) {\n', '            newOwner = _newOwner;\n', '        }\n', '    }\n', '\n', '    /// @notice accept ownership of the contract\n', '    function acceptOwnership() {\n', '        require(msg.sender == newOwner);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract Administrable is Ownable {\n', '\n', '    event AdminstratorAdded(address adminAddress);\n', '    event AdminstratorRemoved(address adminAddress);\n', '\n', '    mapping (address => bool) public administrators;\n', '\n', '    modifier onlyAdministrator() {\n', '        require(administrators[msg.sender] || owner == msg.sender); // owner is an admin by default\n', '        _;\n', '    }\n', '\n', '    /// @notice Add an administrator\n', '    /// @param _adminAddress The new administrator address\n', '    function addAdministrators(address _adminAddress) onlyOwner {\n', '        administrators[_adminAddress] = true;\n', '        AdminstratorAdded(_adminAddress);\n', '    }\n', '\n', '    /// @notice Remove an administrator\n', '    /// @param _adminAddress The administrator address to remove\n', '    function removeAdministrators(address _adminAddress) onlyOwner {\n', '        delete administrators[_adminAddress];\n', '        AdminstratorRemoved(_adminAddress);\n', '    }\n', '}\n', '\n', '/// @title Gimli Token Contract.\n', 'contract GimliToken is ERC20, SafeMath, Ownable {\n', '\n', '\n', '    /*************************\n', '    **** Global variables ****\n', '    *************************/\n', '\n', '    uint8 public constant decimals = 8;\n', '    string public constant name = "Gimli Token";\n', '    string public constant symbol = "GIM";\n', "    string public constant version = 'v1';\n", '\n', '    /// total amount of tokens\n', '    uint256 public constant UNIT = 10**uint256(decimals);\n', "    uint256 constant MILLION_GML = 10**6 * UNIT; // can't use `safeMul` with constant\n", '    /// Should include CROWDSALE_AMOUNT and VESTING_X_AMOUNT\n', "    uint256 public constant TOTAL_SUPPLY = 150 * MILLION_GML; // can't use `safeMul` with constant;\n", '\n', '    /// balances indexed by address\n', '    mapping (address => uint256) balances;\n', '\n', '    /// allowances indexed by owner and spender\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    bool public transferable = false;\n', '\n', '    /*********************\n', '    **** Transactions ****\n', '    *********************/\n', '\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        require(transferable);\n', '\n', '        require(balances[msg.sender] >= _value && _value >=0);\n', '\n', '\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        require(transferable);\n', '\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value >= 0);\n', '\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /****************\n', '    **** Getters ****\n', '    ****************/\n', '\n', '    /// @notice Get balance of an address\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /// @notice Get tokens allowed to spent by `_spender`\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '/// @title Gimli Crowdsale Contract.\n', 'contract GimliCrowdsale is SafeMath, GimliToken {\n', '\n', '    address public constant MULTISIG_WALLET_ADDRESS = 0xc79ab28c5c03f1e7fbef056167364e6782f9ff4f;\n', '    address public constant LOCKED_ADDRESS = 0xABcdEFABcdEFabcdEfAbCdefabcdeFABcDEFabCD;\n', '\n', '    // crowdsale\n', '    uint256 public constant CROWDSALE_AMOUNT = 80 * MILLION_GML; // Should not include vested amount\n', '    uint256 public constant START_DATE = 1505736000; //  (epoch timestamp)\n', '    uint256 public constant END_DATE = 1508500800; // TODO (epoch timestamp)\n', '    uint256 public constant CROWDSALE_PRICE = 700; // 700 GML / ETH\n', '    uint256 public constant VESTING_1_AMOUNT = 10 * MILLION_GML; // GIM reserve fund\n', '    uint256 public constant VESTING_1_DATE = 1537272000; // TODO (epoch timestamp)\n', '    uint256 public constant VESTING_2_AMOUNT = 30 * MILLION_GML; // Team\n', '    uint256 public constant VESTING_2_DATE = 1568808000; // TODO (epoch timestamp)\n', '    bool public vesting1Withdrawn = false;\n', '    bool public vesting2Withdrawn = false;\n', '    bool public crowdsaleCanceled = false;\n', '    uint256 public soldAmount; // GIM\n', '    uint256 public paidAmount; // ETH\n', '\n', '    /// @notice `msg.sender` invest `msg.value`\n', '    function() payable {\n', '        require(!crowdsaleCanceled);\n', '\n', '        require(msg.value > 0);\n', '        // check date\n', '        require(block.timestamp >= START_DATE && block.timestamp <= END_DATE);\n', '\n', '        // calculate and check quantity\n', '        uint256 quantity = safeDiv(safeMul(msg.value, CROWDSALE_PRICE), 10**(18-uint256(decimals)));\n', '        require(safeSub(balances[this], quantity) >= 0);\n', '\n', '        require(MULTISIG_WALLET_ADDRESS.send(msg.value));\n', '\n', '        // update balances\n', '        balances[this] = safeSub(balances[this], quantity);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], quantity);\n', '        soldAmount = safeAdd(soldAmount, quantity);\n', '        paidAmount = safeAdd(paidAmount, msg.value);\n', '\n', '        Transfer(this, msg.sender, quantity);\n', '    }\n', '\n', '    /// @notice returns non-sold tokens to owner\n', '    function  closeCrowdsale() onlyOwner {\n', '        // check if closable\n', '        require(block.timestamp > END_DATE || crowdsaleCanceled || balances[this] == 0);\n', '\n', '        // enable token transfer\n', '        transferable = true;\n', '\n', '        // update balances\n', '        if (balances[this] > 0) {\n', '            uint256 amount = balances[this];\n', '            balances[MULTISIG_WALLET_ADDRESS] = safeAdd(balances[MULTISIG_WALLET_ADDRESS], amount);\n', '            balances[this] = 0;\n', '            Transfer(this, MULTISIG_WALLET_ADDRESS, amount);\n', '        }\n', '    }\n', '\n', '    /// @notice Terminate the crowdsale before END_DATE\n', '    function cancelCrowdsale() onlyOwner {\n', '        crowdsaleCanceled = true;\n', '    }\n', '\n', '    /// @notice Pre-allocate tokens to advisor or partner\n', '    /// @param _to The pre-allocation destination\n', '    /// @param _value The amount of token to be allocated\n', '    /// @param _price ETH paid for these tokens\n', '    function preAllocate(address _to, uint256 _value, uint256 _price) onlyOwner {\n', '        require(block.timestamp < START_DATE);\n', '\n', '        balances[this] = safeSub(balances[this], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        soldAmount = safeAdd(soldAmount, _value);\n', '        paidAmount = safeAdd(paidAmount, _price);\n', '\n', '        Transfer(this, _to, _value);\n', '    }\n', '\n', '    /// @notice Send vested amount to _destination\n', '    /// @param _destination The address of the recipient\n', '    /// @return Whether the release was successful or not\n', '    function releaseVesting(address _destination) onlyOwner returns (bool success) {\n', '        if (block.timestamp > VESTING_1_DATE && vesting1Withdrawn == false) {\n', '            balances[LOCKED_ADDRESS] = safeSub(balances[LOCKED_ADDRESS], VESTING_1_AMOUNT);\n', '            balances[_destination] = safeAdd(balances[_destination], VESTING_1_AMOUNT);\n', '            vesting1Withdrawn = true;\n', '            Transfer(LOCKED_ADDRESS, _destination, VESTING_1_AMOUNT);\n', '            return true;\n', '        }\n', '        if (block.timestamp > VESTING_2_DATE && vesting2Withdrawn == false) {\n', '            balances[LOCKED_ADDRESS] = safeSub(balances[LOCKED_ADDRESS], VESTING_2_AMOUNT);\n', '            balances[_destination] = safeAdd(balances[_destination], VESTING_2_AMOUNT);\n', '            vesting2Withdrawn = true;\n', '            Transfer(LOCKED_ADDRESS, _destination, VESTING_2_AMOUNT);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @notice transfer out any accidentally sent ERC20 tokens\n', '    /// @param tokenAddress Address of the ERC20 contract\n', '    /// @param amount The amount of token to be transfered\n', '    function transferOtherERC20Token(address tokenAddress, uint256 amount)\n', '      onlyOwner returns (bool success)\n', '    {\n', "        // can't be used for GIM token\n", '        require(tokenAddress != address(this) || transferable);\n', '        return ERC20(tokenAddress).transfer(owner, amount);\n', '    }\n', '}\n', '\n', '/// @title Main Gimli contract.\n', 'contract Gimli is GimliCrowdsale, Administrable {\n', '\n', '    address public streamerContract;\n', '    uint256 public streamerContractMaxAmount;\n', '\n', '    event StreamerContractChanged(address newContractAddress, uint256 newMaxAmount);\n', '\n', '    /// @notice Gimli Contract constructor. `msg.sender` is the owner.\n', '    function Gimli() {\n', '        // Give the multisig wallet initial tokens\n', '        balances[MULTISIG_WALLET_ADDRESS] = safeAdd(balances[MULTISIG_WALLET_ADDRESS], TOTAL_SUPPLY - CROWDSALE_AMOUNT - VESTING_1_AMOUNT - VESTING_2_AMOUNT);\n', '        // Give the contract crowdsale amount\n', '        balances[this] = CROWDSALE_AMOUNT;\n', '        // Locked address\n', '        balances[LOCKED_ADDRESS] = VESTING_1_AMOUNT + VESTING_2_AMOUNT;\n', '        // For ERC20 compatibility\n', '        totalSupply = TOTAL_SUPPLY;\n', '    }\n', '\n', '    /// @notice authorize an address to transfer GIM on behalf an user\n', '    /// @param _contractAddress Address of GimliStreamer contract\n', '    /// @param _maxAmount The maximum amount that can be transfered by the contract\n', '    function setStreamerContract(\n', '        address _contractAddress,\n', '        uint256 _maxAmount) onlyAdministrator\n', '    {\n', '        // To change the maximum amount you first have to reduce it to 0`\n', '        require(_maxAmount == 0 || streamerContractMaxAmount == 0);\n', '\n', '        streamerContract = _contractAddress;\n', '        streamerContractMaxAmount = _maxAmount;\n', '\n', '        StreamerContractChanged(streamerContract, streamerContractMaxAmount);\n', '    }\n', '\n', '    /// @notice Called by a Gimli contract to transfer GIM\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferGIM(address _from, address _to, uint256 _amount) returns (bool success) {\n', '        require(msg.sender == streamerContract);\n', '        require(tx.origin == _from);\n', '        require(_amount <= streamerContractMaxAmount);\n', '\n', '        if (balances[_from] < _amount || _amount <= 0)\n', '            return false;\n', '\n', '        balances[_from] = safeSub(balances[_from], _amount);\n', '        balances[_to] = safeAdd(balances[_to], _amount);\n', '\n', '        Transfer(_from, _to, _amount);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '}']
