['pragma solidity ^0.4.13;\n', '// -------------------------------------------------\n', '// 0.4.13+commit.0fb4cb1a\n', '// EthPoker.io ERC20 PKT token contract\n', '// Contact <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8beaefe6e2e5cbeeffe3fbe4e0eef9a5e2e4">[email&#160;protected]</a> for any query\n', '// -------------------------------------------------\n', '// ERC Token Standard #20 Interface https://github.com/ethereum/EIPs/issues/20\n', '// -------------------------------------------------\n', '// Security, functional, code reviews completed 06/October/17 [passed OK]\n', '// Regression test cycle complete 06/October/17 [passed OK]\n', '// -------------------------------------------------\n', '\n', 'contract safeMath {\n', '  function safeMul(uint256 a, uint256 b) internal returns (uint256) {\n', '      uint256 c = a * b;\n', '      safeAssert(a == 0 || c / a == b);\n', '      return c;\n', '  }\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {\n', '      safeAssert(b > 0);\n', '      uint256 c = a / b;\n', '      safeAssert(a == b * c + a % b);\n', '      return c;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal returns (uint256) {\n', '      safeAssert(b <= a);\n', '      return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\n', '      uint256 c = a + b;\n', '      safeAssert(c>=a && c>=b);\n', '      return c;\n', '  }\n', '\n', '  function safeAssert(bool assertion) internal {\n', '      if (!assertion) revert();\n', '  }\n', '}\n', '\n', 'contract ERC20Interface is safeMath {\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '  function approve(address _spender, uint256 _value) returns (bool success);\n', '  function increaseApproval (address _spender, uint _addedValue) returns (bool success);\n', '  function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success);\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '  event Buy(address indexed _sender, uint256 _eth, uint256 _PKT);\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract PKTToken is safeMath, ERC20Interface {\n', '  // token setup variables\n', '  string  public constant standard              = "PKT";\n', '  string  public constant name                  = "ethPoker";\n', '  string  public constant symbol                = "PKT";\n', '  uint8   public constant decimals              = 4;                                  // 4 decimals for usability\n', '  uint256 public constant totalSupply           = 100000000000;                       // 10 million + 4 decimals (presale maximum capped) static supply\n', '\n', '  // token mappings\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '  // ERC20 standard token possible events, matched to ICO and preSale contracts\n', '  event Buy(address indexed _sender, uint256 _eth, uint256 _PKT);\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  // ERC20 token balanceOf query function\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '      return balances[_owner];\n', '  }\n', '\n', '  // ERC20 token transfer function with additional safety\n', '  function transfer(address _to, uint256 _amount) returns (bool success) {\n', '      require(!(_to == 0x0));\n', '      if ((balances[msg.sender] >= _amount)\n', '      && (_amount > 0)\n', '      && ((safeAdd(balances[_to],_amount) > balances[_to]))) {\n', '          balances[msg.sender] = safeSub(balances[msg.sender], _amount);\n', '          balances[_to] = safeAdd(balances[_to], _amount);\n', '          Transfer(msg.sender, _to, _amount);\n', '          return true;\n', '      } else {\n', '          return false;\n', '      }\n', '  }\n', '\n', '  // ERC20 token transferFrom function with additional safety\n', '  function transferFrom(\n', '      address _from,\n', '      address _to,\n', '      uint256 _amount) returns (bool success) {\n', '      require(!(_to == 0x0));\n', '      if ((balances[_from] >= _amount)\n', '      && (allowed[_from][msg.sender] >= _amount)\n', '      && (_amount > 0)\n', '      && (safeAdd(balances[_to],_amount) > balances[_to])) {\n', '          balances[_from] = safeSub(balances[_from], _amount);\n', '          allowed[_from][msg.sender] = safeSub((allowed[_from][msg.sender]),_amount);\n', '          balances[_to] = safeAdd(balances[_to], _amount);\n', '          Transfer(_from, _to, _amount);\n', '          return true;\n', '      } else {\n', '          return false;\n', '      }\n', '  }\n', '\n', '  // ERC20 allow _spender to withdraw, multiple times, up to the _value amount\n', '  function approve(address _spender, uint256 _amount) returns (bool success) {\n', '      //Fix for known double-spend https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#\n', '      //Input must either set allow amount to 0, or have 0 already set, to workaround issue\n', '\n', '      require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '      allowed[msg.sender][_spender] = _amount;\n', '      Approval(msg.sender, _spender, _amount);\n', '      return true;\n', '  }\n', '\n', '  // ERC20 return allowance for given owner spender pair\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '  }\n', '\n', '  // ERC20 Updated increase approval process (to prevent double-spend attack but remove need to zero allowance before setting)\n', '  function increaseApproval (address _spender, uint _addedValue) returns (bool success) {\n', '      allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender],_addedValue);\n', '\n', '      // report new approval amount\n', '      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '      return true;\n', '  }\n', '\n', '  // ERC20 Updated decrease approval process (to prevent double-spend attack but remove need to zero allowance before setting)\n', '  function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) {\n', '      uint oldValue = allowed[msg.sender][_spender];\n', '\n', '      if (_subtractedValue > oldValue) {\n', '        allowed[msg.sender][_spender] = 0;\n', '      } else {\n', '        allowed[msg.sender][_spender] = safeSub(oldValue,_subtractedValue);\n', '      }\n', '\n', '      // report new approval amount\n', '      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '      return true;\n', '  }\n', '\n', '  // ERC20 Standard default function to assign initial supply variables and send balance to creator for distribution to PKT presale and ICO contract\n', '  function PKTToken() {\n', '      balances[msg.sender] = totalSupply;\n', '  }\n', '}']