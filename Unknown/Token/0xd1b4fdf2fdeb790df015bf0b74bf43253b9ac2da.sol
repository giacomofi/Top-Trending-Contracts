['pragma solidity ^0.4.11;\n', '// Dr. Sebastian Buergel, Validity Labs AG\n', '\n', '// from https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control \n', ' * functions, this simplifies the implementation of "user permissions". \n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /** \n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner. \n', '   */\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to. \n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '// from https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Token.sol\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '\n', '// from https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/StandardToken.sol\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        //Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', '\n', '\n', '// wraps non-ERC20-conforming fundraising contracts (aka pure IOU ICO) in a standard ERC20 contract that is immediately tradable and usable via default tools.\n', '// this is again a pure IOU token but now having all the benefits of standard tokens.\n', 'contract ERC20nator is StandardToken, Ownable {\n', '\n', '    address public fundraiserAddress;\n', '    bytes public fundraiserCallData;\n', '\n', '    uint constant issueFeePercent = 2; // fee in percent that is collected for all paid in funds\n', '\n', '    event requestedRedeem(address indexed requestor, uint amount);\n', '    \n', '    event redeemed(address redeemer, uint amount);\n', '\n', '    // fallback function invests in fundraiser\n', '    // fee percentage is given to owner for providing this service\n', '    // remainder is invested in fundraiser\n', '    function() payable {\n', '        uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;\n', '\n', '        // pay fee to owner\n', '        if(!owner.send(msg.value - issuedTokens))\n', '            throw;\n', '        \n', '        // invest remainder into fundraiser\n', '        if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))\n', '            throw;\n', '\n', '        // issue tokens by increasing total supply and balance\n', '        totalSupply += issuedTokens;\n', '        balances[msg.sender] += issuedTokens;\n', '    }\n', '\n', '    // allow owner to set fundraiser target address\n', '    function setFundraiserAddress(address _fundraiserAddress) onlyOwner {\n', '        fundraiserAddress = _fundraiserAddress;\n', '    }\n', '\n', '    // allow owner to set call data to be sent along to fundraiser target address\n', '    function setFundraiserCallData(string _fundraiserCallData) onlyOwner {\n', '        fundraiserCallData = hexStrToBytes(_fundraiserCallData);\n', '    }\n', '\n', '    // this is just to inform the owner that a user wants to redeem some of their IOU tokens\n', '    function requestRedeem(uint _amount) {\n', '        requestedRedeem(msg.sender, _amount);\n', '    }\n', '\n', '    // this is just to inform the investor that the owner redeemed some of their IOU tokens\n', '    function redeem(uint _amount) onlyOwner{\n', '        redeemed(msg.sender, _amount);\n', '    }\n', '\n', '    // helper function to input bytes via remix\n', '    // from https://ethereum.stackexchange.com/a/13658/16\n', '    function hexStrToBytes(string _hexString) constant returns (bytes) {\n', '        //Check hex string is valid\n', '        if (bytes(_hexString)[0]!=&#39;0&#39; ||\n', '            bytes(_hexString)[1]!=&#39;x&#39; ||\n', '            bytes(_hexString).length%2!=0 ||\n', '            bytes(_hexString).length<4) {\n', '                throw;\n', '            }\n', '\n', '        bytes memory bytes_array = new bytes((bytes(_hexString).length-2)/2);\n', '        uint len = bytes(_hexString).length;\n', '        \n', '        for (uint i=2; i<len; i+=2) {\n', '            uint tetrad1=16;\n', '            uint tetrad2=16;\n', '\n', '            //left digit\n', '            if (uint(bytes(_hexString)[i])>=48 &&uint(bytes(_hexString)[i])<=57)\n', '                tetrad1=uint(bytes(_hexString)[i])-48;\n', '\n', '            //right digit\n', '            if (uint(bytes(_hexString)[i+1])>=48 &&uint(bytes(_hexString)[i+1])<=57)\n', '                tetrad2=uint(bytes(_hexString)[i+1])-48;\n', '\n', '            //left A->F\n', '            if (uint(bytes(_hexString)[i])>=65 &&uint(bytes(_hexString)[i])<=70)\n', '                tetrad1=uint(bytes(_hexString)[i])-65+10;\n', '\n', '            //right A->F\n', '            if (uint(bytes(_hexString)[i+1])>=65 &&uint(bytes(_hexString)[i+1])<=70)\n', '                tetrad2=uint(bytes(_hexString)[i+1])-65+10;\n', '\n', '            //left a->f\n', '            if (uint(bytes(_hexString)[i])>=97 &&uint(bytes(_hexString)[i])<=102)\n', '                tetrad1=uint(bytes(_hexString)[i])-97+10;\n', '\n', '            //right a->f\n', '            if (uint(bytes(_hexString)[i+1])>=97 &&uint(bytes(_hexString)[i+1])<=102)\n', '                tetrad2=uint(bytes(_hexString)[i+1])-97+10;\n', '\n', '            //Check all symbols are allowed\n', '            if (tetrad1==16 || tetrad2==16)\n', '                throw;\n', '\n', '            bytes_array[i/2-1]=byte(16*tetrad1 + tetrad2);\n', '        }\n', '\n', '        return bytes_array;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '// Dr. Sebastian Buergel, Validity Labs AG\n', '\n', '// from https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control \n', ' * functions, this simplifies the implementation of "user permissions". \n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /** \n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner. \n', '   */\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to. \n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '// from https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Token.sol\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '\n', '// from https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/StandardToken.sol\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', "        //Default assumes totalSupply can't be over max (2^256 - 1).\n", "        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', '\n', '\n', '// wraps non-ERC20-conforming fundraising contracts (aka pure IOU ICO) in a standard ERC20 contract that is immediately tradable and usable via default tools.\n', '// this is again a pure IOU token but now having all the benefits of standard tokens.\n', 'contract ERC20nator is StandardToken, Ownable {\n', '\n', '    address public fundraiserAddress;\n', '    bytes public fundraiserCallData;\n', '\n', '    uint constant issueFeePercent = 2; // fee in percent that is collected for all paid in funds\n', '\n', '    event requestedRedeem(address indexed requestor, uint amount);\n', '    \n', '    event redeemed(address redeemer, uint amount);\n', '\n', '    // fallback function invests in fundraiser\n', '    // fee percentage is given to owner for providing this service\n', '    // remainder is invested in fundraiser\n', '    function() payable {\n', '        uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;\n', '\n', '        // pay fee to owner\n', '        if(!owner.send(msg.value - issuedTokens))\n', '            throw;\n', '        \n', '        // invest remainder into fundraiser\n', '        if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))\n', '            throw;\n', '\n', '        // issue tokens by increasing total supply and balance\n', '        totalSupply += issuedTokens;\n', '        balances[msg.sender] += issuedTokens;\n', '    }\n', '\n', '    // allow owner to set fundraiser target address\n', '    function setFundraiserAddress(address _fundraiserAddress) onlyOwner {\n', '        fundraiserAddress = _fundraiserAddress;\n', '    }\n', '\n', '    // allow owner to set call data to be sent along to fundraiser target address\n', '    function setFundraiserCallData(string _fundraiserCallData) onlyOwner {\n', '        fundraiserCallData = hexStrToBytes(_fundraiserCallData);\n', '    }\n', '\n', '    // this is just to inform the owner that a user wants to redeem some of their IOU tokens\n', '    function requestRedeem(uint _amount) {\n', '        requestedRedeem(msg.sender, _amount);\n', '    }\n', '\n', '    // this is just to inform the investor that the owner redeemed some of their IOU tokens\n', '    function redeem(uint _amount) onlyOwner{\n', '        redeemed(msg.sender, _amount);\n', '    }\n', '\n', '    // helper function to input bytes via remix\n', '    // from https://ethereum.stackexchange.com/a/13658/16\n', '    function hexStrToBytes(string _hexString) constant returns (bytes) {\n', '        //Check hex string is valid\n', "        if (bytes(_hexString)[0]!='0' ||\n", "            bytes(_hexString)[1]!='x' ||\n", '            bytes(_hexString).length%2!=0 ||\n', '            bytes(_hexString).length<4) {\n', '                throw;\n', '            }\n', '\n', '        bytes memory bytes_array = new bytes((bytes(_hexString).length-2)/2);\n', '        uint len = bytes(_hexString).length;\n', '        \n', '        for (uint i=2; i<len; i+=2) {\n', '            uint tetrad1=16;\n', '            uint tetrad2=16;\n', '\n', '            //left digit\n', '            if (uint(bytes(_hexString)[i])>=48 &&uint(bytes(_hexString)[i])<=57)\n', '                tetrad1=uint(bytes(_hexString)[i])-48;\n', '\n', '            //right digit\n', '            if (uint(bytes(_hexString)[i+1])>=48 &&uint(bytes(_hexString)[i+1])<=57)\n', '                tetrad2=uint(bytes(_hexString)[i+1])-48;\n', '\n', '            //left A->F\n', '            if (uint(bytes(_hexString)[i])>=65 &&uint(bytes(_hexString)[i])<=70)\n', '                tetrad1=uint(bytes(_hexString)[i])-65+10;\n', '\n', '            //right A->F\n', '            if (uint(bytes(_hexString)[i+1])>=65 &&uint(bytes(_hexString)[i+1])<=70)\n', '                tetrad2=uint(bytes(_hexString)[i+1])-65+10;\n', '\n', '            //left a->f\n', '            if (uint(bytes(_hexString)[i])>=97 &&uint(bytes(_hexString)[i])<=102)\n', '                tetrad1=uint(bytes(_hexString)[i])-97+10;\n', '\n', '            //right a->f\n', '            if (uint(bytes(_hexString)[i+1])>=97 &&uint(bytes(_hexString)[i+1])<=102)\n', '                tetrad2=uint(bytes(_hexString)[i+1])-97+10;\n', '\n', '            //Check all symbols are allowed\n', '            if (tetrad1==16 || tetrad2==16)\n', '                throw;\n', '\n', '            bytes_array[i/2-1]=byte(16*tetrad1 + tetrad2);\n', '        }\n', '\n', '        return bytes_array;\n', '    }\n', '\n', '}']
