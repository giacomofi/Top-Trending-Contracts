['pragma solidity ^0.4.11;\n', '\n', '\n', '\n', 'contract Token \n', '{\n', '\n', '    \n', '    function totalSupply() constant returns (uint256 ) {\n', '      return;\n', '    }\n', '\n', '    \n', '    \n', '    function balanceOf(address ) constant returns (uint256 ) {\n', '      return;\n', '    }\n', '\n', '    \n', '    \n', '    \n', '    \n', '    function transfer(address , uint256 ) returns (bool ) {\n', '      return;\n', '    }\n', '\n', '    \n', '    \n', '    \n', '    \n', '    \n', '    function transferFrom(address , address , uint256 ) returns (bool ) {\n', '      return;\n', '    }\n', '\n', '    \n', '    \n', '    \n', '    \n', '    function approve(address , uint256 ) returns (bool ) {\n', '      return;\n', '    }\n', '\n', '    \n', '    \n', '    \n', '    function allowance(address , address ) constant returns (uint256 ) {\n', '      return;\n', '    }\n', '\n', '\n', '    event Transfer(address indexed , address indexed , uint256 );\n', '    event Approval(address indexed , address indexed , uint256 );\n', '}\n', '\n', 'contract StdToken is Token \n', '{\n', '\n', '     mapping(address => uint256) balances;\n', '     mapping (address => mapping (address => uint256)) allowed;\n', '\n', '     uint256 public allSupply = 0;\n', '\n', '\n', '     function transfer(address _to, uint256 _value) returns (bool success) \n', '     {\n', '          if((balances[msg.sender] >= _value) && (balances[_to] + _value > balances[_to])) \n', '          {\n', '               balances[msg.sender] -= _value;\n', '               balances[_to] += _value;\n', '\n', '               Transfer(msg.sender, _to, _value);\n', '               return true;\n', '          } \n', '          else \n', '          { \n', '               return false; \n', '          }\n', '     }\n', '\n', '     function transferFrom(address _from, address _to, uint256 _value) returns (bool success) \n', '     {\n', '          if((balances[_from] >= _value) && (allowed[_from][msg.sender] >= _value) && (balances[_to] + _value > balances[_to])) \n', '          {\n', '               balances[_to] += _value;\n', '               balances[_from] -= _value;\n', '               allowed[_from][msg.sender] -= _value;\n', '\n', '               Transfer(_from, _to, _value);\n', '               return true;\n', '          } \n', '          else \n', '          { \n', '               return false; \n', '          }\n', '     }\n', '\n', '     function balanceOf(address _owner) constant returns (uint256 balance) \n', '     {\n', '          return balances[_owner];\n', '     }\n', '\n', '     function approve(address _spender, uint256 _value) returns (bool success) \n', '     {\n', '          allowed[msg.sender][_spender] = _value;\n', '          Approval(msg.sender, _spender, _value);\n', '\n', '          return true;\n', '     }\n', '\n', '     function allowance(address _owner, address _spender) constant returns (uint256 remaining) \n', '     {\n', '          return allowed[_owner][_spender];\n', '     }\n', '\n', '     function totalSupply() constant returns (uint256 supplyOut) \n', '     {\n', '          supplyOut = allSupply;\n', '          return;\n', '     }\n', '}\n', '\n', 'contract ReputationToken is StdToken {\n', '     string public name = "EthlendReputationToken";\n', '     uint public decimals = 18;\n', '     string public symbol = "CRE";\n', '\n', '     address public creator = 0x0;\n', '\n', '     function ReputationToken(){\n', '          creator = msg.sender;\n', '     }\n', '\n', '     function changeCreator(address newCreator){\n', '          if(msg.sender!=creator)throw;\n', '\n', '          creator = newCreator;\n', '     }\n', '\n', '     function issueTokens(address forAddress, uint tokenCount) returns (bool success){\n', '          if(msg.sender!=creator)throw;\n', '          \n', '          if(tokenCount==0) {\n', '               success = false;\n', '               return ;\n', '          }\n', '\n', '          balances[forAddress]+=tokenCount;\n', '          allSupply+=tokenCount;\n', '\n', '          success = true;\n', '          return;\n', '     }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '\n', '\n', 'contract Token \n', '{\n', '\n', '    \n', '    function totalSupply() constant returns (uint256 ) {\n', '      return;\n', '    }\n', '\n', '    \n', '    \n', '    function balanceOf(address ) constant returns (uint256 ) {\n', '      return;\n', '    }\n', '\n', '    \n', '    \n', '    \n', '    \n', '    function transfer(address , uint256 ) returns (bool ) {\n', '      return;\n', '    }\n', '\n', '    \n', '    \n', '    \n', '    \n', '    \n', '    function transferFrom(address , address , uint256 ) returns (bool ) {\n', '      return;\n', '    }\n', '\n', '    \n', '    \n', '    \n', '    \n', '    function approve(address , uint256 ) returns (bool ) {\n', '      return;\n', '    }\n', '\n', '    \n', '    \n', '    \n', '    function allowance(address , address ) constant returns (uint256 ) {\n', '      return;\n', '    }\n', '\n', '\n', '    event Transfer(address indexed , address indexed , uint256 );\n', '    event Approval(address indexed , address indexed , uint256 );\n', '}\n', '\n', 'contract StdToken is Token \n', '{\n', '\n', '     mapping(address => uint256) balances;\n', '     mapping (address => mapping (address => uint256)) allowed;\n', '\n', '     uint256 public allSupply = 0;\n', '\n', '\n', '     function transfer(address _to, uint256 _value) returns (bool success) \n', '     {\n', '          if((balances[msg.sender] >= _value) && (balances[_to] + _value > balances[_to])) \n', '          {\n', '               balances[msg.sender] -= _value;\n', '               balances[_to] += _value;\n', '\n', '               Transfer(msg.sender, _to, _value);\n', '               return true;\n', '          } \n', '          else \n', '          { \n', '               return false; \n', '          }\n', '     }\n', '\n', '     function transferFrom(address _from, address _to, uint256 _value) returns (bool success) \n', '     {\n', '          if((balances[_from] >= _value) && (allowed[_from][msg.sender] >= _value) && (balances[_to] + _value > balances[_to])) \n', '          {\n', '               balances[_to] += _value;\n', '               balances[_from] -= _value;\n', '               allowed[_from][msg.sender] -= _value;\n', '\n', '               Transfer(_from, _to, _value);\n', '               return true;\n', '          } \n', '          else \n', '          { \n', '               return false; \n', '          }\n', '     }\n', '\n', '     function balanceOf(address _owner) constant returns (uint256 balance) \n', '     {\n', '          return balances[_owner];\n', '     }\n', '\n', '     function approve(address _spender, uint256 _value) returns (bool success) \n', '     {\n', '          allowed[msg.sender][_spender] = _value;\n', '          Approval(msg.sender, _spender, _value);\n', '\n', '          return true;\n', '     }\n', '\n', '     function allowance(address _owner, address _spender) constant returns (uint256 remaining) \n', '     {\n', '          return allowed[_owner][_spender];\n', '     }\n', '\n', '     function totalSupply() constant returns (uint256 supplyOut) \n', '     {\n', '          supplyOut = allSupply;\n', '          return;\n', '     }\n', '}\n', '\n', 'contract ReputationToken is StdToken {\n', '     string public name = "EthlendReputationToken";\n', '     uint public decimals = 18;\n', '     string public symbol = "CRE";\n', '\n', '     address public creator = 0x0;\n', '\n', '     function ReputationToken(){\n', '          creator = msg.sender;\n', '     }\n', '\n', '     function changeCreator(address newCreator){\n', '          if(msg.sender!=creator)throw;\n', '\n', '          creator = newCreator;\n', '     }\n', '\n', '     function issueTokens(address forAddress, uint tokenCount) returns (bool success){\n', '          if(msg.sender!=creator)throw;\n', '          \n', '          if(tokenCount==0) {\n', '               success = false;\n', '               return ;\n', '          }\n', '\n', '          balances[forAddress]+=tokenCount;\n', '          allSupply+=tokenCount;\n', '\n', '          success = true;\n', '          return;\n', '     }\n', '}']
