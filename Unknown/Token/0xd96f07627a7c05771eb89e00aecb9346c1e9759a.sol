['pragma solidity 0.4.15;\n', '\n', '/**\n', ' * Basic interface for contracts, following ERC20 standard\n', ' */\n', 'contract ERC20Token {\n', '    \n', '\n', '    /**\n', '     * Triggered when tokens are transferred.\n', '     * @param from - address tokens were transfered from\n', '     * @param to - address tokens were transfered to\n', '     * @param value - amount of tokens transfered\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * Triggered whenever allowance status changes\n', '     * @param owner - tokens owner, allowance changed for\n', '     * @param spender - tokens spender, allowance changed for\n', '     * @param value - new allowance value (overwriting the old value)\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /**\n', '     * Returns total supply of tokens ever emitted\n', '     * @return totalSupply - total supply of tokens ever emitted\n', '     */\n', '    function totalSupply() constant returns (uint256 totalSupply);\n', '\n', '    /**\n', '     * Returns `owner` balance of tokens\n', '     * @param owner address to request balance for\n', '     * @return balance - token balance of `owner`\n', '     */\n', '    function balanceOf(address owner) constant returns (uint256 balance);\n', '\n', '    /**\n', '     * Transfers `amount` of tokens to `to` address\n', '     * @param  to - address to transfer to\n', '     * @param  value - amount of tokens to transfer\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transfer(address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Transfers `value` tokens from `from` address to `to`\n', '     * the sender needs to have allowance for this operation\n', '     * @param  from - address to take tokens from\n', '     * @param  to - address to send tokens to\n', '     * @param  value - amount of tokens to send\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Allow spender to withdraw from your account, multiple times, up to the value amount.\n', '     * If this function is called again it overwrites the current allowance with `value`.\n', '     * this function is required for some DEX functionality\n', '     * @param spender - address to give allowance to\n', '     * @param value - the maximum amount of tokens allowed for spending\n', '     * @return success - `true` if the allowance was given, `false` otherwise\n', '     */\n', '    function approve(address spender, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Returns the amount which `spender` is still allowed to withdraw from `owner`\n', '     * @param  owner - tokens owner\n', '     * @param  spender - addres to request allowance for\n', '     * @return remaining - remaining allowance (token count)\n', '     */\n', '    function allowance(address owner, address spender) constant returns (uint256 remaining);\n', '}\n', '\n', 'pragma solidity 0.4.15;\n', '\n', '/**\n', ' * @title Blind Croupier Token\n', ' * WIN fixed supply Token, used for Blind Croupier TokenDistribution\n', ' */\n', ' contract WIN is ERC20Token {\n', '    \n', '\n', '    string public constant symbol = "WIN";\n', '    string public constant name = "WIN";\n', '\n', '    uint8 public constant decimals = 7;\n', '    uint256 constant TOKEN = 10**7;\n', '    uint256 constant MILLION = 10**6;\n', '    uint256 public totalTokenSupply = 500 * MILLION * TOKEN;\n', '\n', '    /** balances of each accounts */\n', '    mapping(address => uint256) balances;\n', '\n', '    /** amount of tokens approved for transfer */\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    /** Triggered when `owner` destroys `amount` tokens */\n', '    event Destroyed(address indexed owner, uint256 amount);\n', '\n', '    /**\n', '     * Constucts the token, and supplies the creator with `totalTokenSupply` tokens\n', '     */\n', '    function WIN ()   { \n', '        balances[msg.sender] = totalTokenSupply;\n', '    }\n', '\n', '    /**\n', '     * Returns total supply of tokens ever emitted\n', '     * @return result - total supply of tokens ever emitted\n', '     */\n', '    function totalSupply ()  constant  returns (uint256 result) { \n', '        result = totalTokenSupply;\n', '    }\n', '\n', '    /**\n', '    * Returns `owner` balance of tokens\n', '    * @param owner address to request balance for\n', '    * @return balance - token balance of `owner`\n', '    */\n', '    function balanceOf (address owner)  constant  returns (uint256 balance) { \n', '        return balances[owner];\n', '    }\n', '\n', '    /**\n', '     * Transfers `amount` of tokens to `to` address\n', '     * @param  to - address to transfer to\n', '     * @param  amount - amount of tokens to transfer\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transfer (address to, uint256 amount)   returns (bool success) { \n', '        if(balances[msg.sender] < amount)\n', '            return false;\n', '\n', '        if(amount <= 0)\n', '            return false;\n', '\n', '        if(balances[to] + amount <= balances[to])\n', '            return false;\n', '\n', '        balances[msg.sender] -= amount;\n', '        balances[to] += amount;\n', '        Transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfers `amount` tokens from `from` address to `to`\n', '     * the sender needs to have allowance for this operation\n', '     * @param  from - address to take tokens from\n', '     * @param  to - address to send tokens to\n', '     * @param  amount - amount of tokens to send\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transferFrom (address from, address to, uint256 amount)   returns (bool success) { \n', '        if (balances[from] < amount)\n', '            return false;\n', '\n', '        if(allowed[from][msg.sender] < amount)\n', '            return false;\n', '\n', '        if(amount == 0)\n', '            return false;\n', '\n', '        if(balances[to] + amount <= balances[to])\n', '            return false;\n', '\n', '        balances[from] -= amount;\n', '        allowed[from][msg.sender] -= amount;\n', '        balances[to] += amount;\n', '        Transfer(from, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Allow spender to withdraw from your account, multiple times, up to the amount amount.\n', '     * If this function is called again it overwrites the current allowance with `amount`.\n', '     * this function is required for some DEX functionality\n', '     * @param spender - address to give allowance to\n', '     * @param amount - the maximum amount of tokens allowed for spending\n', '     * @return success - `true` if the allowance was given, `false` otherwise\n', '     */\n', '    function approve (address spender, uint256 amount)   returns (bool success) { \n', '       allowed[msg.sender][spender] = amount;\n', '       Approval(msg.sender, spender, amount);\n', '       return true;\n', '   }\n', '\n', '    /**\n', '     * Returns the amount which `spender` is still allowed to withdraw from `owner`\n', '     * @param  owner - tokens owner\n', '     * @param  spender - addres to request allowance for\n', '     * @return remaining - remaining allowance (token count)\n', '     */\n', '    function allowance (address owner, address spender)  constant  returns (uint256 remaining) { \n', '        return allowed[owner][spender];\n', '    }\n', '\n', '     /**\n', '      * Destroys `amount` of tokens permanently, they cannot be restored\n', '      * @return success - `true` if `amount` of tokens were destroyed, `false` otherwise\n', '      */\n', '    function destroy (uint256 amount)   returns (bool success) { \n', '        if(amount == 0) return false;\n', '        if(balances[msg.sender] < amount) return false;\n', '        balances[msg.sender] -= amount;\n', '        totalTokenSupply -= amount;\n', '        Destroyed(msg.sender, amount);\n', '    }\n', '}']
['pragma solidity 0.4.15;\n', '\n', '/**\n', ' * Basic interface for contracts, following ERC20 standard\n', ' */\n', 'contract ERC20Token {\n', '    \n', '\n', '    /**\n', '     * Triggered when tokens are transferred.\n', '     * @param from - address tokens were transfered from\n', '     * @param to - address tokens were transfered to\n', '     * @param value - amount of tokens transfered\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * Triggered whenever allowance status changes\n', '     * @param owner - tokens owner, allowance changed for\n', '     * @param spender - tokens spender, allowance changed for\n', '     * @param value - new allowance value (overwriting the old value)\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /**\n', '     * Returns total supply of tokens ever emitted\n', '     * @return totalSupply - total supply of tokens ever emitted\n', '     */\n', '    function totalSupply() constant returns (uint256 totalSupply);\n', '\n', '    /**\n', '     * Returns `owner` balance of tokens\n', '     * @param owner address to request balance for\n', '     * @return balance - token balance of `owner`\n', '     */\n', '    function balanceOf(address owner) constant returns (uint256 balance);\n', '\n', '    /**\n', '     * Transfers `amount` of tokens to `to` address\n', '     * @param  to - address to transfer to\n', '     * @param  value - amount of tokens to transfer\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transfer(address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Transfers `value` tokens from `from` address to `to`\n', '     * the sender needs to have allowance for this operation\n', '     * @param  from - address to take tokens from\n', '     * @param  to - address to send tokens to\n', '     * @param  value - amount of tokens to send\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Allow spender to withdraw from your account, multiple times, up to the value amount.\n', '     * If this function is called again it overwrites the current allowance with `value`.\n', '     * this function is required for some DEX functionality\n', '     * @param spender - address to give allowance to\n', '     * @param value - the maximum amount of tokens allowed for spending\n', '     * @return success - `true` if the allowance was given, `false` otherwise\n', '     */\n', '    function approve(address spender, uint256 value) returns (bool success);\n', '\n', '    /**\n', '     * Returns the amount which `spender` is still allowed to withdraw from `owner`\n', '     * @param  owner - tokens owner\n', '     * @param  spender - addres to request allowance for\n', '     * @return remaining - remaining allowance (token count)\n', '     */\n', '    function allowance(address owner, address spender) constant returns (uint256 remaining);\n', '}\n', '\n', 'pragma solidity 0.4.15;\n', '\n', '/**\n', ' * @title Blind Croupier Token\n', ' * WIN fixed supply Token, used for Blind Croupier TokenDistribution\n', ' */\n', ' contract WIN is ERC20Token {\n', '    \n', '\n', '    string public constant symbol = "WIN";\n', '    string public constant name = "WIN";\n', '\n', '    uint8 public constant decimals = 7;\n', '    uint256 constant TOKEN = 10**7;\n', '    uint256 constant MILLION = 10**6;\n', '    uint256 public totalTokenSupply = 500 * MILLION * TOKEN;\n', '\n', '    /** balances of each accounts */\n', '    mapping(address => uint256) balances;\n', '\n', '    /** amount of tokens approved for transfer */\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    /** Triggered when `owner` destroys `amount` tokens */\n', '    event Destroyed(address indexed owner, uint256 amount);\n', '\n', '    /**\n', '     * Constucts the token, and supplies the creator with `totalTokenSupply` tokens\n', '     */\n', '    function WIN ()   { \n', '        balances[msg.sender] = totalTokenSupply;\n', '    }\n', '\n', '    /**\n', '     * Returns total supply of tokens ever emitted\n', '     * @return result - total supply of tokens ever emitted\n', '     */\n', '    function totalSupply ()  constant  returns (uint256 result) { \n', '        result = totalTokenSupply;\n', '    }\n', '\n', '    /**\n', '    * Returns `owner` balance of tokens\n', '    * @param owner address to request balance for\n', '    * @return balance - token balance of `owner`\n', '    */\n', '    function balanceOf (address owner)  constant  returns (uint256 balance) { \n', '        return balances[owner];\n', '    }\n', '\n', '    /**\n', '     * Transfers `amount` of tokens to `to` address\n', '     * @param  to - address to transfer to\n', '     * @param  amount - amount of tokens to transfer\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transfer (address to, uint256 amount)   returns (bool success) { \n', '        if(balances[msg.sender] < amount)\n', '            return false;\n', '\n', '        if(amount <= 0)\n', '            return false;\n', '\n', '        if(balances[to] + amount <= balances[to])\n', '            return false;\n', '\n', '        balances[msg.sender] -= amount;\n', '        balances[to] += amount;\n', '        Transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Transfers `amount` tokens from `from` address to `to`\n', '     * the sender needs to have allowance for this operation\n', '     * @param  from - address to take tokens from\n', '     * @param  to - address to send tokens to\n', '     * @param  amount - amount of tokens to send\n', '     * @return success - `true` if the transfer was succesful, `false` otherwise\n', '     */\n', '    function transferFrom (address from, address to, uint256 amount)   returns (bool success) { \n', '        if (balances[from] < amount)\n', '            return false;\n', '\n', '        if(allowed[from][msg.sender] < amount)\n', '            return false;\n', '\n', '        if(amount == 0)\n', '            return false;\n', '\n', '        if(balances[to] + amount <= balances[to])\n', '            return false;\n', '\n', '        balances[from] -= amount;\n', '        allowed[from][msg.sender] -= amount;\n', '        balances[to] += amount;\n', '        Transfer(from, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Allow spender to withdraw from your account, multiple times, up to the amount amount.\n', '     * If this function is called again it overwrites the current allowance with `amount`.\n', '     * this function is required for some DEX functionality\n', '     * @param spender - address to give allowance to\n', '     * @param amount - the maximum amount of tokens allowed for spending\n', '     * @return success - `true` if the allowance was given, `false` otherwise\n', '     */\n', '    function approve (address spender, uint256 amount)   returns (bool success) { \n', '       allowed[msg.sender][spender] = amount;\n', '       Approval(msg.sender, spender, amount);\n', '       return true;\n', '   }\n', '\n', '    /**\n', '     * Returns the amount which `spender` is still allowed to withdraw from `owner`\n', '     * @param  owner - tokens owner\n', '     * @param  spender - addres to request allowance for\n', '     * @return remaining - remaining allowance (token count)\n', '     */\n', '    function allowance (address owner, address spender)  constant  returns (uint256 remaining) { \n', '        return allowed[owner][spender];\n', '    }\n', '\n', '     /**\n', '      * Destroys `amount` of tokens permanently, they cannot be restored\n', '      * @return success - `true` if `amount` of tokens were destroyed, `false` otherwise\n', '      */\n', '    function destroy (uint256 amount)   returns (bool success) { \n', '        if(amount == 0) return false;\n', '        if(balances[msg.sender] < amount) return false;\n', '        balances[msg.sender] -= amount;\n', '        totalTokenSupply -= amount;\n', '        Destroyed(msg.sender, amount);\n', '    }\n', '}']
