['pragma solidity ^0.4.13;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC223ReceivingContract {\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public;\n', '}\n', '\n', 'contract ERC20ERC223 {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address _owner) public constant returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  function transfer(address _to, uint256 _value, bytes _data) public returns (bool);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '  \n', '  event Transfer(address indexed _from, address indexed _to, uint256 indexed _value);\n', '  event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Deco is ERC20ERC223 {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  string public constant name = "Deco";\n', '  string public constant symbol = "DEC";\n', '  uint8 public constant decimals = 18;\n', '  \n', '  uint256 public constant totalSupply = 6*10**26; // 600,000,000. 000,000,000,000,000,000 units\n', '    \n', '  // Accounts\n', '  \n', '  mapping(address => Account) private accounts;\n', '  \n', '  struct Account {\n', '    uint256 balance;\n', '    mapping(address => uint256) allowed;\n', '    mapping(address => bool) isAllowanceAuthorized;\n', '  }  \n', '  \n', '  // Fix for the ERC20 short address attack.\n', '  // http://vessenes.com/the-erc20-short-address-attack-explained/\n', '  modifier onlyPayloadSize(uint256 size) {\n', '    require(msg.data.length >= size + 4);\n', '     _;\n', '  }\n', '\n', '  // Initialization\n', '\n', '  function Deco() {\n', '    accounts[msg.sender].balance = totalSupply;\n', '    Transfer(this, msg.sender, totalSupply);\n', '  }\n', '\n', '  // Balance\n', '\n', '  function balanceOf(address _owner) constant returns (uint256) {\n', '    return accounts[_owner].balance;\n', '  }\n', '\n', '  // Transfers\n', '\n', '  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {\n', '    performTransfer(msg.sender, _to, _value, "");\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value, bytes _data) onlyPayloadSize(2 * 32) returns (bool) {\n', '    performTransfer(msg.sender, _to, _value, _data);\n', '    Transfer(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool) {\n', '    require(hasApproval(_from, msg.sender));\n', '    uint256 _allowed = accounts[_from].allowed[msg.sender];    \n', '    performTransfer(_from, _to, _value, "");    \n', '    accounts[_from].allowed[msg.sender] = _allowed.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function performTransfer(address _from, address _to, uint256 _value, bytes _data) private returns (bool) {\n', '    require(_to != 0x0);\n', '    accounts[_from].balance = accounts[_from].balance.sub(_value);    \n', '    accounts[_to].balance = accounts[_to].balance.add(_value);\n', '    if (isContract(_to)) {\n', '      ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '      receiver.tokenFallback(_from, _value, _data);\n', '    }    \n', '    return true;\n', '  }\n', '\n', '  function isContract(address _to) private constant returns (bool) {\n', '    uint256 codeLength;\n', '    assembly {\n', '      codeLength := extcodesize(_to)\n', '    }\n', '    return codeLength > 0;\n', '  }\n', '\n', '  // Approval & Allowance\n', '  \n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '    require(msg.sender != _spender);\n', '    // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (accounts[msg.sender].allowed[_spender] != 0)) {\n', '      revert();\n', '      return false;\n', '    }\n', '    accounts[msg.sender].allowed[_spender] = _value;\n', '    accounts[msg.sender].isAllowanceAuthorized[_spender] = true;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return accounts[_owner].allowed[_spender];\n', '  }\n', '\n', '  function hasApproval(address _owner, address _spender) constant returns (bool) {        \n', '    return accounts[_owner].isAllowanceAuthorized[_spender];\n', '  }\n', '\n', '  function removeApproval(address _spender) {    \n', '    delete(accounts[msg.sender].allowed[_spender]);\n', '    accounts[msg.sender].isAllowanceAuthorized[_spender] = false;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC223ReceivingContract {\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public;\n', '}\n', '\n', 'contract ERC20ERC223 {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address _owner) public constant returns (uint256);\n', '  function transfer(address _to, uint256 _value) public returns (bool);\n', '  function transfer(address _to, uint256 _value, bytes _data) public returns (bool);\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '  function approve(address _spender, uint256 _value) public returns (bool success);\n', '  function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '  \n', '  event Transfer(address indexed _from, address indexed _to, uint256 indexed _value);\n', '  event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Deco is ERC20ERC223 {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  string public constant name = "Deco";\n', '  string public constant symbol = "DEC";\n', '  uint8 public constant decimals = 18;\n', '  \n', '  uint256 public constant totalSupply = 6*10**26; // 600,000,000. 000,000,000,000,000,000 units\n', '    \n', '  // Accounts\n', '  \n', '  mapping(address => Account) private accounts;\n', '  \n', '  struct Account {\n', '    uint256 balance;\n', '    mapping(address => uint256) allowed;\n', '    mapping(address => bool) isAllowanceAuthorized;\n', '  }  \n', '  \n', '  // Fix for the ERC20 short address attack.\n', '  // http://vessenes.com/the-erc20-short-address-attack-explained/\n', '  modifier onlyPayloadSize(uint256 size) {\n', '    require(msg.data.length >= size + 4);\n', '     _;\n', '  }\n', '\n', '  // Initialization\n', '\n', '  function Deco() {\n', '    accounts[msg.sender].balance = totalSupply;\n', '    Transfer(this, msg.sender, totalSupply);\n', '  }\n', '\n', '  // Balance\n', '\n', '  function balanceOf(address _owner) constant returns (uint256) {\n', '    return accounts[_owner].balance;\n', '  }\n', '\n', '  // Transfers\n', '\n', '  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {\n', '    performTransfer(msg.sender, _to, _value, "");\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value, bytes _data) onlyPayloadSize(2 * 32) returns (bool) {\n', '    performTransfer(msg.sender, _to, _value, _data);\n', '    Transfer(msg.sender, _to, _value, _data);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool) {\n', '    require(hasApproval(_from, msg.sender));\n', '    uint256 _allowed = accounts[_from].allowed[msg.sender];    \n', '    performTransfer(_from, _to, _value, "");    \n', '    accounts[_from].allowed[msg.sender] = _allowed.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function performTransfer(address _from, address _to, uint256 _value, bytes _data) private returns (bool) {\n', '    require(_to != 0x0);\n', '    accounts[_from].balance = accounts[_from].balance.sub(_value);    \n', '    accounts[_to].balance = accounts[_to].balance.add(_value);\n', '    if (isContract(_to)) {\n', '      ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n', '      receiver.tokenFallback(_from, _value, _data);\n', '    }    \n', '    return true;\n', '  }\n', '\n', '  function isContract(address _to) private constant returns (bool) {\n', '    uint256 codeLength;\n', '    assembly {\n', '      codeLength := extcodesize(_to)\n', '    }\n', '    return codeLength > 0;\n', '  }\n', '\n', '  // Approval & Allowance\n', '  \n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '    require(msg.sender != _spender);\n', '    // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (accounts[msg.sender].allowed[_spender] != 0)) {\n', '      revert();\n', '      return false;\n', '    }\n', '    accounts[msg.sender].allowed[_spender] = _value;\n', '    accounts[msg.sender].isAllowanceAuthorized[_spender] = true;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return accounts[_owner].allowed[_spender];\n', '  }\n', '\n', '  function hasApproval(address _owner, address _spender) constant returns (bool) {        \n', '    return accounts[_owner].isAllowanceAuthorized[_spender];\n', '  }\n', '\n', '  function removeApproval(address _spender) {    \n', '    delete(accounts[msg.sender].allowed[_spender]);\n', '    accounts[msg.sender].isAllowanceAuthorized[_spender] = false;\n', '  }\n', '\n', '}']
