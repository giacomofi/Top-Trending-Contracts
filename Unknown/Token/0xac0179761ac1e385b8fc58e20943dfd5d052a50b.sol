['pragma solidity ^0.4.8;\n', '\n', '\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * Issuer manages token distribution after the crowdsale.\n', ' *\n', ' * This contract is fed a CSV file with Ethereum addresses and their\n', ' * issued token balances.\n', ' *\n', ' * Issuer act as a gate keeper to ensure there is no double issuance\n', ' * per address, in the case we need to do several issuance batches,\n', ' * there is a race condition or there is a fat finger error.\n', ' *\n', ' * Issuer contract gets allowance from the team multisig to distribute tokens.\n', ' *\n', ' */\n', 'contract Issuer is Ownable {\n', '\n', '  /** Map addresses whose tokens we have already issued. */\n', '  mapping(address => bool) public issued;\n', '\n', '  /** Centrally issued token we are distributing to our contributors */\n', '  ERC20 public token;\n', '\n', '  /** Party (team multisig) who is in the control of the token pool. Note that this will be different from the owner address (scripted) that calls this contract. */\n', '  address public allower;\n', '\n', '  /** How many addresses have received their tokens. */\n', '  uint public issuedCount;\n', '\n', '  function Issuer(address _owner, address _allower, ERC20 _token) {\n', '    owner = _owner;\n', '    allower = _allower;\n', '    token = _token;\n', '  }\n', '\n', '  function issue(address benefactor, uint amount) onlyOwner {\n', '    if(issued[benefactor]) throw;\n', '    token.transferFrom(allower, benefactor, amount);\n', '    issued[benefactor] = true;\n', '    issuedCount += amount;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.8;\n', '\n', '\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * Issuer manages token distribution after the crowdsale.\n', ' *\n', ' * This contract is fed a CSV file with Ethereum addresses and their\n', ' * issued token balances.\n', ' *\n', ' * Issuer act as a gate keeper to ensure there is no double issuance\n', ' * per address, in the case we need to do several issuance batches,\n', ' * there is a race condition or there is a fat finger error.\n', ' *\n', ' * Issuer contract gets allowance from the team multisig to distribute tokens.\n', ' *\n', ' */\n', 'contract Issuer is Ownable {\n', '\n', '  /** Map addresses whose tokens we have already issued. */\n', '  mapping(address => bool) public issued;\n', '\n', '  /** Centrally issued token we are distributing to our contributors */\n', '  ERC20 public token;\n', '\n', '  /** Party (team multisig) who is in the control of the token pool. Note that this will be different from the owner address (scripted) that calls this contract. */\n', '  address public allower;\n', '\n', '  /** How many addresses have received their tokens. */\n', '  uint public issuedCount;\n', '\n', '  function Issuer(address _owner, address _allower, ERC20 _token) {\n', '    owner = _owner;\n', '    allower = _allower;\n', '    token = _token;\n', '  }\n', '\n', '  function issue(address benefactor, uint amount) onlyOwner {\n', '    if(issued[benefactor]) throw;\n', '    token.transferFrom(allower, benefactor, amount);\n', '    issued[benefactor] = true;\n', '    issuedCount += amount;\n', '  }\n', '\n', '}']
