['contract Token {\n', '    /// Get the total amount of tokens in the system.\n', '    function totalSupply() constant returns (uint256 total);\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract GavCoin {\n', '    struct Receipt {\n', '        uint units;\n', '        uint32 activation;\n', '    }\n', '    struct Account {\n', '        uint balance;\n', '        mapping (uint => Receipt) receipt;\n', '        mapping (address => uint) allowanceOf;\n', '    }\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Buyin(address indexed buyer, uint indexed price, uint indexed amount);\n', '    event Refund(address indexed buyer, uint indexed price, uint indexed amount);\n', '    event NewTranch(uint indexed price);\n', '    \n', '    modifier when_owns(address _owner, uint _amount) { if (accounts[_owner].balance < _amount) return; _ }\n', '    modifier when_has_allowance(address _owner, address _spender, uint _amount) { if (accounts[_owner].allowanceOf[_spender] < _amount) return; _ }\n', '    modifier when_have_active_receipt(uint _price, uint _units) { if (accounts[msg.sender].receipt[_price].units < _units || now < accounts[msg.sender].receipt[_price].activation) return; _ }\n', '\n', '    function balanceOf(address _who) constant returns (uint) { return accounts[_who].balance; }\n', '    \n', '    function transfer(address _to, uint256 _value) when_owns(msg.sender, _value) returns (bool success) {\n', '        Transfer(msg.sender, _to, _value);\n', '        accounts[msg.sender].balance -= _value;\n', '        accounts[_to].balance += _value;\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _value) when_owns(_from, _value) when_has_allowance(_from, msg.sender, _value) returns (bool success) {\n', '        Transfer(_from, _to, _value);\n', '        accounts[_from].allowanceOf[msg.sender] -= _value;\n', '        accounts[_from].balance -= _value;\n', '        accounts[_to].balance += _value;\n', '        return true;\n', '    }\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        Approval(msg.sender, _spender, _value);\n', '        accounts[msg.sender].allowanceOf[_spender] += _value;\n', '        return true;\n', '    }\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return accounts[_owner].allowanceOf[_spender];\n', '    }\n', '    \n', '    /// Simple buyin.\n', '    function() { buyinInternal(msg.sender, 2 ** 255); }\n', '\n', '    /// Extended buyin.\n', '    function buyin(address _who, uint _maxPrice) { buyinInternal(_who, _maxPrice); }\n', '\n', '    function refund(uint _price, uint _units) when_have_active_receipt(_price, _units) when_owns(msg.sender, _units) returns (bool) {\n', '        Refund(msg.sender, _price, _units);\n', '        accounts[msg.sender].balance -= _units;\n', '        totalSupply += _units;\n', '        accounts[msg.sender].receipt[_price].units -= _units;\n', '        if (accounts[msg.sender].receipt[_price].units == 0)\n', '            delete accounts[msg.sender].receipt[_price];\n', '        if (!msg.sender.send(_units * _price / base))\n', '            throw;\n', '        return true;\n', '    }\n', '\n', '    function buyinInternal(address _who, uint _maxPrice) internal {\n', '        var leftToSpend = msg.value;\n', '        while (leftToSpend > 0 && price <= _maxPrice) {\n', '            // How much the remaining tokens of this tranch cost to buy\n', '            var maxCanSpend = price * remaining / base;\n', "            // How much we will spend - the mininum of what's left in the tranch\n", '            // to buy and what we have remaining\n', '            var spend = leftToSpend > maxCanSpend ? maxCanSpend : leftToSpend;\n', '            // The number of units we get for spending that\n', '            var units = spend * base / price;\n', '\n', '            // Provide tokens and a purchase receipt\n', '            accounts[msg.sender].balance += units;\n', '            accounts[msg.sender].receipt[price].units += units;\n', '            accounts[msg.sender].receipt[price].activation = uint32(now) + refundActivationPeriod;\n', '            totalSupply += units;\n', '            Buyin(msg.sender, price, units);\n', '\n', '            // Reduce the amounts remaining\n', '            leftToSpend -= spend;\n', '            remaining -= units;\n', '            \n', '            // If this is the end of the tranch...\n', '            if (remaining == 0) {\n', '                // ...Increment price and reset remaining\n', '                price += tranchStep;\n', '                remaining = tokensPerTranch * base;\n', '                NewTranch(price);\n', '            }\n', '        }\n', '    }\n', '    \n', '    uint public totalSupply;\n', '    mapping (address => Account) accounts;\n', '    \n', '    uint constant base = 1000000;               // tokens are subdivisible by 1000000\n', '    uint constant tranchStep = 1 finney;        // raise price by 1 finney / tranch\n', '    uint constant tokensPerTranch = 100;        // 100 tokens per tranch\n', '    uint public price = 1 finney;               // begin at 1 finney / token\n', '    uint public remaining = tokensPerTranch * base;\n', '    uint32 constant refundActivationPeriod = 7 days;\n', '}']