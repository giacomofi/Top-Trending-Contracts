['//////////////////////////////////////////////////////////////////////////////////////////\n', '//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n', '//\tTitle: \t\t\t\t\t\tClipper Coin Creation Contract\t\t\t\t\t\t\t//\n', '//\tAuthor: \t\t\t\t\tMarko Valentin Micic\t\t\t\t\t\t\t\t\t//\n', '//\tVersion: \t\t\t\t\tv0.1\t\t\t\t\t\t\t\t\t\t\t\t\t//\n', '//\tDate of current version:\t2017/09/01\t\t\t\t\t\t\t\t\t\t\t\t//\n', '//\tBrief Description:\t\t\tThe smart contract that will create tokens. The tokens\t//\n', '//\t\t\t\t\t\t\t\twill be apportioned according to the results of the \t//\n', '//\t\t\t\t\t\t\t\tICO conducted on ico.info earlier. Results of the ICO\t// \n', '//\t\t\t\t\t\t\t\tcan be viewed at https://ico.info/projects/19 and are \t//\n', '//\t\t\t\t\t\t\t\tsummarized below:\t\t\t\t\t\t\t\t\t\t//\n', '//\t\t\t\t\t\t\t\tBTC raised: 386.808\t\t\t\t\t\t\t\t\t\t//\n', '//\t\t\t\t\t\t\t\tETH raised: 24451.896\t\t\t\t\t\t\t\t\t//\n', '//\t\t\t\t\t\t\t\tEOS raised: 1468860\t\t\t\t\t\t\t\t\t\t//\n', '//\t\t\t\t\t\t\t\tIn accordance with Clipper Coin Venture&#39;s plan (also\t//\n', '//\t\t\t\t\t\t\t\tviewable on the same website), the appropriate \t\t\t//\n', '//\t\t\t\t\t\t\t\tproportion of coins will be delivered to ICOInfo, a \t//\n', '//\t\t\t\t\t\t\t\tcertain proportion will be deleted, and the rest held \t//\n', '//\t\t\t\t\t\t\t\tin reserve for uses that will be determined by later\t//\n', '//\t\t\t\t\t\t\t\tsmart contracts. \t\t\t\t\t\t\t\t\t\t//\n', '//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n', '//////////////////////////////////////////////////////////////////////////////////////////\n', 'pragma solidity ^0.4.11;\n', '\n', 'contract ERC20Protocol {\n', '/* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint supply);\n', '    is replaced with:\n', '    uint public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n', '///  later changed\n', 'contract Owned {\n', '\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    address public newOwner;\n', '\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '    ///  an unowned neutral vault, however that cannot be undone\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '\n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract StandardToken is ERC20Protocol {\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '    * @dev Fix for the ERC20 short address attack.\n', '    */\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '        //Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '}\n', '\n', 'contract tokenRecipient { \n', '\tfunction receiveApproval(\n', '\t\taddress _from, \n', '\t\tuint256 _value, \n', '\t\taddress _token, \n', '\t\tbytes _extraData); \n', '}\n', '\n', 'contract ClipperCoin is Owned{\n', '    using SafeMath for uint;\n', '\n', '    /// Constant token specific fields\n', '    string public name = "Clipper Coin";\n', '    string public symbol = "CCCT";\n', '    uint public decimals = 18;\n', '\n', '    /// Total supply of Clipper Coin\n', '    uint public totalSupply = 200000000 ether;\n', '    \n', '    /// Create an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    \n', '    /// Generate public event on the blockchain that will notify clients of transfers\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '    /// Generate public event on the blockchain that notifies clients how much CCC has \n', '    /// been destroyed\n', '    event Burn(address indexed from, uint256 value);\n', '    \n', '    /// Initialize contract with initial supply of tokens sent to the creator of the \n', '    /// contract, who is defined as the minter of the coin\n', '    function ClipperCoin(\n', '    \tuint256 initialSupply,\n', '    \tstring tokenName,\n', '    \tuint8 tokenDecimals,\n', '    \tstring tokenSymbol\n', '    \t) {\n', '    \t    \n', '    \t//Give creator all initial tokens\n', '    \tbalanceOf[msg.sender]  = initialSupply;\n', '    \t\n', '    \t// Set the total supply of all Clipper Coins\n', '    \ttotalSupply  = initialSupply;\n', '    \t\n', '    \t// Set the name of Clipper Coins\n', '    \tname = tokenName;\n', '    \t\n', '    \t// Set the symbol of Clipper Coins: CCC\n', '    \tsymbol = tokenSymbol;\n', '    \t\n', '    \t// Set the amount of decimal places present in Clipper Coin: 18\n', '    \t// Note: 18 is the ethereum standard\n', '    \tdecimals = tokenDecimals;\n', '    }\n', '    \n', '    \n', '    /// Internal transfers, which can only be called by this contract.\n', '    function _transfer(\n', '    \taddress _from,\n', '    \taddress _to,\n', '    \tuint _value)\n', '    \tinternal {\n', '    \t    \n', '    \t// Prevent transfers to the 0x0 address. Use burn() instead to \n', '    \t// permanently remove Clipper Coins from the Blockchain\n', '    \trequire (_to != 0x0);\n', '    \t\n', '    \t// Check that the account has enough Clipper Coins to be transferred\n', '        require (balanceOf[_from] > _value);                \n', '        \n', '        // Check that the subraction of coins is not occuring\n', '        require (balanceOf[_to] + _value > balanceOf[_to]); \n', '        balanceOf[_from] -= _value;                         \n', '        balanceOf[_to] += _value;                           \n', '        Transfer(_from, _to, _value);\n', '    }\n', '    \n', '    /// @notice Send `_value` tokens to `_to` from your account\n', '    /// @param _to The address of the recipient\n', '    /// @param _value the amount to send\n', '    function transfer(\n', '    \taddress _to, \n', '    \tuint256 _value) {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /// @notice Send `_value` tokens to `_to` on behalf of `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value the amount to send\n', '    function transferFrom(\n', '    \taddress _from, \n', '    \taddress _to, \n', '    \tuint256 _value) returns (bool success) {\n', '        require (_value < allowance[_from][msg.sender]);     \n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allows `_spender` to spend no more than `_value` tokens on your behalf\n', '    /// @param _spender The address authorized to spend\n', '    /// @param _value the max amount they can spend\n', '    function approve(\n', '    \taddress _spender, \n', '    \tuint256 _value) returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allows `_spender` to spend no more than `_value` tokens on your behalf, \n', '    ///\t\t\tand then ping the contract about it\n', '    /// @param _spender The address authorized to spend\n', '    /// @param _value the max amount they can spend\n', '    /// @param _extraData some extra information to send to the approved contract\n', '    function approveAndCall(\n', '    \taddress _spender, \n', '    \tuint256 _value, \n', '    \tbytes _extraData) returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }        \n', '\n', '    /// @notice Remove `_value` tokens from the system irreversibly\n', '    /// @param _value the amount of money to burn\n', '    function burn(uint256 _value) returns (bool success) {\n', '        require (balanceOf[msg.sender] > _value);            \n', '        balanceOf[msg.sender] -= _value;                      \n', '        totalSupply -= _value;                                \n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(\n', '    \taddress _from, \n', '    \tuint256 _value) returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                \n', '        require(_value <= allowance[_from][msg.sender]);    \n', '        balanceOf[_from] -= _value;                         \n', '        allowance[_from][msg.sender] -= _value;             \n', '        totalSupply -= _value;                              \n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '}']
['//////////////////////////////////////////////////////////////////////////////////////////\n', '//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n', '//\tTitle: \t\t\t\t\t\tClipper Coin Creation Contract\t\t\t\t\t\t\t//\n', '//\tAuthor: \t\t\t\t\tMarko Valentin Micic\t\t\t\t\t\t\t\t\t//\n', '//\tVersion: \t\t\t\t\tv0.1\t\t\t\t\t\t\t\t\t\t\t\t\t//\n', '//\tDate of current version:\t2017/09/01\t\t\t\t\t\t\t\t\t\t\t\t//\n', '//\tBrief Description:\t\t\tThe smart contract that will create tokens. The tokens\t//\n', '//\t\t\t\t\t\t\t\twill be apportioned according to the results of the \t//\n', '//\t\t\t\t\t\t\t\tICO conducted on ico.info earlier. Results of the ICO\t// \n', '//\t\t\t\t\t\t\t\tcan be viewed at https://ico.info/projects/19 and are \t//\n', '//\t\t\t\t\t\t\t\tsummarized below:\t\t\t\t\t\t\t\t\t\t//\n', '//\t\t\t\t\t\t\t\tBTC raised: 386.808\t\t\t\t\t\t\t\t\t\t//\n', '//\t\t\t\t\t\t\t\tETH raised: 24451.896\t\t\t\t\t\t\t\t\t//\n', '//\t\t\t\t\t\t\t\tEOS raised: 1468860\t\t\t\t\t\t\t\t\t\t//\n', "//\t\t\t\t\t\t\t\tIn accordance with Clipper Coin Venture's plan (also\t//\n", '//\t\t\t\t\t\t\t\tviewable on the same website), the appropriate \t\t\t//\n', '//\t\t\t\t\t\t\t\tproportion of coins will be delivered to ICOInfo, a \t//\n', '//\t\t\t\t\t\t\t\tcertain proportion will be deleted, and the rest held \t//\n', '//\t\t\t\t\t\t\t\tin reserve for uses that will be determined by later\t//\n', '//\t\t\t\t\t\t\t\tsmart contracts. \t\t\t\t\t\t\t\t\t\t//\n', '//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n', '//////////////////////////////////////////////////////////////////////////////////////////\n', 'pragma solidity ^0.4.11;\n', '\n', 'contract ERC20Protocol {\n', '/* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint supply);\n', '    is replaced with:\n', '    uint public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n', '///  later changed\n', 'contract Owned {\n', '\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    address public newOwner;\n', '\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '    ///  an unowned neutral vault, however that cannot be undone\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '\n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', 'contract StandardToken is ERC20Protocol {\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '    * @dev Fix for the ERC20 short address attack.\n', '    */\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', "        //Default assumes totalSupply can't be over max (2^256 - 1).\n", "        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '}\n', '\n', 'contract tokenRecipient { \n', '\tfunction receiveApproval(\n', '\t\taddress _from, \n', '\t\tuint256 _value, \n', '\t\taddress _token, \n', '\t\tbytes _extraData); \n', '}\n', '\n', 'contract ClipperCoin is Owned{\n', '    using SafeMath for uint;\n', '\n', '    /// Constant token specific fields\n', '    string public name = "Clipper Coin";\n', '    string public symbol = "CCCT";\n', '    uint public decimals = 18;\n', '\n', '    /// Total supply of Clipper Coin\n', '    uint public totalSupply = 200000000 ether;\n', '    \n', '    /// Create an array with all balances\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    \n', '    /// Generate public event on the blockchain that will notify clients of transfers\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '    /// Generate public event on the blockchain that notifies clients how much CCC has \n', '    /// been destroyed\n', '    event Burn(address indexed from, uint256 value);\n', '    \n', '    /// Initialize contract with initial supply of tokens sent to the creator of the \n', '    /// contract, who is defined as the minter of the coin\n', '    function ClipperCoin(\n', '    \tuint256 initialSupply,\n', '    \tstring tokenName,\n', '    \tuint8 tokenDecimals,\n', '    \tstring tokenSymbol\n', '    \t) {\n', '    \t    \n', '    \t//Give creator all initial tokens\n', '    \tbalanceOf[msg.sender]  = initialSupply;\n', '    \t\n', '    \t// Set the total supply of all Clipper Coins\n', '    \ttotalSupply  = initialSupply;\n', '    \t\n', '    \t// Set the name of Clipper Coins\n', '    \tname = tokenName;\n', '    \t\n', '    \t// Set the symbol of Clipper Coins: CCC\n', '    \tsymbol = tokenSymbol;\n', '    \t\n', '    \t// Set the amount of decimal places present in Clipper Coin: 18\n', '    \t// Note: 18 is the ethereum standard\n', '    \tdecimals = tokenDecimals;\n', '    }\n', '    \n', '    \n', '    /// Internal transfers, which can only be called by this contract.\n', '    function _transfer(\n', '    \taddress _from,\n', '    \taddress _to,\n', '    \tuint _value)\n', '    \tinternal {\n', '    \t    \n', '    \t// Prevent transfers to the 0x0 address. Use burn() instead to \n', '    \t// permanently remove Clipper Coins from the Blockchain\n', '    \trequire (_to != 0x0);\n', '    \t\n', '    \t// Check that the account has enough Clipper Coins to be transferred\n', '        require (balanceOf[_from] > _value);                \n', '        \n', '        // Check that the subraction of coins is not occuring\n', '        require (balanceOf[_to] + _value > balanceOf[_to]); \n', '        balanceOf[_from] -= _value;                         \n', '        balanceOf[_to] += _value;                           \n', '        Transfer(_from, _to, _value);\n', '    }\n', '    \n', '    /// @notice Send `_value` tokens to `_to` from your account\n', '    /// @param _to The address of the recipient\n', '    /// @param _value the amount to send\n', '    function transfer(\n', '    \taddress _to, \n', '    \tuint256 _value) {\n', '        _transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    /// @notice Send `_value` tokens to `_to` on behalf of `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value the amount to send\n', '    function transferFrom(\n', '    \taddress _from, \n', '    \taddress _to, \n', '    \tuint256 _value) returns (bool success) {\n', '        require (_value < allowance[_from][msg.sender]);     \n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allows `_spender` to spend no more than `_value` tokens on your behalf\n', '    /// @param _spender The address authorized to spend\n', '    /// @param _value the max amount they can spend\n', '    function approve(\n', '    \taddress _spender, \n', '    \tuint256 _value) returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /// @notice Allows `_spender` to spend no more than `_value` tokens on your behalf, \n', '    ///\t\t\tand then ping the contract about it\n', '    /// @param _spender The address authorized to spend\n', '    /// @param _value the max amount they can spend\n', '    /// @param _extraData some extra information to send to the approved contract\n', '    function approveAndCall(\n', '    \taddress _spender, \n', '    \tuint256 _value, \n', '    \tbytes _extraData) returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }        \n', '\n', '    /// @notice Remove `_value` tokens from the system irreversibly\n', '    /// @param _value the amount of money to burn\n', '    function burn(uint256 _value) returns (bool success) {\n', '        require (balanceOf[msg.sender] > _value);            \n', '        balanceOf[msg.sender] -= _value;                      \n', '        totalSupply -= _value;                                \n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(\n', '    \taddress _from, \n', '    \tuint256 _value) returns (bool success) {\n', '        require(balanceOf[_from] >= _value);                \n', '        require(_value <= allowance[_from][msg.sender]);    \n', '        balanceOf[_from] -= _value;                         \n', '        allowance[_from][msg.sender] -= _value;             \n', '        totalSupply -= _value;                              \n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '}']
