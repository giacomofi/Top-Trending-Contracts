['/*\n', 'An ERC20 compliant token that is linked to an external identifier. For exmaple, Meetup.com\n', '\n', 'This software is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \n', 'See MIT Licence for further details.\n', '<https://opensource.org/licenses/MIT>.\n', '*/\n', '\n', 'pragma solidity ^0.4.15;\n', '\n', 'contract ERC20Token\n', '{\n', '/* State */\n', '    // The Total supply of tokens\n', '    uint totSupply;\n', '    \n', '    /// @return Token symbol\n', '    string sym;\n', '    string nam;\n', '\n', '    uint8 public decimals = 0;\n', '    \n', '    // Token ownership mapping\n', '    mapping (address => uint) balance;\n', '    \n', '    // Allowances mapping\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '/* Events */\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value);\n', '\n', '/* Funtions Public */\n', '\n', '    function symbol() public constant returns (string)\n', '    {\n', '        return sym;\n', '    }\n', '\n', '    function name() public constant returns (string)\n', '    {\n', '        return nam;\n', '    }\n', '    \n', '    // Using an explicit getter allows for function overloading    \n', '    function totalSupply() public constant returns (uint)\n', '    {\n', '        return totSupply;\n', '    }\n', '    \n', '    // Using an explicit getter allows for function overloading    \n', '    function balanceOf(address holderAddress) public constant returns (uint)\n', '    {\n', '        return balance[holderAddress];\n', '    }\n', '    \n', '    // Using an explicit getter allows for function overloading    \n', '    function allowance(address ownerAddress, address spenderAddress) public constant returns (uint remaining)\n', '    {\n', '        return allowed[ownerAddress][spenderAddress];\n', '    }\n', '        \n', '\n', '    // Send amount amount of tokens to address _to\n', '    // Reentry protection prevents attacks upon the state\n', '    function transfer(address toAddress, uint256 amount) public\n', '    {\n', '        xfer(msg.sender, toAddress, amount);\n', '    }\n', '\n', '    // Send amount amount of tokens from address _from to address _to\n', '    // Reentry protection prevents attacks upon the state\n', '    function transferFrom(address fromAddress, address toAddress, uint256 amount) public\n', '    {\n', '        require(amount <= allowed[fromAddress][msg.sender]);\n', '        allowed[fromAddress][msg.sender] -= amount;\n', '        xfer(fromAddress, toAddress, amount);\n', '    }\n', '\n', '    // Process a transfer internally.\n', '    function xfer(address fromAddress, address toAddress, uint amount) internal\n', '    {\n', '        require(amount <= balance[fromAddress]);\n', '        balance[fromAddress] -= amount;\n', '        balance[toAddress] += amount;\n', '        Transfer(fromAddress, toAddress, amount);\n', '    }\n', '\n', '    // Approves a third-party spender\n', '    // Reentry protection prevents attacks upon the state\n', '    function approve(address spender, uint256 amount) public\n', '    {\n', '        allowed[msg.sender][spender] = amount;\n', '        Approval(msg.sender, spender, amount);\n', '    }\n', '}\n', '\n', 'contract TransferableMeetupToken is ERC20Token\n', '{\n', '    address owner = msg.sender;\n', '    \n', '    function TransferableMeetupToken(string tokenSymbol, string toeknName)\n', '    {\n', '        sym = tokenSymbol;\n', '        nam = toeknName;\n', '    }\n', '    \n', '    event Issue(\n', '        address indexed toAddress,\n', '        uint256 amount,\n', '        string externalId,\n', '        string reason);\n', '\n', '    event Redeem(\n', '        address indexed fromAddress,\n', '        uint256 amount);\n', '\n', '    function issue(address toAddress, uint amount, string externalId, string reason) public\n', '    {\n', '        require(owner == msg.sender);\n', '        totSupply += amount;\n', '        balance[toAddress] += amount;\n', '        Issue(toAddress, amount, externalId, reason);\n', '        Transfer(0x0, toAddress, amount);\n', '    }\n', '    \n', '    function redeem(uint amount) public\n', '    {\n', '        require(balance[msg.sender] >= amount);\n', '        totSupply -= amount;\n', '        balance[msg.sender] -= amount;\n', '        Redeem(msg.sender, amount);\n', '        Transfer(msg.sender, 0x0, amount);\n', '    }\n', '}']
['/*\n', 'An ERC20 compliant token that is linked to an external identifier. For exmaple, Meetup.com\n', '\n', 'This software is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \n', 'See MIT Licence for further details.\n', '<https://opensource.org/licenses/MIT>.\n', '*/\n', '\n', 'pragma solidity ^0.4.15;\n', '\n', 'contract ERC20Token\n', '{\n', '/* State */\n', '    // The Total supply of tokens\n', '    uint totSupply;\n', '    \n', '    /// @return Token symbol\n', '    string sym;\n', '    string nam;\n', '\n', '    uint8 public decimals = 0;\n', '    \n', '    // Token ownership mapping\n', '    mapping (address => uint) balance;\n', '    \n', '    // Allowances mapping\n', '    mapping (address => mapping (address => uint)) allowed;\n', '\n', '/* Events */\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value);\n', '\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value);\n', '\n', '/* Funtions Public */\n', '\n', '    function symbol() public constant returns (string)\n', '    {\n', '        return sym;\n', '    }\n', '\n', '    function name() public constant returns (string)\n', '    {\n', '        return nam;\n', '    }\n', '    \n', '    // Using an explicit getter allows for function overloading    \n', '    function totalSupply() public constant returns (uint)\n', '    {\n', '        return totSupply;\n', '    }\n', '    \n', '    // Using an explicit getter allows for function overloading    \n', '    function balanceOf(address holderAddress) public constant returns (uint)\n', '    {\n', '        return balance[holderAddress];\n', '    }\n', '    \n', '    // Using an explicit getter allows for function overloading    \n', '    function allowance(address ownerAddress, address spenderAddress) public constant returns (uint remaining)\n', '    {\n', '        return allowed[ownerAddress][spenderAddress];\n', '    }\n', '        \n', '\n', '    // Send amount amount of tokens to address _to\n', '    // Reentry protection prevents attacks upon the state\n', '    function transfer(address toAddress, uint256 amount) public\n', '    {\n', '        xfer(msg.sender, toAddress, amount);\n', '    }\n', '\n', '    // Send amount amount of tokens from address _from to address _to\n', '    // Reentry protection prevents attacks upon the state\n', '    function transferFrom(address fromAddress, address toAddress, uint256 amount) public\n', '    {\n', '        require(amount <= allowed[fromAddress][msg.sender]);\n', '        allowed[fromAddress][msg.sender] -= amount;\n', '        xfer(fromAddress, toAddress, amount);\n', '    }\n', '\n', '    // Process a transfer internally.\n', '    function xfer(address fromAddress, address toAddress, uint amount) internal\n', '    {\n', '        require(amount <= balance[fromAddress]);\n', '        balance[fromAddress] -= amount;\n', '        balance[toAddress] += amount;\n', '        Transfer(fromAddress, toAddress, amount);\n', '    }\n', '\n', '    // Approves a third-party spender\n', '    // Reentry protection prevents attacks upon the state\n', '    function approve(address spender, uint256 amount) public\n', '    {\n', '        allowed[msg.sender][spender] = amount;\n', '        Approval(msg.sender, spender, amount);\n', '    }\n', '}\n', '\n', 'contract TransferableMeetupToken is ERC20Token\n', '{\n', '    address owner = msg.sender;\n', '    \n', '    function TransferableMeetupToken(string tokenSymbol, string toeknName)\n', '    {\n', '        sym = tokenSymbol;\n', '        nam = toeknName;\n', '    }\n', '    \n', '    event Issue(\n', '        address indexed toAddress,\n', '        uint256 amount,\n', '        string externalId,\n', '        string reason);\n', '\n', '    event Redeem(\n', '        address indexed fromAddress,\n', '        uint256 amount);\n', '\n', '    function issue(address toAddress, uint amount, string externalId, string reason) public\n', '    {\n', '        require(owner == msg.sender);\n', '        totSupply += amount;\n', '        balance[toAddress] += amount;\n', '        Issue(toAddress, amount, externalId, reason);\n', '        Transfer(0x0, toAddress, amount);\n', '    }\n', '    \n', '    function redeem(uint amount) public\n', '    {\n', '        require(balance[msg.sender] >= amount);\n', '        totSupply -= amount;\n', '        balance[msg.sender] -= amount;\n', '        Redeem(msg.sender, amount);\n', '        Transfer(msg.sender, 0x0, amount);\n', '    }\n', '}']
