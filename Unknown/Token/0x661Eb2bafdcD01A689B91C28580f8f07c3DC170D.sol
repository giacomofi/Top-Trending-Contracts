['pragma solidity ^0.4.8;\n', '\n', '\n', '// ERC Token Standard #20 Interface \n', 'contract ERC20 {\n', '    // Get the total token supply\n', '    uint public totalSupply;\n', '    // Get the account balance of another account with address _owner\n', '    function balanceOf(address who) constant returns(uint256);\n', '    // Send _value amount of tokens to address _to\n', '    function transfer(address to, uint value) returns(bool ok);\n', '    // Send _value amount of tokens from address _from to address _to\n', '    function transferFrom(address from, address to, uint value) returns(bool ok);\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    // this function is required for some DEX functionality\n', '    function approve(address spender, uint value) returns(bool ok);\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address owner, address spender) constant returns(uint);\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '}\n', '\n', '\n', 'contract FuBi is ERC20 {\n', '\n', '    // each address in this contract may have tokens, to define balances and store balance of each address we use mapping.\n', '    mapping (address => uint256) balances;   \n', '    // frozen account mapping to store account which are freeze to do anything\n', '    mapping (address => bool) public frozenAccount; //\n', '\n', '    //address internal owner = 0x4Bce8E9850254A86a1988E2dA79e41Bc6793640d;  \n', '\n', '    // Owner of this contract will be the creater of the contract\n', '    address public owner;\n', '    // name of this contract and investment fund\n', '    string public name = "FuBi";  \n', '    // token symbol\n', '    string public symbol = "Fu";  \n', '    // decimals (for humans)\n', '    uint8 public decimals = 6;    \n', '    // total supply of tokens it includes 6 zeros extra to handle decimal of 6 places.\n', '    uint256 public totalSupply = 20000000000000000;  \n', '    // This generates a public event on the blockchain that will notify clients\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    // events that will notifies clints about the freezing accounts and status\n', '    event FrozenFu(address target, bool frozen);\n', '\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    \n', '    bool flag = false;\n', '\n', '    // modifier to authorize owner\n', '    modifier onlyOwner()\n', '    {\n', '        if (msg.sender != owner) revert();\n', '        _;\n', '    }\n', '\n', '    // constructor called during creation of contract\n', '    function FuBi() { \n', '        owner = msg.sender;       // person who deploy the contract will be the owner of the contract\n', '        balances[owner] = totalSupply; // balance of owner will be equal to 20000 million\n', '        }    \n', '\n', '    // implemented function balanceOf of erc20 to know the balnce of any account\n', '    function balanceOf(address _owner) constant returns (uint256 balance)\n', '    {\n', '        return balances[_owner];\n', '    }\n', '    // transfer tokens from one address to another\n', '    function transfer(address _to, uint _value) returns (bool success)\n', '    {\n', '         // Check send token value > 0;\n', '        if(_value <= 0) throw;                                     \n', '        // Check if the sender has enough\n', '        if (balances[msg.sender] < _value) throw;                   \n', '        // Check for overflows\n', '        if (balances[_to] + _value < balances[_to]) throw; \n', '        // Subtract from the sender\n', '        balances[msg.sender] -= _value;                             \n', '        // Add the same to the recipient, if it&#39;s the contact itself then it signals a sell order of those tokens\n', '        balances[_to] += _value;                                    \n', '        // Notify anyone listening that this transfer took place               \n', '        Transfer(msg.sender, _to, _value);                          \n', '        return true;      \n', '    }\n', '    \n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value)\n', '    returns(bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '    // Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\n', '        return allowance[_owner][_spender];\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint _value) returns(bool success) {\n', '        if (_to == 0x0) throw; // Prevent transfer to 0x0 address. Use burn() instead\n', '        if (balances[_from] < _value) throw; // Check if the sender has enough\n', '        if (balances[_to] + _value < balances[_to]) throw; // Check for overflows\n', '        if (_value > allowance[_from][msg.sender]) throw; // Check allowance\n', '\n', '        balances[_from] -= _value; // Subtract from the sender\n', '        balances[_to] += _value; // Add the same to the recipient\n', '        allowance[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // create new tokens, called only by owner, new token value supplied will be added to _to address with total supply\n', '    function mint(address _to, uint256 _value) onlyOwner\n', '    {\n', '        if(!flag)\n', '        {\n', '        balances[_to] += _value;\n', '    \ttotalSupply += _value;\n', '        }\n', '        else\n', '        revert();\n', '    }\n', '\n', '   //owner can call this freeze function to freeze some accounts from doing certain functions\n', '    function freeze(address target, bool freeze) onlyOwner\n', '    {\n', '        if(!flag)\n', '        {\n', '        frozenAccount[target] = freeze;\n', '        FrozenFu(target,freeze);  \n', '        }\n', '        else\n', '        revert();\n', '    }\n', '   // transfer the ownership to new address, called only by owner\n', '   function transferOwnership(address to) public onlyOwner {\n', '         owner = to;\n', '         balances[owner]=balances[msg.sender];\n', '         balances[msg.sender]=0;\n', '    }\n', '    // flag function called by ony owner, stopping some function to work for\n', '    function turn_flag_ON() onlyOwner\n', '    {\n', '        flag = true;\n', '    }\n', '    // flag function called by owner, releasing some function to work for\n', '    function turn_flag_OFF() onlyOwner\n', '    {\n', '        flag = false;\n', '    }\n', '    //Drain Any Ether in contract to owner\n', '    function drain() public onlyOwner {\n', '        if (!owner.send(this.balance)) throw;\n', '    }\n', '}']