['pragma solidity ^0.4.11;\n', '\n', 'contract owned { \n', '    address public owner;\n', '    \n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', 'contract doftManaged { \n', '    address public doftManager;\n', '    \n', '    function doftManaged() {\n', '        doftManager = msg.sender;\n', '    }\n', '\n', '    modifier onlyDoftManager {\n', '        require(msg.sender == doftManager);\n', '        _;\n', '    }\n', '\n', '    function transferDoftManagment(address newDoftManager) onlyDoftManager {\n', '        doftManager = newDoftManager;\n', '\t//coins for mining should be transferred after transferring of doftManagment\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'contract BasicToken is ERC20 { \n', '    uint256 public totalSupply;\n', '    \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint totalSupply){\n', '        return totalSupply;\n', '    }\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance){\n', '        return balanceOf[_owner];\n', '    }\n', '\n', '    /* Internal transfer, only can be called by this contract */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (balanceOf[_from] > _value);                // Check if the sender has enough\n', '        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n', '\n', '        balanceOf[_from] -= _value;                         // Subtract from the sender\n', '        balanceOf[_to] += _value;                           // Add the same to the recipient\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n', '        require (_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '\t    Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '        return allowance[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract DoftToken is BasicToken, owned, doftManaged { \n', '    string public name; \n', '    string public symbol; \n', '    uint256 public decimals; \n', '    uint256 public sellPrice;\n', '    uint256 public buyPrice;\n', '    uint256 public miningStorage;\n', '    string public version; \n', '\n', '    event Mine(address target, uint256 minedAmount);\n', '\n', '    function DoftToken() {\n', '        decimals = 18;\n', '        totalSupply = 5000000 * (10 ** decimals);  // Update total supply\n', '        miningStorage = totalSupply / 2;\n', '        name = "Doftcoin";                                   // Set the name for display purposes\n', '        symbol = "DFC";                               // Set the symbol for display purposes\n', '\n', '        balanceOf[msg.sender] = totalSupply;              // Give the creator all initial tokens\n', '\tversion = "1.0";\n', '    }\n', '\n', '    /// @notice Create `_mintedAmount` tokens and send it to `_target`\n', '    /// @param _target Address to receive the tokens\n', '    /// @param _mintedAmount the amount of tokens it will receive\n', '    function mintToken(address _target, uint256 _mintedAmount) onlyOwner {\n', '        require (_target != 0x0);\n', '\n', '\t//ownership will be given to ICO after creation\n', '        balanceOf[_target] += _mintedAmount;\n', '        totalSupply += _mintedAmount;\n', '        Transfer(0, this, _mintedAmount);\n', '        Transfer(this, _target, _mintedAmount);\n', '    }\n', '\n', '    /// @notice Buy tokens from contract by sending ether\n', '    function buy() payable {\n', '\t    require(buyPrice > 0);\n', '        uint amount = msg.value / buyPrice;               // calculates the amount\n', '        _transfer(this, msg.sender, amount);              // makes the transfers\n', '    }\n', '\n', '    /// @notice Sell `_amount` tokens to contract\n', '    /// @param _amount Amount of tokens to be sold\n', '    function sell(uint256 _amount) {\n', '\t    require(sellPrice > 0);\n', '        require(this.balance >= _amount * sellPrice);      // checks if the contract has enough ether to buy\n', '        _transfer(msg.sender, this, _amount);              // makes the transfers\n', '        msg.sender.transfer(_amount * sellPrice);          // sends ether to the seller. It&#39;s important to do this last to avoid recursion attacks\n', '    }\n', '\n', '    /// @notice Allow users to buy tokens for `_newBuyPrice` eth and sell tokens for `_newSellPrice` eth\n', '    /// @param _newSellPrice Price the users can sell to the contract\n', '    /// @param _newBuyPrice Price users can buy from the contract\n', '    function setPrices(uint256 _newSellPrice, uint256 _newBuyPrice) onlyDoftManager {\n', '        sellPrice = _newSellPrice;\n', '        buyPrice = _newBuyPrice;\n', '    }\n', '\n', '    /// @notice Send `_minedAmount` to `_target` as a reward for mining\n', '    /// @param _target The address of the recipient\n', '    /// @param _minedAmount The amount of reward tokens\n', '    function mine(address _target, uint256 _minedAmount) onlyDoftManager {\n', '\trequire (_minedAmount > 0);\n', '        require (_target != 0x0);\n', '        require (miningStorage - _minedAmount >= 0);\n', '        require (balanceOf[doftManager] >= _minedAmount);                // Check if the sender has enough\n', '        require (balanceOf[_target] + _minedAmount > balanceOf[_target]); // Check for overflows\n', '\n', '\t    balanceOf[doftManager] -= _minedAmount;\n', '\t    balanceOf[_target] += _minedAmount;\n', '\t    miningStorage -= _minedAmount;\n', '\n', '\t    Mine(_target, _minedAmount);\n', '    } \n', '}']