['pragma solidity ^0.4.15;\n', '\n', '/**\n', ' *  Standard Interface for ERC20 Contract\n', ' */\n', 'contract IERC20 {\n', '    function totalSupply() constant returns (uint _totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', '/**\n', ' * Checking overflows for various operations\n', ' */\n', 'library SafeMathLib {\n', '\n', '/**\n', '* Issue: Change to internal constant\n', '**/\n', '  function minus(uint a, uint b) internal constant returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '/**\n', '* Issue: Change to internal constant\n', '**/\n', '  function plus(uint a, uint b) internal constant returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @notice The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '  mapping (address => bool) public accessHolder;\n', '\n', '  /**\n', '   * @notice The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @notice Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));\n', '    owner = newOwner;\n', '  }\n', '  \n', '  /**\n', '   * @notice Adds the provided addresses to Access List.\n', '   * @param user The address to user to whom access is to be granted.\n', '   */\n', '  function addToAccesslist(address user) onlyOwner {\n', '    accessHolder[user] = true;\n', '  }\n', '  \n', '}\n', '\n', '\n', '/**\n', ' * @title BitIndia Coin\n', ' * @notice The ERC20 Token for Cove Identity.\n', ' */\n', 'contract BitIndia is IERC20, Ownable {\n', '    \n', '    using SafeMathLib for uint256;\n', '    \n', '    uint256 public constant totalTokenSupply = 180000000 * 10**18;\n', '\n', '    string public name;    // BitIndia\n', '    string public symbol;  // BitIndia\n', '    uint8 public constant decimals = 18;\n', '    \n', '    uint private publicTransferDealine = 1509494400; //11/01/2017 @ 12:00am (UTC)\n', '    bool private isPublicTransferAllowed = false;\n', '    \n', '    \n', '    mapping (address => uint256) public balances;\n', '    //approved[owner][spender]\n', '    mapping(address => mapping(address => uint256)) approved;\n', '    \n', '    function BitIndia(string tokenName, string tokenSymbol) {\n', '        \n', '        name = tokenName;\n', '        symbol = tokenSymbol;\n', '        balances[msg.sender] = totalTokenSupply;\n', '\n', '    }\n', '    \n', '    function totalSupply() constant returns (uint256 _totalSupply) {\n', '        return totalTokenSupply;\n', '    }\n', '    \n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    /* Internal transfer, only can be called by this contract */\n', '    function _transfer(address _from, address _to, uint256 _value) internal {\n', '        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (balances[_from] >= _value);                 // Check if the sender has enough\n', '        require (balances[_to] + _value > balances[_to]);   // Check for overflows\n', '        balances[_from] = balances[_from].minus(_value);    // Subtract from the sender\n', '        balances[_to] = balances[_to].plus(_value);         // Add the same to the recipient\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * @notice Send `_value` tokens to `_to` from your account\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @notice Send `_value` tokens to `_to` on behalf of `_from`\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        require (_value <= approved[_from][msg.sender]);     // Check allowance\n', '        approved[_from][msg.sender] = approved[_from][msg.sender].minus(_value);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @notice Approve `_value` tokens for `_spender`\n', '     * @param _spender The address of the sender\n', '     * @param _value the amount to send\n', '     */\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        if(balances[msg.sender] >= _value) {\n', '            approved[msg.sender][_spender] = _value;\n', '            Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    /**\n', '     * @notice Check `_value` tokens allowed to `_spender` by `_owner`\n', '     * @param _owner The address of the Owner\n', '     * @param _spender The address of the Spender\n', '     */\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return approved[_owner][_spender];\n', '    }\n', '    \n', '    /**\n', '     * @notice Function to allow the Token users to transfer\n', '     * among themselves.\n', '     */\n', '    function allowPublicTransfer() onlyOwner {\n', '        isPublicTransferAllowed = true;\n', '    }\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    \n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    \n', '}']