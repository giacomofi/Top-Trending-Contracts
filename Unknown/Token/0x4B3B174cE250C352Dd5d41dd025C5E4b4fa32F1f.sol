['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-06\n', '*/\n', '\n', '// File: solidity/solidity/Owned.sol\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /*\n', '        allows transferring the contract ownership\n', '        can only be called by the contract owner\n', '    */\n', '    function setOwner(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        address prevOwner = owner;\n', '        owner = _newOwner;\n', '        OwnerUpdate(prevOwner, owner);\n', '    }\n', '}\n', '\n', '// File: solidity/solidity/ERC20TokenInterface.sol\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract ERC20TokenInterface {\n', "    // these functions aren't abstract since the compiler doesn't recognize automatically generated getter functions as functions\n", '    function totalSupply() public constant returns (uint256 totalSupply) {}\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {}\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '// File: solidity/solidity/ERC20Token.sol\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', '\n', '/*\n', '    ERC20 Standard Token implementation\n', '*/\n', 'contract ERC20Token is ERC20TokenInterface {\n', "    string public standard = 'Token 0.1';\n", "    string public name = '';\n", "    string public symbol = '';\n", '    uint256 public totalSupply = 0;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function ERC20Token(string _name, string _symbol) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '    }\n', '\n', "    // validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        assert(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    /*\n', '        send coins\n', '        note that the function slightly deviates from the ERC20 standard and will throw on any error rather then return a boolean return value to minimize user errors\n', '    */\n', '    function transfer(address _to, uint256 _value)\n', '        public\n', '        validAddress(_to)\n', '        returns (bool success)\n', '    {\n', '        require(_value <= balanceOf[msg.sender]); // balance check\n', '        assert(balanceOf[_to] + _value >= balanceOf[_to]); // overflow protection\n', '\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        an account/contract attempts to get the coins\n', '        note that the function slightly deviates from the ERC20 standard and will throw on any error rather then return a boolean return value to minimize user errors\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        validAddress(_from)\n', '        validAddress(_to)\n', '        returns (bool success)\n', '    {\n', '        require(_value <= balanceOf[_from]); // balance check\n', '        require(_value <= allowance[_from][msg.sender]); // allowance check\n', '        assert(balanceOf[_to] + _value >= balanceOf[_to]); // overflow protection\n', '\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        allowance[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        allow another account/contract to spend some tokens on your behalf\n', '        note that the function slightly deviates from the ERC20 standard and will throw on any error rather then return a boolean return value to minimize user errors\n', '\n', '        also, to minimize the risk of the approve/transferFrom attack vector\n', '        (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\n', '        in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\n', '    */\n', '    function approve(address _spender, uint256 _value)\n', '        public\n', '        validAddress(_spender)\n', '        returns (bool success)\n', '    {\n', "        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\n", '        require(_value == 0 || allowance[msg.sender][_spender] == 0);\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: solidity/solidity/BancorEventsInterface.sol\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', '/*\n', '    Bancor events interface\n', '*/\n', 'contract BancorEventsInterface {\n', '    event NewToken(address _token);\n', '    event TokenOwnerUpdate(address indexed _token, address _prevOwner, address _newOwner);\n', '    event TokenChangerUpdate(address indexed _token, address _prevChanger, address _newChanger);\n', '    event TokenTransfer(address indexed _token, address indexed _from, address indexed _to, uint256 _value);\n', '    event TokenApproval(address indexed _token, address indexed _owner, address indexed _spender, uint256 _value);\n', '    event TokenChange(address indexed _sender, address indexed _fromToken, address indexed _toToken, address _changer, uint256 _amount, uint256 _return);\n', '\n', '    function newToken() public;\n', '    function tokenOwnerUpdate(address _prevOwner, address _newOwner) public;\n', '    function tokenChangerUpdate(address _prevChanger, address _newChanger) public;\n', '    function tokenTransfer(address _from, address _to, uint256 _value) public;\n', '    function tokenApproval(address _owner, address _spender, uint256 _value) public;\n', '    function tokenChange(address _fromToken, address _toToken, address _changer, uint256 _amount, uint256 _return) public;\n', '}\n', '\n', '// File: solidity/solidity/SmartToken.sol\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '    Smart Token v0.1\n', '*/\n', 'contract SmartToken is Owned, ERC20Token {\n', "    string public version = '0.1';\n", '    uint8 public numDecimalUnits = 0;   // for display purposes only\n', '    address public events = 0x0;        // bancor events contract address\n', '    address public changer = 0x0;       // changer contract address\n', '    bool public transfersEnabled = true;\n', '\n', '    // events, can be used to listen to the contract directly, as opposed to through the events contract\n', '    event ChangerUpdate(address _prevChanger, address _newChanger);\n', '\n', '    /*\n', '        _name               token name\n', '        _symbol             token short symbol, 1-6 characters\n', '        _numDecimalUnits    for display purposes only\n', '        _formula            address of a bancor formula contract\n', '        _events             optional, address of a bancor events contract\n', '    */\n', '    function SmartToken(string _name, string _symbol, uint8 _numDecimalUnits, address _events)\n', '        ERC20Token(_name, _symbol)\n', '    {\n', '        require(bytes(_name).length != 0 && bytes(_symbol).length >= 1 && bytes(_symbol).length <= 6); // validate input\n', '\n', '        numDecimalUnits = _numDecimalUnits;\n', '        events = _events;\n', '        if (events == 0x0)\n', '            return;\n', '\n', '        BancorEventsInterface eventsContract = BancorEventsInterface(events);\n', '        eventsContract.newToken();\n', '    }\n', '\n', "    // allows execution only when transfers aren't disabled\n", '    modifier transfersAllowed {\n', '        assert(transfersEnabled);\n', '        _;\n', '    }\n', '\n', "    // allows execution by the owner if there's no changer defined or by the changer contract if a changer is defined\n", '    modifier managerOnly {\n', '        assert((changer == 0x0 && msg.sender == owner) ||\n', '               (changer != 0x0 && msg.sender == changer)); // validate state & permissions\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _newOwner)\n', '        public\n', '        ownerOnly\n', '        validAddress(_newOwner)\n', '    {\n', '        address prevOwner = owner;\n', '        super.setOwner(_newOwner);\n', '        if (events == 0x0)\n', '            return;\n', '\n', '        BancorEventsInterface eventsContract = BancorEventsInterface(events);\n', '        eventsContract.tokenOwnerUpdate(prevOwner, owner);\n', '    }\n', '\n', '    /*\n', '        sets the number of display decimal units\n', '        can only be called by the token owner\n', '\n', '        _numDecimalUnits    new number of decimal units\n', '    */\n', '    function setNumDecimalUnits(uint8 _numDecimalUnits) public ownerOnly {\n', '        numDecimalUnits = _numDecimalUnits;\n', '    }\n', '\n', '    /*\n', '        disables/enables transfers\n', '        can only be called by the token owner (if no changer is defined) or the changer contract (if a changer is defined)\n', '\n', '        _disable    true to disable transfers, false to enable them\n', '    */\n', '    function disableTransfers(bool _disable) public managerOnly {\n', '        transfersEnabled = !_disable;\n', '    }\n', '\n', '    /*\n', '        increases the token supply and sends the new tokens to an account\n', '        can only be called by the token owner (if no changer is defined) or the changer contract (if a changer is defined)\n', '\n', '        _to         account to receive the new amount\n', '        _amount     amount to increase the supply by\n', '    */\n', '    function issue(address _to, uint256 _amount)\n', '        public\n', '        managerOnly\n', '        validAddress(_to)\n', '        returns (bool success)\n', '    {\n', '         // validate input\n', '        require(_to != address(this) && _amount != 0);\n', '         // supply overflow protection\n', '        assert(totalSupply + _amount >= totalSupply);\n', '        // target account balance overflow protection\n', '        assert(balanceOf[_to] + _amount >= balanceOf[_to]);\n', '\n', '        totalSupply += _amount;\n', '        balanceOf[_to] += _amount;\n', '        dispatchTransfer(this, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        removes tokens from an account and decreases the token supply\n', '        can only be called by the token owner (if no changer is defined) or the changer contract (if a changer is defined)\n', '\n', '        _from       account to remove the new amount from\n', '        _amount     amount to decrease the supply by\n', '    */\n', '    function destroy(address _from, uint256 _amount)\n', '        public\n', '        managerOnly\n', '        validAddress(_from)\n', '        returns (bool success)\n', '    {\n', '        require(_from != address(this) && _amount != 0 && _amount <= balanceOf[_from]); // validate input\n', '\n', '        totalSupply -= _amount;\n', '        balanceOf[_from] -= _amount;\n', '        dispatchTransfer(_from, this, _amount);\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        sets a changer contract address\n', '        can only be called by the token owner (if no changer is defined) or the changer contract (if a changer is defined)\n', '        the changer can be set to null to transfer ownership from the changer to the owner\n', '\n', '        _changer            new changer contract address (can also be set to 0x0 to remove the current changer)\n', '    */\n', '    function setChanger(address _changer) public managerOnly returns (bool success) {\n', '        require(_changer != changer);\n', '        address prevChanger = changer;\n', '        changer = _changer;\n', '        dispatchChangerUpdate(prevChanger, changer);\n', '        return true;\n', '    }\n', '\n', '    // ERC20 standard method overrides with some extra functionality\n', '\n', '    // send coins\n', '    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {\n', '        assert(super.transfer(_to, _value));\n', '\n', '        // transferring to the contract address destroys tokens\n', '        if (_to == address(this)) {\n', '            balanceOf[_to] -= _value;\n', '            totalSupply -= _value;\n', '        }\n', '\n', '        if (events == 0x0)\n', '            return;\n', '\n', '        BancorEventsInterface eventsContract = BancorEventsInterface(events);\n', '        eventsContract.tokenTransfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // an account/contract attempts to get the coins\n', '    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) {\n', '        assert(super.transferFrom(_from, _to, _value));\n', '\n', '        // transferring to the contract address destroys tokens\n', '        if (_to == address(this)) {\n', '            balanceOf[_to] -= _value;\n', '            totalSupply -= _value;\n', '        }\n', '\n', '        if (events == 0x0)\n', '            return;\n', '\n', '        BancorEventsInterface eventsContract = BancorEventsInterface(events);\n', '        eventsContract.tokenTransfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    // allow another account/contract to spend some tokens on your behalf\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        assert(super.approve(_spender, _value));\n', '        if (events == 0x0)\n', '            return true;\n', '\n', '        BancorEventsInterface eventsContract = BancorEventsInterface(events);\n', '        eventsContract.tokenApproval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    // utility\n', '\n', '    function dispatchChangerUpdate(address _prevChanger, address _newChanger) private {\n', '        ChangerUpdate(_prevChanger, _newChanger);\n', '        if (events == 0x0)\n', '            return;\n', '\n', '        BancorEventsInterface eventsContract = BancorEventsInterface(events);\n', '        eventsContract.tokenChangerUpdate(_prevChanger, _newChanger);\n', '    }\n', '\n', '    function dispatchTransfer(address _from, address _to, uint256 _value) private {\n', '        Transfer(_from, _to, _value);\n', '        if (events == 0x0)\n', '            return;\n', '\n', '        BancorEventsInterface eventsContract = BancorEventsInterface(events);\n', '        eventsContract.tokenTransfer(_from, _to, _value);\n', '    }\n', '\n', '    // fallback\n', '    function() {\n', '        assert(false);\n', '    }\n', '}']