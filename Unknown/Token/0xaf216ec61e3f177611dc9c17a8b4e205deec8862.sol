['pragma solidity ^0.4.11;\n', '\n', 'contract Owned {\n', '\n', '    /// `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    address newOwner=0x0;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    ///change the owner\n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /// accept the ownership\n', '    function acceptOwnership() public{\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', 'contract SafeMath {\n', '    function SafeMath() {\n', '    }\n', '\n', '    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', 'contract ERC20Token {\n', '\n', '    function name() public constant returns (string name) { name; }\n', '    function symbol() public constant returns (string symbol) { symbol; }\n', '    function decimals() public constant returns (uint8 decimals) { decimals; }\n', '    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '}\n', 'contract TokenHolder is Owned {\n', '    function TokenHolder() {\n', '    }\n', '\n', '    // validates an address - currently only checks that it isn&#39;t null\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address){\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '}\n', 'contract SmartToken is ERC20Token,TokenHolder{\n', '    function generateTokens(address _to, uint256 _amount) public;\n', '}\n', '\n', 'contract StandardToken is SmartToken,SafeMath {\n', '    string public name;\n', '    uint8 public decimals=18;\n', '    string public symbol;\n', '    string public version = &#39;V0.1&#39;;\n', '    uint256 public totalSupply=0;\n', '\n', '    bool public transferEnabled=false;\n', '    function StandardToken(string _name, string _symbol) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '    }\n', '    function transfer(address _to, uint256 _value) transferAllowed returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) transferAllowed returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '    /**\n', '        @dev increases the token supply and sends the new tokens to an account\n', '        can only be called by the contract owner\n', '\n', '        @param _to         account to receive the new amount\n', '        @param _amount     amount to increase the supply by\n', '    */\n', '    function generateTokens(address _to, uint256 _amount)\n', '        public\n', '        onlyOwner\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        totalSupply = safeAdd(totalSupply, _amount);\n', '        balances[_to] = safeAdd(balances[_to], _amount);\n', '\n', '        Transfer(this, _to, _amount);\n', '    }\n', '    //only owner can destroy the token\n', '    function destroy(address _from, uint256 _amount)\n', '        public\n', '        onlyOwner\n', '    {\n', '        balances[_from] = safeSub(balances[_from], _amount);\n', '        totalSupply = safeSub(totalSupply, _amount);\n', '\n', '        Transfer(_from, this, _amount);\n', '        Destroy(_from,_amount);\n', '    }\n', '    function enableTransfer(bool _enable) public onlyOwner{\n', '        transferEnabled=_enable;\n', '    }\n', '    modifier transferAllowed {\n', '        assert(transferEnabled);\n', '        _;\n', '    }\n', '\n', '    event Destroy(address indexed _from,uint256 _amount);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'contract Owned {\n', '\n', '    /// `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    address newOwner=0x0;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    ///change the owner\n', '    function changeOwner(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /// accept the ownership\n', '    function acceptOwnership() public{\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', 'contract SafeMath {\n', '    function SafeMath() {\n', '    }\n', '\n', '    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', 'contract ERC20Token {\n', '\n', '    function name() public constant returns (string name) { name; }\n', '    function symbol() public constant returns (string symbol) { symbol; }\n', '    function decimals() public constant returns (uint8 decimals) { decimals; }\n', '    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '}\n', 'contract TokenHolder is Owned {\n', '    function TokenHolder() {\n', '    }\n', '\n', "    // validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address){\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '}\n', 'contract SmartToken is ERC20Token,TokenHolder{\n', '    function generateTokens(address _to, uint256 _amount) public;\n', '}\n', '\n', 'contract StandardToken is SmartToken,SafeMath {\n', '    string public name;\n', '    uint8 public decimals=18;\n', '    string public symbol;\n', "    string public version = 'V0.1';\n", '    uint256 public totalSupply=0;\n', '\n', '    bool public transferEnabled=false;\n', '    function StandardToken(string _name, string _symbol) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '    }\n', '    function transfer(address _to, uint256 _value) transferAllowed returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) transferAllowed returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '    /**\n', '        @dev increases the token supply and sends the new tokens to an account\n', '        can only be called by the contract owner\n', '\n', '        @param _to         account to receive the new amount\n', '        @param _amount     amount to increase the supply by\n', '    */\n', '    function generateTokens(address _to, uint256 _amount)\n', '        public\n', '        onlyOwner\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        totalSupply = safeAdd(totalSupply, _amount);\n', '        balances[_to] = safeAdd(balances[_to], _amount);\n', '\n', '        Transfer(this, _to, _amount);\n', '    }\n', '    //only owner can destroy the token\n', '    function destroy(address _from, uint256 _amount)\n', '        public\n', '        onlyOwner\n', '    {\n', '        balances[_from] = safeSub(balances[_from], _amount);\n', '        totalSupply = safeSub(totalSupply, _amount);\n', '\n', '        Transfer(_from, this, _amount);\n', '        Destroy(_from,_amount);\n', '    }\n', '    function enableTransfer(bool _enable) public onlyOwner{\n', '        transferEnabled=_enable;\n', '    }\n', '    modifier transferAllowed {\n', '        assert(transferEnabled);\n', '        _;\n', '    }\n', '\n', '    event Destroy(address indexed _from,uint256 _amount);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}']
