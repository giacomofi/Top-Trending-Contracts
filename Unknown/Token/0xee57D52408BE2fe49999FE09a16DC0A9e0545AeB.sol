['pragma solidity ^0.4.8;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    function changeOwner(address _addr) onlyOwner {\n', '        if (_addr == 0x0) throw;\n', '        owner = _addr;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) throw;\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Mutex is Owned {\n', '    bool locked = false;\n', '    modifier mutexed {\n', '        if (locked) throw;\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '\n', '    function unMutex() onlyOwner {\n', '        locked = false;\n', '    }\n', '}\n', '\n', '\n', 'contract Rental is Owned {\n', '    function Rental(address _owner) {\n', '        if (_owner == 0x0) throw;\n', '        owner = _owner;\n', '    }\n', '\n', '    function offer(address from, uint num) {\n', '\n', '    }\n', '\n', '    function claimBalance(address) returns(uint) {\n', '        return 0;\n', '    }\n', '\n', '    function exec(address dest) onlyOwner {\n', '        if (!dest.call(msg.data)) throw;\n', '    }\n', '}\n', '\n', 'contract Token is Owned, Mutex {\n', '    uint ONE = 10**8;\n', '    uint price = 5000;\n', '    Ledger ledger;\n', '    Rental rentalContract;\n', '    uint8 rollOverTime = 4;\n', '    uint8 startTime = 8;\n', '    bool live = false;\n', '    address club;\n', '    uint lockedSupply = 0;\n', '    string public name;\n', '    uint8 public decimals; \n', '    string public symbol;     \n', '    string public version = &#39;0.1&#39;;  \n', '    bool transfersOn = false;\n', '\n', '\n', '\n', '    function Token(address _owner, string _tokenName, uint8 _decimals, string _symbol, address _ledger, address _rental) {\n', '        if (_owner == 0x0) throw;\n', '        owner = _owner;\n', '\n', '        name = _tokenName;\n', '        decimals = _decimals;\n', '        symbol = _symbol;\n', '        ONE = 10**uint(decimals);\n', '        ledger = Ledger(_ledger);\n', '        rentalContract = Rental(_rental);\n', '    }\n', '\n', '    /*\n', '    *\tBookkeeping and Admin Functions\n', '    */\n', '\n', '    event LedgerUpdated(address,address);\n', '\n', '    function changeClub(address _addr) onlyOwner {\n', '        if (_addr == 0x0) throw;\n', '\n', '        club = _addr;\n', '    }\n', '\n', '    function changePrice(uint _num) onlyOwner {\n', '        price = _num;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) returns (uint) {\n', '        if ((a + b) < a) throw;\n', '        return (a + b);\n', '    }\n', '\n', '    function changeLedger(address _addr) onlyOwner {\n', '        if (_addr == 0x0) throw;\n', '\n', '        LedgerUpdated(msg.sender, _addr);\n', '        ledger = Ledger(_addr);\n', '    }\n', '\n', '    function changeRental(address _addr) onlyOwner {\n', '        if (_addr == 0x0) throw;\n', '        rentalContract = Rental(_addr);\n', '    }\n', '\n', '    function changeTimes(uint8 _rollOver, uint8 _start) onlyOwner {\n', '        rollOverTime = _rollOver;\n', '        startTime = _start;\n', '    }\n', '\n', '    /*\n', '    * Locking is a feature that turns a user&#39;s balances into\n', '    * un-issued tokens, taking them out of an account and reducing the supply.\n', '    * Diluting is so named to remind the caller that they are changing the money supply.\n', '        */\n', '\n', '    function lock(address _seizeAddr) onlyOwner mutexed {\n', '        uint myBalance = ledger.balanceOf(_seizeAddr);\n', '\n', '        lockedSupply += myBalance;\n', '        ledger.setBalance(_seizeAddr, 0);\n', '    }\n', '\n', '    event Dilution(address, uint);\n', '\n', '    function dilute(address _destAddr, uint amount) onlyOwner {\n', '        if (amount > lockedSupply) throw;\n', '\n', '        Dilution(_destAddr, amount);\n', '\n', '        lockedSupply -= amount;\n', '\n', '        uint curBalance = ledger.balanceOf(_destAddr);\n', '        curBalance = safeAdd(amount, curBalance);\n', '        ledger.setBalance(_destAddr, curBalance);\n', '    }\n', '\n', '    /* \n', '     * Crowdsale -- \n', '     *\n', '     */\n', '    function completeCrowdsale() onlyOwner {\n', '        // Lock unsold tokens\n', '        // allow transfers for arbitrary owners\n', '        transfersOn = true;\n', '        lock(owner);\n', '    }\n', '\n', '    function pauseTransfers() onlyOwner {\n', '        transfersOn = false;\n', '    }\n', '\n', '    function resumeTransfers() onlyOwner {\n', '        transfersOn = true;\n', '    }\n', '\n', '    /*\n', '    * Renting -- Logic TBD later. For now, we trust the rental contract\n', '    * to manage everything about the rentals, including bookkeeping on earnings\n', '    * and returning tokens.\n', '    */\n', '\n', '    function rentOut(uint num) {\n', '        if (ledger.balanceOf(msg.sender) < num) throw;\n', '        rentalContract.offer(msg.sender, num);\n', '        ledger.tokenTransfer(msg.sender, rentalContract, num);\n', '    }\n', '\n', '    function claimUnrented() {  \n', '        uint amount = rentalContract.claimBalance(msg.sender); // this should reduce sender&#39;s claimableBalance to 0\n', '\n', '        ledger.tokenTransfer(rentalContract, msg.sender, amount);\n', '    }\n', '\n', '    /*\n', '    * Burning -- We allow any user to burn tokens.\n', '    *\n', '     */\n', '\n', '    function burn(uint _amount) {\n', '        uint balance = ledger.balanceOf(msg.sender);\n', '        if (_amount > balance) throw;\n', '\n', '        ledger.setBalance(msg.sender, balance - _amount);\n', '    }\n', '\n', '    /*\n', '    Entry\n', '    */\n', '    function checkIn(uint _numCheckins) returns(bool) {\n', '        int needed = int(price * ONE* _numCheckins);\n', '        if (int(ledger.balanceOf(msg.sender)) > needed) {\n', '            ledger.changeUsed(msg.sender, needed);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    // ERC20 Support. This could also use the fallback but\n', '    // I prefer the control for now.\n', '\n', '    event Transfer(address, address, uint);\n', '    event Approval(address, address, uint);\n', '\n', '    function totalSupply() constant returns(uint) {\n', '        return ledger.totalSupply();\n', '    }\n', '\n', '    function transfer(address _to, uint _amount) returns(bool) {\n', '        if (!transfersOn && msg.sender != owner) return false;\n', '        if (! ledger.tokenTransfer(msg.sender, _to, _amount)) { return false; }\n', '\n', '        Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _amount) returns (bool) {\n', '        if (!transfersOn && msg.sender != owner) return false;\n', '        if (! ledger.tokenTransferFrom(msg.sender, _from, _to, _amount) ) { return false;}\n', '\n', '        Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _from, address _to) constant returns(uint) {\n', '        return ledger.allowance(_from, _to); \n', '    }\n', '\n', '    function approve(address _spender, uint _value) returns (bool) {\n', '        if ( ledger.tokenApprove(msg.sender, _spender, _value) ) {\n', '            Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function balanceOf(address _addr) constant returns(uint) {\n', '        return ledger.balanceOf(_addr);\n', '    }\n', '}\n', '\n', 'contract Ledger is Owned {\n', '    mapping (address => uint) balances;\n', '    mapping (address => uint) usedToday;\n', '\n', '    mapping (address => bool) seenHere;\n', '    address[] public seenHereA;\n', '\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    address token;\n', '    uint public totalSupply = 0;\n', '\n', '    function Ledger(address _owner, uint _preMined, uint ONE) {\n', '        if (_owner == 0x0) throw;\n', '        owner = _owner;\n', '\n', '        seenHere[_owner] = true;\n', '        seenHereA.push(_owner);\n', '\n', '        totalSupply = _preMined *ONE;\n', '        balances[_owner] = totalSupply;\n', '    }\n', '\n', '    modifier onlyToken {\n', '        if (msg.sender != token) throw;\n', '        _;\n', '    }\n', '\n', '    modifier onlyTokenOrOwner {\n', '        if (msg.sender != token && msg.sender != owner) throw;\n', '        _;\n', '    }\n', '\n', '\n', '    function tokenTransfer(address _from, address _to, uint amount) onlyToken returns(bool) {\n', '        if (amount > balances[_from]) return false;\n', '        if ((balances[_to] + amount) < balances[_to]) return false;\n', '        if (amount == 0) { return false; }\n', '\n', '        balances[_from] -= amount;\n', '        balances[_to] += amount;\n', '\n', '        if (seenHere[_to] == false) {\n', '            seenHereA.push(_to);\n', '            seenHere[_to] = true;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function tokenTransferFrom(address _sender, address _from, address _to, uint amount) onlyToken returns(bool) {\n', '        if (allowed[_from][_sender] <= amount) return false;\n', '        if (amount > balanceOf(_from)) return false;\n', '        if (amount == 0) return false;\n', '\n', '        if ((balances[_to] + amount) < amount) return false;\n', '\n', '        balances[_from] -= amount;\n', '        balances[_to] += amount;\n', '        allowed[_from][_sender] -= amount;\n', '\n', '        if (seenHere[_to] == false) {\n', '            seenHereA.push(_to);\n', '            seenHere[_to] = true;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '    function changeUsed(address _addr, int amount) onlyToken {\n', '        int myToday = int(usedToday[_addr]) + amount;\n', '        usedToday[_addr] = uint(myToday);\n', '    }\n', '\n', '    function resetUsedToday(uint8 startI, uint8 numTimes) onlyTokenOrOwner returns(uint8) {\n', '        uint8 numDeleted;\n', '        for (uint i = 0; i < numTimes && i + startI < seenHereA.length; i++) {\n', '            if (usedToday[seenHereA[i+startI]] != 0) { \n', '                delete usedToday[seenHereA[i+startI]];\n', '                numDeleted++;\n', '            }\n', '        }\n', '        return numDeleted;\n', '    }\n', '\n', '    function balanceOf(address _addr) constant returns (uint) {\n', '        // don&#39;t forget to subtract usedToday\n', '        if (usedToday[_addr] >= balances[_addr]) { return 0;}\n', '        return balances[_addr] - usedToday[_addr];\n', '    }\n', '\n', '    event Approval(address, address, uint);\n', '\n', '    function tokenApprove(address _from, address _spender, uint256 _value) onlyToken returns (bool) {\n', '        allowed[_from][_spender] = _value;\n', '        Approval(_from, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function changeToken(address _token) onlyOwner {\n', '        token = Token(_token);\n', '    }\n', '\n', '    function reduceTotalSupply(uint amount) onlyToken {\n', '        if (amount > totalSupply) throw;\n', '\n', '        totalSupply -= amount;    \n', '    }\n', '\n', '    function setBalance(address _addr, uint amount) onlyTokenOrOwner {\n', '        if (balances[_addr] == amount) { return; }\n', '        if (balances[_addr] < amount) {\n', '            // increasing totalSupply\n', '            uint increase = amount - balances[_addr];\n', '            totalSupply += increase;\n', '        } else {\n', '            // decreasing totalSupply\n', '            uint decrease = balances[_addr] - amount;\n', '            //TODO: safeSub\n', '            totalSupply -= decrease;\n', '        }\n', '        balances[_addr] = amount;\n', '    }\n', '\n', '}']