['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is Token {\n', '    \n', '    mapping (address => uint256) balances;    \n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '      if (_to == 0x0) return false;\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256){\n', '        return balances[_owner];\n', '    }\n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value)\n', '        returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract KairosToken is StandardToken {\n', '\n', '  using SafeMath for uint256;\n', '  mapping(address => bool) frozenAccount;\n', '  mapping(address => uint256) bonus; \n', '\n', '  address public kairosOwner;\n', '  string  public constant name         = "KAIROS";\n', '  string  public constant symbol       = "KRX";\n', '  string  public constant version      = "1.0";\n', '  uint256 public constant decimals     = 18;  \n', '  uint256 public initialSupply         = 25 * (10**6) * 10**decimals;\n', '  uint256 public totalSupply;\n', '  uint256 public sellPrice;\n', '  uint256 public buyPrice;\n', '\n', '  event CreateNertia(address indexed _to, uint256 _value);\n', '  event Burn(address indexed _from, uint256 _value);\n', '  event FrozenFunds(address indexed _target, bool _frozen );\n', '  event Mint(address indexed _to, uint256 _value);\n', '  \n', '  \n', '  modifier onlyOwner{ \n', '    if ( msg.sender != kairosOwner) throw; \n', '    _; \n', '  }    \n', '\n', '  function KairosToken(){\n', '    kairosOwner            = msg.sender;\n', '    balances[kairosOwner]  = initialSupply;\n', '    totalSupply            = initialSupply;\n', '    CreateNertia(kairosOwner, initialSupply);\n', '  }\n', '\n', '  function buy() payable returns (uint256 amount) {\n', '    amount = msg.value / buyPrice;\n', '    if(balances[kairosOwner] < amount) throw;\n', '    balances[msg.sender] += amount;\n', '    balances[kairosOwner] -= amount;    \n', '    Transfer(kairosOwner, msg.sender, amount);\n', '    return amount;\n', '  }\n', '\n', '  function sell(uint256 amount){\n', '    if(balances[msg.sender] < amount) throw;\n', '    balances[kairosOwner] += amount;\n', '    balances[msg.sender] -= amount;\n', '    if(!msg.sender.send(amount.mul(sellPrice))){\n', '        throw;\n', '    }\n', '    Transfer(msg.sender, kairosOwner, amount);    \n', '  }\n', '\n', '  function setPrices(uint256 newSellPrice, uint256 newBuyPrice){\n', '    sellPrice = newSellPrice;\n', '    buyPrice = newBuyPrice;\n', '  }\n', '  \n', '\n', '  function transfer(address _to, uint256 _value) returns (bool success) {\n', '      if (_to == 0x0) return false;\n', '      if (!frozenAccount[msg.sender] && balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      }\n', '      return false;      \n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      if(!frozenAccount[msg.sender] && balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      }\n', '      return false;\n', '      \n', '  }\n', '\n', '  function burn(uint256 _value) returns (bool success) {\n', '    if (balances[msg.sender] < _value) throw;            \n', '    balances[msg.sender] -= _value;                      \n', '    totalSupply -= _value;                                \n', '    Burn(msg.sender, _value);\n', '    return true;\n', '  }\n', '\n', '  function burnFrom(address _from, uint256 _value) returns (bool success) {\n', '    if (balances[_from] < _value) throw;                \n', '    if (_value > allowed[_from][msg.sender]) throw;    \n', '    balances[_from] -= _value;                          \n', '    totalSupply -= _value;                               \n', '    Burn(_from, _value);\n', '    return true;\n', '  }\n', '\n', '  function freezeAccount(address _target, bool frozen){\n', '    frozenAccount[_target] = frozen;\n', '    FrozenFunds(_target, frozen);\n', '  }\n', '\n', '  function getDecimals() public returns (uint256){\n', '    return decimals;\n', '  }\n', '\n', '  function getOwner() public returns (address){\n', '    return kairosOwner;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is Token {\n', '    \n', '    mapping (address => uint256) balances;    \n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '      if (_to == 0x0) return false;\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256){\n', '        return balances[_owner];\n', '    }\n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value)\n', '        returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract KairosToken is StandardToken {\n', '\n', '  using SafeMath for uint256;\n', '  mapping(address => bool) frozenAccount;\n', '  mapping(address => uint256) bonus; \n', '\n', '  address public kairosOwner;\n', '  string  public constant name         = "KAIROS";\n', '  string  public constant symbol       = "KRX";\n', '  string  public constant version      = "1.0";\n', '  uint256 public constant decimals     = 18;  \n', '  uint256 public initialSupply         = 25 * (10**6) * 10**decimals;\n', '  uint256 public totalSupply;\n', '  uint256 public sellPrice;\n', '  uint256 public buyPrice;\n', '\n', '  event CreateNertia(address indexed _to, uint256 _value);\n', '  event Burn(address indexed _from, uint256 _value);\n', '  event FrozenFunds(address indexed _target, bool _frozen );\n', '  event Mint(address indexed _to, uint256 _value);\n', '  \n', '  \n', '  modifier onlyOwner{ \n', '    if ( msg.sender != kairosOwner) throw; \n', '    _; \n', '  }    \n', '\n', '  function KairosToken(){\n', '    kairosOwner            = msg.sender;\n', '    balances[kairosOwner]  = initialSupply;\n', '    totalSupply            = initialSupply;\n', '    CreateNertia(kairosOwner, initialSupply);\n', '  }\n', '\n', '  function buy() payable returns (uint256 amount) {\n', '    amount = msg.value / buyPrice;\n', '    if(balances[kairosOwner] < amount) throw;\n', '    balances[msg.sender] += amount;\n', '    balances[kairosOwner] -= amount;    \n', '    Transfer(kairosOwner, msg.sender, amount);\n', '    return amount;\n', '  }\n', '\n', '  function sell(uint256 amount){\n', '    if(balances[msg.sender] < amount) throw;\n', '    balances[kairosOwner] += amount;\n', '    balances[msg.sender] -= amount;\n', '    if(!msg.sender.send(amount.mul(sellPrice))){\n', '        throw;\n', '    }\n', '    Transfer(msg.sender, kairosOwner, amount);    \n', '  }\n', '\n', '  function setPrices(uint256 newSellPrice, uint256 newBuyPrice){\n', '    sellPrice = newSellPrice;\n', '    buyPrice = newBuyPrice;\n', '  }\n', '  \n', '\n', '  function transfer(address _to, uint256 _value) returns (bool success) {\n', '      if (_to == 0x0) return false;\n', '      if (!frozenAccount[msg.sender] && balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      }\n', '      return false;      \n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      if(!frozenAccount[msg.sender] && balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      }\n', '      return false;\n', '      \n', '  }\n', '\n', '  function burn(uint256 _value) returns (bool success) {\n', '    if (balances[msg.sender] < _value) throw;            \n', '    balances[msg.sender] -= _value;                      \n', '    totalSupply -= _value;                                \n', '    Burn(msg.sender, _value);\n', '    return true;\n', '  }\n', '\n', '  function burnFrom(address _from, uint256 _value) returns (bool success) {\n', '    if (balances[_from] < _value) throw;                \n', '    if (_value > allowed[_from][msg.sender]) throw;    \n', '    balances[_from] -= _value;                          \n', '    totalSupply -= _value;                               \n', '    Burn(_from, _value);\n', '    return true;\n', '  }\n', '\n', '  function freezeAccount(address _target, bool frozen){\n', '    frozenAccount[_target] = frozen;\n', '    FrozenFunds(_target, frozen);\n', '  }\n', '\n', '  function getDecimals() public returns (uint256){\n', '    return decimals;\n', '  }\n', '\n', '  function getOwner() public returns (address){\n', '    return kairosOwner;\n', '  }\n', '\n', '}']
