['/// @title Cryptocurrency  of the Ravensburg-Weingarten University of Applied Sciences ///(German: Hochschule Ravensburg-Weingarten) \n', '///@author Walther,Dominik \n', '\n', 'pragma solidity ^0.4.13; contract owned { address public owner;\n', '  function owned() {\n', '      owner = msg.sender;\n', '  }\n', '  modifier onlyOwner {\n', '      require(msg.sender == owner);\n', '      _;\n', '  }\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '      owner = newOwner;\n', '  }\n', '}\n', '/// receive other cryptocurrency\n', 'contract tokenRecipient { function receiveApproval(address from, uint256 value, address token, bytes extraData); }\n', '\n', '/// the public variables of the HRWtoken\n', 'contract HRWtoken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice;\n', '///@notice create an array with all adresses and associated balances of the cryptocurrency\n', '\n', '  mapping (address => uint256) public balanceOf;\n', '  mapping (address => mapping (address => uint256)) public allowance;\n', '\n', ' ///@notice generate a event on the blockchain to show transfer information \n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '///@notice initialization of the contract and distribution of tokes to the creater\n', '  function HRWtoken(\n', '      uint256 initialSupply,\n', '      string tokenName,\n', '      uint8 decimalUnits,\n', '      string tokenSymbol,\n', 'address centralMinter\n', '      ) {\n', 'if(centralMinter != 0 ) owner = centralMinter;\n', '      balanceOf[msg.sender] = initialSupply;       \n', '      totalSupply = initialSupply;                        \n', '      name = tokenName;                                   \n', '      symbol = tokenSymbol;                               \n', '      decimals = decimalUnits;                            \n', '  }\n', '\n', '  ///@notice only the contract can operate this internal funktion\n', '  function _transfer(address _from, address _to, uint _value) internal {\n', '      require (_to != 0x0);           \n', '      require (balanceOf[_from] >= _value);            \n', '      require (balanceOf[_to] + _value > balanceOf[_to]); \n', '      balanceOf[_from] -= _value;                         \n', '      balanceOf[_to] += _value;                            \n', '      Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /// @notice transfer to account (_to) any value (_value)\n', '  /// @param _to The address of the reciver\n', '  /// @param _value value units from the cryptocurrency\n', '  function transfer(address _to, uint256 _value) {\n', '      _transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /// @notice to dend the tokens the sender need the allowance \n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value value units to send\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      require (_value < allowance[_from][msg.sender]);     \n', '      allowance[_from][msg.sender] -= _value;\n', '      _transfer(_from, _to, _value);\n', '      return true;\n', '  }\n', '\n', '  /// @notice the spender can only transfer the value units he own\n', '  /// @param _spender the address authorized to transfer\n', '  /// @param _value the max amount they can spend\n', '  function approve(address _spender, uint256 _value)\n', '      returns (bool success) {\n', '      allowance[msg.sender][_spender] = _value;\n', '      return true;\n', '  }\n', '\n', '/// @notice funktion contains approve with the addition to follow the contract ///about the allowance\n', '  /// @param _spender the address authorized to spend\n', '  /// @param _value the max amount they can spend\n', '  /// @param _extraData some extra information to send to the approved contract\n', '  function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '      returns (bool success) {\n', '      tokenRecipient spender = tokenRecipient(_spender);\n', '      if (approve(_spender, _value)) {\n', '          spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '          return true;\n', '      }\n', '  }        \n', '/// @notice Create new token in addition to the initalsupply and send to target adress\n', '  /// @param target address to receive the tokens\n', '  /// @param mintedAmount ist the generated amount send to specified adress\n', '  function mintToken(address target, uint256 mintedAmount) onlyOwner {\n', '      balanceOf[target] += mintedAmount;\n', '      totalSupply += mintedAmount;\n', '      Transfer(0, this, mintedAmount);\n', '      Transfer(this, target, mintedAmount);\n', '  }\n', '  /// @notice participants of the Ethereum Network can buy or sell this token in ///exchange to Ether\n', '  /// @param newSellPrice price the users can sell to the contract\n', '  /// @param newBuyPrice price users can buy from the contract\n', '  function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {\n', '      sellPrice = newSellPrice;\n', '      buyPrice = newBuyPrice;\n', '  }\n', '\n', '/// @notice The Ether send to the contract exchange by BuyPrice and send back  ///HRW Tokens\n', '  function buy() payable {\n', '      uint amount = msg.value / buyPrice;               \n', '      _transfer(this, msg.sender, amount);              \n', '  }\n', '\n', '/// @notice the HRWToken send to the contract and exchange by SellPrice and ///send ether back\n', '  /// @param amount HRW Token to sale\n', '  function sell(uint256 amount) {\n', '      require(this.balance >= amount * sellPrice);      \n', '      _transfer(msg.sender, this, amount);              \n', '      msg.sender.transfer(amount * sellPrice);          \n', '  }\n', '}']
['/// @title Cryptocurrency  of the Ravensburg-Weingarten University of Applied Sciences ///(German: Hochschule Ravensburg-Weingarten) \n', '///@author Walther,Dominik \n', '\n', 'pragma solidity ^0.4.13; contract owned { address public owner;\n', '  function owned() {\n', '      owner = msg.sender;\n', '  }\n', '  modifier onlyOwner {\n', '      require(msg.sender == owner);\n', '      _;\n', '  }\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '      owner = newOwner;\n', '  }\n', '}\n', '/// receive other cryptocurrency\n', 'contract tokenRecipient { function receiveApproval(address from, uint256 value, address token, bytes extraData); }\n', '\n', '/// the public variables of the HRWtoken\n', 'contract HRWtoken is owned { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice;\n', '///@notice create an array with all adresses and associated balances of the cryptocurrency\n', '\n', '  mapping (address => uint256) public balanceOf;\n', '  mapping (address => mapping (address => uint256)) public allowance;\n', '\n', ' ///@notice generate a event on the blockchain to show transfer information \n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '///@notice initialization of the contract and distribution of tokes to the creater\n', '  function HRWtoken(\n', '      uint256 initialSupply,\n', '      string tokenName,\n', '      uint8 decimalUnits,\n', '      string tokenSymbol,\n', 'address centralMinter\n', '      ) {\n', 'if(centralMinter != 0 ) owner = centralMinter;\n', '      balanceOf[msg.sender] = initialSupply;       \n', '      totalSupply = initialSupply;                        \n', '      name = tokenName;                                   \n', '      symbol = tokenSymbol;                               \n', '      decimals = decimalUnits;                            \n', '  }\n', '\n', '  ///@notice only the contract can operate this internal funktion\n', '  function _transfer(address _from, address _to, uint _value) internal {\n', '      require (_to != 0x0);           \n', '      require (balanceOf[_from] >= _value);            \n', '      require (balanceOf[_to] + _value > balanceOf[_to]); \n', '      balanceOf[_from] -= _value;                         \n', '      balanceOf[_to] += _value;                            \n', '      Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /// @notice transfer to account (_to) any value (_value)\n', '  /// @param _to The address of the reciver\n', '  /// @param _value value units from the cryptocurrency\n', '  function transfer(address _to, uint256 _value) {\n', '      _transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /// @notice to dend the tokens the sender need the allowance \n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value value units to send\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      require (_value < allowance[_from][msg.sender]);     \n', '      allowance[_from][msg.sender] -= _value;\n', '      _transfer(_from, _to, _value);\n', '      return true;\n', '  }\n', '\n', '  /// @notice the spender can only transfer the value units he own\n', '  /// @param _spender the address authorized to transfer\n', '  /// @param _value the max amount they can spend\n', '  function approve(address _spender, uint256 _value)\n', '      returns (bool success) {\n', '      allowance[msg.sender][_spender] = _value;\n', '      return true;\n', '  }\n', '\n', '/// @notice funktion contains approve with the addition to follow the contract ///about the allowance\n', '  /// @param _spender the address authorized to spend\n', '  /// @param _value the max amount they can spend\n', '  /// @param _extraData some extra information to send to the approved contract\n', '  function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '      returns (bool success) {\n', '      tokenRecipient spender = tokenRecipient(_spender);\n', '      if (approve(_spender, _value)) {\n', '          spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '          return true;\n', '      }\n', '  }        \n', '/// @notice Create new token in addition to the initalsupply and send to target adress\n', '  /// @param target address to receive the tokens\n', '  /// @param mintedAmount ist the generated amount send to specified adress\n', '  function mintToken(address target, uint256 mintedAmount) onlyOwner {\n', '      balanceOf[target] += mintedAmount;\n', '      totalSupply += mintedAmount;\n', '      Transfer(0, this, mintedAmount);\n', '      Transfer(this, target, mintedAmount);\n', '  }\n', '  /// @notice participants of the Ethereum Network can buy or sell this token in ///exchange to Ether\n', '  /// @param newSellPrice price the users can sell to the contract\n', '  /// @param newBuyPrice price users can buy from the contract\n', '  function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {\n', '      sellPrice = newSellPrice;\n', '      buyPrice = newBuyPrice;\n', '  }\n', '\n', '/// @notice The Ether send to the contract exchange by BuyPrice and send back  ///HRW Tokens\n', '  function buy() payable {\n', '      uint amount = msg.value / buyPrice;               \n', '      _transfer(this, msg.sender, amount);              \n', '  }\n', '\n', '/// @notice the HRWToken send to the contract and exchange by SellPrice and ///send ether back\n', '  /// @param amount HRW Token to sale\n', '  function sell(uint256 amount) {\n', '      require(this.balance >= amount * sellPrice);      \n', '      _transfer(msg.sender, this, amount);              \n', '      msg.sender.transfer(amount * sellPrice);          \n', '  }\n', '}']
