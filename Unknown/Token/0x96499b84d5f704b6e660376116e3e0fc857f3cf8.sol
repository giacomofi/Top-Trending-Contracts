['pragma solidity ^0.4.11;\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '  mapping(address => uint256) balances;\n', '  //address[] public addressLUT;\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '      \n', '    // Check to see if transfer window has been reached\n', '    require (now >= 1512835200); // transfers can&#39;t happen until 3mo after sale ends (1512835200)\n', '    \n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '    \n', '    // Check to see if transfer window has been reached\n', '    require (now >= 1512835200); // transfers can&#39;t happen until 3mo after sale ends (1512835200)\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', '/**\n', ' * Upgrade agent interface inspired by Lunyr.\n', ' *\n', ' * Upgrade agent transfers tokens to a new contract.\n', ' * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\n', ' */\n', 'contract UpgradeAgent {\n', '  /** Interface marker */\n', '  function isUpgradeAgent() public constant returns (bool) {\n', '    return true;\n', '  }\n', '  function upgradeFrom(address _from, uint256 _value) public;\n', '}\n', '\n', 'contract PSIToken is StandardToken {\n', '    address public owner;\n', '    string public constant name = "Protostarr"; // Protostarr\n', '    string public constant symbol = "PSR"; // PSR\n', '    uint256 public constant decimals = 4;\n', '    \n', '    // Address for founder&#39;s PSI token and ETH deposits\n', '    address public constant founders_addr = 0xEa16ebd8Cdf5A51fa0a80bFA5665146b2AB82210;\n', '    \n', '    UpgradeAgent public upgradeAgent;\n', '    uint256 public totalUpgraded;\n', '    \n', '    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n', '    \n', '    event UpgradeAgentSet(address agent);\n', '    function setUpgradeAgent(address agent) external {\n', '        if (agent == 0x0) revert();\n', '        // Only owner can designate the next agent\n', '        if (msg.sender != owner) revert();\n', '        upgradeAgent = UpgradeAgent(agent);\n', '        \n', '        // Bad interface\n', '        if(!upgradeAgent.isUpgradeAgent()) revert();\n', '        UpgradeAgentSet(upgradeAgent);\n', '    }\n', '    function upgrade(uint256 value) public {\n', '        \n', '        if(address(upgradeAgent) == 0x00) revert();\n', '        // Validate input value.\n', '        if (value <= 0) revert();\n', '        \n', '        balances[msg.sender] = balances[msg.sender].sub(value);\n', '        \n', '        // Take tokens out from circulation\n', '        totalSupply = totalSupply.sub(value);\n', '        totalUpgraded = totalUpgraded.add(value);\n', '        \n', '        // Upgrade agent reissues the tokens\n', '        upgradeAgent.upgradeFrom(msg.sender, value);\n', '        Upgrade(msg.sender, upgradeAgent, value);\n', '    }\n', '\n', '    // Constructor\n', '    function PSIToken() {\n', '        // set owner as sender\n', '        owner = msg.sender;\n', '        \n', '        // add founders to address LUT\n', '        //addressLUT.push(founders_addr);\n', '    }\n', '    // check to see if sender is owner\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    // Allows the current owner to transfer control of the contract to a newOwner.\n', '    // newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        require(newOwner != address(0));      \n', '        owner = newOwner;\n', '    }\n', '    // catch received ether\n', '    function () payable {\n', '        createTokens(msg.sender);\n', '    }\n', '    // issue tokens for received ether\n', '    function createTokens(address recipient) payable {\n', '        if(msg.value<=uint256(1 ether).div(600)) {\n', '            revert();\n', '        }\n', '    \n', '        uint multiplier = 10 ** decimals;\n', '    \n', '        // create tokens for buyer\n', '        uint tokens = ((msg.value.mul(getPrice())).mul(multiplier)).div(1 ether);\n', '        totalSupply = totalSupply.add(tokens);\n', '        balances[recipient] = balances[recipient].add(tokens);      \n', '        \n', '        // add buyer to address LUT\n', '        //addressLUT.push(founders_addr);        \n', '        \n', '        // create 10% additional tokens for founders\n', '        uint ftokens = tokens.div(10);\n', '        totalSupply = totalSupply.add(ftokens);\n', '        balances[founders_addr] = balances[founders_addr].add(ftokens);\n', '    \n', '        // send ETH for buy to founders\n', '        if(!founders_addr.send(msg.value)) {\n', '            revert();\n', '        }\n', '    \n', '    }\n', '  \n', '    // get tiered pricing based on block.timestamp, or revert transaction if before/after sale times\n', '    // Unix Timestamps\n', '    // 1502640000 power hour start (170 tokens)\n', '    // 1502643600 week 1 start (150 tokens)\n', '    // 1503244800 week 2 start (130 tokens)\n', '    // 1503849600 week 3 start (110 tokens)\n', '    // 1504454400 week 4 start (100 tokens)\n', '    // 1505059200 SALE ENDS\n', '    // 1512835200 transfer period begins\n', '    function getPrice() constant returns (uint result) {\n', '        if (now < 1502640000) { // before power hour  1502640000\n', '            revert(); // DISQUALIFIED!!! There&#39;s one every season!!!\n', '        } else {\n', '            if (now < 1502645400) { // before week 1 start (in power hour)  1502643600 (new 1502645400)\n', '                return 170;\n', '            } else {\n', '                if (now < 1503244800) { // before week 2 start (in week 1)  1503244800\n', '                    return 150;\n', '                } else {\n', '                    if (now < 1503849600) { // before week 3 start (in week 2)  1503849600\n', '                        return 130;\n', '                    } else {\n', '                        if (now < 1504454400) { // before week 4 start (in week 3)  1504454400\n', '                            return 110;\n', '                        } else {\n', '                            if (now < 1505059200) { // before end of sale (in week 4)  1505059200\n', '                                return 100;\n', '                            } else {\n', '                                revert(); // sale has ended, kill transaction\n', '                            }\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '  \n', '}']
['pragma solidity ^0.4.11;\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '  mapping(address => uint256) balances;\n', '  //address[] public addressLUT;\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '      \n', '    // Check to see if transfer window has been reached\n', "    require (now >= 1512835200); // transfers can't happen until 3mo after sale ends (1512835200)\n", '    \n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '    \n', '    // Check to see if transfer window has been reached\n', "    require (now >= 1512835200); // transfers can't happen until 3mo after sale ends (1512835200)\n", '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still available for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', '/**\n', ' * Upgrade agent interface inspired by Lunyr.\n', ' *\n', ' * Upgrade agent transfers tokens to a new contract.\n', ' * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\n', ' */\n', 'contract UpgradeAgent {\n', '  /** Interface marker */\n', '  function isUpgradeAgent() public constant returns (bool) {\n', '    return true;\n', '  }\n', '  function upgradeFrom(address _from, uint256 _value) public;\n', '}\n', '\n', 'contract PSIToken is StandardToken {\n', '    address public owner;\n', '    string public constant name = "Protostarr"; // Protostarr\n', '    string public constant symbol = "PSR"; // PSR\n', '    uint256 public constant decimals = 4;\n', '    \n', "    // Address for founder's PSI token and ETH deposits\n", '    address public constant founders_addr = 0xEa16ebd8Cdf5A51fa0a80bFA5665146b2AB82210;\n', '    \n', '    UpgradeAgent public upgradeAgent;\n', '    uint256 public totalUpgraded;\n', '    \n', '    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n', '    \n', '    event UpgradeAgentSet(address agent);\n', '    function setUpgradeAgent(address agent) external {\n', '        if (agent == 0x0) revert();\n', '        // Only owner can designate the next agent\n', '        if (msg.sender != owner) revert();\n', '        upgradeAgent = UpgradeAgent(agent);\n', '        \n', '        // Bad interface\n', '        if(!upgradeAgent.isUpgradeAgent()) revert();\n', '        UpgradeAgentSet(upgradeAgent);\n', '    }\n', '    function upgrade(uint256 value) public {\n', '        \n', '        if(address(upgradeAgent) == 0x00) revert();\n', '        // Validate input value.\n', '        if (value <= 0) revert();\n', '        \n', '        balances[msg.sender] = balances[msg.sender].sub(value);\n', '        \n', '        // Take tokens out from circulation\n', '        totalSupply = totalSupply.sub(value);\n', '        totalUpgraded = totalUpgraded.add(value);\n', '        \n', '        // Upgrade agent reissues the tokens\n', '        upgradeAgent.upgradeFrom(msg.sender, value);\n', '        Upgrade(msg.sender, upgradeAgent, value);\n', '    }\n', '\n', '    // Constructor\n', '    function PSIToken() {\n', '        // set owner as sender\n', '        owner = msg.sender;\n', '        \n', '        // add founders to address LUT\n', '        //addressLUT.push(founders_addr);\n', '    }\n', '    // check to see if sender is owner\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    // Allows the current owner to transfer control of the contract to a newOwner.\n', '    // newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        require(newOwner != address(0));      \n', '        owner = newOwner;\n', '    }\n', '    // catch received ether\n', '    function () payable {\n', '        createTokens(msg.sender);\n', '    }\n', '    // issue tokens for received ether\n', '    function createTokens(address recipient) payable {\n', '        if(msg.value<=uint256(1 ether).div(600)) {\n', '            revert();\n', '        }\n', '    \n', '        uint multiplier = 10 ** decimals;\n', '    \n', '        // create tokens for buyer\n', '        uint tokens = ((msg.value.mul(getPrice())).mul(multiplier)).div(1 ether);\n', '        totalSupply = totalSupply.add(tokens);\n', '        balances[recipient] = balances[recipient].add(tokens);      \n', '        \n', '        // add buyer to address LUT\n', '        //addressLUT.push(founders_addr);        \n', '        \n', '        // create 10% additional tokens for founders\n', '        uint ftokens = tokens.div(10);\n', '        totalSupply = totalSupply.add(ftokens);\n', '        balances[founders_addr] = balances[founders_addr].add(ftokens);\n', '    \n', '        // send ETH for buy to founders\n', '        if(!founders_addr.send(msg.value)) {\n', '            revert();\n', '        }\n', '    \n', '    }\n', '  \n', '    // get tiered pricing based on block.timestamp, or revert transaction if before/after sale times\n', '    // Unix Timestamps\n', '    // 1502640000 power hour start (170 tokens)\n', '    // 1502643600 week 1 start (150 tokens)\n', '    // 1503244800 week 2 start (130 tokens)\n', '    // 1503849600 week 3 start (110 tokens)\n', '    // 1504454400 week 4 start (100 tokens)\n', '    // 1505059200 SALE ENDS\n', '    // 1512835200 transfer period begins\n', '    function getPrice() constant returns (uint result) {\n', '        if (now < 1502640000) { // before power hour  1502640000\n', "            revert(); // DISQUALIFIED!!! There's one every season!!!\n", '        } else {\n', '            if (now < 1502645400) { // before week 1 start (in power hour)  1502643600 (new 1502645400)\n', '                return 170;\n', '            } else {\n', '                if (now < 1503244800) { // before week 2 start (in week 1)  1503244800\n', '                    return 150;\n', '                } else {\n', '                    if (now < 1503849600) { // before week 3 start (in week 2)  1503849600\n', '                        return 130;\n', '                    } else {\n', '                        if (now < 1504454400) { // before week 4 start (in week 3)  1504454400\n', '                            return 110;\n', '                        } else {\n', '                            if (now < 1505059200) { // before end of sale (in week 4)  1505059200\n', '                                return 100;\n', '                            } else {\n', '                                revert(); // sale has ended, kill transaction\n', '                            }\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '  \n', '}']
