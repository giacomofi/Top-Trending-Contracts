['pragma solidity ^0.4.8;\n', '\n', 'contract IProxyManagement { \n', '    function isProxyLegit(address _address) returns (bool){}\n', '    function raiseTransferEvent(address _from, address _to, uint _ammount){}\n', '    function raiseApprovalEvent(address _sender,address _spender,uint _value){}\n', '    function dedicatedProxyAddress() constant returns (address contractAddress){}\n', '}\n', '\n', 'contract ITokenRecipient { \n', '\tfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); \n', '}\n', '\n', 'contract NeterContract {\n', '    \n', '  \n', '    address public dev;\n', '    address public curator;\n', '    address public creationAddress;\n', '    address public destructionAddress;\n', '    uint256 public totalSupply = 0;\n', '    bool public lockdown = false;\n', '\n', '\n', "    string public standard = 'Neter token 1.0';\n", "    string public name = 'Neter';\n", "    string public symbol = 'NTR';\n", '    uint8 public decimals = 8;\n', '\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    IProxyManagement proxyManagementContract;\n', '\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Create(address _destination, uint _amount);\n', '    event Destroy(address _destination, uint _amount);\n', '\n', '\n', '    function NeterContract() { \n', '        dev = msg.sender;\n', '    }\n', '    \n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _amount) returns (uint error) {\n', '        if(balances[msg.sender] < _amount) { return 55; }\n', '        if(balances[_to] + _amount <= balances[_to]) { return 55; }\n', '        if(lockdown) { return 55; }\n', '\n', '        balances[msg.sender] -= _amount;\n', '        balances[_to] += _amount;\n', '        createTransferEvent(true, msg.sender, _to, _amount);              \n', '        return 0;\n', '        \n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _amount) returns (uint error) {\n', '        if(balances[_from] < _amount) { return 55; }\n', '        if(balances[_to] + _amount <= balances[_to]) { return 55; }\n', '        if(_amount > allowed[_from][msg.sender]) { return 55; }\n', '        if(lockdown) { return 55; }\n', '\n', '        balances[_from] -= _amount;\n', '        balances[_to] += _amount;\n', '        createTransferEvent(true, _from, _to, _amount);\n', '        allowed[_from][msg.sender] -= _amount;\n', '        return 0;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (uint error) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        createApprovalEvent(true, msg.sender, _spender, _value);\n', '        return 0;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    function transferViaProxy(address _source, address _to, uint256 _amount) returns (uint error){\n', '        if (!proxyManagementContract.isProxyLegit(msg.sender)) { return 1; }\n', '\n', '        if (balances[_source] < _amount) {return 55;}\n', '        if (balances[_to] + _amount <= balances[_to]) {return 55;}\n', '        if (lockdown) {return 55;}\n', '\n', '        balances[_source] -= _amount;\n', '        balances[_to] += _amount;\n', '\n', '        if (msg.sender == proxyManagementContract.dedicatedProxyAddress()){\n', '            createTransferEvent(false, _source, _to, _amount); \n', '        }else{\n', '            createTransferEvent(true, _source, _to, _amount); \n', '        }\n', '        return 0;\n', '    }\n', '    \n', '    function transferFromViaProxy(address _source, address _from, address _to, uint256 _amount) returns (uint error) {\n', '        if (!proxyManagementContract.isProxyLegit(msg.sender)){ return 1; }\n', '\n', '        if (balances[_from] < _amount) {return 55;}\n', '        if (balances[_to] + _amount <= balances[_to]) {return 55;}\n', '        if (lockdown) {return 55;}\n', '        if (_amount > allowed[_from][_source]) {return 55;}\n', '\n', '        balances[_from] -= _amount;\n', '        balances[_to] += _amount;\n', '        allowed[_from][_source] -= _amount;\n', '\n', '        if (msg.sender == proxyManagementContract.dedicatedProxyAddress()){\n', '            createTransferEvent(false, _source, _to, _amount); \n', '        }else{\n', '            createTransferEvent(true, _source, _to, _amount); \n', '        }\n', '        return 0;\n', '    }\n', '    \n', '    function approveFromProxy(address _source, address _spender, uint256 _value) returns (uint error) {\n', '        if (!proxyManagementContract.isProxyLegit(msg.sender)){ return 1; }\n', '\n', '        allowed[_source][_spender] = _value;\n', '        if (msg.sender == proxyManagementContract.dedicatedProxyAddress()){\n', '            createApprovalEvent(false, _source, _spender, _value);\n', '        }else{\n', '            createApprovalEvent(true, _source, _spender, _value);\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function issueNewCoins(address _destination, uint _amount, string _details) returns (uint error){\n', '        if (msg.sender != creationAddress) { return 1;}\n', '\n', '        if(balances[_destination] + _amount < balances[_destination]) { return 55;}\n', '        if(totalSupply + _amount < totalSupply) { return 55; }\n', '\n', '        totalSupply += _amount;\n', '        balances[_destination] += _amount;\n', '        Create(_destination, _amount);\n', '        createTransferEvent(true, 0x0, _destination, _amount);\n', '        return 0;\n', '    }\n', '\n', '    function destroyOldCoins(address _destination, uint _amount, string _details) returns (uint error) {\n', '        if (msg.sender != destructionAddress) { return 1;}\n', '\n', '        if (balances[_destination] < _amount) { return 55;} \n', '\n', '        totalSupply -= _amount;\n', '        balances[_destination] -= _amount;\n', '        Destroy(_destination, _amount);\n', '        createTransferEvent(true, _destination, 0x0, _amount);\n', '        return 0;\n', '    }\n', '\n', '    function setTokenCurator(address _curatorAddress) returns (uint error){\n', '        if( msg.sender != dev) {return 1;}\n', '     \n', '        curator = _curatorAddress;\n', '        return 0;\n', '    }\n', '    \n', '    function setCreationAddress(address _contractAddress) returns (uint error){ \n', '        if (msg.sender != curator) { return 1;}\n', '        \n', '        creationAddress = _contractAddress;\n', '        return 0;\n', '    }\n', '\n', '    function setDestructionAddress(address _contractAddress) returns (uint error){ \n', '        if (msg.sender != curator) { return 1;}\n', '        \n', '        destructionAddress = _contractAddress;\n', '        return 0;\n', '    }\n', '\n', '    function setProxyManagementContract(address _contractAddress) returns (uint error){\n', '        if (msg.sender != curator) { return 1;}\n', '        \n', '        proxyManagementContract = IProxyManagement(_contractAddress);\n', '        return 0;\n', '    }\n', '\n', '    function emergencyLock() returns (uint error){\n', '        if (msg.sender != curator && msg.sender != dev) { return 1; }\n', '        \n', '        lockdown = !lockdown;\n', '        return 0;\n', '    }\n', '\n', '    function killContract() returns (uint error){\n', '        if (msg.sender != dev) { return 1; }\n', '        \n', '        selfdestruct(dev);\n', '        return 0;\n', '    }\n', '\n', '    function proxyManagementAddress() constant returns (address proxyManagementAddress){\n', '        return address(proxyManagementContract);\n', '    }\n', '\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        ITokenRecipient spender = ITokenRecipient(_spender);\n', '        spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '        return true;\n', '    }\n', '\n', '    function createTransferEvent(bool _relayEvent, address _from, address _to, uint256 _value) internal {\n', '        if (_relayEvent){\n', '            proxyManagementContract.raiseTransferEvent(_from, _to, _value);\n', '        }\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function createApprovalEvent(bool _relayEvent, address _sender, address _spender, uint _value) internal {\n', '        if (_relayEvent){\n', '            proxyManagementContract.raiseApprovalEvent(_sender, _spender, _value);\n', '        }\n', '        Approval(_sender, _spender, _value);\n', '    }\n', '\n', '    function () {\n', '        throw;\n', '    }\n', '}']