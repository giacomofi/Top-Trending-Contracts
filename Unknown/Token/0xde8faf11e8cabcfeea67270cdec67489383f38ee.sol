['//! BasicCoin ECR20-compliant token contract\n', '//! By Parity Team (Ethcore), 2016.\n', '//! Released under the Apache Licence 2.\n', '\n', 'pragma solidity ^0.4.1;\n', '\n', '// ECR20 standard token interface\n', 'contract Token {\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '  function approve(address _spender, uint256 _value) returns (bool success);\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', '// Owner-specific contract interface\n', 'contract Owned {\n', '  event NewOwner(address indexed old, address indexed current);\n', '\n', '  modifier only_owner {\n', '    if (msg.sender != owner) throw;\n', '    _;\n', '  }\n', '\n', '  address public owner = msg.sender;\n', '\n', '  function setOwner(address _new) only_owner {\n', '    NewOwner(owner, _new);\n', '    owner = _new;\n', '  }\n', '}\n', '\n', '// TokenReg interface\n', 'contract TokenReg {\n', '  function register(address _addr, string _tla, uint _base, string _name) payable returns (bool);\n', '  function registerAs(address _addr, string _tla, uint _base, string _name, address _owner) payable returns (bool);\n', '  function unregister(uint _id);\n', '  function setFee(uint _fee);\n', '  function tokenCount() constant returns (uint);\n', '  function token(uint _id) constant returns (address addr, string tla, uint base, string name, address owner);\n', '  function fromAddress(address _addr) constant returns (uint id, string tla, uint base, string name, address owner);\n', '  function fromTLA(string _tla) constant returns (uint id, address addr, uint base, string name, address owner);\n', '  function meta(uint _id, bytes32 _key) constant returns (bytes32);\n', '  function setMeta(uint _id, bytes32 _key, bytes32 _value);\n', '  function transferTLA(string _tla, address _to) returns (bool success);\n', '  function drain();\n', '  uint public fee;\n', '}\n', '\n', '// BasicCoin, ECR20 tokens that all belong to the owner for sending around\n', 'contract BasicCoin is Owned, Token {\n', '  // this is as basic as can be, only the associated balance & allowances\n', '  struct Account {\n', '    uint balance;\n', '    mapping (address => uint) allowanceOf;\n', '  }\n', '\n', '  // the balance should be available\n', '  modifier when_owns(address _owner, uint _amount) {\n', '    if (accounts[_owner].balance < _amount) throw;\n', '    _;\n', '  }\n', '\n', '  // an allowance should be available\n', '  modifier when_has_allowance(address _owner, address _spender, uint _amount) {\n', '    if (accounts[_owner].allowanceOf[_spender] < _amount) throw;\n', '    _;\n', '  }\n', '\n', '  // no ETH should be sent with the transaction\n', '  modifier when_no_eth {\n', '    if (msg.value > 0) throw;\n', '    _;\n', '  }\n', '\n', '  // a value should be > 0\n', '  modifier when_non_zero(uint _value) {\n', '    if (_value == 0) throw;\n', '    _;\n', '  }\n', '\n', '  // the base, tokens denoted in micros\n', '  uint constant public base = 1000000;\n', '\n', '  // available token supply\n', '  uint public totalSupply;\n', '\n', '  // storage and mapping of all balances & allowances\n', '  mapping (address => Account) accounts;\n', '\n', '  // constructor sets the parameters of execution, _totalSupply is all units\n', '  function BasicCoin(uint _totalSupply, address _owner) when_no_eth when_non_zero(_totalSupply) {\n', '    totalSupply = _totalSupply;\n', '    owner = _owner;\n', '    accounts[_owner].balance = totalSupply;\n', '  }\n', '\n', '  // balance of a specific address\n', '  function balanceOf(address _who) constant returns (uint256) {\n', '    return accounts[_who].balance;\n', '  }\n', '\n', '  // transfer\n', '  function transfer(address _to, uint256 _value) when_no_eth when_owns(msg.sender, _value) returns (bool) {\n', '    Transfer(msg.sender, _to, _value);\n', '    accounts[msg.sender].balance -= _value;\n', '    accounts[_to].balance += _value;\n', '\n', '    return true;\n', '  }\n', '\n', '  // transfer via allowance\n', '  function transferFrom(address _from, address _to, uint256 _value) when_no_eth when_owns(_from, _value) when_has_allowance(_from, msg.sender, _value) returns (bool) {\n', '    Transfer(_from, _to, _value);\n', '    accounts[_from].allowanceOf[msg.sender] -= _value;\n', '    accounts[_from].balance -= _value;\n', '    accounts[_to].balance += _value;\n', '\n', '    return true;\n', '  }\n', '\n', '  // approve allowances\n', '  function approve(address _spender, uint256 _value) when_no_eth returns (bool) {\n', '    Approval(msg.sender, _spender, _value);\n', '    accounts[msg.sender].allowanceOf[_spender] += _value;\n', '\n', '    return true;\n', '  }\n', '\n', '  // available allowance\n', '  function allowance(address _owner, address _spender) constant returns (uint256) {\n', '    return accounts[_owner].allowanceOf[_spender];\n', '  }\n', '\n', '  // no default function, simple contract only, entry-level users\n', '  function() {\n', '    throw;\n', '  }\n', '}\n', '\n', '// Manages BasicCoin instances, including the deployment & registration\n', 'contract BasicCoinManager is Owned {\n', '  // a structure wrapping a deployed BasicCoin\n', '  struct Coin {\n', '    address coin;\n', '    address owner;\n', '    address tokenreg;\n', '  }\n', '\n', '  // a new BasicCoin has been deployed\n', '  event Created(address indexed owner, address indexed tokenreg, address indexed coin);\n', '\n', '  // a list of all the deployed BasicCoins\n', '  Coin[] coins;\n', '\n', '  // all BasicCoins for a specific owner\n', '  mapping (address => uint[]) ownedCoins;\n', '\n', '  // the base, tokens denoted in micros (matches up with BasicCoin interface above)\n', '  uint constant public base = 1000000;\n', '\n', '  // return the number of deployed\n', '  function count() constant returns (uint) {\n', '    return coins.length;\n', '  }\n', '\n', '  // get a specific deployment\n', '  function get(uint _index) constant returns (address coin, address owner, address tokenreg) {\n', '    Coin c = coins[_index];\n', '\n', '    coin = c.coin;\n', '    owner = c.owner;\n', '    tokenreg = c.tokenreg;\n', '  }\n', '\n', '  // returns the number of coins for a specific owner\n', '  function countByOwner(address _owner) constant returns (uint) {\n', '    return ownedCoins[_owner].length;\n', '  }\n', '\n', '  // returns a specific index by owner\n', '  function getByOwner(address _owner, uint _index) constant returns (address coin, address owner, address tokenreg) {\n', '    return get(ownedCoins[_owner][_index]);\n', '  }\n', '\n', '  // deploy a new BasicCoin on the blockchain\n', '  function deploy(uint _totalSupply, string _tla, string _name, address _tokenreg) payable returns (bool) {\n', '    TokenReg tokenreg = TokenReg(_tokenreg);\n', '    BasicCoin coin = new BasicCoin(_totalSupply, msg.sender);\n', '\n', '    uint ownerCount = countByOwner(msg.sender);\n', '    uint fee = tokenreg.fee();\n', '\n', '    ownedCoins[msg.sender].length = ownerCount + 1;\n', '    ownedCoins[msg.sender][ownerCount] = coins.length;\n', '    coins.push(Coin(coin, msg.sender, tokenreg));\n', '    tokenreg.registerAs.value(fee)(coin, _tla, base, _name, msg.sender);\n', '\n', '    Created(msg.sender, tokenreg, coin);\n', '\n', '    return true;\n', '  }\n', '\n', '  // owner can withdraw all collected funds\n', '  function drain() only_owner {\n', '    if (!msg.sender.send(this.balance)) {\n', '      throw;\n', '    }\n', '  }\n', '}']