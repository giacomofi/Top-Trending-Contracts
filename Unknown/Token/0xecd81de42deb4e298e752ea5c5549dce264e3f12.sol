['pragma solidity ^0.4.16;\n', '//Fixed Base EAC0 supply token contract\n', '// (c) 7/7/2017. EACOINS;\n', '// Define standard fields for ERC20 contract\n', 'contract ERC20 {\n', '   // uint public total a getter function instead\n', '   // NOTE from Jalmost every token contract uses public uint variable. Total supply of t I think. \n', "    string public standard = 'ERC20';\n", '    function balanceOf(address who) constant returns (uint);\n', '    function allowance(address owner, address spender) constant returns (uint);\n', '    function transfer(address to, uint value) returns (bool ok);\n', '    function transferFrom(address from, address to, uint value) returns (bool ok);\n', '    function approve(address spender, uint value) returns (bool ok); \n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '// needed to add restrictions who could execute commands (in this case owner - person who deployed the contract)\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '  \n', '        modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) owner = newOwner;\n', '    }\n', '}\n', '\n', '// best practice to use safe mathematic operations to avoid major problems\n', 'library SafeMath { \n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns (uint) {\n', '        // assert(b > 0); // NOTE (ihen): solidity will automatically throw when divided by 0\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', "        assert(c >= a); // a + b can't be larger than or equal to a when overflowed\n", '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '                     \n', '            \n', '    }\n', '  }\n', '\n', 'contract TokenSpender {\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\n', '}\n', '\n', 'contract EACOIN is ERC20, Ownable {\n', '    using SafeMath for uint256;\n', '    /* Public variables of the token */\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', "    string public version = 'v1.0';\n", '  // uint public initialSupply;\n', '    uint public totalSupply;\n', '    mapping (address => uint) public balances; // NOTE(hen): those should be public\n', '    mapping (address => mapping (address => uint)) public allowed;\n', '\n', '    function EACOIN() {\n', '        totalSupply = 100000000000000000000000000;\n', '        balances[msg.sender] = 100000000000000000000000000;\n', "        name = 'EACOIN';\n", "        symbol = 'EACO';\n", '        decimals = 18;\n', '    }\n', '\n', '    function balanceOf(address who) constant returns (uint256) {\n', '        return balances[who];\n', '    }\n', '    function transfer(address _to, uint _value) returns (bool) {\n', '        if (balances[msg.sender] >= _value &&\n', '            _value > 0 /* zero transfer is not allowed */ &&\n', '            balances[_to] + _value > balances[_to] /* check overflow */) {\n', '                                      \n', '                \n', '             balances[msg.sender] = balances[msg.sender] - _value;\n', '            balances[_to] = balances[_to] + _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address spender, uint256 value) returns (bool) {\n', '        require(value > 0 && spender != 0x0);\n', '        allowed[msg.sender][spender] = value;\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool) {\n', '        if (balances[_from] >= _value &&\n', '            allowed[_from][msg.sender] >= _value &&\n', '            _value > 0 &&\n', '            balances[_to] + _value > balances[_to]) {\n', '             balances[_from] -= _value;\n', '             allowed[_from][msg.sender] -= _value;\n', '             balances[_to] += _value;\n', '             return true;\n', '          } else {\n', '             return false;\n', '         }\n', '    }\n', '    \n', '     /* Approve and then comunicate the approved contract in a single tx */\n', '        function approveAndCall(address _spender, uint256 _value, bytes _extraData) {\n', '         TokenSpender spender = TokenSpender(_spender);\n', '         if (approve(_spender, _value)) {\n', '             spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '         }\n', '    }\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}']