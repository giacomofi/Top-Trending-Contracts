['pragma solidity ^0.4.15;\n', '\n', 'contract SafeMath {\n', '\n', '    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x + y;\n', '      assert((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n', '      assert(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '\n', '    function safeDiv(uint256 a, uint256 b) internal returns (uint256) {\n', '      assert(b > 0);\n', '      uint c = a / b;\n', '      assert(a == b * c + a % b);\n', '      return c;\n', '    }\n', '\n', '}\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', '    /**\n', '     * @title Ownable\n', '     * @dev The Ownable contract has an owner address, and provides basic authorization control\n', '     * functions, this simplifies the implementation of "user permissions".\n', '     */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', 'contract TripAlly is SafeMath, StandardToken, Pausable {\n', '\n', '    string public constant name = "TripAlly Token";\n', '    string public constant symbol = "ALLY";\n', '    uint256 public constant decimals = 18;\n', '    uint256 public constant tokenCreationCap = 100000000*10**decimals;\n', '    uint256 constant tokenCreationCapPreICO = 750000*10**decimals;\n', '\n', '    uint256 public oneTokenInWei = 2000000000000000;\n', '\n', '    uint public totalEthRecieved;\n', '\n', '    Phase public currentPhase = Phase.PreICO;\n', '\n', '    enum Phase {\n', '        PreICO,\n', '        ICO\n', '    }\n', '\n', '    event CreateALLY(address indexed _to, uint256 _value);\n', '    event PriceChanged(string _text, uint _newPrice);\n', '    event StageChanged(string _text);\n', '    event Withdraw(address to, uint amount);\n', '\n', '    function TripAlly() {\n', '    }\n', '\n', '    function () payable {\n', '        createTokens();\n', '    }\n', '\n', '\n', '    function createTokens() internal whenNotPaused {\n', '        uint multiplier = 10 ** 10;\n', '        uint256 tokens = safeDiv(msg.value*100000000, oneTokenInWei) * multiplier;\n', '        uint256 checkedSupply = safeAdd(totalSupply, tokens);\n', '\n', '        if (currentPhase == Phase.PreICO &&  checkedSupply <= tokenCreationCapPreICO) {\n', '            addTokens(tokens);\n', '        } else if (currentPhase == Phase.ICO && checkedSupply <= tokenCreationCap) {\n', '            addTokens(tokens);\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function addTokens(uint256 tokens) internal {\n', '        if (msg.value <= 0) revert();\n', '        balances[msg.sender] += tokens;\n', '        totalSupply = safeAdd(totalSupply, tokens);\n', '        totalEthRecieved += msg.value;\n', '        CreateALLY(msg.sender, tokens);\n', '    }\n', '\n', '    function withdraw(address _toAddress, uint256 amount) external onlyOwner {\n', '        require(_toAddress != address(0));\n', '        _toAddress.transfer(amount);\n', '        Withdraw(_toAddress, amount);\n', '    }\n', '\n', '    function setEthPrice(uint256 _tokenPrice) external onlyOwner {\n', '        oneTokenInWei = _tokenPrice;\n', '        PriceChanged("New price is", _tokenPrice);\n', '    }\n', '\n', '    function setICOPhase() external onlyOwner {\n', '        currentPhase = Phase.ICO;\n', '        StageChanged("Current stage is ICO");\n', '    }\n', '\n', '    function setPreICOPhase() external onlyOwner {\n', '        currentPhase = Phase.PreICO;\n', '        StageChanged("Current stage is PreICO");\n', '    }\n', '\n', '    function generateTokens(address _reciever, uint256 _amount) external onlyOwner {\n', '        require(_reciever != address(0));\n', '        balances[_reciever] += _amount;\n', '        totalSupply = safeAdd(totalSupply, _amount);\n', '        CreateALLY(_reciever, _amount);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.15;\n', '\n', 'contract SafeMath {\n', '\n', '    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x + y;\n', '      assert((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n', '      assert(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '\n', '    function safeDiv(uint256 a, uint256 b) internal returns (uint256) {\n', '      assert(b > 0);\n', '      uint c = a / b;\n', '      assert(a == b * c + a % b);\n', '      return c;\n', '    }\n', '\n', '}\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', '    /**\n', '     * @title Ownable\n', '     * @dev The Ownable contract has an owner address, and provides basic authorization control\n', '     * functions, this simplifies the implementation of "user permissions".\n', '     */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', 'contract TripAlly is SafeMath, StandardToken, Pausable {\n', '\n', '    string public constant name = "TripAlly Token";\n', '    string public constant symbol = "ALLY";\n', '    uint256 public constant decimals = 18;\n', '    uint256 public constant tokenCreationCap = 100000000*10**decimals;\n', '    uint256 constant tokenCreationCapPreICO = 750000*10**decimals;\n', '\n', '    uint256 public oneTokenInWei = 2000000000000000;\n', '\n', '    uint public totalEthRecieved;\n', '\n', '    Phase public currentPhase = Phase.PreICO;\n', '\n', '    enum Phase {\n', '        PreICO,\n', '        ICO\n', '    }\n', '\n', '    event CreateALLY(address indexed _to, uint256 _value);\n', '    event PriceChanged(string _text, uint _newPrice);\n', '    event StageChanged(string _text);\n', '    event Withdraw(address to, uint amount);\n', '\n', '    function TripAlly() {\n', '    }\n', '\n', '    function () payable {\n', '        createTokens();\n', '    }\n', '\n', '\n', '    function createTokens() internal whenNotPaused {\n', '        uint multiplier = 10 ** 10;\n', '        uint256 tokens = safeDiv(msg.value*100000000, oneTokenInWei) * multiplier;\n', '        uint256 checkedSupply = safeAdd(totalSupply, tokens);\n', '\n', '        if (currentPhase == Phase.PreICO &&  checkedSupply <= tokenCreationCapPreICO) {\n', '            addTokens(tokens);\n', '        } else if (currentPhase == Phase.ICO && checkedSupply <= tokenCreationCap) {\n', '            addTokens(tokens);\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function addTokens(uint256 tokens) internal {\n', '        if (msg.value <= 0) revert();\n', '        balances[msg.sender] += tokens;\n', '        totalSupply = safeAdd(totalSupply, tokens);\n', '        totalEthRecieved += msg.value;\n', '        CreateALLY(msg.sender, tokens);\n', '    }\n', '\n', '    function withdraw(address _toAddress, uint256 amount) external onlyOwner {\n', '        require(_toAddress != address(0));\n', '        _toAddress.transfer(amount);\n', '        Withdraw(_toAddress, amount);\n', '    }\n', '\n', '    function setEthPrice(uint256 _tokenPrice) external onlyOwner {\n', '        oneTokenInWei = _tokenPrice;\n', '        PriceChanged("New price is", _tokenPrice);\n', '    }\n', '\n', '    function setICOPhase() external onlyOwner {\n', '        currentPhase = Phase.ICO;\n', '        StageChanged("Current stage is ICO");\n', '    }\n', '\n', '    function setPreICOPhase() external onlyOwner {\n', '        currentPhase = Phase.PreICO;\n', '        StageChanged("Current stage is PreICO");\n', '    }\n', '\n', '    function generateTokens(address _reciever, uint256 _amount) external onlyOwner {\n', '        require(_reciever != address(0));\n', '        balances[_reciever] += _amount;\n', '        totalSupply = safeAdd(totalSupply, _amount);\n', '        CreateALLY(_reciever, _amount);\n', '    }\n', '\n', '}']
