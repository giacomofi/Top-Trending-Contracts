['pragma solidity ^0.4.0;\n', '\n', 'library TokenEventLib {\n', '    /*\n', '     * When underlying solidity issue is fixed this library will not be needed.\n', '     * https://github.com/ethereum/solidity/issues/1215\n', '     */\n', '    event Transfer(address indexed _from,\n', '                   address indexed _to);\n', '    event Approval(address indexed _owner,\n', '                   address indexed _spender);\n', '\n', '    function _Transfer(address _from, address _to) internal {\n', '        Transfer(_from, _to);\n', '    }\n', '\n', '    function _Approval(address _owner, address _spender) internal {\n', '        Approval(_owner, _spender);\n', '    }\n', '}\n', '\n', 'contract TokenInterface {\n', '    /*\n', '     *  Events\n', '     */\n', '    event Mint(address indexed _owner);\n', '    event Destroy(address _owner);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event MinterAdded(address who);\n', '    event MinterRemoved(address who);\n', '\n', '    /*\n', '     *  Minting\n', '     */\n', '    /// @dev Mints a new token.\n', '    /// @param _owner Address of token owner.\n', '    function mint(address _owner) returns (bool success);\n', '\n', '    /// @dev Destroy a token\n', '    /// @param _owner Bytes32 id of the owner of the token\n', '    function destroy(address _owner) returns (bool success);\n', '\n', '    /// @dev Add a new minter\n', '    /// @param who Address the address that can now mint tokens.\n', '    function addMinter(address who) returns (bool);\n', '\n', '    /// @dev Remove a minter\n', '    /// @param who Address the address that will no longer be a minter.\n', '    function removeMinter(address who) returns (bool);\n', '\n', '    /*\n', '     *  Read and write storage functions\n', '     */\n', '\n', '    /// @dev Return the number of tokens\n', '    function totalSupply() constant returns (uint supply);\n', '\n', '    /// @dev Transfers sender token to given address. Returns success.\n', '    /// @param _to Address of new token owner.\n', '    /// @param _value Bytes32 id of the token to transfer.\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address of token owner.\n', '    /// @param _to Address of new token owner.\n', '    /// @param _value Bytes32 id of the token to transfer.\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @dev Sets approval spender to transfer ownership of token. Returns success.\n', '    /// @param _spender Address of spender..\n', '    /// @param _value Bytes32 id of token that can be spend.\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /*\n', '     * Read storage functions\n', '     */\n', '    /// @dev Returns id of token owned by given address (encoded as an integer).\n', '    /// @param _owner Address of token owner.\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @dev Returns the token id that may transfer from _owner account by _spender..\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    /*\n', '     *  Extra non ERC20 functions\n', '     */\n', '    /// @dev Returns whether the address owns a token.\n', '    /// @param _owner Address to check.\n', '    function isTokenOwner(address _owner) constant returns (bool);\n', '}\n', '\n', 'contract IndividualityTokenInterface {\n', '    /*\n', '     * Read storage functions\n', '     */\n', '\n', '    /// @dev Returns id of token owned by given address (encoded as an integer).\n', '    /// @param _owner Address of token owner.\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @dev Returns the token id that may transfer from _owner account by _spender..\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    /*\n', '     *  Write storage functions\n', '     */\n', '\n', '    /// @dev Transfers sender token to given address. Returns success.\n', '    /// @param _to Address of new token owner.\n', '    /// @param _value Bytes32 id of the token to transfer.\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transfer(address _to) public returns (bool success);\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address of token owner.\n', '    /// @param _to Address of new token owner.\n', '    /// @param _value Bytes32 id of the token to transfer.\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to) public returns (bool success);\n', '\n', '    /// @dev Sets approval spender to transfer ownership of token. Returns success.\n', '    /// @param _spender Address of spender..\n', '    /// @param _value Bytes32 id of token that can be spend.\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function approve(address _spender) public returns (bool success);\n', '\n', '    /*\n', '     *  Extra non ERC20 functions\n', '     */\n', '\n', '    /// @dev Returns whether the address owns a token.\n', '    /// @param _owner Address to check.\n', '    function isTokenOwner(address _owner) constant returns (bool);\n', '}\n', '\n', '\n', 'contract IndividualityToken is TokenInterface, IndividualityTokenInterface {\n', '    function IndividualityToken() {\n', '        minters[msg.sender] = true;\n', '        MinterAdded(msg.sender);\n', '    }\n', '\n', '    modifier minterOnly {\n', '        if(!minters[msg.sender]) throw;\n', '        _;\n', '    }\n', '\n', '    // address => canmint\n', '    mapping (address => bool) minters;\n', '    \n', '    // owner => balance\n', '    mapping (address => uint) balances;\n', '\n', '    // owner => spender => balance\n', '    mapping (address => mapping (address => uint)) approvals;\n', '\n', '    uint numTokens;\n', '\n', '    /// @dev Mints a new token.\n', '    /// @param _to Address of token owner.\n', '    function mint(address _to) minterOnly returns (bool success) {\n', "        // ensure that the token owner doesn't already own a token.\n", '        if (balances[_to] != 0x0) return false;\n', '\n', '        balances[_to] = 1;\n', '\n', '        // log the minting of this token.\n', '        Mint(_to);\n', '        Transfer(0x0, _to, 1);\n', '        TokenEventLib._Transfer(0x0, _to);\n', '\n', '        // increase the supply.\n', '        numTokens += 1;\n', '\n', '        return true;\n', '    }\n', '    \n', '    // @dev Mint many new tokens\n', '    function mint(address[] _to) minterOnly returns (bool success) {\n', '        for(uint i = 0; i < _to.length; i++) {\n', '            if(balances[_to[i]] != 0x0) return false;\n', '            balances[_to[i]] = 1;\n', '            Mint(_to[i]);\n', '            Transfer(0x0, _to[i], 1);\n', '            TokenEventLib._Transfer(0x0, _to[i]);\n', '        }\n', '        numTokens += _to.length;\n', '        return true;\n', '    }\n', '\n', '    /// @dev Destroy a token\n', '    /// @param _owner address owner of the token to destroy\n', '    function destroy(address _owner) minterOnly returns (bool success) {\n', '        if(balances[_owner] != 1) throw;\n', '        \n', '        balances[_owner] = 0;\n', '        numTokens -= 1;\n', '        Destroy(_owner);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Add a new minter\n', '    /// @param who Address the address that can now mint tokens.\n', '    function addMinter(address who) minterOnly returns (bool) {\n', '        minters[who] = true;\n', '        MinterAdded(who);\n', '    }\n', '\n', '    /// @dev Remove a minter\n', '    /// @param who Address the address that will no longer be a minter.\n', '    function removeMinter(address who) minterOnly returns (bool) {\n', '        minters[who] = false;\n', '        MinterRemoved(who);\n', '    }\n', '\n', '    /// @dev Return the number of tokens\n', '    function totalSupply() constant returns (uint supply) {\n', '        return numTokens;\n', '    }\n', '\n', '    /// @dev Returns id of token owned by given address (encoded as an integer).\n', '    /// @param _owner Address of token owner.\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        if (_owner == 0x0) {\n', '            return 0;\n', '        } else {\n', '            return balances[_owner];\n', '        }\n', '    }\n', '\n', '    /// @dev Returns the token id that may transfer from _owner account by _spender..\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    function allowance(address _owner,\n', '                       address _spender) constant returns (uint256 remaining) {\n', '        return approvals[_owner][_spender];\n', '    }\n', '\n', '    /// @dev Transfers sender token to given address. Returns success.\n', '    /// @param _to Address of new token owner.\n', '    /// @param _value Bytes32 id of the token to transfer.\n', '    function transfer(address _to,\n', '                      uint256 _value) public returns (bool success) {\n', '        if (_value != 1) {\n', '            // 1 is the only value that makes any sense here.\n', '            return false;\n', '        } else if (_to == 0x0) {\n', '            // cannot transfer to the null address.\n', '            return false;\n', '        } else if (balances[msg.sender] == 0x0) {\n', '            // msg.sender is not a token owner\n', '            return false;\n', '        } else if (balances[_to] != 0x0) {\n', '            // cannot transfer to an address that already owns a token.\n', '            return false;\n', '        }\n', '\n', '        balances[msg.sender] = 0;\n', '        balances[_to] = 1;\n', '        Transfer(msg.sender, _to, 1);\n', '        TokenEventLib._Transfer(msg.sender, _to);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Transfers sender token to given address. Returns success.\n', '    /// @param _to Address of new token owner.\n', '    function transfer(address _to) public returns (bool success) {\n', '        return transfer(_to, 1);\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address of token owner.\n', '    /// @param _to Address of new token owner.\n', '    /// @param _value Bytes32 id of the token to transfer.\n', '    function transferFrom(address _from,\n', '                          address _to,\n', '                          uint256 _value) public returns (bool success) {\n', '        if (_value != 1) {\n', '            // Cannot transfer anything other than 1 token.\n', '            return false;\n', '        } else if (_to == 0x0) {\n', '            // Cannot transfer to the null address\n', '            return false;\n', '        } else if (balances[_from] == 0x0) {\n', '            // Cannot transfer if _from is not a token owner\n', '            return false;\n', '        } else if (balances[_to] != 0x0) {\n', '            // Cannot transfer to an existing token owner\n', '            return false;\n', '        } else if (approvals[_from][msg.sender] == 0) {\n', "            // The approved token doesn't match the token being transferred.\n", '            return false;\n', '        }\n', '\n', '        // null out the approval\n', '        approvals[_from][msg.sender] = 0x0;\n', '\n', '        // remove the token from the sender.\n', '        balances[_from] = 0;\n', '\n', '        // assign the token to the new owner\n', '        balances[_to] = 1;\n', '\n', '        // log the transfer\n', '        Transfer(_from, _to, 1);\n', '        TokenEventLib._Transfer(_from, _to);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address of token owner.\n', '    /// @param _to Address of new token owner.\n', '    function transferFrom(address _from, address _to) public returns (bool success) {\n', '        return transferFrom(_from, _to, 1);\n', '    }\n', '\n', '    /// @dev Sets approval spender to transfer ownership of token. Returns success.\n', '    /// @param _spender Address of spender..\n', '    /// @param _value Bytes32 id of token that can be spend.\n', '    function approve(address _spender,\n', '                     uint256 _value) public returns (bool success) {\n', '        if (_value != 1) {\n', '            // cannot approve any value other than 1\n', '            return false;\n', '        } else if (_spender == 0x0) {\n', '            // cannot approve the null address as a spender.\n', '            return false;\n', '        } else if (balances[msg.sender] == 0x0) {\n', '            // cannot approve if not a token owner.\n', '            return false;\n', '        }\n', '\n', '        approvals[msg.sender][_spender] = 1;\n', '\n', '        Approval(msg.sender, _spender, 1);\n', '        TokenEventLib._Approval(msg.sender, _spender);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Sets approval spender to transfer ownership of token. Returns success.\n', '    /// @param _spender Address of spender..\n', '    function approve(address _spender) public returns (bool success) {\n', '        return approve(_spender, 1);\n', '    }\n', '\n', '    /*\n', '     *  Extra non ERC20 functions\n', '     */\n', '    /// @dev Returns whether the address owns a token.\n', '    /// @param _owner Address to check.\n', '    function isTokenOwner(address _owner) constant returns (bool) {\n', '        return balances[_owner] != 0;\n', '    }\n', '}']