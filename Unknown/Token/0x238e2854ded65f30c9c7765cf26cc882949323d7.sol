['pragma solidity ^0.4.8;\n', '\n', 'contract IERC20Token {\n', '\n', '    /// @return total amount of tokens\n', '    function totalSupply() constant returns (uint256 supply) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}   \n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract IToken {\n', '    function totalSupply() constant returns (uint256 supply) {}\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '    function transferViaProxy(address _from, address _to, uint _value) returns (uint error) {}\n', '    function transferFromViaProxy(address _source, address _from, address _to, uint256 _amount) returns (uint error) {}\n', '    function approveFromProxy(address _source, address _spender, uint256 _value) returns (uint error) {}\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} \n', '    function issueNewCoins(address _destination, uint _amount, string _details) returns (uint error){}\n', '    function destroyOldCoins(address _destination, uint _amount, string _details) returns (uint error) {}\n', '}\n', '\n', 'contract ProxyContract is IERC20Token {\n', '\n', '\n', '    address public dev;\n', '    address public curator;\n', '    address public proxyManagementAddress;\n', '    \n', '    bool public proxyWorking;\n', '\n', "    string public standard = 'Neter proxy';\n", "    string public name = 'Neter';\n", "    string public symbol = 'NTR';\n", '    uint8 public decimals = 8;\n', '\n', '    IToken tokenContract;\n', '\n', '\n', '    function ProxyContract(){ \n', '        dev = msg.sender;\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256 supply) {\n', '        return tokenContract.totalSupply();\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return tokenContract.balanceOf(_owner);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (!proxyWorking) { return false;}\n', '        \n', '        uint error =  tokenContract.transferViaProxy(msg.sender, _to, _value);\n', '        \n', '        if(error == 0){\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (!proxyWorking) { return false;}\n', '        \n', '        uint error =  tokenContract.transferFromViaProxy(msg.sender, _from, _to, _value);\n', '        \n', '        if(error == 0){\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        if (!proxyWorking) { return false;}\n', '        \n', '        uint error =  tokenContract.approveFromProxy(msg.sender, _spender, _value);\n', '        \n', '        if(error == 0){\n', '            Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return tokenContract.allowance(_owner, _spender);\n', '    } \n', '    \n', '    function setTokenContract(address _tokenAddress) returns (uint error){\n', '        if (msg.sender != curator) { return 1;}\n', '        \n', '        tokenContract = IToken(_tokenAddress);\n', '        return 0;\n', '    }\n', '    \n', '    function setProxyManagementAddress(address _proxyManagementAddress) returns (uint error){ \n', '        if (msg.sender != curator) { return 1;}\n', '        \n', '        proxyManagementAddress = _proxyManagementAddress;\n', '        return 0;\n', '    }\n', '\n', '    function EnableDisableTokenProxy() returns (uint error){\n', '        if (msg.sender != curator) { return 1; }       \n', '        \n', '        proxyWorking = !proxyWorking;\n', '        return 0;\n', '\n', '    }\n', '    \n', '    function setProxyCurator(address _curatorAddress) returns (uint error){\n', '        if( msg.sender != dev) {return 1;}\n', '     \n', '        curator = _curatorAddress;\n', '        return 0;\n', '    }\n', '\n', '    function killContract() returns (uint error){\n', '        if (msg.sender != dev) { return 1; }\n', '        \n', '        selfdestruct(dev);\n', '        return 0;\n', '    }\n', '\n', '    function tokenAddress() constant returns (address contractAddress){\n', '        return address(tokenContract);\n', '    }\n', '\n', '    function raiseTransferEvent(address _from, address _to, uint256 _value) returns (uint error){\n', '        if(msg.sender != proxyManagementAddress) { return 1; }\n', '\n', '        Transfer(_from, _to, _value);\n', '        return 0;\n', '    }\n', '\n', '    function raiseApprovalEvent(address _owner, address _spender, uint256 _value) returns (uint error){\n', '        if(msg.sender != proxyManagementAddress) { return 1; }\n', '\n', '        Approval(_owner, _spender, _value);\n', '        return 0;\n', '    }\n', '\n', '    function () {\n', '        throw;     \n', '    }\n', '}']