['pragma solidity ^0.4.11;\n', '\n', '// ----------------------------------------------------------------------------\n', '// The Useless Reserve Bank Token Contract\n', '//\n', '// - If you need welfare support, claim your free URB token entitlements from\n', '//   the gubberment.\n', '//\n', '//   Call the default function `()` to claim 1,000 URBs by sending a 0 value\n', '//   transaction to this contract address.\n', '//\n', '//   NOTE that any ethers sent with this call will fill the coffers of this\n', '//   gubberment&#39;s token contract.\n', '//\n', '// - If you consider yourself to be in the top 1%, make a donation for world\n', '//   peace.\n', '//\n', '//   Call `philanthropise({message})` and 100,000 URBs will be sent to\n', '//   your account for each ether you donate. Fractions of ethers are always\n', '//   accepted.\n', '//\n', '//   Your message and donation amount will be etched into the blockchain\n', '//   forever, to recognise your generousity. Thank you.\n', '//\n', '//   As you are making this world a better place, your philanthropic donation\n', '//   is eligible for a special discounted 20% tax rate. Your taxes will be\n', '//   shared equally among the current gubberment treasury officials.\n', '//   Thank you.\n', '//\n', '// - If you have fallen into hard times and have accumulated some URB tokens,\n', '//   you can convert your URBs into ethers.\n', '//\n', '//   Liquidate your URBs by calling `liquidate(amountOfTokens)`, where\n', '//   1 URB is specified as 1,000,000,000,000,000,000 (18 decimal places).\n', '//   You will receive 1 ether for each 30,000 URBs you liquidate.\n', '//\n', '//   NOTE that this treasury contract can only dish out ethers in exchange\n', '//   for URB tokens **IF** there are sufficient ethers in this contract.\n', '//   Only 25% of the ether balance of this contract can be claimed at any\n', '//   one time.\n', '//\n', '// - Any gifts of ERC20 tokens send to this contract will be solemnly accepted\n', '//   by the gubberment. The treasury will at it&#39;s discretion disburst these \n', '//   gifts to friendly officials. Thank you.\n', '//\n', '// Token Contract:\n', '// - Symbol: URB\n', '// - Name: Useless Reserve Bank\n', '// - Decimals: 18\n', '// - Contract address; 0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23\n', '// - Block: 4,000,000\n', '//\n', '// Usage:\n', '// - Watch this contract at address:\n', '//     0x7A83dB2d2737C240C77C7C5D8be8c2aD68f6FF23\n', '//   with the application binary interface published at:\n', '//     https://etherscan.io/address/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23#code\n', '//   to execute this token contract functions in Ethereum Wallet / Mist or\n', '//   MyEtherWallet.\n', '//\n', '// User Functions:\n', '// - default send function ()\n', '//   Users can send 0 or more ethers to this contract address and receive back\n', '//   1000 URBs\n', '//\n', '// - philanthropise(name)\n', '//   Rich users can send a non-zero ether amount, calling this function with\n', '//   a name or dedication message. 100,000 URBs will be minted for each\n', '//   1 ETH sent. Fractions of an ether can be sent.\n', '//   Remember that your goodwill karma is related to the size of your donation.\n', '//\n', '// - liquidate(amountOfTokens)\n', '//   URB token holders can liquidate part or all of their tokens and receive\n', '//   back 1 ether for every 30,000 URBs liquidated, ONLY if the ethers to be\n', '//   received is less than 25% of the outstanding ETH balance of this contract\n', '//\n', '// - bribe()\n', '//   Send ethers directly to the gubberment treasury officials. Your ethers\n', '//   will be distributed equally among the current treasury offcials.\n', '//\n', '// Info Functions:\n', '// - currentEtherBalance()\n', '//   Returns the current ether balance of this contract.\n', '//\n', '// - currentTokenBalance()\n', '//   Returns the total supply of URB tokens, where 1 URB is represented as\n', '//   1,000,000,000,000,000,000 (18 decimal places).\n', '//\n', '// - numberOfTreasuryOfficials()\n', '//   Returns the number of officials on the payroll of the gubberment\n', '//   treasury.\n', '//\n', '// Gubberment Functions:\n', '// - pilfer(amount)\n', '//   Gubberment officials can pilfer any ethers in this contract when necessary.\n', '//\n', '// - acceptGiftTokens(tokenAddress)\n', '//   The gubberment can accept any ERC20-compliant gift tokens send to this\n', '//   contract.\n', '//\n', '// - replaceOfficials([accounts])\n', '//   The gubberment can sack and replace all it&#39;s treasury officials in one go.\n', '//\n', '// Standard ERC20 Functions:\n', '// - balanceOf(account)\n', '// - totalSupply\n', '// - transfer(to, amount)\n', '// - approve(spender, amount)\n', '// - transferFrom(owner, spender, amount)\n', '//\n', '// Yes, I made it into block 4,000,000 .\n', '//\n', '// Remember to make love and peace, not war!\n', '//\n', '// (c) The Gubberment 2017. The MIT Licence.\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Gubberment {\n', '    address public gubberment;\n', '    address public newGubberment;\n', '    event GubbermentOverthrown(address indexed _from, address indexed _to);\n', '\n', '    function Gubberment() {\n', '        gubberment = msg.sender;\n', '    }\n', '\n', '    modifier onlyGubberment {\n', '        if (msg.sender != gubberment) throw;\n', '        _;\n', '    }\n', '\n', '    function coupDetat(address _newGubberment) onlyGubberment {\n', '        newGubberment = _newGubberment;\n', '    }\n', ' \n', '    function gubbermentOverthrown() {\n', '        if (msg.sender == newGubberment) {\n', '            GubbermentOverthrown(gubberment, newGubberment);\n', '            gubberment = newGubberment;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// ERC Token Standard #20 - https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20Token {\n', '    // ------------------------------------------------------------------------\n', '    // Balances for each account\n', '    // ------------------------------------------------------------------------\n', '    mapping(address => uint) balances;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner of account approves the transfer of an amount to another account\n', '    // ------------------------------------------------------------------------\n', '    mapping(address => mapping (address => uint)) allowed;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total token supply\n', '    // ------------------------------------------------------------------------\n', '    uint public totalSupply;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the account balance of another account with address _owner\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer the balance from owner&#39;s account to another account\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address _to, uint _amount) returns (bool success) {\n', '        if (balances[msg.sender] >= _amount\n', '            && _amount > 0\n', '            && balances[_to] + _amount > balances[_to]) {\n', '            balances[msg.sender] -= _amount;\n', '            balances[_to] += _amount;\n', '            Transfer(msg.sender, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Allow _spender to withdraw from your account, multiple times, up to the\n', '    // _value amount. If this function is called again it overwrites the\n', '    // current allowance with _value.\n', '    // ------------------------------------------------------------------------\n', '    function approve(\n', '        address _spender,\n', '        uint _amount\n', '    ) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Spender of tokens transfer an amount of tokens from the token owner&#39;s\n', '    // balance to the spender&#39;s account. The owner of the tokens must already\n', '    // have approve(...)-d this transfer\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint _amount\n', '    ) returns (bool success) {\n', '        if (balances[_from] >= _amount\n', '            && allowed[_from][msg.sender] >= _amount\n', '            && _amount > 0\n', '            && balances[_to] + _amount > balances[_to]) {\n', '            balances[_from] -= _amount;\n', '            allowed[_from][msg.sender] -= _amount;\n', '            balances[_to] += _amount;\n', '            Transfer(_from, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', '    // transferred to the spender&#39;s account\n', '    // ------------------------------------------------------------------------\n', '    function allowance(\n', '        address _owner, \n', '        address _spender\n', '    ) constant returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender,\n', '        uint _value);\n', '}\n', '\n', '\n', 'contract UselessReserveBank is ERC20Token, Gubberment {\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token information\n', '    // ------------------------------------------------------------------------\n', '    string public constant symbol = "URB";\n', '    string public constant name = "Useless Reserve Bank";\n', '    uint8 public constant decimals = 18;\n', '    \n', '    uint public constant WELFARE_HANDOUT = 1000;\n', '    uint public constant ONEPERCENT_TOKENS_PER_ETH = 100000;\n', '    uint public constant LIQUIDATION_TOKENS_PER_ETH = 30000;\n', '\n', '    address[] public treasuryOfficials;\n', '    uint public constant TAXRATE = 20;\n', '    uint public constant LIQUIDATION_RESERVE_RATIO = 75;\n', '\n', '    uint public totalTaxed;\n', '    uint public totalBribery;\n', '    uint public totalPilfered;\n', '\n', '    uint public constant SENDING_BLOCK = 3999998; \n', '\n', '    function UselessReserveBank() {\n', '        treasuryOfficials.push(0xDe18789c4d65DC8ecE671A4145F32F1590c4D802);\n', '        treasuryOfficials.push(0x8899822D031891371afC369767511164Ef21e55c);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Just give the welfare handouts\n', '    // ------------------------------------------------------------------------\n', '    function () payable {\n', '        uint tokens = WELFARE_HANDOUT * 1 ether;\n', '        totalSupply += tokens;\n', '        balances[msg.sender] += tokens;\n', '        WelfareHandout(msg.sender, tokens, totalSupply, msg.value, \n', '            this.balance);\n', '        Transfer(0x0, msg.sender, tokens);\n', '    }\n', '    event WelfareHandout(address indexed recipient, uint tokens, \n', '        uint newTotalSupply, uint ethers, uint newEtherBalance);\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // If you consider yourself rich, donate for world peace\n', '    // ------------------------------------------------------------------------\n', '    function philanthropise(string name) payable {\n', '        // Sending something real?\n', '        require(msg.value > 0);\n', '\n', '        // Calculate the number of tokens\n', '        uint tokens = msg.value * ONEPERCENT_TOKENS_PER_ETH;\n', '\n', '        // Assign tokens to account and inflate total supply\n', '        balances[msg.sender] += tokens;\n', '        totalSupply += tokens;\n', '\n', '        // Calculate and forward taxes to the treasury\n', '        uint taxAmount = msg.value * TAXRATE / 100;\n', '        if (taxAmount > 0) {\n', '            totalTaxed += taxAmount;\n', '            uint taxPerOfficial = taxAmount / treasuryOfficials.length;\n', '            for (uint i = 0; i < treasuryOfficials.length; i++) {\n', '                treasuryOfficials[i].transfer(taxPerOfficial);\n', '            }\n', '        }\n', '\n', '        Philanthropy(msg.sender, name, tokens, totalSupply, msg.value, \n', '            this.balance, totalTaxed);\n', '        Transfer(0x0, msg.sender, tokens);\n', '    }\n', '    event Philanthropy(address indexed buyer, string name, uint tokens, \n', '        uint newTotalSupply, uint ethers, uint newEtherBalance,\n', '        uint totalTaxed);\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Liquidate your tokens for ETH, if this contract has sufficient ETH\n', '    // ------------------------------------------------------------------------\n', '    function liquidate(uint amountOfTokens) {\n', '        // Account must have sufficient tokens\n', '        require(amountOfTokens <= balances[msg.sender]);\n', '\n', '        // Burn tokens\n', '        balances[msg.sender] -= amountOfTokens;\n', '        totalSupply -= amountOfTokens;\n', '\n', '        // Calculate ETH to exchange\n', '        uint ethersToSend = amountOfTokens / LIQUIDATION_TOKENS_PER_ETH;\n', '\n', '        // Is there sufficient ETH to support this liquidation?\n', '        require(ethersToSend > 0 && \n', '            ethersToSend <= (this.balance * (100 - LIQUIDATION_RESERVE_RATIO) / 100));\n', '\n', '        // Log message\n', '        Liquidate(msg.sender, amountOfTokens, totalSupply, \n', '            ethersToSend, this.balance - ethersToSend);\n', '        Transfer(msg.sender, 0x0, amountOfTokens);\n', '\n', '        // Send ETH\n', '        msg.sender.transfer(ethersToSend);\n', '    }\n', '    event Liquidate(address indexed seller, \n', '        uint tokens, uint newTotalSupply, \n', '        uint ethers, uint newEtherBalance);\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Gubberment officials will accept 100% of bribes\n', '    // ------------------------------------------------------------------------\n', '    function bribe() payable {\n', '        // Briber must be offering something real\n', '        require(msg.value > 0);\n', '\n', '        // Do we really need to keep track of the total bribes?\n', '        totalBribery += msg.value;\n', '        Bribed(msg.value, totalBribery);\n', '\n', '        uint bribePerOfficial = msg.value / treasuryOfficials.length;\n', '        for (uint i = 0; i < treasuryOfficials.length; i++) {\n', '            treasuryOfficials[i].transfer(bribePerOfficial);\n', '        }\n', '    }\n', '    event Bribed(uint amount, uint newTotalBribery);\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Gubberment officials can pilfer out of necessity\n', '    // ------------------------------------------------------------------------\n', '    function pilfer(uint amount) onlyGubberment {\n', '        // Cannot pilfer more than the contract balance\n', '        require(amount > this.balance);\n', '\n', '        // Do we really need to keep track of the total pilfered amounts?\n', '        totalPilfered += amount;\n', '        Pilfered(amount, totalPilfered, this.balance - amount);\n', '\n', '        uint amountPerOfficial = amount / treasuryOfficials.length;\n', '        for (uint i = 0; i < treasuryOfficials.length; i++) {\n', '            treasuryOfficials[i].transfer(amountPerOfficial);\n', '        }\n', '    }\n', '    event Pilfered(uint amount, uint totalPilfered, \n', '        uint newEtherBalance);\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Accept any ERC20 gifts\n', '    // ------------------------------------------------------------------------\n', '    function acceptGiftTokens(address tokenAddress) \n', '      onlyGubberment returns (bool success) \n', '    {\n', '        ERC20Token token = ERC20Token(tokenAddress);\n', '        uint amount = token.balanceOf(this);\n', '        return token.transfer(gubberment, amount);\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Change gubberment officials\n', '    // ------------------------------------------------------------------------\n', '    function replaceOfficials(address[] newOfficials) onlyGubberment {\n', '        treasuryOfficials = newOfficials;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Information function\n', '    // ------------------------------------------------------------------------\n', '    function currentEtherBalance() constant returns (uint) {\n', '        return this.balance;\n', '    }\n', '\n', '    function currentTokenBalance() constant returns (uint) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function numberOfTreasuryOfficials() constant returns (uint) {\n', '        return treasuryOfficials.length;\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '// ----------------------------------------------------------------------------\n', '// The Useless Reserve Bank Token Contract\n', '//\n', '// - If you need welfare support, claim your free URB token entitlements from\n', '//   the gubberment.\n', '//\n', '//   Call the default function `()` to claim 1,000 URBs by sending a 0 value\n', '//   transaction to this contract address.\n', '//\n', '//   NOTE that any ethers sent with this call will fill the coffers of this\n', "//   gubberment's token contract.\n", '//\n', '// - If you consider yourself to be in the top 1%, make a donation for world\n', '//   peace.\n', '//\n', '//   Call `philanthropise({message})` and 100,000 URBs will be sent to\n', '//   your account for each ether you donate. Fractions of ethers are always\n', '//   accepted.\n', '//\n', '//   Your message and donation amount will be etched into the blockchain\n', '//   forever, to recognise your generousity. Thank you.\n', '//\n', '//   As you are making this world a better place, your philanthropic donation\n', '//   is eligible for a special discounted 20% tax rate. Your taxes will be\n', '//   shared equally among the current gubberment treasury officials.\n', '//   Thank you.\n', '//\n', '// - If you have fallen into hard times and have accumulated some URB tokens,\n', '//   you can convert your URBs into ethers.\n', '//\n', '//   Liquidate your URBs by calling `liquidate(amountOfTokens)`, where\n', '//   1 URB is specified as 1,000,000,000,000,000,000 (18 decimal places).\n', '//   You will receive 1 ether for each 30,000 URBs you liquidate.\n', '//\n', '//   NOTE that this treasury contract can only dish out ethers in exchange\n', '//   for URB tokens **IF** there are sufficient ethers in this contract.\n', '//   Only 25% of the ether balance of this contract can be claimed at any\n', '//   one time.\n', '//\n', '// - Any gifts of ERC20 tokens send to this contract will be solemnly accepted\n', "//   by the gubberment. The treasury will at it's discretion disburst these \n", '//   gifts to friendly officials. Thank you.\n', '//\n', '// Token Contract:\n', '// - Symbol: URB\n', '// - Name: Useless Reserve Bank\n', '// - Decimals: 18\n', '// - Contract address; 0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23\n', '// - Block: 4,000,000\n', '//\n', '// Usage:\n', '// - Watch this contract at address:\n', '//     0x7A83dB2d2737C240C77C7C5D8be8c2aD68f6FF23\n', '//   with the application binary interface published at:\n', '//     https://etherscan.io/address/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23#code\n', '//   to execute this token contract functions in Ethereum Wallet / Mist or\n', '//   MyEtherWallet.\n', '//\n', '// User Functions:\n', '// - default send function ()\n', '//   Users can send 0 or more ethers to this contract address and receive back\n', '//   1000 URBs\n', '//\n', '// - philanthropise(name)\n', '//   Rich users can send a non-zero ether amount, calling this function with\n', '//   a name or dedication message. 100,000 URBs will be minted for each\n', '//   1 ETH sent. Fractions of an ether can be sent.\n', '//   Remember that your goodwill karma is related to the size of your donation.\n', '//\n', '// - liquidate(amountOfTokens)\n', '//   URB token holders can liquidate part or all of their tokens and receive\n', '//   back 1 ether for every 30,000 URBs liquidated, ONLY if the ethers to be\n', '//   received is less than 25% of the outstanding ETH balance of this contract\n', '//\n', '// - bribe()\n', '//   Send ethers directly to the gubberment treasury officials. Your ethers\n', '//   will be distributed equally among the current treasury offcials.\n', '//\n', '// Info Functions:\n', '// - currentEtherBalance()\n', '//   Returns the current ether balance of this contract.\n', '//\n', '// - currentTokenBalance()\n', '//   Returns the total supply of URB tokens, where 1 URB is represented as\n', '//   1,000,000,000,000,000,000 (18 decimal places).\n', '//\n', '// - numberOfTreasuryOfficials()\n', '//   Returns the number of officials on the payroll of the gubberment\n', '//   treasury.\n', '//\n', '// Gubberment Functions:\n', '// - pilfer(amount)\n', '//   Gubberment officials can pilfer any ethers in this contract when necessary.\n', '//\n', '// - acceptGiftTokens(tokenAddress)\n', '//   The gubberment can accept any ERC20-compliant gift tokens send to this\n', '//   contract.\n', '//\n', '// - replaceOfficials([accounts])\n', "//   The gubberment can sack and replace all it's treasury officials in one go.\n", '//\n', '// Standard ERC20 Functions:\n', '// - balanceOf(account)\n', '// - totalSupply\n', '// - transfer(to, amount)\n', '// - approve(spender, amount)\n', '// - transferFrom(owner, spender, amount)\n', '//\n', '// Yes, I made it into block 4,000,000 .\n', '//\n', '// Remember to make love and peace, not war!\n', '//\n', '// (c) The Gubberment 2017. The MIT Licence.\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Gubberment {\n', '    address public gubberment;\n', '    address public newGubberment;\n', '    event GubbermentOverthrown(address indexed _from, address indexed _to);\n', '\n', '    function Gubberment() {\n', '        gubberment = msg.sender;\n', '    }\n', '\n', '    modifier onlyGubberment {\n', '        if (msg.sender != gubberment) throw;\n', '        _;\n', '    }\n', '\n', '    function coupDetat(address _newGubberment) onlyGubberment {\n', '        newGubberment = _newGubberment;\n', '    }\n', ' \n', '    function gubbermentOverthrown() {\n', '        if (msg.sender == newGubberment) {\n', '            GubbermentOverthrown(gubberment, newGubberment);\n', '            gubberment = newGubberment;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// ERC Token Standard #20 - https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20Token {\n', '    // ------------------------------------------------------------------------\n', '    // Balances for each account\n', '    // ------------------------------------------------------------------------\n', '    mapping(address => uint) balances;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner of account approves the transfer of an amount to another account\n', '    // ------------------------------------------------------------------------\n', '    mapping(address => mapping (address => uint)) allowed;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total token supply\n', '    // ------------------------------------------------------------------------\n', '    uint public totalSupply;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the account balance of another account with address _owner\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Transfer the balance from owner's account to another account\n", '    // ------------------------------------------------------------------------\n', '    function transfer(address _to, uint _amount) returns (bool success) {\n', '        if (balances[msg.sender] >= _amount\n', '            && _amount > 0\n', '            && balances[_to] + _amount > balances[_to]) {\n', '            balances[msg.sender] -= _amount;\n', '            balances[_to] += _amount;\n', '            Transfer(msg.sender, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Allow _spender to withdraw from your account, multiple times, up to the\n', '    // _value amount. If this function is called again it overwrites the\n', '    // current allowance with _value.\n', '    // ------------------------------------------------------------------------\n', '    function approve(\n', '        address _spender,\n', '        uint _amount\n', '    ) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Spender of tokens transfer an amount of tokens from the token owner's\n", "    // balance to the spender's account. The owner of the tokens must already\n", '    // have approve(...)-d this transfer\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint _amount\n', '    ) returns (bool success) {\n', '        if (balances[_from] >= _amount\n', '            && allowed[_from][msg.sender] >= _amount\n', '            && _amount > 0\n', '            && balances[_to] + _amount > balances[_to]) {\n', '            balances[_from] -= _amount;\n', '            allowed[_from][msg.sender] -= _amount;\n', '            balances[_to] += _amount;\n', '            Transfer(_from, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', "    // transferred to the spender's account\n", '    // ------------------------------------------------------------------------\n', '    function allowance(\n', '        address _owner, \n', '        address _spender\n', '    ) constant returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender,\n', '        uint _value);\n', '}\n', '\n', '\n', 'contract UselessReserveBank is ERC20Token, Gubberment {\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token information\n', '    // ------------------------------------------------------------------------\n', '    string public constant symbol = "URB";\n', '    string public constant name = "Useless Reserve Bank";\n', '    uint8 public constant decimals = 18;\n', '    \n', '    uint public constant WELFARE_HANDOUT = 1000;\n', '    uint public constant ONEPERCENT_TOKENS_PER_ETH = 100000;\n', '    uint public constant LIQUIDATION_TOKENS_PER_ETH = 30000;\n', '\n', '    address[] public treasuryOfficials;\n', '    uint public constant TAXRATE = 20;\n', '    uint public constant LIQUIDATION_RESERVE_RATIO = 75;\n', '\n', '    uint public totalTaxed;\n', '    uint public totalBribery;\n', '    uint public totalPilfered;\n', '\n', '    uint public constant SENDING_BLOCK = 3999998; \n', '\n', '    function UselessReserveBank() {\n', '        treasuryOfficials.push(0xDe18789c4d65DC8ecE671A4145F32F1590c4D802);\n', '        treasuryOfficials.push(0x8899822D031891371afC369767511164Ef21e55c);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Just give the welfare handouts\n', '    // ------------------------------------------------------------------------\n', '    function () payable {\n', '        uint tokens = WELFARE_HANDOUT * 1 ether;\n', '        totalSupply += tokens;\n', '        balances[msg.sender] += tokens;\n', '        WelfareHandout(msg.sender, tokens, totalSupply, msg.value, \n', '            this.balance);\n', '        Transfer(0x0, msg.sender, tokens);\n', '    }\n', '    event WelfareHandout(address indexed recipient, uint tokens, \n', '        uint newTotalSupply, uint ethers, uint newEtherBalance);\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // If you consider yourself rich, donate for world peace\n', '    // ------------------------------------------------------------------------\n', '    function philanthropise(string name) payable {\n', '        // Sending something real?\n', '        require(msg.value > 0);\n', '\n', '        // Calculate the number of tokens\n', '        uint tokens = msg.value * ONEPERCENT_TOKENS_PER_ETH;\n', '\n', '        // Assign tokens to account and inflate total supply\n', '        balances[msg.sender] += tokens;\n', '        totalSupply += tokens;\n', '\n', '        // Calculate and forward taxes to the treasury\n', '        uint taxAmount = msg.value * TAXRATE / 100;\n', '        if (taxAmount > 0) {\n', '            totalTaxed += taxAmount;\n', '            uint taxPerOfficial = taxAmount / treasuryOfficials.length;\n', '            for (uint i = 0; i < treasuryOfficials.length; i++) {\n', '                treasuryOfficials[i].transfer(taxPerOfficial);\n', '            }\n', '        }\n', '\n', '        Philanthropy(msg.sender, name, tokens, totalSupply, msg.value, \n', '            this.balance, totalTaxed);\n', '        Transfer(0x0, msg.sender, tokens);\n', '    }\n', '    event Philanthropy(address indexed buyer, string name, uint tokens, \n', '        uint newTotalSupply, uint ethers, uint newEtherBalance,\n', '        uint totalTaxed);\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Liquidate your tokens for ETH, if this contract has sufficient ETH\n', '    // ------------------------------------------------------------------------\n', '    function liquidate(uint amountOfTokens) {\n', '        // Account must have sufficient tokens\n', '        require(amountOfTokens <= balances[msg.sender]);\n', '\n', '        // Burn tokens\n', '        balances[msg.sender] -= amountOfTokens;\n', '        totalSupply -= amountOfTokens;\n', '\n', '        // Calculate ETH to exchange\n', '        uint ethersToSend = amountOfTokens / LIQUIDATION_TOKENS_PER_ETH;\n', '\n', '        // Is there sufficient ETH to support this liquidation?\n', '        require(ethersToSend > 0 && \n', '            ethersToSend <= (this.balance * (100 - LIQUIDATION_RESERVE_RATIO) / 100));\n', '\n', '        // Log message\n', '        Liquidate(msg.sender, amountOfTokens, totalSupply, \n', '            ethersToSend, this.balance - ethersToSend);\n', '        Transfer(msg.sender, 0x0, amountOfTokens);\n', '\n', '        // Send ETH\n', '        msg.sender.transfer(ethersToSend);\n', '    }\n', '    event Liquidate(address indexed seller, \n', '        uint tokens, uint newTotalSupply, \n', '        uint ethers, uint newEtherBalance);\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Gubberment officials will accept 100% of bribes\n', '    // ------------------------------------------------------------------------\n', '    function bribe() payable {\n', '        // Briber must be offering something real\n', '        require(msg.value > 0);\n', '\n', '        // Do we really need to keep track of the total bribes?\n', '        totalBribery += msg.value;\n', '        Bribed(msg.value, totalBribery);\n', '\n', '        uint bribePerOfficial = msg.value / treasuryOfficials.length;\n', '        for (uint i = 0; i < treasuryOfficials.length; i++) {\n', '            treasuryOfficials[i].transfer(bribePerOfficial);\n', '        }\n', '    }\n', '    event Bribed(uint amount, uint newTotalBribery);\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Gubberment officials can pilfer out of necessity\n', '    // ------------------------------------------------------------------------\n', '    function pilfer(uint amount) onlyGubberment {\n', '        // Cannot pilfer more than the contract balance\n', '        require(amount > this.balance);\n', '\n', '        // Do we really need to keep track of the total pilfered amounts?\n', '        totalPilfered += amount;\n', '        Pilfered(amount, totalPilfered, this.balance - amount);\n', '\n', '        uint amountPerOfficial = amount / treasuryOfficials.length;\n', '        for (uint i = 0; i < treasuryOfficials.length; i++) {\n', '            treasuryOfficials[i].transfer(amountPerOfficial);\n', '        }\n', '    }\n', '    event Pilfered(uint amount, uint totalPilfered, \n', '        uint newEtherBalance);\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Accept any ERC20 gifts\n', '    // ------------------------------------------------------------------------\n', '    function acceptGiftTokens(address tokenAddress) \n', '      onlyGubberment returns (bool success) \n', '    {\n', '        ERC20Token token = ERC20Token(tokenAddress);\n', '        uint amount = token.balanceOf(this);\n', '        return token.transfer(gubberment, amount);\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Change gubberment officials\n', '    // ------------------------------------------------------------------------\n', '    function replaceOfficials(address[] newOfficials) onlyGubberment {\n', '        treasuryOfficials = newOfficials;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Information function\n', '    // ------------------------------------------------------------------------\n', '    function currentEtherBalance() constant returns (uint) {\n', '        return this.balance;\n', '    }\n', '\n', '    function currentTokenBalance() constant returns (uint) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function numberOfTreasuryOfficials() constant returns (uint) {\n', '        return treasuryOfficials.length;\n', '    }\n', '}']
