['pragma solidity ^0.4.10;\n', '\n', 'contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n', '\n', '/// @title ICONOMI Daa token\n', 'contract DaaToken {\n', '  //\n', '  // events\n', '  //\n', '  // ERC20 events\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  // mint/burn events\n', '  event Mint(address indexed _to, uint256 _amount, uint256 _newTotalSupply);\n', '  event Burn(address indexed _from, uint256 _amount, uint256 _newTotalSupply);\n', '\n', '  // admin events\n', '  event BlockLockSet(uint256 _value);\n', '  event NewOwner(address _newOwner);\n', '  event NewMinter(address _minter);\n', '\n', '  modifier onlyOwner {\n', '    if (msg.sender == owner) {\n', '      _;\n', '    }\n', '  }\n', '\n', '  modifier minterOrOwner {\n', '    if (msg.sender == minter || msg.sender == owner) {\n', '      _;\n', '    }\n', '  }\n', '\n', '  modifier blockLock(address _sender) {\n', '    if (!isLocked() || _sender == owner) {\n', '      _;\n', '    }\n', '  }\n', '\n', '  modifier validTransfer(address _from, address _to, uint256 _amount) {\n', '    if (isTransferValid(_from, _to, _amount)) {\n', '      _;\n', '    }\n', '  }\n', '\n', '  uint256 public totalSupply;\n', '  string public name;\n', '  uint8 public decimals;\n', '  string public symbol;\n', '  string public version = &#39;0.0.1&#39;;\n', '  address public owner;\n', '  address public minter;\n', '  uint256 public lockedUntilBlock;\n', '\n', '  function DaaToken(\n', '      string _tokenName,\n', '      uint8 _decimalUnits,\n', '      string _tokenSymbol,\n', '      uint256 _lockedUntilBlock\n', '  ) {\n', '\n', '    name = _tokenName;\n', '    decimals = _decimalUnits;\n', '    symbol = _tokenSymbol;\n', '    lockedUntilBlock = _lockedUntilBlock;\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value)\n', '      public\n', '      blockLock(msg.sender)\n', '      validTransfer(msg.sender, _to, _value)\n', '      returns (bool success)\n', '  {\n', '\n', '    // transfer tokens\n', '    balances[msg.sender] -= _value;\n', '    balances[_to] += _value;\n', '\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value)\n', '      public\n', '      returns (bool success)\n', '  {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value)\n', '      public\n', '      blockLock(_from)\n', '      validTransfer(_from, _to, _value)\n', '      returns (bool success)\n', '  {\n', '\n', '    // check sufficient allowance\n', '    if (_value > allowed[_from][msg.sender]) {\n', '      return false;\n', '    }\n', '\n', '    // transfer tokens\n', '    balances[_from] -= _value;\n', '    balances[_to] += _value;\n', '    allowed[_from][msg.sender] -= _value;\n', '\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '      public\n', '      returns (bool success)\n', '  {\n', '    if (approve(_spender, _value)) {\n', '      tokenRecipient(_spender).receiveApproval(msg.sender, _value, this, _extraData);\n', '      return true;\n', '    }\n', '  }\n', '\n', '  /// @notice Mint new tokens. Can only be called by minter or owner\n', '  function mint(address _to, uint256 _value)\n', '      public\n', '      minterOrOwner\n', '      blockLock(msg.sender)\n', '      returns (bool success)\n', '  {\n', '    // ensure _value is greater than zero and\n', '    // doesn&#39;t overflow\n', '    if (totalSupply + _value <= totalSupply) {\n', '      return false;\n', '    }\n', '\n', '    balances[_to] += _value;\n', '    totalSupply += _value;\n', '\n', '    Mint(_to, _value, totalSupply);\n', '    Transfer(0x0, _to, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /// @notice Burn tokens. Can be called by any account\n', '  function burn(uint256 _value)\n', '      public\n', '      blockLock(msg.sender)\n', '      returns (bool success)\n', '  {\n', '    if (_value == 0 || _value > balances[msg.sender]) {\n', '      return false;\n', '    }\n', '\n', '    balances[msg.sender] -= _value;\n', '    totalSupply -= _value;\n', '\n', '    Burn(msg.sender, _value, totalSupply);\n', '    Transfer(msg.sender, 0x0, _value);\n', '\n', '    return true;\n', '  }\n', '\n', '  /// @notice Set block lock. Until that block (exclusive) transfers are disallowed\n', '  function setBlockLock(uint256 _lockedUntilBlock)\n', '      public\n', '      onlyOwner\n', '      returns (bool success)\n', '  {\n', '    lockedUntilBlock = _lockedUntilBlock;\n', '    BlockLockSet(_lockedUntilBlock);\n', '    return true;\n', '  }\n', '\n', '  /// @notice Replace current owner with new one\n', '  function replaceOwner(address _newOwner)\n', '      public\n', '      onlyOwner\n', '      returns (bool success)\n', '  {\n', '    owner = _newOwner;\n', '    NewOwner(_newOwner);\n', '    return true;\n', '  }\n', '\n', '  /// @notice Set account that can mint new tokens\n', '  function setMinter(address _newMinter)\n', '      public\n', '      onlyOwner\n', '      returns (bool success)\n', '  {\n', '    minter = _newMinter;\n', '    NewMinter(_newMinter);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address _owner)\n', '      public\n', '      constant\n', '      returns (uint256 balance)\n', '  {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function allowance(address _owner, address _spender)\n', '      public\n', '      constant\n', '      returns (uint256 remaining)\n', '  {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /// @notice Are transfers currently disallowed\n', '  function isLocked()\n', '      public\n', '      constant\n', '      returns (bool success)\n', '  {\n', '    return lockedUntilBlock > block.number;\n', '  }\n', '\n', '  /// @dev Checks if transfer parameters are valid\n', '  function isTransferValid(address _from, address _to, uint256 _amount)\n', '      private\n', '      constant\n', '      returns (bool isValid)\n', '  {\n', '    return  balances[_from] >= _amount &&  // sufficient balance\n', '            _amount > 0 &&                 // amount is positive\n', '            _to != address(this) &&        // prevent sending tokens to contract\n', '            _to != 0x0                     // prevent sending token to 0x0 address\n', '    ;\n', '  }\n', '\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '}']