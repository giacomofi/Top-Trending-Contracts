['pragma solidity ^0.4.15;\n', '\n', 'contract TokenInterface {\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _amount) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n', '    function approve(address _spender, uint256 _amount) returns (bool success);\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    ) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _spender,\n', '        uint256 _amount\n', '    );\n', '}\n', '\n', 'contract DynamicToken is TokenInterface {\n', '  bool public isClosed;\n', '  bool public isMaxSupplyLocked;\n', '  bool public isLockedOpen;\n', '  bool public isContractOwnerLocked;\n', '\n', '  uint256 public maxSupply;\n', '\n', '  address public upgradedContract;\n', '  address public contractOwner;\n', '  address[] public accounts;\n', '\n', '  string[] public proofIds;\n', '\n', '  mapping (address => bool) public accountExists;\n', '  mapping (string => bool) proofIdExists;\n', '\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public constant decimals = 0;\n', '\n', '  event TransferFrom(address indexed _from, address indexed _to,  address indexed _spender, uint256 _amount);\n', '  event Burn(address indexed _burnFrom, uint256 _amount);\n', '  event Close(address indexed _closedBy);\n', '  event Upgrade(address indexed _upgradedContract);\n', '  event LockOpen(address indexed _by);\n', '  event LockContractOwner(address indexed _by);\n', '  event TransferContractOwnership(address indexed _by, address indexed _to);\n', '  event MaxSupply(address indexed _by, uint256 _newMaxSupply, bool _isMaxSupplyLocked);\n', '\n', '  function DynamicToken() {\n', '    contractOwner = msg.sender;     // contract owner is contract creator\n', '    maxSupply = 10**7;\n', '    totalSupply = 0;\n', '\n', '    isClosed = false;\n', '    isMaxSupplyLocked = false;\n', '    isLockedOpen = false;\n', '    isContractOwnerLocked = false;\n', '    name = "Vevue Pre";\n', '    symbol = "VEVP";\n', '  }\n', '\n', '  // restrict usage to only the owner\n', '  modifier onlyContractOwner {\n', '    if (msg.sender != contractOwner) revert();\n', '    _;\n', '  }\n', '\n', '  // check if the contract has been closed\n', '  modifier notClosed {\n', '    if (isClosed) revert();\n', '    _;\n', '  }\n', '\n', '  modifier notLockedOpen {\n', '    if (isLockedOpen) revert();\n', '    _;\n', '  }\n', '\n', '  // no ether should be transferred to this contract\n', '  modifier noEther() {if (msg.value > 0) revert(); _;}\n', '\n', '  // accessors\n', '\n', '  function getAccounts() noEther constant returns (address[] _accounts) {\n', '    return accounts;\n', '  }\n', '\n', '  function balanceOf(address _owner) noEther constant returns(uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) noEther constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  // TOKEN MUTATORS\n', '\n', '  // tokens are only issued in exchange for a unique proof of contribution\n', '  function issue(address _to, uint256 _amount, string _proofId) notClosed onlyContractOwner noEther returns (bool success) {\n', '    if (balances[_to] + _amount < balances[_to]) revert(); // Guard against overflow\n', '    if (totalSupply + _amount < totalSupply) revert();     // Guard against overflow  (this should never happen)\n', '\n', '    if (proofIdExists[_proofId]) return false;\n', '    if (totalSupply + _amount > maxSupply) return false;\n', '\n', '    balances[msg.sender] += _amount;\n', '    totalSupply += _amount;\n', '\n', '    transfer(_to, _amount);\n', '    _indexAccount(_to);\n', '    _indexProofId(_proofId);\n', '    return true;\n', '  }\n', '\n', '  function setMaxSupply(uint256 _maxSupply) notClosed onlyContractOwner noEther returns (bool success) {\n', '    if (_maxSupply < totalSupply) revert();\n', '    if (isMaxSupplyLocked) return false;\n', '\n', '    maxSupply = _maxSupply;\n', '    MaxSupply(msg.sender, _maxSupply, isMaxSupplyLocked);\n', '    return true;\n', '  }\n', '\n', '  // lock the maxSupply to its current value forever\n', '  function lockMaxSupply() notClosed onlyContractOwner noEther returns(bool success) {\n', '    isMaxSupplyLocked = true;\n', '    MaxSupply(msg.sender, maxSupply, isMaxSupplyLocked);\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _amount) notClosed noEther returns (bool success) {\n', '    return _transfer(msg.sender, _to, _amount);\n', '  }\n', '\n', '  function approve(address _spender, uint256 _amount) notClosed noEther returns (bool success) {\n', '    allowed[msg.sender][_spender] = _amount;\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _amount) notClosed noEther returns (bool success) {\n', '    if (_amount > allowed[_from][msg.sender]) return false;\n', '\n', '    if (allowed[_from][msg.sender] - _amount > allowed[_from][msg.sender]) revert();  // Guard against underflow\n', '\n', '    if (_transfer(_from, _to, _amount)) {\n', '      allowed[_from][msg.sender] -= _amount;\n', '      TransferFrom(_from, _to, msg.sender, _amount);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function burn(uint256 _amount) notClosed noEther returns (bool success) {\n', '    if (_amount > balances[msg.sender]) return false;\n', '\n', '    if (_amount > totalSupply) revert();\n', '    if (balances[msg.sender] - _amount > balances[msg.sender]) revert();     // Guard against underflow\n', '    if (totalSupply - _amount > totalSupply) revert();                     // Guard against underflow\n', '\n', '    balances[msg.sender] -= _amount;\n', '    totalSupply -= _amount;\n', '    Burn(msg.sender, _amount);\n', '    return true;\n', '  }\n', '\n', '  // CONTRACT MUTATORS\n', '\n', '  // Lock the contract owner forever\n', '  function lockContractOwner() notClosed onlyContractOwner noEther returns(bool success) {\n', '    isContractOwnerLocked = true;\n', '    LockContractOwner(msg.sender);\n', '    return true;\n', '  }\n', '\n', '  function transferContractOwnership(address _newOwner) notClosed onlyContractOwner noEther returns (bool success) {\n', '    if(isContractOwnerLocked) revert();\n', '\n', '    contractOwner = _newOwner;\n', '    TransferContractOwnership(msg.sender, _newOwner);\n', '    return true;\n', '  }\n', '\n', '  // Block the contract from ever being upgraded, closed, or destroyed\n', '  function lockOpen() notClosed onlyContractOwner noEther returns (bool success) {\n', '    isLockedOpen = true;\n', '    LockOpen(msg.sender);\n', '    return true;\n', '  }\n', '\n', '  function upgrade(address _upgradedContract) notLockedOpen notClosed onlyContractOwner noEther returns (bool success) {\n', '    upgradedContract = _upgradedContract;\n', '    close();\n', '    Upgrade(_upgradedContract);\n', '    return true;\n', '  }\n', '\n', '  function close() notLockedOpen notClosed onlyContractOwner noEther returns (bool success) {\n', '    isClosed = true;\n', '    Close(msg.sender);\n', '    return true;\n', '  }\n', '\n', '  function destroyContract() notLockedOpen onlyContractOwner noEther {\n', '    selfdestruct(contractOwner);\n', '  }\n', '\n', '  // PRIVATE MUTATORS\n', '\n', '  function _transfer(address _from, address _to, uint256 _amount) notClosed private returns (bool success) {\n', '    if (_amount > balances[_from]) return false;\n', '\n', '    if (balances[_to] + _amount < balances[_to]) revert();      // Guard against overflow\n', '    if (balances[_from] - _amount > balances[_from]) revert();  // Guard against underflow\n', '\n', '    balances[_to] += _amount;\n', '    balances[_from] -= _amount;\n', '    _indexAccount(_to);\n', '    Transfer(_from, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  function _indexAccount(address _account) notClosed private returns (bool success) {\n', '    if (accountExists[_account]) return;\n', '    accountExists[_account] = true;\n', '    accounts.push(_account);\n', '    return true;\n', '  }\n', '\n', '  function _indexProofId(string _proofId) notClosed private returns (bool success) {\n', '    if (proofIdExists[_proofId]) return;\n', '    proofIdExists[_proofId] = true;\n', '    proofIds.push(_proofId);\n', '    return true;\n', '  }\n', '\n', '  // revert() on malformed calls\n', '  function () {\n', '    revert();\n', '  }\n', '}']
['pragma solidity ^0.4.15;\n', '\n', 'contract TokenInterface {\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _amount) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n', '    function approve(address _spender, uint256 _amount) returns (bool success);\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    ) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _spender,\n', '        uint256 _amount\n', '    );\n', '}\n', '\n', 'contract DynamicToken is TokenInterface {\n', '  bool public isClosed;\n', '  bool public isMaxSupplyLocked;\n', '  bool public isLockedOpen;\n', '  bool public isContractOwnerLocked;\n', '\n', '  uint256 public maxSupply;\n', '\n', '  address public upgradedContract;\n', '  address public contractOwner;\n', '  address[] public accounts;\n', '\n', '  string[] public proofIds;\n', '\n', '  mapping (address => bool) public accountExists;\n', '  mapping (string => bool) proofIdExists;\n', '\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public constant decimals = 0;\n', '\n', '  event TransferFrom(address indexed _from, address indexed _to,  address indexed _spender, uint256 _amount);\n', '  event Burn(address indexed _burnFrom, uint256 _amount);\n', '  event Close(address indexed _closedBy);\n', '  event Upgrade(address indexed _upgradedContract);\n', '  event LockOpen(address indexed _by);\n', '  event LockContractOwner(address indexed _by);\n', '  event TransferContractOwnership(address indexed _by, address indexed _to);\n', '  event MaxSupply(address indexed _by, uint256 _newMaxSupply, bool _isMaxSupplyLocked);\n', '\n', '  function DynamicToken() {\n', '    contractOwner = msg.sender;     // contract owner is contract creator\n', '    maxSupply = 10**7;\n', '    totalSupply = 0;\n', '\n', '    isClosed = false;\n', '    isMaxSupplyLocked = false;\n', '    isLockedOpen = false;\n', '    isContractOwnerLocked = false;\n', '    name = "Vevue Pre";\n', '    symbol = "VEVP";\n', '  }\n', '\n', '  // restrict usage to only the owner\n', '  modifier onlyContractOwner {\n', '    if (msg.sender != contractOwner) revert();\n', '    _;\n', '  }\n', '\n', '  // check if the contract has been closed\n', '  modifier notClosed {\n', '    if (isClosed) revert();\n', '    _;\n', '  }\n', '\n', '  modifier notLockedOpen {\n', '    if (isLockedOpen) revert();\n', '    _;\n', '  }\n', '\n', '  // no ether should be transferred to this contract\n', '  modifier noEther() {if (msg.value > 0) revert(); _;}\n', '\n', '  // accessors\n', '\n', '  function getAccounts() noEther constant returns (address[] _accounts) {\n', '    return accounts;\n', '  }\n', '\n', '  function balanceOf(address _owner) noEther constant returns(uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) noEther constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  // TOKEN MUTATORS\n', '\n', '  // tokens are only issued in exchange for a unique proof of contribution\n', '  function issue(address _to, uint256 _amount, string _proofId) notClosed onlyContractOwner noEther returns (bool success) {\n', '    if (balances[_to] + _amount < balances[_to]) revert(); // Guard against overflow\n', '    if (totalSupply + _amount < totalSupply) revert();     // Guard against overflow  (this should never happen)\n', '\n', '    if (proofIdExists[_proofId]) return false;\n', '    if (totalSupply + _amount > maxSupply) return false;\n', '\n', '    balances[msg.sender] += _amount;\n', '    totalSupply += _amount;\n', '\n', '    transfer(_to, _amount);\n', '    _indexAccount(_to);\n', '    _indexProofId(_proofId);\n', '    return true;\n', '  }\n', '\n', '  function setMaxSupply(uint256 _maxSupply) notClosed onlyContractOwner noEther returns (bool success) {\n', '    if (_maxSupply < totalSupply) revert();\n', '    if (isMaxSupplyLocked) return false;\n', '\n', '    maxSupply = _maxSupply;\n', '    MaxSupply(msg.sender, _maxSupply, isMaxSupplyLocked);\n', '    return true;\n', '  }\n', '\n', '  // lock the maxSupply to its current value forever\n', '  function lockMaxSupply() notClosed onlyContractOwner noEther returns(bool success) {\n', '    isMaxSupplyLocked = true;\n', '    MaxSupply(msg.sender, maxSupply, isMaxSupplyLocked);\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _amount) notClosed noEther returns (bool success) {\n', '    return _transfer(msg.sender, _to, _amount);\n', '  }\n', '\n', '  function approve(address _spender, uint256 _amount) notClosed noEther returns (bool success) {\n', '    allowed[msg.sender][_spender] = _amount;\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _amount) notClosed noEther returns (bool success) {\n', '    if (_amount > allowed[_from][msg.sender]) return false;\n', '\n', '    if (allowed[_from][msg.sender] - _amount > allowed[_from][msg.sender]) revert();  // Guard against underflow\n', '\n', '    if (_transfer(_from, _to, _amount)) {\n', '      allowed[_from][msg.sender] -= _amount;\n', '      TransferFrom(_from, _to, msg.sender, _amount);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function burn(uint256 _amount) notClosed noEther returns (bool success) {\n', '    if (_amount > balances[msg.sender]) return false;\n', '\n', '    if (_amount > totalSupply) revert();\n', '    if (balances[msg.sender] - _amount > balances[msg.sender]) revert();     // Guard against underflow\n', '    if (totalSupply - _amount > totalSupply) revert();                     // Guard against underflow\n', '\n', '    balances[msg.sender] -= _amount;\n', '    totalSupply -= _amount;\n', '    Burn(msg.sender, _amount);\n', '    return true;\n', '  }\n', '\n', '  // CONTRACT MUTATORS\n', '\n', '  // Lock the contract owner forever\n', '  function lockContractOwner() notClosed onlyContractOwner noEther returns(bool success) {\n', '    isContractOwnerLocked = true;\n', '    LockContractOwner(msg.sender);\n', '    return true;\n', '  }\n', '\n', '  function transferContractOwnership(address _newOwner) notClosed onlyContractOwner noEther returns (bool success) {\n', '    if(isContractOwnerLocked) revert();\n', '\n', '    contractOwner = _newOwner;\n', '    TransferContractOwnership(msg.sender, _newOwner);\n', '    return true;\n', '  }\n', '\n', '  // Block the contract from ever being upgraded, closed, or destroyed\n', '  function lockOpen() notClosed onlyContractOwner noEther returns (bool success) {\n', '    isLockedOpen = true;\n', '    LockOpen(msg.sender);\n', '    return true;\n', '  }\n', '\n', '  function upgrade(address _upgradedContract) notLockedOpen notClosed onlyContractOwner noEther returns (bool success) {\n', '    upgradedContract = _upgradedContract;\n', '    close();\n', '    Upgrade(_upgradedContract);\n', '    return true;\n', '  }\n', '\n', '  function close() notLockedOpen notClosed onlyContractOwner noEther returns (bool success) {\n', '    isClosed = true;\n', '    Close(msg.sender);\n', '    return true;\n', '  }\n', '\n', '  function destroyContract() notLockedOpen onlyContractOwner noEther {\n', '    selfdestruct(contractOwner);\n', '  }\n', '\n', '  // PRIVATE MUTATORS\n', '\n', '  function _transfer(address _from, address _to, uint256 _amount) notClosed private returns (bool success) {\n', '    if (_amount > balances[_from]) return false;\n', '\n', '    if (balances[_to] + _amount < balances[_to]) revert();      // Guard against overflow\n', '    if (balances[_from] - _amount > balances[_from]) revert();  // Guard against underflow\n', '\n', '    balances[_to] += _amount;\n', '    balances[_from] -= _amount;\n', '    _indexAccount(_to);\n', '    Transfer(_from, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  function _indexAccount(address _account) notClosed private returns (bool success) {\n', '    if (accountExists[_account]) return;\n', '    accountExists[_account] = true;\n', '    accounts.push(_account);\n', '    return true;\n', '  }\n', '\n', '  function _indexProofId(string _proofId) notClosed private returns (bool success) {\n', '    if (proofIdExists[_proofId]) return;\n', '    proofIdExists[_proofId] = true;\n', '    proofIds.push(_proofId);\n', '    return true;\n', '  }\n', '\n', '  // revert() on malformed calls\n', '  function () {\n', '    revert();\n', '  }\n', '}']
