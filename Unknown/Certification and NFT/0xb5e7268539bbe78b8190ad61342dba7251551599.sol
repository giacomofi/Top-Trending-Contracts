['pragma solidity ^0.4.11;\n', '\n', '/*  Copyright 2017 GoInto, LLC\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '        http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', '/**\n', ' * Storage contract for Etherep to store ratings and score data.  It&#39;s been \n', ' * separated from the main contract because this is much less likely to change\n', ' * than the other parts.  It would allow for upgrading the main contract without\n', ' * losing data.\n', ' */\n', 'contract RatingStore {\n', '\n', '    struct Score {\n', '        bool exists;\n', '        int cumulativeScore;\n', '        uint totalRatings;\n', '    }\n', '\n', '    bool internal debug;\n', '    mapping (address => Score) internal scores;\n', '    // The manager with full access\n', '    address internal manager;\n', '    // The contract that has write accees\n', '    address internal controller;\n', '\n', '    /// Events\n', '    event Debug(string message);\n', '\n', '    /**\n', '     * Only the manager or controller can use this method\n', '     */\n', '    modifier restricted() { \n', '        require(msg.sender == manager || tx.origin == manager || msg.sender == controller);\n', '        _; \n', '    }\n', '\n', '    /**\n', '     * Only a certain address can use this modified method\n', '     * @param by The address that can use the method\n', '     */\n', '    modifier onlyBy(address by) { \n', '        require(msg.sender == by);\n', '        _; \n', '    }\n', '\n', '    /**\n', '     * Constructor\n', '     * @param _manager The address that has full access to the contract\n', '     * @param _controller The contract that can make write calls to this contract\n', '     */\n', '    function RatingStore(address _manager, address _controller) {\n', '        manager = _manager;\n', '        controller = _controller;\n', '        debug = false;\n', '    }\n', '\n', '    /**\n', '     * Set a Score\n', '     * @param target The address&#39; score we&#39;re setting\n', '     * @param cumulative The cumulative score for the address\n', '     * @param total Total individual ratings for the address\n', '     * @return success If the set was completed successfully\n', '     */\n', '    function set(address target, int cumulative, uint total) external restricted {\n', '        if (!scores[target].exists) {\n', '            scores[target] = Score(true, 0, 0);\n', '        }\n', '        scores[target].cumulativeScore = cumulative;\n', '        scores[target].totalRatings = total;\n', '    }\n', '\n', '    /**\n', '     * Add a rating\n', '     * @param target The address&#39; score we&#39;re adding to\n', '     * @param wScore The weighted rating to add to the score\n', '     * @return success\n', '     */\n', '    function add(address target, int wScore) external restricted {\n', '        if (!scores[target].exists) {\n', '            scores[target] = Score(true, 0, 0);\n', '        }\n', '        scores[target].cumulativeScore += wScore;\n', '        scores[target].totalRatings += 1;\n', '    }\n', '\n', '    /**\n', '     * Get the score for an address\n', '     * @param target The address&#39; score to return\n', '     * @return cumulative score\n', '     * @return total ratings\n', '     */\n', '    function get(address target) external constant returns (int, uint) {\n', '        if (scores[target].exists == true) {\n', '            return (scores[target].cumulativeScore, scores[target].totalRatings);\n', '        } else {\n', '            return (0,0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Reset an entire score storage\n', '     * @param target The address we&#39;re wiping clean\n', '     */\n', '    function reset(address target) external onlyBy(manager) {\n', '        scores[target] = Score(true, 0,0);\n', '    }\n', '\n', '    /**\n', '     * Return the manager\n', '     * @return address The manager address\n', '     */\n', '    function getManager() external constant returns (address) {\n', '        return manager;\n', '    }\n', '\n', '    /**\n', '     * Change the manager\n', '     * @param newManager The address we&#39;re setting as manager\n', '     */\n', '    function setManager(address newManager) external onlyBy(manager) {\n', '        manager = newManager;\n', '    }\n', '\n', '    /**\n', '     * Return the controller\n', '     * @return address The manager address\n', '     */\n', '    function getController() external constant returns (address) {\n', '        return controller;\n', '    }\n', '\n', '    /**\n', '     * Change the controller\n', '     * @param newController The address we&#39;re setting as controller\n', '     */\n', '    function setController(address newController) external onlyBy(manager) {\n', '        controller = newController;\n', '    }\n', '\n', '    /**\n', '     * Return the debug setting\n', '     * @return bool debug\n', '     */\n', '    function getDebug() external constant returns (bool) {\n', '        return debug;\n', '    }\n', '\n', '    /**\n', '     * Set debug\n', '     * @param _debug The bool value debug should be set to\n', '     */\n', '    function setDebug(bool _debug) external onlyBy(manager) {\n', '        debug = _debug;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/*  Copyright 2017 GoInto, LLC\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '        http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', '/**\n', " * Storage contract for Etherep to store ratings and score data.  It's been \n", ' * separated from the main contract because this is much less likely to change\n', ' * than the other parts.  It would allow for upgrading the main contract without\n', ' * losing data.\n', ' */\n', 'contract RatingStore {\n', '\n', '    struct Score {\n', '        bool exists;\n', '        int cumulativeScore;\n', '        uint totalRatings;\n', '    }\n', '\n', '    bool internal debug;\n', '    mapping (address => Score) internal scores;\n', '    // The manager with full access\n', '    address internal manager;\n', '    // The contract that has write accees\n', '    address internal controller;\n', '\n', '    /// Events\n', '    event Debug(string message);\n', '\n', '    /**\n', '     * Only the manager or controller can use this method\n', '     */\n', '    modifier restricted() { \n', '        require(msg.sender == manager || tx.origin == manager || msg.sender == controller);\n', '        _; \n', '    }\n', '\n', '    /**\n', '     * Only a certain address can use this modified method\n', '     * @param by The address that can use the method\n', '     */\n', '    modifier onlyBy(address by) { \n', '        require(msg.sender == by);\n', '        _; \n', '    }\n', '\n', '    /**\n', '     * Constructor\n', '     * @param _manager The address that has full access to the contract\n', '     * @param _controller The contract that can make write calls to this contract\n', '     */\n', '    function RatingStore(address _manager, address _controller) {\n', '        manager = _manager;\n', '        controller = _controller;\n', '        debug = false;\n', '    }\n', '\n', '    /**\n', '     * Set a Score\n', "     * @param target The address' score we're setting\n", '     * @param cumulative The cumulative score for the address\n', '     * @param total Total individual ratings for the address\n', '     * @return success If the set was completed successfully\n', '     */\n', '    function set(address target, int cumulative, uint total) external restricted {\n', '        if (!scores[target].exists) {\n', '            scores[target] = Score(true, 0, 0);\n', '        }\n', '        scores[target].cumulativeScore = cumulative;\n', '        scores[target].totalRatings = total;\n', '    }\n', '\n', '    /**\n', '     * Add a rating\n', "     * @param target The address' score we're adding to\n", '     * @param wScore The weighted rating to add to the score\n', '     * @return success\n', '     */\n', '    function add(address target, int wScore) external restricted {\n', '        if (!scores[target].exists) {\n', '            scores[target] = Score(true, 0, 0);\n', '        }\n', '        scores[target].cumulativeScore += wScore;\n', '        scores[target].totalRatings += 1;\n', '    }\n', '\n', '    /**\n', '     * Get the score for an address\n', "     * @param target The address' score to return\n", '     * @return cumulative score\n', '     * @return total ratings\n', '     */\n', '    function get(address target) external constant returns (int, uint) {\n', '        if (scores[target].exists == true) {\n', '            return (scores[target].cumulativeScore, scores[target].totalRatings);\n', '        } else {\n', '            return (0,0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Reset an entire score storage\n', "     * @param target The address we're wiping clean\n", '     */\n', '    function reset(address target) external onlyBy(manager) {\n', '        scores[target] = Score(true, 0,0);\n', '    }\n', '\n', '    /**\n', '     * Return the manager\n', '     * @return address The manager address\n', '     */\n', '    function getManager() external constant returns (address) {\n', '        return manager;\n', '    }\n', '\n', '    /**\n', '     * Change the manager\n', "     * @param newManager The address we're setting as manager\n", '     */\n', '    function setManager(address newManager) external onlyBy(manager) {\n', '        manager = newManager;\n', '    }\n', '\n', '    /**\n', '     * Return the controller\n', '     * @return address The manager address\n', '     */\n', '    function getController() external constant returns (address) {\n', '        return controller;\n', '    }\n', '\n', '    /**\n', '     * Change the controller\n', "     * @param newController The address we're setting as controller\n", '     */\n', '    function setController(address newController) external onlyBy(manager) {\n', '        controller = newController;\n', '    }\n', '\n', '    /**\n', '     * Return the debug setting\n', '     * @return bool debug\n', '     */\n', '    function getDebug() external constant returns (bool) {\n', '        return debug;\n', '    }\n', '\n', '    /**\n', '     * Set debug\n', '     * @param _debug The bool value debug should be set to\n', '     */\n', '    function setDebug(bool _debug) external onlyBy(manager) {\n', '        debug = _debug;\n', '    }\n', '\n', '}']
