['pragma solidity ^0.4.11;\n', '\n', '\n', '/*\n', '  Author: Victor Mezrin  victor@mezrin.com\n', '*/\n', '\n', '\n', '/* Interface of the ERC223 token */\n', 'contract ERC223TokenInterface {\n', '    function name() constant returns (string _name);\n', '    function symbol() constant returns (string _symbol);\n', '    function decimals() constant returns (uint8 _decimals);\n', '    function totalSupply() constant returns (uint256 _supply);\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 _balance);\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool _success);\n', '    function allowance(address _owner, address spender) constant returns (uint256 _remaining);\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool _success);\n', '    function transfer(address _to, uint256 _value, bytes _metadata) returns (bool _success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool _success);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value, bytes metadata);\n', '}\n', '\n', '\n', '/* Interface of the contract that is going to receive ERC223 tokens */\n', 'contract ERC223ContractInterface {\n', '    function erc223Fallback(address _from, uint256 _value, bytes _data){\n', '        // to avoid warnings during compilation\n', '        _from = _from;\n', '        _value = _value;\n', '        _data = _data;\n', '        // Incoming transaction code here\n', '        throw;\n', '    }\n', '}\n', '\n', '\n', '/* https://github.com/LykkeCity/EthereumApiDotNetCore/blob/master/src/ContractBuilder/contracts/token/SafeMath.sol */\n', 'contract SafeMath {\n', '    uint256 constant public MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x > MAX_UINT256 - y) throw;\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x < y) throw;\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) return 0;\n', '        if (x > MAX_UINT256 / y) throw;\n', '        return x * y;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC223Token is ERC223TokenInterface, SafeMath {\n', '\n', '    /*\n', '      Storage of the contract\n', '    */\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowances;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '\n', '    /*\n', '      Getters\n', '    */\n', '\n', '    function name() constant returns (string _name) {\n', '        return name;\n', '    }\n', '\n', '    function symbol() constant returns (string _symbol) {\n', '        return symbol;\n', '    }\n', '\n', '    function decimals() constant returns (uint8 _decimals) {\n', '        return decimals;\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256 _supply) {\n', '        return totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 _balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '\n', '    /*\n', '      Allow to spend\n', '    */\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool _success) {\n', '        allowances[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 _remaining) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '\n', '    /*\n', '      Transfer\n', '    */\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool _success) {\n', '        bytes memory emptyMetadata;\n', '        __transfer(msg.sender, _to, _value, emptyMetadata);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value, bytes _metadata) returns (bool _success)\n', '    {\n', '        __transfer(msg.sender, _to, _value, _metadata);\n', '        Transfer(msg.sender, _to, _value, _metadata);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool _success) {\n', '        if (allowances[_from][msg.sender] < _value) throw;\n', '\n', '        allowances[_from][msg.sender] = safeSub(allowances[_from][msg.sender], _value);\n', '        bytes memory emptyMetadata;\n', '        __transfer(_from, _to, _value, emptyMetadata);\n', '        return true;\n', '    }\n', '\n', '    function __transfer(address _from, address _to, uint256 _value, bytes _metadata) internal\n', '    {\n', '        if (_from == _to) throw;\n', '        if (_value == 0) throw;\n', '        if (balanceOf(_from) < _value) throw;\n', '\n', '        balances[_from] = safeSub(balanceOf(_from), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '\n', '        if (isContract(_to)) {\n', '            ERC223ContractInterface receiverContract = ERC223ContractInterface(_to);\n', '            receiverContract.erc223Fallback(_from, _value, _metadata);\n', '        }\n', '\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '\n', '    /*\n', '      Helpers\n', '    */\n', '\n', '    // Assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) internal returns (bool _isContract) {\n', '        _addr = _addr; // to avoid warnings during compilation\n', '\n', '        uint256 length;\n', '        assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '        }\n', '        return (length > 0);\n', '    }\n', '}\n', '\n', '\n', '\n', '// ERC223 token with the ability for the owner to block any account\n', 'contract DASToken is ERC223Token {\n', '    mapping (address => bool) blockedAccounts;\n', '    address public secretaryGeneral;\n', '\n', '\n', '    // Constructor\n', '    function DASToken(\n', '            string _name,\n', '            string _symbol,\n', '            uint8 _decimals,\n', '            uint256 _totalSupply,\n', '            address _initialTokensHolder) {\n', '        secretaryGeneral = msg.sender;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        totalSupply = _totalSupply;\n', '        balances[_initialTokensHolder] = _totalSupply;\n', '    }\n', '\n', '\n', '    modifier onlySecretaryGeneral {\n', '        if (msg.sender != secretaryGeneral) throw;\n', '        _;\n', '    }\n', '\n', '\n', '    // block account\n', '    function blockAccount(address _account) onlySecretaryGeneral {\n', '        blockedAccounts[_account] = true;\n', '    }\n', '\n', '    // unblock account\n', '    function unblockAccount(address _account) onlySecretaryGeneral {\n', '        blockedAccounts[_account] = false;\n', '    }\n', '\n', '    // check is account blocked\n', '    function isAccountBlocked(address _account) returns (bool){\n', '        return blockedAccounts[_account];\n', '    }\n', '\n', '    // override transfer methods to throw on blocked accounts\n', '    function transfer(address _to, uint256 _value) returns (bool _success) {\n', '        if (blockedAccounts[msg.sender]) {\n', '            throw;\n', '        }\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value, bytes _metadata) returns (bool _success) {\n', '        if (blockedAccounts[msg.sender]) {\n', '            throw;\n', '        }\n', '        return super.transfer(_to, _value, _metadata);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool _success) {\n', '        if (blockedAccounts[_from]) {\n', '            throw;\n', '        }\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract DASCrowdsale is ERC223ContractInterface {\n', '\n', '    /* Contract state */\n', '    // configuration\n', '    address public secretaryGeneral;\n', '    address public crowdsaleBeneficiary;\n', '    address public crowdsaleDasTokensChangeBeneficiary;\n', '    uint256 public crowdsaleDeadline;\n', '    uint256 public crowdsaleTokenPriceNumerator;\n', '    uint256 public crowdsaleTokenPriceDenominator;\n', '    DASToken public dasToken;\n', '    // crowdsale results\n', '    mapping (address => uint256) public ethBalanceOf;\n', '    uint256 crowdsaleFundsRaised;\n', '\n', '\n', '    /* Contract events */\n', '    event FundsReceived(address indexed backer, uint256 indexed amount);\n', '\n', '\n', '    /* Configuration */\n', '    function DASCrowdsale(\n', '        address _secretaryGeneral,\n', '        address _crowdsaleBeneficiary,\n', '        address _crowdsaleDasTokensChangeBeneficiary,\n', '        uint256 _durationInSeconds,\n', '        uint256 _crowdsaleTokenPriceNumerator,\n', '        uint256 _crowdsaleTokenPriceDenominator,\n', '        address _dasTokenAddress\n', '    ) {\n', '        secretaryGeneral = _secretaryGeneral;\n', '        crowdsaleBeneficiary = _crowdsaleBeneficiary;\n', '        crowdsaleDasTokensChangeBeneficiary = _crowdsaleDasTokensChangeBeneficiary;\n', '        crowdsaleDeadline = now + _durationInSeconds * 1 seconds;\n', '        crowdsaleTokenPriceNumerator = _crowdsaleTokenPriceNumerator;\n', '        crowdsaleTokenPriceDenominator = _crowdsaleTokenPriceDenominator;\n', '        dasToken = DASToken(_dasTokenAddress);\n', '        crowdsaleFundsRaised = 0;\n', '    }\n', '\n', '    function __setSecretaryGeneral(address _secretaryGeneral) onlySecretaryGeneral {\n', '        secretaryGeneral = _secretaryGeneral;\n', '    }\n', '\n', '    function __setBeneficiary(address _crowdsaleBeneficiary) onlySecretaryGeneral {\n', '        crowdsaleBeneficiary = _crowdsaleBeneficiary;\n', '    }\n', '\n', '    function __setBeneficiaryForDasTokensChange(address _crowdsaleDasTokensChangeBeneficiary) onlySecretaryGeneral {\n', '        crowdsaleDasTokensChangeBeneficiary = _crowdsaleDasTokensChangeBeneficiary;\n', '    }\n', '\n', '    function __setDeadline(uint256 _durationInSeconds) onlySecretaryGeneral {\n', '        crowdsaleDeadline = now + _durationInSeconds * 1 seconds;\n', '    }\n', '\n', '    function __setTokenPrice(\n', '        uint256 _crowdsaleTokenPriceNumerator,\n', '        uint256 _crowdsaleTokenPriceDenominator\n', '    )\n', '        onlySecretaryGeneral\n', '    {\n', '        crowdsaleTokenPriceNumerator = _crowdsaleTokenPriceNumerator;\n', '        crowdsaleTokenPriceDenominator = _crowdsaleTokenPriceDenominator;\n', '    }\n', '\n', '\n', '    /* Deposit funds */\n', '    function() payable onlyBeforeCrowdsaleDeadline {\n', '        uint256 receivedAmount = msg.value;\n', '\n', '        ethBalanceOf[msg.sender] += receivedAmount;\n', '        crowdsaleFundsRaised += receivedAmount;\n', '\n', '        dasToken.transfer(msg.sender, receivedAmount / crowdsaleTokenPriceDenominator * crowdsaleTokenPriceNumerator);\n', '        FundsReceived(msg.sender, receivedAmount);\n', '    }\n', '\n', '    function erc223Fallback(address _from, uint256 _value, bytes _data) {\n', '        // blank ERC223 fallback to receive DA$ tokens\n', '        // to avoid warnings during compilation\n', '        _from = _from;\n', '        _value = _value;\n', '        _data = _data;\n', '    }\n', '\n', '\n', '    /* Finish the crowdsale and withdraw funds */\n', '    function withdraw() onlyAfterCrowdsaleDeadline {\n', '        uint256 ethToWithdraw = address(this).balance;\n', '        uint256 dasToWithdraw = dasToken.balanceOf(address(this));\n', '\n', '        if (ethToWithdraw == 0 && dasToWithdraw == 0) throw;\n', '\n', '        if (ethToWithdraw > 0) { crowdsaleBeneficiary.transfer(ethToWithdraw); }\n', '        if (dasToWithdraw > 0) { dasToken.transfer(crowdsaleDasTokensChangeBeneficiary, dasToWithdraw); }\n', '    }\n', '\n', '\n', '    /* Helpers */\n', '    modifier onlyBeforeCrowdsaleDeadline {\n', '        require(now <= crowdsaleDeadline);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAfterCrowdsaleDeadline {\n', '        require(now > crowdsaleDeadline);\n', '        _;\n', '    }\n', '\n', '    modifier onlySecretaryGeneral {\n', '        if (msg.sender != secretaryGeneral) throw;\n', '        _;\n', '    }\n', '}']