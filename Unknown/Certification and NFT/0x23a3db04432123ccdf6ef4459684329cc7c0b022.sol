['/**\n', ' * Edgeless Casino Proxy Contract. Serves as a proxy for game functionality.\n', ' * Allows the players to deposit and withdraw funds.\n', ' * Allows authorized addresses to make game transactions.\n', ' * author: Julia Altenried\n', ' **/\n', '\n', 'pragma solidity ^ 0.4 .17;\n', '\n', '\n', 'contract token {\n', '\tfunction transferFrom(address sender, address receiver, uint amount) public returns(bool success) {}\n', '\n', '\tfunction transfer(address receiver, uint amount) public returns(bool success) {}\n', '\n', '\tfunction balanceOf(address holder) public constant returns(uint) {}\n', '}\n', '\n', 'contract owned {\n', '\taddress public owner;\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction owned() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tfunction changeOwner(address newOwner) onlyOwner public {\n', '\t\towner = newOwner;\n', '\t}\n', '}\n', '\n', 'contract safeMath {\n', '\t//internals\n', '\tfunction safeSub(uint a, uint b) constant internal returns(uint) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction safeAdd(uint a, uint b) constant internal returns(uint) {\n', '\t\tuint c = a + b;\n', '\t\tassert(c >= a && c >= b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction safeMul(uint a, uint b) constant internal returns(uint) {\n', '\t\tuint c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', 'contract casinoBank is owned, safeMath {\n', '\t/** the total balance of all players with 4 virtual decimals **/\n', '\tuint public playerBalance;\n', '\t/** the balance per player in edgeless tokens with 4 virtual decimals */\n', '\tmapping(address => uint) public balanceOf;\n', '\t/** in case the user wants/needs to call the withdraw function from his own wallet, he first needs to request a withdrawal */\n', '\tmapping(address => uint) public withdrawAfter;\n', '\t/** the price per kgas in tokens (4 decimals) */\n', '\tuint public gasPrice = 20;\n', '\t/** the edgeless token contract */\n', '\ttoken edg;\n', '\t/** owner should be able to close the contract is nobody has been using it for at least 30 days */\n', '\tuint public closeAt;\n', '\t/** informs listeners how many tokens were deposited for a player */\n', '\tevent Deposit(address _player, uint _numTokens, bool _chargeGas);\n', '\t/** informs listeners how many tokens were withdrawn from the player to the receiver address */\n', '\tevent Withdrawal(address _player, address _receiver, uint _numTokens);\n', '\n', '\tfunction casinoBank(address tokenContract) public {\n', '\t\tedg = token(tokenContract);\n', '\t}\n', '\n', '\t/**\n', '\t * accepts deposits for an arbitrary address.\n', '\t * retrieves tokens from the message sender and adds them to the balance of the specified address.\n', '\t * edgeless tokens do not have any decimals, but are represented on this contract with 4 decimals.\n', '\t * @param receiver  address of the receiver\n', '\t *        numTokens number of tokens to deposit (0 decimals)\n', '\t *\t\t\t\t chargeGas indicates if the gas cost is subtracted from the user&#39;s edgeless token balance\n', '\t **/\n', '\tfunction deposit(address receiver, uint numTokens, bool chargeGas) public isAlive {\n', '\t\trequire(numTokens > 0);\n', '\t\tuint value = safeMul(numTokens, 10000);\n', '\t\tif (chargeGas) value = safeSub(value, msg.gas / 1000 * gasPrice);\n', '\t\tassert(edg.transferFrom(msg.sender, address(this), numTokens));\n', '\t\tbalanceOf[receiver] = safeAdd(balanceOf[receiver], value);\n', '\t\tplayerBalance = safeAdd(playerBalance, value);\n', '\t\tDeposit(receiver, numTokens, chargeGas);\n', '\t}\n', '\n', '\t/**\n', '\t * If the user wants/needs to withdraw his funds himself, he needs to request the withdrawal first.\n', '\t * This method sets the earliest possible withdrawal date to 7 minutes from now. \n', '\t * Reason: The user should not be able to withdraw his funds, while the the last game methods have not yet been mined.\n', '\t **/\n', '\tfunction requestWithdrawal() public {\n', '\t\twithdrawAfter[msg.sender] = now + 7 minutes;\n', '\t}\n', '\n', '\t/**\n', '\t * In case the user requested a withdrawal and changes his mind.\n', '\t * Necessary to be able to continue playing.\n', '\t **/\n', '\tfunction cancelWithdrawalRequest() public {\n', '\t\twithdrawAfter[msg.sender] = 0;\n', '\t}\n', '\n', '\t/**\n', '\t * withdraws an amount from the user balance if 7 minutes passed since the request.\n', '\t * @param amount the amount of tokens to withdraw\n', '\t **/\n', '\tfunction withdraw(uint amount) public keepAlive {\n', '\t\trequire(withdrawAfter[msg.sender] > 0 && now > withdrawAfter[msg.sender]);\n', '\t\twithdrawAfter[msg.sender] = 0;\n', '\t\tuint value = safeMul(amount, 10000);\n', '\t\tbalanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);\n', '\t\tplayerBalance = safeSub(playerBalance, value);\n', '\t\tassert(edg.transfer(msg.sender, amount));\n', '\t\tWithdrawal(msg.sender, msg.sender, amount);\n', '\t}\n', '\n', '\t/**\n', '\t * lets the owner withdraw from the bankroll\n', '\t * @param numTokens the number of tokens to withdraw (0 decimals)\n', '\t **/\n', '\tfunction withdrawBankroll(uint numTokens) public onlyOwner {\n', '\t\trequire(numTokens <= bankroll());\n', '\t\tassert(edg.transfer(owner, numTokens));\n', '\t}\n', '\n', '\t/**\n', '\t * returns the current bankroll in tokens with 0 decimals\n', '\t **/\n', '\tfunction bankroll() constant public returns(uint) {\n', '\t\treturn safeSub(edg.balanceOf(address(this)), playerBalance / 10000);\n', '\t}\n', '\n', '\t/** \n', '\t * lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days \n', '\t */\n', '\tfunction close() onlyOwner public {\n', '\t\tif (playerBalance == 0) selfdestruct(owner);\n', '\t\tif (closeAt == 0) closeAt = now + 30 days;\n', '\t\telse if (closeAt < now) selfdestruct(owner);\n', '\t}\n', '\n', '\t/**\n', '\t * in case close has been called accidentally.\n', '\t **/\n', '\tfunction open() onlyOwner public {\n', '\t\tcloseAt = 0;\n', '\t}\n', '\n', '\t/**\n', '\t * make sure the contract is not in process of being closed.\n', '\t **/\n', '\tmodifier isAlive {\n', '\t\trequire(closeAt == 0);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * delays the time of closing.\n', '\t **/\n', '\tmodifier keepAlive {\n', '\t\tif (closeAt > 0) closeAt = now + 30 days;\n', '\t\t_;\n', '\t}\n', '}\n', '\n', 'contract casinoProxy is casinoBank {\n', '\t/** indicates if an address is authorized to call game functions  */\n', '\tmapping(address => bool) public authorized;\n', '\t/** list of casino game contract addresses */\n', '\taddress[] public casinoGames;\n', '\t/** a number to count withdrawal signatures to ensure each signature is different even if withdrawing the same amount to the same address */\n', '\tmapping(address => uint) public count;\n', '\n', '\tmodifier onlyAuthorized {\n', '\t\trequire(authorized[msg.sender]);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyCasinoGames {\n', '\t\tbool isCasino;\n', '\t\tfor (uint i = 0; i < casinoGames.length; i++) {\n', '\t\t\tif (msg.sender == casinoGames[i]) {\n', '\t\t\t\tisCasino = true;\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\trequire(isCasino);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * creates a new casino wallet.\n', '\t * @param authorizedAddress the address which may send transactions to the Edgeless Casino\n', '\t *        blackjackAddress  the address of the Edgeless blackjack contract\n', '\t *\t\t\t\t tokenContract     the address of the Edgeless token contract\n', '\t **/\n', '\tfunction casinoProxy(address authorizedAddress, address blackjackAddress, address tokenContract) casinoBank(tokenContract) public {\n', '\t\tauthorized[authorizedAddress] = true;\n', '\t\tcasinoGames.push(blackjackAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * shifts tokens from the contract balance to the receiver.\n', '\t * only callable from an edgeless casino contract.\n', '\t * @param receiver the address of the receiver\n', '\t *        numTokens the amount of tokens to shift with 4 decimals\n', '\t **/\n', '\tfunction shift(address receiver, uint numTokens) public onlyCasinoGames {\n', '\t\tbalanceOf[receiver] = safeAdd(balanceOf[receiver], numTokens);\n', '\t\tplayerBalance = safeAdd(playerBalance, numTokens);\n', '\t}\n', '\n', '\t/**\n', '\t * transfers an amount from the contract balance to the owner&#39;s wallet.\n', '\t * @param receiver the receiver address\n', '\t *\t\t\t\t amount   the amount of tokens to withdraw (0 decimals)\n', '\t *\t\t\t\t v,r,s \t\tthe signature of the player\n', '\t **/\n', '\tfunction withdrawFor(address receiver, uint amount, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized keepAlive {\n', '\t\tuint gasCost = msg.gas / 1000 * gasPrice;\n', '\t\tvar player = ecrecover(keccak256(receiver, amount, count[receiver]), v, r, s);\n', '\t\tcount[receiver]++;\n', '\t\tuint value = safeAdd(safeMul(amount, 10000), gasCost);\n', '\t\tbalanceOf[player] = safeSub(balanceOf[player], value);\n', '\t\tplayerBalance = safeSub(playerBalance, value);\n', '\t\tassert(edg.transfer(receiver, amount));\n', '\t\tWithdrawal(player, receiver, amount);\n', '\t}\n', '\n', '\t/**\n', '\t * update a casino game address in case of a new contract or a new casino game\n', '\t * @param game       the index of the game \n', '\t *        newAddress the new address of the game\n', '\t **/\n', '\tfunction setGameAddress(uint8 game, address newAddress) public onlyOwner {\n', '\t\tif (game < casinoGames.length) casinoGames[game] = newAddress;\n', '\t\telse casinoGames.push(newAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * authorize a address to call game functions.\n', '\t * @param addr the address to be authorized\n', '\t **/\n', '\tfunction authorize(address addr) public onlyOwner {\n', '\t\tauthorized[addr] = true;\n', '\t}\n', '\n', '\t/**\n', '\t * deauthorize a address to call game functions.\n', '\t * @param addr the address to be deauthorized\n', '\t **/\n', '\tfunction deauthorize(address addr) public onlyOwner {\n', '\t\tauthorized[addr] = false;\n', '\t}\n', '\n', '\t/**\n', '\t * updates the price per 1000 gas in EDG.\n', '\t * @param price the new gas price (4 decimals, max 0.0256 EDG)\n', '\t **/\n', '\tfunction setGasPrice(uint8 price) public onlyOwner {\n', '\t\tgasPrice = price;\n', '\t}\n', '\n', '\t/**\n', '\t * Forwards a move to the corresponding game contract if the data has been signed by the client.\n', '\t * The casino contract ensures it is no duplicate move.\n', '\t * @param game  specifies which game contract to call\n', '\t *        value the value to send to the contract in tokens with 4 decimals\n', '\t *        data  the function call\n', '\t *        v,r,s the player&#39;s signature of the data\n', '\t **/\n', '\tfunction move(uint8 game, uint value, bytes data, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized isAlive {\n', '\t\trequire(game < casinoGames.length);\n', '\t\trequire(safeMul(bankroll(), 10000) > value * 8); //make sure, the casino can always pay out the player\n', '\t\tvar player = ecrecover(keccak256(data), v, r, s);\n', '\t\trequire(withdrawAfter[player] == 0 || now < withdrawAfter[player]);\n', '\t\tvalue = safeAdd(value, msg.gas / 1000 * gasPrice);\n', '\t\tbalanceOf[player] = safeSub(balanceOf[player], value);\n', '\t\tplayerBalance = safeSub(playerBalance, value);\n', '\t\tassert(casinoGames[game].call(data));\n', '\t}\n', '\n', '\n', '}']
['/**\n', ' * Edgeless Casino Proxy Contract. Serves as a proxy for game functionality.\n', ' * Allows the players to deposit and withdraw funds.\n', ' * Allows authorized addresses to make game transactions.\n', ' * author: Julia Altenried\n', ' **/\n', '\n', 'pragma solidity ^ 0.4 .17;\n', '\n', '\n', 'contract token {\n', '\tfunction transferFrom(address sender, address receiver, uint amount) public returns(bool success) {}\n', '\n', '\tfunction transfer(address receiver, uint amount) public returns(bool success) {}\n', '\n', '\tfunction balanceOf(address holder) public constant returns(uint) {}\n', '}\n', '\n', 'contract owned {\n', '\taddress public owner;\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction owned() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tfunction changeOwner(address newOwner) onlyOwner public {\n', '\t\towner = newOwner;\n', '\t}\n', '}\n', '\n', 'contract safeMath {\n', '\t//internals\n', '\tfunction safeSub(uint a, uint b) constant internal returns(uint) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction safeAdd(uint a, uint b) constant internal returns(uint) {\n', '\t\tuint c = a + b;\n', '\t\tassert(c >= a && c >= b);\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction safeMul(uint a, uint b) constant internal returns(uint) {\n', '\t\tuint c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\t\treturn c;\n', '\t}\n', '}\n', '\n', 'contract casinoBank is owned, safeMath {\n', '\t/** the total balance of all players with 4 virtual decimals **/\n', '\tuint public playerBalance;\n', '\t/** the balance per player in edgeless tokens with 4 virtual decimals */\n', '\tmapping(address => uint) public balanceOf;\n', '\t/** in case the user wants/needs to call the withdraw function from his own wallet, he first needs to request a withdrawal */\n', '\tmapping(address => uint) public withdrawAfter;\n', '\t/** the price per kgas in tokens (4 decimals) */\n', '\tuint public gasPrice = 20;\n', '\t/** the edgeless token contract */\n', '\ttoken edg;\n', '\t/** owner should be able to close the contract is nobody has been using it for at least 30 days */\n', '\tuint public closeAt;\n', '\t/** informs listeners how many tokens were deposited for a player */\n', '\tevent Deposit(address _player, uint _numTokens, bool _chargeGas);\n', '\t/** informs listeners how many tokens were withdrawn from the player to the receiver address */\n', '\tevent Withdrawal(address _player, address _receiver, uint _numTokens);\n', '\n', '\tfunction casinoBank(address tokenContract) public {\n', '\t\tedg = token(tokenContract);\n', '\t}\n', '\n', '\t/**\n', '\t * accepts deposits for an arbitrary address.\n', '\t * retrieves tokens from the message sender and adds them to the balance of the specified address.\n', '\t * edgeless tokens do not have any decimals, but are represented on this contract with 4 decimals.\n', '\t * @param receiver  address of the receiver\n', '\t *        numTokens number of tokens to deposit (0 decimals)\n', "\t *\t\t\t\t chargeGas indicates if the gas cost is subtracted from the user's edgeless token balance\n", '\t **/\n', '\tfunction deposit(address receiver, uint numTokens, bool chargeGas) public isAlive {\n', '\t\trequire(numTokens > 0);\n', '\t\tuint value = safeMul(numTokens, 10000);\n', '\t\tif (chargeGas) value = safeSub(value, msg.gas / 1000 * gasPrice);\n', '\t\tassert(edg.transferFrom(msg.sender, address(this), numTokens));\n', '\t\tbalanceOf[receiver] = safeAdd(balanceOf[receiver], value);\n', '\t\tplayerBalance = safeAdd(playerBalance, value);\n', '\t\tDeposit(receiver, numTokens, chargeGas);\n', '\t}\n', '\n', '\t/**\n', '\t * If the user wants/needs to withdraw his funds himself, he needs to request the withdrawal first.\n', '\t * This method sets the earliest possible withdrawal date to 7 minutes from now. \n', '\t * Reason: The user should not be able to withdraw his funds, while the the last game methods have not yet been mined.\n', '\t **/\n', '\tfunction requestWithdrawal() public {\n', '\t\twithdrawAfter[msg.sender] = now + 7 minutes;\n', '\t}\n', '\n', '\t/**\n', '\t * In case the user requested a withdrawal and changes his mind.\n', '\t * Necessary to be able to continue playing.\n', '\t **/\n', '\tfunction cancelWithdrawalRequest() public {\n', '\t\twithdrawAfter[msg.sender] = 0;\n', '\t}\n', '\n', '\t/**\n', '\t * withdraws an amount from the user balance if 7 minutes passed since the request.\n', '\t * @param amount the amount of tokens to withdraw\n', '\t **/\n', '\tfunction withdraw(uint amount) public keepAlive {\n', '\t\trequire(withdrawAfter[msg.sender] > 0 && now > withdrawAfter[msg.sender]);\n', '\t\twithdrawAfter[msg.sender] = 0;\n', '\t\tuint value = safeMul(amount, 10000);\n', '\t\tbalanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);\n', '\t\tplayerBalance = safeSub(playerBalance, value);\n', '\t\tassert(edg.transfer(msg.sender, amount));\n', '\t\tWithdrawal(msg.sender, msg.sender, amount);\n', '\t}\n', '\n', '\t/**\n', '\t * lets the owner withdraw from the bankroll\n', '\t * @param numTokens the number of tokens to withdraw (0 decimals)\n', '\t **/\n', '\tfunction withdrawBankroll(uint numTokens) public onlyOwner {\n', '\t\trequire(numTokens <= bankroll());\n', '\t\tassert(edg.transfer(owner, numTokens));\n', '\t}\n', '\n', '\t/**\n', '\t * returns the current bankroll in tokens with 0 decimals\n', '\t **/\n', '\tfunction bankroll() constant public returns(uint) {\n', '\t\treturn safeSub(edg.balanceOf(address(this)), playerBalance / 10000);\n', '\t}\n', '\n', '\t/** \n', '\t * lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days \n', '\t */\n', '\tfunction close() onlyOwner public {\n', '\t\tif (playerBalance == 0) selfdestruct(owner);\n', '\t\tif (closeAt == 0) closeAt = now + 30 days;\n', '\t\telse if (closeAt < now) selfdestruct(owner);\n', '\t}\n', '\n', '\t/**\n', '\t * in case close has been called accidentally.\n', '\t **/\n', '\tfunction open() onlyOwner public {\n', '\t\tcloseAt = 0;\n', '\t}\n', '\n', '\t/**\n', '\t * make sure the contract is not in process of being closed.\n', '\t **/\n', '\tmodifier isAlive {\n', '\t\trequire(closeAt == 0);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * delays the time of closing.\n', '\t **/\n', '\tmodifier keepAlive {\n', '\t\tif (closeAt > 0) closeAt = now + 30 days;\n', '\t\t_;\n', '\t}\n', '}\n', '\n', 'contract casinoProxy is casinoBank {\n', '\t/** indicates if an address is authorized to call game functions  */\n', '\tmapping(address => bool) public authorized;\n', '\t/** list of casino game contract addresses */\n', '\taddress[] public casinoGames;\n', '\t/** a number to count withdrawal signatures to ensure each signature is different even if withdrawing the same amount to the same address */\n', '\tmapping(address => uint) public count;\n', '\n', '\tmodifier onlyAuthorized {\n', '\t\trequire(authorized[msg.sender]);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyCasinoGames {\n', '\t\tbool isCasino;\n', '\t\tfor (uint i = 0; i < casinoGames.length; i++) {\n', '\t\t\tif (msg.sender == casinoGames[i]) {\n', '\t\t\t\tisCasino = true;\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\trequire(isCasino);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * creates a new casino wallet.\n', '\t * @param authorizedAddress the address which may send transactions to the Edgeless Casino\n', '\t *        blackjackAddress  the address of the Edgeless blackjack contract\n', '\t *\t\t\t\t tokenContract     the address of the Edgeless token contract\n', '\t **/\n', '\tfunction casinoProxy(address authorizedAddress, address blackjackAddress, address tokenContract) casinoBank(tokenContract) public {\n', '\t\tauthorized[authorizedAddress] = true;\n', '\t\tcasinoGames.push(blackjackAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * shifts tokens from the contract balance to the receiver.\n', '\t * only callable from an edgeless casino contract.\n', '\t * @param receiver the address of the receiver\n', '\t *        numTokens the amount of tokens to shift with 4 decimals\n', '\t **/\n', '\tfunction shift(address receiver, uint numTokens) public onlyCasinoGames {\n', '\t\tbalanceOf[receiver] = safeAdd(balanceOf[receiver], numTokens);\n', '\t\tplayerBalance = safeAdd(playerBalance, numTokens);\n', '\t}\n', '\n', '\t/**\n', "\t * transfers an amount from the contract balance to the owner's wallet.\n", '\t * @param receiver the receiver address\n', '\t *\t\t\t\t amount   the amount of tokens to withdraw (0 decimals)\n', '\t *\t\t\t\t v,r,s \t\tthe signature of the player\n', '\t **/\n', '\tfunction withdrawFor(address receiver, uint amount, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized keepAlive {\n', '\t\tuint gasCost = msg.gas / 1000 * gasPrice;\n', '\t\tvar player = ecrecover(keccak256(receiver, amount, count[receiver]), v, r, s);\n', '\t\tcount[receiver]++;\n', '\t\tuint value = safeAdd(safeMul(amount, 10000), gasCost);\n', '\t\tbalanceOf[player] = safeSub(balanceOf[player], value);\n', '\t\tplayerBalance = safeSub(playerBalance, value);\n', '\t\tassert(edg.transfer(receiver, amount));\n', '\t\tWithdrawal(player, receiver, amount);\n', '\t}\n', '\n', '\t/**\n', '\t * update a casino game address in case of a new contract or a new casino game\n', '\t * @param game       the index of the game \n', '\t *        newAddress the new address of the game\n', '\t **/\n', '\tfunction setGameAddress(uint8 game, address newAddress) public onlyOwner {\n', '\t\tif (game < casinoGames.length) casinoGames[game] = newAddress;\n', '\t\telse casinoGames.push(newAddress);\n', '\t}\n', '\n', '\t/**\n', '\t * authorize a address to call game functions.\n', '\t * @param addr the address to be authorized\n', '\t **/\n', '\tfunction authorize(address addr) public onlyOwner {\n', '\t\tauthorized[addr] = true;\n', '\t}\n', '\n', '\t/**\n', '\t * deauthorize a address to call game functions.\n', '\t * @param addr the address to be deauthorized\n', '\t **/\n', '\tfunction deauthorize(address addr) public onlyOwner {\n', '\t\tauthorized[addr] = false;\n', '\t}\n', '\n', '\t/**\n', '\t * updates the price per 1000 gas in EDG.\n', '\t * @param price the new gas price (4 decimals, max 0.0256 EDG)\n', '\t **/\n', '\tfunction setGasPrice(uint8 price) public onlyOwner {\n', '\t\tgasPrice = price;\n', '\t}\n', '\n', '\t/**\n', '\t * Forwards a move to the corresponding game contract if the data has been signed by the client.\n', '\t * The casino contract ensures it is no duplicate move.\n', '\t * @param game  specifies which game contract to call\n', '\t *        value the value to send to the contract in tokens with 4 decimals\n', '\t *        data  the function call\n', "\t *        v,r,s the player's signature of the data\n", '\t **/\n', '\tfunction move(uint8 game, uint value, bytes data, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized isAlive {\n', '\t\trequire(game < casinoGames.length);\n', '\t\trequire(safeMul(bankroll(), 10000) > value * 8); //make sure, the casino can always pay out the player\n', '\t\tvar player = ecrecover(keccak256(data), v, r, s);\n', '\t\trequire(withdrawAfter[player] == 0 || now < withdrawAfter[player]);\n', '\t\tvalue = safeAdd(value, msg.gas / 1000 * gasPrice);\n', '\t\tbalanceOf[player] = safeSub(balanceOf[player], value);\n', '\t\tplayerBalance = safeSub(playerBalance, value);\n', '\t\tassert(casinoGames[game].call(data));\n', '\t}\n', '\n', '\n', '}']
