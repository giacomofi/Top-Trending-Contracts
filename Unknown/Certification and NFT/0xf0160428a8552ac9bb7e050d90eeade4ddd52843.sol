['//***********************************************************\n', '//\n', '// created with pyetherchain.EtherChainAccount(address).describe_contract()\n', '// see: https://github.com/tintinweb/pyetherchain\n', '//\n', '// Date:     Fri Jul 27 15:58:00 2018\n', '//\n', '// Name:     DigixCrowdSale\n', '// Address:  f0160428a8552ac9bb7e050d90eeade4ddd52843\n', '// Swarm:    \n', '//\n', '//\n', "// Constructor Args: constructor None ((address) _config = '<nA>') returns ()\n", '//\n', '//\n', '// Transactions : <disabled>\n', '//\n', '//***************************\n', '/// @title DigixDAO Contract Interfaces\n', '\n', 'contract ConfigInterface {\n', '  address public owner;\n', '  mapping (address => bool) admins;\n', '  mapping (bytes32 => address) addressMap;\n', '  mapping (bytes32 => bool) boolMap;\n', '  mapping (bytes32 => bytes32) bytesMap;\n', '  mapping (bytes32 => uint256) uintMap;\n', '\n', '  /// @notice setConfigAddress sets configuration `_key` to `_val` \n', '  /// @param _key The key name of the configuration.\n', '  /// @param _val The value of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.\n', '  function setConfigAddress(bytes32 _key, address _val) returns (bool success);\n', '\n', '  /// @notice setConfigBool sets configuration `_key` to `_val` \n', '  /// @param _key The key name of the configuration.\n', '  /// @param _val The value of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.\n', '  function setConfigBool(bytes32 _key, bool _val) returns (bool success);\n', '\n', '  /// @notice setConfigBytes sets configuration `_key` to `_val`\n', '  /// @param _key The key name of the configuration.\n', '  /// @param _val The value of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.\n', '  function setConfigBytes(bytes32 _key, bytes32 _val) returns (bool success);\n', '\n', '  /// @notice setConfigUint `_key` to `_val`\n', '  /// @param _key The key name of the configuration.\n', '  /// @param _val The value of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.\n', '  function setConfigUint(bytes32 _key, uint256 _val) returns (bool success);\n', '\n', "  /// @notice getConfigAddress gets configuration `_key`'s value\n", '  /// @param _key The key name of the configuration.\n', '  /// @return The configuration value \n', '  function getConfigAddress(bytes32 _key) returns (address val);\n', '\n', "  /// @notice getConfigBool gets configuration `_key`'s value\n", '  /// @param _key The key name of the configuration.\n', '  /// @return The configuration value \n', '  function getConfigBool(bytes32 _key) returns (bool val);\n', '\n', "  /// @notice getConfigBytes gets configuration `_key`'s value\n", '  /// @param _key The key name of the configuration.\n', '  /// @return The configuration value \n', '  function getConfigBytes(bytes32 _key) returns (bytes32 val);\n', '\n', "  /// @notice getConfigUint gets configuration `_key`'s value\n", '  /// @param _key The key name of the configuration.\n', '  /// @return The configuration value \n', '  function getConfigUint(bytes32 _key) returns (uint256 val);\n', '\n', '  /// @notice addAdmin sets `_admin` as configuration admin\n', '  /// @return Whether the configuration setting was successful or not.  \n', '  function addAdmin(address _admin) returns (bool success);\n', '\n', "  /// @notice removeAdmin removes  `_admin`'s rights\n", '  /// @param _admin The key name of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.  \n', '  function removeAdmin(address _admin) returns (bool success);\n', '\n', '}\n', '\n', 'contract TokenInterface {\n', '\n', '  struct User {\n', '    bool locked;\n', '    uint256 balance;\n', '    uint256 badges;\n', '    mapping (address => uint256) allowed;\n', '  }\n', '\n', '  mapping (address => User) users;\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '  mapping (address => bool) seller;\n', '\n', '  address config;\n', '  address owner;\n', '  address dao;\n', '  bool locked;\n', '\n', '  /// @return total amount of tokens\n', '  uint256 public totalSupply;\n', '  uint256 public totalBadges;\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '  /// @param _owner The address from which the badge count will be retrieved\n', '  /// @return The badges count\n', '  function badgesOf(address _owner) constant returns (uint256 badge);\n', '\n', '  /// @notice send `_value` tokens to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of tokens to be transfered\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice send `_value` badges to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of tokens to be transfered\n', '  /// @return Whether the transfer was successful or not\n', '  function sendBadge(address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of tokens to be transfered\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of tokens to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '  /// @notice mint `_amount` of tokens to `_owner`\n', '  /// @param _owner The address of the account receiving the tokens\n', '  /// @param _amount The amount of tokens to mint\n', '  /// @return Whether or not minting was successful\n', '  function mint(address _owner, uint256 _amount) returns (bool success);\n', '\n', '  /// @notice mintBadge Mint `_amount` badges to `_owner`\n', '  /// @param _owner The address of the account receiving the tokens\n', '  /// @param _amount The amount of tokens to mint\n', '  /// @return Whether or not minting was successful\n', '  function mintBadge(address _owner, uint256 _amount) returns (bool success);\n', '\n', '  function registerDao(address _dao) returns (bool success);\n', '\n', '  function registerSeller(address _tokensales) returns (bool success);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event SendBadge(address indexed _from, address indexed _to, uint256 _amount);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract TokenSalesInterface {\n', '\n', '  struct SaleProxy {\n', '    address payout;\n', '    bool isProxy;\n', '  }\n', '\n', '  struct SaleStatus {\n', '    bool founderClaim;\n', '    uint256 releasedTokens;\n', '    uint256 releasedBadges;\n', '    uint256 claimers;\n', '  }\n', '\n', '  struct Info {\n', '    uint256 totalWei;\n', '    uint256 totalCents;\n', '    uint256 realCents;\n', '    uint256 amount;\n', '  }\n', '\n', '  struct SaleConfig {\n', '    uint256 startDate;\n', '    uint256 periodTwo;\n', '    uint256 periodThree;\n', '    uint256 endDate;\n', '    uint256 goal;\n', '    uint256 cap;\n', '    uint256 badgeCost;\n', '    uint256 founderAmount;\n', '    address founderWallet;\n', '  }\n', '\n', '  struct Buyer {\n', '    uint256 centsTotal;\n', '    uint256 weiTotal;\n', '    bool claimed;\n', '  }\n', '\n', '  Info saleInfo;\n', '  SaleConfig saleConfig;\n', '  SaleStatus saleStatus;\n', '\n', '  address config;\n', '  address owner;\n', '  bool locked;\n', '\n', '  uint256 public ethToCents;\n', '\n', '  mapping (address => Buyer) buyers;\n', '  mapping (address => SaleProxy) proxies;\n', '\n', '  /// @notice Calculates the parts per billion 1â\x81„1,000,000,000 of `_a` to `_b`\n', '  /// @param _a The antecedent\n', '  /// @param _c The consequent\n', '  /// @return Part per billion value\n', '  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b);\n', '\n', '\n', '  /// @notice Calculates the share from `_total` based on `_contrib` \n', '  /// @param _contrib The contributed amount in USD\n', '  /// @param _total The total amount raised in USD\n', '  /// @return Total number of shares\n', '  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share);\n', '\n', '  /// @notice Calculates the current USD cents value of `_wei` \n', '  /// @param _wei the amount of wei\n', '  /// @return The USD cents value\n', '  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue);\n', '\n', '  function proxyPurchase(address _user) returns (bool success);\n', '\n', '  /// @notice Send msg.value purchase for _user.  \n', '  /// @param _user The account to be credited\n', '  /// @return Success if purchase was accepted\n', '  function purchase(address _user, uint256 _amount) private returns (bool success);\n', '\n', '  /// @notice Get crowdsale information for `_user`\n', '  /// @param _user The account to be queried\n', '  /// @return `centstotal` the total amount of USD cents contributed\n', '  /// @return `weitotal` the total amount in wei contributed\n', '  /// @return `share` the current token shares earned\n', '  /// @return `badges` the number of proposer badges earned\n', '  /// @return `claimed` is true if the tokens and badges have been claimed\n', '  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n', '\n', '  /// @notice Get the crowdsale information from msg.sender (see userInfo)\n', '  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n', '\n', '  /// @notice get the total amount of wei raised for the crowdsale\n', '  /// @return The amount of wei raised\n', '  function totalWei() public constant returns (uint);\n', '\n', '  /// @notice get the total USD value in cents raised for the crowdsale\n', '  /// @return the amount USD cents\n', '  function totalCents() public constant returns (uint);\n', '\n', '  /// @notice get the current crowdsale information\n', '  /// @return `startsale` The unix timestamp for the start of the crowdsale and the first period modifier\n', '  /// @return `two` The unix timestamp for the start of the second period modifier\n', '  /// @return `three` The unix timestamp for the start of the third period modifier\n', '  /// @return `endsale` The unix timestamp of the end of crowdsale\n', '  /// @return `totalwei` The total amount of wei raised\n', '  /// @return `totalcents` The total number of USD cents raised\n', '  /// @return `amount` The amount of DGD tokens available for the crowdsale\n', '  /// @return `goal` The USD value goal for the crowdsale\n', '  /// @return `famount` Founders endowment\n', '  /// @return `faddress` Founder wallet address\n', '  /*function getSaleInfo() public constant returns (uint256 startsale, uint256 two, uint256 three, uint256 endsale, uint256 totalwei, uint256 totalcents, uint256 amount, uint256 goal, uint256 famount, address faddress);*/\n', '\n', '  function claimFor(address _user) returns (bool success); \n', '\n', '  /// @notice Allows msg.sender to claim the DGD tokens and badges if the goal is reached or refunds the ETH contributed if goal is not reached at the end of the crowdsale\n', '  function claim() returns (bool success);\n', '\n', '  function claimFounders() returns (bool success);\n', '\n', '  /// @notice See if the crowdsale goal has been reached\n', '  function goalReached() public constant returns (bool reached);\n', '\n', '  /// @notice Get the current sale period\n', '  /// @return `saleperiod` 0 = Outside of the crowdsale period, 1 = First reward period, 2 = Second reward period, 3 = Final crowdsale period.\n', '  function getPeriod() public constant returns (uint saleperiod);\n', '\n', '  /// @notice Get the date for the start of the crowdsale\n', '  /// @return `date` The unix timestamp for the start\n', '  function startDate() public constant returns (uint date);\n', '  \n', '  /// @notice Get the date for the second reward period of the crowdsale\n', '  /// @return `date` The unix timestamp for the second period\n', '  function periodTwo() public constant returns (uint date);\n', '\n', '  /// @notice Get the date for the final period of the crowdsale\n', '  /// @return `date` The unix timestamp for the final period\n', '  function periodThree() public constant returns (uint date);\n', '\n', '  /// @notice Get the date for the end of the crowdsale\n', '  /// @return `date` The unix timestamp for the end of the crowdsale\n', '  function endDate() public constant returns (uint date);\n', '\n', '  /// @notice Check if crowdsale has ended\n', '  /// @return `ended` If the crowdsale has ended\n', '  \n', '  function isEnded() public constant returns (bool ended);\n', '\n', '  /// @notice Send raised funds from the crowdsale to the DAO\n', '  /// @return `success` if the send succeeded\n', '  function sendFunds() public returns (bool success);\n', '\n', '  //function regProxy(address _payment, address _payout) returns (bool success);\n', '  function regProxy(address _payout) returns (bool success);\n', '\n', '  function getProxy(address _payout) public returns (address proxy);\n', '  \n', '  function getPayout(address _proxy) public returns (address payout, bool isproxy);\n', '\n', '  function unlock() public returns (bool success);\n', '\n', '  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers);\n', '\n', '  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount);\n', '\n', '  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet);\n', '  \n', '  event Purchase(uint256 indexed _exchange, uint256 indexed _rate, uint256 indexed _cents);\n', '  event Claim(address indexed _user, uint256 indexed _amount, uint256 indexed _badges);\n', '\n', '}\n', '\n', 'contract ProxyPayment {\n', '\n', '  address payout;\n', '  address tokenSales; \n', '  address owner;\n', '\n', '  function ProxyPayment(address _payout, address _tokenSales) {\n', '    payout = _payout;\n', '    tokenSales = _tokenSales;\n', '    owner = _payout;\n', '  }\n', '\n', '  function () {\n', '    if (!TokenSalesInterface(tokenSales).proxyPurchase.value(msg.value).gas(106000)(payout)) throw;\n', '  }\n', '\n', '}\n', '\n', 'contract TokenSales is TokenSalesInterface {\n', '\n', '  modifier ifOwner() {\n', '    if (msg.sender != owner) throw;\n', '    _\n', '  }\n', '\n', '  modifier ifOOrigin() {\n', '    if (tx.origin != owner) throw;\n', '    _\n', '  }\n', '\n', '  mapping (address => address) proxyPayouts;\n', '  uint256 public WEI_PER_ETH = 1000000000000000000;\n', '  uint256 public BILLION = 1000000000;\n', '  uint256 public CENTS = 100;\n', '\n', '\n', '  function TokenSales(address _config) {\n', '    owner = msg.sender;\n', '    config = _config;\n', '    saleStatus.founderClaim = false;\n', '    saleStatus.releasedTokens = 0;\n', '    saleStatus.releasedBadges = 0;\n', '    saleStatus.claimers = 0;\n', '    saleConfig.startDate = ConfigInterface(_config).getConfigUint("sale1:period1");\n', '    saleConfig.periodTwo = ConfigInterface(_config).getConfigUint("sale1:period2");\n', '    saleConfig.periodThree = ConfigInterface(_config).getConfigUint("sale1:period3");\n', '    saleConfig.endDate = ConfigInterface(_config).getConfigUint("sale1:end");\n', '    saleConfig.founderAmount = ConfigInterface(_config).getConfigUint("sale1:famount") * BILLION;\n', '    saleConfig.founderWallet = ConfigInterface(_config).getConfigAddress("sale1:fwallet");\n', '    saleConfig.goal = ConfigInterface(_config).getConfigUint("sale1:goal") * CENTS;\n', '    saleConfig.cap = ConfigInterface(_config).getConfigUint("sale1:cap") * CENTS;\n', '    saleConfig.badgeCost = ConfigInterface(_config).getConfigUint("sale1:badgecost") * CENTS;\n', '    saleInfo.amount = ConfigInterface(_config).getConfigUint("sale1:amount") * BILLION;\n', '    saleInfo.totalWei = 0;\n', '    saleInfo.totalCents = 0;\n', '    saleInfo.realCents;\n', '    saleStatus.founderClaim = false;\n', '    locked = true;\n', '  }\n', '\n', '  function () {\n', '    if (getPeriod() == 0) throw;\n', '    uint256 _amount = msg.value;\n', '    address _sender;\n', '    if (proxies[msg.sender].isProxy == true) {\n', '      _sender = proxies[msg.sender].payout;\n', '    } else {\n', '      _sender = msg.sender;\n', '    }\n', '    if (!purchase(_sender, _amount)) throw;\n', '  }\n', '\n', '  function proxyPurchase(address _user) returns (bool success) {\n', '    return purchase(_user, msg.value);\n', '  }\n', '\n', '  function purchase(address _user, uint256 _amount) private returns (bool success) {\n', '    uint256 _cents = weiToCents(_amount);\n', '    if ((saleInfo.realCents + _cents) > saleConfig.cap) return false;\n', '    uint256 _wei = _amount;\n', '    uint256 _modifier;\n', '    uint _period = getPeriod();\n', '    if ((_period == 0) || (_cents == 0)) {\n', '      return false;\n', '    } else {\n', '      if (_period == 3) _modifier = 100;\n', '      if (_period == 2) _modifier = 115;\n', '      if (_period == 1) _modifier = 130;\n', '      uint256 _creditwei = _amount;\n', '      uint256 _creditcents = (weiToCents(_creditwei) * _modifier * 10000) / 1000000 ;\n', '      buyers[_user].centsTotal += _creditcents;\n', '      buyers[_user].weiTotal += _creditwei; \n', '      saleInfo.totalCents += _creditcents;\n', '      saleInfo.realCents += _cents;\n', '      saleInfo.totalWei += _creditwei;\n', '      Purchase(ethToCents, _modifier, _creditcents); \n', '      return true;\n', '    }\n', '  }\n', '\n', '  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b) {\n', '    b = (BILLION * _a + _c / 2) / _c;\n', '    return b;\n', '  }\n', '\n', '  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share) {\n', '    uint256 _ppb = ppb(_contrib, _total);\n', '    share = ((_ppb * saleInfo.amount) / BILLION);\n', '    return share;\n', '  }\n', '\n', '  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue) {\n', '    centsvalue = ((_wei * 100000 / WEI_PER_ETH) * ethToCents) / 100000;\n', '    return centsvalue;\n', '  }\n', '\n', '  function setEthToCents(uint256 _eth) ifOwner returns (bool success) {\n', '    ethToCents = _eth;\n', '    success = true;\n', '    return success;\n', '  }\n', '\n', '\n', '  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers) {\n', '    return (saleStatus.founderClaim, saleStatus.releasedTokens, saleStatus.releasedBadges, saleStatus.claimers);\n', '  }\n', '\n', '  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount) {\n', '    return (saleInfo.totalWei, saleInfo.totalCents, saleInfo.realCents, saleInfo.amount);\n', '  }\n', '\n', '\n', '  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet) {\n', '    return (saleConfig.startDate, saleConfig.periodTwo, saleConfig.periodThree, saleConfig.endDate, saleConfig.goal, saleConfig.cap, saleConfig.badgeCost, saleConfig.founderAmount, saleConfig.founderWallet);\n', '  }\n', '\n', '  function goalReached() public constant returns (bool reached) {\n', '    reached = (saleInfo.totalCents >= saleConfig.goal);\n', '    return reached;\n', '  }\n', '\n', '  function claim() returns (bool success) {\n', '    return claimFor(msg.sender);\n', '  }\n', '\n', '  function claimFor(address _user) returns (bool success) {\n', '    if ( (now < saleConfig.endDate) || (buyers[_user].claimed == true) ) {\n', '      return true;\n', '    }\n', '  \n', '    if (!goalReached()) {\n', '      if (!address(_user).send(buyers[_user].weiTotal)) throw;\n', '      buyers[_user].claimed = true;\n', '      return true;\n', '    }\n', '\n', '    if (goalReached()) {\n', '      address _tokenc = ConfigInterface(config).getConfigAddress("ledger");\n', '      uint256 _tokens = calcShare(buyers[_user].centsTotal, saleInfo.totalCents); \n', '      uint256 _badges = buyers[_user].centsTotal / saleConfig.badgeCost;\n', '      if ((TokenInterface(_tokenc).mint(msg.sender, _tokens)) && (TokenInterface(_tokenc).mintBadge(_user, _badges))) {\n', '        saleStatus.releasedTokens += _tokens;\n', '        saleStatus.releasedBadges += _badges;\n', '        saleStatus.claimers += 1;\n', '        buyers[_user].claimed = true;\n', '        Claim(_user, _tokens, _badges);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '  }\n', '\n', '  function claimFounders() returns (bool success) {\n', '    if (saleStatus.founderClaim == true) return false;\n', '    if (now < saleConfig.endDate) return false;\n', '    if (!goalReached()) return false;\n', '    address _tokenc = ConfigInterface(config).getConfigAddress("ledger");\n', '    uint256 _tokens = saleConfig.founderAmount;\n', '    uint256 _badges = 4;\n', '    address _faddr = saleConfig.founderWallet;\n', '    if ((TokenInterface(_tokenc).mint(_faddr, _tokens)) && (TokenInterface(_tokenc).mintBadge(_faddr, _badges))) {\n', '      saleStatus.founderClaim = true;\n', '      saleStatus.releasedTokens += _tokens;\n', '      saleStatus.releasedBadges += _badges;\n', '      saleStatus.claimers += 1;\n', '      Claim(_faddr, _tokens, _badges);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function getPeriod() public constant returns (uint saleperiod) {\n', '    if ((now > saleConfig.endDate) || (now < saleConfig.startDate)) {\n', '      saleperiod = 0;\n', '      return saleperiod;\n', '    }\n', '    if (now >= saleConfig.periodThree) {\n', '      saleperiod = 3;\n', '      return saleperiod;\n', '    }\n', '    if (now >= saleConfig.periodTwo) {\n', '      saleperiod = 2;\n', '      return saleperiod;\n', '    }\n', '    if (now < saleConfig.periodTwo) {\n', '      saleperiod = 1;\n', '      return saleperiod;\n', '    }\n', '  }\n', '\n', '  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed) {\n', '    share = calcShare(buyers[_user].centsTotal, saleInfo.totalCents);\n', '    badges = buyers[_user].centsTotal / saleConfig.badgeCost;\n', '    return (buyers[_user].centsTotal, buyers[_user].weiTotal, share, badges, buyers[_user].claimed);\n', '  }\n', '\n', '  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed) {\n', '    return userInfo(msg.sender);\n', '  }\n', '\n', '  function totalWei() public constant returns (uint) {\n', '    return saleInfo.totalWei;\n', '  }\n', '\n', '  function totalCents() public constant returns (uint) {\n', '    return saleInfo.totalCents;\n', '  }\n', '\n', '  function startDate() public constant returns (uint date) {\n', '    return saleConfig.startDate;\n', '  }\n', '  \n', '  function periodTwo() public constant returns (uint date) {\n', '    return saleConfig.periodTwo;\n', '  }\n', '\n', '  function periodThree() public constant returns (uint date) {\n', '    return saleConfig.periodThree;\n', '  }\n', '\n', '  function endDate() public constant returns (uint date) {\n', '    return saleConfig.endDate;\n', '  }\n', '\n', '  function isEnded() public constant returns (bool ended) {\n', '    return (now >= endDate());\n', '  }\n', '  \n', '  function sendFunds() public returns (bool success) {\n', '    if (locked) return false;\n', '    if (!goalReached()) return false;\n', '    if (!isEnded()) return false;\n', '    address _dao = ConfigInterface(config).getConfigAddress("sale1:dao");\n', '    if (_dao == 0x0000000000000000000000000000000000000000) return false;\n', '    return _dao.send(totalWei());\n', '  }\n', '\n', '  function regProxy(address _payout) ifOOrigin returns (bool success) {\n', '    address _proxy = new ProxyPayment(_payout, address(this));\n', '    proxies[_proxy].payout = _payout;\n', '    proxies[_proxy].isProxy = true;\n', '    proxyPayouts[_payout] = _proxy;\n', '    return true;\n', '  }\n', '  \n', '  function getProxy(address _payout) public returns (address proxy) {\n', '    return proxyPayouts[_payout];\n', '  }\n', '\n', '  function getPayout(address _proxy) public returns (address payout, bool isproxy) {\n', '    return (proxies[_proxy].payout, proxies[_proxy].isProxy);\n', '  }\n', '\n', '  function unlock() ifOwner public returns (bool success) {\n', '    locked = false;\n', '    return true;\n', '  }\n', '}']
['//***********************************************************\n', '//\n', '// created with pyetherchain.EtherChainAccount(address).describe_contract()\n', '// see: https://github.com/tintinweb/pyetherchain\n', '//\n', '// Date:     Tue Apr 10 21:34:41 2018\n', '//\n', '// Name:     DigixCrowdSale\n', '// Address:  f0160428a8552ac9bb7e050d90eeade4ddd52843\n', '// Swarm:    \n', '//\n', '//\n', '// Constructor Args: [constructor None <unknown> returns (<unknown>)]\n', '//\n', '//\n', '// Transactions (last 5): \n', '//     [IN] 83846d85aee4fb2cfd495968ac2ff1055525adbfdea02c4b2c80efae92846783 : [function claimFounders <unknown> returns (((bool) success))]\n', "//     [IN] d2ab73fe81a788b2b14810a366d6e5eb2f375d65bdee6a1cad343071cd566ab5 : [<unknown>  ((<unknown>)  'Hi, please check out the first tokenized animated movie TROLLHUNTERS!!\\nhttps://tokit.io/campaign/0xc336a19213609a5b21ba7125f96684b2cfeb8d5a\\nThanks and stay cool!') returns (<unknown>)]\n", '//     [IN] d92d716d7a5e53d5ffb751dc508e40cbb1f661548cf6867488a2f52d4adad106 : [function claimFounders <unknown> returns (((bool) success))]\n', '//     [IN] 499fea8795db45352b9e18ff7b956070c9476cf2de2f9f86052ac8b316662946 : [function claim <unknown> returns (((bool) success))]\n', '//\n', '//***************************\n', '/// @title DigixDAO Contract Interfaces\n', '\n', 'contract ConfigInterface {\n', '  address public owner;\n', '  mapping (address => bool) admins;\n', '  mapping (bytes32 => address) addressMap;\n', '  mapping (bytes32 => bool) boolMap;\n', '  mapping (bytes32 => bytes32) bytesMap;\n', '  mapping (bytes32 => uint256) uintMap;\n', '\n', '  /// @notice setConfigAddress sets configuration `_key` to `_val` \n', '  /// @param _key The key name of the configuration.\n', '  /// @param _val The value of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.\n', '  function setConfigAddress(bytes32 _key, address _val) returns (bool success);\n', '\n', '  /// @notice setConfigBool sets configuration `_key` to `_val` \n', '  /// @param _key The key name of the configuration.\n', '  /// @param _val The value of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.\n', '  function setConfigBool(bytes32 _key, bool _val) returns (bool success);\n', '\n', '  /// @notice setConfigBytes sets configuration `_key` to `_val`\n', '  /// @param _key The key name of the configuration.\n', '  /// @param _val The value of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.\n', '  function setConfigBytes(bytes32 _key, bytes32 _val) returns (bool success);\n', '\n', '  /// @notice setConfigUint `_key` to `_val`\n', '  /// @param _key The key name of the configuration.\n', '  /// @param _val The value of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.\n', '  function setConfigUint(bytes32 _key, uint256 _val) returns (bool success);\n', '\n', "  /// @notice getConfigAddress gets configuration `_key`'s value\n", '  /// @param _key The key name of the configuration.\n', '  /// @return The configuration value \n', '  function getConfigAddress(bytes32 _key) returns (address val);\n', '\n', "  /// @notice getConfigBool gets configuration `_key`'s value\n", '  /// @param _key The key name of the configuration.\n', '  /// @return The configuration value \n', '  function getConfigBool(bytes32 _key) returns (bool val);\n', '\n', "  /// @notice getConfigBytes gets configuration `_key`'s value\n", '  /// @param _key The key name of the configuration.\n', '  /// @return The configuration value \n', '  function getConfigBytes(bytes32 _key) returns (bytes32 val);\n', '\n', "  /// @notice getConfigUint gets configuration `_key`'s value\n", '  /// @param _key The key name of the configuration.\n', '  /// @return The configuration value \n', '  function getConfigUint(bytes32 _key) returns (uint256 val);\n', '\n', '  /// @notice addAdmin sets `_admin` as configuration admin\n', '  /// @return Whether the configuration setting was successful or not.  \n', '  function addAdmin(address _admin) returns (bool success);\n', '\n', "  /// @notice removeAdmin removes  `_admin`'s rights\n", '  /// @param _admin The key name of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.  \n', '  function removeAdmin(address _admin) returns (bool success);\n', '\n', '}\n', '\n', 'contract TokenInterface {\n', '\n', '  struct User {\n', '    bool locked;\n', '    uint256 balance;\n', '    uint256 badges;\n', '    mapping (address => uint256) allowed;\n', '  }\n', '\n', '  mapping (address => User) users;\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '  mapping (address => bool) seller;\n', '\n', '  address config;\n', '  address owner;\n', '  address dao;\n', '  bool locked;\n', '\n', '  /// @return total amount of tokens\n', '  uint256 public totalSupply;\n', '  uint256 public totalBadges;\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '  /// @param _owner The address from which the badge count will be retrieved\n', '  /// @return The badges count\n', '  function badgesOf(address _owner) constant returns (uint256 badge);\n', '\n', '  /// @notice send `_value` tokens to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of tokens to be transfered\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice send `_value` badges to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of tokens to be transfered\n', '  /// @return Whether the transfer was successful or not\n', '  function sendBadge(address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of tokens to be transfered\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of tokens to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '  /// @notice mint `_amount` of tokens to `_owner`\n', '  /// @param _owner The address of the account receiving the tokens\n', '  /// @param _amount The amount of tokens to mint\n', '  /// @return Whether or not minting was successful\n', '  function mint(address _owner, uint256 _amount) returns (bool success);\n', '\n', '  /// @notice mintBadge Mint `_amount` badges to `_owner`\n', '  /// @param _owner The address of the account receiving the tokens\n', '  /// @param _amount The amount of tokens to mint\n', '  /// @return Whether or not minting was successful\n', '  function mintBadge(address _owner, uint256 _amount) returns (bool success);\n', '\n', '  function registerDao(address _dao) returns (bool success);\n', '\n', '  function registerSeller(address _tokensales) returns (bool success);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event SendBadge(address indexed _from, address indexed _to, uint256 _amount);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract TokenSalesInterface {\n', '\n', '  struct SaleProxy {\n', '    address payout;\n', '    bool isProxy;\n', '  }\n', '\n', '  struct SaleStatus {\n', '    bool founderClaim;\n', '    uint256 releasedTokens;\n', '    uint256 releasedBadges;\n', '    uint256 claimers;\n', '  }\n', '\n', '  struct Info {\n', '    uint256 totalWei;\n', '    uint256 totalCents;\n', '    uint256 realCents;\n', '    uint256 amount;\n', '  }\n', '\n', '  struct SaleConfig {\n', '    uint256 startDate;\n', '    uint256 periodTwo;\n', '    uint256 periodThree;\n', '    uint256 endDate;\n', '    uint256 goal;\n', '    uint256 cap;\n', '    uint256 badgeCost;\n', '    uint256 founderAmount;\n', '    address founderWallet;\n', '  }\n', '\n', '  struct Buyer {\n', '    uint256 centsTotal;\n', '    uint256 weiTotal;\n', '    bool claimed;\n', '  }\n', '\n', '  Info saleInfo;\n', '  SaleConfig saleConfig;\n', '  SaleStatus saleStatus;\n', '\n', '  address config;\n', '  address owner;\n', '  bool locked;\n', '\n', '  uint256 public ethToCents;\n', '\n', '  mapping (address => Buyer) buyers;\n', '  mapping (address => SaleProxy) proxies;\n', '\n', '  /// @notice Calculates the parts per billion 1â\x81„1,000,000,000 of `_a` to `_b`\n', '  /// @param _a The antecedent\n', '  /// @param _c The consequent\n', '  /// @return Part per billion value\n', '  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b);\n', '\n', '\n', '  /// @notice Calculates the share from `_total` based on `_contrib` \n', '  /// @param _contrib The contributed amount in USD\n', '  /// @param _total The total amount raised in USD\n', '  /// @return Total number of shares\n', '  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share);\n', '\n', '  /// @notice Calculates the current USD cents value of `_wei` \n', '  /// @param _wei the amount of wei\n', '  /// @return The USD cents value\n', '  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue);\n', '\n', '  function proxyPurchase(address _user) returns (bool success);\n', '\n', '  /// @notice Send msg.value purchase for _user.  \n', '  /// @param _user The account to be credited\n', '  /// @return Success if purchase was accepted\n', '  function purchase(address _user, uint256 _amount) private returns (bool success);\n', '\n', '  /// @notice Get crowdsale information for `_user`\n', '  /// @param _user The account to be queried\n', '  /// @return `centstotal` the total amount of USD cents contributed\n', '  /// @return `weitotal` the total amount in wei contributed\n', '  /// @return `share` the current token shares earned\n', '  /// @return `badges` the number of proposer badges earned\n', '  /// @return `claimed` is true if the tokens and badges have been claimed\n', '  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n', '\n', '  /// @notice Get the crowdsale information from msg.sender (see userInfo)\n', '  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n', '\n', '  /// @notice get the total amount of wei raised for the crowdsale\n', '  /// @return The amount of wei raised\n', '  function totalWei() public constant returns (uint);\n', '\n', '  /// @notice get the total USD value in cents raised for the crowdsale\n', '  /// @return the amount USD cents\n', '  function totalCents() public constant returns (uint);\n', '\n', '  /// @notice get the current crowdsale information\n', '  /// @return `startsale` The unix timestamp for the start of the crowdsale and the first period modifier\n', '  /// @return `two` The unix timestamp for the start of the second period modifier\n', '  /// @return `three` The unix timestamp for the start of the third period modifier\n', '  /// @return `endsale` The unix timestamp of the end of crowdsale\n', '  /// @return `totalwei` The total amount of wei raised\n', '  /// @return `totalcents` The total number of USD cents raised\n', '  /// @return `amount` The amount of DGD tokens available for the crowdsale\n', '  /// @return `goal` The USD value goal for the crowdsale\n', '  /// @return `famount` Founders endowment\n', '  /// @return `faddress` Founder wallet address\n', '  /*function getSaleInfo() public constant returns (uint256 startsale, uint256 two, uint256 three, uint256 endsale, uint256 totalwei, uint256 totalcents, uint256 amount, uint256 goal, uint256 famount, address faddress);*/\n', '\n', '  function claimFor(address _user) returns (bool success); \n', '\n', '  /// @notice Allows msg.sender to claim the DGD tokens and badges if the goal is reached or refunds the ETH contributed if goal is not reached at the end of the crowdsale\n', '  function claim() returns (bool success);\n', '\n', '  function claimFounders() returns (bool success);\n', '\n', '  /// @notice See if the crowdsale goal has been reached\n', '  function goalReached() public constant returns (bool reached);\n', '\n', '  /// @notice Get the current sale period\n', '  /// @return `saleperiod` 0 = Outside of the crowdsale period, 1 = First reward period, 2 = Second reward period, 3 = Final crowdsale period.\n', '  function getPeriod() public constant returns (uint saleperiod);\n', '\n', '  /// @notice Get the date for the start of the crowdsale\n', '  /// @return `date` The unix timestamp for the start\n', '  function startDate() public constant returns (uint date);\n', '  \n', '  /// @notice Get the date for the second reward period of the crowdsale\n', '  /// @return `date` The unix timestamp for the second period\n', '  function periodTwo() public constant returns (uint date);\n', '\n', '  /// @notice Get the date for the final period of the crowdsale\n', '  /// @return `date` The unix timestamp for the final period\n', '  function periodThree() public constant returns (uint date);\n', '\n', '  /// @notice Get the date for the end of the crowdsale\n', '  /// @return `date` The unix timestamp for the end of the crowdsale\n', '  function endDate() public constant returns (uint date);\n', '\n', '  /// @notice Check if crowdsale has ended\n', '  /// @return `ended` If the crowdsale has ended\n', '  \n', '  function isEnded() public constant returns (bool ended);\n', '\n', '  /// @notice Send raised funds from the crowdsale to the DAO\n', '  /// @return `success` if the send succeeded\n', '  function sendFunds() public returns (bool success);\n', '\n', '  //function regProxy(address _payment, address _payout) returns (bool success);\n', '  function regProxy(address _payout) returns (bool success);\n', '\n', '  function getProxy(address _payout) public returns (address proxy);\n', '  \n', '  function getPayout(address _proxy) public returns (address payout, bool isproxy);\n', '\n', '  function unlock() public returns (bool success);\n', '\n', '  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers);\n', '\n', '  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount);\n', '\n', '  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet);\n', '  \n', '  event Purchase(uint256 indexed _exchange, uint256 indexed _rate, uint256 indexed _cents);\n', '  event Claim(address indexed _user, uint256 indexed _amount, uint256 indexed _badges);\n', '\n', '}\n', '\n', 'contract ProxyPayment {\n', '\n', '  address payout;\n', '  address tokenSales; \n', '  address owner;\n', '\n', '  function ProxyPayment(address _payout, address _tokenSales) {\n', '    payout = _payout;\n', '    tokenSales = _tokenSales;\n', '    owner = _payout;\n', '  }\n', '\n', '  function () {\n', '    if (!TokenSalesInterface(tokenSales).proxyPurchase.value(msg.value).gas(106000)(payout)) throw;\n', '  }\n', '\n', '}\n', '\n', 'contract TokenSales is TokenSalesInterface {\n', '\n', '  modifier ifOwner() {\n', '    if (msg.sender != owner) throw;\n', '    _\n', '  }\n', '\n', '  modifier ifOOrigin() {\n', '    if (tx.origin != owner) throw;\n', '    _\n', '  }\n', '\n', '  mapping (address => address) proxyPayouts;\n', '  uint256 public WEI_PER_ETH = 1000000000000000000;\n', '  uint256 public BILLION = 1000000000;\n', '  uint256 public CENTS = 100;\n', '\n', '\n', '  function TokenSales(address _config) {\n', '    owner = msg.sender;\n', '    config = _config;\n', '    saleStatus.founderClaim = false;\n', '    saleStatus.releasedTokens = 0;\n', '    saleStatus.releasedBadges = 0;\n', '    saleStatus.claimers = 0;\n', '    saleConfig.startDate = ConfigInterface(_config).getConfigUint("sale1:period1");\n', '    saleConfig.periodTwo = ConfigInterface(_config).getConfigUint("sale1:period2");\n', '    saleConfig.periodThree = ConfigInterface(_config).getConfigUint("sale1:period3");\n', '    saleConfig.endDate = ConfigInterface(_config).getConfigUint("sale1:end");\n', '    saleConfig.founderAmount = ConfigInterface(_config).getConfigUint("sale1:famount") * BILLION;\n', '    saleConfig.founderWallet = ConfigInterface(_config).getConfigAddress("sale1:fwallet");\n', '    saleConfig.goal = ConfigInterface(_config).getConfigUint("sale1:goal") * CENTS;\n', '    saleConfig.cap = ConfigInterface(_config).getConfigUint("sale1:cap") * CENTS;\n', '    saleConfig.badgeCost = ConfigInterface(_config).getConfigUint("sale1:badgecost") * CENTS;\n', '    saleInfo.amount = ConfigInterface(_config).getConfigUint("sale1:amount") * BILLION;\n', '    saleInfo.totalWei = 0;\n', '    saleInfo.totalCents = 0;\n', '    saleInfo.realCents;\n', '    saleStatus.founderClaim = false;\n', '    locked = true;\n', '  }\n', '\n', '  function () {\n', '    if (getPeriod() == 0) throw;\n', '    uint256 _amount = msg.value;\n', '    address _sender;\n', '    if (proxies[msg.sender].isProxy == true) {\n', '      _sender = proxies[msg.sender].payout;\n', '    } else {\n', '      _sender = msg.sender;\n', '    }\n', '    if (!purchase(_sender, _amount)) throw;\n', '  }\n', '\n', '  function proxyPurchase(address _user) returns (bool success) {\n', '    return purchase(_user, msg.value);\n', '  }\n', '\n', '  function purchase(address _user, uint256 _amount) private returns (bool success) {\n', '    uint256 _cents = weiToCents(_amount);\n', '    if ((saleInfo.realCents + _cents) > saleConfig.cap) return false;\n', '    uint256 _wei = _amount;\n', '    uint256 _modifier;\n', '    uint _period = getPeriod();\n', '    if ((_period == 0) || (_cents == 0)) {\n', '      return false;\n', '    } else {\n', '      if (_period == 3) _modifier = 100;\n', '      if (_period == 2) _modifier = 115;\n', '      if (_period == 1) _modifier = 130;\n', '      uint256 _creditwei = _amount;\n', '      uint256 _creditcents = (weiToCents(_creditwei) * _modifier * 10000) / 1000000 ;\n', '      buyers[_user].centsTotal += _creditcents;\n', '      buyers[_user].weiTotal += _creditwei; \n', '      saleInfo.totalCents += _creditcents;\n', '      saleInfo.realCents += _cents;\n', '      saleInfo.totalWei += _creditwei;\n', '      Purchase(ethToCents, _modifier, _creditcents); \n', '      return true;\n', '    }\n', '  }\n', '\n', '  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b) {\n', '    b = (BILLION * _a + _c / 2) / _c;\n', '    return b;\n', '  }\n', '\n', '  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share) {\n', '    uint256 _ppb = ppb(_contrib, _total);\n', '    share = ((_ppb * saleInfo.amount) / BILLION);\n', '    return share;\n', '  }\n', '\n', '  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue) {\n', '    centsvalue = ((_wei * 100000 / WEI_PER_ETH) * ethToCents) / 100000;\n', '    return centsvalue;\n', '  }\n', '\n', '  function setEthToCents(uint256 _eth) ifOwner returns (bool success) {\n', '    ethToCents = _eth;\n', '    success = true;\n', '    return success;\n', '  }\n', '\n', '\n', '  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers) {\n', '    return (saleStatus.founderClaim, saleStatus.releasedTokens, saleStatus.releasedBadges, saleStatus.claimers);\n', '  }\n', '\n', '  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount) {\n', '    return (saleInfo.totalWei, saleInfo.totalCents, saleInfo.realCents, saleInfo.amount);\n', '  }\n', '\n', '\n', '  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet) {\n', '    return (saleConfig.startDate, saleConfig.periodTwo, saleConfig.periodThree, saleConfig.endDate, saleConfig.goal, saleConfig.cap, saleConfig.badgeCost, saleConfig.founderAmount, saleConfig.founderWallet);\n', '  }\n', '\n', '  function goalReached() public constant returns (bool reached) {\n', '    reached = (saleInfo.totalCents >= saleConfig.goal);\n', '    return reached;\n', '  }\n', '\n', '  function claim() returns (bool success) {\n', '    return claimFor(msg.sender);\n', '  }\n', '\n', '  function claimFor(address _user) returns (bool success) {\n', '    if ( (now < saleConfig.endDate) || (buyers[_user].claimed == true) ) {\n', '      return true;\n', '    }\n', '  \n', '    if (!goalReached()) {\n', '      if (!address(_user).send(buyers[_user].weiTotal)) throw;\n', '      buyers[_user].claimed = true;\n', '      return true;\n', '    }\n', '\n', '    if (goalReached()) {\n', '      address _tokenc = ConfigInterface(config).getConfigAddress("ledger");\n', '      uint256 _tokens = calcShare(buyers[_user].centsTotal, saleInfo.totalCents); \n', '      uint256 _badges = buyers[_user].centsTotal / saleConfig.badgeCost;\n', '      if ((TokenInterface(_tokenc).mint(msg.sender, _tokens)) && (TokenInterface(_tokenc).mintBadge(_user, _badges))) {\n', '        saleStatus.releasedTokens += _tokens;\n', '        saleStatus.releasedBadges += _badges;\n', '        saleStatus.claimers += 1;\n', '        buyers[_user].claimed = true;\n', '        Claim(_user, _tokens, _badges);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '  }\n', '\n', '  function claimFounders() returns (bool success) {\n', '    if (saleStatus.founderClaim == true) return false;\n', '    if (now < saleConfig.endDate) return false;\n', '    if (!goalReached()) return false;\n', '    address _tokenc = ConfigInterface(config).getConfigAddress("ledger");\n', '    uint256 _tokens = saleConfig.founderAmount;\n', '    uint256 _badges = 4;\n', '    address _faddr = saleConfig.founderWallet;\n', '    if ((TokenInterface(_tokenc).mint(_faddr, _tokens)) && (TokenInterface(_tokenc).mintBadge(_faddr, _badges))) {\n', '      saleStatus.founderClaim = true;\n', '      saleStatus.releasedTokens += _tokens;\n', '      saleStatus.releasedBadges += _badges;\n', '      saleStatus.claimers += 1;\n', '      Claim(_faddr, _tokens, _badges);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function getPeriod() public constant returns (uint saleperiod) {\n', '    if ((now > saleConfig.endDate) || (now < saleConfig.startDate)) {\n', '      saleperiod = 0;\n', '      return saleperiod;\n', '    }\n', '    if (now >= saleConfig.periodThree) {\n', '      saleperiod = 3;\n', '      return saleperiod;\n', '    }\n', '    if (now >= saleConfig.periodTwo) {\n', '      saleperiod = 2;\n', '      return saleperiod;\n', '    }\n', '    if (now < saleConfig.periodTwo) {\n', '      saleperiod = 1;\n', '      return saleperiod;\n', '    }\n', '  }\n', '\n', '  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed) {\n', '    share = calcShare(buyers[_user].centsTotal, saleInfo.totalCents);\n', '    badges = buyers[_user].centsTotal / saleConfig.badgeCost;\n', '    return (buyers[_user].centsTotal, buyers[_user].weiTotal, share, badges, buyers[_user].claimed);\n', '  }\n', '\n', '  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed) {\n', '    return userInfo(msg.sender);\n', '  }\n', '\n', '  function totalWei() public constant returns (uint) {\n', '    return saleInfo.totalWei;\n', '  }\n', '\n', '  function totalCents() public constant returns (uint) {\n', '    return saleInfo.totalCents;\n', '  }\n', '\n', '  function startDate() public constant returns (uint date) {\n', '    return saleConfig.startDate;\n', '  }\n', '  \n', '  function periodTwo() public constant returns (uint date) {\n', '    return saleConfig.periodTwo;\n', '  }\n', '\n', '  function periodThree() public constant returns (uint date) {\n', '    return saleConfig.periodThree;\n', '  }\n', '\n', '  function endDate() public constant returns (uint date) {\n', '    return saleConfig.endDate;\n', '  }\n', '\n', '  function isEnded() public constant returns (bool ended) {\n', '    return (now >= endDate());\n', '  }\n', '  \n', '  function sendFunds() public returns (bool success) {\n', '    if (locked) return false;\n', '    if (!goalReached()) return false;\n', '    if (!isEnded()) return false;\n', '    address _dao = ConfigInterface(config).getConfigAddress("sale1:dao");\n', '    if (_dao == 0x0000000000000000000000000000000000000000) return false;\n', '    return _dao.send(totalWei());\n', '  }\n', '\n', '  function regProxy(address _payout) ifOOrigin returns (bool success) {\n', '    address _proxy = new ProxyPayment(_payout, address(this));\n', '    proxies[_proxy].payout = _payout;\n', '    proxies[_proxy].isProxy = true;\n', '    proxyPayouts[_payout] = _proxy;\n', '    return true;\n', '  }\n', '  \n', '  function getProxy(address _payout) public returns (address proxy) {\n', '    return proxyPayouts[_payout];\n', '  }\n', '\n', '  function getPayout(address _proxy) public returns (address payout, bool isproxy) {\n', '    return (proxies[_proxy].payout, proxies[_proxy].isProxy);\n', '  }\n', '\n', '  function unlock() ifOwner public returns (bool success) {\n', '    locked = false;\n', '    return true;\n', '  }\n', '}']
['/// @title DigixDAO Contract Interfaces\n', '\n', 'contract ConfigInterface {\n', '  address public owner;\n', '  mapping (address => bool) admins;\n', '  mapping (bytes32 => address) addressMap;\n', '  mapping (bytes32 => bool) boolMap;\n', '  mapping (bytes32 => bytes32) bytesMap;\n', '  mapping (bytes32 => uint256) uintMap;\n', '\n', '  /// @notice setConfigAddress sets configuration `_key` to `_val` \n', '  /// @param _key The key name of the configuration.\n', '  /// @param _val The value of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.\n', '  function setConfigAddress(bytes32 _key, address _val) returns (bool success);\n', '\n', '  /// @notice setConfigBool sets configuration `_key` to `_val` \n', '  /// @param _key The key name of the configuration.\n', '  /// @param _val The value of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.\n', '  function setConfigBool(bytes32 _key, bool _val) returns (bool success);\n', '\n', '  /// @notice setConfigBytes sets configuration `_key` to `_val`\n', '  /// @param _key The key name of the configuration.\n', '  /// @param _val The value of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.\n', '  function setConfigBytes(bytes32 _key, bytes32 _val) returns (bool success);\n', '\n', '  /// @notice setConfigUint `_key` to `_val`\n', '  /// @param _key The key name of the configuration.\n', '  /// @param _val The value of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.\n', '  function setConfigUint(bytes32 _key, uint256 _val) returns (bool success);\n', '\n', "  /// @notice getConfigAddress gets configuration `_key`'s value\n", '  /// @param _key The key name of the configuration.\n', '  /// @return The configuration value \n', '  function getConfigAddress(bytes32 _key) returns (address val);\n', '\n', "  /// @notice getConfigBool gets configuration `_key`'s value\n", '  /// @param _key The key name of the configuration.\n', '  /// @return The configuration value \n', '  function getConfigBool(bytes32 _key) returns (bool val);\n', '\n', "  /// @notice getConfigBytes gets configuration `_key`'s value\n", '  /// @param _key The key name of the configuration.\n', '  /// @return The configuration value \n', '  function getConfigBytes(bytes32 _key) returns (bytes32 val);\n', '\n', "  /// @notice getConfigUint gets configuration `_key`'s value\n", '  /// @param _key The key name of the configuration.\n', '  /// @return The configuration value \n', '  function getConfigUint(bytes32 _key) returns (uint256 val);\n', '\n', '  /// @notice addAdmin sets `_admin` as configuration admin\n', '  /// @return Whether the configuration setting was successful or not.  \n', '  function addAdmin(address _admin) returns (bool success);\n', '\n', "  /// @notice removeAdmin removes  `_admin`'s rights\n", '  /// @param _admin The key name of the configuration.\n', '  /// @return Whether the configuration setting was successful or not.  \n', '  function removeAdmin(address _admin) returns (bool success);\n', '\n', '}\n', '\n', 'contract TokenInterface {\n', '\n', '  struct User {\n', '    bool locked;\n', '    uint256 balance;\n', '    uint256 badges;\n', '    mapping (address => uint256) allowed;\n', '  }\n', '\n', '  mapping (address => User) users;\n', '  mapping (address => uint256) balances;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '  mapping (address => bool) seller;\n', '\n', '  address config;\n', '  address owner;\n', '  address dao;\n', '  bool locked;\n', '\n', '  /// @return total amount of tokens\n', '  uint256 public totalSupply;\n', '  uint256 public totalBadges;\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '  /// @param _owner The address from which the badge count will be retrieved\n', '  /// @return The badges count\n', '  function badgesOf(address _owner) constant returns (uint256 badge);\n', '\n', '  /// @notice send `_value` tokens to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of tokens to be transfered\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice send `_value` badges to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of tokens to be transfered\n', '  /// @return Whether the transfer was successful or not\n', '  function sendBadge(address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of tokens to be transfered\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of tokens to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '  /// @notice mint `_amount` of tokens to `_owner`\n', '  /// @param _owner The address of the account receiving the tokens\n', '  /// @param _amount The amount of tokens to mint\n', '  /// @return Whether or not minting was successful\n', '  function mint(address _owner, uint256 _amount) returns (bool success);\n', '\n', '  /// @notice mintBadge Mint `_amount` badges to `_owner`\n', '  /// @param _owner The address of the account receiving the tokens\n', '  /// @param _amount The amount of tokens to mint\n', '  /// @return Whether or not minting was successful\n', '  function mintBadge(address _owner, uint256 _amount) returns (bool success);\n', '\n', '  function registerDao(address _dao) returns (bool success);\n', '\n', '  function registerSeller(address _tokensales) returns (bool success);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event SendBadge(address indexed _from, address indexed _to, uint256 _amount);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract TokenSalesInterface {\n', '\n', '  struct SaleProxy {\n', '    address payout;\n', '    bool isProxy;\n', '  }\n', '\n', '  struct SaleStatus {\n', '    bool founderClaim;\n', '    uint256 releasedTokens;\n', '    uint256 releasedBadges;\n', '    uint256 claimers;\n', '  }\n', '\n', '  struct Info {\n', '    uint256 totalWei;\n', '    uint256 totalCents;\n', '    uint256 realCents;\n', '    uint256 amount;\n', '  }\n', '\n', '  struct SaleConfig {\n', '    uint256 startDate;\n', '    uint256 periodTwo;\n', '    uint256 periodThree;\n', '    uint256 endDate;\n', '    uint256 goal;\n', '    uint256 cap;\n', '    uint256 badgeCost;\n', '    uint256 founderAmount;\n', '    address founderWallet;\n', '  }\n', '\n', '  struct Buyer {\n', '    uint256 centsTotal;\n', '    uint256 weiTotal;\n', '    bool claimed;\n', '  }\n', '\n', '  Info saleInfo;\n', '  SaleConfig saleConfig;\n', '  SaleStatus saleStatus;\n', '\n', '  address config;\n', '  address owner;\n', '  bool locked;\n', '\n', '  uint256 public ethToCents;\n', '\n', '  mapping (address => Buyer) buyers;\n', '  mapping (address => SaleProxy) proxies;\n', '\n', '  /// @notice Calculates the parts per billion 1â\x81„1,000,000,000 of `_a` to `_b`\n', '  /// @param _a The antecedent\n', '  /// @param _c The consequent\n', '  /// @return Part per billion value\n', '  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b);\n', '\n', '\n', '  /// @notice Calculates the share from `_total` based on `_contrib` \n', '  /// @param _contrib The contributed amount in USD\n', '  /// @param _total The total amount raised in USD\n', '  /// @return Total number of shares\n', '  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share);\n', '\n', '  /// @notice Calculates the current USD cents value of `_wei` \n', '  /// @param _wei the amount of wei\n', '  /// @return The USD cents value\n', '  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue);\n', '\n', '  function proxyPurchase(address _user) returns (bool success);\n', '\n', '  /// @notice Send msg.value purchase for _user.  \n', '  /// @param _user The account to be credited\n', '  /// @return Success if purchase was accepted\n', '  function purchase(address _user, uint256 _amount) private returns (bool success);\n', '\n', '  /// @notice Get crowdsale information for `_user`\n', '  /// @param _user The account to be queried\n', '  /// @return `centstotal` the total amount of USD cents contributed\n', '  /// @return `weitotal` the total amount in wei contributed\n', '  /// @return `share` the current token shares earned\n', '  /// @return `badges` the number of proposer badges earned\n', '  /// @return `claimed` is true if the tokens and badges have been claimed\n', '  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n', '\n', '  /// @notice Get the crowdsale information from msg.sender (see userInfo)\n', '  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n', '\n', '  /// @notice get the total amount of wei raised for the crowdsale\n', '  /// @return The amount of wei raised\n', '  function totalWei() public constant returns (uint);\n', '\n', '  /// @notice get the total USD value in cents raised for the crowdsale\n', '  /// @return the amount USD cents\n', '  function totalCents() public constant returns (uint);\n', '\n', '  /// @notice get the current crowdsale information\n', '  /// @return `startsale` The unix timestamp for the start of the crowdsale and the first period modifier\n', '  /// @return `two` The unix timestamp for the start of the second period modifier\n', '  /// @return `three` The unix timestamp for the start of the third period modifier\n', '  /// @return `endsale` The unix timestamp of the end of crowdsale\n', '  /// @return `totalwei` The total amount of wei raised\n', '  /// @return `totalcents` The total number of USD cents raised\n', '  /// @return `amount` The amount of DGD tokens available for the crowdsale\n', '  /// @return `goal` The USD value goal for the crowdsale\n', '  /// @return `famount` Founders endowment\n', '  /// @return `faddress` Founder wallet address\n', '  /*function getSaleInfo() public constant returns (uint256 startsale, uint256 two, uint256 three, uint256 endsale, uint256 totalwei, uint256 totalcents, uint256 amount, uint256 goal, uint256 famount, address faddress);*/\n', '\n', '  function claimFor(address _user) returns (bool success); \n', '\n', '  /// @notice Allows msg.sender to claim the DGD tokens and badges if the goal is reached or refunds the ETH contributed if goal is not reached at the end of the crowdsale\n', '  function claim() returns (bool success);\n', '\n', '  function claimFounders() returns (bool success);\n', '\n', '  /// @notice See if the crowdsale goal has been reached\n', '  function goalReached() public constant returns (bool reached);\n', '\n', '  /// @notice Get the current sale period\n', '  /// @return `saleperiod` 0 = Outside of the crowdsale period, 1 = First reward period, 2 = Second reward period, 3 = Final crowdsale period.\n', '  function getPeriod() public constant returns (uint saleperiod);\n', '\n', '  /// @notice Get the date for the start of the crowdsale\n', '  /// @return `date` The unix timestamp for the start\n', '  function startDate() public constant returns (uint date);\n', '  \n', '  /// @notice Get the date for the second reward period of the crowdsale\n', '  /// @return `date` The unix timestamp for the second period\n', '  function periodTwo() public constant returns (uint date);\n', '\n', '  /// @notice Get the date for the final period of the crowdsale\n', '  /// @return `date` The unix timestamp for the final period\n', '  function periodThree() public constant returns (uint date);\n', '\n', '  /// @notice Get the date for the end of the crowdsale\n', '  /// @return `date` The unix timestamp for the end of the crowdsale\n', '  function endDate() public constant returns (uint date);\n', '\n', '  /// @notice Check if crowdsale has ended\n', '  /// @return `ended` If the crowdsale has ended\n', '  \n', '  function isEnded() public constant returns (bool ended);\n', '\n', '  /// @notice Send raised funds from the crowdsale to the DAO\n', '  /// @return `success` if the send succeeded\n', '  function sendFunds() public returns (bool success);\n', '\n', '  //function regProxy(address _payment, address _payout) returns (bool success);\n', '  function regProxy(address _payout) returns (bool success);\n', '\n', '  function getProxy(address _payout) public returns (address proxy);\n', '  \n', '  function getPayout(address _proxy) public returns (address payout, bool isproxy);\n', '\n', '  function unlock() public returns (bool success);\n', '\n', '  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers);\n', '\n', '  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount);\n', '\n', '  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet);\n', '  \n', '  event Purchase(uint256 indexed _exchange, uint256 indexed _rate, uint256 indexed _cents);\n', '  event Claim(address indexed _user, uint256 indexed _amount, uint256 indexed _badges);\n', '\n', '}\n', '\n', 'contract ProxyPayment {\n', '\n', '  address payout;\n', '  address tokenSales; \n', '  address owner;\n', '\n', '  function ProxyPayment(address _payout, address _tokenSales) {\n', '    payout = _payout;\n', '    tokenSales = _tokenSales;\n', '    owner = _payout;\n', '  }\n', '\n', '  function () {\n', '    if (!TokenSalesInterface(tokenSales).proxyPurchase.value(msg.value).gas(106000)(payout)) throw;\n', '  }\n', '\n', '}\n', '\n', 'contract TokenSales is TokenSalesInterface {\n', '\n', '  modifier ifOwner() {\n', '    if (msg.sender != owner) throw;\n', '    _\n', '  }\n', '\n', '  modifier ifOOrigin() {\n', '    if (tx.origin != owner) throw;\n', '    _\n', '  }\n', '\n', '  mapping (address => address) proxyPayouts;\n', '  uint256 public WEI_PER_ETH = 1000000000000000000;\n', '  uint256 public BILLION = 1000000000;\n', '  uint256 public CENTS = 100;\n', '\n', '\n', '  function TokenSales(address _config) {\n', '    owner = msg.sender;\n', '    config = _config;\n', '    saleStatus.founderClaim = false;\n', '    saleStatus.releasedTokens = 0;\n', '    saleStatus.releasedBadges = 0;\n', '    saleStatus.claimers = 0;\n', '    saleConfig.startDate = ConfigInterface(_config).getConfigUint("sale1:period1");\n', '    saleConfig.periodTwo = ConfigInterface(_config).getConfigUint("sale1:period2");\n', '    saleConfig.periodThree = ConfigInterface(_config).getConfigUint("sale1:period3");\n', '    saleConfig.endDate = ConfigInterface(_config).getConfigUint("sale1:end");\n', '    saleConfig.founderAmount = ConfigInterface(_config).getConfigUint("sale1:famount") * BILLION;\n', '    saleConfig.founderWallet = ConfigInterface(_config).getConfigAddress("sale1:fwallet");\n', '    saleConfig.goal = ConfigInterface(_config).getConfigUint("sale1:goal") * CENTS;\n', '    saleConfig.cap = ConfigInterface(_config).getConfigUint("sale1:cap") * CENTS;\n', '    saleConfig.badgeCost = ConfigInterface(_config).getConfigUint("sale1:badgecost") * CENTS;\n', '    saleInfo.amount = ConfigInterface(_config).getConfigUint("sale1:amount") * BILLION;\n', '    saleInfo.totalWei = 0;\n', '    saleInfo.totalCents = 0;\n', '    saleInfo.realCents;\n', '    saleStatus.founderClaim = false;\n', '    locked = true;\n', '  }\n', '\n', '  function () {\n', '    if (getPeriod() == 0) throw;\n', '    uint256 _amount = msg.value;\n', '    address _sender;\n', '    if (proxies[msg.sender].isProxy == true) {\n', '      _sender = proxies[msg.sender].payout;\n', '    } else {\n', '      _sender = msg.sender;\n', '    }\n', '    if (!purchase(_sender, _amount)) throw;\n', '  }\n', '\n', '  function proxyPurchase(address _user) returns (bool success) {\n', '    return purchase(_user, msg.value);\n', '  }\n', '\n', '  function purchase(address _user, uint256 _amount) private returns (bool success) {\n', '    uint256 _cents = weiToCents(_amount);\n', '    if ((saleInfo.realCents + _cents) > saleConfig.cap) return false;\n', '    uint256 _wei = _amount;\n', '    uint256 _modifier;\n', '    uint _period = getPeriod();\n', '    if ((_period == 0) || (_cents == 0)) {\n', '      return false;\n', '    } else {\n', '      if (_period == 3) _modifier = 100;\n', '      if (_period == 2) _modifier = 115;\n', '      if (_period == 1) _modifier = 130;\n', '      uint256 _creditwei = _amount;\n', '      uint256 _creditcents = (weiToCents(_creditwei) * _modifier * 10000) / 1000000 ;\n', '      buyers[_user].centsTotal += _creditcents;\n', '      buyers[_user].weiTotal += _creditwei; \n', '      saleInfo.totalCents += _creditcents;\n', '      saleInfo.realCents += _cents;\n', '      saleInfo.totalWei += _creditwei;\n', '      Purchase(ethToCents, _modifier, _creditcents); \n', '      return true;\n', '    }\n', '  }\n', '\n', '  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b) {\n', '    b = (BILLION * _a + _c / 2) / _c;\n', '    return b;\n', '  }\n', '\n', '  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share) {\n', '    uint256 _ppb = ppb(_contrib, _total);\n', '    share = ((_ppb * saleInfo.amount) / BILLION);\n', '    return share;\n', '  }\n', '\n', '  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue) {\n', '    centsvalue = ((_wei * 100000 / WEI_PER_ETH) * ethToCents) / 100000;\n', '    return centsvalue;\n', '  }\n', '\n', '  function setEthToCents(uint256 _eth) ifOwner returns (bool success) {\n', '    ethToCents = _eth;\n', '    success = true;\n', '    return success;\n', '  }\n', '\n', '\n', '  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers) {\n', '    return (saleStatus.founderClaim, saleStatus.releasedTokens, saleStatus.releasedBadges, saleStatus.claimers);\n', '  }\n', '\n', '  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount) {\n', '    return (saleInfo.totalWei, saleInfo.totalCents, saleInfo.realCents, saleInfo.amount);\n', '  }\n', '\n', '\n', '  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet) {\n', '    return (saleConfig.startDate, saleConfig.periodTwo, saleConfig.periodThree, saleConfig.endDate, saleConfig.goal, saleConfig.cap, saleConfig.badgeCost, saleConfig.founderAmount, saleConfig.founderWallet);\n', '  }\n', '\n', '  function goalReached() public constant returns (bool reached) {\n', '    reached = (saleInfo.totalCents >= saleConfig.goal);\n', '    return reached;\n', '  }\n', '\n', '  function claim() returns (bool success) {\n', '    return claimFor(msg.sender);\n', '  }\n', '\n', '  function claimFor(address _user) returns (bool success) {\n', '    if ( (now < saleConfig.endDate) || (buyers[_user].claimed == true) ) {\n', '      return true;\n', '    }\n', '  \n', '    if (!goalReached()) {\n', '      if (!address(_user).send(buyers[_user].weiTotal)) throw;\n', '      buyers[_user].claimed = true;\n', '      return true;\n', '    }\n', '\n', '    if (goalReached()) {\n', '      address _tokenc = ConfigInterface(config).getConfigAddress("ledger");\n', '      uint256 _tokens = calcShare(buyers[_user].centsTotal, saleInfo.totalCents); \n', '      uint256 _badges = buyers[_user].centsTotal / saleConfig.badgeCost;\n', '      if ((TokenInterface(_tokenc).mint(msg.sender, _tokens)) && (TokenInterface(_tokenc).mintBadge(_user, _badges))) {\n', '        saleStatus.releasedTokens += _tokens;\n', '        saleStatus.releasedBadges += _badges;\n', '        saleStatus.claimers += 1;\n', '        buyers[_user].claimed = true;\n', '        Claim(_user, _tokens, _badges);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '  }\n', '\n', '  function claimFounders() returns (bool success) {\n', '    if (saleStatus.founderClaim == true) return false;\n', '    if (now < saleConfig.endDate) return false;\n', '    if (!goalReached()) return false;\n', '    address _tokenc = ConfigInterface(config).getConfigAddress("ledger");\n', '    uint256 _tokens = saleConfig.founderAmount;\n', '    uint256 _badges = 4;\n', '    address _faddr = saleConfig.founderWallet;\n', '    if ((TokenInterface(_tokenc).mint(_faddr, _tokens)) && (TokenInterface(_tokenc).mintBadge(_faddr, _badges))) {\n', '      saleStatus.founderClaim = true;\n', '      saleStatus.releasedTokens += _tokens;\n', '      saleStatus.releasedBadges += _badges;\n', '      saleStatus.claimers += 1;\n', '      Claim(_faddr, _tokens, _badges);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function getPeriod() public constant returns (uint saleperiod) {\n', '    if ((now > saleConfig.endDate) || (now < saleConfig.startDate)) {\n', '      saleperiod = 0;\n', '      return saleperiod;\n', '    }\n', '    if (now >= saleConfig.periodThree) {\n', '      saleperiod = 3;\n', '      return saleperiod;\n', '    }\n', '    if (now >= saleConfig.periodTwo) {\n', '      saleperiod = 2;\n', '      return saleperiod;\n', '    }\n', '    if (now < saleConfig.periodTwo) {\n', '      saleperiod = 1;\n', '      return saleperiod;\n', '    }\n', '  }\n', '\n', '  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed) {\n', '    share = calcShare(buyers[_user].centsTotal, saleInfo.totalCents);\n', '    badges = buyers[_user].centsTotal / saleConfig.badgeCost;\n', '    return (buyers[_user].centsTotal, buyers[_user].weiTotal, share, badges, buyers[_user].claimed);\n', '  }\n', '\n', '  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed) {\n', '    return userInfo(msg.sender);\n', '  }\n', '\n', '  function totalWei() public constant returns (uint) {\n', '    return saleInfo.totalWei;\n', '  }\n', '\n', '  function totalCents() public constant returns (uint) {\n', '    return saleInfo.totalCents;\n', '  }\n', '\n', '  function startDate() public constant returns (uint date) {\n', '    return saleConfig.startDate;\n', '  }\n', '  \n', '  function periodTwo() public constant returns (uint date) {\n', '    return saleConfig.periodTwo;\n', '  }\n', '\n', '  function periodThree() public constant returns (uint date) {\n', '    return saleConfig.periodThree;\n', '  }\n', '\n', '  function endDate() public constant returns (uint date) {\n', '    return saleConfig.endDate;\n', '  }\n', '\n', '  function isEnded() public constant returns (bool ended) {\n', '    return (now >= endDate());\n', '  }\n', '  \n', '  function sendFunds() public returns (bool success) {\n', '    if (locked) return false;\n', '    if (!goalReached()) return false;\n', '    if (!isEnded()) return false;\n', '    address _dao = ConfigInterface(config).getConfigAddress("sale1:dao");\n', '    if (_dao == 0x0000000000000000000000000000000000000000) return false;\n', '    return _dao.send(totalWei());\n', '  }\n', '\n', '  function regProxy(address _payout) ifOOrigin returns (bool success) {\n', '    address _proxy = new ProxyPayment(_payout, address(this));\n', '    proxies[_proxy].payout = _payout;\n', '    proxies[_proxy].isProxy = true;\n', '    proxyPayouts[_payout] = _proxy;\n', '    return true;\n', '  }\n', '  \n', '  function getProxy(address _payout) public returns (address proxy) {\n', '    return proxyPayouts[_payout];\n', '  }\n', '\n', '  function getPayout(address _proxy) public returns (address payout, bool isproxy) {\n', '    return (proxies[_proxy].payout, proxies[_proxy].isProxy);\n', '  }\n', '\n', '  function unlock() ifOwner public returns (bool success) {\n', '    locked = false;\n', '    return true;\n', '  }\n', '}']
