['pragma solidity ^0.4.2;\n', '\n', 'contract OwnedI {\n', '    event LogOwnerChanged(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function getOwner()\n', '        constant\n', '        returns (address);\n', '\n', '    function setOwner(address newOwner)\n', '        returns (bool success); \n', '}\n', '\n', 'contract Owned is OwnedI {\n', '    /**\n', '     * @dev Made private to protect against child contract setting it to 0 by mistake.\n', '     */\n', '    address private owner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier fromOwner {\n', '        if (msg.sender != owner) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    function getOwner()\n', '        constant\n', '        returns (address) {\n', '        return owner;\n', '    }\n', '\n', '    function setOwner(address newOwner)\n', '        fromOwner \n', '        returns (bool success) {\n', '        if (newOwner == 0) {\n', '            throw;\n', '        }\n', '        if (owner != newOwner) {\n', '            LogOwnerChanged(owner, newOwner);\n', '            owner = newOwner;\n', '        }\n', '        success = true;\n', '    }\n', '}\n', '\n', 'contract PullPaymentCapable {\n', '    uint256 private totalBalance;\n', '    mapping(address => uint256) private payments;\n', '\n', '    event LogPaymentReceived(address indexed dest, uint256 amount);\n', '\n', '    function PullPaymentCapable() {\n', '        if (0 < this.balance) {\n', '            asyncSend(msg.sender, this.balance);\n', '        }\n', '    }\n', '\n', '    // store sent amount as credit to be pulled, called by payer\n', '    function asyncSend(address dest, uint256 amount) internal {\n', '        if (amount > 0) {\n', '            totalBalance += amount;\n', '            payments[dest] += amount;\n', '            LogPaymentReceived(dest, amount);\n', '        }\n', '    }\n', '\n', '    function getTotalBalance()\n', '        constant\n', '        returns (uint256) {\n', '        return totalBalance;\n', '    }\n', '\n', '    function getPaymentOf(address beneficiary) \n', '        constant\n', '        returns (uint256) {\n', '        return payments[beneficiary];\n', '    }\n', '\n', '    // withdraw accumulated balance, called by payee\n', '    function withdrawPayments()\n', '        external \n', '        returns (bool success) {\n', '        uint256 payment = payments[msg.sender];\n', '        payments[msg.sender] = 0;\n', '        totalBalance -= payment;\n', '        if (!msg.sender.call.value(payment)()) {\n', '            throw;\n', '        }\n', '        success = true;\n', '    }\n', '\n', '    function fixBalance()\n', '        returns (bool success);\n', '\n', '    function fixBalanceInternal(address dest)\n', '        internal\n', '        returns (bool success) {\n', '        if (totalBalance < this.balance) {\n', '            uint256 amount = this.balance - totalBalance;\n', '            payments[dest] += amount;\n', '            LogPaymentReceived(dest, amount);\n', '        }\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract WithBeneficiary is Owned {\n', '    /**\n', '     * @notice Address that is forwarded all value.\n', '     * @dev Made private to protect against child contract setting it to 0 by mistake.\n', '     */\n', '    address private beneficiary;\n', '    \n', '    event LogBeneficiarySet(address indexed previousBeneficiary, address indexed newBeneficiary);\n', '\n', '    function WithBeneficiary(address _beneficiary) payable {\n', '        if (_beneficiary == 0) {\n', '            throw;\n', '        }\n', '        beneficiary = _beneficiary;\n', '        if (msg.value > 0) {\n', '            asyncSend(beneficiary, msg.value);\n', '        }\n', '    }\n', '\n', '    function asyncSend(address dest, uint amount) internal;\n', '\n', '    function getBeneficiary()\n', '        constant\n', '        returns (address) {\n', '        return beneficiary;\n', '    }\n', '\n', '    function setBeneficiary(address newBeneficiary)\n', '        fromOwner \n', '        returns (bool success) {\n', '        if (newBeneficiary == 0) {\n', '            throw;\n', '        }\n', '        if (beneficiary != newBeneficiary) {\n', '            LogBeneficiarySet(beneficiary, newBeneficiary);\n', '            beneficiary = newBeneficiary;\n', '        }\n', '        success = true;\n', '    }\n', '\n', '    function () payable {\n', '        asyncSend(beneficiary, msg.value);\n', '    }\n', '}\n', '\n', 'contract CertificationCentreI {\n', '    event LogCertificationDbRegistered(address indexed db);\n', '\n', '    event LogCertificationDbUnRegistered(address indexed db);\n', '\n', '    function getCertificationDbCount()\n', '        constant\n', '        returns (uint);\n', '\n', '    function getCertificationDbStatus(address db)\n', '        constant\n', '        returns (bool valid, uint256 index);\n', '\n', '    function getCertificationDbAtIndex(uint256 index)\n', '        constant\n', '        returns (address db);\n', '\n', '    function registerCertificationDb(address db)\n', '        returns (bool success);\n', '\n', '    function unRegisterCertificationDb(address db)\n', '        returns (bool success);\n', '}\n', '\n', 'contract CertificationCentre is CertificationCentreI, WithBeneficiary, PullPaymentCapable {\n', '    struct CertificationDbStruct {\n', '        bool valid;\n', '        uint256 index;\n', '    }\n', '\n', '    mapping (address => CertificationDbStruct) private certificationDbStatuses;\n', '    address[] private certificationDbs;\n', '\n', '    function CertificationCentre(address beneficiary)\n', '        WithBeneficiary(beneficiary) {\n', '        if (msg.value > 0) {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    function getCertificationDbCount()\n', '        constant\n', '        returns (uint256) {\n', '        return certificationDbs.length;\n', '    }\n', '\n', '    function getCertificationDbStatus(address db)\n', '        constant\n', '        returns (bool valid, uint256 index) {\n', '        CertificationDbStruct status = certificationDbStatuses[db];\n', '        return (status.valid, status.index);\n', '    }\n', '\n', '    function getCertificationDbAtIndex(uint256 index)\n', '        constant\n', '        returns (address db) {\n', '        return certificationDbs[index];\n', '    }\n', '\n', '    function registerCertificationDb(address db) \n', '        fromOwner\n', '        returns (bool success) {\n', '        if (db == 0) {\n', '            throw;\n', '        }\n', '        if (!certificationDbStatuses[db].valid) {\n', '            certificationDbStatuses[db].valid = true;\n', '            certificationDbStatuses[db].index = certificationDbs.length;\n', '            certificationDbs.push(db);\n', '        }\n', '        LogCertificationDbRegistered(db);\n', '        success = true;\n', '    }\n', '\n', '    function unRegisterCertificationDb(address db)\n', '        fromOwner\n', '        returns (bool success) {\n', '        if (certificationDbStatuses[db].valid) {\n', '            uint256 index = certificationDbStatuses[db].index;\n', '            certificationDbs[index] = certificationDbs[certificationDbs.length - 1];\n', '            certificationDbStatuses[certificationDbs[index]].index = index;\n', '            delete certificationDbStatuses[db];\n', '            certificationDbs.length--;\n', '        }\n', '        LogCertificationDbUnRegistered(db);\n', '        success = true;\n', '    }\n', '\n', '    function fixBalance()\n', '        returns (bool success) {\n', '        return fixBalanceInternal(getBeneficiary());\n', '    }\n', '}']