['pragma solidity ^0.4.17;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'interface ManagedToken{\n', '    function setLock(bool _newLockState) public returns (bool success);\n', '    function mint(address _for, uint256 _amount) public returns (bool success);\n', '    function demint(address _for, uint256 _amount) public returns (bool success);\n', '    function decimals() constant public returns (uint8 decDigits);\n', '    function totalSupply() constant public returns (uint256 supply);\n', '    function balanceOf(address _owner) constant public returns (uint256 balance);\n', '}\n', '  \n', 'contract HardcodedCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    //global definisions\n', '\n', '    enum ICOStateEnum {NotStarted, Started, Refunded, Successful}\n', '\n', '\n', '    address public owner = msg.sender;\n', '    ManagedToken public managedTokenLedger;\n', '\n', '    string public name = "MDBlockchainPreICO";\n', '    string public symbol = "MDB";\n', '\n', '    bool public unlocked = false;\n', '    bool public halted = false;\n', '\n', '    uint256 public totalSupply = 0;\n', '    \n', '    uint256 public minTokensToBuy = 1000;\n', '    \n', '    uint256 public preICOcontributors = 0;\n', '    uint256 public ICOcontributors = 0;\n', '\n', '    uint256 public preICOstart;\n', '    uint256 public preICOend;\n', '    uint256 public preICOgoal;\n', '    uint256 public preICOcollected = 0;\n', '    uint256 public preICOcap = 0 ether;\n', '    uint256 public preICOtokensSold = 0;\n', '    ICOStateEnum public preICOstate = ICOStateEnum.NotStarted;\n', '    \n', '    uint8 public decimals = 18;\n', '    uint256 public DECIMAL_MULTIPLIER = 10**uint256(decimals);\n', '\n', '    uint256[3] public preICOrates = [uint(1 ether).div(1600), uint(1 ether).div(1400), uint(1 ether).div(1200)];\n', '    uint256[3] public preICOcoinsLeft = [7000000*DECIMAL_MULTIPLIER, 14000000*DECIMAL_MULTIPLIER, 21000000*DECIMAL_MULTIPLIER];\n', '    uint256 public totalPreICOavailible = 42000000*DECIMAL_MULTIPLIER;\n', '\n', '    mapping(address => uint256) public weiForRefundPreICO;\n', '\n', '    mapping(address => uint256) public weiToRecoverPreICO;\n', '\n', '    mapping(address => uint256) public balancesForPreICO;\n', '\n', '    event Purchased(address indexed _from, uint256 _value);\n', '\n', '    function advanceState() public returns (bool success) {\n', '        transitionState();\n', '        return true;\n', '    }\n', '\n', '    function transitionState() internal {\n', '        if (now >= preICOstart) {\n', '            if (preICOstate == ICOStateEnum.NotStarted) {\n', '                preICOstate = ICOStateEnum.Started;\n', '            }\n', '            if (preICOcap > 0 && preICOcollected >= preICOcap) {\n', '                preICOstate = ICOStateEnum.Successful;\n', '            }\n', '            if (preICOtokensSold == totalPreICOavailible) {\n', '                preICOstate = ICOStateEnum.Successful;\n', '            }\n', '        } if (now >= preICOend) {\n', '            if (preICOstate == ICOStateEnum.Started) {\n', '                if (preICOcollected >= preICOgoal) {\n', '                    preICOstate = ICOStateEnum.Successful;\n', '                } else {\n', '                    preICOstate = ICOStateEnum.Refunded;\n', '                }\n', '            }\n', '        } \n', '    }\n', '\n', '    modifier stateTransition() {\n', '        transitionState();\n', '        _;\n', '        transitionState();\n', '    }\n', '\n', '    modifier requirePreICOState(ICOStateEnum _state) {\n', '        require(preICOstate == _state);\n', '        _;\n', '    }\n', '\n', '    modifier notHalted() {\n', '        require(!halted);\n', '        _;\n', '    }\n', '\n', '    // Ownership\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));      \n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant public returns (uint256 balance) {\n', '        return managedTokenLedger.balanceOf(_owner);\n', '    }\n', '\n', '\n', '    function HardcodedCrowdsale (uint _preICOstart, uint _preICOend, uint _preICOgoal, uint _preICOcap, address _newLedgerAddress) public {\n', '        require(_preICOstart > now);\n', '        require(_preICOend > _preICOstart);\n', '        require(_preICOgoal > 0);\n', '        require(_newLedgerAddress != address(0));\n', '        preICOstart = _preICOstart;\n', '        preICOend = _preICOend;\n', '        preICOgoal = _preICOgoal;\n', '        preICOcap = _preICOcap;\n', '        managedTokenLedger = ManagedToken(_newLedgerAddress);\n', '        decimals = managedTokenLedger.decimals();\n', '        DECIMAL_MULTIPLIER = 10**uint256(decimals);\n', '    }\n', '\n', '    function setNameAndTicker(string _name, string _symbol) onlyOwner public returns (bool success) {\n', '        require(bytes(_name).length > 1);\n', '        require(bytes(_symbol).length > 1);\n', '        name = _name;\n', '        symbol = _symbol;\n', '        return true;\n', '    }\n', '\n', '    function setLedger (address _newLedgerAddress) onlyOwner public returns (bool success) {\n', '        require(_newLedgerAddress != address(0));\n', '        managedTokenLedger = ManagedToken(_newLedgerAddress);\n', '        decimals = managedTokenLedger.decimals();\n', '        DECIMAL_MULTIPLIER = 10**uint256(decimals);\n', '        return true;\n', '    }\n', '\n', '    function () payable stateTransition notHalted public {\n', '        if (preICOstate == ICOStateEnum.Started) {\n', '            assert(preICOBuy());\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function transferPreICOCollected() onlyOwner stateTransition public returns (bool success) {\n', '        require(preICOstate == ICOStateEnum.Successful);\n', '        owner.transfer(preICOcollected);\n', '        return true;\n', '    }\n', '\n', '    function setHalt(bool _halt) onlyOwner public returns (bool success) {\n', '        halted = _halt;\n', '        return true;\n', '    }\n', '\n', '    function calculateAmountBoughtPreICO(uint256 _weisSentScaled) internal returns (uint256 _tokensToBuyScaled, uint256 _weisLeftScaled) {\n', '        uint256 value = _weisSentScaled;\n', '        uint256 totalPurchased = 0;\n', '        for (uint8 i = 0; i < preICOrates.length; i++) {\n', '            if (preICOcoinsLeft[i] == 0) {\n', '                continue;\n', '            }\n', '            uint256 rate = preICOrates[i];\n', '            uint256 forThisRate = value.div(rate);\n', '            if (forThisRate == 0) {\n', '                break;\n', '            }\n', '            if (forThisRate > preICOcoinsLeft[i]) {\n', '                forThisRate = preICOcoinsLeft[i];\n', '                preICOcoinsLeft[i] = 0;\n', '            } else {\n', '                preICOcoinsLeft[i] = preICOcoinsLeft[i].sub(forThisRate);\n', '            }\n', '            uint256 consumed = forThisRate.mul(rate);\n', '            value = value.sub(consumed);\n', '            totalPurchased = totalPurchased.add(forThisRate);\n', '        }\n', '        return (totalPurchased, value);\n', '    }\n', '\n', '    function preICOBuy() internal notHalted returns (bool success) {\n', '        uint256 weisSentScaled = msg.value.mul(DECIMAL_MULTIPLIER);\n', '        address _for = msg.sender;\n', '        var (tokensBought, fundsLeftScaled) = calculateAmountBoughtPreICO(weisSentScaled);\n', '        if (tokensBought < minTokensToBuy.mul(DECIMAL_MULTIPLIER)) {\n', '            revert();\n', '        }\n', '        uint256 fundsLeft = fundsLeftScaled.div(DECIMAL_MULTIPLIER);\n', '        uint256 totalSpent = msg.value.sub(fundsLeft);\n', '        if (balanceOf(_for) == 0) {\n', '            preICOcontributors = preICOcontributors + 1;\n', '        }\n', '        managedTokenLedger.mint(_for, tokensBought);\n', '        balancesForPreICO[_for] = balancesForPreICO[_for].add(tokensBought);\n', '        weiForRefundPreICO[_for] = weiForRefundPreICO[_for].add(totalSpent);\n', '        weiToRecoverPreICO[_for] = weiToRecoverPreICO[_for].add(fundsLeft);\n', '        Purchased(_for, tokensBought);\n', '        preICOcollected = preICOcollected.add(totalSpent);\n', '        totalSupply = totalSupply.add(tokensBought);\n', '        preICOtokensSold = preICOtokensSold.add(tokensBought);\n', '        return true;\n', '    }\n', '\n', '    function recoverLeftoversPreICO() stateTransition notHalted public returns (bool success) {\n', '        require(preICOstate != ICOStateEnum.NotStarted);\n', '        uint256 value = weiToRecoverPreICO[msg.sender];\n', '        delete weiToRecoverPreICO[msg.sender];\n', '        msg.sender.transfer(value);\n', '        return true;\n', '    }\n', '\n', '    function refundPreICO() stateTransition requirePreICOState(ICOStateEnum.Refunded) notHalted \n', '        public returns (bool success) {\n', '            uint256 value = weiForRefundPreICO[msg.sender];\n', '            delete weiForRefundPreICO[msg.sender];\n', '            uint256 tokenValue = balancesForPreICO[msg.sender];\n', '            delete balancesForPreICO[msg.sender];\n', '            managedTokenLedger.demint(msg.sender, tokenValue);\n', '            msg.sender.transfer(value);\n', '            return true;\n', '    }\n', '\n', '    function cleanup() onlyOwner public {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.17;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'interface ManagedToken{\n', '    function setLock(bool _newLockState) public returns (bool success);\n', '    function mint(address _for, uint256 _amount) public returns (bool success);\n', '    function demint(address _for, uint256 _amount) public returns (bool success);\n', '    function decimals() constant public returns (uint8 decDigits);\n', '    function totalSupply() constant public returns (uint256 supply);\n', '    function balanceOf(address _owner) constant public returns (uint256 balance);\n', '}\n', '  \n', 'contract HardcodedCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    //global definisions\n', '\n', '    enum ICOStateEnum {NotStarted, Started, Refunded, Successful}\n', '\n', '\n', '    address public owner = msg.sender;\n', '    ManagedToken public managedTokenLedger;\n', '\n', '    string public name = "MDBlockchainPreICO";\n', '    string public symbol = "MDB";\n', '\n', '    bool public unlocked = false;\n', '    bool public halted = false;\n', '\n', '    uint256 public totalSupply = 0;\n', '    \n', '    uint256 public minTokensToBuy = 1000;\n', '    \n', '    uint256 public preICOcontributors = 0;\n', '    uint256 public ICOcontributors = 0;\n', '\n', '    uint256 public preICOstart;\n', '    uint256 public preICOend;\n', '    uint256 public preICOgoal;\n', '    uint256 public preICOcollected = 0;\n', '    uint256 public preICOcap = 0 ether;\n', '    uint256 public preICOtokensSold = 0;\n', '    ICOStateEnum public preICOstate = ICOStateEnum.NotStarted;\n', '    \n', '    uint8 public decimals = 18;\n', '    uint256 public DECIMAL_MULTIPLIER = 10**uint256(decimals);\n', '\n', '    uint256[3] public preICOrates = [uint(1 ether).div(1600), uint(1 ether).div(1400), uint(1 ether).div(1200)];\n', '    uint256[3] public preICOcoinsLeft = [7000000*DECIMAL_MULTIPLIER, 14000000*DECIMAL_MULTIPLIER, 21000000*DECIMAL_MULTIPLIER];\n', '    uint256 public totalPreICOavailible = 42000000*DECIMAL_MULTIPLIER;\n', '\n', '    mapping(address => uint256) public weiForRefundPreICO;\n', '\n', '    mapping(address => uint256) public weiToRecoverPreICO;\n', '\n', '    mapping(address => uint256) public balancesForPreICO;\n', '\n', '    event Purchased(address indexed _from, uint256 _value);\n', '\n', '    function advanceState() public returns (bool success) {\n', '        transitionState();\n', '        return true;\n', '    }\n', '\n', '    function transitionState() internal {\n', '        if (now >= preICOstart) {\n', '            if (preICOstate == ICOStateEnum.NotStarted) {\n', '                preICOstate = ICOStateEnum.Started;\n', '            }\n', '            if (preICOcap > 0 && preICOcollected >= preICOcap) {\n', '                preICOstate = ICOStateEnum.Successful;\n', '            }\n', '            if (preICOtokensSold == totalPreICOavailible) {\n', '                preICOstate = ICOStateEnum.Successful;\n', '            }\n', '        } if (now >= preICOend) {\n', '            if (preICOstate == ICOStateEnum.Started) {\n', '                if (preICOcollected >= preICOgoal) {\n', '                    preICOstate = ICOStateEnum.Successful;\n', '                } else {\n', '                    preICOstate = ICOStateEnum.Refunded;\n', '                }\n', '            }\n', '        } \n', '    }\n', '\n', '    modifier stateTransition() {\n', '        transitionState();\n', '        _;\n', '        transitionState();\n', '    }\n', '\n', '    modifier requirePreICOState(ICOStateEnum _state) {\n', '        require(preICOstate == _state);\n', '        _;\n', '    }\n', '\n', '    modifier notHalted() {\n', '        require(!halted);\n', '        _;\n', '    }\n', '\n', '    // Ownership\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));      \n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant public returns (uint256 balance) {\n', '        return managedTokenLedger.balanceOf(_owner);\n', '    }\n', '\n', '\n', '    function HardcodedCrowdsale (uint _preICOstart, uint _preICOend, uint _preICOgoal, uint _preICOcap, address _newLedgerAddress) public {\n', '        require(_preICOstart > now);\n', '        require(_preICOend > _preICOstart);\n', '        require(_preICOgoal > 0);\n', '        require(_newLedgerAddress != address(0));\n', '        preICOstart = _preICOstart;\n', '        preICOend = _preICOend;\n', '        preICOgoal = _preICOgoal;\n', '        preICOcap = _preICOcap;\n', '        managedTokenLedger = ManagedToken(_newLedgerAddress);\n', '        decimals = managedTokenLedger.decimals();\n', '        DECIMAL_MULTIPLIER = 10**uint256(decimals);\n', '    }\n', '\n', '    function setNameAndTicker(string _name, string _symbol) onlyOwner public returns (bool success) {\n', '        require(bytes(_name).length > 1);\n', '        require(bytes(_symbol).length > 1);\n', '        name = _name;\n', '        symbol = _symbol;\n', '        return true;\n', '    }\n', '\n', '    function setLedger (address _newLedgerAddress) onlyOwner public returns (bool success) {\n', '        require(_newLedgerAddress != address(0));\n', '        managedTokenLedger = ManagedToken(_newLedgerAddress);\n', '        decimals = managedTokenLedger.decimals();\n', '        DECIMAL_MULTIPLIER = 10**uint256(decimals);\n', '        return true;\n', '    }\n', '\n', '    function () payable stateTransition notHalted public {\n', '        if (preICOstate == ICOStateEnum.Started) {\n', '            assert(preICOBuy());\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function transferPreICOCollected() onlyOwner stateTransition public returns (bool success) {\n', '        require(preICOstate == ICOStateEnum.Successful);\n', '        owner.transfer(preICOcollected);\n', '        return true;\n', '    }\n', '\n', '    function setHalt(bool _halt) onlyOwner public returns (bool success) {\n', '        halted = _halt;\n', '        return true;\n', '    }\n', '\n', '    function calculateAmountBoughtPreICO(uint256 _weisSentScaled) internal returns (uint256 _tokensToBuyScaled, uint256 _weisLeftScaled) {\n', '        uint256 value = _weisSentScaled;\n', '        uint256 totalPurchased = 0;\n', '        for (uint8 i = 0; i < preICOrates.length; i++) {\n', '            if (preICOcoinsLeft[i] == 0) {\n', '                continue;\n', '            }\n', '            uint256 rate = preICOrates[i];\n', '            uint256 forThisRate = value.div(rate);\n', '            if (forThisRate == 0) {\n', '                break;\n', '            }\n', '            if (forThisRate > preICOcoinsLeft[i]) {\n', '                forThisRate = preICOcoinsLeft[i];\n', '                preICOcoinsLeft[i] = 0;\n', '            } else {\n', '                preICOcoinsLeft[i] = preICOcoinsLeft[i].sub(forThisRate);\n', '            }\n', '            uint256 consumed = forThisRate.mul(rate);\n', '            value = value.sub(consumed);\n', '            totalPurchased = totalPurchased.add(forThisRate);\n', '        }\n', '        return (totalPurchased, value);\n', '    }\n', '\n', '    function preICOBuy() internal notHalted returns (bool success) {\n', '        uint256 weisSentScaled = msg.value.mul(DECIMAL_MULTIPLIER);\n', '        address _for = msg.sender;\n', '        var (tokensBought, fundsLeftScaled) = calculateAmountBoughtPreICO(weisSentScaled);\n', '        if (tokensBought < minTokensToBuy.mul(DECIMAL_MULTIPLIER)) {\n', '            revert();\n', '        }\n', '        uint256 fundsLeft = fundsLeftScaled.div(DECIMAL_MULTIPLIER);\n', '        uint256 totalSpent = msg.value.sub(fundsLeft);\n', '        if (balanceOf(_for) == 0) {\n', '            preICOcontributors = preICOcontributors + 1;\n', '        }\n', '        managedTokenLedger.mint(_for, tokensBought);\n', '        balancesForPreICO[_for] = balancesForPreICO[_for].add(tokensBought);\n', '        weiForRefundPreICO[_for] = weiForRefundPreICO[_for].add(totalSpent);\n', '        weiToRecoverPreICO[_for] = weiToRecoverPreICO[_for].add(fundsLeft);\n', '        Purchased(_for, tokensBought);\n', '        preICOcollected = preICOcollected.add(totalSpent);\n', '        totalSupply = totalSupply.add(tokensBought);\n', '        preICOtokensSold = preICOtokensSold.add(tokensBought);\n', '        return true;\n', '    }\n', '\n', '    function recoverLeftoversPreICO() stateTransition notHalted public returns (bool success) {\n', '        require(preICOstate != ICOStateEnum.NotStarted);\n', '        uint256 value = weiToRecoverPreICO[msg.sender];\n', '        delete weiToRecoverPreICO[msg.sender];\n', '        msg.sender.transfer(value);\n', '        return true;\n', '    }\n', '\n', '    function refundPreICO() stateTransition requirePreICOState(ICOStateEnum.Refunded) notHalted \n', '        public returns (bool success) {\n', '            uint256 value = weiForRefundPreICO[msg.sender];\n', '            delete weiForRefundPreICO[msg.sender];\n', '            uint256 tokenValue = balancesForPreICO[msg.sender];\n', '            delete balancesForPreICO[msg.sender];\n', '            managedTokenLedger.demint(msg.sender, tokenValue);\n', '            msg.sender.transfer(value);\n', '            return true;\n', '    }\n', '\n', '    function cleanup() onlyOwner public {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '}']
