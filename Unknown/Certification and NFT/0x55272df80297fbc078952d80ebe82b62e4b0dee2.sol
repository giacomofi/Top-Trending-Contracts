['pragma solidity ^0.4.13;\n', '\n', 'contract StandardContract {\n', '    // allows usage of "require" as a modifier\n', '    modifier requires(bool b) {\n', '        require(b);\n', '        _;\n', '    }\n', '\n', '    // require at least one of the two conditions to be true\n', '    modifier requiresOne(bool b1, bool b2) {\n', '        require(b1 || b2);\n', '        _;\n', '    }\n', '\n', '    modifier notNull(address a) {\n', '        require(a != 0);\n', '        _;\n', '    }\n', '\n', '    modifier notZero(uint256 a) {\n', '        require(a != 0);\n', '        _;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private rentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!rentrancy_lock);\n', '    rentrancy_lock = true;\n', '    _;\n', '    rentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = 0x0;\n', '  }\n', '}\n', '\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  function HasNoEther() payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    assert(owner.send(this.balance));\n', '  }\n', '}\n', '\n', '/*\n', ' * A SingleTokenLocker allows a user to create a locker that can lock a single type of ERC20 token.\n', ' * The token locker should:\n', ' *    - Allow the owner to prove a certain number of their own tokens are locked for until a particular time\n', ' *    - Allow the owner to transfer tokens to a recipient and prove the tokens are locked until a particular time\n', ' *    - Allow the owner to cancel a transfer before a recipient confirms (in case of transfer to an incorrect address)\n', ' *    - Allow the recipient to be certain that they will have access to transferred tokens once the lock expires\n', ' *    - Be re-usable by the owner, so an owner can easily schedule/monitor multiple transfers/locks\n', ' *\n', ' * This class should be reusable for any ERC20 token.  Ideally, this sort of fine grained locking would be available in\n', ' * the token contract itself.  Short of that, the token locker receives tokens (presumably from the locker owner) and\n', ' * can be configured to release them only under certain conditions.\n', ' *\n', ' * Usage:\n', ' *  - The owner creates a token locker for a particular ERC20 token type\n', ' *  - The owner approves the locker up to some number of tokens: token.approve(tokenLockerAddress, tokenAmount)\n', ' *    - Alternately, the owner can send tokens to the locker.  When locking tokens, the locker checks its balance first\n', ' *  - The owner calls "lockup" with a particular recipient, amount, and unlock time.  The recipient will be allowed\n', ' *    to collect the tokens once the lockup period is ended.\n', ' *  - The recipient calls "confirm" which confirms that the recipient&#39;s address is correct and is controlled by the\n', ' *    intended recipient (e.g. not an exchange address).  The assumption is that if the recipient can call "confirm"\n', ' *    they have demonstrated that they will also be able to call "collect" when the tokens are ready.\n', ' *  - Once the lock expires, the recipient calls "collect" and the tokens are transferred from the locker to the\n', ' *    recipient.\n', ' *\n', ' * An owner can lockup his/her own tokens in order to demonstrate the they will not be moved until a particular time.\n', ' * In this case, no separate "confirm" step is needed (confirm happens automatically)\n', ' *\n', ' * The following diagram shows the actual balance of the token locker and how it is tracked internally\n', ' *\n', ' *         +-------------------------------------------------------------+\n', ' *         |                      Actual Locker Balance                  |\n', ' *         |-------------------------------------------------------------|\n', ' *         |                     |                Promised               |\n', ' *  State  |     Uncommitted     +---------------------------------------|\n', ' *         |                     |        Pending            |  Locked   |\n', ' *         |---------------------+---------------------------------------|\n', ' *  Actions| withdraw            |  confirm, cancel, collect | collect   |\n', ' *         |---------------------+---------------------------+-----------|\n', ' *  Field  | balance - promised  | promised - locked         | locked    |\n', ' *         +---------------------+---------------------------+-----------+\n', ' */\n', 'contract SingleTokenLocker is Claimable, ReentrancyGuard, StandardContract, HasNoEther {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  // the type of token this locker is used for\n', '  ERC20 public token;\n', '\n', '  // A counter to generate unique Ids for promises\n', '  uint256 public nextPromiseId;\n', '\n', '  // promise storage\n', '  mapping(uint256 => TokenPromise) public promises;\n', '\n', '  // The total amount of tokens locked or pending lock (in the non-fractional units, like wei)\n', '  uint256 public promisedTokenBalance;\n', '\n', '  // The total amount of tokens actually locked (recipients have confirmed)\n', '  uint256 public lockedTokenBalance;\n', '\n', '  // promise states\n', '  //  none: The default state.  Never explicitly assigned.\n', '  //  pending: The owner has initiated a promise, but it has not been claimed\n', '  //  confirmed: The recipient has confirmed the promise\n', '  //  executed: The promise has completed (after the required lockup)\n', '  //  canceled: The promise was canceled (only from pending state)\n', '  //  failed: The promise could not be fulfilled due to an error\n', '  enum PromiseState { none, pending, confirmed, executed, canceled, failed }\n', '\n', '  // a matrix designating the legal state transitions for a promise (see constructor)\n', '  mapping (uint => mapping(uint => bool)) stateTransitionMatrix;\n', '\n', '  // true if the contract has been initialized\n', '  bool initialized;\n', '\n', '  struct TokenPromise {\n', '    uint256 promiseId;\n', '    address recipient;\n', '    uint256 amount;\n', '    uint256 lockedUntil;\n', '    PromiseState state;\n', '  }\n', '\n', '  event logPromiseCreated(uint256 promiseId, address recipient, uint256 amount, uint256 lockedUntil);\n', '  event logPromiseConfirmed(uint256 promiseId);\n', '  event logPromiseCanceled(uint256 promiseId);\n', '  event logPromiseFulfilled(uint256 promiseId);\n', '  event logPromiseUnfulfillable(uint256 promiseId, address recipient, uint256 amount);\n', '\n', '  /**\n', '   * Guards actions that only the intended recipient should be able to perform\n', '   */\n', '  modifier onlyRecipient(uint256 promiseId) {\n', '    require(msg.sender == promises[promiseId].recipient);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * Ensures the promiseId as actually in use.\n', '   */\n', '  modifier promiseExists(uint promiseId) {\n', '    require(promiseId < nextPromiseId);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * Ensure state consistency after modifying lockedTokenBalance or promisedTokenBalance\n', '   */\n', '  modifier thenAssertState() {\n', '    _;\n', '    uint256 balance = tokenBalance();\n', '    assert(lockedTokenBalance <= promisedTokenBalance);\n', '    assert(promisedTokenBalance <= balance);\n', '  }\n', '\n', '  // Constructor\n', '  function SingleTokenLocker(address tokenAddress) {\n', '    token = ERC20(tokenAddress);\n', '\n', '    allowTransition(PromiseState.pending, PromiseState.canceled);\n', '    allowTransition(PromiseState.pending, PromiseState.executed);\n', '    allowTransition(PromiseState.pending, PromiseState.confirmed);\n', '    allowTransition(PromiseState.confirmed, PromiseState.executed);\n', '    allowTransition(PromiseState.executed, PromiseState.failed);\n', '    initialized = true;\n', '  }\n', '\n', '  /**\n', '   * Initiates the request to lockup the given number of tokens until the given block.timestamp occurs.\n', '   * This contract will attempt to acquire tokens from the Token contract from the owner if its balance\n', '   * is not sufficient.  Therefore, the locker owner may call token.approve(locker.address, amount) one time\n', '   * and then initiate many smaller transfers to individuals.\n', '   *\n', '   * Note 1: lockup is not guaranteed until the recipient confirms.\n', '   * Note 2: Assumes the owner has already given approval for the TokenLocker to take out the tokens\n', '   *         or that the locker&#39;s balance is sufficient\n', '   */\n', '  function lockup(address recipient, uint256 amount, uint256 lockedUntil)\n', '    onlyOwner\n', '    notNull(recipient)\n', '    notZero(amount)\n', '    nonReentrant\n', '    external\n', '  {\n', '    // if the locker does not have sufficient unlocked tokens, assume it has enough\n', '    // approved by the owner to make up the difference\n', '    ensureTokensAvailable(amount);\n', '\n', '    // setup a promise that allow transfer to the recipient after the lock expires\n', '    TokenPromise storage promise = createPromise(recipient, amount, lockedUntil);\n', '\n', '    // auto-confirm if the recipient is the owner\n', '    if (recipient == owner) {\n', '      doConfirm(promise);\n', '    }\n', '  }\n', '\n', '  /***\n', '   * @dev Cancels the pending transaction as long as the caller has permissions and the transaction has not already\n', '   * been confirmed.  Allowing *any* transaction to be canceled would mean no lockup could ever be guaranteed.\n', '   */\n', '  function cancel(uint256 promiseId)\n', '    promiseExists(promiseId)\n', '    requires(promises[promiseId].state == PromiseState.pending)\n', '    requiresOne(\n', '      msg.sender == owner,\n', '      msg.sender == promises[promiseId].recipient\n', '    )\n', '    nonReentrant\n', '    external\n', '  {\n', '    TokenPromise storage promise = promises[promiseId];\n', '    unlockTokens(promise, PromiseState.canceled);\n', '    logPromiseCanceled(promise.promiseId);\n', '  }\n', '\n', '  // @dev Allows the recipient to confirm their address.  If this fails (or they cannot send from the specified address)\n', '  // the owner of the TokenLocker can cancel the promise and initiate a new one\n', '  function confirm(uint256 promiseId)\n', '    promiseExists(promiseId)\n', '    onlyRecipient(promiseId)\n', '    requires(promises[promiseId].state == PromiseState.pending)\n', '    nonReentrant\n', '    external\n', '  {\n', '    doConfirm(promises[promiseId]);\n', '  }\n', '\n', '  /***\n', '   * Called by the recipient after the lock has expired.\n', '   */\n', '  function collect(uint256 promiseId)\n', '    promiseExists(promiseId)\n', '    onlyRecipient(promiseId)\n', '    requires(block.timestamp >= promises[promiseId].lockedUntil)\n', '    requiresOne(\n', '      promises[promiseId].state == PromiseState.pending,\n', '      promises[promiseId].state == PromiseState.confirmed\n', '    )\n', '    nonReentrant\n', '    external\n', '  {\n', '    TokenPromise storage promise = promises[promiseId];\n', '\n', '    unlockTokens(promise, PromiseState.executed);\n', '    if (token.transfer(promise.recipient, promise.amount)) {\n', '      logPromiseFulfilled(promise.promiseId);\n', '    }\n', '    else {\n', '      // everything looked good, but the transfer failed.  :(  Now what?\n', '      // There is no reason to think it will work the next time, so\n', '      // reverting probably won&#39;t help here; the tokens would remain locked\n', '      // forever.  Our only hope is that the token owner will resolve the\n', '      // issue in the real world.  Since the amount has been deducted from the\n', '      // locked and pending totals, it has effectively been returned to the owner.\n', '      transition(promise, PromiseState.failed);\n', '      logPromiseUnfulfillable(promiseId, promise.recipient, promise.amount);\n', '    }\n', '  }\n', '\n', '  /***\n', '   * Withdraws the given number of tokens from the locker as long as they are not already locked or promised\n', '   */\n', '  function withdrawUncommittedTokens(uint amount)\n', '    onlyOwner\n', '    requires(amount <= uncommittedTokenBalance())\n', '    nonReentrant\n', '    external\n', '  {\n', '    token.transfer(owner, amount);\n', '  }\n', '\n', '  /***\n', '   * Withdraw all tokens from the wallet that are not locked or promised\n', '   */\n', '  function withdrawAllUncommittedTokens()\n', '    onlyOwner\n', '    nonReentrant\n', '    external\n', '  {\n', '    // not using withdrawUncommittedTokens(uncommittedTokenBalance())\n', '    // to have stronger guarantee on nonReentrant+external\n', '    token.transfer(owner, uncommittedTokenBalance());\n', '  }\n', '\n', '  // tokens can be transferred out by the owner if either\n', '  //  1: The tokens are not the type that are governed by this contract (accidentally sent here, most likely)\n', '  //  2: The tokens are not already promised to a recipient (either pending or confirmed)\n', '  //\n', '  // If neither of these conditions are true, then allowing the owner to transfer the tokens\n', '  // out would violate the purpose of the token locker, which is to prove that the tokens\n', '  // cannot be moved.\n', '  function salvageTokensFromContract(address tokenAddress, address to, uint amount)\n', '    onlyOwner\n', '    requiresOne(\n', '      tokenAddress != address(token),\n', '      amount <= uncommittedTokenBalance()\n', '    )\n', '    nonReentrant\n', '    external\n', '  {\n', '    ERC20(tokenAddress).transfer(to, amount);\n', '  }\n', '\n', '  /***\n', '   * Returns true if the given promise has been confirmed by the recipient\n', '   */\n', '  function isConfirmed(uint256 promiseId)\n', '    constant\n', '    returns(bool)\n', '  {\n', '    return promises[promiseId].state == PromiseState.confirmed;\n', '  }\n', '\n', '  /***\n', '   * Returns true if the give promise can been collected by the recipient\n', '   */\n', '  function canCollect(uint256 promiseId)\n', '    constant\n', '    returns(bool)\n', '  {\n', '    return (promises[promiseId].state == PromiseState.confirmed || promises[promiseId].state == PromiseState.pending)\n', '      && block.timestamp >= promises[promiseId].lockedUntil;\n', '  }\n', '\n', '  // @dev returns the total amount of tokens that are eligible to be collected\n', '  function collectableTokenBalance()\n', '    constant\n', '    returns(uint256 collectable)\n', '  {\n', '    collectable = 0;\n', '    for (uint i=0; i<nextPromiseId; i++) {\n', '      if (canCollect(i)) {\n', '        collectable = collectable.add(promises[i].amount);\n', '      }\n', '    }\n', '    return collectable;\n', '  }\n', '\n', '  /***\n', '   * Return the number of transactions that meet the given criteria.  To be used in conjunction with\n', '   * getPromiseIds()\n', '   *\n', '   * recipient: the recipients address to use for filtering, or 0x0 to return all\n', '   * includeCompleted: true if the list should include transactions that are already executed or canceled\n', '   */\n', '  function getPromiseCount(address recipient, bool includeCompleted)\n', '    public\n', '    constant\n', '    returns (uint count)\n', '  {\n', '    for (uint i=0; i<nextPromiseId; i++) {\n', '      if (recipient != 0x0 && recipient != promises[i].recipient)\n', '        continue;\n', '\n', '        if (includeCompleted\n', '            || promises[i].state == PromiseState.pending\n', '            || promises[i].state == PromiseState.confirmed)\n', '      count += 1;\n', '    }\n', '  }\n', '\n', '  /***\n', '   * Return a list of promiseIds that match the given criteria\n', '   *\n', '   * recipient: the recipients address to use for filtering, or 0x0 to return all\n', '   * includeCompleted: true if the list should include transactions that are already executed or canceled\n', '   */\n', '  function getPromiseIds(uint from, uint to, address recipient, bool includeCompleted)\n', '    public\n', '    constant\n', '    returns (uint[] promiseIds)\n', '  {\n', '    uint[] memory promiseIdsTemp = new uint[](nextPromiseId);\n', '    uint count = 0;\n', '    uint i;\n', '    for (i=0; i<nextPromiseId && count < to; i++) {\n', '      if (recipient != 0x0 && recipient != promises[i].recipient)\n', '        continue;\n', '\n', '      if (includeCompleted\n', '        || promises[i].state == PromiseState.pending\n', '        || promises[i].state == PromiseState.confirmed)\n', '      {\n', '        promiseIdsTemp[count] = i;\n', '        count += 1;\n', '      }\n', '    }\n', '    promiseIds = new uint[](to - from);\n', '    for (i=from; i<to; i++)\n', '      promiseIds[i - from] = promiseIdsTemp[i];\n', '  }\n', '\n', '  /***\n', '   * returns the number of tokens held by the token locker (some might be promised or locked)\n', '   */\n', '  function tokenBalance()\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return token.balanceOf(address(this));\n', '  }\n', '\n', '  /***\n', '   * returns the number of tokens that are not promised or locked\n', '   */\n', '  function uncommittedTokenBalance()\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return tokenBalance() - promisedTokenBalance;\n', '  }\n', '\n', '  /***\n', '   * returns the number of tokens that a promised by have not been locked (pending confirmation from recipient)\n', '   */\n', '  function pendingTokenBalance()\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return promisedTokenBalance - lockedTokenBalance;\n', '  }\n', '\n', '  // ------------------ internal methods ------------------ //\n', '\n', '  // @dev moves the promise to the new state and updates the locked/pending totals accordingly\n', '  function unlockTokens(TokenPromise storage promise, PromiseState newState)\n', '    internal\n', '  {\n', '    promisedTokenBalance = promisedTokenBalance.sub(promise.amount);\n', '    if (promise.state == PromiseState.confirmed) {\n', '      lockedTokenBalance = lockedTokenBalance.sub(promise.amount);\n', '    }\n', '    transition(promise, newState);\n', '  }\n', '\n', '  // @dev add a new state transition to the state transition matrix\n', '  function allowTransition(PromiseState from, PromiseState to)\n', '    requires(!initialized)\n', '    internal\n', '  {\n', '    stateTransitionMatrix[uint(from)][uint(to)] = true;\n', '  }\n', '\n', '  // @dev moves the promise to the new state as long as it&#39;s permitted by the state transition matrix\n', '  function transition(TokenPromise storage promise, PromiseState newState)\n', '    internal\n', '  {\n', '    assert(stateTransitionMatrix[uint(promise.state)][uint(newState)]);\n', '    promise.state = newState;\n', '  }\n', '\n', '  // @dev moves the promise to the confirmed state and updates the locked token total\n', '  function doConfirm(TokenPromise storage promise)\n', '    thenAssertState\n', '    internal\n', '  {\n', '    transition(promise, PromiseState.confirmed);\n', '    lockedTokenBalance = lockedTokenBalance.add(promise.amount);\n', '    logPromiseConfirmed(promise.promiseId);\n', '  }\n', '\n', '  /***\n', '   * @dev creates and stores a new promise object, updates the promisedTokenBalance\n', '   */\n', '  function createPromise(address recipient, uint256 amount, uint256 lockedUntil)\n', '    requires(amount <= uncommittedTokenBalance())\n', '    thenAssertState\n', '    internal\n', '    returns(TokenPromise storage promise)\n', '  {\n', '    uint256 promiseId = nextPromiseId++;\n', '    promise = promises[promiseId];\n', '    promise.promiseId = promiseId;\n', '    promise.recipient = recipient;\n', '    promise.amount = amount;\n', '    promise.lockedUntil = lockedUntil;\n', '    promise.state = PromiseState.pending;\n', '\n', '    promisedTokenBalance = promisedTokenBalance.add(promise.amount);\n', '\n', '    logPromiseCreated(promiseId, recipient, amount, lockedUntil);\n', '\n', '    return promise;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks the uncommitted balance to ensure there the locker has enough tokens to guarantee the\n', '   * amount given can be promised.  If the locker&#39;s balance is not enough, the locker will attempt to transfer\n', '   * tokens from the owner.\n', '   */\n', '  function ensureTokensAvailable(uint256 amount)\n', '    onlyOwner\n', '    internal\n', '  {\n', '    uint256 uncommittedBalance = uncommittedTokenBalance();\n', '    if (uncommittedBalance < amount) {\n', '      token.transferFrom(owner, this, amount.sub(uncommittedBalance));\n', '\n', '      // Just assert that the condition we really care about holds, rather\n', '      // than relying on the return value.  see GavCoin and all the tokens copy/pasted therefrom.\n', '      assert(uncommittedTokenBalance() >= amount);\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract StandardContract {\n', '    // allows usage of "require" as a modifier\n', '    modifier requires(bool b) {\n', '        require(b);\n', '        _;\n', '    }\n', '\n', '    // require at least one of the two conditions to be true\n', '    modifier requiresOne(bool b1, bool b2) {\n', '        require(b1 || b2);\n', '        _;\n', '    }\n', '\n', '    modifier notNull(address a) {\n', '        require(a != 0);\n', '        _;\n', '    }\n', '\n', '    modifier notZero(uint256 a) {\n', '        require(a != 0);\n', '        _;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private rentrancy_lock = false;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!rentrancy_lock);\n', '    rentrancy_lock = true;\n', '    _;\n', '    rentrancy_lock = false;\n', '  }\n', '\n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract Claimable is Ownable {\n', '  address public pendingOwner;\n', '\n', '  /**\n', '   * @dev Modifier throws if called by any account other than the pendingOwner.\n', '   */\n', '  modifier onlyPendingOwner() {\n', '    require(msg.sender == pendingOwner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to set the pendingOwner address.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    pendingOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the pendingOwner address to finalize the transfer.\n', '   */\n', '  function claimOwnership() onlyPendingOwner public {\n', '    OwnershipTransferred(owner, pendingOwner);\n', '    owner = pendingOwner;\n', '    pendingOwner = 0x0;\n', '  }\n', '}\n', '\n', 'contract HasNoEther is Ownable {\n', '\n', '  /**\n', '  * @dev Constructor that rejects incoming Ether\n', '  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\n', '  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\n', '  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\n', '  * we could use assembly to access msg.value.\n', '  */\n', '  function HasNoEther() payable {\n', '    require(msg.value == 0);\n', '  }\n', '\n', '  /**\n', '   * @dev Disallows direct send by settings a default function without the `payable` flag.\n', '   */\n', '  function() external {\n', '  }\n', '\n', '  /**\n', '   * @dev Transfer all Ether held by the contract to the owner.\n', '   */\n', '  function reclaimEther() external onlyOwner {\n', '    assert(owner.send(this.balance));\n', '  }\n', '}\n', '\n', '/*\n', ' * A SingleTokenLocker allows a user to create a locker that can lock a single type of ERC20 token.\n', ' * The token locker should:\n', ' *    - Allow the owner to prove a certain number of their own tokens are locked for until a particular time\n', ' *    - Allow the owner to transfer tokens to a recipient and prove the tokens are locked until a particular time\n', ' *    - Allow the owner to cancel a transfer before a recipient confirms (in case of transfer to an incorrect address)\n', ' *    - Allow the recipient to be certain that they will have access to transferred tokens once the lock expires\n', ' *    - Be re-usable by the owner, so an owner can easily schedule/monitor multiple transfers/locks\n', ' *\n', ' * This class should be reusable for any ERC20 token.  Ideally, this sort of fine grained locking would be available in\n', ' * the token contract itself.  Short of that, the token locker receives tokens (presumably from the locker owner) and\n', ' * can be configured to release them only under certain conditions.\n', ' *\n', ' * Usage:\n', ' *  - The owner creates a token locker for a particular ERC20 token type\n', ' *  - The owner approves the locker up to some number of tokens: token.approve(tokenLockerAddress, tokenAmount)\n', ' *    - Alternately, the owner can send tokens to the locker.  When locking tokens, the locker checks its balance first\n', ' *  - The owner calls "lockup" with a particular recipient, amount, and unlock time.  The recipient will be allowed\n', ' *    to collect the tokens once the lockup period is ended.\n', ' *  - The recipient calls "confirm" which confirms that the recipient\'s address is correct and is controlled by the\n', ' *    intended recipient (e.g. not an exchange address).  The assumption is that if the recipient can call "confirm"\n', ' *    they have demonstrated that they will also be able to call "collect" when the tokens are ready.\n', ' *  - Once the lock expires, the recipient calls "collect" and the tokens are transferred from the locker to the\n', ' *    recipient.\n', ' *\n', ' * An owner can lockup his/her own tokens in order to demonstrate the they will not be moved until a particular time.\n', ' * In this case, no separate "confirm" step is needed (confirm happens automatically)\n', ' *\n', ' * The following diagram shows the actual balance of the token locker and how it is tracked internally\n', ' *\n', ' *         +-------------------------------------------------------------+\n', ' *         |                      Actual Locker Balance                  |\n', ' *         |-------------------------------------------------------------|\n', ' *         |                     |                Promised               |\n', ' *  State  |     Uncommitted     +---------------------------------------|\n', ' *         |                     |        Pending            |  Locked   |\n', ' *         |---------------------+---------------------------------------|\n', ' *  Actions| withdraw            |  confirm, cancel, collect | collect   |\n', ' *         |---------------------+---------------------------+-----------|\n', ' *  Field  | balance - promised  | promised - locked         | locked    |\n', ' *         +---------------------+---------------------------+-----------+\n', ' */\n', 'contract SingleTokenLocker is Claimable, ReentrancyGuard, StandardContract, HasNoEther {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  // the type of token this locker is used for\n', '  ERC20 public token;\n', '\n', '  // A counter to generate unique Ids for promises\n', '  uint256 public nextPromiseId;\n', '\n', '  // promise storage\n', '  mapping(uint256 => TokenPromise) public promises;\n', '\n', '  // The total amount of tokens locked or pending lock (in the non-fractional units, like wei)\n', '  uint256 public promisedTokenBalance;\n', '\n', '  // The total amount of tokens actually locked (recipients have confirmed)\n', '  uint256 public lockedTokenBalance;\n', '\n', '  // promise states\n', '  //  none: The default state.  Never explicitly assigned.\n', '  //  pending: The owner has initiated a promise, but it has not been claimed\n', '  //  confirmed: The recipient has confirmed the promise\n', '  //  executed: The promise has completed (after the required lockup)\n', '  //  canceled: The promise was canceled (only from pending state)\n', '  //  failed: The promise could not be fulfilled due to an error\n', '  enum PromiseState { none, pending, confirmed, executed, canceled, failed }\n', '\n', '  // a matrix designating the legal state transitions for a promise (see constructor)\n', '  mapping (uint => mapping(uint => bool)) stateTransitionMatrix;\n', '\n', '  // true if the contract has been initialized\n', '  bool initialized;\n', '\n', '  struct TokenPromise {\n', '    uint256 promiseId;\n', '    address recipient;\n', '    uint256 amount;\n', '    uint256 lockedUntil;\n', '    PromiseState state;\n', '  }\n', '\n', '  event logPromiseCreated(uint256 promiseId, address recipient, uint256 amount, uint256 lockedUntil);\n', '  event logPromiseConfirmed(uint256 promiseId);\n', '  event logPromiseCanceled(uint256 promiseId);\n', '  event logPromiseFulfilled(uint256 promiseId);\n', '  event logPromiseUnfulfillable(uint256 promiseId, address recipient, uint256 amount);\n', '\n', '  /**\n', '   * Guards actions that only the intended recipient should be able to perform\n', '   */\n', '  modifier onlyRecipient(uint256 promiseId) {\n', '    require(msg.sender == promises[promiseId].recipient);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * Ensures the promiseId as actually in use.\n', '   */\n', '  modifier promiseExists(uint promiseId) {\n', '    require(promiseId < nextPromiseId);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * Ensure state consistency after modifying lockedTokenBalance or promisedTokenBalance\n', '   */\n', '  modifier thenAssertState() {\n', '    _;\n', '    uint256 balance = tokenBalance();\n', '    assert(lockedTokenBalance <= promisedTokenBalance);\n', '    assert(promisedTokenBalance <= balance);\n', '  }\n', '\n', '  // Constructor\n', '  function SingleTokenLocker(address tokenAddress) {\n', '    token = ERC20(tokenAddress);\n', '\n', '    allowTransition(PromiseState.pending, PromiseState.canceled);\n', '    allowTransition(PromiseState.pending, PromiseState.executed);\n', '    allowTransition(PromiseState.pending, PromiseState.confirmed);\n', '    allowTransition(PromiseState.confirmed, PromiseState.executed);\n', '    allowTransition(PromiseState.executed, PromiseState.failed);\n', '    initialized = true;\n', '  }\n', '\n', '  /**\n', '   * Initiates the request to lockup the given number of tokens until the given block.timestamp occurs.\n', '   * This contract will attempt to acquire tokens from the Token contract from the owner if its balance\n', '   * is not sufficient.  Therefore, the locker owner may call token.approve(locker.address, amount) one time\n', '   * and then initiate many smaller transfers to individuals.\n', '   *\n', '   * Note 1: lockup is not guaranteed until the recipient confirms.\n', '   * Note 2: Assumes the owner has already given approval for the TokenLocker to take out the tokens\n', "   *         or that the locker's balance is sufficient\n", '   */\n', '  function lockup(address recipient, uint256 amount, uint256 lockedUntil)\n', '    onlyOwner\n', '    notNull(recipient)\n', '    notZero(amount)\n', '    nonReentrant\n', '    external\n', '  {\n', '    // if the locker does not have sufficient unlocked tokens, assume it has enough\n', '    // approved by the owner to make up the difference\n', '    ensureTokensAvailable(amount);\n', '\n', '    // setup a promise that allow transfer to the recipient after the lock expires\n', '    TokenPromise storage promise = createPromise(recipient, amount, lockedUntil);\n', '\n', '    // auto-confirm if the recipient is the owner\n', '    if (recipient == owner) {\n', '      doConfirm(promise);\n', '    }\n', '  }\n', '\n', '  /***\n', '   * @dev Cancels the pending transaction as long as the caller has permissions and the transaction has not already\n', '   * been confirmed.  Allowing *any* transaction to be canceled would mean no lockup could ever be guaranteed.\n', '   */\n', '  function cancel(uint256 promiseId)\n', '    promiseExists(promiseId)\n', '    requires(promises[promiseId].state == PromiseState.pending)\n', '    requiresOne(\n', '      msg.sender == owner,\n', '      msg.sender == promises[promiseId].recipient\n', '    )\n', '    nonReentrant\n', '    external\n', '  {\n', '    TokenPromise storage promise = promises[promiseId];\n', '    unlockTokens(promise, PromiseState.canceled);\n', '    logPromiseCanceled(promise.promiseId);\n', '  }\n', '\n', '  // @dev Allows the recipient to confirm their address.  If this fails (or they cannot send from the specified address)\n', '  // the owner of the TokenLocker can cancel the promise and initiate a new one\n', '  function confirm(uint256 promiseId)\n', '    promiseExists(promiseId)\n', '    onlyRecipient(promiseId)\n', '    requires(promises[promiseId].state == PromiseState.pending)\n', '    nonReentrant\n', '    external\n', '  {\n', '    doConfirm(promises[promiseId]);\n', '  }\n', '\n', '  /***\n', '   * Called by the recipient after the lock has expired.\n', '   */\n', '  function collect(uint256 promiseId)\n', '    promiseExists(promiseId)\n', '    onlyRecipient(promiseId)\n', '    requires(block.timestamp >= promises[promiseId].lockedUntil)\n', '    requiresOne(\n', '      promises[promiseId].state == PromiseState.pending,\n', '      promises[promiseId].state == PromiseState.confirmed\n', '    )\n', '    nonReentrant\n', '    external\n', '  {\n', '    TokenPromise storage promise = promises[promiseId];\n', '\n', '    unlockTokens(promise, PromiseState.executed);\n', '    if (token.transfer(promise.recipient, promise.amount)) {\n', '      logPromiseFulfilled(promise.promiseId);\n', '    }\n', '    else {\n', '      // everything looked good, but the transfer failed.  :(  Now what?\n', '      // There is no reason to think it will work the next time, so\n', "      // reverting probably won't help here; the tokens would remain locked\n", '      // forever.  Our only hope is that the token owner will resolve the\n', '      // issue in the real world.  Since the amount has been deducted from the\n', '      // locked and pending totals, it has effectively been returned to the owner.\n', '      transition(promise, PromiseState.failed);\n', '      logPromiseUnfulfillable(promiseId, promise.recipient, promise.amount);\n', '    }\n', '  }\n', '\n', '  /***\n', '   * Withdraws the given number of tokens from the locker as long as they are not already locked or promised\n', '   */\n', '  function withdrawUncommittedTokens(uint amount)\n', '    onlyOwner\n', '    requires(amount <= uncommittedTokenBalance())\n', '    nonReentrant\n', '    external\n', '  {\n', '    token.transfer(owner, amount);\n', '  }\n', '\n', '  /***\n', '   * Withdraw all tokens from the wallet that are not locked or promised\n', '   */\n', '  function withdrawAllUncommittedTokens()\n', '    onlyOwner\n', '    nonReentrant\n', '    external\n', '  {\n', '    // not using withdrawUncommittedTokens(uncommittedTokenBalance())\n', '    // to have stronger guarantee on nonReentrant+external\n', '    token.transfer(owner, uncommittedTokenBalance());\n', '  }\n', '\n', '  // tokens can be transferred out by the owner if either\n', '  //  1: The tokens are not the type that are governed by this contract (accidentally sent here, most likely)\n', '  //  2: The tokens are not already promised to a recipient (either pending or confirmed)\n', '  //\n', '  // If neither of these conditions are true, then allowing the owner to transfer the tokens\n', '  // out would violate the purpose of the token locker, which is to prove that the tokens\n', '  // cannot be moved.\n', '  function salvageTokensFromContract(address tokenAddress, address to, uint amount)\n', '    onlyOwner\n', '    requiresOne(\n', '      tokenAddress != address(token),\n', '      amount <= uncommittedTokenBalance()\n', '    )\n', '    nonReentrant\n', '    external\n', '  {\n', '    ERC20(tokenAddress).transfer(to, amount);\n', '  }\n', '\n', '  /***\n', '   * Returns true if the given promise has been confirmed by the recipient\n', '   */\n', '  function isConfirmed(uint256 promiseId)\n', '    constant\n', '    returns(bool)\n', '  {\n', '    return promises[promiseId].state == PromiseState.confirmed;\n', '  }\n', '\n', '  /***\n', '   * Returns true if the give promise can been collected by the recipient\n', '   */\n', '  function canCollect(uint256 promiseId)\n', '    constant\n', '    returns(bool)\n', '  {\n', '    return (promises[promiseId].state == PromiseState.confirmed || promises[promiseId].state == PromiseState.pending)\n', '      && block.timestamp >= promises[promiseId].lockedUntil;\n', '  }\n', '\n', '  // @dev returns the total amount of tokens that are eligible to be collected\n', '  function collectableTokenBalance()\n', '    constant\n', '    returns(uint256 collectable)\n', '  {\n', '    collectable = 0;\n', '    for (uint i=0; i<nextPromiseId; i++) {\n', '      if (canCollect(i)) {\n', '        collectable = collectable.add(promises[i].amount);\n', '      }\n', '    }\n', '    return collectable;\n', '  }\n', '\n', '  /***\n', '   * Return the number of transactions that meet the given criteria.  To be used in conjunction with\n', '   * getPromiseIds()\n', '   *\n', '   * recipient: the recipients address to use for filtering, or 0x0 to return all\n', '   * includeCompleted: true if the list should include transactions that are already executed or canceled\n', '   */\n', '  function getPromiseCount(address recipient, bool includeCompleted)\n', '    public\n', '    constant\n', '    returns (uint count)\n', '  {\n', '    for (uint i=0; i<nextPromiseId; i++) {\n', '      if (recipient != 0x0 && recipient != promises[i].recipient)\n', '        continue;\n', '\n', '        if (includeCompleted\n', '            || promises[i].state == PromiseState.pending\n', '            || promises[i].state == PromiseState.confirmed)\n', '      count += 1;\n', '    }\n', '  }\n', '\n', '  /***\n', '   * Return a list of promiseIds that match the given criteria\n', '   *\n', '   * recipient: the recipients address to use for filtering, or 0x0 to return all\n', '   * includeCompleted: true if the list should include transactions that are already executed or canceled\n', '   */\n', '  function getPromiseIds(uint from, uint to, address recipient, bool includeCompleted)\n', '    public\n', '    constant\n', '    returns (uint[] promiseIds)\n', '  {\n', '    uint[] memory promiseIdsTemp = new uint[](nextPromiseId);\n', '    uint count = 0;\n', '    uint i;\n', '    for (i=0; i<nextPromiseId && count < to; i++) {\n', '      if (recipient != 0x0 && recipient != promises[i].recipient)\n', '        continue;\n', '\n', '      if (includeCompleted\n', '        || promises[i].state == PromiseState.pending\n', '        || promises[i].state == PromiseState.confirmed)\n', '      {\n', '        promiseIdsTemp[count] = i;\n', '        count += 1;\n', '      }\n', '    }\n', '    promiseIds = new uint[](to - from);\n', '    for (i=from; i<to; i++)\n', '      promiseIds[i - from] = promiseIdsTemp[i];\n', '  }\n', '\n', '  /***\n', '   * returns the number of tokens held by the token locker (some might be promised or locked)\n', '   */\n', '  function tokenBalance()\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return token.balanceOf(address(this));\n', '  }\n', '\n', '  /***\n', '   * returns the number of tokens that are not promised or locked\n', '   */\n', '  function uncommittedTokenBalance()\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return tokenBalance() - promisedTokenBalance;\n', '  }\n', '\n', '  /***\n', '   * returns the number of tokens that a promised by have not been locked (pending confirmation from recipient)\n', '   */\n', '  function pendingTokenBalance()\n', '    constant\n', '    returns(uint256)\n', '  {\n', '    return promisedTokenBalance - lockedTokenBalance;\n', '  }\n', '\n', '  // ------------------ internal methods ------------------ //\n', '\n', '  // @dev moves the promise to the new state and updates the locked/pending totals accordingly\n', '  function unlockTokens(TokenPromise storage promise, PromiseState newState)\n', '    internal\n', '  {\n', '    promisedTokenBalance = promisedTokenBalance.sub(promise.amount);\n', '    if (promise.state == PromiseState.confirmed) {\n', '      lockedTokenBalance = lockedTokenBalance.sub(promise.amount);\n', '    }\n', '    transition(promise, newState);\n', '  }\n', '\n', '  // @dev add a new state transition to the state transition matrix\n', '  function allowTransition(PromiseState from, PromiseState to)\n', '    requires(!initialized)\n', '    internal\n', '  {\n', '    stateTransitionMatrix[uint(from)][uint(to)] = true;\n', '  }\n', '\n', "  // @dev moves the promise to the new state as long as it's permitted by the state transition matrix\n", '  function transition(TokenPromise storage promise, PromiseState newState)\n', '    internal\n', '  {\n', '    assert(stateTransitionMatrix[uint(promise.state)][uint(newState)]);\n', '    promise.state = newState;\n', '  }\n', '\n', '  // @dev moves the promise to the confirmed state and updates the locked token total\n', '  function doConfirm(TokenPromise storage promise)\n', '    thenAssertState\n', '    internal\n', '  {\n', '    transition(promise, PromiseState.confirmed);\n', '    lockedTokenBalance = lockedTokenBalance.add(promise.amount);\n', '    logPromiseConfirmed(promise.promiseId);\n', '  }\n', '\n', '  /***\n', '   * @dev creates and stores a new promise object, updates the promisedTokenBalance\n', '   */\n', '  function createPromise(address recipient, uint256 amount, uint256 lockedUntil)\n', '    requires(amount <= uncommittedTokenBalance())\n', '    thenAssertState\n', '    internal\n', '    returns(TokenPromise storage promise)\n', '  {\n', '    uint256 promiseId = nextPromiseId++;\n', '    promise = promises[promiseId];\n', '    promise.promiseId = promiseId;\n', '    promise.recipient = recipient;\n', '    promise.amount = amount;\n', '    promise.lockedUntil = lockedUntil;\n', '    promise.state = PromiseState.pending;\n', '\n', '    promisedTokenBalance = promisedTokenBalance.add(promise.amount);\n', '\n', '    logPromiseCreated(promiseId, recipient, amount, lockedUntil);\n', '\n', '    return promise;\n', '  }\n', '\n', '  /**\n', '   * @dev Checks the uncommitted balance to ensure there the locker has enough tokens to guarantee the\n', "   * amount given can be promised.  If the locker's balance is not enough, the locker will attempt to transfer\n", '   * tokens from the owner.\n', '   */\n', '  function ensureTokensAvailable(uint256 amount)\n', '    onlyOwner\n', '    internal\n', '  {\n', '    uint256 uncommittedBalance = uncommittedTokenBalance();\n', '    if (uncommittedBalance < amount) {\n', '      token.transferFrom(owner, this, amount.sub(uncommittedBalance));\n', '\n', '      // Just assert that the condition we really care about holds, rather\n', '      // than relying on the return value.  see GavCoin and all the tokens copy/pasted therefrom.\n', '      assert(uncommittedTokenBalance() >= amount);\n', '    }\n', '  }\n', '}']
