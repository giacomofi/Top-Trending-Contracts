['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '    // ------------------------------------------------------------------------\n', '    // Add a number to another number, checking for overflows\n', '    // ------------------------------------------------------------------------\n', '    function add(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Subtract a number from another number, checking for underflows\n', '    // ------------------------------------------------------------------------\n', '    function sub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\t\n', '}\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function setOwner(address _newOwner) onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', 'interface token {\n', '    function transfer(address receiver, uint amount) returns (bool success) ;\n', '\tfunction balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', 'contract IQTCrowdsale is Owned{\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint;\n', '\t\n', '\tstruct ContributorData{\n', '\t\tbool isActive;\n', '\t\tbool isTokenDistributed;\n', '\t\tuint contributionAmount;\t// ETH contribution\n', '\t\tuint tokensAmount;\t\t\t// Exchanged IQT amount\n', '\t}\n', '\t\n', '\tmapping(address => ContributorData) public contributorList;\n', '\tmapping(uint => address) contributorIndexes;\n', '\tuint nextContributorIndex;\n', '\tuint contributorCount;\n', '    \n', '    address public beneficiary;\n', '    uint public fundingLimit;\n', '    uint public amountRaised;\n', '\tuint public remainAmount;\n', '    uint public deadline;\n', '    uint public exchangeTokenRate;\n', '    token public tokenReward;\n', '\tuint256 public tokenBalance;\n', '    bool public crowdsaleClosed = false;\n', '    bool public isIQTDistributed = false;\n', '    \n', '\n', '    // ------------------------------------------------------------------------\n', '    // Tranche 1 crowdsale start date and end date\n', '    // Start - Monday, 25-Sep-17 12:00:00 UTC / 12pm GMT 25th September 2017\n', '    // Tier1  - Sunday, 1-Oct-17 16:00:00 UTC / 16pm GMT 1st October 2017\n', '    // Tier2  - Wednesday, 11-Oct-17 16:00:00 UTC / 16pm GMT 11th October 2017\n', '    // Tier3  - Monday, 21-Oct-17 16:00:00 UTC / 16pm GMT 21th October 2017\n', '    // End - Saturday, 25-Nov-17 12:00:00 UTC / 12pm GMT 25 November 2017 \n', '    // ------------------------------------------------------------------------\n', '    uint public constant START_TIME = 1506340800;\n', '    uint public constant SECOND_TIER_SALE_START_TIME = 1506787200;\n', '    uint public constant THIRD_TIER_SALE_START_TIME = 1507651200;\n', '    uint public constant FOURTH_TIER_SALE_START_TIME = 1508515200;\n', '    uint public constant END_TIME = 1511611200;\n', '\t\n', '\t\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // crowdsale exchange rate\n', '    // ------------------------------------------------------------------------\n', '    uint public START_RATE = 900;\n', '    uint public SECOND_TIER_RATE = 850;\n', '    uint public THIRD_TIER_RATE = 800;\n', '    uint public FOURTH_RATE = 700;\n', '    \n', '\n', '    // ------------------------------------------------------------------------\n', '    // Funding Goal\n', '    //    - HARD CAP : 33000 ETH\n', '    // ------------------------------------------------------------------------\n', '    uint public constant FUNDING_ETH_HARD_CAP = 33000;\n', '    \n', '    // IQT token decimals\n', '    uint8 public constant IQT_DECIMALS = 8;\n', '    uint public constant IQT_DECIMALSFACTOR = 10**uint(IQT_DECIMALS);\n', '    \n', '    address public constant IQT_FUNDATION_ADDRESS = 0xB58d67ced1E480aC7FBAf70dc2b023e30140fBB4;\n', '    address public constant IQT_CONTRACT_ADDRESS = 0x51ee82641Ac238BDe34B9859f98F5F311d6E4954;\n', '\n', '    event GoalReached(address raisingAddress, uint amountRaised);\n', '\tevent LimitReached(address raisingAddress, uint amountRaised);\n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\tevent WithdrawFailed(address raisingAddress, uint amount, bool isContribution);\n', '\tevent FundReturn(address backer, uint amount, bool isContribution);\n', '\n', '    /**\n', '     * Constrctor function\n', '     *\n', '     * Setup the owner\n', '     */\n', '    function IQTCrowdsale(\n', '    ) {\n', '        beneficiary = IQT_FUNDATION_ADDRESS;\n', '        fundingLimit = FUNDING_ETH_HARD_CAP * 1 ether;  // Funding limit 33000 ETH\n', '\t\t\n', '        deadline = END_TIME;  // 2017-11-25 12:00:00 UTC\n', '        exchangeTokenRate = FOURTH_RATE * IQT_DECIMALSFACTOR;\n', '        tokenReward = token(IQT_CONTRACT_ADDRESS);\n', '\t\tcontributorCount = 0;\n', '    }\n', '\n', '    /**\n', '     * Fallback function\n', '     *\n', '     * The function without name is the default function that is called whenever anyone sends funds to a contract\n', '     */\n', '    function () payable {\n', '\t\t\n', '        require(!crowdsaleClosed);\n', '        require(now >= START_TIME && now < END_TIME);\n', '        \n', '\t\tprocessTransaction(msg.sender, msg.value);\n', '    }\n', '\t\n', '\t/**\n', '\t * Process transaction\n', '\t */\n', '\tfunction processTransaction(address _contributor, uint _amount) internal{\t\n', '\t\tuint contributionEthAmount = _amount;\n', '\t\t\t\n', '        amountRaised += contributionEthAmount;                    // add newly received ETH\n', '\t\tremainAmount += contributionEthAmount;\n', '        \n', '\t\t// calcualte exchanged token based on exchange rate\n', '        if (now >= START_TIME && now < SECOND_TIER_SALE_START_TIME){\n', '\t\t\texchangeTokenRate = START_RATE * IQT_DECIMALSFACTOR;\n', '        }\n', '        if (now >= SECOND_TIER_SALE_START_TIME && now < THIRD_TIER_SALE_START_TIME){\n', '            exchangeTokenRate = SECOND_TIER_RATE * IQT_DECIMALSFACTOR;\n', '        }\n', '        if (now >= THIRD_TIER_SALE_START_TIME && now < FOURTH_TIER_SALE_START_TIME){\n', '            exchangeTokenRate = THIRD_TIER_RATE * IQT_DECIMALSFACTOR;\n', '        }\n', '        if (now >= FOURTH_TIER_SALE_START_TIME && now < END_TIME){\n', '            exchangeTokenRate = FOURTH_RATE * IQT_DECIMALSFACTOR;\n', '        }\n', '        uint amountIqtToken = _amount * exchangeTokenRate / 1 ether;\n', '\t\t\n', '\t\tif (contributorList[_contributor].isActive == false){                  // Check if contributor has already contributed\n', '\t\t\tcontributorList[_contributor].isActive = true;                            // Set his activity to true\n', '\t\t\tcontributorList[_contributor].contributionAmount = contributionEthAmount;    // Set his contribution\n', '\t\t\tcontributorList[_contributor].tokensAmount = amountIqtToken;\n', '\t\t\tcontributorList[_contributor].isTokenDistributed = false;\n', '\t\t\tcontributorIndexes[nextContributorIndex] = _contributor;                  // Set contributors index\n', '\t\t\tnextContributorIndex++;\n', '\t\t\tcontributorCount++;\n', '\t\t}\n', '\t\telse{\n', '\t\t\tcontributorList[_contributor].contributionAmount += contributionEthAmount;   // Add contribution amount to existing contributor\n', '\t\t\tcontributorList[_contributor].tokensAmount += amountIqtToken;             // log token amount`\n', '\t\t}\n', '\t\t\n', '        FundTransfer(msg.sender, contributionEthAmount, true);\n', '\t\t\n', '\t\tif (amountRaised >= fundingLimit){\n', '\t\t\t// close crowdsale because the crowdsale limit is reached\n', '\t\t\tcrowdsaleClosed = true;\n', '\t\t}\t\t\n', '\t\t\n', '\t}\n', '\n', '    modifier afterDeadline() { if (now >= deadline) _; }\t\n', '\tmodifier afterCrowdsaleClosed() { if (crowdsaleClosed == true || now >= deadline) _; }\n', '\t\n', '\t\n', '\t/**\n', '     * close Crowdsale\n', '     *\n', '     */\n', '\tfunction closeCrowdSale(){\n', '\t\trequire(beneficiary == msg.sender);\n', '\t\tif ( beneficiary == msg.sender) {\n', '\t\t\tcrowdsaleClosed = true;\n', '\t\t}\n', '\t}\n', '\t\n', '    /**\n', '     * Check token balance\n', '     *\n', '     */\n', '\tfunction checkTokenBalance(){\n', '\t\tif ( beneficiary == msg.sender) {\n', '\t\t\t//check current token balance\n', '\t\t\ttokenBalance = tokenReward.balanceOf(address(this));\n', '\t\t}\n', '\t}\n', '\t\n', '    /**\n', '     * Withdraw the all funds\n', '     *\n', '     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n', '     * sends the entire amount to the beneficiary. \n', '     */\n', '    function safeWithdrawalAll() {\n', '        if ( beneficiary == msg.sender) {\n', '            if (beneficiary.send(amountRaised)) {\n', '                FundTransfer(beneficiary, amountRaised, false);\n', '\t\t\t\tremainAmount = remainAmount - amountRaised;\n', '            } else {\n', '\t\t\t\tWithdrawFailed(beneficiary, amountRaised, false);\n', '\t\t\t\t//If we fail to send the funds to beneficiary\n', '            }\n', '        }\n', '    }\n', '\t\n', '\t/**\n', '     * Withdraw the funds\n', '     *\n', '     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n', '     * sends the entire amount to the beneficiary. \n', '     */\n', '    function safeWithdrawalAmount(uint256 withdrawAmount) {\n', '        if (beneficiary == msg.sender) {\n', '            if (beneficiary.send(withdrawAmount)) {\n', '                FundTransfer(beneficiary, withdrawAmount, false);\n', '\t\t\t\tremainAmount = remainAmount - withdrawAmount;\n', '            } else {\n', '\t\t\t\tWithdrawFailed(beneficiary, withdrawAmount, false);\n', '\t\t\t\t//If we fail to send the funds to beneficiary\n', '            }\n', '        }\n', '    }\n', '\t\n', '\t/**\n', '\t * Withdraw IQT \n', '     * \n', '\t * If there are some remaining IQT in the contract \n', '\t * after all token are distributed the contributor,\n', '\t * the beneficiary can withdraw the IQT in the contract\n', '     *\n', '     */\n', '    function withdrawIQT(uint256 tokenAmount) afterCrowdsaleClosed {\n', '\t\trequire(beneficiary == msg.sender);\n', '        if (isIQTDistributed && beneficiary == msg.sender) {\n', '            tokenReward.transfer(beneficiary, tokenAmount);\n', '\t\t\t// update token balance\n', '\t\t\ttokenBalance = tokenReward.balanceOf(address(this));\n', '        }\n', '    }\n', '\t\n', '\n', '\t/**\n', '     * Distribute token\n', '     *\n', '     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n', '     * distribute token to contributor. \n', '     */\n', '\tfunction distributeIQTToken() {\n', '\t\tif (beneficiary == msg.sender) {  // only IQT_FUNDATION_ADDRESS can distribute the IQT\n', '\t\t\taddress currentParticipantAddress;\n', '\t\t\tfor (uint index = 0; index < contributorCount; index++){\n', '\t\t\t\tcurrentParticipantAddress = contributorIndexes[index]; \n', '\t\t\t\t\n', '\t\t\t\tuint amountIqtToken = contributorList[currentParticipantAddress].tokensAmount;\n', '\t\t\t\tif (false == contributorList[currentParticipantAddress].isTokenDistributed){\n', '\t\t\t\t\tbool isSuccess = tokenReward.transfer(currentParticipantAddress, amountIqtToken);\n', '\t\t\t\t\tif (isSuccess){\n', '\t\t\t\t\t\tcontributorList[currentParticipantAddress].isTokenDistributed = true;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\t// check if all IQT are distributed\n', '\t\t\tcheckIfAllIQTDistributed();\n', '\t\t\t// get latest token balance\n', '\t\t\ttokenBalance = tokenReward.balanceOf(address(this));\n', '\t\t}\n', '\t}\n', '\t\n', '\t/**\n', '     * Distribute token by batch\n', '     *\n', '     * Checks to see if goal or time limit has been reached, and if so, and the funding goal was reached,\n', '     * distribute token to contributor. \n', '     */\n', '\tfunction distributeIQTTokenBatch(uint batchUserCount) {\n', '\t\tif (beneficiary == msg.sender) {  // only IQT_FUNDATION_ADDRESS can distribute the IQT\n', '\t\t\taddress currentParticipantAddress;\n', '\t\t\tuint transferedUserCount = 0;\n', '\t\t\tfor (uint index = 0; index < contributorCount && transferedUserCount<batchUserCount; index++){\n', '\t\t\t\tcurrentParticipantAddress = contributorIndexes[index]; \n', '\t\t\t\t\n', '\t\t\t\tuint amountIqtToken = contributorList[currentParticipantAddress].tokensAmount;\n', '\t\t\t\tif (false == contributorList[currentParticipantAddress].isTokenDistributed){\n', '\t\t\t\t\tbool isSuccess = tokenReward.transfer(currentParticipantAddress, amountIqtToken);\n', '\t\t\t\t\ttransferedUserCount = transferedUserCount + 1;\n', '\t\t\t\t\tif (isSuccess){\n', '\t\t\t\t\t\tcontributorList[currentParticipantAddress].isTokenDistributed = true;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\t// check if all IQT are distributed\n', '\t\t\tcheckIfAllIQTDistributed();\n', '\t\t\t// get latest token balance\n', '\t\t\ttokenBalance = tokenReward.balanceOf(address(this));\n', '\t\t}\n', '\t}\n', '\t\n', '\t/**\n', "\t * Check if all contributor's token are successfully distributed\n", '\t */\n', '\tfunction checkIfAllIQTDistributed(){\n', '\t    address currentParticipantAddress;\n', '\t\tisIQTDistributed = true;\n', '\t\tfor (uint index = 0; index < contributorCount; index++){\n', '\t\t\t\tcurrentParticipantAddress = contributorIndexes[index]; \n', '\t\t\t\t\n', '\t\t\tif (false == contributorList[currentParticipantAddress].isTokenDistributed){\n', '\t\t\t\tisIQTDistributed = false;\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '}']