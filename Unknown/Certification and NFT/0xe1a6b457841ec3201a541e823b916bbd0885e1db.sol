['pragma solidity ^0.4.2;\n', '\n', '/// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\n', '/// @title Abstract token contract - Functions to be implemented by token contracts.\n', 'contract Token {\n', "    // This is not an abstract function, because solc won't recognize generated getter functions for public variables as functions\n", '    function totalSupply() constant returns (uint256 supply) {}\n', '    function balanceOf(address owner) constant returns (uint256 balance);\n', '    function transfer(address to, uint256 value) returns (bool success);\n', '    function transferFrom(address from, address to, uint256 value) returns (bool success);\n', '    function approve(address spender, uint256 value) returns (bool success);\n', '    function allowance(address owner, address spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract HumaniqToken is Token {\n', '    function issueTokens(address _for, uint tokenCount) payable returns (bool);\n', '    function changeEmissionContractAddress(address newAddress) returns (bool);\n', '}\n', '\n', '/// @title HumaniqICO contract - Takes funds from users and issues tokens.\n', '/// @author Evgeny Yurtaev - <evgeny@etherionlab.com>\n', 'contract HumaniqICO {\n', '\n', '    /*\n', '     * External contracts\n', '     */\n', '    HumaniqToken public humaniqToken = HumaniqToken(0x9734c136F5c63531b60D02548Bca73a3d72E024D);\n', '\n', '    /*\n', '     * Crowdfunding parameters\n', '     */\n', '    uint constant public CROWDFUNDING_PERIOD = 12 days;\n', '    // Goal threshold, 10000 ETH\n', '    uint constant public CROWDSALE_TARGET = 10000 ether;\n', '\n', '    /*\n', '     *  Storage\n', '     */\n', '    address public founder;\n', '    address public multisig;\n', '    uint public startDate = 0;\n', '    uint public icoBalance = 0;\n', '    uint public baseTokenPrice = 666 szabo; // 0.000666 ETH\n', '    uint public discountedPrice = baseTokenPrice;\n', '    bool public isICOActive = false;\n', '\n', '    // participant address => value in Wei\n', '    mapping (address => uint) public investments;\n', '\n', '    /*\n', '     *  Modifiers\n', '     */\n', '    modifier onlyFounder() {\n', '        // Only founder is allowed to do this action.\n', '        if (msg.sender != founder) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier minInvestment() {\n', '        // User has to send at least the ether value of one token.\n', '        if (msg.value < baseTokenPrice) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier icoActive() {\n', '        if (isICOActive == false) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier applyBonus() {\n', '        uint icoDuration = now - startDate;\n', '        if (icoDuration >= 248 hours) {\n', '            discountedPrice = baseTokenPrice;\n', '        }\n', '        else if (icoDuration >= 176 hours) {\n', '            discountedPrice = (baseTokenPrice * 100) / 107;\n', '        }\n', '        else if (icoDuration >= 104 hours) {\n', '            discountedPrice = (baseTokenPrice * 100) / 120;\n', '        }\n', '        else if (icoDuration >= 32 hours) {\n', '            discountedPrice = (baseTokenPrice * 100) / 142;\n', '        }\n', '        else if (icoDuration >= 12 hours) {\n', '            discountedPrice = (baseTokenPrice * 100) / 150;\n', '        }\n', '        else {\n', '            discountedPrice = (baseTokenPrice * 100) / 170;\n', '        }\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows user to create tokens if token creation is still going\n', '    /// and cap was not reached. Returns token count.\n', '    function fund()\n', '        public\n', '        applyBonus\n', '        icoActive\n', '        minInvestment\n', '        payable\n', '        returns (uint)\n', '    {\n', '        // Token count is rounded down. Sent ETH should be multiples of baseTokenPrice.\n', '        uint tokenCount = msg.value / discountedPrice;\n', '        // Ether spent by user.\n', '        uint investment = tokenCount * discountedPrice;\n', '        // Send change back to user.\n', '        if (msg.value > investment && !msg.sender.send(msg.value - investment)) {\n', '            throw;\n', '        }\n', "        // Update fund's and user's balance and total supply of tokens.\n", '        icoBalance += investment;\n', '        investments[msg.sender] += investment;\n', '        // Send funds to founders.\n', '        if (!multisig.send(investment)) {\n', '            // Could not send money\n', '            throw;\n', '        }\n', '        if (!humaniqToken.issueTokens(msg.sender, tokenCount)) {\n', '            // Tokens could not be issued.\n', '            throw;\n', '        }\n', '        return tokenCount;\n', '    }\n', '\n', '    /// @dev Issues tokens for users who made BTC purchases.\n', '    /// @param beneficiary Address the tokens will be issued to.\n', '    /// @param _tokenCount Number of tokens to issue.\n', '    function fundBTC(address beneficiary, uint _tokenCount)\n', '        external\n', '        applyBonus\n', '        icoActive\n', '        onlyFounder\n', '        returns (uint)\n', '    {\n', '        // Approximate ether spent.\n', '        uint investment = _tokenCount * discountedPrice;\n', "        // Update fund's and user's balance and total supply of tokens.\n", '        icoBalance += investment;\n', '        investments[beneficiary] += investment;\n', '        if (!humaniqToken.issueTokens(beneficiary, _tokenCount)) {\n', '            // Tokens could not be issued.\n', '            throw;\n', '        }\n', '        return _tokenCount;\n', '    }\n', '\n', '    /// @dev If ICO has successfully finished sends the money to multisig\n', '    /// wallet.\n', '    function finishCrowdsale()\n', '        external\n', '        onlyFounder\n', '        returns (bool)\n', '    {\n', '        if (isICOActive == true) {\n', '            isICOActive = false;\n', '            // Founders receive 14% of all created tokens.\n', '            uint founderBonus = ((icoBalance / baseTokenPrice) * 114) / 100;\n', '            if (!humaniqToken.issueTokens(multisig, founderBonus)) {\n', '                // Tokens could not be issued.\n', '                throw;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Sets token value in Wei.\n', '    /// @param valueInWei New value.\n', '    function changeBaseTokenPrice(uint valueInWei)\n', '        external\n', '        onlyFounder\n', '        returns (bool)\n', '    {\n', '        baseTokenPrice = valueInWei;\n', '        return true;\n', '    }\n', '\n', '    /// @dev Function that activates ICO.\n', '    function startICO()\n', '        external\n', '        onlyFounder\n', '    {\n', '        if (isICOActive == false && startDate == 0) {\n', '          // Start ICO\n', '          isICOActive = true;\n', '          // Set start-date of token creation\n', '          startDate = now;\n', '        }\n', '    }\n', '\n', '    /// @dev Contract constructor function sets founder and multisig addresses.\n', '    function HumaniqICO(address _multisig) {\n', '        // Set founder address\n', '        founder = msg.sender;\n', '        // Set multisig address\n', '        multisig = _multisig;\n', '    }\n', '\n', '    /// @dev Fallback function. Calls fund() function to create tokens.\n', '    function () payable {\n', '        fund();\n', '    }\n', '}']