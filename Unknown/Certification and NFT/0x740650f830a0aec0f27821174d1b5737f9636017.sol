['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', '/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n', '///  later changed\n', 'contract Owned {\n', '\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    address public newOwner;\n', '\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '    ///  an unowned neutral vault, however that cannot be undone\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '\n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'pragma solidity ^0.4.11;\n', '\n', 'contract ERC20Protocol {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint supply);\n', '    is replaced with:\n', '    uint public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '//import "./ERC20Protocol.sol";\n', '//import "./SafeMath.sol";\n', '\n', 'contract StandardToken is ERC20Protocol {\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '    * @dev Fix for the ERC20 short address attack.\n', '    */\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '        //Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '}\n', '\n', '\n', '\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', '/*\n', '\n', '  Copyright 2017 Wanchain Foundation.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '//                            _           _           _\n', '//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n', '//  \\ \\ /\\ / / _` | &#39;_ \\ / __| &#39;_ \\ / _` | | &#39;_ \\@/ _` |/ _ \\ \\ / /\n', '//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n', '//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n', '//\n', '//  Code style according to: https://github.com/wanchain/wanchain-token/blob/master/style-guide.rst\n', '\n', '\n', '\n', '//import "./StandardToken.sol";\n', '//import "./SafeMath.sol";\n', '\n', '\n', '/// @title Wanchain Token Contract\n', '/// For more information about this token sale, please visit https://wanchain.org\n', '/// @author Cathy - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="177476637f6e57607679747f767e7939786570">[email&#160;protected]</a>>\n', 'contract WanToken is StandardToken {\n', '    using SafeMath for uint;\n', '\n', '    /// Constant token specific fields\n', '    string public constant name = "WanCoin";\n', '    string public constant symbol = "WAN";\n', '    uint public constant decimals = 18;\n', '\n', '    /// Wanchain total tokens supply\n', '    uint public constant MAX_TOTAL_TOKEN_AMOUNT = 210000000 ether;\n', '\n', '    /// Fields that are only changed in constructor\n', '    /// Wanchain contribution contract\n', '    address public minter;\n', '    /// ICO start time\n', '    uint public startTime;\n', '    /// ICO end time\n', '    uint public endTime;\n', '\n', '    /// Fields that can be changed by functions\n', '    mapping (address => uint) public lockedBalances;\n', '    /*\n', '     * MODIFIERS\n', '     */\n', '\n', '    modifier onlyMinter {\n', '    \t  assert(msg.sender == minter);\n', '    \t  _;\n', '    }\n', '\n', '    modifier isLaterThan (uint x){\n', '    \t  assert(now > x);\n', '    \t  _;\n', '    }\n', '\n', '    modifier maxWanTokenAmountNotReached (uint amount){\n', '    \t  assert(totalSupply.add(amount) <= MAX_TOTAL_TOKEN_AMOUNT);\n', '    \t  _;\n', '    }\n', '\n', '    /**\n', '     * CONSTRUCTOR\n', '     *\n', '     * @dev Initialize the Wanchain Token\n', '     * @param _minter The Wanchain Contribution Contract\n', '     * @param _startTime ICO start time\n', '     * @param _endTime ICO End Time\n', '     */\n', '    function WanToken(address _minter, uint _startTime, uint _endTime){\n', '    \t  minter = _minter;\n', '    \t  startTime = _startTime;\n', '    \t  endTime = _endTime;\n', '    }\n', '\n', '    /**\n', '     * EXTERNAL FUNCTION\n', '     *\n', '     * @dev Contribution contract instance mint token\n', '     * @param receipent The destination account owned mint tokens\n', '     * @param amount The amount of mint token\n', '     * be sent to this address.\n', '     */\n', '    function mintToken(address receipent, uint amount)\n', '        external\n', '        onlyMinter\n', '        maxWanTokenAmountNotReached(amount)\n', '        returns (bool)\n', '    {\n', '      \tlockedBalances[receipent] = lockedBalances[receipent].add(amount);\n', '      \ttotalSupply = totalSupply.add(amount);\n', '      \treturn true;\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '\n', '    /// @dev Locking period has passed - Locked tokens have turned into tradeable\n', '    ///      All tokens owned by receipent will be tradeable\n', '    function claimTokens(address receipent)\n', '        public\n', '        onlyMinter\n', '    {\n', '      \tbalances[receipent] = balances[receipent].add(lockedBalances[receipent]);\n', '      \tlockedBalances[receipent] = 0;\n', '    }\n', '\n', '    /*\n', '     * CONSTANT METHODS\n', '     */\n', '    function lockedBalanceOf(address _owner) constant returns (uint balance) {\n', '        return lockedBalances[_owner];\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '/*\n', '\n', '  Copyright 2017 Wanchain Foundation.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '//                            _           _           _\n', '//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n', '//  \\ \\ /\\ / / _` | &#39;_ \\ / __| &#39;_ \\ / _` | | &#39;_ \\@/ _` |/ _ \\ \\ / /\n', '//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n', '//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n', '//\n', '//  Code style according to: https://github.com/wanchain/wanchain-token/blob/master/style-guide.rst\n', '\n', '/// @title Wanchain Contribution Contract\n', '/// ICO Rules according: https://www.wanchain.org/crowdsale\n', '/// For more information about this token sale, please visit https://wanchain.org\n', '/// @author Zane Liang - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2f554e414a43464e41486f584e414c474e464101405d48">[email&#160;protected]</a>>\n', 'contract WanchainContribution is Owned {\n', '    using SafeMath for uint;\n', '\n', '    /// Constant fields\n', '    /// Wanchain total tokens supply\n', '    uint public constant WAN_TOTAL_SUPPLY = 210000000 ether;\n', '    uint public constant MAX_CONTRIBUTION_DURATION = 3 days;\n', '\n', '    /// Exchange rates for first phase\n', '    uint public constant PRICE_RATE_FIRST = 880;\n', '    /// Exchange rates for second phase\n', '    uint public constant PRICE_RATE_SECOND = 790;\n', '    /// Exchange rates for last phase\n', '    uint public constant PRICE_RATE_LAST = 750;\n', '\n', '    /// ----------------------------------------------------------------------------------------------------\n', '    /// |                                                  |                    |                 |        |\n', '    /// |        PUBLIC SALE (PRESALE + OPEN SALE)         |      DEV TEAM      |    FOUNDATION   |  MINER |\n', '    /// |                       51%                        |         20%        |       19%       |   10%  |\n', '    /// ----------------------------------------------------------------------------------------------------\n', '      /// OPEN_SALE_STAKE + PRESALE_STAKE = 51; 51% sale for public\n', '      uint public constant OPEN_SALE_STAKE = 459;  // 45.9% for open sale\n', '      uint public constant PRESALE_STAKE = 51;     // 5.1%  for presale\n', '\n', '      // Reserved stakes\n', '      uint public constant DEV_TEAM_STAKE = 200;   // 20%\n', '      uint public constant FOUNDATION_STAKE = 190; // 19%\n', '      uint public constant MINERS_STAKE = 100;     // 10%\n', '\n', '      uint public constant DIVISOR_STAKE = 1000;\n', '\n', '      /// Holder address for presale and reserved tokens\n', '      /// TODO: change addressed before deployed to main net\n', '      address public constant PRESALE_HOLDER = 0xca8f76fd9597e5c0ea5ef0f83381c0635271cd5d;\n', '\n', '      // Addresses of Patrons\n', '      address public constant DEV_TEAM_HOLDER = 0x1631447d041f929595a9c7b0c9c0047de2e76186;\n', '      address public constant FOUNDATION_HOLDER = 0xe442408a5f2e224c92b34e251de48f5266fc38de;\n', '      address public constant MINERS_HOLDER = 0x38b195d2a18a4e60292868fa74fae619d566111e;\n', '\n', '      uint public MAX_OPEN_SOLD = WAN_TOTAL_SUPPLY * OPEN_SALE_STAKE / DIVISOR_STAKE;\n', '\n', '    /// Fields that are only changed in constructor\n', '    /// All deposited ETH will be instantly forwarded to this address.\n', '    address public wanport;\n', '    /// Contribution start time\n', '    uint public startTime;\n', '    /// Contribution end time\n', '    uint public endTime;\n', '\n', '    /// Fields that can be changed by functions\n', '    /// Accumulator for open sold tokens\n', '    uint openSoldTokens;\n', '    /// Normal sold tokens\n', '    uint normalSoldTokens;\n', '    /// The sum of reserved tokens for ICO stage 1\n', '    uint public partnerReservedSum;\n', '    /// Due to an emergency, set this to true to halt the contribution\n', '    bool public halted;\n', '    /// ERC20 compilant wanchain token contact instance\n', '    WanToken public wanToken;\n', '\n', '    /// Quota for partners\n', '    mapping (address => uint256) public partnersLimit;\n', '    /// Accumulator for partner sold\n', '    mapping (address => uint256) public partnersBought;\n', '\n', '    uint256 public normalBuyLimit = 65 ether;\n', '\n', '    /*\n', '     * EVENTS\n', '     */\n', '\n', '    event NewSale(address indexed destAddress, uint ethCost, uint gotTokens);\n', '    event PartnerAddressQuota(address indexed partnerAddress, uint quota);\n', '\n', '    /*\n', '     * MODIFIERS\n', '     */\n', '\n', '    modifier onlyWallet {\n', '        require(msg.sender == wanport);\n', '        _;\n', '    }\n', '\n', '    modifier notHalted() {\n', '        require(!halted);\n', '        _;\n', '    }\n', '\n', '    modifier initialized() {\n', '        require(address(wanport) != 0x0);\n', '        _;\n', '    }\n', '\n', '    modifier notEarlierThan(uint x) {\n', '        require(now >= x);\n', '        _;\n', '    }\n', '\n', '    modifier earlierThan(uint x) {\n', '        require(now < x);\n', '        _;\n', '    }\n', '\n', '    modifier ceilingNotReached() {\n', '        require(openSoldTokens < MAX_OPEN_SOLD);\n', '        _;\n', '    }\n', '\n', '    modifier isSaleEnded() {\n', '        require(now > endTime || openSoldTokens >= MAX_OPEN_SOLD);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * CONSTRUCTOR\n', '     *\n', '     * @dev Initialize the Wanchain contribution contract\n', '     * @param _wanport The escrow account address, all ethers will be sent to this address.\n', '     * @param _startTime ICO start time\n', '     */\n', '    function WanchainContribution(address _wanport, uint _startTime){\n', '    \trequire(_wanport != 0x0);\n', '\n', '        halted = false;\n', '    \twanport = _wanport;\n', '    \tstartTime = _startTime;\n', '    \tendTime = startTime + MAX_CONTRIBUTION_DURATION;\n', '        openSoldTokens = 0;\n', '        partnerReservedSum = 0;\n', '        normalSoldTokens = 0;\n', '        /// Create wanchain token contract instance\n', '    \twanToken = new WanToken(this,startTime, endTime);\n', '\n', '        /// Reserve tokens according wanchain ICO rules\n', '    \tuint stakeMultiplier = WAN_TOTAL_SUPPLY / DIVISOR_STAKE;\n', '\n', '    \twanToken.mintToken(PRESALE_HOLDER, PRESALE_STAKE * stakeMultiplier);\n', '        wanToken.mintToken(DEV_TEAM_HOLDER, DEV_TEAM_STAKE * stakeMultiplier);\n', '        wanToken.mintToken(FOUNDATION_HOLDER, FOUNDATION_STAKE * stakeMultiplier);\n', '        wanToken.mintToken(MINERS_HOLDER, MINERS_STAKE * stakeMultiplier);\n', '    }\n', '\n', '    /**\n', '     * Fallback function\n', '     *\n', '     * @dev If anybody sends Ether directly to this  contract, consider he is getting wan token\n', '     */\n', '    function () public payable notHalted ceilingNotReached{\n', '    \tbuyWanCoin(msg.sender);\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '\n', '   function setNormalBuyLimit(uint256 limit)\n', '        public\n', '        initialized\n', '        onlyOwner\n', '        earlierThan(endTime)\n', '    {\n', '        normalBuyLimit = limit;\n', '    }\n', '\n', '    /// @dev Sets the limit for a partner address. All the partner addresses\n', '    /// will be able to get wan token during the contribution period with his own\n', '    /// specific limit.\n', '    /// This method should be called by the owner after the initialization\n', '    /// and before the contribution end.\n', '    /// @param setPartnerAddress Partner address\n', '    /// @param limit Limit for the partner address,the limit is WANTOKEN, not ETHER\n', '    function setPartnerQuota(address setPartnerAddress, uint256 limit)\n', '        public\n', '        initialized\n', '        onlyOwner\n', '        earlierThan(endTime)\n', '    {\n', '        require(limit > 0 && limit <= MAX_OPEN_SOLD);\n', '        partnersLimit[setPartnerAddress] = limit;\n', '        partnerReservedSum += limit;\n', '        PartnerAddressQuota(setPartnerAddress, limit);\n', '    }\n', '\n', '    /// @dev Exchange msg.value ether to WAN for account recepient\n', '    /// @param receipient WAN tokens receiver\n', '    function buyWanCoin(address receipient)\n', '        public\n', '        payable\n', '        notHalted\n', '        initialized\n', '        ceilingNotReached\n', '        notEarlierThan(startTime)\n', '        earlierThan(endTime)\n', '        returns (bool)\n', '    {\n', '    \trequire(receipient != 0x0);\n', '    \trequire(msg.value >= 0.1 ether);\n', '\n', '    \tif (partnersLimit[receipient] > 0)\n', '    \t\tbuyFromPartner(receipient);\n', '    \telse {\n', '    \t\trequire(msg.value <= normalBuyLimit);\n', '    \t\tbuyNormal(receipient);\n', '    \t}\n', '\n', '    \treturn true;\n', '    }\n', '\n', '    /// @dev Emergency situation that requires contribution period to stop.\n', '    /// Contributing not possible anymore.\n', '    function halt() public onlyWallet{\n', '        halted = true;\n', '    }\n', '\n', '    /// @dev Emergency situation resolved.\n', '    /// Contributing becomes possible again withing the outlined restrictions.\n', '    function unHalt() public onlyWallet{\n', '        halted = false;\n', '    }\n', '\n', '    /// @dev Emergency situation\n', '    function changeWalletAddress(address newAddress) onlyWallet {\n', '        wanport = newAddress;\n', '    }\n', '\n', '    /// @return true if sale has started, false otherwise.\n', '    function saleStarted() constant returns (bool) {\n', '        return now >= startTime;\n', '    }\n', '\n', '    /// @return true if sale has ended, false otherwise.\n', '    function saleEnded() constant returns (bool) {\n', '        return now > endTime || openSoldTokens >= MAX_OPEN_SOLD;\n', '    }\n', '\n', '    /// CONSTANT METHODS\n', '    /// @dev Get current exchange rate\n', '    function priceRate() public constant returns (uint) {\n', '        // Three price tiers\n', '        if (startTime <= now && now < startTime + 1 days)\n', '            return PRICE_RATE_FIRST;\n', '        if (startTime + 1 days <= now && now < startTime + 2 days)\n', '            return PRICE_RATE_SECOND;\n', '        if (startTime + 2 days <= now && now < endTime)\n', '            return PRICE_RATE_LAST;\n', '        // Should not be called before or after contribution period\n', '        assert(false);\n', '    }\n', '\n', '\n', '    function claimTokens(address receipent)\n', '      public\n', '      isSaleEnded\n', '    {\n', '\n', '      wanToken.claimTokens(receipent);\n', '\n', '    }\n', '\n', '    /*\n', '     * INTERNAL FUNCTIONS\n', '     */\n', '\n', '    /// @dev Buy wanchain tokens by partners\n', '    function buyFromPartner(address receipient) internal {\n', '    \tuint partnerAvailable = partnersLimit[receipient].sub(partnersBought[receipient]);\n', '\t    uint allAvailable = MAX_OPEN_SOLD.sub(openSoldTokens);\n', '      partnerAvailable = partnerAvailable.min256(allAvailable);\n', '\n', '    \trequire(partnerAvailable > 0);\n', '\n', '    \tuint toFund;\n', '    \tuint toCollect;\n', '    \t(toFund,  toCollect)= costAndBuyTokens(partnerAvailable);\n', '\n', '    \tpartnersBought[receipient] = partnersBought[receipient].add(toCollect);\n', '\n', '    \tbuyCommon(receipient, toFund, toCollect);\n', '\n', '    }\n', '\n', '    /// @dev Buy wanchain token normally\n', '    function buyNormal(address receipient) internal {\n', '        // Do not allow contracts to game the system\n', '        require(!isContract(msg.sender));\n', '\n', '        // protect partner quota in stage one\n', '        uint tokenAvailable;\n', '        if(startTime <= now && now < startTime + 1 days) {\n', '            uint totalNormalAvailable = MAX_OPEN_SOLD.sub(partnerReservedSum);\n', '            tokenAvailable = totalNormalAvailable.sub(normalSoldTokens);\n', '        } else {\n', '            tokenAvailable = MAX_OPEN_SOLD.sub(openSoldTokens);\n', '        }\n', '\n', '        require(tokenAvailable > 0);\n', '\n', '    \tuint toFund;\n', '    \tuint toCollect;\n', '    \t(toFund, toCollect) = costAndBuyTokens(tokenAvailable);\n', '        buyCommon(receipient, toFund, toCollect);\n', '        normalSoldTokens += toCollect;\n', '    }\n', '\n', '    /// @dev Utility function for bug wanchain token\n', '    function buyCommon(address receipient, uint toFund, uint wanTokenCollect) internal {\n', '        require(msg.value >= toFund); // double check\n', '\n', '        if(toFund > 0) {\n', '            require(wanToken.mintToken(receipient, wanTokenCollect));\n', '            wanport.transfer(toFund);\n', '            openSoldTokens = openSoldTokens.add(wanTokenCollect);\n', '            NewSale(receipient, toFund, wanTokenCollect);\n', '        }\n', '\n', '        uint toReturn = msg.value.sub(toFund);\n', '        if(toReturn > 0) {\n', '            msg.sender.transfer(toReturn);\n', '        }\n', '    }\n', '\n', '    /// @dev Utility function for calculate available tokens and cost ethers\n', '    function costAndBuyTokens(uint availableToken) constant internal returns (uint costValue, uint getTokens){\n', '    \t// all conditions has checked in the caller functions\n', '    \tuint exchangeRate = priceRate();\n', '    \tgetTokens = exchangeRate * msg.value;\n', '\n', '    \tif(availableToken >= getTokens){\n', '    \t\tcostValue = msg.value;\n', '    \t} else {\n', '    \t\tcostValue = availableToken / exchangeRate;\n', '    \t\tgetTokens = availableToken;\n', '    \t}\n', '\n', '    }\n', '\n', '    /// @dev Internal function to determine if an address is a contract\n', '    /// @param _addr The address being queried\n', '    /// @return True if `_addr` is a contract\n', '    function isContract(address _addr) constant internal returns(bool) {\n', '        uint size;\n', '        if (_addr == 0) return false;\n', '        assembly {\n', '            size := extcodesize(_addr)\n', '        }\n', '        return size > 0;\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', '/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n', '///  later changed\n', 'contract Owned {\n', '\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    /// @notice The Constructor assigns the message sender to be `owner`\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    address public newOwner;\n', '\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner. 0x0 can be used to create\n', '    ///  an unowned neutral vault, however that cannot be undone\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '\n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'pragma solidity ^0.4.11;\n', '\n', 'contract ERC20Protocol {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint supply);\n', '    is replaced with:\n', '    uint public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '//import "./ERC20Protocol.sol";\n', '//import "./SafeMath.sol";\n', '\n', 'contract StandardToken is ERC20Protocol {\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '    * @dev Fix for the ERC20 short address attack.\n', '    */\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', "        //Default assumes totalSupply can't be over max (2^256 - 1).\n", "        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '        //Replace the if with this one instead.\n', '        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[msg.sender] >= _value) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) {\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '}\n', '\n', '\n', '\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '\n', '/*\n', '\n', '  Copyright 2017 Wanchain Foundation.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '//                            _           _           _\n', '//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n', "//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n", '//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n', '//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n', '//\n', '//  Code style according to: https://github.com/wanchain/wanchain-token/blob/master/style-guide.rst\n', '\n', '\n', '\n', '//import "./StandardToken.sol";\n', '//import "./SafeMath.sol";\n', '\n', '\n', '/// @title Wanchain Token Contract\n', '/// For more information about this token sale, please visit https://wanchain.org\n', '/// @author Cathy - <cathy@wanchain.org>\n', 'contract WanToken is StandardToken {\n', '    using SafeMath for uint;\n', '\n', '    /// Constant token specific fields\n', '    string public constant name = "WanCoin";\n', '    string public constant symbol = "WAN";\n', '    uint public constant decimals = 18;\n', '\n', '    /// Wanchain total tokens supply\n', '    uint public constant MAX_TOTAL_TOKEN_AMOUNT = 210000000 ether;\n', '\n', '    /// Fields that are only changed in constructor\n', '    /// Wanchain contribution contract\n', '    address public minter;\n', '    /// ICO start time\n', '    uint public startTime;\n', '    /// ICO end time\n', '    uint public endTime;\n', '\n', '    /// Fields that can be changed by functions\n', '    mapping (address => uint) public lockedBalances;\n', '    /*\n', '     * MODIFIERS\n', '     */\n', '\n', '    modifier onlyMinter {\n', '    \t  assert(msg.sender == minter);\n', '    \t  _;\n', '    }\n', '\n', '    modifier isLaterThan (uint x){\n', '    \t  assert(now > x);\n', '    \t  _;\n', '    }\n', '\n', '    modifier maxWanTokenAmountNotReached (uint amount){\n', '    \t  assert(totalSupply.add(amount) <= MAX_TOTAL_TOKEN_AMOUNT);\n', '    \t  _;\n', '    }\n', '\n', '    /**\n', '     * CONSTRUCTOR\n', '     *\n', '     * @dev Initialize the Wanchain Token\n', '     * @param _minter The Wanchain Contribution Contract\n', '     * @param _startTime ICO start time\n', '     * @param _endTime ICO End Time\n', '     */\n', '    function WanToken(address _minter, uint _startTime, uint _endTime){\n', '    \t  minter = _minter;\n', '    \t  startTime = _startTime;\n', '    \t  endTime = _endTime;\n', '    }\n', '\n', '    /**\n', '     * EXTERNAL FUNCTION\n', '     *\n', '     * @dev Contribution contract instance mint token\n', '     * @param receipent The destination account owned mint tokens\n', '     * @param amount The amount of mint token\n', '     * be sent to this address.\n', '     */\n', '    function mintToken(address receipent, uint amount)\n', '        external\n', '        onlyMinter\n', '        maxWanTokenAmountNotReached(amount)\n', '        returns (bool)\n', '    {\n', '      \tlockedBalances[receipent] = lockedBalances[receipent].add(amount);\n', '      \ttotalSupply = totalSupply.add(amount);\n', '      \treturn true;\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '\n', '    /// @dev Locking period has passed - Locked tokens have turned into tradeable\n', '    ///      All tokens owned by receipent will be tradeable\n', '    function claimTokens(address receipent)\n', '        public\n', '        onlyMinter\n', '    {\n', '      \tbalances[receipent] = balances[receipent].add(lockedBalances[receipent]);\n', '      \tlockedBalances[receipent] = 0;\n', '    }\n', '\n', '    /*\n', '     * CONSTANT METHODS\n', '     */\n', '    function lockedBalanceOf(address _owner) constant returns (uint balance) {\n', '        return lockedBalances[_owner];\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '/*\n', '\n', '  Copyright 2017 Wanchain Foundation.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '//                            _           _           _\n', '//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n', "//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n", '//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n', '//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n', '//\n', '//  Code style according to: https://github.com/wanchain/wanchain-token/blob/master/style-guide.rst\n', '\n', '/// @title Wanchain Contribution Contract\n', '/// ICO Rules according: https://www.wanchain.org/crowdsale\n', '/// For more information about this token sale, please visit https://wanchain.org\n', '/// @author Zane Liang - <zaneliang@wanchain.org>\n', 'contract WanchainContribution is Owned {\n', '    using SafeMath for uint;\n', '\n', '    /// Constant fields\n', '    /// Wanchain total tokens supply\n', '    uint public constant WAN_TOTAL_SUPPLY = 210000000 ether;\n', '    uint public constant MAX_CONTRIBUTION_DURATION = 3 days;\n', '\n', '    /// Exchange rates for first phase\n', '    uint public constant PRICE_RATE_FIRST = 880;\n', '    /// Exchange rates for second phase\n', '    uint public constant PRICE_RATE_SECOND = 790;\n', '    /// Exchange rates for last phase\n', '    uint public constant PRICE_RATE_LAST = 750;\n', '\n', '    /// ----------------------------------------------------------------------------------------------------\n', '    /// |                                                  |                    |                 |        |\n', '    /// |        PUBLIC SALE (PRESALE + OPEN SALE)         |      DEV TEAM      |    FOUNDATION   |  MINER |\n', '    /// |                       51%                        |         20%        |       19%       |   10%  |\n', '    /// ----------------------------------------------------------------------------------------------------\n', '      /// OPEN_SALE_STAKE + PRESALE_STAKE = 51; 51% sale for public\n', '      uint public constant OPEN_SALE_STAKE = 459;  // 45.9% for open sale\n', '      uint public constant PRESALE_STAKE = 51;     // 5.1%  for presale\n', '\n', '      // Reserved stakes\n', '      uint public constant DEV_TEAM_STAKE = 200;   // 20%\n', '      uint public constant FOUNDATION_STAKE = 190; // 19%\n', '      uint public constant MINERS_STAKE = 100;     // 10%\n', '\n', '      uint public constant DIVISOR_STAKE = 1000;\n', '\n', '      /// Holder address for presale and reserved tokens\n', '      /// TODO: change addressed before deployed to main net\n', '      address public constant PRESALE_HOLDER = 0xca8f76fd9597e5c0ea5ef0f83381c0635271cd5d;\n', '\n', '      // Addresses of Patrons\n', '      address public constant DEV_TEAM_HOLDER = 0x1631447d041f929595a9c7b0c9c0047de2e76186;\n', '      address public constant FOUNDATION_HOLDER = 0xe442408a5f2e224c92b34e251de48f5266fc38de;\n', '      address public constant MINERS_HOLDER = 0x38b195d2a18a4e60292868fa74fae619d566111e;\n', '\n', '      uint public MAX_OPEN_SOLD = WAN_TOTAL_SUPPLY * OPEN_SALE_STAKE / DIVISOR_STAKE;\n', '\n', '    /// Fields that are only changed in constructor\n', '    /// All deposited ETH will be instantly forwarded to this address.\n', '    address public wanport;\n', '    /// Contribution start time\n', '    uint public startTime;\n', '    /// Contribution end time\n', '    uint public endTime;\n', '\n', '    /// Fields that can be changed by functions\n', '    /// Accumulator for open sold tokens\n', '    uint openSoldTokens;\n', '    /// Normal sold tokens\n', '    uint normalSoldTokens;\n', '    /// The sum of reserved tokens for ICO stage 1\n', '    uint public partnerReservedSum;\n', '    /// Due to an emergency, set this to true to halt the contribution\n', '    bool public halted;\n', '    /// ERC20 compilant wanchain token contact instance\n', '    WanToken public wanToken;\n', '\n', '    /// Quota for partners\n', '    mapping (address => uint256) public partnersLimit;\n', '    /// Accumulator for partner sold\n', '    mapping (address => uint256) public partnersBought;\n', '\n', '    uint256 public normalBuyLimit = 65 ether;\n', '\n', '    /*\n', '     * EVENTS\n', '     */\n', '\n', '    event NewSale(address indexed destAddress, uint ethCost, uint gotTokens);\n', '    event PartnerAddressQuota(address indexed partnerAddress, uint quota);\n', '\n', '    /*\n', '     * MODIFIERS\n', '     */\n', '\n', '    modifier onlyWallet {\n', '        require(msg.sender == wanport);\n', '        _;\n', '    }\n', '\n', '    modifier notHalted() {\n', '        require(!halted);\n', '        _;\n', '    }\n', '\n', '    modifier initialized() {\n', '        require(address(wanport) != 0x0);\n', '        _;\n', '    }\n', '\n', '    modifier notEarlierThan(uint x) {\n', '        require(now >= x);\n', '        _;\n', '    }\n', '\n', '    modifier earlierThan(uint x) {\n', '        require(now < x);\n', '        _;\n', '    }\n', '\n', '    modifier ceilingNotReached() {\n', '        require(openSoldTokens < MAX_OPEN_SOLD);\n', '        _;\n', '    }\n', '\n', '    modifier isSaleEnded() {\n', '        require(now > endTime || openSoldTokens >= MAX_OPEN_SOLD);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * CONSTRUCTOR\n', '     *\n', '     * @dev Initialize the Wanchain contribution contract\n', '     * @param _wanport The escrow account address, all ethers will be sent to this address.\n', '     * @param _startTime ICO start time\n', '     */\n', '    function WanchainContribution(address _wanport, uint _startTime){\n', '    \trequire(_wanport != 0x0);\n', '\n', '        halted = false;\n', '    \twanport = _wanport;\n', '    \tstartTime = _startTime;\n', '    \tendTime = startTime + MAX_CONTRIBUTION_DURATION;\n', '        openSoldTokens = 0;\n', '        partnerReservedSum = 0;\n', '        normalSoldTokens = 0;\n', '        /// Create wanchain token contract instance\n', '    \twanToken = new WanToken(this,startTime, endTime);\n', '\n', '        /// Reserve tokens according wanchain ICO rules\n', '    \tuint stakeMultiplier = WAN_TOTAL_SUPPLY / DIVISOR_STAKE;\n', '\n', '    \twanToken.mintToken(PRESALE_HOLDER, PRESALE_STAKE * stakeMultiplier);\n', '        wanToken.mintToken(DEV_TEAM_HOLDER, DEV_TEAM_STAKE * stakeMultiplier);\n', '        wanToken.mintToken(FOUNDATION_HOLDER, FOUNDATION_STAKE * stakeMultiplier);\n', '        wanToken.mintToken(MINERS_HOLDER, MINERS_STAKE * stakeMultiplier);\n', '    }\n', '\n', '    /**\n', '     * Fallback function\n', '     *\n', '     * @dev If anybody sends Ether directly to this  contract, consider he is getting wan token\n', '     */\n', '    function () public payable notHalted ceilingNotReached{\n', '    \tbuyWanCoin(msg.sender);\n', '    }\n', '\n', '    /*\n', '     * PUBLIC FUNCTIONS\n', '     */\n', '\n', '   function setNormalBuyLimit(uint256 limit)\n', '        public\n', '        initialized\n', '        onlyOwner\n', '        earlierThan(endTime)\n', '    {\n', '        normalBuyLimit = limit;\n', '    }\n', '\n', '    /// @dev Sets the limit for a partner address. All the partner addresses\n', '    /// will be able to get wan token during the contribution period with his own\n', '    /// specific limit.\n', '    /// This method should be called by the owner after the initialization\n', '    /// and before the contribution end.\n', '    /// @param setPartnerAddress Partner address\n', '    /// @param limit Limit for the partner address,the limit is WANTOKEN, not ETHER\n', '    function setPartnerQuota(address setPartnerAddress, uint256 limit)\n', '        public\n', '        initialized\n', '        onlyOwner\n', '        earlierThan(endTime)\n', '    {\n', '        require(limit > 0 && limit <= MAX_OPEN_SOLD);\n', '        partnersLimit[setPartnerAddress] = limit;\n', '        partnerReservedSum += limit;\n', '        PartnerAddressQuota(setPartnerAddress, limit);\n', '    }\n', '\n', '    /// @dev Exchange msg.value ether to WAN for account recepient\n', '    /// @param receipient WAN tokens receiver\n', '    function buyWanCoin(address receipient)\n', '        public\n', '        payable\n', '        notHalted\n', '        initialized\n', '        ceilingNotReached\n', '        notEarlierThan(startTime)\n', '        earlierThan(endTime)\n', '        returns (bool)\n', '    {\n', '    \trequire(receipient != 0x0);\n', '    \trequire(msg.value >= 0.1 ether);\n', '\n', '    \tif (partnersLimit[receipient] > 0)\n', '    \t\tbuyFromPartner(receipient);\n', '    \telse {\n', '    \t\trequire(msg.value <= normalBuyLimit);\n', '    \t\tbuyNormal(receipient);\n', '    \t}\n', '\n', '    \treturn true;\n', '    }\n', '\n', '    /// @dev Emergency situation that requires contribution period to stop.\n', '    /// Contributing not possible anymore.\n', '    function halt() public onlyWallet{\n', '        halted = true;\n', '    }\n', '\n', '    /// @dev Emergency situation resolved.\n', '    /// Contributing becomes possible again withing the outlined restrictions.\n', '    function unHalt() public onlyWallet{\n', '        halted = false;\n', '    }\n', '\n', '    /// @dev Emergency situation\n', '    function changeWalletAddress(address newAddress) onlyWallet {\n', '        wanport = newAddress;\n', '    }\n', '\n', '    /// @return true if sale has started, false otherwise.\n', '    function saleStarted() constant returns (bool) {\n', '        return now >= startTime;\n', '    }\n', '\n', '    /// @return true if sale has ended, false otherwise.\n', '    function saleEnded() constant returns (bool) {\n', '        return now > endTime || openSoldTokens >= MAX_OPEN_SOLD;\n', '    }\n', '\n', '    /// CONSTANT METHODS\n', '    /// @dev Get current exchange rate\n', '    function priceRate() public constant returns (uint) {\n', '        // Three price tiers\n', '        if (startTime <= now && now < startTime + 1 days)\n', '            return PRICE_RATE_FIRST;\n', '        if (startTime + 1 days <= now && now < startTime + 2 days)\n', '            return PRICE_RATE_SECOND;\n', '        if (startTime + 2 days <= now && now < endTime)\n', '            return PRICE_RATE_LAST;\n', '        // Should not be called before or after contribution period\n', '        assert(false);\n', '    }\n', '\n', '\n', '    function claimTokens(address receipent)\n', '      public\n', '      isSaleEnded\n', '    {\n', '\n', '      wanToken.claimTokens(receipent);\n', '\n', '    }\n', '\n', '    /*\n', '     * INTERNAL FUNCTIONS\n', '     */\n', '\n', '    /// @dev Buy wanchain tokens by partners\n', '    function buyFromPartner(address receipient) internal {\n', '    \tuint partnerAvailable = partnersLimit[receipient].sub(partnersBought[receipient]);\n', '\t    uint allAvailable = MAX_OPEN_SOLD.sub(openSoldTokens);\n', '      partnerAvailable = partnerAvailable.min256(allAvailable);\n', '\n', '    \trequire(partnerAvailable > 0);\n', '\n', '    \tuint toFund;\n', '    \tuint toCollect;\n', '    \t(toFund,  toCollect)= costAndBuyTokens(partnerAvailable);\n', '\n', '    \tpartnersBought[receipient] = partnersBought[receipient].add(toCollect);\n', '\n', '    \tbuyCommon(receipient, toFund, toCollect);\n', '\n', '    }\n', '\n', '    /// @dev Buy wanchain token normally\n', '    function buyNormal(address receipient) internal {\n', '        // Do not allow contracts to game the system\n', '        require(!isContract(msg.sender));\n', '\n', '        // protect partner quota in stage one\n', '        uint tokenAvailable;\n', '        if(startTime <= now && now < startTime + 1 days) {\n', '            uint totalNormalAvailable = MAX_OPEN_SOLD.sub(partnerReservedSum);\n', '            tokenAvailable = totalNormalAvailable.sub(normalSoldTokens);\n', '        } else {\n', '            tokenAvailable = MAX_OPEN_SOLD.sub(openSoldTokens);\n', '        }\n', '\n', '        require(tokenAvailable > 0);\n', '\n', '    \tuint toFund;\n', '    \tuint toCollect;\n', '    \t(toFund, toCollect) = costAndBuyTokens(tokenAvailable);\n', '        buyCommon(receipient, toFund, toCollect);\n', '        normalSoldTokens += toCollect;\n', '    }\n', '\n', '    /// @dev Utility function for bug wanchain token\n', '    function buyCommon(address receipient, uint toFund, uint wanTokenCollect) internal {\n', '        require(msg.value >= toFund); // double check\n', '\n', '        if(toFund > 0) {\n', '            require(wanToken.mintToken(receipient, wanTokenCollect));\n', '            wanport.transfer(toFund);\n', '            openSoldTokens = openSoldTokens.add(wanTokenCollect);\n', '            NewSale(receipient, toFund, wanTokenCollect);\n', '        }\n', '\n', '        uint toReturn = msg.value.sub(toFund);\n', '        if(toReturn > 0) {\n', '            msg.sender.transfer(toReturn);\n', '        }\n', '    }\n', '\n', '    /// @dev Utility function for calculate available tokens and cost ethers\n', '    function costAndBuyTokens(uint availableToken) constant internal returns (uint costValue, uint getTokens){\n', '    \t// all conditions has checked in the caller functions\n', '    \tuint exchangeRate = priceRate();\n', '    \tgetTokens = exchangeRate * msg.value;\n', '\n', '    \tif(availableToken >= getTokens){\n', '    \t\tcostValue = msg.value;\n', '    \t} else {\n', '    \t\tcostValue = availableToken / exchangeRate;\n', '    \t\tgetTokens = availableToken;\n', '    \t}\n', '\n', '    }\n', '\n', '    /// @dev Internal function to determine if an address is a contract\n', '    /// @param _addr The address being queried\n', '    /// @return True if `_addr` is a contract\n', '    function isContract(address _addr) constant internal returns(bool) {\n', '        uint size;\n', '        if (_addr == 0) return false;\n', '        assembly {\n', '            size := extcodesize(_addr)\n', '        }\n', '        return size > 0;\n', '    }\n', '}']
