['pragma solidity ^ 0.4.13;\n', '\n', 'contract MigrationAgent {\n', '    function migrateFrom(address _from, uint256 _value);\n', '}\n', '\n', 'contract PreArtexToken {\n', '    function balanceOf(address _owner) constant returns(uint256 balance);\n', '    mapping(address => uint) public deposits;\n', '    uint public tokenPriceUSDWEI;\n', '}\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '    address public oracle;\n', '    address public btcOracle;\n', '\n', '    function Owned() payable {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrOracle {\n', '        require(owner == msg.sender || oracle == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrBtcOracle {\n', '        require(owner == msg.sender || btcOracle == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner external {\n', '        require(_owner != 0);\n', '        newOwner = _owner;\n', '    }\n', '\n', '    function confirmOwner() external {\n', '        require(newOwner == msg.sender);\n', '        owner = newOwner;\n', '        delete newOwner;\n', '    }\n', '\n', '    function changeOracle(address _oracle) onlyOwner external {\n', '        require(_oracle != 0);\n', '        oracle = _oracle;\n', '    }\n', '\n', '    function changeBtcOracle(address _btcOracle) onlyOwner external {\n', '        require(_btcOracle != 0);\n', '        btcOracle = _btcOracle;\n', '    }\n', '}\n', '\n', 'contract KnownContract {\n', '    function transfered(address _sender, uint256 _value, bytes32[] _data) external;\n', '}\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '\n', '    function balanceOf(address who) constant returns(uint);\n', '\n', '    function transfer(address to, uint value);\n', '\n', '    function allowance(address owner, address spender) constant returns(uint);\n', '\n', '    function transferFrom(address from, address to, uint value);\n', '\n', '    function approve(address spender, uint value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', 'contract Stateful {\n', '    enum State {\n', '        Initial,\n', '        PreSale,\n', '        WaitingForSale,\n', '        Sale,\n', '        CrowdsaleCompleted,\n', '        SaleFailed\n', '    }\n', '\n', '    State public state = State.Initial;\n', '\n', '    event StateChanged(State oldState, State newState);\n', '\n', '    function setState(State newState) internal {\n', '        State oldState = state;\n', '        state = newState;\n', '        StateChanged(oldState, newState);\n', '    }\n', '}\n', '\n', 'contract Crowdsale is Owned, Stateful {\n', '\n', '    uint public etherPriceUSDWEI;\n', '    address public beneficiary;\n', '    uint public totalLimitUSDWEI;\n', '    uint public minimalSuccessUSDWEI;\n', '    uint public collectedUSDWEI;\n', '\n', '    uint public crowdsaleStartTime;\n', '    uint public crowdsaleFinishTime;\n', '\n', '    struct Investor {\n', '        uint amountTokens;\n', '        uint amountWei;\n', '    }\n', '\n', '    struct BtcDeposit {\n', '        uint amountBTCWEI;\n', '        uint btcPriceUSDWEI;\n', '        address investor;\n', '    }\n', '\n', '    mapping(bytes32 => BtcDeposit) public btcDeposits;\n', '\n', '    mapping(address => Investor) public investors;\n', '    mapping(uint => address) public investorsIter;\n', '    uint public numberOfInvestors;\n', '\n', '    mapping(uint => address) public investorsToWithdrawIter;\n', '    uint public numberOfInvestorsToWithdraw;\n', '\n', '    function Crowdsale() payable Owned() {}\n', '\n', '    //abstract methods\n', '    function emitTokens(address _investor, uint _tokenPriceUSDWEI, uint _usdwei) internal returns(uint tokensToEmit);\n', '\n', '    function emitAdditionalTokens() internal;\n', '\n', '    function burnTokens(address _address, uint _amount) internal;\n', '\n', '    function() payable crowdsaleState limitNotExceeded crowdsaleNotFinished {\n', '        uint valueWEI = msg.value;\n', '        uint valueUSDWEI = valueWEI * etherPriceUSDWEI / 1 ether;\n', '        uint tokenPriceUSDWEI = getTokenPriceUSDWEI();\n', '        if (collectedUSDWEI + valueUSDWEI > totalLimitUSDWEI) { // don&#39;t need so much ether\n', '            valueUSDWEI = totalLimitUSDWEI - collectedUSDWEI;\n', '            valueWEI = valueUSDWEI * 1 ether / etherPriceUSDWEI;\n', '            uint weiToReturn = msg.value - valueWEI;\n', '            bool isSent = msg.sender.call.gas(3000000).value(weiToReturn)();\n', '            require(isSent);\n', '            collectedUSDWEI = totalLimitUSDWEI; // to be sure!                                              \n', '        } else {\n', '            collectedUSDWEI += valueUSDWEI;\n', '        }\n', '        emitTokensFor(msg.sender, tokenPriceUSDWEI, valueUSDWEI, valueWEI);\n', '    }\n', '\n', '    function depositUSD(address _to, uint _amountUSDWEI) external onlyOwner crowdsaleState limitNotExceeded crowdsaleNotFinished {\n', '        uint tokenPriceUSDWEI = getTokenPriceUSDWEI();\n', '        collectedUSDWEI += _amountUSDWEI;\n', '        emitTokensFor(_to, tokenPriceUSDWEI, _amountUSDWEI, 0);\n', '    }\n', '\n', '    function depositBTC(address _to, uint _amountBTCWEI, uint _btcPriceUSDWEI, bytes32 _btcTxId) external onlyOwnerOrBtcOracle crowdsaleState limitNotExceeded crowdsaleNotFinished {\n', '        uint valueUSDWEI = _amountBTCWEI * _btcPriceUSDWEI / 1 ether;\n', '        uint tokenPriceUSDWEI = getTokenPriceUSDWEI();\n', '        BtcDeposit storage btcDep = btcDeposits[_btcTxId];\n', '        require(btcDep.amountBTCWEI == 0);\n', '        btcDep.amountBTCWEI = _amountBTCWEI;\n', '        btcDep.btcPriceUSDWEI = _btcPriceUSDWEI;\n', '        btcDep.investor = _to;\n', '        collectedUSDWEI += valueUSDWEI;\n', '        emitTokensFor(_to, tokenPriceUSDWEI, valueUSDWEI, 0);\n', '    }\n', '\n', '    function emitTokensFor(address _investor, uint _tokenPriceUSDWEI, uint _valueUSDWEI, uint _valueWEI) internal {\n', '        var emittedTokens = emitTokens(_investor, _tokenPriceUSDWEI, _valueUSDWEI);\n', '        Investor storage inv = investors[_investor];\n', '        if (inv.amountTokens == 0) { // new investor\n', '            investorsIter[numberOfInvestors++] = _investor;\n', '        }\n', '        inv.amountTokens += emittedTokens;\n', '        if (state == State.Sale) {\n', '            inv.amountWei += _valueWEI;\n', '        }\n', '    }\n', '\n', '    function getTokenPriceUSDWEI() internal returns(uint tokenPriceUSDWEI) {\n', '        tokenPriceUSDWEI = 0;\n', '        if (state == State.PreSale) {\n', '            tokenPriceUSDWEI = 76923076923076900;\n', '        }\n', '        if (state == State.Sale) {\n', '            if (now < crowdsaleStartTime + 1 days) {\n', '                tokenPriceUSDWEI = 86956521730000000;\n', '            } else if (now < crowdsaleStartTime + 1 weeks) {\n', '                tokenPriceUSDWEI = 90909090900000000;\n', '            } else if (now < crowdsaleStartTime + 2 weeks) {\n', '                tokenPriceUSDWEI = 95238095230000000;\n', '            } else {\n', '                tokenPriceUSDWEI = 100000000000000000;\n', '            }\n', '        }\n', '    }\n', '\n', '    function startPreSale(\n', '        address _beneficiary,\n', '        uint _etherPriceUSDWEI,\n', '        uint _totalLimitUSDWEI,\n', '        uint _crowdsaleDurationDays) external onlyOwner {\n', '        require(state == State.Initial);\n', '        crowdsaleStartTime = now;\n', '        beneficiary = _beneficiary;\n', '        etherPriceUSDWEI = _etherPriceUSDWEI;\n', '        totalLimitUSDWEI = _totalLimitUSDWEI;\n', '        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\n', '        collectedUSDWEI = 0;\n', '        setState(State.PreSale);\n', '    }\n', '\n', '    function finishPreSale() public onlyOwner {\n', '        require(state == State.PreSale);\n', '        bool isSent = beneficiary.call.gas(3000000).value(this.balance)();\n', '        require(isSent);\n', '        setState(State.WaitingForSale);\n', '    }\n', '\n', '    function startSale(\n', '        address _beneficiary,\n', '        uint _etherPriceUSDWEI,\n', '        uint _totalLimitUSDWEI,\n', '        uint _crowdsaleDurationDays,\n', '        uint _minimalSuccessUSDWEI) external onlyOwner {\n', '\n', '        require(state == State.WaitingForSale);\n', '        crowdsaleStartTime = now;\n', '        beneficiary = _beneficiary;\n', '        etherPriceUSDWEI = _etherPriceUSDWEI;\n', '        totalLimitUSDWEI = _totalLimitUSDWEI;\n', '        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\n', '        minimalSuccessUSDWEI = _minimalSuccessUSDWEI;\n', '        collectedUSDWEI = 0;\n', '        setState(State.Sale);\n', '    }\n', '\n', '    function failSale(uint _investorsToProcess) public {\n', '        require(state == State.Sale);\n', '        require(now >= crowdsaleFinishTime && collectedUSDWEI < minimalSuccessUSDWEI);\n', '        while (_investorsToProcess > 0 && numberOfInvestors > 0) {\n', '            address addr = investorsIter[--numberOfInvestors];\n', '            Investor memory inv = investors[addr];\n', '            burnTokens(addr, inv.amountTokens);\n', '            --_investorsToProcess;\n', '            delete investorsIter[numberOfInvestors];\n', '\n', '            investorsToWithdrawIter[numberOfInvestorsToWithdraw] = addr;\n', '            numberOfInvestorsToWithdraw++;\n', '        }\n', '        if (numberOfInvestors > 0) {\n', '            return;\n', '        }\n', '        setState(State.SaleFailed);\n', '    }\n', '\n', '    function completeSale(uint _investorsToProcess) public onlyOwner {\n', '        require(state == State.Sale);\n', '        require(collectedUSDWEI >= minimalSuccessUSDWEI);\n', '\n', '        while (_investorsToProcess > 0 && numberOfInvestors > 0) {\n', '            --numberOfInvestors;\n', '            --_investorsToProcess;\n', '            delete investors[investorsIter[numberOfInvestors]];\n', '            delete investorsIter[numberOfInvestors];\n', '        }\n', '\n', '        if (numberOfInvestors > 0) {\n', '            return;\n', '        }\n', '\n', '        emitAdditionalTokens();\n', '\n', '        bool isSent = beneficiary.call.gas(3000000).value(this.balance)();\n', '        require(isSent);\n', '        setState(State.CrowdsaleCompleted);\n', '    }\n', '\n', '    function setEtherPriceUSDWEI(uint _etherPriceUSDWEI) external onlyOwnerOrOracle {\n', '        etherPriceUSDWEI = _etherPriceUSDWEI;\n', '    }\n', '\n', '    function setBeneficiary(address _beneficiary) external onlyOwner() {\n', '        require(_beneficiary != 0);\n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '    // This function must be called by token holder in case of crowdsale failed\n', '    function withdrawBack() external saleFailedState {\n', '        returnInvestmentsToInternal(msg.sender);\n', '    }\n', '\n', '    function returnInvestments(uint _investorsToProcess) public saleFailedState {\n', '        while (_investorsToProcess > 0 && numberOfInvestorsToWithdraw > 0) {\n', '            address addr = investorsToWithdrawIter[--numberOfInvestorsToWithdraw];\n', '            delete investorsToWithdrawIter[numberOfInvestorsToWithdraw];\n', '            --_investorsToProcess;\n', '            returnInvestmentsToInternal(addr);\n', '        }\n', '    }\n', '\n', '    function returnInvestmentsTo(address _to) public saleFailedState {\n', '        returnInvestmentsToInternal(_to);\n', '    }\n', '\n', '    function returnInvestmentsToInternal(address _to) internal {\n', '        Investor memory inv = investors[_to];\n', '        uint value = inv.amountWei;\n', '        if (value > 0) {\n', '            delete investors[_to];\n', '            require(_to.call.gas(3000000).value(value)());\n', '        }\n', '    }\n', '\n', '    function withdrawFunds(uint _value) public onlyOwner {\n', '        require(state == State.PreSale || (state == State.Sale && collectedUSDWEI > minimalSuccessUSDWEI));\n', '        if (_value == 0) {\n', '            _value = this.balance;\n', '        }\n', '        bool isSent = beneficiary.call.gas(3000000).value(_value)();\n', '        require(isSent);\n', '    }\n', '\n', '    modifier crowdsaleNotFinished {\n', '        require(now < crowdsaleFinishTime);\n', '        _;\n', '    }\n', '\n', '    modifier limitNotExceeded {\n', '        require(collectedUSDWEI < totalLimitUSDWEI);\n', '        _;\n', '    }\n', '\n', '    modifier crowdsaleState {\n', '        require(state == State.PreSale || state == State.Sale);\n', '        _;\n', '    }\n', '\n', '    modifier saleFailedState {\n', '        require(state == State.SaleFailed);\n', '        _;\n', '    }\n', '\n', '    modifier completedSaleState {\n', '        require(state == State.CrowdsaleCompleted);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Token is Crowdsale, ERC20 {\n', '\n', '    mapping(address => uint) internal balances;\n', '    mapping(address => mapping(address => uint)) public allowed;\n', '    uint8 public constant decimals = 8;\n', '\n', '\n', '    function Token() payable Crowdsale() {}\n', '\n', '    function balanceOf(address who) constant returns(uint) {\n', '        return balances[who];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public completedSaleState onlyPayloadSize(2 * 32) {\n', '        require(balances[msg.sender] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]); // overflow\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public completedSaleState onlyPayloadSize(3 * 32) {\n', '        require(balances[_from] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]); // overflow\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public completedSaleState {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant completedSaleState returns(uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract MigratableToken is Token {\n', '\n', '    function MigratableToken() payable Token() {}\n', '\n', '    address public migrationAgent;\n', '    uint public totalMigrated;\n', '    address public migrationHost;\n', '    mapping(address => bool) migratedInvestors;\n', '\n', '    event Migrated(address indexed from, address indexed to, uint value);\n', '\n', '    function setMigrationHost(address _address) external onlyOwner {\n', '        require(_address != 0);\n', '        migrationHost = _address;\n', '    }\n', '\n', '    //manual migration by owner\n', '    function migrateInvestorFromHost(address _address) external onlyOwner {\n', '        require(migrationHost != 0 &&\n', '            state != State.SaleFailed &&\n', '            etherPriceUSDWEI != 0 &&\n', '            migratedInvestors[_address] == false);\n', '\n', '        PreArtexToken preArtex = PreArtexToken(migrationHost);\n', '        uint tokensDecimals = preArtex.balanceOf(_address);\n', '        require(tokensDecimals > 0);\n', '        uint depositWEI = preArtex.deposits(_address);\n', '        uint preArtexTokenPriceUSDWEI = preArtex.tokenPriceUSDWEI();\n', '        uint tokensToTransfer = 0;\n', '\n', '        if (tokensDecimals != 0 && depositWEI == 0) {\n', '            tokensToTransfer = tokensDecimals * 140 / 130;\n', '        } else {\n', '            var preArtexEtherPriceUSDWEI = ((tokensDecimals * preArtexTokenPriceUSDWEI * 1 ether) / (depositWEI * (10 ** uint(decimals))));\n', '            if (etherPriceUSDWEI > preArtexEtherPriceUSDWEI) {\n', '                tokensToTransfer = (tokensDecimals * etherPriceUSDWEI * 140) / (preArtexEtherPriceUSDWEI * 130);\n', '            } else {\n', '                tokensToTransfer = tokensDecimals * 140 / 130;\n', '            }\n', '        }\n', '\n', '        balances[_address] = tokensToTransfer;\n', '        totalSupply += tokensToTransfer;\n', '        migratedInvestors[_address] = true;\n', '\n', '        if (state != State.CrowdsaleCompleted) {\n', '            Investor storage inv = investors[_address];\n', '            investorsIter[numberOfInvestors++] = _address;\n', '            inv.amountTokens += tokensToTransfer;\n', '        }\n', '\n', '        Transfer(this, _address, tokensToTransfer);\n', '    }\n', '\n', '    //migration by investor\n', '    function migrate() external {\n', '        require(migrationAgent != 0);\n', '        uint value = balances[msg.sender];\n', '        balances[msg.sender] -= value;\n', '        Transfer(msg.sender, this, value);\n', '        totalSupply -= value;\n', '        totalMigrated += value;\n', '        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\n', '        Migrated(msg.sender, migrationAgent, value);\n', '    }\n', '\n', '    function setMigrationAgent(address _agent) external onlyOwner {\n', '        require(migrationAgent == 0);\n', '        migrationAgent = _agent;\n', '    }\n', '}\n', '\n', 'contract ArtexToken is MigratableToken {\n', '\n', '    string public constant symbol = "ART";\n', '\n', '    string public constant name = "Artex Token";\n', '\n', '    mapping(address => bool) public allowedContracts;\n', '\n', '    function ArtexToken() payable MigratableToken() {}\n', '\n', '    function emitTokens(address _investor, uint _tokenPriceUSDWEI, uint _valueUSDWEI) internal returns(uint tokensToEmit) {\n', '        tokensToEmit = (_valueUSDWEI * (10 ** uint(decimals))) / _tokenPriceUSDWEI;\n', '        require(balances[_investor] + tokensToEmit > balances[_investor]); // overflow\n', '        require(tokensToEmit > 0);\n', '        balances[_investor] += tokensToEmit;\n', '        totalSupply += tokensToEmit;\n', '        Transfer(this, _investor, tokensToEmit);\n', '    }\n', '\n', '    function emitAdditionalTokens() internal {\n', '        uint tokensToEmit = totalSupply * 100 / 74 - totalSupply;\n', '        require(balances[beneficiary] + tokensToEmit > balances[beneficiary]); // overflow\n', '        require(tokensToEmit > 0);\n', '        balances[beneficiary] += tokensToEmit;\n', '        totalSupply += tokensToEmit;\n', '        Transfer(this, beneficiary, tokensToEmit);\n', '    }\n', '\n', '    function burnTokens(address _address, uint _amount) internal {\n', '        balances[_address] -= _amount;\n', '        totalSupply -= _amount;\n', '        Transfer(_address, this, _amount);\n', '    }\n', '\n', '    function addAllowedContract(address _address) external onlyOwner {\n', '        require(_address != 0);\n', '        allowedContracts[_address] = true;\n', '    }\n', '\n', '    function removeAllowedContract(address _address) external onlyOwner {\n', '        require(_address != 0);\n', '        delete allowedContracts[_address];\n', '    }\n', '\n', '    function transferToKnownContract(address _to, uint256 _value, bytes32[] _data) external onlyAllowedContracts(_to) {\n', '        var knownContract = KnownContract(_to);\n', '        transfer(_to, _value);\n', '        knownContract.transfered(msg.sender, _value, _data);\n', '    }\n', '\n', '    modifier onlyAllowedContracts(address _address) {\n', '        require(allowedContracts[_address] == true);\n', '        _;\n', '    }\n', '}']