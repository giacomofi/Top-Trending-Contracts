['library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', '\n', 'contract Lockable is Owned{\n', '\n', '  uint256 public lockedUntilBlock;\n', '\n', '  event ContractLocked(uint256 _untilBlock, string _reason);\n', '\n', '  modifier lockAffected {\n', '      require(block.number > lockedUntilBlock);\n', '      _;\n', '  }\n', '\n', '  function lockFromSelf(uint256 _untilBlock, string _reason) internal {\n', '    lockedUntilBlock = _untilBlock;\n', '    ContractLocked(_untilBlock, _reason);\n', '  }\n', '\n', '\n', '  function lockUntil(uint256 _untilBlock, string _reason) onlyOwner {\n', '    lockedUntilBlock = _untilBlock;\n', '    ContractLocked(_untilBlock, _reason);\n', '  }\n', '}\n', '\n', 'contract ReentrancyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', 'contract IMintableToken {\n', '  function mintTokens(address _to, uint256 _amount){}\n', '}\n', 'contract IERC20Token {\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '  function approve(address _spender, uint256 _value) returns (bool success) {}\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', 'contract ItokenRecipient {\n', '  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\n', '}\n', 'contract IToken {\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '  function mintTokens(address _to, uint256 _amount) {}\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Crowdsale is ReentrancyHandlingContract, Owned{\n', '\n', '  struct ContributorData{\n', '    uint contributionAmount;\n', '    uint tokensIssued;\n', '  }\n', '\n', '  mapping(address => ContributorData) public contributorList;\n', '  uint nextContributorIndex;\n', '  mapping(uint => address) contributorIndexes;\n', '\n', '  state public crowdsaleState = state.pendingStart;\n', '  enum state { pendingStart, crowdsale, crowdsaleEnded }\n', '\n', '  uint public crowdsaleStartBlock;\n', '  uint public crowdsaleEndedBlock;\n', '\n', '  event CrowdsaleStarted(uint blockNumber);\n', '  event CrowdsaleEnded(uint blockNumber);\n', '  event ErrorSendingETH(address to, uint amount);\n', '  event MinCapReached(uint blockNumber);\n', '  event MaxCapReached(uint blockNumber);\n', '\n', '  address tokenAddress = 0x0;\n', '  uint decimals = 18;\n', '\n', '  uint ethToTokenConversion;\n', '\n', '  uint public minCap;\n', '  uint public maxCap;\n', '  uint public ethRaised;\n', '  uint public tokenTotalSupply = 200000000 * 10**decimals;\n', '\n', '  address public multisigAddress;\n', '  uint blocksInADay;\n', '\n', '  uint nextContributorToClaim;\n', '  mapping(address => bool) hasClaimedEthWhenFail;\n', '\n', '  uint crowdsaleTokenCap =          120000000 * 10**decimals;\n', '  uint foundersAndTeamTokens =       32000000 * 10**decimals;\n', '  uint advisorAndAmbassadorTokens =  16000000 * 10**decimals;\n', '  uint investorTokens =               8000000 * 10**decimals;\n', '  uint viberateContributorTokens =   10000000 * 10**decimals;\n', '  uint futurePartnerTokens =         14000000 * 10**decimals;\n', '  bool foundersAndTeamTokensClaimed = false;\n', '  bool advisorAndAmbassadorTokensClaimed = false;\n', '  bool investorTokensClaimed = false;\n', '  bool viberateContributorTokensClaimed = false;\n', '  bool futurePartnerTokensClaimed = false;\n', '\n', '  //\n', '  // Unnamed function that runs when eth is sent to the contract\n', '  //\n', '  function() noReentrancy payable{\n', '    require(msg.value != 0);                        // Throw if value is 0\n', '    require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\n', '\n', '    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\n', '\n', '    if(crowdsaleState == state.crowdsale){\n', '      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\n', '    }\n', '    else{\n', '      refundTransaction(stateChanged);              // Set state and return funds or throw\n', '    }\n', '  }\n', '\n', '  //\n', '  // Check crowdsale state and calibrate it\n', '  //\n', '  function checkCrowdsaleState() internal returns (bool){\n', '    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded){                         // Check if max cap is reached\n', '      crowdsaleState = state.crowdsaleEnded;\n', '      CrowdsaleEnded(block.number);                                                             // Raise event\n', '      return true;\n', '    }\n', '\n', '    if(block.number > crowdsaleStartBlock && block.number <= crowdsaleEndedBlock){        // Check if we are in crowdsale state\n', '      if (crowdsaleState != state.crowdsale){                                                   // Check if state needs to be changed\n', '        crowdsaleState = state.crowdsale;                                                       // Set new state\n', '        CrowdsaleStarted(block.number);                                                         // Raise event\n', '        return true;\n', '      }\n', '    }else{\n', '      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock){        // Check if crowdsale is over\n', '        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\n', '        CrowdsaleEnded(block.number);                                                           // Raise event\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '  //\n', '  // Decide if throw or only return ether\n', '  //\n', '  function refundTransaction(bool _stateChanged) internal{\n', '    if (_stateChanged){\n', '      msg.sender.transfer(msg.value);\n', '    }else{\n', '      revert();\n', '    }\n', '  }\n', '\n', '  //\n', '  //\n', '  //\n', '  function calculateEthToVibe(uint _eth, uint _blockNumber) constant returns(uint) {\n', '    if (_blockNumber < crowdsaleStartBlock) return _eth * 3158;\n', '    if (_blockNumber >= crowdsaleStartBlock && _blockNumber < crowdsaleStartBlock + blocksInADay * 2) return _eth * 3158;\n', '    if (_blockNumber >= crowdsaleStartBlock + blocksInADay * 2 && _blockNumber < crowdsaleStartBlock + blocksInADay * 7) return _eth * 3074;\n', '    if (_blockNumber >= crowdsaleStartBlock + blocksInADay * 7 && _blockNumber < crowdsaleStartBlock + blocksInADay * 14) return _eth * 2989;\n', '    if (_blockNumber >= crowdsaleStartBlock + blocksInADay * 14 && _blockNumber < crowdsaleStartBlock + blocksInADay * 21) return _eth * 2905;\n', '    if (_blockNumber >= crowdsaleStartBlock + blocksInADay * 21 ) return _eth * 2820;\n', '  }\n', '\n', '  //\n', '  // Issue tokens and return if there is overflow\n', '  //\n', '  function processTransaction(address _contributor, uint _amount) internal{\n', '    uint contributionAmount = _amount;\n', '    uint returnAmount = 0;\n', '\n', '    if (_amount > (maxCap - ethRaised)){                                           // Check if max contribution is lower than _amount sent\n', '      contributionAmount = maxCap - ethRaised;                                     // Set that user contibutes his maximum alowed contribution\n', '      returnAmount = _amount - contributionAmount;                                 // Calculate howmuch he must get back\n', '    }\n', '\n', '    if (ethRaised + contributionAmount > minCap && minCap > ethRaised){\n', '      MinCapReached(block.number);\n', '    }\n', '\n', '    if (ethRaised + contributionAmount == maxCap && ethRaised < maxCap){\n', '      MaxCapReached(block.number);\n', '    }\n', '\n', '    if (contributorList[_contributor].contributionAmount == 0){\n', '        contributorIndexes[nextContributorIndex] = _contributor;\n', '        nextContributorIndex += 1;\n', '    }\n', '\n', '    contributorList[_contributor].contributionAmount += contributionAmount;\n', '    contributorList[_contributor].tokensIssued += contributionAmount;\n', '    ethRaised += contributionAmount;                                              // Add to eth raised\n', '\n', '    uint tokenAmount = calculateEthToVibe(contributionAmount, block.number);      // Calculate how much tokens must contributor get\n', '    if (tokenAmount > 0){\n', '      IToken(tokenAddress).mintTokens(_contributor, tokenAmount);                 // Issue new tokens\n', '      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\n', '    }\n', '    if (returnAmount != 0) _contributor.transfer(returnAmount);\n', '  }\n', '\n', '  function pushAngelInvestmentData(address _address, uint _ethContributed) onlyOwner{\n', '      assert(ethRaised + _ethContributed <= maxCap);\n', '      processTransaction(_address, _ethContributed);\n', '  }\n', '  function depositAngelInvestmentEth() payable onlyOwner {}\n', '  \n', '\n', '  //\n', '  // Method is needed for recovering tokens accedentaly sent to token address\n', '  //\n', '  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner{\n', '    IERC20Token(_tokenAddress).transfer(_to, _amount);\n', '  }\n', '\n', '  //\n', '  // withdrawEth when minimum cap is reached\n', '  //\n', '  function withdrawEth() onlyOwner{\n', '    require(this.balance != 0);\n', '    require(ethRaised >= minCap);\n', '\n', '    multisigAddress.transfer(this.balance);\n', '  }\n', '\n', '  //\n', '  // Users can claim their contribution if min cap is not raised\n', '  //\n', '  function claimEthIfFailed(){\n', '    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);    // Check if crowdsale has failed\n', '    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedBlock\n', '    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\n', '\n', '    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\n', '    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\n', '    if (!msg.sender.send(ethContributed)){                                // Refund eth\n', '      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\n', '    }\n', '  }\n', '\n', '  //\n', '  // Owner can batch return contributors contributions(eth)\n', '  //\n', '  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner{\n', '    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);                // Check if crowdsale has failed\n', '    address currentParticipantAddress;\n', '    uint contribution;\n', '    for (uint cnt = 0; cnt < _numberOfReturns; cnt++){\n', '      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\n', '      if (currentParticipantAddress == 0x0) return;                                   // Check if all the participants were compensated\n', '      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\n', '        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\n', '        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\n', '        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\n', '          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\n', '        }\n', '      }\n', '      nextContributorToClaim += 1;                                                    // Repeat\n', '    }\n', '  }\n', '\n', '  //\n', '  // If there were any issue/attach with refund owner can withraw eth at the end for manual recovery\n', '  //\n', '  function withdrawRemainingBalanceForManualRecovery() onlyOwner{\n', '    require(this.balance != 0);                                  // Check if there are any eth to claim\n', '    require(block.number > crowdsaleEndedBlock);                 // Check if crowdsale is over\n', '    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\n', '    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\n', '  }\n', '\n', '  function claimTeamTokens(address _to, uint _choice) onlyOwner{\n', '    require(crowdsaleState == state.crowdsaleEnded);\n', '    require(ethRaised >= minCap);\n', '\n', '    uint mintAmount;\n', '    if(_choice == 1){\n', '      assert(!advisorAndAmbassadorTokensClaimed);\n', '      mintAmount = advisorAndAmbassadorTokens;\n', '      advisorAndAmbassadorTokensClaimed = true;\n', '    }else if(_choice == 2){\n', '      assert(!investorTokensClaimed);\n', '      mintAmount = investorTokens;\n', '      investorTokensClaimed = true;\n', '    }else if(_choice == 3){\n', '      assert(!viberateContributorTokensClaimed);\n', '      mintAmount = viberateContributorTokens;\n', '      viberateContributorTokensClaimed = true;\n', '    }else if(_choice == 4){\n', '      assert(!futurePartnerTokensClaimed);\n', '      mintAmount = futurePartnerTokens;\n', '      futurePartnerTokensClaimed = true;\n', '    }else if(_choice == 5){\n', '      assert(!foundersAndTeamTokensClaimed);\n', '      assert(advisorAndAmbassadorTokensClaimed);\n', '      assert(investorTokensClaimed);\n', '      assert(viberateContributorTokensClaimed);\n', '      assert(futurePartnerTokensClaimed);\n', '      assert(tokenTotalSupply > IERC20Token(tokenAddress).totalSupply());\n', '      mintAmount = tokenTotalSupply - IERC20Token(tokenAddress).totalSupply();\n', '      foundersAndTeamTokensClaimed = true;\n', '    }\n', '    else{\n', '      revert();\n', '    }\n', '    IToken(tokenAddress).mintTokens(_to, mintAmount);\n', '  }\n', '\n', '\n', '  //\n', '  // Owner can set multisig address for crowdsale\n', '  //\n', '  function setMultisigAddress(address _newAddress) onlyOwner{\n', '    multisigAddress = _newAddress;\n', '  }\n', '\n', '  //\n', '  // Owner can set token address where mints will happen\n', '  //\n', '  function setToken(address _newAddress) onlyOwner{\n', '    tokenAddress = _newAddress;\n', '  }\n', '\n', '  function getTokenAddress() constant returns(address){\n', '    return tokenAddress;\n', '  }\n', '\n', '  function investorCount() constant returns(uint){\n', '    return nextContributorIndex;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ViberateCrowdsale is Crowdsale {\n', '  function ViberateCrowdsale(){\n', '\n', '    crowdsaleStartBlock = 4240935;\n', '    crowdsaleEndedBlock = 4348935;\n', '\n', '    minCap = 3546099290780000000000;\n', '    maxCap = 37993920972640000000000;\n', '\n', '    blocksInADay = 3600;\n', '\n', '  }\n', '}']