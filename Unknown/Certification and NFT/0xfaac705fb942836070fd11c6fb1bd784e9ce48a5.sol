['pragma solidity ^0.4.11;\n', '\n', '\n', 'contract Storage {\n', '    struct Crate {\n', '        mapping(bytes32 => uint256) uints;\n', '        mapping(bytes32 => address) addresses;\n', '        mapping(bytes32 => bool) bools;\n', '        mapping(address => uint256) bals;\n', '    }\n', '\n', '    mapping(bytes32 => Crate) crates;\n', '\n', '    function setUInt(bytes32 _crate, bytes32 _key, uint256 _value)  {\n', '        crates[_crate].uints[_key] = _value;\n', '    }\n', '\n', '    function getUInt(bytes32 _crate, bytes32 _key) constant returns(uint256) {\n', '        return crates[_crate].uints[_key];\n', '    }\n', '\n', '    function setAddress(bytes32 _crate, bytes32 _key, address _value)  {\n', '        crates[_crate].addresses[_key] = _value;\n', '    }\n', '\n', '    function getAddress(bytes32 _crate, bytes32 _key) constant returns(address) {\n', '        return crates[_crate].addresses[_key];\n', '    }\n', '\n', '    function setBool(bytes32 _crate, bytes32 _key, bool _value)  {\n', '        crates[_crate].bools[_key] = _value;\n', '    }\n', '\n', '    function getBool(bytes32 _crate, bytes32 _key) constant returns(bool) {\n', '        return crates[_crate].bools[_key];\n', '    }\n', '\n', '    function setBal(bytes32 _crate, address _key, uint256 _value)  {\n', '        crates[_crate].bals[_key] = _value;\n', '    }\n', '\n', '    function getBal(bytes32 _crate, address _key) constant returns(uint256) {\n', '        return crates[_crate].bals[_key];\n', '    }\n', '}\n', '\n', 'contract StorageEnabled {\n', '\n', '  // satelite contract addresses\n', '  address public storageAddr;\n', '\n', '  function StorageEnabled(address _storageAddr) {\n', '    storageAddr = _storageAddr;\n', '  }\n', '\n', '\n', '  // ############################################\n', '  // ########### NUTZ FUNCTIONS  ################\n', '  // ############################################\n', '\n', '\n', '  // all Nutz balances\n', '  function babzBalanceOf(address _owner) constant returns (uint256) {\n', '    return Storage(storageAddr).getBal(&#39;Nutz&#39;, _owner);\n', '  }\n', '  function _setBabzBalanceOf(address _owner, uint256 _newValue) internal {\n', '    Storage(storageAddr).setBal(&#39;Nutz&#39;, _owner, _newValue);\n', '  }\n', '  // active supply - sum of balances above\n', '  function activeSupply() constant returns (uint256) {\n', '    return Storage(storageAddr).getUInt(&#39;Nutz&#39;, &#39;activeSupply&#39;);\n', '  }\n', '  function _setActiveSupply(uint256 _newActiveSupply) internal {\n', '    Storage(storageAddr).setUInt(&#39;Nutz&#39;, &#39;activeSupply&#39;, _newActiveSupply);\n', '  }\n', '  // burn pool - inactive supply\n', '  function burnPool() constant returns (uint256) {\n', '    return Storage(storageAddr).getUInt(&#39;Nutz&#39;, &#39;burnPool&#39;);\n', '  }\n', '  function _setBurnPool(uint256 _newBurnPool) internal {\n', '    Storage(storageAddr).setUInt(&#39;Nutz&#39;, &#39;burnPool&#39;, _newBurnPool);\n', '  }\n', '  // power pool - inactive supply\n', '  function powerPool() constant returns (uint256) {\n', '    return Storage(storageAddr).getUInt(&#39;Nutz&#39;, &#39;powerPool&#39;);\n', '  }\n', '  function _setPowerPool(uint256 _newPowerPool) internal {\n', '    Storage(storageAddr).setUInt(&#39;Nutz&#39;, &#39;powerPool&#39;, _newPowerPool);\n', '  }\n', '\n', '\n', '\n', '\n', '\n', '  // ############################################\n', '  // ########### POWER   FUNCTIONS  #############\n', '  // ############################################\n', '\n', '  // all power balances\n', '  function powerBalanceOf(address _owner) constant returns (uint256) {\n', '    return Storage(storageAddr).getBal(&#39;Power&#39;, _owner);\n', '  }\n', '\n', '  function _setPowerBalanceOf(address _owner, uint256 _newValue) internal {\n', '    Storage(storageAddr).setBal(&#39;Power&#39;, _owner, _newValue);\n', '  }\n', '\n', '  function outstandingPower() constant returns (uint256) {\n', '    return Storage(storageAddr).getUInt(&#39;Power&#39;, &#39;outstandingPower&#39;);\n', '  }\n', '\n', '  function _setOutstandingPower(uint256 _newOutstandingPower) internal {\n', '    Storage(storageAddr).setUInt(&#39;Power&#39;, &#39;outstandingPower&#39;, _newOutstandingPower);\n', '  }\n', '\n', '  function authorizedPower() constant returns (uint256) {\n', '    return Storage(storageAddr).getUInt(&#39;Power&#39;, &#39;authorizedPower&#39;);\n', '  }\n', '\n', '  function _setAuthorizedPower(uint256 _newAuthorizedPower) internal {\n', '    Storage(storageAddr).setUInt(&#39;Power&#39;, &#39;authorizedPower&#39;, _newAuthorizedPower);\n', '  }\n', '\n', '\n', '  function downs(address _user) constant public returns (uint256 total, uint256 left, uint256 start) {\n', '    uint256 rawBytes = Storage(storageAddr).getBal(&#39;PowerDown&#39;, _user);\n', '    start = uint64(rawBytes);\n', '    left = uint96(rawBytes >> (64));\n', '    total = uint96(rawBytes >> (96 + 64));\n', '    return;\n', '  }\n', '\n', '  function _setDownRequest(address _holder, uint256 total, uint256 left, uint256 start) internal {\n', '    uint256 result = uint64(start) + (left << 64) + (total << (96 + 64));\n', '    Storage(storageAddr).setBal(&#39;PowerDown&#39;, _holder, result);\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract Governable {\n', '\n', '  // list of admins, council at first spot\n', '  address[] public admins;\n', '\n', '  function Governable() {\n', '    admins.length = 1;\n', '    admins[0] = msg.sender;\n', '  }\n', '\n', '  modifier onlyAdmins() {\n', '    bool isAdmin = false;\n', '    for (uint256 i = 0; i < admins.length; i++) {\n', '      if (msg.sender == admins[i]) {\n', '        isAdmin = true;\n', '      }\n', '    }\n', '    require(isAdmin == true);\n', '    _;\n', '  }\n', '\n', '  function addAdmin(address _admin) public onlyAdmins {\n', '    for (uint256 i = 0; i < admins.length; i++) {\n', '      require(_admin != admins[i]);\n', '    }\n', '    require(admins.length < 10);\n', '    admins[admins.length++] = _admin;\n', '  }\n', '\n', '  function removeAdmin(address _admin) public onlyAdmins {\n', '    uint256 pos = admins.length;\n', '    for (uint256 i = 0; i < admins.length; i++) {\n', '      if (_admin == admins[i]) {\n', '        pos = i;\n', '      }\n', '    }\n', '    require(pos < admins.length);\n', '    // if not last element, switch with last\n', '    if (pos < admins.length - 1) {\n', '      admins[pos] = admins[admins.length - 1];\n', '    }\n', '    // then cut off the tail\n', '    admins.length--;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Governable {\n', '\n', '  bool public paused = true;\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyAdmins whenNotPaused {\n', '    paused = true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyAdmins whenPaused {\n', '    //TODO: do some checks\n', '    paused = false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract NutzEnabled is Pausable, StorageEnabled {\n', '  using SafeMath for uint;\n', '\n', '  // satelite contract addresses\n', '  address public nutzAddr;\n', '\n', '\n', '  modifier onlyNutz() {\n', '    require(msg.sender == nutzAddr);\n', '    _;\n', '  }\n', '\n', '  function NutzEnabled(address _nutzAddr, address _storageAddr)\n', '    StorageEnabled(_storageAddr) {\n', '    nutzAddr = _nutzAddr;\n', '  }\n', '\n', '  // ############################################\n', '  // ########### NUTZ FUNCTIONS  ################\n', '  // ############################################\n', '\n', '  // total supply\n', '  function totalSupply() constant returns (uint256) {\n', '    return activeSupply().add(powerPool()).add(burnPool());\n', '  }\n', '\n', '  // allowances according to ERC20\n', '  // not written to storage, as not very critical\n', '  mapping (address => mapping (address => uint)) internal allowed;\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function approve(address _owner, address _spender, uint256 _amountBabz) public onlyNutz whenNotPaused {\n', '    require(_owner != _spender);\n', '    allowed[_owner][_spender] = _amountBabz;\n', '  }\n', '\n', '  function _transfer(address _from, address _to, uint256 _amountBabz, bytes _data) internal {\n', '    require(_to != address(this));\n', '    require(_to != address(0));\n', '    require(_amountBabz > 0);\n', '    require(_from != _to);\n', '    _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz));\n', '    _setBabzBalanceOf(_to, babzBalanceOf(_to).add(_amountBabz));\n', '  }\n', '\n', '  function transfer(address _from, address _to, uint256 _amountBabz, bytes _data) public onlyNutz whenNotPaused {\n', '    _transfer(_from, _to, _amountBabz, _data);\n', '  }\n', '\n', '  function transferFrom(address _sender, address _from, address _to, uint256 _amountBabz, bytes _data) public onlyNutz whenNotPaused {\n', '    allowed[_from][_sender] = allowed[_from][_sender].sub(_amountBabz);\n', '    _transfer(_from, _to, _amountBabz, _data);\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title PullPayment\n', ' * @dev Base contract supporting async send for pull payments.\n', ' */\n', 'contract PullPayment {\n', '\n', '  modifier onlyNutz() {\n', '      _;\n', '  }\n', '  \n', 'modifier onlyOwner() {\n', '      _;\n', '  }\n', '\n', '  modifier whenNotPaused () {_;}\n', '\n', '  function balanceOf(address _owner) constant returns (uint256 value);\n', '\n', '  function paymentOf(address _owner) constant returns (uint256 value, uint256 date) ;\n', '\n', '  /// @dev Allows to change the daily limit. Transaction has to be sent by wallet.\n', '  /// @param _dailyLimit Amount in wei.\n', '  function changeDailyLimit(uint _dailyLimit) public ;\n', '\n', '  function changeWithdrawalDate(address _owner, uint256 _newDate)  public ;\n', '\n', '  function asyncSend(address _dest) public payable ;\n', '\n', '\n', '  function withdraw() public ;\n', '\n', '  /*\n', '   * Internal functions\n', '   */\n', '  /// @dev Returns if amount is within daily limit and resets spentToday after one day.\n', '  /// @param amount Amount to withdraw.\n', '  /// @return Returns if amount is under daily limit.\n', '  function isUnderLimit(uint amount) internal returns (bool);\n', '\n', '}\n', '\n', '\n', '/**\n', ' * Nutz implements a price floor and a price ceiling on the token being\n', ' * sold. It is based of the zeppelin token contract.\n', ' */\n', 'contract Nutz {\n', '\n', '\n', '  // returns balances of active holders\n', '  function balanceOf(address _owner) constant returns (uint);\n', '\n', '  function totalSupply() constant returns (uint256);\n', '\n', '  function activeSupply() constant returns (uint256);\n', '\n', '  // return remaining allowance\n', '  // if calling return allowed[address(this)][_spender];\n', '  // returns balance of ether parked to be withdrawn\n', '  function allowance(address _owner, address _spender) constant returns (uint256);\n', '\n', '  // returns either the salePrice, or if reserve does not suffice\n', '  // for active supply, returns maxFloor\n', '  function floor() constant returns (uint256);\n', '\n', '  // returns either the salePrice, or if reserve does not suffice\n', '  // for active supply, returns maxFloor\n', '  function ceiling() constant returns (uint256);\n', '\n', '  function powerPool() constant returns (uint256);\n', '\n', '\n', '  function _checkDestination(address _from, address _to, uint256 _value, bytes _data) internal;\n', '\n', '\n', '\n', '  // ############################################\n', '  // ########### ADMIN FUNCTIONS ################\n', '  // ############################################\n', '\n', '  function powerDown(address powerAddr, address _holder, uint256 _amountBabz) public ;\n', '\n', '\n', '  function asyncSend(address _pullAddr, address _dest, uint256 _amountWei) public ;\n', '\n', '\n', '  // ############################################\n', '  // ########### PUBLIC FUNCTIONS ###############\n', '  // ############################################\n', '\n', '  function approve(address _spender, uint256 _amountBabz) public;\n', '\n', '  function transfer(address _to, uint256 _amountBabz, bytes _data) public returns (bool);\n', '\n', '  function transfer(address _to, uint256 _amountBabz) public returns (bool);\n', '\n', '  function transData(address _to, uint256 _amountBabz, bytes _data) public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _amountBabz, bytes _data) public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _amountBabz);\n', '\n', '  function () public payable;\n', '\n', '  function purchase(uint256 _price) public payable;\n', '\n', '  function sell(uint256 _price, uint256 _amountBabz);\n', '\n', '  function powerUp(uint256 _amountBabz) public;\n', '\n', '}\n', '\n', '\n', 'contract MarketEnabled is NutzEnabled {\n', '\n', '  uint256 constant INFINITY = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n', '\n', '  // address of the pull payemnt satelite\n', '  address public pullAddr;\n', '\n', '  // the Token sale mechanism parameters:\n', '  // purchasePrice is the number of NTZ received for purchase with 1 ETH\n', '  uint256 internal purchasePrice;\n', '\n', '  // floor is the number of NTZ needed, to receive 1 ETH in sell\n', '  uint256 internal salePrice;\n', '\n', '  function MarketEnabled(address _pullAddr, address _storageAddr, address _nutzAddr)\n', '    NutzEnabled(_nutzAddr, _storageAddr) {\n', '    pullAddr = _pullAddr;\n', '  }\n', '\n', '\n', '  function ceiling() constant returns (uint256) {\n', '    return purchasePrice;\n', '  }\n', '\n', '  // returns either the salePrice, or if reserve does not suffice\n', '  // for active supply, returns maxFloor\n', '  function floor() constant returns (uint256) {\n', '    if (nutzAddr.balance == 0) {\n', '      return INFINITY;\n', '    }\n', '    uint256 maxFloor = activeSupply().mul(1000000).div(nutzAddr.balance); // 1,000,000 WEI, used as price factor\n', '    // return max of maxFloor or salePrice\n', '    return maxFloor >= salePrice ? maxFloor : salePrice;\n', '  }\n', '\n', '  function moveCeiling(uint256 _newPurchasePrice) public onlyAdmins {\n', '    require(_newPurchasePrice <= salePrice);\n', '    purchasePrice = _newPurchasePrice;\n', '  }\n', '\n', '  function moveFloor(uint256 _newSalePrice) public onlyAdmins {\n', '    require(_newSalePrice >= purchasePrice);\n', '    // moveFloor fails if the administrator tries to push the floor so low\n', '    // that the sale mechanism is no longer able to buy back all tokens at\n', '    // the floor price if those funds were to be withdrawn.\n', '    if (_newSalePrice < INFINITY) {\n', '      require(nutzAddr.balance >= activeSupply().mul(1000000).div(_newSalePrice)); // 1,000,000 WEI, used as price factor\n', '    }\n', '    salePrice = _newSalePrice;\n', '  }\n', '\n', '  function purchase(address _sender, uint256 _value, uint256 _price) public onlyNutz whenNotPaused returns (uint256) {\n', '    // disable purchases if purchasePrice set to 0\n', '    require(purchasePrice > 0);\n', '    require(_price == purchasePrice);\n', '\n', '    uint256 amountBabz = purchasePrice.mul(_value).div(1000000); // 1,000,000 WEI, used as price factor\n', '    // avoid deposits that issue nothing\n', '    // might happen with very high purchase price\n', '    require(amountBabz > 0);\n', '\n', '    // make sure power pool grows proportional to economy\n', '    uint256 activeSup = activeSupply();\n', '    uint256 powPool = powerPool();\n', '    if (powPool > 0) {\n', '      uint256 powerShare = powPool.mul(amountBabz).div(activeSup.add(burnPool()));\n', '      _setPowerPool(powPool.add(powerShare));\n', '    }\n', '    _setActiveSupply(activeSup.add(amountBabz));\n', '    _setBabzBalanceOf(_sender, babzBalanceOf(_sender).add(amountBabz));\n', '    return amountBabz;\n', '  }\n', '\n', '  function sell(address _from, uint256 _price, uint256 _amountBabz) public onlyNutz whenNotPaused {\n', '    uint256 effectiveFloor = floor();\n', '    require(_amountBabz != 0);\n', '    require(effectiveFloor != INFINITY);\n', '    require(_price == effectiveFloor);\n', '\n', '    uint256 amountWei = _amountBabz.mul(1000000).div(effectiveFloor);  // 1,000,000 WEI, used as price factor\n', '    require(amountWei > 0);\n', '    // make sure power pool shrinks proportional to economy\n', '    uint256 powPool = powerPool();\n', '    uint256 activeSup = activeSupply();\n', '    if (powPool > 0) {\n', '      uint256 powerShare = powPool.mul(_amountBabz).div(activeSup);\n', '      _setPowerPool(powPool.sub(powerShare));\n', '    }\n', '    _setActiveSupply(activeSup.sub(_amountBabz));\n', '    _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz));\n', '    Nutz(nutzAddr).asyncSend(pullAddr, _from, amountWei);\n', '  }\n', '\n', '\n', '  // withdraw excessive reserve - i.e. milestones\n', '  function allocateEther(uint256 _amountWei, address _beneficiary) public onlyAdmins {\n', '    require(_amountWei > 0);\n', '    // allocateEther fails if allocating those funds would mean that the\n', '    // sale mechanism is no longer able to buy back all tokens at the floor\n', '    // price if those funds were to be withdrawn.\n', '    require(nutzAddr.balance.sub(_amountWei) >= activeSupply().mul(1000000).div(salePrice)); // 1,000,000 WEI, used as price factor\n', '    Nutz(nutzAddr).asyncSend(pullAddr, _beneficiary, _amountWei);\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract Power {\n', '\n', '\n', '\n', '  function balanceOf(address _holder) constant returns (uint256);\n', '\n', '  function totalSupply() constant returns (uint256);\n', '\n', '  function activeSupply() constant returns (uint256);\n', '\n', '\n', '  // ############################################\n', '  // ########### ADMIN FUNCTIONS ################\n', '  // ############################################\n', '\n', '  function slashPower(address _holder, uint256 _value, bytes32 _data) public ;\n', '\n', '  function powerUp(address _holder, uint256 _value) public ;\n', '\n', '  // ############################################\n', '  // ########### PUBLIC FUNCTIONS ###############\n', '  // ############################################\n', '\n', '  // registers a powerdown request\n', '  function transfer(address _to, uint256 _amountPower) public returns (bool success);\n', '\n', '  function downtime() public returns (uint256);\n', '\n', '  function downTick(address _owner) public;\n', '\n', '  function downs(address _owner) constant public returns (uint256, uint256, uint256);\n', '\n', '}\n', '\n', '\n', 'contract PowerEnabled is MarketEnabled {\n', '\n', '  // satelite contract addresses\n', '  address public powerAddr;\n', '\n', '  // maxPower is a limit of total power that can be outstanding\n', '  // maxPower has a valid value between outstandingPower and authorizedPow/2\n', '  uint256 public maxPower = 0;\n', '\n', '  // time it should take to power down\n', '  uint256 public downtime;\n', '\n', '  modifier onlyPower() {\n', '    require(msg.sender == powerAddr);\n', '    _;\n', '  }\n', '\n', '  function PowerEnabled(address _powerAddr, address _pullAddr, address _storageAddr, address _nutzAddr)\n', '    MarketEnabled(_pullAddr, _nutzAddr, _storageAddr) {\n', '    powerAddr = _powerAddr;\n', '  }\n', '\n', '  function setMaxPower(uint256 _maxPower) public onlyAdmins {\n', '    require(outstandingPower() <= _maxPower && _maxPower < authorizedPower());\n', '    maxPower = _maxPower;\n', '  }\n', '\n', '  function setDowntime(uint256 _downtime) public onlyAdmins {\n', '    downtime = _downtime;\n', '  }\n', '\n', '  // this is called when NTZ are deposited into the burn pool\n', '  function dilutePower(uint256 _amountBabz, uint256 _amountPower) public onlyAdmins {\n', '    uint256 authorizedPow = authorizedPower();\n', '    uint256 totalBabz = totalSupply();\n', '    if (authorizedPow == 0) {\n', '      // during the first capital increase, set value directly as authorized shares\n', '      _setAuthorizedPower((_amountPower > 0) ? _amountPower : _amountBabz.add(totalBabz));\n', '    } else {\n', '      // in later increases, expand authorized shares at same rate like economy\n', '      _setAuthorizedPower(authorizedPow.mul(totalBabz.add(_amountBabz)).div(totalBabz));\n', '    }\n', '    _setBurnPool(burnPool().add(_amountBabz));\n', '  }\n', '\n', '  function _slashPower(address _holder, uint256 _value, bytes32 _data) internal {\n', '    uint256 previouslyOutstanding = outstandingPower();\n', '    _setOutstandingPower(previouslyOutstanding.sub(_value));\n', '    // adjust size of power pool\n', '    uint256 powPool = powerPool();\n', '    uint256 slashingBabz = _value.mul(powPool).div(previouslyOutstanding);\n', '    _setPowerPool(powPool.sub(slashingBabz));\n', '    // put event into satelite contract\n', '    Power(powerAddr).slashPower(_holder, _value, _data);\n', '  }\n', '\n', '  function slashPower(address _holder, uint256 _value, bytes32 _data) public onlyAdmins {\n', '    _setPowerBalanceOf(_holder, powerBalanceOf(_holder).sub(_value));\n', '    _slashPower(_holder, _value, _data);\n', '  }\n', '\n', '  function slashDownRequest(uint256 _pos, address _holder, uint256 _value, bytes32 _data) public onlyAdmins {\n', '    var (total, left, start) = downs(_holder);\n', '    left = left.sub(_value);\n', '    _setDownRequest(_holder, total, left, start);\n', '    _slashPower(_holder, _value, _data);\n', '  }\n', '\n', '  // this is called when NTZ are deposited into the power pool\n', '  function powerUp(address _sender, address _from, uint256 _amountBabz) public onlyNutz whenNotPaused {\n', '    uint256 authorizedPow = authorizedPower();\n', '    require(authorizedPow != 0);\n', '    require(_amountBabz != 0);\n', '    uint256 totalBabz = totalSupply();\n', '    require(totalBabz != 0);\n', '    uint256 amountPow = _amountBabz.mul(authorizedPow).div(totalBabz);\n', '    // check pow limits\n', '    uint256 outstandingPow = outstandingPower();\n', '    require(outstandingPow.add(amountPow) <= maxPower);\n', '\n', '    if (_sender != _from) {\n', '      allowed[_from][_sender] = allowed[_from][_sender].sub(_amountBabz);\n', '    }\n', '\n', '    _setOutstandingPower(outstandingPow.add(amountPow));\n', '\n', '    uint256 powBal = powerBalanceOf(_from).add(amountPow);\n', '    require(powBal >= authorizedPow.div(10000)); // minShare = 10000\n', '    _setPowerBalanceOf(_from, powBal);\n', '    _setActiveSupply(activeSupply().sub(_amountBabz));\n', '    _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz));\n', '    _setPowerPool(powerPool().add(_amountBabz));\n', '    Power(powerAddr).powerUp(_from, amountPow);\n', '  }\n', '\n', '  function powerTotalSupply() constant returns (uint256) {\n', '    uint256 issuedPower = authorizedPower().div(2);\n', '    // return max of maxPower or issuedPower\n', '    return maxPower >= issuedPower ? maxPower : issuedPower;\n', '  }\n', '\n', '  function _vestedDown(uint256 _total, uint256 _left, uint256 _start, uint256 _now) internal constant returns (uint256) {\n', '    if (_now <= _start) {\n', '      return 0;\n', '    }\n', '    // calculate amountVested\n', '    // amountVested is amount that can be withdrawn according to time passed\n', '    uint256 timePassed = _now.sub(_start);\n', '    if (timePassed > downtime) {\n', '     timePassed = downtime;\n', '    }\n', '    uint256 amountVested = _total.mul(timePassed).div(downtime);\n', '    uint256 amountFrozen = _total.sub(amountVested);\n', '    if (_left <= amountFrozen) {\n', '      return 0;\n', '    }\n', '    return _left.sub(amountFrozen);\n', '  }\n', '\n', '  function createDownRequest(address _owner, uint256 _amountPower) public onlyPower whenNotPaused {\n', '    // prevent powering down tiny amounts\n', '    // when powering down, at least totalSupply/minShare Power should be claimed\n', '    require(_amountPower >= authorizedPower().div(10000)); // minShare = 10000;\n', '    _setPowerBalanceOf(_owner, powerBalanceOf(_owner).sub(_amountPower));\n', '\n', '    var (, left, ) = downs(_owner);\n', '    uint256 total = _amountPower.add(left);\n', '    _setDownRequest(_owner, total, total, now);\n', '  }\n', '\n', '  // executes a powerdown request\n', '  function downTick(address _holder, uint256 _now) public onlyPower whenNotPaused {\n', '    var (total, left, start) = downs(_holder);\n', '    uint256 amountPow = _vestedDown(total, left, start, _now);\n', '\n', '    // prevent power down in tiny steps\n', '    uint256 minStep = total.div(10);\n', '    require(left <= minStep || minStep <= amountPow);\n', '\n', '    // calculate token amount representing share of power\n', '    uint256 amountBabz = amountPow.mul(totalSupply()).div(authorizedPower());\n', '\n', '    // transfer power and tokens\n', '    _setOutstandingPower(outstandingPower().sub(amountPow));\n', '    left = left.sub(amountPow);\n', '    _setPowerPool(powerPool().sub(amountBabz));\n', '    _setActiveSupply(activeSupply().add(amountBabz));\n', '    _setBabzBalanceOf(_holder, babzBalanceOf(_holder).add(amountBabz));\n', '    // down request completed\n', '    if (left == 0) {\n', '      start = 0;\n', '      total = 0;\n', '    }\n', '    // TODO\n', '    _setDownRequest(_holder, total, left, start);\n', '    Nutz(nutzAddr).powerDown(powerAddr, _holder, amountBabz);\n', '  }\n', '}\n', '\n', '\n', 'contract Controller is PowerEnabled {\n', '\n', '  function Controller(address _powerAddr, address _pullAddr, address _nutzAddr, address _storageAddr) \n', '    PowerEnabled(_powerAddr, _pullAddr, _nutzAddr, _storageAddr) {\n', '  }\n', '\n', '  function setContracts(address _storageAddr, address _nutzAddr, address _powerAddr, address _pullAddr) public onlyAdmins whenPaused {\n', '    storageAddr = _storageAddr;\n', '    nutzAddr = _nutzAddr;\n', '    powerAddr = _powerAddr;\n', '    pullAddr = _pullAddr;\n', '  }\n', '\n', '  function changeDailyLimit(uint256 _dailyLimit) public onlyAdmins {\n', '    PullPayment(pullAddr).changeDailyLimit(_dailyLimit);\n', '  }\n', '\n', '  function kill(address _newController) public onlyAdmins whenPaused {\n', '    if (powerAddr != address(0)) { Ownable(powerAddr).transferOwnership(msg.sender); }\n', '    if (pullAddr != address(0)) { Ownable(pullAddr).transferOwnership(msg.sender); }\n', '    if (nutzAddr != address(0)) { Ownable(nutzAddr).transferOwnership(msg.sender); }\n', '    if (storageAddr != address(0)) { Ownable(storageAddr).transferOwnership(msg.sender); }\n', '    selfdestruct(_newController);\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '\n', 'contract Storage {\n', '    struct Crate {\n', '        mapping(bytes32 => uint256) uints;\n', '        mapping(bytes32 => address) addresses;\n', '        mapping(bytes32 => bool) bools;\n', '        mapping(address => uint256) bals;\n', '    }\n', '\n', '    mapping(bytes32 => Crate) crates;\n', '\n', '    function setUInt(bytes32 _crate, bytes32 _key, uint256 _value)  {\n', '        crates[_crate].uints[_key] = _value;\n', '    }\n', '\n', '    function getUInt(bytes32 _crate, bytes32 _key) constant returns(uint256) {\n', '        return crates[_crate].uints[_key];\n', '    }\n', '\n', '    function setAddress(bytes32 _crate, bytes32 _key, address _value)  {\n', '        crates[_crate].addresses[_key] = _value;\n', '    }\n', '\n', '    function getAddress(bytes32 _crate, bytes32 _key) constant returns(address) {\n', '        return crates[_crate].addresses[_key];\n', '    }\n', '\n', '    function setBool(bytes32 _crate, bytes32 _key, bool _value)  {\n', '        crates[_crate].bools[_key] = _value;\n', '    }\n', '\n', '    function getBool(bytes32 _crate, bytes32 _key) constant returns(bool) {\n', '        return crates[_crate].bools[_key];\n', '    }\n', '\n', '    function setBal(bytes32 _crate, address _key, uint256 _value)  {\n', '        crates[_crate].bals[_key] = _value;\n', '    }\n', '\n', '    function getBal(bytes32 _crate, address _key) constant returns(uint256) {\n', '        return crates[_crate].bals[_key];\n', '    }\n', '}\n', '\n', 'contract StorageEnabled {\n', '\n', '  // satelite contract addresses\n', '  address public storageAddr;\n', '\n', '  function StorageEnabled(address _storageAddr) {\n', '    storageAddr = _storageAddr;\n', '  }\n', '\n', '\n', '  // ############################################\n', '  // ########### NUTZ FUNCTIONS  ################\n', '  // ############################################\n', '\n', '\n', '  // all Nutz balances\n', '  function babzBalanceOf(address _owner) constant returns (uint256) {\n', "    return Storage(storageAddr).getBal('Nutz', _owner);\n", '  }\n', '  function _setBabzBalanceOf(address _owner, uint256 _newValue) internal {\n', "    Storage(storageAddr).setBal('Nutz', _owner, _newValue);\n", '  }\n', '  // active supply - sum of balances above\n', '  function activeSupply() constant returns (uint256) {\n', "    return Storage(storageAddr).getUInt('Nutz', 'activeSupply');\n", '  }\n', '  function _setActiveSupply(uint256 _newActiveSupply) internal {\n', "    Storage(storageAddr).setUInt('Nutz', 'activeSupply', _newActiveSupply);\n", '  }\n', '  // burn pool - inactive supply\n', '  function burnPool() constant returns (uint256) {\n', "    return Storage(storageAddr).getUInt('Nutz', 'burnPool');\n", '  }\n', '  function _setBurnPool(uint256 _newBurnPool) internal {\n', "    Storage(storageAddr).setUInt('Nutz', 'burnPool', _newBurnPool);\n", '  }\n', '  // power pool - inactive supply\n', '  function powerPool() constant returns (uint256) {\n', "    return Storage(storageAddr).getUInt('Nutz', 'powerPool');\n", '  }\n', '  function _setPowerPool(uint256 _newPowerPool) internal {\n', "    Storage(storageAddr).setUInt('Nutz', 'powerPool', _newPowerPool);\n", '  }\n', '\n', '\n', '\n', '\n', '\n', '  // ############################################\n', '  // ########### POWER   FUNCTIONS  #############\n', '  // ############################################\n', '\n', '  // all power balances\n', '  function powerBalanceOf(address _owner) constant returns (uint256) {\n', "    return Storage(storageAddr).getBal('Power', _owner);\n", '  }\n', '\n', '  function _setPowerBalanceOf(address _owner, uint256 _newValue) internal {\n', "    Storage(storageAddr).setBal('Power', _owner, _newValue);\n", '  }\n', '\n', '  function outstandingPower() constant returns (uint256) {\n', "    return Storage(storageAddr).getUInt('Power', 'outstandingPower');\n", '  }\n', '\n', '  function _setOutstandingPower(uint256 _newOutstandingPower) internal {\n', "    Storage(storageAddr).setUInt('Power', 'outstandingPower', _newOutstandingPower);\n", '  }\n', '\n', '  function authorizedPower() constant returns (uint256) {\n', "    return Storage(storageAddr).getUInt('Power', 'authorizedPower');\n", '  }\n', '\n', '  function _setAuthorizedPower(uint256 _newAuthorizedPower) internal {\n', "    Storage(storageAddr).setUInt('Power', 'authorizedPower', _newAuthorizedPower);\n", '  }\n', '\n', '\n', '  function downs(address _user) constant public returns (uint256 total, uint256 left, uint256 start) {\n', "    uint256 rawBytes = Storage(storageAddr).getBal('PowerDown', _user);\n", '    start = uint64(rawBytes);\n', '    left = uint96(rawBytes >> (64));\n', '    total = uint96(rawBytes >> (96 + 64));\n', '    return;\n', '  }\n', '\n', '  function _setDownRequest(address _holder, uint256 total, uint256 left, uint256 start) internal {\n', '    uint256 result = uint64(start) + (left << 64) + (total << (96 + 64));\n', "    Storage(storageAddr).setBal('PowerDown', _holder, result);\n", '  }\n', '\n', '}\n', '\n', '\n', 'contract Governable {\n', '\n', '  // list of admins, council at first spot\n', '  address[] public admins;\n', '\n', '  function Governable() {\n', '    admins.length = 1;\n', '    admins[0] = msg.sender;\n', '  }\n', '\n', '  modifier onlyAdmins() {\n', '    bool isAdmin = false;\n', '    for (uint256 i = 0; i < admins.length; i++) {\n', '      if (msg.sender == admins[i]) {\n', '        isAdmin = true;\n', '      }\n', '    }\n', '    require(isAdmin == true);\n', '    _;\n', '  }\n', '\n', '  function addAdmin(address _admin) public onlyAdmins {\n', '    for (uint256 i = 0; i < admins.length; i++) {\n', '      require(_admin != admins[i]);\n', '    }\n', '    require(admins.length < 10);\n', '    admins[admins.length++] = _admin;\n', '  }\n', '\n', '  function removeAdmin(address _admin) public onlyAdmins {\n', '    uint256 pos = admins.length;\n', '    for (uint256 i = 0; i < admins.length; i++) {\n', '      if (_admin == admins[i]) {\n', '        pos = i;\n', '      }\n', '    }\n', '    require(pos < admins.length);\n', '    // if not last element, switch with last\n', '    if (pos < admins.length - 1) {\n', '      admins[pos] = admins[admins.length - 1];\n', '    }\n', '    // then cut off the tail\n', '    admins.length--;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Governable {\n', '\n', '  bool public paused = true;\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyAdmins whenNotPaused {\n', '    paused = true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyAdmins whenPaused {\n', '    //TODO: do some checks\n', '    paused = false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract NutzEnabled is Pausable, StorageEnabled {\n', '  using SafeMath for uint;\n', '\n', '  // satelite contract addresses\n', '  address public nutzAddr;\n', '\n', '\n', '  modifier onlyNutz() {\n', '    require(msg.sender == nutzAddr);\n', '    _;\n', '  }\n', '\n', '  function NutzEnabled(address _nutzAddr, address _storageAddr)\n', '    StorageEnabled(_storageAddr) {\n', '    nutzAddr = _nutzAddr;\n', '  }\n', '\n', '  // ############################################\n', '  // ########### NUTZ FUNCTIONS  ################\n', '  // ############################################\n', '\n', '  // total supply\n', '  function totalSupply() constant returns (uint256) {\n', '    return activeSupply().add(powerPool()).add(burnPool());\n', '  }\n', '\n', '  // allowances according to ERC20\n', '  // not written to storage, as not very critical\n', '  mapping (address => mapping (address => uint)) internal allowed;\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint256) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  function approve(address _owner, address _spender, uint256 _amountBabz) public onlyNutz whenNotPaused {\n', '    require(_owner != _spender);\n', '    allowed[_owner][_spender] = _amountBabz;\n', '  }\n', '\n', '  function _transfer(address _from, address _to, uint256 _amountBabz, bytes _data) internal {\n', '    require(_to != address(this));\n', '    require(_to != address(0));\n', '    require(_amountBabz > 0);\n', '    require(_from != _to);\n', '    _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz));\n', '    _setBabzBalanceOf(_to, babzBalanceOf(_to).add(_amountBabz));\n', '  }\n', '\n', '  function transfer(address _from, address _to, uint256 _amountBabz, bytes _data) public onlyNutz whenNotPaused {\n', '    _transfer(_from, _to, _amountBabz, _data);\n', '  }\n', '\n', '  function transferFrom(address _sender, address _from, address _to, uint256 _amountBabz, bytes _data) public onlyNutz whenNotPaused {\n', '    allowed[_from][_sender] = allowed[_from][_sender].sub(_amountBabz);\n', '    _transfer(_from, _to, _amountBabz, _data);\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title PullPayment\n', ' * @dev Base contract supporting async send for pull payments.\n', ' */\n', 'contract PullPayment {\n', '\n', '  modifier onlyNutz() {\n', '      _;\n', '  }\n', '  \n', 'modifier onlyOwner() {\n', '      _;\n', '  }\n', '\n', '  modifier whenNotPaused () {_;}\n', '\n', '  function balanceOf(address _owner) constant returns (uint256 value);\n', '\n', '  function paymentOf(address _owner) constant returns (uint256 value, uint256 date) ;\n', '\n', '  /// @dev Allows to change the daily limit. Transaction has to be sent by wallet.\n', '  /// @param _dailyLimit Amount in wei.\n', '  function changeDailyLimit(uint _dailyLimit) public ;\n', '\n', '  function changeWithdrawalDate(address _owner, uint256 _newDate)  public ;\n', '\n', '  function asyncSend(address _dest) public payable ;\n', '\n', '\n', '  function withdraw() public ;\n', '\n', '  /*\n', '   * Internal functions\n', '   */\n', '  /// @dev Returns if amount is within daily limit and resets spentToday after one day.\n', '  /// @param amount Amount to withdraw.\n', '  /// @return Returns if amount is under daily limit.\n', '  function isUnderLimit(uint amount) internal returns (bool);\n', '\n', '}\n', '\n', '\n', '/**\n', ' * Nutz implements a price floor and a price ceiling on the token being\n', ' * sold. It is based of the zeppelin token contract.\n', ' */\n', 'contract Nutz {\n', '\n', '\n', '  // returns balances of active holders\n', '  function balanceOf(address _owner) constant returns (uint);\n', '\n', '  function totalSupply() constant returns (uint256);\n', '\n', '  function activeSupply() constant returns (uint256);\n', '\n', '  // return remaining allowance\n', '  // if calling return allowed[address(this)][_spender];\n', '  // returns balance of ether parked to be withdrawn\n', '  function allowance(address _owner, address _spender) constant returns (uint256);\n', '\n', '  // returns either the salePrice, or if reserve does not suffice\n', '  // for active supply, returns maxFloor\n', '  function floor() constant returns (uint256);\n', '\n', '  // returns either the salePrice, or if reserve does not suffice\n', '  // for active supply, returns maxFloor\n', '  function ceiling() constant returns (uint256);\n', '\n', '  function powerPool() constant returns (uint256);\n', '\n', '\n', '  function _checkDestination(address _from, address _to, uint256 _value, bytes _data) internal;\n', '\n', '\n', '\n', '  // ############################################\n', '  // ########### ADMIN FUNCTIONS ################\n', '  // ############################################\n', '\n', '  function powerDown(address powerAddr, address _holder, uint256 _amountBabz) public ;\n', '\n', '\n', '  function asyncSend(address _pullAddr, address _dest, uint256 _amountWei) public ;\n', '\n', '\n', '  // ############################################\n', '  // ########### PUBLIC FUNCTIONS ###############\n', '  // ############################################\n', '\n', '  function approve(address _spender, uint256 _amountBabz) public;\n', '\n', '  function transfer(address _to, uint256 _amountBabz, bytes _data) public returns (bool);\n', '\n', '  function transfer(address _to, uint256 _amountBabz) public returns (bool);\n', '\n', '  function transData(address _to, uint256 _amountBabz, bytes _data) public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _amountBabz, bytes _data) public returns (bool);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _amountBabz);\n', '\n', '  function () public payable;\n', '\n', '  function purchase(uint256 _price) public payable;\n', '\n', '  function sell(uint256 _price, uint256 _amountBabz);\n', '\n', '  function powerUp(uint256 _amountBabz) public;\n', '\n', '}\n', '\n', '\n', 'contract MarketEnabled is NutzEnabled {\n', '\n', '  uint256 constant INFINITY = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n', '\n', '  // address of the pull payemnt satelite\n', '  address public pullAddr;\n', '\n', '  // the Token sale mechanism parameters:\n', '  // purchasePrice is the number of NTZ received for purchase with 1 ETH\n', '  uint256 internal purchasePrice;\n', '\n', '  // floor is the number of NTZ needed, to receive 1 ETH in sell\n', '  uint256 internal salePrice;\n', '\n', '  function MarketEnabled(address _pullAddr, address _storageAddr, address _nutzAddr)\n', '    NutzEnabled(_nutzAddr, _storageAddr) {\n', '    pullAddr = _pullAddr;\n', '  }\n', '\n', '\n', '  function ceiling() constant returns (uint256) {\n', '    return purchasePrice;\n', '  }\n', '\n', '  // returns either the salePrice, or if reserve does not suffice\n', '  // for active supply, returns maxFloor\n', '  function floor() constant returns (uint256) {\n', '    if (nutzAddr.balance == 0) {\n', '      return INFINITY;\n', '    }\n', '    uint256 maxFloor = activeSupply().mul(1000000).div(nutzAddr.balance); // 1,000,000 WEI, used as price factor\n', '    // return max of maxFloor or salePrice\n', '    return maxFloor >= salePrice ? maxFloor : salePrice;\n', '  }\n', '\n', '  function moveCeiling(uint256 _newPurchasePrice) public onlyAdmins {\n', '    require(_newPurchasePrice <= salePrice);\n', '    purchasePrice = _newPurchasePrice;\n', '  }\n', '\n', '  function moveFloor(uint256 _newSalePrice) public onlyAdmins {\n', '    require(_newSalePrice >= purchasePrice);\n', '    // moveFloor fails if the administrator tries to push the floor so low\n', '    // that the sale mechanism is no longer able to buy back all tokens at\n', '    // the floor price if those funds were to be withdrawn.\n', '    if (_newSalePrice < INFINITY) {\n', '      require(nutzAddr.balance >= activeSupply().mul(1000000).div(_newSalePrice)); // 1,000,000 WEI, used as price factor\n', '    }\n', '    salePrice = _newSalePrice;\n', '  }\n', '\n', '  function purchase(address _sender, uint256 _value, uint256 _price) public onlyNutz whenNotPaused returns (uint256) {\n', '    // disable purchases if purchasePrice set to 0\n', '    require(purchasePrice > 0);\n', '    require(_price == purchasePrice);\n', '\n', '    uint256 amountBabz = purchasePrice.mul(_value).div(1000000); // 1,000,000 WEI, used as price factor\n', '    // avoid deposits that issue nothing\n', '    // might happen with very high purchase price\n', '    require(amountBabz > 0);\n', '\n', '    // make sure power pool grows proportional to economy\n', '    uint256 activeSup = activeSupply();\n', '    uint256 powPool = powerPool();\n', '    if (powPool > 0) {\n', '      uint256 powerShare = powPool.mul(amountBabz).div(activeSup.add(burnPool()));\n', '      _setPowerPool(powPool.add(powerShare));\n', '    }\n', '    _setActiveSupply(activeSup.add(amountBabz));\n', '    _setBabzBalanceOf(_sender, babzBalanceOf(_sender).add(amountBabz));\n', '    return amountBabz;\n', '  }\n', '\n', '  function sell(address _from, uint256 _price, uint256 _amountBabz) public onlyNutz whenNotPaused {\n', '    uint256 effectiveFloor = floor();\n', '    require(_amountBabz != 0);\n', '    require(effectiveFloor != INFINITY);\n', '    require(_price == effectiveFloor);\n', '\n', '    uint256 amountWei = _amountBabz.mul(1000000).div(effectiveFloor);  // 1,000,000 WEI, used as price factor\n', '    require(amountWei > 0);\n', '    // make sure power pool shrinks proportional to economy\n', '    uint256 powPool = powerPool();\n', '    uint256 activeSup = activeSupply();\n', '    if (powPool > 0) {\n', '      uint256 powerShare = powPool.mul(_amountBabz).div(activeSup);\n', '      _setPowerPool(powPool.sub(powerShare));\n', '    }\n', '    _setActiveSupply(activeSup.sub(_amountBabz));\n', '    _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz));\n', '    Nutz(nutzAddr).asyncSend(pullAddr, _from, amountWei);\n', '  }\n', '\n', '\n', '  // withdraw excessive reserve - i.e. milestones\n', '  function allocateEther(uint256 _amountWei, address _beneficiary) public onlyAdmins {\n', '    require(_amountWei > 0);\n', '    // allocateEther fails if allocating those funds would mean that the\n', '    // sale mechanism is no longer able to buy back all tokens at the floor\n', '    // price if those funds were to be withdrawn.\n', '    require(nutzAddr.balance.sub(_amountWei) >= activeSupply().mul(1000000).div(salePrice)); // 1,000,000 WEI, used as price factor\n', '    Nutz(nutzAddr).asyncSend(pullAddr, _beneficiary, _amountWei);\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract Power {\n', '\n', '\n', '\n', '  function balanceOf(address _holder) constant returns (uint256);\n', '\n', '  function totalSupply() constant returns (uint256);\n', '\n', '  function activeSupply() constant returns (uint256);\n', '\n', '\n', '  // ############################################\n', '  // ########### ADMIN FUNCTIONS ################\n', '  // ############################################\n', '\n', '  function slashPower(address _holder, uint256 _value, bytes32 _data) public ;\n', '\n', '  function powerUp(address _holder, uint256 _value) public ;\n', '\n', '  // ############################################\n', '  // ########### PUBLIC FUNCTIONS ###############\n', '  // ############################################\n', '\n', '  // registers a powerdown request\n', '  function transfer(address _to, uint256 _amountPower) public returns (bool success);\n', '\n', '  function downtime() public returns (uint256);\n', '\n', '  function downTick(address _owner) public;\n', '\n', '  function downs(address _owner) constant public returns (uint256, uint256, uint256);\n', '\n', '}\n', '\n', '\n', 'contract PowerEnabled is MarketEnabled {\n', '\n', '  // satelite contract addresses\n', '  address public powerAddr;\n', '\n', '  // maxPower is a limit of total power that can be outstanding\n', '  // maxPower has a valid value between outstandingPower and authorizedPow/2\n', '  uint256 public maxPower = 0;\n', '\n', '  // time it should take to power down\n', '  uint256 public downtime;\n', '\n', '  modifier onlyPower() {\n', '    require(msg.sender == powerAddr);\n', '    _;\n', '  }\n', '\n', '  function PowerEnabled(address _powerAddr, address _pullAddr, address _storageAddr, address _nutzAddr)\n', '    MarketEnabled(_pullAddr, _nutzAddr, _storageAddr) {\n', '    powerAddr = _powerAddr;\n', '  }\n', '\n', '  function setMaxPower(uint256 _maxPower) public onlyAdmins {\n', '    require(outstandingPower() <= _maxPower && _maxPower < authorizedPower());\n', '    maxPower = _maxPower;\n', '  }\n', '\n', '  function setDowntime(uint256 _downtime) public onlyAdmins {\n', '    downtime = _downtime;\n', '  }\n', '\n', '  // this is called when NTZ are deposited into the burn pool\n', '  function dilutePower(uint256 _amountBabz, uint256 _amountPower) public onlyAdmins {\n', '    uint256 authorizedPow = authorizedPower();\n', '    uint256 totalBabz = totalSupply();\n', '    if (authorizedPow == 0) {\n', '      // during the first capital increase, set value directly as authorized shares\n', '      _setAuthorizedPower((_amountPower > 0) ? _amountPower : _amountBabz.add(totalBabz));\n', '    } else {\n', '      // in later increases, expand authorized shares at same rate like economy\n', '      _setAuthorizedPower(authorizedPow.mul(totalBabz.add(_amountBabz)).div(totalBabz));\n', '    }\n', '    _setBurnPool(burnPool().add(_amountBabz));\n', '  }\n', '\n', '  function _slashPower(address _holder, uint256 _value, bytes32 _data) internal {\n', '    uint256 previouslyOutstanding = outstandingPower();\n', '    _setOutstandingPower(previouslyOutstanding.sub(_value));\n', '    // adjust size of power pool\n', '    uint256 powPool = powerPool();\n', '    uint256 slashingBabz = _value.mul(powPool).div(previouslyOutstanding);\n', '    _setPowerPool(powPool.sub(slashingBabz));\n', '    // put event into satelite contract\n', '    Power(powerAddr).slashPower(_holder, _value, _data);\n', '  }\n', '\n', '  function slashPower(address _holder, uint256 _value, bytes32 _data) public onlyAdmins {\n', '    _setPowerBalanceOf(_holder, powerBalanceOf(_holder).sub(_value));\n', '    _slashPower(_holder, _value, _data);\n', '  }\n', '\n', '  function slashDownRequest(uint256 _pos, address _holder, uint256 _value, bytes32 _data) public onlyAdmins {\n', '    var (total, left, start) = downs(_holder);\n', '    left = left.sub(_value);\n', '    _setDownRequest(_holder, total, left, start);\n', '    _slashPower(_holder, _value, _data);\n', '  }\n', '\n', '  // this is called when NTZ are deposited into the power pool\n', '  function powerUp(address _sender, address _from, uint256 _amountBabz) public onlyNutz whenNotPaused {\n', '    uint256 authorizedPow = authorizedPower();\n', '    require(authorizedPow != 0);\n', '    require(_amountBabz != 0);\n', '    uint256 totalBabz = totalSupply();\n', '    require(totalBabz != 0);\n', '    uint256 amountPow = _amountBabz.mul(authorizedPow).div(totalBabz);\n', '    // check pow limits\n', '    uint256 outstandingPow = outstandingPower();\n', '    require(outstandingPow.add(amountPow) <= maxPower);\n', '\n', '    if (_sender != _from) {\n', '      allowed[_from][_sender] = allowed[_from][_sender].sub(_amountBabz);\n', '    }\n', '\n', '    _setOutstandingPower(outstandingPow.add(amountPow));\n', '\n', '    uint256 powBal = powerBalanceOf(_from).add(amountPow);\n', '    require(powBal >= authorizedPow.div(10000)); // minShare = 10000\n', '    _setPowerBalanceOf(_from, powBal);\n', '    _setActiveSupply(activeSupply().sub(_amountBabz));\n', '    _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz));\n', '    _setPowerPool(powerPool().add(_amountBabz));\n', '    Power(powerAddr).powerUp(_from, amountPow);\n', '  }\n', '\n', '  function powerTotalSupply() constant returns (uint256) {\n', '    uint256 issuedPower = authorizedPower().div(2);\n', '    // return max of maxPower or issuedPower\n', '    return maxPower >= issuedPower ? maxPower : issuedPower;\n', '  }\n', '\n', '  function _vestedDown(uint256 _total, uint256 _left, uint256 _start, uint256 _now) internal constant returns (uint256) {\n', '    if (_now <= _start) {\n', '      return 0;\n', '    }\n', '    // calculate amountVested\n', '    // amountVested is amount that can be withdrawn according to time passed\n', '    uint256 timePassed = _now.sub(_start);\n', '    if (timePassed > downtime) {\n', '     timePassed = downtime;\n', '    }\n', '    uint256 amountVested = _total.mul(timePassed).div(downtime);\n', '    uint256 amountFrozen = _total.sub(amountVested);\n', '    if (_left <= amountFrozen) {\n', '      return 0;\n', '    }\n', '    return _left.sub(amountFrozen);\n', '  }\n', '\n', '  function createDownRequest(address _owner, uint256 _amountPower) public onlyPower whenNotPaused {\n', '    // prevent powering down tiny amounts\n', '    // when powering down, at least totalSupply/minShare Power should be claimed\n', '    require(_amountPower >= authorizedPower().div(10000)); // minShare = 10000;\n', '    _setPowerBalanceOf(_owner, powerBalanceOf(_owner).sub(_amountPower));\n', '\n', '    var (, left, ) = downs(_owner);\n', '    uint256 total = _amountPower.add(left);\n', '    _setDownRequest(_owner, total, total, now);\n', '  }\n', '\n', '  // executes a powerdown request\n', '  function downTick(address _holder, uint256 _now) public onlyPower whenNotPaused {\n', '    var (total, left, start) = downs(_holder);\n', '    uint256 amountPow = _vestedDown(total, left, start, _now);\n', '\n', '    // prevent power down in tiny steps\n', '    uint256 minStep = total.div(10);\n', '    require(left <= minStep || minStep <= amountPow);\n', '\n', '    // calculate token amount representing share of power\n', '    uint256 amountBabz = amountPow.mul(totalSupply()).div(authorizedPower());\n', '\n', '    // transfer power and tokens\n', '    _setOutstandingPower(outstandingPower().sub(amountPow));\n', '    left = left.sub(amountPow);\n', '    _setPowerPool(powerPool().sub(amountBabz));\n', '    _setActiveSupply(activeSupply().add(amountBabz));\n', '    _setBabzBalanceOf(_holder, babzBalanceOf(_holder).add(amountBabz));\n', '    // down request completed\n', '    if (left == 0) {\n', '      start = 0;\n', '      total = 0;\n', '    }\n', '    // TODO\n', '    _setDownRequest(_holder, total, left, start);\n', '    Nutz(nutzAddr).powerDown(powerAddr, _holder, amountBabz);\n', '  }\n', '}\n', '\n', '\n', 'contract Controller is PowerEnabled {\n', '\n', '  function Controller(address _powerAddr, address _pullAddr, address _nutzAddr, address _storageAddr) \n', '    PowerEnabled(_powerAddr, _pullAddr, _nutzAddr, _storageAddr) {\n', '  }\n', '\n', '  function setContracts(address _storageAddr, address _nutzAddr, address _powerAddr, address _pullAddr) public onlyAdmins whenPaused {\n', '    storageAddr = _storageAddr;\n', '    nutzAddr = _nutzAddr;\n', '    powerAddr = _powerAddr;\n', '    pullAddr = _pullAddr;\n', '  }\n', '\n', '  function changeDailyLimit(uint256 _dailyLimit) public onlyAdmins {\n', '    PullPayment(pullAddr).changeDailyLimit(_dailyLimit);\n', '  }\n', '\n', '  function kill(address _newController) public onlyAdmins whenPaused {\n', '    if (powerAddr != address(0)) { Ownable(powerAddr).transferOwnership(msg.sender); }\n', '    if (pullAddr != address(0)) { Ownable(pullAddr).transferOwnership(msg.sender); }\n', '    if (nutzAddr != address(0)) { Ownable(nutzAddr).transferOwnership(msg.sender); }\n', '    if (storageAddr != address(0)) { Ownable(storageAddr).transferOwnership(msg.sender); }\n', '    selfdestruct(_newController);\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}']
