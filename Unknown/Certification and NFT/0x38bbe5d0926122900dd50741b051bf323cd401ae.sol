['pragma solidity ^0.4.11;\n', '\n', '/*\n', '  Allows owner/seller to deposit ETH in order to participate in\n', '  an ICO on behalf of the contract so that users can buy directly\n', '  from this contract with assurances that they will receive their\n', '  tokens via a user-invoked withdrawal() call once the ICO token\n', '  creator releases tokens for trading.\n', '\n', '  This affords users the ability to reserve/claim tokens that they\n', '  were not able to buy in an ICO, before they hit the exchanges.\n', '\n', '*/\n', 'contract DaoCasinoToken {\n', '  uint256 public CAP;\n', '  uint256 public totalEthers;\n', '  function proxyPayment(address participant) payable;\n', '  function transfer(address _to, uint _amount) returns (bool success);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', 'contract BETSale {\n', '  // Store the amount of BET purchased by a buyer\n', '  mapping (address => uint256) public bet_purchased;\n', '\n', '  // Store the amount of ETH sent in by a buyer. Good to have this record just in case\n', '  mapping (address => uint256) public eth_sent;\n', '\n', '  // Total BET available to sell\n', '  uint256 public total_bet_available;\n', '\n', '  // Total BET purchased by all buyers\n', '  uint256 public total_bet_purchased;\n', '\n', '  // Total BET withdrawn by all buyers\n', '  uint256 public total_bet_withdrawn;\n', '\n', '  // BET per ETH (price)\n', '  uint256 public price_per_eth = 900;\n', '\n', '  //  BET token contract address (IOU offering)\n', '  DaoCasinoToken public token = DaoCasinoToken(0x725803315519de78D232265A8f1040f054e70B98);\n', '\n', '  // The seller&#39;s address\n', '  address seller = 0xB00Ae1e677B27Eee9955d632FF07a8590210B366;\n', '\n', '  // Halt further purchase ability just in case\n', '  bool public halt_purchases;\n', '\n', '  /*\n', '    Safety to withdraw all tokens, ONLY if all buyers have already withdrawn their purchases\n', '  */\n', '  function withdrawTokens() {\n', '    if(msg.sender != seller) throw;\n', '    if(total_bet_withdrawn != total_bet_purchased) throw;\n', '\n', '    // reset everything\n', '    total_bet_available = 0;\n', '    total_bet_purchased = 0;\n', '    total_bet_withdrawn = 0;\n', '\n', '    token.transfer(seller, token.balanceOf(address(this)));\n', '  }\n', '\n', '  /*\n', '    Safety to withdraw ETH\n', '  */\n', '  function withdrawETH() {\n', '    if(msg.sender != seller) throw;\n', '    msg.sender.transfer(this.balance);\n', '  }\n', '\n', '  /*\n', '    Initiate ICO purchase\n', '  */\n', '  function buyTokens() payable {\n', '    if(msg.sender != seller) throw;\n', '    if(token.totalEthers() < token.CAP()) {\n', '      token.proxyPayment.value(this.balance)(address(this));\n', '    }\n', '  }\n', '\n', '  /*\n', '    Update available BET to purchase\n', '  */\n', '  function updateAvailability(uint256 _bet_amount) {\n', '    if(msg.sender != seller) throw;\n', '    total_bet_available += _bet_amount;\n', '  }\n', '\n', '  /*\n', '    Update BET price\n', '  */\n', '  function updatePrice(uint256 _price) {\n', '    if(msg.sender != seller) throw;\n', '    price_per_eth = _price;\n', '  }\n', '\n', '  /*\n', '    Safety to prevent anymore purchases/sales from occurring in the event of\n', '    unforeseen issue. Buyer token withdrawals still allowed\n', '  */\n', '  function haltPurchases() {\n', '    if(msg.sender != seller) throw;\n', '    halt_purchases = true;\n', '  }\n', '\n', '  function resumePurchases() {\n', '    if(msg.sender != seller) throw;\n', '    halt_purchases = false;\n', '  }\n', '\n', '  function withdraw() {\n', '    // Dismiss any early or ill attempts at withdrawing\n', '    if(token.balanceOf(address(this)) == 0 || bet_purchased[msg.sender] == 0) throw;\n', '\n', '    uint256 bet_to_withdraw = bet_purchased[msg.sender];\n', '\n', '    // Clear record of buyer&#39;s BET balance before transferring out\n', '    bet_purchased[msg.sender] = 0;\n', '\n', '    total_bet_withdrawn += bet_to_withdraw;\n', '\n', '    // Distribute tokens to the buyer\n', '    if(!token.transfer(msg.sender, bet_to_withdraw)) throw;\n', '  }\n', '\n', '  function purchase() payable {\n', '    if(halt_purchases) throw;\n', '\n', '    // Determine amount of tokens user wants to/can buy\n', '    uint256 bet_to_purchase = price_per_eth * msg.value;\n', '\n', '    // Check if we have enough BET left to sell\n', '    if((total_bet_purchased + bet_to_purchase) > total_bet_available) throw;\n', '\n', '    // Update the amount of BET purchased by user. Also keep track of the total ETH they sent in\n', '    bet_purchased[msg.sender] += bet_to_purchase;\n', '    eth_sent[msg.sender] += msg.value;\n', '\n', '    // Update the total amount of BET purchased by all buyers over all periods of availability\n', '    total_bet_purchased += bet_to_purchase;\n', '\n', '    // Tokens are clearly in the contract, therefore we can release ETH to seller&#39;s address\n', '    seller.transfer(msg.value);\n', '  }\n', '\n', '  // Fallback function/entry point\n', '  function () payable {\n', '    if(msg.value == 0) {\n', '      withdraw();\n', '    }\n', '    else {\n', '      if(msg.sender == seller) {\n', '        return;\n', '      }\n', '      purchase();\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/*\n', '  Allows owner/seller to deposit ETH in order to participate in\n', '  an ICO on behalf of the contract so that users can buy directly\n', '  from this contract with assurances that they will receive their\n', '  tokens via a user-invoked withdrawal() call once the ICO token\n', '  creator releases tokens for trading.\n', '\n', '  This affords users the ability to reserve/claim tokens that they\n', '  were not able to buy in an ICO, before they hit the exchanges.\n', '\n', '*/\n', 'contract DaoCasinoToken {\n', '  uint256 public CAP;\n', '  uint256 public totalEthers;\n', '  function proxyPayment(address participant) payable;\n', '  function transfer(address _to, uint _amount) returns (bool success);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', 'contract BETSale {\n', '  // Store the amount of BET purchased by a buyer\n', '  mapping (address => uint256) public bet_purchased;\n', '\n', '  // Store the amount of ETH sent in by a buyer. Good to have this record just in case\n', '  mapping (address => uint256) public eth_sent;\n', '\n', '  // Total BET available to sell\n', '  uint256 public total_bet_available;\n', '\n', '  // Total BET purchased by all buyers\n', '  uint256 public total_bet_purchased;\n', '\n', '  // Total BET withdrawn by all buyers\n', '  uint256 public total_bet_withdrawn;\n', '\n', '  // BET per ETH (price)\n', '  uint256 public price_per_eth = 900;\n', '\n', '  //  BET token contract address (IOU offering)\n', '  DaoCasinoToken public token = DaoCasinoToken(0x725803315519de78D232265A8f1040f054e70B98);\n', '\n', "  // The seller's address\n", '  address seller = 0xB00Ae1e677B27Eee9955d632FF07a8590210B366;\n', '\n', '  // Halt further purchase ability just in case\n', '  bool public halt_purchases;\n', '\n', '  /*\n', '    Safety to withdraw all tokens, ONLY if all buyers have already withdrawn their purchases\n', '  */\n', '  function withdrawTokens() {\n', '    if(msg.sender != seller) throw;\n', '    if(total_bet_withdrawn != total_bet_purchased) throw;\n', '\n', '    // reset everything\n', '    total_bet_available = 0;\n', '    total_bet_purchased = 0;\n', '    total_bet_withdrawn = 0;\n', '\n', '    token.transfer(seller, token.balanceOf(address(this)));\n', '  }\n', '\n', '  /*\n', '    Safety to withdraw ETH\n', '  */\n', '  function withdrawETH() {\n', '    if(msg.sender != seller) throw;\n', '    msg.sender.transfer(this.balance);\n', '  }\n', '\n', '  /*\n', '    Initiate ICO purchase\n', '  */\n', '  function buyTokens() payable {\n', '    if(msg.sender != seller) throw;\n', '    if(token.totalEthers() < token.CAP()) {\n', '      token.proxyPayment.value(this.balance)(address(this));\n', '    }\n', '  }\n', '\n', '  /*\n', '    Update available BET to purchase\n', '  */\n', '  function updateAvailability(uint256 _bet_amount) {\n', '    if(msg.sender != seller) throw;\n', '    total_bet_available += _bet_amount;\n', '  }\n', '\n', '  /*\n', '    Update BET price\n', '  */\n', '  function updatePrice(uint256 _price) {\n', '    if(msg.sender != seller) throw;\n', '    price_per_eth = _price;\n', '  }\n', '\n', '  /*\n', '    Safety to prevent anymore purchases/sales from occurring in the event of\n', '    unforeseen issue. Buyer token withdrawals still allowed\n', '  */\n', '  function haltPurchases() {\n', '    if(msg.sender != seller) throw;\n', '    halt_purchases = true;\n', '  }\n', '\n', '  function resumePurchases() {\n', '    if(msg.sender != seller) throw;\n', '    halt_purchases = false;\n', '  }\n', '\n', '  function withdraw() {\n', '    // Dismiss any early or ill attempts at withdrawing\n', '    if(token.balanceOf(address(this)) == 0 || bet_purchased[msg.sender] == 0) throw;\n', '\n', '    uint256 bet_to_withdraw = bet_purchased[msg.sender];\n', '\n', "    // Clear record of buyer's BET balance before transferring out\n", '    bet_purchased[msg.sender] = 0;\n', '\n', '    total_bet_withdrawn += bet_to_withdraw;\n', '\n', '    // Distribute tokens to the buyer\n', '    if(!token.transfer(msg.sender, bet_to_withdraw)) throw;\n', '  }\n', '\n', '  function purchase() payable {\n', '    if(halt_purchases) throw;\n', '\n', '    // Determine amount of tokens user wants to/can buy\n', '    uint256 bet_to_purchase = price_per_eth * msg.value;\n', '\n', '    // Check if we have enough BET left to sell\n', '    if((total_bet_purchased + bet_to_purchase) > total_bet_available) throw;\n', '\n', '    // Update the amount of BET purchased by user. Also keep track of the total ETH they sent in\n', '    bet_purchased[msg.sender] += bet_to_purchase;\n', '    eth_sent[msg.sender] += msg.value;\n', '\n', '    // Update the total amount of BET purchased by all buyers over all periods of availability\n', '    total_bet_purchased += bet_to_purchase;\n', '\n', "    // Tokens are clearly in the contract, therefore we can release ETH to seller's address\n", '    seller.transfer(msg.value);\n', '  }\n', '\n', '  // Fallback function/entry point\n', '  function () payable {\n', '    if(msg.value == 0) {\n', '      withdraw();\n', '    }\n', '    else {\n', '      if(msg.sender == seller) {\n', '        return;\n', '      }\n', '      purchase();\n', '    }\n', '  }\n', '}']
