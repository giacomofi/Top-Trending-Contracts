['pragma solidity 0.4.16;\n', '\n', '/// @title Multi signature token wallet - Allows multiple parties to approve tokens transfer\n', '/// @author popofe (Avalon Platform) - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4a3a253a252c2f0a2b3c2b26252464243f">[email&#160;protected]</a>>\n', '\n', 'contract MultiSigTokenWallet {\n', '    /// @dev No fallback function to prevent ether deposit\n', '\n', '    address constant public TOKEN = 0xeD247980396B10169BB1d36f6e278eD16700a60f;\n', '\n', '    event Confirmation(address source, uint actionId);\n', '    event Revocation(address source, uint actionId);\n', '    event NewAction(uint actionId);\n', '    event Execution(uint actionId);\n', '    event ExecutionFailure(uint actionId);\n', '    event OwnerAddition(address owner);\n', '    event OwnerWithdraw(address owner);\n', '    event QuorumChange(uint quorum);\n', '\n', '    enum ActionChoices { AddOwner, ChangeQuorum, DeleteAction, TransferToken, WithdrawOwner}\n', '    mapping (uint => Action) public actions;\n', '    mapping (uint => mapping (address => bool)) public confirmations;\n', '    mapping (address => bool) public isOwner;\n', '    address[] public owners;\n', '    uint public quorum;\n', '    uint public actionCount;\n', '\n', '    struct Action {\n', '        address addressField;\n', '        uint value;\n', '        ActionChoices actionType;\n', '        bool executed;\n', '        bool deleted;\n', '    }\n', '\n', '    modifier ownerDeclared(address owner) {\n', '        require (isOwner[owner]);\n', '        _;\n', '    }\n', '\n', '    modifier actionSubmitted(uint actionId) {\n', '        require (   actions[actionId].addressField != 0\n', '                 || actions[actionId].value != 0);\n', '        _;\n', '    }\n', '\n', '    modifier confirmed(uint actionId, address owner) {\n', '        require (confirmations[actionId][owner]);\n', '        _;\n', '    }\n', '\n', '    modifier notConfirmed(uint actionId, address owner) {\n', '        require (!confirmations[actionId][owner]);\n', '        _;\n', '    }\n', '\n', '    modifier notExecuted(uint actionId) {\n', '        require (!actions[actionId].executed);\n', '        _;\n', '    }\n', '\n', '    modifier notDeleted(uint actionId) {\n', '        require (!actions[actionId].deleted);\n', '        _;\n', '    }\n', '\n', '    modifier validQuorum(uint ownerCount, uint _quorum) {\n', '        require (_quorum <= ownerCount && _quorum > 0);\n', '        _;\n', '    }\n', '\n', '    modifier validAction(address  addressField, uint value, ActionChoices actionType) {\n', '        require ((actionType == ActionChoices.AddOwner && addressField != 0 && value == 0)\n', '                || (actionType == ActionChoices.ChangeQuorum && addressField == 0 && value > 0)\n', '                || (actionType == ActionChoices.DeleteAction && addressField == 0 && value > 0)\n', '                || (actionType == ActionChoices.TransferToken && addressField != 0 && value > 0)\n', '                || (actionType == ActionChoices.WithdrawOwner && addressField != 0 && value == 0));\n', '        _;\n', '    }\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '    /// @dev Contract constructor sets initial owners and required number of confirmations.\n', '    /// @param _owners List of initial owners.\n', '    /// @param _quorum Number of required confirmations.\n', '    function MultiSigTokenWallet(address[] _owners, uint _quorum)\n', '        public\n', '        validQuorum(_owners.length, _quorum)\n', '    {\n', '        for (uint i=0; i<_owners.length; i++) {\n', '            require (!isOwner[_owners[i]] && _owners[i] != 0);\n', '            isOwner[_owners[i]] = true;\n', '        }\n', '        owners = _owners;\n', '        quorum = _quorum;\n', '    }\n', '\n', '    /// @dev Allows to add a new owner. \n', '    /// @param owner Address of new owner.\n', '    function addOwner(address owner)\n', '        private\n', '    {\n', '        require(!isOwner[owner]);\n', '        isOwner[owner] = true;\n', '        owners.push(owner);\n', '        OwnerAddition(owner);\n', '    }\n', '\n', '    /// @dev Allows to withdraw an owner. \n', '    /// @param owner Address of owner.\n', '    function withdrawOwner(address owner)\n', '        private\n', '    {\n', '        require (isOwner[owner]);\n', '        require (owners.length - 1 >= quorum);\n', '        isOwner[owner] = false;\n', '        for (uint i=0; i<owners.length - 1; i++)\n', '            if (owners[i] == owner) {\n', '                owners[i] = owners[owners.length - 1];\n', '                break;\n', '            }\n', '        owners.length -= 1;\n', '        OwnerWithdraw(owner);\n', '    }\n', '\n', '    /// @dev Allows to change the number of required confirmations.\n', '    /// @param _quorum Number of required confirmations.\n', '    function changeQuorum(uint _quorum)\n', '        private\n', '    {\n', '        require (_quorum > 0 && _quorum <= owners.length);\n', '        quorum = _quorum;\n', '        QuorumChange(_quorum);\n', '    }\n', '\n', '    /// @dev Allows to delete a previous action not executed\n', '    /// @param _actionId Number of required confirmations.\n', '    function deleteAction(uint _actionId)\n', '        private\n', '        notExecuted(_actionId)\n', '    {\n', '        actions[_actionId].deleted = true;\n', '    }\n', '\n', '    /// @dev Allows to delete a previous action not executed\n', '    /// @param _destination address that receive tokens.\n', '    /// @param _value Number of tokens.\n', '    function transferToken(address _destination, uint _value)\n', '        private\n', '        returns (bool)\n', '    {\n', '        ERC20Basic ERC20Contract = ERC20Basic(TOKEN);\n', '        return ERC20Contract.transfer(_destination, _value);\n', '    }\n', '\n', '    /// @dev Allows an owner to submit and confirm a transaction.\n', '    /// @param addressField Action target address.\n', '    /// @param value Number of token / new quorum to reach.\n', '    /// @return Returns transaction ID.\n', '    function submitAction(address addressField, uint value, ActionChoices actionType)\n', '        public\n', '        ownerDeclared(msg.sender)\n', '        validAction(addressField, value, actionType)\n', '        returns (uint actionId)\n', '    {\n', '        actionId = addAction(addressField, value, actionType);\n', '        confirmAction(actionId);\n', '    }\n', '\n', '    /// @dev Allows an owner to confirm a transaction.\n', '    /// @param actionId Action ID.\n', '    function confirmAction(uint actionId)\n', '        public\n', '        ownerDeclared(msg.sender)\n', '        actionSubmitted(actionId)\n', '        notConfirmed(actionId, msg.sender)\n', '    {\n', '        confirmations[actionId][msg.sender] = true;\n', '        Confirmation(msg.sender, actionId);\n', '    }\n', '\n', '    /// @dev Allows an owner to revoke a confirmation for a transaction.\n', '    /// @param actionId Action ID.\n', '    function revokeConfirmation(uint actionId)\n', '        public\n', '        ownerDeclared(msg.sender)\n', '        confirmed(actionId, msg.sender)\n', '        notExecuted(actionId)\n', '    {\n', '        confirmations[actionId][msg.sender] = false;\n', '        Revocation(msg.sender, actionId);\n', '    }\n', '\n', '    /// @dev Allows anyone to execute a confirmed transaction.\n', '    /// @param actionId Action ID.\n', '    function executeAction(uint actionId)\n', '        public\n', '        ownerDeclared(msg.sender)\n', '        actionSubmitted(actionId)\n', '        notExecuted(actionId)\n', '        notDeleted(actionId)\n', '    {\n', '        if (isConfirmed(actionId)) {\n', '            Action memory action = actions[actionId];\n', '            action.executed = true;\n', '            if (action.actionType == ActionChoices.AddOwner)\n', '                addOwner(action.addressField);\n', '            else if (action.actionType == ActionChoices.ChangeQuorum)\n', '                changeQuorum(action.value);\n', '            else if (action.actionType == ActionChoices.DeleteAction)\n', '                deleteAction(action.value);\n', '            else if (action.actionType == ActionChoices.TransferToken)\n', '                if (transferToken(action.addressField, action.value))\n', '                    Execution(actionId);\n', '                else {    \n', '                    ExecutionFailure(actionId);\n', '                    action.executed = false;\n', '                }\n', '            else if (action.actionType == ActionChoices.WithdrawOwner)\n', '                withdrawOwner(action.addressField);\n', '            else\n', '                revert();\n', '        }\n', '    }\n', '\n', '    /// @dev Returns the confirmation status of a transaction.\n', '    /// @param actionId Action ID.\n', '    /// @return Confirmation status.\n', '    function isConfirmed(uint actionId)\n', '        public\n', '        constant\n', '        returns (bool)\n', '    {\n', '        uint count = 0;\n', '        for (uint i=0; i<owners.length; i++) {\n', '            if (confirmations[actionId][owners[i]])\n', '                count += 1;\n', '            if (count == quorum)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @dev Adds a new action to the transaction list, if action does not exist yet.\n', '    /// @param addressField address to send token or too add or withadraw as owner.\n', '    /// @param value number of tokens (useful only for token transfer).\n', '    /// @return Returns transaction ID.\n', '    function addAction(address addressField, uint value, ActionChoices actionType)\n', '        private\n', '        returns (uint)\n', '    {\n', '        actionCount += 1;\n', '        uint actionId = actionCount;\n', '        actions[actionId] = Action({\n', '            addressField: addressField,\n', '            value: value,\n', '            actionType: actionType,\n', '            executed: false,\n', '            deleted: false\n', '        });\n', '        NewAction(actionId);\n', '        return actionId;\n', '    }\n', '\n', '    /// @dev Returns number of confirmations of an action.\n', '    /// @param actionId Action ID.\n', '    /// @return Number of confirmations.\n', '    function getConfirmationCount(uint actionId)\n', '        public\n', '        constant\n', '        returns (uint count)\n', '    {\n', '        for (uint i=0; i<owners.length; i++)\n', '            if (confirmations[actionId][owners[i]])\n', '                count += 1;\n', '    }\n', '\n', '    /// @dev Returns total number of actions after filers are applied.\n', '    /// @param pending Include pending actions.\n', '    /// @param executed Include executed actions.\n', '    /// @return Total number of actions after filters are applied.\n', '    function getActionCount(bool pending, bool executed, bool exceptDeleted)\n', '        public\n', '        constant\n', '        returns (uint count)\n', '    {\n', '        for (uint i=0; i<actionCount; i++)\n', '            if (   ((pending && !actions[i].executed)\n', '                    || (executed && actions[i].executed))\n', '                && (!exceptDeleted || !actions[i].deleted))\n', '                count += 1;\n', '    }\n', '\n', '    /// @dev Returns list of owners.\n', '    /// @return List of owner addresses.\n', '    function getOwners()\n', '        public\n', '        constant\n', '        returns (address[])\n', '    {\n', '        return owners;\n', '    }\n', '\n', '    /// @dev Returns array with owner addresses, which confirmed transaction.\n', '    /// @param actionId Action ID.\n', '    /// @return Returns array of owner addresses.\n', '    function getConfirmations(uint actionId)\n', '        public\n', '        constant\n', '        returns (address[] _confirmations)\n', '    {\n', '        address[] memory confirmationsTemp = new address[](owners.length);\n', '        uint count = 0;\n', '        uint i;\n', '        for (i=0; i<owners.length; i++)\n', '            if (confirmations[actionId][owners[i]]) {\n', '                confirmationsTemp[count] = owners[i];\n', '                count += 1;\n', '            }\n', '        _confirmations = new address[](count);\n', '        for (i=0; i<count; i++)\n', '            _confirmations[i] = confirmationsTemp[i];\n', '    }\n', '\n', '    /// @dev Returns list of action IDs in defined range.\n', '    /// @param pending Include pending actions.\n', '    /// @param executed Include executed actions.\n', '    /// @param exceptDeleted Exclude deleted actions.\n', '    /// @return Returns array of transaction IDs.\n', '    function getActionIds(bool pending, bool executed, bool exceptDeleted)\n', '        public\n', '        constant\n', '        returns (uint[] memory)\n', '    {\n', '        uint[] memory actionIds;\n', '        uint count = 0;\n', '        uint i;\n', '        for (i=0; i<actionCount; i++)\n', '            if (((pending && !actions[i].executed)\n', '                 || (executed && actions[i].executed))\n', '                && (!exceptDeleted || !actions[i].deleted))\n', '            {\n', '                actionIds[count] = i;\n', '                count += 1;\n', '            }\n', '            \n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}']