['pragma solidity 0.4.11;\n', '\n', 'contract Wolker {\n', '  mapping (address => uint256) balances;\n', '  mapping (address => uint256) allocations;\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '  mapping (address => mapping (address => bool)) authorized; //trustee\n', '\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) returns (bool success) {\n', '    if (balances[msg.sender] >= _value && _value > 0) {\n', '      balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '      balances[_to] = safeAdd(balances[_to], _value);\n', '      Transfer(msg.sender, _to, _value, balances[msg.sender], balances[_to]);\n', '      return true;\n', '    } else {\n', '      throw;\n', '    }\n', '  }\n', '  \n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '      balances[_to] = safeAdd(balances[_to], _value);\n', '      balances[_from] = safeSub(balances[_from], _value);\n', '      allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '      Transfer(_from, _to, _value, balances[_from], balances[_to]);\n', '      return true;\n', '    } else {\n', '      throw;\n', '    }\n', '  }\n', ' \n', '  /// @return total amount of tokens\n', '  function totalSupply() external constant returns (uint256) {\n', '        return generalTokens + reservedTokens;\n', '  }\n', ' \n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of Wolk token to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) returns (bool success) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '\n', '  /// @param _trustee Grant trustee permission to settle media spend\n', '  /// @return Whether the authorization was successful or not\n', '  function authorize(address _trustee) returns (bool success) {\n', '    authorized[msg.sender][_trustee] = true;\n', '    Authorization(msg.sender, _trustee);\n', '    return true;\n', '  }\n', '\n', "  /// @param _trustee_to_remove Revoke trustee's permission on settle media spend \n", '  /// @return Whether the deauthorization was successful or not\n', '  function deauthorize(address _trustee_to_remove) returns (bool success) {\n', '    authorized[msg.sender][_trustee_to_remove] = false;\n', '    Deauthorization(msg.sender, _trustee_to_remove);\n', '    return true;\n', '  }\n', '\n', '  // @param _owner\n', '  // @param _trustee\n', '  // @return authorization_status for platform settlement \n', '  function check_authorization(address _owner, address _trustee) constant returns (bool authorization_status) {\n', '    return authorized[_owner][_trustee];\n', '  }\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '\n', '  //**** ERC20 TOK Events:\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value, uint from_final_tok, uint to_final_tok);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '  event Authorization(address indexed _owner, address indexed _trustee);\n', '  event Deauthorization(address indexed _owner, address indexed _trustee_to_remove);\n', '\n', '  event NewOwner(address _newOwner);\n', '  event MintEvent(uint reward_tok, address recipient);\n', '  event LogRefund(address indexed _to, uint256 _value);\n', '  event CreateWolk(address indexed _to, uint256 _value);\n', '  event Vested(address indexed _to, uint256 _value);\n', '\n', '  modifier onlyOwner {\n', '    assert(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  modifier isOperational() {\n', '    assert(isFinalized);\n', '    _;\n', '  }\n', '\n', '\n', '  //**** ERC20 TOK fields:\n', "  string  public constant name = 'Wolk';\n", '  string  public constant symbol = "WOLK";\n', '  string  public constant version = "0.2";\n', '  uint256 public constant decimals = 18;\n', '  uint256 public constant wolkFund  =  10 * 10**1 * 10**decimals;        //  100 Wolk in operation Fund\n', '  uint256 public constant tokenCreationMin =  20 * 10**1 * 10**decimals; //  200 Wolk Min\n', '  uint256 public constant tokenCreationMax = 100 * 10**1 * 10**decimals; // 1000 Wolk Max\n', '  uint256 public constant tokenExchangeRate = 10000;   // 10000 Wolk per 1 ETH\n', '  uint256 public generalTokens = wolkFund; // tokens in circulation\n', '  uint256 public reservedTokens; \n', '\n', '  //address public owner = msg.sender;\n', '  address public owner = 0xC28dA4d42866758d0Fc49a5A3948A1f43de491e9; // michael - main\n', '  address public multisig_owner = 0x6968a9b90245cB9bD2506B9460e3D13ED4B2FD1e; // new multi-sig\n', '\n', '  bool public isFinalized = false;          // after token sale success, this is true\n', '  uint public constant dust = 1000000 wei; \n', '  bool public fairsale_protection = true;\n', '\n', '  \n', '     // Actual crowdsale\n', '  uint256 public start_block;                // Starting block\n', '  uint256 public end_block;                  // Ending block\n', '  uint256 public unlockedAt;                 // Unlocking block \n', ' \n', '  uint256 public end_ts;                     // Unix End time\n', '\n', '\n', '  // minting support\n', '  //uint public max_creation_rate_per_second; // Maximum token creation rate per second\n', '  //address public minter_address;            // Has permission to mint\n', '\n', '  // migration support\n', '  //address migrationMaster;\n', '\n', '\n', '  //**** Constructor:\n', '  function Wolk() \n', '  {\n', '\n', '    // Actual crowdsale\n', '    start_block = 3831300;\n', '    end_block = 3831900;\n', '\n', '    // wolkFund is 100\n', '    balances[msg.sender] = wolkFund;\n', '\n', '    // Wolk Inc has 25MM Wolk, 5MM of which is allocated for Wolk Inc Founding staff, who vest at "unlockedAt" time\n', '    reservedTokens = 25 * 10**decimals;\n', '    allocations[0x564a3f7d98Eb5B1791132F8875fef582d528d5Cf] = 20; // unassigned\n', '    allocations[0x7f512CCFEF05F651A70Fa322Ce27F4ad79b74ffe] = 1;  // Sourabh\n', '    allocations[0x9D203A36cd61b21B7C8c7Da1d8eeB13f04bb24D9] = 2;  // Michael - Test\n', '    allocations[0x5fcf700654B8062B709a41527FAfCda367daE7b1] = 1;  // Michael - Main\n', '    allocations[0xC28dA4d42866758d0Fc49a5A3948A1f43de491e9] = 1;  // Urmi\n', '    \n', '    \n', '    CreateWolk(msg.sender, wolkFund); \n', '  }\n', '\n', '  // ****** VESTING SUPPORT\n', '  /// @notice Allow developer to unlock allocated tokens by transferring them to developer\'s address on vesting schedule of "vested 100% on 1 year)\n', '  function unlock() external {\n', '    if (now < unlockedAt) throw;\n', '    uint256 vested = allocations[msg.sender] * 10**decimals;\n', '    if (vested < 0 ) throw; // Will fail if allocation (and therefore toTransfer) is 0.\n', '    allocations[msg.sender] = 0;\n', '    reservedTokens = safeSub(reservedTokens, vested);\n', '    balances[msg.sender] = safeAdd(balances[msg.sender], vested); \n', '    Vested(msg.sender, vested);\n', '  }\n', '\n', '  // ******* CROWDSALE SUPPORT\n', '  // Accepts ETH and creates WOLK\n', '  function createTokens() payable external is_not_dust {\n', '    if (isFinalized) throw;\n', '    if (block.number < start_block) throw;\n', '    if (block.number > end_block) throw;\n', '    if (msg.value == 0) throw;\n', '    if (tx.gasprice > 0.021 szabo && fairsale_protection) throw; \n', '    if (msg.value > 0.04 ether && fairsale_protection) throw; \n', '\n', "    uint256 tokens = safeMul(msg.value, tokenExchangeRate); // check that we're not over totals\n", '    uint256 checkedSupply = safeAdd(generalTokens, tokens);\n', '    if ( checkedSupply > tokenCreationMax) { \n', '      throw; // they need to get their money back if something goes wrong\n', '    } else {\n', '      generalTokens = checkedSupply;\n', '      balances[msg.sender] = safeAdd(balances[msg.sender], tokens);   // safeAdd not needed; bad semantics to use here\n', '      CreateWolk(msg.sender, tokens); // logs token creation\n', '    }\n', '  }\n', '  \n', '  // The value of the message must be sufficiently large to not be considered dust.\n', '  modifier is_not_dust { if (msg.value < dust) throw; _; }\n', '\n', '  // Disabling fairsale protection  \n', '  function fairsale_protectionOFF() external {\n', '    if ( block.number - start_block < 200) throw; // fairsale window is strictly enforced\n', '    if ( msg.sender != owner ) throw;\n', '    fairsale_protection = false;\n', '  }\n', '\n', '  // Finalizing the crowdsale\n', '  function finalize() external {\n', '    if ( isFinalized ) throw;\n', '    if ( msg.sender != owner ) throw;  // locks finalize to ETH owner\n', '    if ( generalTokens < tokenCreationMin ) throw; // have to sell tokenCreationMin to finalize\n', '    if ( block.number < end_block ) throw;  \n', '    isFinalized = true;\n', '    end_ts = now;\n', '    unlockedAt = end_ts + 2 minutes;\n', '    if ( ! multisig_owner.send(this.balance) ) throw;\n', '  }\n', '\n', '  function refund() external {\n', '    if ( isFinalized ) throw; \n', '    if ( block.number < end_block ) throw;   \n', '    if ( generalTokens >= tokenCreationMin ) throw;  \n', '    if ( msg.sender == owner ) throw;\n', '    uint256 Val = balances[msg.sender];\n', '    balances[msg.sender] = 0;\n', '    generalTokens = safeSub(generalTokens, Val);\n', '    uint256 ethVal = safeDiv(Val, tokenExchangeRate);\n', '    LogRefund(msg.sender, ethVal);\n', '    if ( ! msg.sender.send(ethVal) ) throw;\n', '  }\n', '    \n', '  // ****** Platform Settlement\n', '  function settleFrom(address _from, address _to, uint256 _value) isOperational() external returns (bool success) {\n', '    if ( msg.sender != owner ) throw;\n', '    var _allowance = allowed[_from][msg.sender];\n', '    if (balances[_from] >= _value && (allowed[_from][msg.sender] >= _value || authorized[_from][msg.sender] == true ) && _value > 0) {\n', '      balances[_to] = safeAdd(balances[_to], _value);\n', '      balances[_from] = safeSub(balances[_from], _value);\n', '      allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '      if ( allowed[_from][msg.sender] < 0 ){\n', '         allowed[_from][msg.sender] = 0;\n', '      }\n', '      Transfer(_from, _to, _value, balances[_from], balances[_to]);\n', '      return true;\n', '    } else {\n', '      throw;\n', '    }\n', '  }\n', '\n', '  // ****** MINTING SUPPORT\n', '  // Mint new tokens\n', '  modifier only_minter {\n', '    assert(msg.sender == minter_address);\n', '    _;\n', '  }\n', '  \n', '  address public minter_address = owner;            // Has permission to mint\n', '\n', '  function mintTokens(uint reward_tok, address recipient) external payable only_minter\n', '  {\n', '    balances[recipient] = safeAdd(balances[recipient], reward_tok);\n', '    generalTokens = safeAdd(generalTokens, reward_tok);\n', '    MintEvent(reward_tok, recipient);\n', '  }\n', '\n', '  function changeMintingAddress(address newAddress) onlyOwner returns (bool success) { \n', '    minter_address = newAddress; \n', '    return true;\n', '  }\n', '\n', '  \n', '  //**** SafeMath:\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '  \n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '  \n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  \n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) throw;\n', '  }\n', '}']