['// This software is a subject to Ambisafe License Agreement.\n', '// No use or distribution is allowed without written permission from Ambisafe.\n', '// https://ambisafe.com/terms.pdf\n', '\n', 'contract Ambi {\n', '    function getNodeAddress(bytes32 _nodeName) constant returns(address);\n', '    function hasRelation(bytes32 _nodeName, bytes32 _relation, address _to) constant returns(bool);\n', '    function addNode(bytes32 _nodeName, address _nodeAddress) constant returns(bool);\n', '}\n', '\n', 'contract AmbiEnabled {\n', '    Ambi public ambiC;\n', '    bool public isImmortal;\n', '    bytes32 public name;\n', '\n', '    modifier checkAccess(bytes32 _role) {\n', '        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n', '            _\n', '        }\n', '    }\n', '    \n', '    function getAddress(bytes32 _name) constant returns (address) {\n', '        return ambiC.getNodeAddress(_name);\n', '    }\n', '\n', '    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n', '        if(address(ambiC) != 0x0){\n', '            return false;\n', '        }\n', '        Ambi ambiContract = Ambi(_ambi);\n', '        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n', '            if (!ambiContract.addNode(_name, address(this))){\n', '                return false;\n', '            }\n', '        }\n', '        name = _name;\n', '        ambiC = ambiContract;\n', '        return true;\n', '    }\n', '\n', '    function immortality() checkAccess("owner") returns(bool) {\n', '        isImmortal = true;\n', '        return true;\n', '    }\n', '\n', '    function remove() checkAccess("owner") returns(bool) {\n', '        if (isImmortal) {\n', '            return false;\n', '        }\n', '        selfdestruct(msg.sender);\n', '        return true;\n', '    }\n', '}\n', '\n', 'library StackDepthLib {\n', '    // This will probably work with a value of 390 but no need to cut it\n', '    // that close in the case that the optimizer changes slightly or\n', '    // something causing that number to rise slightly.\n', '    uint constant GAS_PER_DEPTH = 400;\n', '\n', '    function checkDepth(address self, uint n) constant returns(bool) {\n', '        if (n == 0) return true;\n', '        return self.call.gas(GAS_PER_DEPTH * n)(0x21835af6, n - 1);\n', '    }\n', '\n', '    function __dig(uint n) constant {\n', '        if (n == 0) return;\n', '        if (!address(this).delegatecall(0x21835af6, n - 1)) throw;\n', '    }\n', '}\n', '\n', 'contract Safe {\n', '    // Should always be placed as first modifier!\n', '    modifier noValue {\n', '        if (msg.value > 0) {\n', '            // Internal Out Of Gas/Throw: revert this transaction too;\n', '            // Call Stack Depth Limit reached: revert this transaction too;\n', '            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\n', '            _safeSend(msg.sender, msg.value);\n', '        }\n', '        _\n', '    }\n', '\n', '    modifier onlyHuman {\n', '        if (_isHuman()) {\n', '            _\n', '        }\n', '    }\n', '\n', '    modifier noCallback {\n', '        if (!isCall) {\n', '            _\n', '        }\n', '    }\n', '\n', '    modifier immutable(address _address) {\n', '        if (_address == 0) {\n', '            _\n', '        }\n', '    }\n', '\n', '    address stackDepthLib;\n', '    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n', '        stackDepthLib = _stackDepthLib;\n', '        return true;\n', '    }\n', '\n', '    modifier requireStackDepth(uint16 _depth) {\n', '        if (stackDepthLib == 0x0) {\n', '            throw;\n', '        }\n', '        if (_depth > 1023) {\n', '            throw;\n', '        }\n', '        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n', '            throw;\n', '        }\n', '        _\n', '    }\n', '\n', '    // Must not be used inside the functions that have noValue() modifier!\n', '    function _safeFalse() internal noValue() returns(bool) {\n', '        return false;\n', '    }\n', '\n', '    function _safeSend(address _to, uint _value) internal {\n', '        if (!_unsafeSend(_to, _value)) {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n', '        return _to.call.value(_value)();\n', '    }\n', '\n', '    function _isContract() constant internal returns(bool) {\n', '        return msg.sender != tx.origin;\n', '    }\n', '\n', '    function _isHuman() constant internal returns(bool) {\n', '        return !_isContract();\n', '    }\n', '\n', '    bool private isCall = false;\n', '    function _setupNoCallback() internal {\n', '        isCall = true;\n', '    }\n', '\n', '    function _finishNoCallback() internal {\n', '        isCall = false;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Events History universal contract.\n', ' *\n', ' * Contract serves as an Events storage and version history for a particular contract type.\n', ' * Events appear on this contract address but their definitions provided by other contracts/libraries.\n', ' * Version info is provided for historical and informational purposes.\n', ' *\n', ' * Note: all the non constant functions return false instead of throwing in case if state change\n', ' * didn&#39;t happen yet.\n', ' */\n', 'contract EventsHistory is AmbiEnabled, Safe {\n', '    // Event emitter signature to address with Event definiton mapping.\n', '    mapping(bytes4 => address) public emitters;\n', '\n', '    // Calling contract address to version mapping.\n', '    mapping(address => uint) public versions;\n', '\n', '    // Version to info mapping.\n', '    mapping(uint => VersionInfo) public versionInfo;\n', '\n', '    // Latest verion number.\n', '    uint public latestVersion;\n', '\n', '    struct VersionInfo {\n', '        uint block;        // Block number in which version has been introduced.\n', '        address by;        // Contract owner address who added version.\n', '        address caller;    // Address of this version calling contract.\n', '        string name;       // Version name, informative.\n', '        string changelog;  // Version changelog, informative.\n', '    }\n', '\n', '    /**\n', '     * Assign emitter address to a specified emit function signature.\n', '     *\n', '     * Can be set only once for each signature, and only by contract owner.\n', '     * Caller contract should be sure that emitter for a particular signature will never change.\n', '     *\n', '     * @param _eventSignature signature of the event emitting function.\n', '     * @param _emitter address with Event definition.\n', '     *\n', '     * @return success.\n', '     */\n', '    function addEmitter(bytes4 _eventSignature, address _emitter) noValue() checkAccess("admin") returns(bool) {\n', '        if (emitters[_eventSignature] != 0x0) {\n', '            return false;\n', '        }\n', '        emitters[_eventSignature] = _emitter;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Introduce new caller contract version specifing version information.\n', '     *\n', '     * Can be set only once for each caller, and only by contract owner.\n', '     * Name and changelog should not be empty.\n', '     *\n', '     * @param _caller address of the new caller.\n', '     * @param _name version name.\n', '     * @param _changelog version changelog.\n', '     *\n', '     * @return success.\n', '     */\n', '    function addVersion(address _caller, string _name, string _changelog) noValue() checkAccess("admin") returns(bool) {\n', '        if (versions[_caller] != 0) {\n', '            return false;\n', '        }\n', '        if (bytes(_name).length == 0) {\n', '            return false;\n', '        }\n', '        if (bytes(_changelog).length == 0) {\n', '            return false;\n', '        }\n', '        uint version = ++latestVersion;\n', '        versions[_caller] = version;\n', '        versionInfo[version] = VersionInfo(block.number, msg.sender, _caller, _name, _changelog);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Event emitting fallback.\n', '     *\n', '     * Can be and only called caller with assigned version.\n', '     * Resolves msg.sig to an emitter address, and calls it to emit an event.\n', '     *\n', '     * Throws if emit function signature is not registered, or call failed.\n', '     */\n', '    function () noValue() {\n', '        if (versions[msg.sender] == 0) {\n', '            return;\n', '        }\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Call Stack Depth Limit reached: revert this transaction too;\n', '        // Recursive Call: safe, all changes already made.\n', '        if (!emitters[msg.sig].delegatecall(msg.data)) {\n', '            throw;\n', '        }\n', '    }\n', '}']