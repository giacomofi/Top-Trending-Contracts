['contract owned {\n', '\n', '  address public owner;\n', '\n', '  function owned() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner {\n', '    if (msg.sender != owner) throw;\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n', '\n', 'contract ISncToken {\n', '  function mintTokens(address _to, uint256 _amount);\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '}\n', '\n', 'contract SunContractIco is owned{\n', '\n', '  uint256 public startBlock;\n', '  uint256 public endBlock;\n', '  uint256 public minEthToRaise;\n', '  uint256 public maxEthToRaise;\n', '  uint256 public totalEthRaised;\n', '  address public multisigAddress;\n', '\n', '\n', '  ISncToken sncTokenContract; \n', '  mapping (address => bool) presaleContributorAllowance;\n', '  uint256 nextFreeParticipantIndex;\n', '  mapping (uint => address) participantIndex;\n', '  mapping (address => uint256) participantContribution;\n', '\n', '  bool icoHasStarted;\n', '  bool minTresholdReached;\n', '  bool icoHasSucessfulyEnded;\n', '  uint256 blocksInWeek;\n', '    bool ownerHasClaimedTokens;\n', '\n', '  uint256 lastEthReturnIndex;\n', '  mapping (address => bool) hasClaimedEthWhenFail;\n', '\n', '  event ICOStarted(uint256 _blockNumber);\n', '  event ICOMinTresholdReached(uint256 _blockNumber);\n', '  event ICOEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised);\n', '  event ICOFailed(uint256 _blockNumber, uint256 _ammountRaised);\n', '  event ErrorSendingETH(address _from, uint256 _amount);\n', '\n', '  function SunContractIco(uint256 _startBlock, address _multisigAddress) {\n', '    blocksInWeek = 4 * 60 * 24 * 7;\n', '    startBlock = _startBlock;\n', '    endBlock = _startBlock + blocksInWeek * 4;\n', '    minEthToRaise = 5000 * 10**18;\n', '    maxEthToRaise = 100000 * 10**18;\n', '    multisigAddress = _multisigAddress;\n', '  }\n', '\n', '  //  \n', '  /* User accessible methods */   \n', '  //  \n', '\n', '  /* Users send ETH and enter the token sale*/  \n', '  function () payable {\n', '    if (msg.value == 0) throw;                                          // Throw if the value is 0  \n', '    if (icoHasSucessfulyEnded || block.number > endBlock) throw;        // Throw if the ICO has ended     \n', '    if (!icoHasStarted){                                                // Check if this is the first ICO transaction       \n', '      if (block.number >= startBlock){                                  // Check if the ICO should start        \n', '        icoHasStarted = true;                                           // Set that the ICO has started         \n', '        ICOStarted(block.number);                                       // Raise ICOStarted event     \n', '      } else{\n', '        throw;\n', '      }\n', '    }     \n', '    if (participantContribution[msg.sender] == 0){                     // Check if the sender is a new user       \n', '      participantIndex[nextFreeParticipantIndex] = msg.sender;         // Add a new user to the participant index       \n', '      nextFreeParticipantIndex += 1;\n', '    }     \n', '    if (maxEthToRaise > (totalEthRaised + msg.value)){                 // Check if the user sent too much ETH       \n', '      participantContribution[msg.sender] += msg.value;                // Add contribution      \n', '      totalEthRaised += msg.value;// Add to total eth Raised\n', '      sncTokenContract.mintTokens(msg.sender, getSncTokenIssuance(block.number, msg.value));\n', '      if (!minTresholdReached && totalEthRaised >= minEthToRaise){      // Check if the min treshold has been reached one time        \n', '        ICOMinTresholdReached(block.number);                            // Raise ICOMinTresholdReached event        \n', '        minTresholdReached = true;                                      // Set that the min treshold has been reached       \n', '      }     \n', '    }else{                                                              // If user sent to much eth       \n', '      uint maxContribution = maxEthToRaise - totalEthRaised;            // Calculate maximum contribution       \n', '      participantContribution[msg.sender] += maxContribution;           // Add maximum contribution to account      \n', '      totalEthRaised += maxContribution;  \n', '      sncTokenContract.mintTokens(msg.sender, getSncTokenIssuance(block.number, maxContribution));\n', '      uint toReturn = msg.value - maxContribution;                       // Calculate how much should be returned       \n', '      icoHasSucessfulyEnded = true;                                      // Set that ICO has successfully ended       \n', '      ICOEndedSuccessfuly(block.number, totalEthRaised);      \n', '      if(!msg.sender.send(toReturn)){                                    // Refund the balance that is over the cap         \n', '        ErrorSendingETH(msg.sender, toReturn);                           // Raise event for manual return if transaction throws       \n', '      }     \n', '    }\n', '  }   \n', '\n', '  /* Users can claim ETH by themselves if they want to in case of ETH failure*/   \n', '  function claimEthIfFailed(){    \n', '    if (block.number <= endBlock || totalEthRaised >= minEthToRaise) throw; // Check if ICO has failed    \n', '    if (participantContribution[msg.sender] == 0) throw;                    // Check if user has participated     \n', '    if (hasClaimedEthWhenFail[msg.sender]) throw;                           // Check if this account has already claimed ETH    \n', '    uint256 ethContributed = participantContribution[msg.sender];           // Get participant ETH Contribution     \n', '    hasClaimedEthWhenFail[msg.sender] = true;     \n', '    if (!msg.sender.send(ethContributed)){      \n', '      ErrorSendingETH(msg.sender, ethContributed);                          // Raise event if send failed, solve manually     \n', '    }   \n', '  }   \n', '\n', '  //  \n', '  /* Only owner methods */  \n', '  //  \n', '\n', '  /* Adds addresses that are allowed to take part in presale */   \n', '  function addPresaleContributors(address[] _presaleContributors) onlyOwner {     \n', '    for (uint cnt = 0; cnt < _presaleContributors.length; cnt++){       \n', '      presaleContributorAllowance[_presaleContributors[cnt]] = true;    \n', '    }   \n', '  }   \n', '\n', '  /* Owner can return eth for multiple users in one call*/  \n', '  function batchReturnEthIfFailed(uint256 _numberOfReturns) onlyOwner{    \n', '    if (block.number < endBlock || totalEthRaised >= minEthToRaise) throw;    // Check if ICO failed  \n', '    address currentParticipantAddress;    \n', '    uint256 contribution;\n', '    for (uint cnt = 0; cnt < _numberOfReturns; cnt++){      \n', '      currentParticipantAddress = participantIndex[lastEthReturnIndex];       // Get next account       \n', '      if (currentParticipantAddress == 0x0) return;                           // Check if participants were reimbursed      \n', '      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                // Check if user has manually recovered ETH         \n', '        contribution = participantContribution[currentParticipantAddress];    // Get accounts contribution        \n', '        hasClaimedEthWhenFail[msg.sender] = true;                             // Set that user got his ETH back         \n', '        if (!currentParticipantAddress.send(contribution)){                   // Send fund back to account          \n', '          ErrorSendingETH(currentParticipantAddress, contribution);           // Raise event if send failed, resolve manually         \n', '        }       \n', '      }       \n', '      lastEthReturnIndex += 1;    \n', '    }   \n', '  }   \n', '\n', '  /* Owner sets new address of SunContractToken */\n', '  function changeMultisigAddress(address _newAddress) onlyOwner {     \n', '    multisigAddress = _newAddress;\n', '  }   \n', '\n', '  /* Owner can claim reserved tokens on the end of crowsale */  \n', '  function claimCoreTeamsTokens(address _to) onlyOwner{     \n', '    if (!icoHasSucessfulyEnded) throw; \n', '    if (ownerHasClaimedTokens) throw;\n', '    \n', '    sncTokenContract.mintTokens(_to, sncTokenContract.totalSupply() * 25 / 100);\n', '    ownerHasClaimedTokens = true;\n', '  }   \n', '\n', '  /* Owner can remove allowance of designated presale contributor */  \n', '  function removePresaleContributor(address _presaleContributor) onlyOwner {    \n', '    presaleContributorAllowance[_presaleContributor] = false;   \n', '  }   \n', '\n', '  /* Set token contract where mints will be done (tokens will be issued)*/  \n', '  function setTokenContract(address _sncTokenContractAddress) onlyOwner {     \n', '    sncTokenContract = ISncToken(_sncTokenContractAddress);   \n', '  }   \n', '\n', '  /* Withdraw funds from contract */  \n', '  function withdrawEth() onlyOwner{     \n', '    if (this.balance == 0) throw;                                            // Check if there is balance on the contract     \n', '    if (totalEthRaised < minEthToRaise) throw;                               // Check if minEthToRaise treshold is exceeded     \n', '      \n', '    if(multisigAddress.send(this.balance)){}                                 // Send the contract&#39;s balance to multisig address   \n', '  }\n', '  \n', '  function endIco() onlyOwner {\n', '      if (totalEthRaised < minEthToRaise) throw;\n', '      if (block.number < endBlock) throw;\n', '  \n', '    icoHasSucessfulyEnded = true;\n', '    ICOEndedSuccessfuly(block.number, totalEthRaised);\n', '  }\n', '\n', '  /* Withdraw remaining balance to manually return where contract send has failed */  \n', '  function withdrawRemainingBalanceForManualRecovery() onlyOwner{     \n', '    if (this.balance == 0) throw;                                         // Check if there is balance on the contract    \n', '    if (block.number < endBlock) throw;                                   // Check if ICO failed    \n', '    if (participantIndex[lastEthReturnIndex] != 0x0) throw;               // Check if all the participants have been reimbursed     \n', '    if (multisigAddress.send(this.balance)){}                             // Send remainder so it can be manually processed   \n', '  }\n', '\n', '  //  \n', '  /* Getters */   \n', '  //  \n', '\n', '  function getSncTokenAddress() constant returns(address _tokenAddress){    \n', '    return address(sncTokenContract);   \n', '  }   \n', '\n', '  function icoInProgress() constant returns (bool answer){    \n', '    return icoHasStarted && !icoHasSucessfulyEnded;   \n', '  }   \n', '\n', '  function isAddressAllowedInPresale(address _querryAddress) constant returns (bool answer){    \n', '    return presaleContributorAllowance[_querryAddress];   \n', '  }   \n', '\n', '  function participantContributionInEth(address _querryAddress) constant returns (uint256 answer){    \n', '    return participantContribution[_querryAddress];   \n', '  }\n', '  \n', '  function getSncTokenIssuance(uint256 _blockNumber, uint256 _ethSent) constant returns(uint){\n', '        if (_blockNumber >= startBlock && _blockNumber < blocksInWeek + startBlock) {\n', '          if (presaleContributorAllowance[msg.sender]) return _ethSent * 11600;\n', '          else return _ethSent * 11500;\n', '        }\n', '        if (_blockNumber >= blocksInWeek + startBlock && _blockNumber < blocksInWeek * 2 + startBlock) return _ethSent * 11000;\n', '        if (_blockNumber >= blocksInWeek * 2 + startBlock && _blockNumber < blocksInWeek * 3 + startBlock) return _ethSent * 10500;\n', '        if (_blockNumber >= blocksInWeek * 3 + startBlock && _blockNumber <= blocksInWeek * 4 + startBlock) return _ethSent * 10000;\n', '    }\n', '\n', '  //\n', '  /* This part is here only for testing and will not be included into final version */\n', '  //\n', '  //function killContract() onlyOwner{\n', '  //  selfdestruct(msg.sender);\n', '  //}\n', '}']