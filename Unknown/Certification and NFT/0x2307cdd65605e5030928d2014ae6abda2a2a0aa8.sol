['pragma solidity ^0.4.11;\n', '\n', '/// @title Splitter\n', '/// @author 0xcaff (Martin Charles)\n', '/// @notice An ethereum smart contract to split received funds between a number\n', '/// of outputs.\n', 'contract Splitter {\n', '    // Mapping between addresses and how much money they have withdrawn. This is\n', '    // used to calculate the balance of each account. The public keyword allows\n', '    // reading from the map but not writing to the map using the\n', '    // amountsWithdrew(address) method of the contract. It&#39;s public mainly for\n', '    // testing.\n', '    mapping(address => uint) public amountsWithdrew;\n', '\n', '    // A set of parties to split the funds between. They are initialized in the\n', '    // constructor.\n', '    mapping(address => bool) public between;\n', '\n', '    // The number of ways incoming funds will we split.\n', '    uint public count;\n', '\n', '    // The total amount of funds which has been deposited into the contract.\n', '    uint public totalInput;\n', '\n', '    // This is the constructor of the contract. It is called at deploy time.\n', '\n', '    /// @param addrs The address received funds will be split between.\n', '    function Splitter(address[] addrs) {\n', '        count = addrs.length;\n', '\n', '        for (uint i = 0; i < addrs.length; i++) {\n', '            // loop over addrs and update set of included accounts\n', '            address included = addrs[i];\n', '            between[included] = true;\n', '        }\n', '    }\n', '\n', '    // To save on transaction fees, it&#39;s beneficial to withdraw in one big\n', '    // transaction instead of many little ones. That&#39;s why a withdrawl flow is\n', '    // being used.\n', '\n', '    /// @notice Withdraws from the sender&#39;s share of funds and deposits into the\n', '    /// sender&#39;s account. If there are insufficient funds in the contract, or\n', '    /// more than the share is being withdrawn, throws, canceling the\n', '    /// transaction.\n', '    /// @param amount The amount of funds in wei to withdraw from the contract.\n', '    function withdraw(uint amount) {\n', '        Splitter.withdrawInternal(amount, false);\n', '    }\n', '\n', '    /// @notice Withdraws all funds available to the sender and deposits them\n', '    /// into the sender&#39;s account.\n', '    function withdrawAll() {\n', '        Splitter.withdrawInternal(0, true);\n', '    }\n', '\n', '    // Since `withdrawInternal` is internal, it isn&#39;t in the ABI and can&#39;t be\n', '    // called from outside of the contract.\n', '\n', '    /// @notice Checks whether the sender is allowed to withdraw and has\n', '    /// sufficient funds, then withdraws.\n', '    /// @param requested The amount of funds in wei to withdraw from the\n', '    /// contract. If the `all` parameter is true, the `amount` parameter is\n', '    /// ignored. If funds are insufficient, throws.\n', '    /// @param all If true, withdraws all funds the sender has access to from\n', '    /// this contract.\n', '    function withdrawInternal(uint requested, bool all) internal {\n', '        // Require the withdrawer to be included in `between` at contract\n', '        // creation time.\n', '        require(between[msg.sender]);\n', '\n', '        // Decide the amount to withdraw based on the `all` parameter.\n', '        uint available = Splitter.balance();\n', '        uint transferring = 0;\n', '\n', '        if (all) { transferring = available; }\n', '        else { available = requested; }\n', '\n', '        // Ensures the funds are available to make the transfer, otherwise\n', '        // throws.\n', '        require(transferring <= available);\n', '\n', '        // Updates the internal state, this is done before the transfer to\n', '        // prevent re-entrancy bugs.\n', '        amountsWithdrew[msg.sender] += transferring;\n', '\n', '        // Transfer funds from the contract to the sender. The gas for this\n', '        // transaction is paid for by msg.sender.\n', '        msg.sender.transfer(transferring);\n', '    }\n', '\n', '    // We do integer division (floor(a / b)) when calculating each share, because\n', '    // solidity doesn&#39;t have a decimal number type. This means there will be a\n', '    // maximum remainder of count - 1 wei locked in the contract. We ignore this\n', '    // because it is such a small amount of ethereum (1 Wei = 10^(-18)\n', '    // Ethereum). The extra Wei can be extracted by depositing an amount to make\n', '    // totalInput evenly divisable between count parties.\n', '\n', '    /// @notice Gets the amount of funds in Wei available to the sender.\n', '    function balance() constant returns (uint) {\n', '        if (!between[msg.sender]) {\n', '            // The sender of the message isn&#39;t part of the split. Ignore them.\n', '            return 0;\n', '        }\n', '\n', '        // `share` is the amount of funds which are available to each of the\n', '        // accounts specified in the constructor.\n', '        uint share = totalInput / count;\n', '        uint withdrew = amountsWithdrew[msg.sender];\n', '        uint available = share - withdrew;\n', '\n', '        assert(available >= 0 && available <= share);\n', '\n', '        return available;\n', '    }\n', '\n', '    // This function will be run when a transaction is sent to the contract\n', '    // without any data. It is minimal to save on gas costs.\n', '    function() payable {\n', '        totalInput += msg.value;\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/// @title Splitter\n', '/// @author 0xcaff (Martin Charles)\n', '/// @notice An ethereum smart contract to split received funds between a number\n', '/// of outputs.\n', 'contract Splitter {\n', '    // Mapping between addresses and how much money they have withdrawn. This is\n', '    // used to calculate the balance of each account. The public keyword allows\n', '    // reading from the map but not writing to the map using the\n', "    // amountsWithdrew(address) method of the contract. It's public mainly for\n", '    // testing.\n', '    mapping(address => uint) public amountsWithdrew;\n', '\n', '    // A set of parties to split the funds between. They are initialized in the\n', '    // constructor.\n', '    mapping(address => bool) public between;\n', '\n', '    // The number of ways incoming funds will we split.\n', '    uint public count;\n', '\n', '    // The total amount of funds which has been deposited into the contract.\n', '    uint public totalInput;\n', '\n', '    // This is the constructor of the contract. It is called at deploy time.\n', '\n', '    /// @param addrs The address received funds will be split between.\n', '    function Splitter(address[] addrs) {\n', '        count = addrs.length;\n', '\n', '        for (uint i = 0; i < addrs.length; i++) {\n', '            // loop over addrs and update set of included accounts\n', '            address included = addrs[i];\n', '            between[included] = true;\n', '        }\n', '    }\n', '\n', "    // To save on transaction fees, it's beneficial to withdraw in one big\n", "    // transaction instead of many little ones. That's why a withdrawl flow is\n", '    // being used.\n', '\n', "    /// @notice Withdraws from the sender's share of funds and deposits into the\n", "    /// sender's account. If there are insufficient funds in the contract, or\n", '    /// more than the share is being withdrawn, throws, canceling the\n', '    /// transaction.\n', '    /// @param amount The amount of funds in wei to withdraw from the contract.\n', '    function withdraw(uint amount) {\n', '        Splitter.withdrawInternal(amount, false);\n', '    }\n', '\n', '    /// @notice Withdraws all funds available to the sender and deposits them\n', "    /// into the sender's account.\n", '    function withdrawAll() {\n', '        Splitter.withdrawInternal(0, true);\n', '    }\n', '\n', "    // Since `withdrawInternal` is internal, it isn't in the ABI and can't be\n", '    // called from outside of the contract.\n', '\n', '    /// @notice Checks whether the sender is allowed to withdraw and has\n', '    /// sufficient funds, then withdraws.\n', '    /// @param requested The amount of funds in wei to withdraw from the\n', '    /// contract. If the `all` parameter is true, the `amount` parameter is\n', '    /// ignored. If funds are insufficient, throws.\n', '    /// @param all If true, withdraws all funds the sender has access to from\n', '    /// this contract.\n', '    function withdrawInternal(uint requested, bool all) internal {\n', '        // Require the withdrawer to be included in `between` at contract\n', '        // creation time.\n', '        require(between[msg.sender]);\n', '\n', '        // Decide the amount to withdraw based on the `all` parameter.\n', '        uint available = Splitter.balance();\n', '        uint transferring = 0;\n', '\n', '        if (all) { transferring = available; }\n', '        else { available = requested; }\n', '\n', '        // Ensures the funds are available to make the transfer, otherwise\n', '        // throws.\n', '        require(transferring <= available);\n', '\n', '        // Updates the internal state, this is done before the transfer to\n', '        // prevent re-entrancy bugs.\n', '        amountsWithdrew[msg.sender] += transferring;\n', '\n', '        // Transfer funds from the contract to the sender. The gas for this\n', '        // transaction is paid for by msg.sender.\n', '        msg.sender.transfer(transferring);\n', '    }\n', '\n', '    // We do integer division (floor(a / b)) when calculating each share, because\n', "    // solidity doesn't have a decimal number type. This means there will be a\n", '    // maximum remainder of count - 1 wei locked in the contract. We ignore this\n', '    // because it is such a small amount of ethereum (1 Wei = 10^(-18)\n', '    // Ethereum). The extra Wei can be extracted by depositing an amount to make\n', '    // totalInput evenly divisable between count parties.\n', '\n', '    /// @notice Gets the amount of funds in Wei available to the sender.\n', '    function balance() constant returns (uint) {\n', '        if (!between[msg.sender]) {\n', "            // The sender of the message isn't part of the split. Ignore them.\n", '            return 0;\n', '        }\n', '\n', '        // `share` is the amount of funds which are available to each of the\n', '        // accounts specified in the constructor.\n', '        uint share = totalInput / count;\n', '        uint withdrew = amountsWithdrew[msg.sender];\n', '        uint available = share - withdrew;\n', '\n', '        assert(available >= 0 && available <= share);\n', '\n', '        return available;\n', '    }\n', '\n', '    // This function will be run when a transaction is sent to the contract\n', '    // without any data. It is minimal to save on gas costs.\n', '    function() payable {\n', '        totalInput += msg.value;\n', '    }\n', '}']
