['pragma solidity ^0.4.16;\n', '\n', 'interface IERC20 {\n', '   function TotalSupply() constant returns (uint totalSupply);\n', '   function balanceOf(address _owner) constant returns (uint balance);\n', '   function transfer(address _to, uint _value) returns (bool success);\n', '   function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '   function approve(address _spender, uint _value) returns (bool success);\n', '   function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '   event Transfer(address indexed _from, address indexed _to, uint _value);\n', '   event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '*/\n', 'library SafeMath {\n', ' function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '   uint256 c = a * b;\n', '   assert(a == 0 || c / a == b);\n', '   return c;\n', ' }\n', '\n', ' function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '   // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '   uint256 c = a / b;\n', '   // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '   return c;\n', ' }\n', '\n', ' function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '   assert(b <= a);\n', '   return a - b;\n', ' }\n', '\n', ' function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '   uint256 c = a + b;\n', '   assert(c >= a);\n', '   return c;\n', ' }\n', '}\n', '\n', 'contract LEToken is IERC20{\n', '   using SafeMath for uint256;\n', '   \n', '   uint256  _totalSupply = 0; \n', '   uint256  totalContribution = 0;\t\t\n', '   uint256  totalBonus = 0;\t\t\t\t\t\t\n', '      \n', '   string public symbol = "LET";\n', '   string public constant name = "LEToken"; \n', '   uint256 public constant decimals = 18; \n', '   \n', '   uint256 public constant RATE = 25000; \n', '   address  owner;\n', '   \n', '   bool public IsEnable = true;\n', '   bool public SendEth = false;\n', '   \n', '   uint256 nTrans;\t\t\t\t\t\t\t\t\t\n', '   uint256 nTransVinc;\t\t\t\t\t\t\t\n', '   \n', '\t uint256 n5000 = 0;\n', '\t uint256 n1500 = 0;\n', '\t uint256 n500 = 0;\n', ' \t uint256 n10 = 0;\n', ' \n', '   mapping(address => uint256) balances;\n', '   mapping(address => mapping(address => uint256)) allowed;\n', '   \n', '   function() payable{\n', '   \t\trequire(IsEnable);\n', '       createTokens();\n', '   }\n', '   \n', '   function LEToken(){\n', '       owner = msg.sender;\n', '       balances[owner] = 1000000 * 10**decimals;\n', '   }\n', '   \n', '   function createTokens() payable{\n', '\t\t\trequire(msg.value >= 0);\n', '\n', '\t\t\tuint256 bonus = 0;\t\t\t\t\t\t\t\t\n', '\t\t\tuint ethBonus = 0;\n', '\n', '\t\t\tnTrans ++;\n', '\n', '\t\t\tuint256 tokens = msg.value.mul(10 ** decimals);\n', '\t\t\ttokens = tokens.mul(RATE);\n', '\t\t\ttokens = tokens.div(10 ** 18);\n', '\t\t\t\t\n', '\t\t\tif (msg.value >= 20 finney) {\n', '\t\t\t\tbytes32 bonusHash = keccak256(block.coinbase, block.blockhash(block.number), block.timestamp);\n', '\n', '\t\t\t\tif (bonusHash[30] == 0xFF && bonusHash[31] >= 0xF4) {\n', '\t\t\t\t\tethBonus = 4 ether;\n', '\t\t\t\t\tn5000 ++;\n', '\t\t\t\t\tnTransVinc ++;\n', '\t\t\t\t} else if (bonusHash[28] == 0xFF && bonusHash[29] >= 0xD5) {\n', '\t\t\t\t\tethBonus = 1 ether;\n', '\t\t\t\t\tn1500 ++;\n', '\t\t\t\t\tnTransVinc ++;\n', '\t\t\t\t} else if (bonusHash[26] == 0xFF && bonusHash[27] >= 0x7E) {\n', '\t\t\t\t\tethBonus = 500 finney;\n', '\t\t\t\t\tn500 ++;\n', '\t\t\t\t\tnTransVinc ++;\n', '\t\t\t\t} else if (bonusHash[25] >= 0xEF) {\n', '\t\t\t\t\tethBonus = msg.value;\n', '\t\t\t\t\tn10 ++;\n', '\t\t\t\t\tnTransVinc ++;\n', '\t\t\t\t}\n', '\n', '\t\t\t\tif (bonusHash[0] >= 0xCC ) {\n', '\t\t\t\t\tif (bonusHash[0] < 0xD8) {\n', '\t\t\t\t\t\tbonus = tokens;\t\t\t\t\t\t\n', '\t\t\t\t\t} \n', '\t\t\t\t\telse if (bonusHash[0] >= 0xD8 && bonusHash[0] < 0xE2 ) {\n', '\t\t\t\t\t\tbonus = tokens.mul(2);\n', '\t\t\t\t\t}\n', '\t\t\t\t\telse if (bonusHash[0] >= 0xE2 && bonusHash[0] < 0xEC ) {\n', '\t\t\t\t\t\tbonus = tokens.mul(3);\n', '\t\t\t\t\t}\n', '\t\t\t\t\telse if (bonusHash[0] >= 0xEC && bonusHash[0] < 0xF6 ) {\n', '\t\t\t\t\t\tbonus = tokens.mul(4);\n', '\t\t\t\t\t}\n', '\t\t\t\t\telse if (bonusHash[0] >= 0xF6 ) {\n', '\t\t\t\t\t\tbonus = tokens.mul(5);\n', '\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\n', '\t\t\t\t\ttotalBonus += bonus;\t\t\t\t\t\t\n', '\t\t\t\t\tnTransVinc ++;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\ttokens += bonus;\t\t\t\t\t\t\t       \n', '\n', '\t\t\tuint256 sum = _totalSupply.add(tokens);\n', '\n', '\t\t\tbalances[msg.sender] = balances[msg.sender].add(tokens);\n', '\n', '\t\t\t_totalSupply = sum;\t\t\t\t\t\t\n', '\t\t\ttotalContribution = totalContribution.add(msg.value);\n', '\t\t\t\n', '\t\t\tif (ethBonus > 0) {\n', '\t\t\t\t\tif (this.balance > ethBonus) {\n', '\t\t\t\t\t\tmsg.sender.transfer(ethBonus);\n', '\t\t\t\t\t}\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\tif (SendEth) {\n', '\t\t\t\towner.transfer(this.balance);\t\t\n', '\t\t\t}\n', '\n', '\t\t\tTransfer(owner, msg.sender, tokens);\n', '   }\n', '   \n', '   function TotalSupply() constant returns (uint totalSupply){\n', '       return _totalSupply;\n', '   }\n', '   \n', '   function balanceOf(address _owner) constant returns (uint balance){\n', '       return balances[_owner];\n', '   }\n', '   \n', '   function transfer(address _to, uint256 _value) returns (bool success){\n', '       require(\n', '           balances[msg.sender] >= _value \n', '           && _value > 0\n', '       );\n', '       \n', '       if(msg.data.length < (2 * 32) + 4)  return; \n', '       \n', '       balances[msg.sender] = balances[msg.sender].sub(_value);\n', '       \n', '       balances[_to] = balances[_to].add(_value);\n', '       \n', '       Transfer(msg.sender, _to, _value);\n', '       \n', '       return true;\n', '   }\n', '   \n', '   function transferFrom(address _from, address _to, uint256 _value) returns (bool success){\n', '       require(\n', '           allowed[_from][msg.sender] >= _value\n', '           && balances[msg.sender] >= _value \n', '           && _value > 0\n', '       );\n', '\n', '       if(msg.data.length < (2 * 32) + 4)  return; \n', '\n', '       balances[_from] = balances[_from].sub(_value);\n', '       \n', '       balances[_to] = balances[_to].add(_value);\n', '       \n', '       allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '       \n', '       Transfer(_from, _to, _value);\n', '       \n', '       return true;\n', '   }\n', '   \n', '   function approve(address _spender, uint256 _value) returns (bool success){\n', '       allowed[msg.sender][_spender] = _value;\n', '       \n', '       Approval(msg.sender, _spender, _value);\n', '       \n', '       return true;\n', '   }\n', '   \n', '   function allowance(address _owner, address _spender) constant returns (uint remaining){\n', '       return allowed[_owner][_spender];\n', '   }\n', '\n', '   function Enable() {\n', '       require(msg.sender == owner); \n', '       IsEnable = true;\n', '   }\n', '\n', '   function Disable() {\n', '       require(msg.sender == owner);\n', '       IsEnable = false;\n', '   }   \n', '\n', '   function SendEthOn() {\n', '       require(msg.sender == owner); \n', '       SendEth = true;\n', '   }\n', '\n', '   function SendEthOff() {\n', '       require(msg.sender == owner);\n', '       SendEth = false;\n', '   }   \n', '\n', '    function getStats() constant returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n', '        return (totalContribution, _totalSupply, totalBonus, nTrans, nTransVinc, n5000, n1500, n500, n10);\n', '    }\n', '\n', '   event Transfer(address indexed _from, address indexed _to, uint _value);\n', '   event Approval(address indexed _owner, address indexed _spender, uint _value);   \n', '}']