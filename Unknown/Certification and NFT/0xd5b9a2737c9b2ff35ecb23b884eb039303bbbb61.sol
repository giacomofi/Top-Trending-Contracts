['/**\n', ' *  Beth token contract, ERC20 compliant (see https://github.com/ethereum/EIPs/issues/20)\n', ' *\n', ' *  Code is based on multiple sources:\n', ' *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20.sol\n', ' *  https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Token.sol\n', ' */\n', '\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Beth is Token {\n', '\n', '    function () {\n', '        //if ether is sent to this address, send it back.\n', '        throw;\n', '    }\n', '     \n', '    address public owner;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    //// Events ////\n', '    event MigrationInfoSet(string newMigrationInfo);\n', '    event FrozenFunds(address target, bool frozen);\n', '    \n', '    // This is to be used when migration to a new contract starts.\n', '    // This string can be used for any authorative information re the migration\n', '    // (e.g. address to use for migration, or URL to explain where to find more info)\n', '    string public migrationInfo = "";\n', '\n', '    modifier onlyOwner{ if (msg.sender != owner) throw; _; }\n', '\n', '    /* Public variables of the token */\n', '    string public name = "Beth";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "BTH";\n', '    string public version = "1.0";\n', '\n', '    bool private stopped = false;\n', '    modifier stopInEmergency { if (!stopped) _; }\n', '\n', '    function Beth() {\n', '        owner = 0xa62dFc3a5bf6ceE820B916d5eF054A29826642e8;\n', '        balances[0xa62dFc3a5bf6ceE820B916d5eF054A29826642e8] = 2832955 * 1 ether;\n', '        totalSupply = 2832955* 1 ether;\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) stopInEmergency returns (bool success) {\n', '        if (frozenAccount[msg.sender]) throw;                // Check if frozen\n', '        if (balances[msg.sender] < _value) throw;\n', '        if (_value <= 0) throw;\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) stopInEmergency  returns (bool success) {\n', '        if (frozenAccount[msg.sender]) throw;                // Check if frozen\n', '        if (balances[_from] < _value) throw;\n', '        if (allowed[_from][msg.sender] < _value) throw;\n', '        if (_value <= 0) throw;\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /* Approves and then calls the receiving contract */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        \n', '        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n', '        if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) {\n', '            throw; \n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Allows setting a descriptive string, which will aid any users in migrating their token\n', '    // to a newer version of the contract. This field provides a kind of &#39;double-layer&#39; of\n', '    // authentication for any migration announcement, as it can only be set by WeTrust.\n', '    /// @param _migrationInfo The information string to be stored on the contract\n', '    function setMigrationInfo(string _migrationInfo) onlyOwner public {\n', '        migrationInfo = _migrationInfo;\n', '        MigrationInfoSet(_migrationInfo);\n', '    }\n', '\n', '    // Owner can set any account into freeze state. It is helpful in case if account holder has \n', '    // lost his key and he want administrator to freeze account until account key is recovered\n', '    // @param target The account address\n', '    // @param freeze The state of account\n', '    function freezeAccount(address target, bool freeze) onlyOwner {\n', '        frozenAccount[target] = freeze;\n', '        FrozenFunds(target, freeze);\n', '    }\n', '\n', '    // It is called Circuit Breakers (Pause contract functionality), it stop execution if certain conditions are met, \n', '    // and can be useful when new errors are discovered. For example, most actions may be suspended in a contract if a \n', '    // bug is discovered, so the most feasible option to stop and updated migration message about launching an updated version of contract. \n', '    // @param _stop Switch the circuite breaker on or off\n', '    function emergencyStop(bool _stop) onlyOwner {\n', '        stopped = _stop;\n', '    }\n', '\n', '    // changeOwner is used to change the administrator of the contract. This can be useful if owner account is suspected to be compromised\n', '    // and you have luck to update owner.\n', '    // @param _newOwner Address of new owner\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        balances[_newOwner] = balances[owner];\n', '        balances[owner] = 0;\n', '        owner = _newOwner;\n', '        Transfer(owner, _newOwner,balances[_newOwner]);\n', '    }\n', '\n', '}']
['/**\n', ' *  Beth token contract, ERC20 compliant (see https://github.com/ethereum/EIPs/issues/20)\n', ' *\n', ' *  Code is based on multiple sources:\n', ' *  https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20.sol\n', ' *  https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Token.sol\n', ' */\n', '\n', 'pragma solidity ^0.4.8;\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Beth is Token {\n', '\n', '    function () {\n', '        //if ether is sent to this address, send it back.\n', '        throw;\n', '    }\n', '     \n', '    address public owner;\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    mapping (address => bool) public frozenAccount;\n', '\n', '    //// Events ////\n', '    event MigrationInfoSet(string newMigrationInfo);\n', '    event FrozenFunds(address target, bool frozen);\n', '    \n', '    // This is to be used when migration to a new contract starts.\n', '    // This string can be used for any authorative information re the migration\n', '    // (e.g. address to use for migration, or URL to explain where to find more info)\n', '    string public migrationInfo = "";\n', '\n', '    modifier onlyOwner{ if (msg.sender != owner) throw; _; }\n', '\n', '    /* Public variables of the token */\n', '    string public name = "Beth";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "BTH";\n', '    string public version = "1.0";\n', '\n', '    bool private stopped = false;\n', '    modifier stopInEmergency { if (!stopped) _; }\n', '\n', '    function Beth() {\n', '        owner = 0xa62dFc3a5bf6ceE820B916d5eF054A29826642e8;\n', '        balances[0xa62dFc3a5bf6ceE820B916d5eF054A29826642e8] = 2832955 * 1 ether;\n', '        totalSupply = 2832955* 1 ether;\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) stopInEmergency returns (bool success) {\n', '        if (frozenAccount[msg.sender]) throw;                // Check if frozen\n', '        if (balances[msg.sender] < _value) throw;\n', '        if (_value <= 0) throw;\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) stopInEmergency  returns (bool success) {\n', '        if (frozenAccount[msg.sender]) throw;                // Check if frozen\n', '        if (balances[_from] < _value) throw;\n', '        if (allowed[_from][msg.sender] < _value) throw;\n', '        if (_value <= 0) throw;\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /* Approves and then calls the receiving contract */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        \n', '        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n', '        if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) {\n', '            throw; \n', '        }\n', '        return true;\n', '    }\n', '\n', '    // Allows setting a descriptive string, which will aid any users in migrating their token\n', "    // to a newer version of the contract. This field provides a kind of 'double-layer' of\n", '    // authentication for any migration announcement, as it can only be set by WeTrust.\n', '    /// @param _migrationInfo The information string to be stored on the contract\n', '    function setMigrationInfo(string _migrationInfo) onlyOwner public {\n', '        migrationInfo = _migrationInfo;\n', '        MigrationInfoSet(_migrationInfo);\n', '    }\n', '\n', '    // Owner can set any account into freeze state. It is helpful in case if account holder has \n', '    // lost his key and he want administrator to freeze account until account key is recovered\n', '    // @param target The account address\n', '    // @param freeze The state of account\n', '    function freezeAccount(address target, bool freeze) onlyOwner {\n', '        frozenAccount[target] = freeze;\n', '        FrozenFunds(target, freeze);\n', '    }\n', '\n', '    // It is called Circuit Breakers (Pause contract functionality), it stop execution if certain conditions are met, \n', '    // and can be useful when new errors are discovered. For example, most actions may be suspended in a contract if a \n', '    // bug is discovered, so the most feasible option to stop and updated migration message about launching an updated version of contract. \n', '    // @param _stop Switch the circuite breaker on or off\n', '    function emergencyStop(bool _stop) onlyOwner {\n', '        stopped = _stop;\n', '    }\n', '\n', '    // changeOwner is used to change the administrator of the contract. This can be useful if owner account is suspected to be compromised\n', '    // and you have luck to update owner.\n', '    // @param _newOwner Address of new owner\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        balances[_newOwner] = balances[owner];\n', '        balances[owner] = 0;\n', '        owner = _newOwner;\n', '        Transfer(owner, _newOwner,balances[_newOwner]);\n', '    }\n', '\n', '}']
