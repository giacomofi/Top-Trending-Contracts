['contract JackPot {\n', '    address public host;\n', '\tuint minAmount;\n', '    uint[] public contributions;\n', '    address[] public contributors;\n', '\tuint public numPlayers;\n', '\tuint public nextDraw;\n', '\tbytes32 public seedHash;\n', '\tbytes32 random;\t\n', '\n', '    struct Win {\n', '        address winner;\n', '        uint timestamp;\n', '        uint contribution;\n', '\t\tuint amountWon;\n', '    }\n', '\n', '    Win[] public recentWins;\n', '    uint recentWinsCount = 10;\n', '\t\n', '\tfunction insert_contribution(address addr, uint value) internal {\n', '\t\t// check if array needs extending\n', '\t\tif(numPlayers == contributions.length) {\n', '\t\t\t// extend the arrays\n', '\t\t\tcontributions.length += 1;\n', '\t\t\tcontributors.length += 1;\n', '\t\t}\n', '\t\tcontributions[numPlayers] = value;\n', '\t\tcontributors[numPlayers++] = addr;\n', '\t}\n', '\t\n', '\tfunction getContributions(address addr) constant returns (uint) {\n', '        uint i;\n', '        for (i=0; i < numPlayers; i++) {\n', '\t\t\tif (contributors[i] == addr) { // if in the list already\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\tif(i == numPlayers) { // Did not find sender already in the list\n', '            return 0;\n', '        } else {\n', '\t\t\treturn contributions[i];\n', '\t\t}\n', '    }\n', '\t\n', '\tfunction JackPot() {\n', '        host = msg.sender;\n', "\t\tseedHash = sha3('aaaa');\n", '\t\tminAmount = 10 * 1 finney;\n', '        recentWinsCount = 10;\n', '\t\tnextDraw = 1234;\n', '    }\n', '\n', '    function() {\n', '        addToContribution();\n', '    }\n', '\n', '    function addToContribution() {\n', '        addValueToContribution(msg.value);\n', '    }\n', '\n', '    function addValueToContribution(uint value) internal {\n', '        // First, make sure this is a valid transaction.\n', '        if(value < minAmount) throw;\n', '\t    uint i;\n', '        for (i=0; i < numPlayers; i++) {\n', '\t\t\tif (contributors[i] == msg.sender) { // Already contributed?\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\tif(i == numPlayers) { // Did not find sender already in the list\n', '\t\t\tinsert_contribution(msg.sender, value);\n', '        } else {\n', '\t\t\tcontributions[i]+= value; // Update amount\n', '\t\t}\n', '\t\t\n', '\t\trandom = sha3(random, block.blockhash(block.number - 1));\t\t\n', '    }\n', '\t\n', '\t//drawPot triggered from Host after time has passed or pot is matured.\n', '\tfunction drawPot(string seed, string newSeed) {\n', '\t\tif(msg.sender != host) throw;\n', '\t\tif (sha3(seed) == seedHash) {\n', '\t\t\t\n', '\t\t\t// Initialize seedHash for next draw\n', '\t\t\tseedHash = sha3(newSeed);\n', '\t\t\t// Choose a winner using the seed as random\n', '\t\t\tuint winner_index = selectWinner(seed);\n', '\n', '\t\t\t// Send the developer a 1% fee\n', '\t\t\thost.send(this.balance / 100);\n', '\t\t\t\n', '\t\t\tuint amountWon = this.balance; \n', '\t\t\t\n', '\t\t\t// Send the winner the remaining balance on the contract.\n', '\t\t\tcontributors[winner_index].send(this.balance);\n', '\t\t\t\n', '\t\t\t// Make a note that someone won, then start all over!\n', '\t\t\trecordWin(winner_index, amountWon);\n', '\n', '\t\t\treset();\n', '\t\t\tnextDraw = now + 7 days;\t\n', '\n', '\t\t}\n', '\t}\n', '\n', '\tfunction setDrawDate(uint _newDraw) {\n', '\t\tif(msg.sender != host) throw;\n', '\t\tnextDraw = _newDraw;\n', '\t}\n', '\t\n', '\t\n', '    function selectWinner(string seed) internal returns (uint winner_index) {\n', '\n', '        uint semirandom = uint(sha3(random, seed)) % this.balance;\n', '        for(uint i = 0; i < numPlayers; ++i) {\n', '            if(semirandom < contributions[i]) return i;\n', '            semirandom -= contributions[i];\n', '        }\n', '    }\n', '\n', '    function recordWin(uint winner_index, uint amount) internal {\n', '        if(recentWins.length < recentWinsCount) {\n', '            recentWins.length++;\n', '        } else {\n', '            // Already at capacity for the number of winners to remember.\n', "            // Forget the oldest one by shifting each entry 'left'\n", '            for(uint i = 0; i < recentWinsCount - 1; ++i) {\n', '                recentWins[i] = recentWins[i + 1];\n', '            }\n', '        }\n', '\n', '        recentWins[recentWins.length - 1] = Win(contributors[winner_index], block.timestamp, contributions[winner_index], amount);\n', '    }\n', '\n', '    function reset() internal {\n', '        // Clear the lists with min gas after the draw.\n', '\t\tnumPlayers = 0;\n', '    }\n', '\n', '\n', '    /* This should only be needed if a bug is discovered\n', '    in the code and the contract must be destroyed. */\n', '    function destroy() {\n', '        if(msg.sender != host) throw;\n', '\n', "        // Refund everyone's contributions.\n", '        for(uint i = 0; i < numPlayers; ++i) {\n', '            contributors[i].send(contributions[i]);\n', '        }\n', '\n', '\t\treset();\n', '        selfdestruct(host);\n', '    }\n', '}']