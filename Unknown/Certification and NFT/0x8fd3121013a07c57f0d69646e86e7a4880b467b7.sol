['pragma solidity ^0.4.11;\n', '\n', '// See the Github at https://github.com/airswap/contracts\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/* Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20 */\n', '\n', 'contract ERC20 is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) public balances; // *added public\n', '    mapping (address => mapping (address => uint256)) public allowed; // *added public\n', '}\n', '\n', '/** @title AirSwap exchange contract.\n', '  * Assumes makers and takers have approved this contract to access their balances.\n', '  */\n', 'contract AirSwapExchange {\n', '\n', '    // Mapping of order hash to bool (true = already filled).\n', '    mapping (bytes32 => bool) public fills;\n', '\n', '    // Events that are emitted in different scenarios.\n', '    event Filled(address indexed makerAddress, uint makerAmount, address indexed makerToken, address takerAddress, uint takerAmount, address indexed takerToken, uint256 expiration, uint256 nonce);\n', '    event Canceled(address indexed makerAddress, uint makerAmount, address indexed makerToken, address takerAddress, uint takerAmount, address indexed takerToken, uint256 expiration, uint256 nonce);\n', '\n', '    /** Event thrown when a trade fails\n', '      * Error codes:\n', "      * 1 -> 'The makeAddress and takerAddress must be different',\n", "      * 2 -> 'The order has expired',\n", "      * 3 -> 'This order has already been filled',\n", "      * 4 -> 'The ether sent with this transaction does not match takerAmount',\n", "      * 5 -> 'No ether is required for a trade between tokens',\n", "      * 6 -> 'The sender of this transaction must match the takerAddress',\n", "      * 7 -> 'Order has already been cancelled or filled'\n", '      */\n', '    event Failed(uint code, address indexed makerAddress, uint makerAmount, address indexed makerToken, address takerAddress, uint takerAmount, address indexed takerToken, uint256 expiration, uint256 nonce);\n', '\n', '    /** Fills an order by transferring tokens between (maker or escrow) and taker.\n', '      * maker is given tokenA to taker,\n', '      */\n', '    function fill(address makerAddress, uint makerAmount, address makerToken,\n', '                  address takerAddress, uint takerAmount, address takerToken,\n', '                  uint256 expiration, uint256 nonce, uint8 v, bytes32 r, bytes32 s) payable {\n', '\n', '        if (makerAddress == takerAddress) {\n', '            msg.sender.transfer(msg.value);\n', '            Failed(1,\n', '            makerAddress, makerAmount, makerToken,\n', '            takerAddress, takerAmount, takerToken,\n', '            expiration, nonce);\n', '            return;\n', '        }\n', '\n', '        // Check if this order has expired\n', '        if (expiration < now) {\n', '            msg.sender.transfer(msg.value);\n', '            Failed(2,\n', '                makerAddress, makerAmount, makerToken,\n', '                takerAddress, takerAmount, takerToken,\n', '                expiration, nonce);\n', '            return;\n', '        }\n', '\n', '        // Validate the message by signature.\n', '        bytes32 hash = validate(makerAddress, makerAmount, makerToken,\n', '            takerAddress, takerAmount, takerToken,\n', '            expiration, nonce, v, r, s);\n', '\n', '        // Check if this order has already been filled\n', '        if (fills[hash]) {\n', '            msg.sender.transfer(msg.value);\n', '            Failed(3,\n', '                makerAddress, makerAmount, makerToken,\n', '                takerAddress, takerAmount, takerToken,\n', '                expiration, nonce);\n', '            return;\n', '        }\n', '\n', '        // Check to see if this an order for ether.\n', '        if (takerToken == address(0x0)) {\n', '\n', '            // Check to make sure the message value is the order amount.\n', '            if (msg.value == takerAmount) {\n', '\n', '                // Mark order as filled to prevent reentrancy.\n', '                fills[hash] = true;\n', '\n', '                // Perform the trade between makerAddress and takerAddress.\n', "                // The transfer will throw if there's a problem.\n", '                assert(transfer(makerAddress, takerAddress, makerAmount, makerToken));\n', '\n', '                // Transfer the ether received from sender to makerAddress.\n', '                makerAddress.transfer(msg.value);\n', '\n', '                // Log an event to indicate completion.\n', '                Filled(makerAddress, makerAmount, makerToken,\n', '                    takerAddress, takerAmount, takerToken,\n', '                    expiration, nonce);\n', '\n', '            } else {\n', '                msg.sender.transfer(msg.value);\n', '                Failed(4,\n', '                    makerAddress, makerAmount, makerToken,\n', '                    takerAddress, takerAmount, takerToken,\n', '                    expiration, nonce);\n', '            }\n', '\n', '        } else {\n', '            // This is an order trading two tokens\n', '            // Check that no ether has been sent accidentally\n', '            if (msg.value != 0) {\n', '                msg.sender.transfer(msg.value);\n', '                Failed(5,\n', '                    makerAddress, makerAmount, makerToken,\n', '                    takerAddress, takerAmount, takerToken,\n', '                    expiration, nonce);\n', '                return;\n', '            }\n', '\n', '            if (takerAddress == msg.sender) {\n', '\n', '                // Mark order as filled to prevent reentrancy.\n', '                fills[hash] = true;\n', '\n', '                // Perform the trade between makerAddress and takerAddress.\n', "                // The transfer will throw if there's a problem.\n", '                // Assert should never fail\n', '                assert(trade(makerAddress, makerAmount, makerToken,\n', '                    takerAddress, takerAmount, takerToken));\n', '\n', '                // Log an event to indicate completion.\n', '                Filled(\n', '                    makerAddress, makerAmount, makerToken,\n', '                    takerAddress, takerAmount, takerToken,\n', '                    expiration, nonce);\n', '\n', '            } else {\n', '                Failed(6,\n', '                    makerAddress, makerAmount, makerToken,\n', '                    takerAddress, takerAmount, takerToken,\n', '                    expiration, nonce);\n', '            }\n', '        }\n', '    }\n', '\n', '    /** Cancels an order by refunding escrow and adding it to the fills mapping.\n', '      * Will log an event if\n', '      * - order has been cancelled or\n', '      * - order has already been filled\n', '      * and will do nothing if the maker of the order in question is not the\n', '      * msg.sender\n', '      */\n', '    function cancel(address makerAddress, uint makerAmount, address makerToken,\n', '                    address takerAddress, uint takerAmount, address takerToken,\n', '                    uint256 expiration, uint256 nonce, uint8 v, bytes32 r, bytes32 s) {\n', '\n', '        // Validate the message by signature.\n', '        bytes32 hash = validate(makerAddress, makerAmount, makerToken,\n', '            takerAddress, takerAmount, takerToken,\n', '            expiration, nonce, v, r, s);\n', '\n', '        // Only the maker can cancel an order\n', '        if (msg.sender == makerAddress) {\n', '\n', '            // Check that order has not already been filled/cancelled\n', '            if (fills[hash] == false) {\n', '\n', '                // Cancel the order by considering it filled.\n', '                fills[hash] = true;\n', '\n', '                // Broadcast an event to the blockchain.\n', '                Canceled(makerAddress, makerAmount, makerToken,\n', '                    takerAddress, takerAmount, takerToken,\n', '                    expiration, nonce);\n', '\n', '            } else {\n', '                Failed(7,\n', '                    makerAddress, makerAmount, makerToken,\n', '                    takerAddress, takerAmount, takerToken,\n', '                    expiration, nonce);\n', '            }\n', '        }\n', '    }\n', '\n', '    /** Atomic trade of tokens between first party and second party.\n', '      * Throws if one of the trades does not go through.\n', '      */\n', '    function trade(address makerAddress, uint makerAmount, address makerToken,\n', '                   address takerAddress, uint takerAmount, address takerToken) private returns (bool) {\n', '        return (transfer(makerAddress, takerAddress, makerAmount, makerToken) &&\n', '        transfer(takerAddress, makerAddress, takerAmount, takerToken));\n', '    }\n', '\n', '    /** Transfers tokens from first party to second party.\n', '      * Prior to a transfer being done by the contract, ensure that\n', '      * tokenVal.approve(this, amount, {from : address}) has been called\n', '      * throws if the transferFrom of the token returns false\n', '      * returns true if, the transfer went through\n', '      */\n', '    function transfer(address from, address to, uint amount, address token) private returns (bool) {\n', '        require(ERC20(token).transferFrom(from, to, amount));\n', '        return true;\n', '    }\n', '\n', '    /** Validates order arguments for fill() and cancel() functions. */\n', '    function validate(address makerAddress, uint makerAmount, address makerToken,\n', '                      address takerAddress, uint takerAmount, address takerToken,\n', '                      uint256 expiration, uint256 nonce, uint8 v, bytes32 r, bytes32 s) private returns (bytes32) {\n', '\n', '        // Hash arguments to identify the order.\n', '        bytes32 hashV = keccak256(makerAddress, makerAmount, makerToken,\n', '            takerAddress, takerAmount, takerToken,\n', '            expiration, nonce);\n', '\n', '        bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '        bytes32 prefixedHash = sha3(prefix, hashV);\n', '\n', '        require(ecrecover(prefixedHash, v, r, s) == makerAddress);\n', '\n', '        return hashV;\n', '    }\n', '}']