['pragma solidity ^0.4.11;//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNKOkOKWMMMMMM //\n', '// MMMMWKkk0KNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNKOkOKWMMMMMM //\n', '// MMMMXl.....,cdOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOo:,.....dNMMMM //\n', '// MMMWd.        .&#39;cxKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMW0d:&#39;.        .xMMMM //\n', '// MMMK,   ......   ..:xXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKd;.    .....    :XMMM //\n', '// MMWd.   .;;;,,&#39;..   .&#39;lkXNWWNNNWMMMMMMMMMMWNNWWWNKkc..  ...&#39;,;;;,.   .kMMM //\n', '// MMNc   .,::::::;,&#39;..   ..,;;,,dNMMMMMMMMMMXl,;;;,..   ..&#39;;;::::::&#39;.  .lWMM //\n', '// MM0&#39;   .;:::::::;;&#39;..        ;0MMMMMMMMMMMWO&#39;        ..,;;:::::::;.   ;KMM //\n', '// MMx.  .&#39;;::::;,&#39;...        .:0MMMMMMMMMMMMMWO;.        ...&#39;;;::::;..  .OMM //\n', '// MWd.  .,:::;&#39;..          .,xNMMMMMMMMMMMMMMMMXd&#39;.          ..,;:::&#39;.  .xMM //\n', '// MNl.  .,:;&#39;..         .,ckNMMMMMMMMMMMMMMMMMMMMXxc&#39;.         ..&#39;;:,.  .dWM //\n', '// MNc   .,,..    .;:clox0NWXXWMMMMMMMMMMMMMMMMMMWXXWXOxolc:;.    ..,&#39;.  .oWM //\n', '// MNc   ...     .oWMMMNXNMW0odXMMMMMMMMMMMMMMMMKooKWMNXNMMMNc.     ...  .oWM //\n', '// MNc.          ;KMMMMNkokNMXlcKMMMMMMMMMMMMMM0coNMNxoOWMMMM0,          .oWM //\n', '// MNc         .;0MMMMMMWO:dNMNoxWMMMMMMMMMMMMNddNMNocKMMMMMMWO,         .oWM //\n', '// MX:        .lXMMMMMMMMM0lOMMNXWMMMMMMMMMMMMWXNMMklKMMMMMMMMM0:.       .lNM //\n', '// MX;      .;kWMMMMMMMMMMMXNMMMMMMMMMMMMMMMMMMMMMMNNMMMMMMMMMMMNx,.      cNM //\n', '// MO.    .:kNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNx:.  . ,0M //\n', '// Wl..&#39;:dKWMMMMMMMWNK000KNMMMMMMMMMMMMMMMMMMMMMMMMMWNK000KNMMMMMMMMW0o;...dW //\n', '// NxdOXWMMMMMMMW0olcc::;,,cxXWMMMMMMMMMMMMMMMMMMWKd:,,;::ccld0WMMMMMMMWKkokW //\n', '// MMMMMMMMMMMWOlcd0XWWWN0x:.,OMMMMMMMMMMMMMMMMMWk,&#39;cxKNWWWXOdcl0MMMMMMMMMMMM //\n', '// MMMMMMMMMMMWKKWMMMMMMMMMWK0XMMMMMMMMMMMMMMMMMMXOXWMMMMMMMMMN0XMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWK0OOOO0KWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNo.......&#39;xWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMNKOkkkk0XNMMMMMMMMMMMMMMMMMMWO;.    .:0WMMMMMMMMMMMMMMMMMWNKOkkkkOKNMMM //\n', '// MMWXOkxddoddxxkKWMMMMMMMMMMMMMMMMXo...&#39;dNMMMMMMMMMMMMMMMMN0kxxdodddxk0XMMM //\n', '// MMMMMMMMMMMMWNKKNMMMMMMMMMMMMMMMMWOc,,c0WMMMMMMMMMMMMMMMMXKKNWMMMMMMMMMMMM //\n', '// MMMMMMMMWXKKXXNWMMMMMMMMMMWWWWWX0xcclc:cxKNWWWWWMMMMMMMMMMWNXXKKXWMMMMMMMM //\n', '// MMMWXOxdoooddxkO0NMMMMMMMWKkfoahheitNX0GlikkdakXMMMMMMMWX0OkxddooddxOXWMMM //\n', '// MMMWXKKNNWMMMMMWWWMMMMMMMMMWNXXXNWMMMMMMWXXXXNWMMMMMMMMMWWWMMMMWWNXKKNWMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM Lucky* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMM> *~+> we are the MMMMMMMMMMMM Number MMMMMMM> we are the <+~* <MMMMMMM //\n', '// MMMMMMMMMM> music <MMMMMMMMMMMMMM ------ MMMMMMMMMM> dreamer <MMMMMMMMMMMM //\n', '// MMMMMMMM> *~+> makers <MMMMM<MMMM Random MMMMMMMMMMMMM> of <MMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM Ledger MMMMMMMMMMMMMM> dreams. <+~* <MMM //\n', '// M> palimpsest by <MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// ~> arkimedes.eth <~+~+~+~~+~+~+~~+~+~+~~+~+~+~~+~+~+~~> VIII*XII*MMXVII <~ //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '\n', '/**\n', ' * Manages contract ownership.\n', ' */\n', 'contract Owned {\n', '    address public owner;\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * Function to recover the funds on the contract\n', ' */\n', 'contract Mortal is Owned {\n', '    function kill() onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/**\n', ' * SafeMath\n', ' * Math operations with safety checks that throw on error.\n', ' * Taking ideas from FirstBlood token. Enhanced by OpenZeppelin.\n', ' */\n', 'contract SafeMath {\n', '  function mul(uint256 a, uint256 b)\n', '  internal\n', '  constant\n', '  returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b)\n', '  internal\n', '  constant\n', '  returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b)\n', '  internal\n', '  constant\n', '  returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b)\n', '  internal\n', '  constant\n', '  returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * Random number generator from mined block hash.\n', ' */\n', 'contract Random is SafeMath {\n', '    // Generates a random number from 1 to max based on the last block hash.\n', '    function getRandomFromBlockHash(uint blockNumber, uint max)\n', '    public\n', '    constant \n', '    returns(uint) {\n', '        // block.blockhash(uint blockNumber)\n', '        //    returns\n', '        //    (bytes32):\n', '        //        hash of the given block\n', '        // !! only works for 256 most recent blocks excluding current !!\n', '        return(add(uint(sha3(block.blockhash(blockNumber))) % max, 1));\n', '    }\n', '}\n', '\n', '/**\n', ' * RandomLedger is the main public interface for a random number ledger.\n', ' * To make a request:\n', ' * Step 1: Call requestNumber with the `cost` as the value\n', ' * Step 2: Wait waitTime in blocks past the block which mines transaction for requestNumber\n', ' * Step 3: Call revealNumber to generate the number, and make it publicly accessable in the UI.\n', ' *         this is required to create the Events which generate the Ledger. \n', ' */\n', 'contract RandomLedger is Owned {\n', '    // ~> cost to generate a random number in Wei.\n', '    uint256 public cost;\n', '    // ~> waitTime is the number of blocks before random is generated.\n', '    uint8 public waitTime;\n', '    // ~> set default max\n', '    uint256 public max;\n', '\n', '    // PendingNumber represents one number.\n', '    struct PendingNumber {\n', '        address requestProxy;\n', '        uint256 renderedNumber;\n', '        uint256 originBlock;\n', '        uint256 max;\n', '        // blocks to wait,\n', '        // also maintains pending state\n', '        uint8 waitTime;\n', '    }\n', '\n', '    // for Number Ledger\n', '    event EventRandomLedgerRequested(address requestor, uint256 max, uint256 originBlock, uint8 waitTime, address indexed requestProxy);\n', '    event EventRandomLedgerRevealed(address requestor, uint256 originBlock, uint256 renderedNumber, address indexed requestProxy);\n', '    \n', '    mapping (address => PendingNumber) pendingNumbers;\n', '    mapping (address => bool) public whiteList;\n', '\n', '    function requestNumber(address _requestor, uint256 _max, uint8 _waitTime) payable public;\n', '    function revealNumber(address _requestor) payable public;\n', '}\n', '\n', '/**\n', ' * Lucky Number :: Random Ledger Service *~+>\n', ' * Any contract or address can make a request from this implementation\n', ' * on behalf of any other address as a requestProxy.\n', ' */\n', 'contract RandomLedgerService is RandomLedger, Mortal, Random {\n', '    \n', '    // Initialize state +.+.+.\n', '    function RandomLedgerService() {\n', '        owned();\n', '        cost = 20000000000000000; // 0.02 ether // 20 finney\n', '        max = 21; // generate number between 1 and 21\n', '        waitTime = 5; // 5 blocks\n', '    }\n', '\n', '    // Let owner customize defauts.\n', '    // Allow the owner to set max.\n', '    function setMax(uint256 _max)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        max = _max;\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to set waitTime. (in blocks)\n', '    function setWaitTime(uint8 _waitTime)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        waitTime = _waitTime;\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to set cost.\n', '    function setCost(uint256 _cost)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        cost = _cost;\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to set a transaction proxy\n', '    // which can perform value exchanges on behalf of this contract.\n', '    // (unrelated to the requestProxy which is not whiteList)\n', '    function enableProxy(address _proxy)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        whiteList[_proxy] = true;\n', '        return whiteList[_proxy];\n', '    }\n', '\n', '    function removeProxy(address _proxy)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        delete whiteList[_proxy];\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to cash out the holdings of this contract.\n', '    function withdraw(address _recipient, uint256 _balance)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        _recipient.transfer(_balance);\n', '        return true;\n', '    }\n', '\n', '    // Assume that simple transactions are trying to request a number,\n', '    // unless it is from the owner.\n', '    function () payable public {\n', '        assert(msg.sender != owner);\n', '        requestNumber(msg.sender, max, waitTime);\n', '    }\n', '    \n', '    // Request a Number ... *~>\n', '    function requestNumber(address _requestor, uint256 _max, uint8 _waitTime)\n', '    payable \n', '    public {\n', '        // external requirement: \n', '        // value must exceed cost\n', '        // unless address is whitelisted\n', '        if (!whiteList[msg.sender]) {\n', '            require(!(msg.value < cost));\n', '        }\n', '\n', '        // internal requirement: \n', '        // request address must not have pending number\n', '        assert(!isRequestPending(_requestor));\n', '        // set pending number\n', '        pendingNumbers[_requestor] = PendingNumber({\n', '            requestProxy: tx.origin, // requestProxy: original address that kicked off the transaction\n', '            renderedNumber: 0,\n', '            max: max,\n', '            originBlock: block.number,\n', '            waitTime: waitTime\n', '        });\n', '        if (_max > 1) {\n', '            pendingNumbers[_requestor].max = _max;\n', '        }\n', '        // max 250 wait to leave a few blocks\n', '        // for the reveal transction to occur\n', '        // and write from the pending numbers block\n', '        // before it expires\n', '        if (_waitTime > 0 && _waitTime < 250) {\n', '            pendingNumbers[_requestor].waitTime = _waitTime;\n', '        }\n', '        EventRandomLedgerRequested(_requestor, pendingNumbers[_requestor].max, pendingNumbers[_requestor].originBlock, pendingNumbers[_requestor].waitTime, pendingNumbers[_requestor].requestProxy);\n', '    }\n', '\n', '    // Reveal your number ... *~>\n', '    // Only requestor or proxy can generate the number\n', '    function revealNumber(address _requestor)\n', '    public\n', '    payable {\n', '        assert(_canReveal(_requestor, msg.sender));\n', '        // waitTime has passed, render this requestor&#39;s number.\n', '        _revealNumber(_requestor);\n', '    }\n', '\n', '    // Internal implementation of revealNumber().\n', '    function _revealNumber(address _requestor) \n', '    internal {\n', '        uint256 luckyBlock = _revealBlock(_requestor);\n', '        // \n', '        // TIME LIMITATION ~> should handle in user interface\n', '        // blocks older than (currentBlock - 256) \n', '        // "expire" and read the same hash as most recent valid block\n', '        // \n', '        uint256 luckyNumber = getRandomFromBlockHash(luckyBlock, pendingNumbers[_requestor].max);\n', '\n', '        // set new values\n', '        pendingNumbers[_requestor].renderedNumber = luckyNumber;\n', '        // event\n', '        EventRandomLedgerRevealed(_requestor, pendingNumbers[_requestor].originBlock, pendingNumbers[_requestor].renderedNumber, pendingNumbers[_requestor].requestProxy);\n', '        // zero out wait blocks since this is now inactive (for state management)\n', '        pendingNumbers[_requestor].waitTime = 0;\n', '    }\n', '\n', '    function canReveal(address _requestor)\n', '    public\n', '    constant\n', '    returns (bool, uint, uint, address, address) {\n', '        return (_canReveal(_requestor, msg.sender), _remainingBlocks(_requestor), _revealBlock(_requestor), _requestor, msg.sender);\n', '    }\n', '\n', '    function _canReveal(address _requestor, address _proxy) \n', '    internal\n', '    constant\n', '    returns (bool) {\n', '        // check for pending number request\n', '        if (isRequestPending(_requestor)) {\n', '            // check for no remaining blocks to be mined\n', '            // must wait for `pendingNumbers[_requestor].waitTime` to be excceeded\n', '            if (_remainingBlocks(_requestor) == 0) {\n', '                // check for ownership\n', '                if (pendingNumbers[_requestor].requestProxy == _requestor || pendingNumbers[_requestor].requestProxy == _proxy) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function _remainingBlocks(address _requestor)\n', '    internal\n', '    constant\n', '    returns (uint) {\n', '        uint256 revealBlock = add(pendingNumbers[_requestor].originBlock, pendingNumbers[_requestor].waitTime);\n', '        uint256 remainingBlocks = 0;\n', '        if (revealBlock > block.number) {\n', '            remainingBlocks = sub(revealBlock, block.number);\n', '        }\n', '        return remainingBlocks;\n', '    }\n', '\n', '    function _revealBlock(address _requestor)\n', '    internal\n', '    constant\n', '    returns (uint) {\n', '        // add wait block time\n', '        // to creation block time\n', '        // then subtract 1\n', '        return add(pendingNumbers[_requestor].originBlock, pendingNumbers[_requestor].waitTime);\n', '    }\n', '\n', '\n', '    function getNumber(address _requestor)\n', '    public\n', '    constant\n', '    returns (uint, uint, uint, address) {\n', '        return (pendingNumbers[_requestor].renderedNumber, pendingNumbers[_requestor].max, pendingNumbers[_requestor].originBlock, _requestor);\n', '    }\n', '\n', '    // is a number request pending for the address\n', '    function isRequestPending(address _requestor)\n', '    public\n', '    constant\n', '    returns (bool) {\n', '        if (pendingNumbers[_requestor].renderedNumber == 0 && pendingNumbers[_requestor].waitTime > 0) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '// 0xMMWKkk0KN/>HBBi/MASSa/DANTi/LANTen.MI.MI.MI.M+.+.+.M->MMWNKOkOKWJ.J.J.M*~+>\n', '}']
['pragma solidity ^0.4.11;//MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNKOkOKWMMMMMM //\n', '// MMMMWKkk0KNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNKOkOKWMMMMMM //\n', '// MMMMXl.....,cdOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOo:,.....dNMMMM //\n', "// MMMWd.        .'cxKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMW0d:'.        .xMMMM //\n", '// MMMK,   ......   ..:xXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMWKd;.    .....    :XMMM //\n', "// MMWd.   .;;;,,'..   .'lkXNWWNNNWMMMMMMMMMMWNNWWWNKkc..  ...',;;;,.   .kMMM //\n", "// MMNc   .,::::::;,'..   ..,;;,,dNMMMMMMMMMMXl,;;;,..   ..';;::::::'.  .lWMM //\n", "// MM0'   .;:::::::;;'..        ;0MMMMMMMMMMMWO'        ..,;;:::::::;.   ;KMM //\n", "// MMx.  .';::::;,'...        .:0MMMMMMMMMMMMMWO;.        ...';;::::;..  .OMM //\n", "// MWd.  .,:::;'..          .,xNMMMMMMMMMMMMMMMMXd'.          ..,;:::'.  .xMM //\n", "// MNl.  .,:;'..         .,ckNMMMMMMMMMMMMMMMMMMMMXxc'.         ..';:,.  .dWM //\n", "// MNc   .,,..    .;:clox0NWXXWMMMMMMMMMMMMMMMMMMWXXWXOxolc:;.    ..,'.  .oWM //\n", '// MNc   ...     .oWMMMNXNMW0odXMMMMMMMMMMMMMMMMKooKWMNXNMMMNc.     ...  .oWM //\n', '// MNc.          ;KMMMMNkokNMXlcKMMMMMMMMMMMMMM0coNMNxoOWMMMM0,          .oWM //\n', '// MNc         .;0MMMMMMWO:dNMNoxWMMMMMMMMMMMMNddNMNocKMMMMMMWO,         .oWM //\n', '// MX:        .lXMMMMMMMMM0lOMMNXWMMMMMMMMMMMMWXNMMklKMMMMMMMMM0:.       .lNM //\n', '// MX;      .;kWMMMMMMMMMMMXNMMMMMMMMMMMMMMMMMMMMMMNNMMMMMMMMMMMNx,.      cNM //\n', '// MO.    .:kNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNx:.  . ,0M //\n', "// Wl..':dKWMMMMMMMWNK000KNMMMMMMMMMMMMMMMMMMMMMMMMMWNK000KNMMMMMMMMW0o;...dW //\n", '// NxdOXWMMMMMMMW0olcc::;,,cxXWMMMMMMMMMMMMMMMMMMWKd:,,;::ccld0WMMMMMMMWKkokW //\n', "// MMMMMMMMMMMWOlcd0XWWWN0x:.,OMMMMMMMMMMMMMMMMMWk,'cxKNWWWXOdcl0MMMMMMMMMMMM //\n", '// MMMMMMMMMMMWKKWMMMMMMMMMWK0XMMMMMMMMMMMMMMMMMMXOXWMMMMMMMMMN0XMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWK0OOOO0KWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', "// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNo.......'xWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n", '// MMMNKOkkkk0XNMMMMMMMMMMMMMMMMMMWO;.    .:0WMMMMMMMMMMMMMMMMMWNKOkkkkOKNMMM //\n', "// MMWXOkxddoddxxkKWMMMMMMMMMMMMMMMMXo...'dNMMMMMMMMMMMMMMMMN0kxxdodddxk0XMMM //\n", '// MMMMMMMMMMMMWNKKNMMMMMMMMMMMMMMMMWOc,,c0WMMMMMMMMMMMMMMMMXKKNWMMMMMMMMMMMM //\n', '// MMMMMMMMWXKKXXNWMMMMMMMMMMWWWWWX0xcclc:cxKNWWWWWMMMMMMMMMMWNXXKKXWMMMMMMMM //\n', '// MMMWXOxdoooddxkO0NMMMMMMMWKkfoahheitNX0GlikkdakXMMMMMMMWX0OkxddooddxOXWMMM //\n', '// MMMWXKKNNWMMMMMWWWMMMMMMMMMWNXXXNWMMMMMMWXXXXNWMMMMMMMMMWWWMMMMWWNXKKNWMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM Lucky* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// MMM> *~+> we are the MMMMMMMMMMMM Number MMMMMMM> we are the <+~* <MMMMMMM //\n', '// MMMMMMMMMM> music <MMMMMMMMMMMMMM ------ MMMMMMMMMM> dreamer <MMMMMMMMMMMM //\n', '// MMMMMMMM> *~+> makers <MMMMM<MMMM Random MMMMMMMMMMMMM> of <MMMMMMMMMMMMMM //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM Ledger MMMMMMMMMMMMMM> dreams. <+~* <MMM //\n', '// M> palimpsest by <MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '// ~> arkimedes.eth <~+~+~+~~+~+~+~~+~+~+~~+~+~+~~+~+~+~~> VIII*XII*MMXVII <~ //\n', '// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM //\n', '\n', '/**\n', ' * Manages contract ownership.\n', ' */\n', 'contract Owned {\n', '    address public owner;\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address _newOwner) onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * Function to recover the funds on the contract\n', ' */\n', 'contract Mortal is Owned {\n', '    function kill() onlyOwner {\n', '        selfdestruct(owner);\n', '    }\n', '}\n', '\n', '/**\n', ' * SafeMath\n', ' * Math operations with safety checks that throw on error.\n', ' * Taking ideas from FirstBlood token. Enhanced by OpenZeppelin.\n', ' */\n', 'contract SafeMath {\n', '  function mul(uint256 a, uint256 b)\n', '  internal\n', '  constant\n', '  returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b)\n', '  internal\n', '  constant\n', '  returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b)\n', '  internal\n', '  constant\n', '  returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b)\n', '  internal\n', '  constant\n', '  returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * Random number generator from mined block hash.\n', ' */\n', 'contract Random is SafeMath {\n', '    // Generates a random number from 1 to max based on the last block hash.\n', '    function getRandomFromBlockHash(uint blockNumber, uint max)\n', '    public\n', '    constant \n', '    returns(uint) {\n', '        // block.blockhash(uint blockNumber)\n', '        //    returns\n', '        //    (bytes32):\n', '        //        hash of the given block\n', '        // !! only works for 256 most recent blocks excluding current !!\n', '        return(add(uint(sha3(block.blockhash(blockNumber))) % max, 1));\n', '    }\n', '}\n', '\n', '/**\n', ' * RandomLedger is the main public interface for a random number ledger.\n', ' * To make a request:\n', ' * Step 1: Call requestNumber with the `cost` as the value\n', ' * Step 2: Wait waitTime in blocks past the block which mines transaction for requestNumber\n', ' * Step 3: Call revealNumber to generate the number, and make it publicly accessable in the UI.\n', ' *         this is required to create the Events which generate the Ledger. \n', ' */\n', 'contract RandomLedger is Owned {\n', '    // ~> cost to generate a random number in Wei.\n', '    uint256 public cost;\n', '    // ~> waitTime is the number of blocks before random is generated.\n', '    uint8 public waitTime;\n', '    // ~> set default max\n', '    uint256 public max;\n', '\n', '    // PendingNumber represents one number.\n', '    struct PendingNumber {\n', '        address requestProxy;\n', '        uint256 renderedNumber;\n', '        uint256 originBlock;\n', '        uint256 max;\n', '        // blocks to wait,\n', '        // also maintains pending state\n', '        uint8 waitTime;\n', '    }\n', '\n', '    // for Number Ledger\n', '    event EventRandomLedgerRequested(address requestor, uint256 max, uint256 originBlock, uint8 waitTime, address indexed requestProxy);\n', '    event EventRandomLedgerRevealed(address requestor, uint256 originBlock, uint256 renderedNumber, address indexed requestProxy);\n', '    \n', '    mapping (address => PendingNumber) pendingNumbers;\n', '    mapping (address => bool) public whiteList;\n', '\n', '    function requestNumber(address _requestor, uint256 _max, uint8 _waitTime) payable public;\n', '    function revealNumber(address _requestor) payable public;\n', '}\n', '\n', '/**\n', ' * Lucky Number :: Random Ledger Service *~+>\n', ' * Any contract or address can make a request from this implementation\n', ' * on behalf of any other address as a requestProxy.\n', ' */\n', 'contract RandomLedgerService is RandomLedger, Mortal, Random {\n', '    \n', '    // Initialize state +.+.+.\n', '    function RandomLedgerService() {\n', '        owned();\n', '        cost = 20000000000000000; // 0.02 ether // 20 finney\n', '        max = 21; // generate number between 1 and 21\n', '        waitTime = 5; // 5 blocks\n', '    }\n', '\n', '    // Let owner customize defauts.\n', '    // Allow the owner to set max.\n', '    function setMax(uint256 _max)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        max = _max;\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to set waitTime. (in blocks)\n', '    function setWaitTime(uint8 _waitTime)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        waitTime = _waitTime;\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to set cost.\n', '    function setCost(uint256 _cost)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        cost = _cost;\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to set a transaction proxy\n', '    // which can perform value exchanges on behalf of this contract.\n', '    // (unrelated to the requestProxy which is not whiteList)\n', '    function enableProxy(address _proxy)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        whiteList[_proxy] = true;\n', '        return whiteList[_proxy];\n', '    }\n', '\n', '    function removeProxy(address _proxy)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        delete whiteList[_proxy];\n', '        return true;\n', '    }\n', '\n', '    // Allow the owner to cash out the holdings of this contract.\n', '    function withdraw(address _recipient, uint256 _balance)\n', '    onlyOwner\n', '    public\n', '    returns (bool) {\n', '        _recipient.transfer(_balance);\n', '        return true;\n', '    }\n', '\n', '    // Assume that simple transactions are trying to request a number,\n', '    // unless it is from the owner.\n', '    function () payable public {\n', '        assert(msg.sender != owner);\n', '        requestNumber(msg.sender, max, waitTime);\n', '    }\n', '    \n', '    // Request a Number ... *~>\n', '    function requestNumber(address _requestor, uint256 _max, uint8 _waitTime)\n', '    payable \n', '    public {\n', '        // external requirement: \n', '        // value must exceed cost\n', '        // unless address is whitelisted\n', '        if (!whiteList[msg.sender]) {\n', '            require(!(msg.value < cost));\n', '        }\n', '\n', '        // internal requirement: \n', '        // request address must not have pending number\n', '        assert(!isRequestPending(_requestor));\n', '        // set pending number\n', '        pendingNumbers[_requestor] = PendingNumber({\n', '            requestProxy: tx.origin, // requestProxy: original address that kicked off the transaction\n', '            renderedNumber: 0,\n', '            max: max,\n', '            originBlock: block.number,\n', '            waitTime: waitTime\n', '        });\n', '        if (_max > 1) {\n', '            pendingNumbers[_requestor].max = _max;\n', '        }\n', '        // max 250 wait to leave a few blocks\n', '        // for the reveal transction to occur\n', '        // and write from the pending numbers block\n', '        // before it expires\n', '        if (_waitTime > 0 && _waitTime < 250) {\n', '            pendingNumbers[_requestor].waitTime = _waitTime;\n', '        }\n', '        EventRandomLedgerRequested(_requestor, pendingNumbers[_requestor].max, pendingNumbers[_requestor].originBlock, pendingNumbers[_requestor].waitTime, pendingNumbers[_requestor].requestProxy);\n', '    }\n', '\n', '    // Reveal your number ... *~>\n', '    // Only requestor or proxy can generate the number\n', '    function revealNumber(address _requestor)\n', '    public\n', '    payable {\n', '        assert(_canReveal(_requestor, msg.sender));\n', "        // waitTime has passed, render this requestor's number.\n", '        _revealNumber(_requestor);\n', '    }\n', '\n', '    // Internal implementation of revealNumber().\n', '    function _revealNumber(address _requestor) \n', '    internal {\n', '        uint256 luckyBlock = _revealBlock(_requestor);\n', '        // \n', '        // TIME LIMITATION ~> should handle in user interface\n', '        // blocks older than (currentBlock - 256) \n', '        // "expire" and read the same hash as most recent valid block\n', '        // \n', '        uint256 luckyNumber = getRandomFromBlockHash(luckyBlock, pendingNumbers[_requestor].max);\n', '\n', '        // set new values\n', '        pendingNumbers[_requestor].renderedNumber = luckyNumber;\n', '        // event\n', '        EventRandomLedgerRevealed(_requestor, pendingNumbers[_requestor].originBlock, pendingNumbers[_requestor].renderedNumber, pendingNumbers[_requestor].requestProxy);\n', '        // zero out wait blocks since this is now inactive (for state management)\n', '        pendingNumbers[_requestor].waitTime = 0;\n', '    }\n', '\n', '    function canReveal(address _requestor)\n', '    public\n', '    constant\n', '    returns (bool, uint, uint, address, address) {\n', '        return (_canReveal(_requestor, msg.sender), _remainingBlocks(_requestor), _revealBlock(_requestor), _requestor, msg.sender);\n', '    }\n', '\n', '    function _canReveal(address _requestor, address _proxy) \n', '    internal\n', '    constant\n', '    returns (bool) {\n', '        // check for pending number request\n', '        if (isRequestPending(_requestor)) {\n', '            // check for no remaining blocks to be mined\n', '            // must wait for `pendingNumbers[_requestor].waitTime` to be excceeded\n', '            if (_remainingBlocks(_requestor) == 0) {\n', '                // check for ownership\n', '                if (pendingNumbers[_requestor].requestProxy == _requestor || pendingNumbers[_requestor].requestProxy == _proxy) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function _remainingBlocks(address _requestor)\n', '    internal\n', '    constant\n', '    returns (uint) {\n', '        uint256 revealBlock = add(pendingNumbers[_requestor].originBlock, pendingNumbers[_requestor].waitTime);\n', '        uint256 remainingBlocks = 0;\n', '        if (revealBlock > block.number) {\n', '            remainingBlocks = sub(revealBlock, block.number);\n', '        }\n', '        return remainingBlocks;\n', '    }\n', '\n', '    function _revealBlock(address _requestor)\n', '    internal\n', '    constant\n', '    returns (uint) {\n', '        // add wait block time\n', '        // to creation block time\n', '        // then subtract 1\n', '        return add(pendingNumbers[_requestor].originBlock, pendingNumbers[_requestor].waitTime);\n', '    }\n', '\n', '\n', '    function getNumber(address _requestor)\n', '    public\n', '    constant\n', '    returns (uint, uint, uint, address) {\n', '        return (pendingNumbers[_requestor].renderedNumber, pendingNumbers[_requestor].max, pendingNumbers[_requestor].originBlock, _requestor);\n', '    }\n', '\n', '    // is a number request pending for the address\n', '    function isRequestPending(address _requestor)\n', '    public\n', '    constant\n', '    returns (bool) {\n', '        if (pendingNumbers[_requestor].renderedNumber == 0 && pendingNumbers[_requestor].waitTime > 0) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '// 0xMMWKkk0KN/>HBBi/MASSa/DANTi/LANTen.MI.MI.MI.M+.+.+.M->MMWNKOkOKWJ.J.J.M*~+>\n', '}']
