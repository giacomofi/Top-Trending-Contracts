['pragma solidity ^0.4.17;\n', '\n', 'contract owned {\n', '    \n', '    address public owner;\n', '    \n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) throw;\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract IValusToken {\n', '  function mintTokens(address _to, uint256 _amount);\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '}\n', '\n', 'contract IERC20Token {\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '  function approve(address _spender, uint256 _value) returns (bool success) {}\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract ValusCrowdsale is owned {\n', '    uint256 public startBlock;\n', '    uint256 public endBlock;\n', '    uint256 public minEthToRaise;\n', '    uint256 public maxEthToRaise;\n', '    uint256 public totalEthRaised;\n', '    address public multisigAddress;\n', '    \n', '    IValusToken valusTokenContract; \n', '\n', '    uint256 nextFreeParticipantIndex;\n', '    mapping (uint => address) participantIndex;\n', '    mapping (address => uint256) participantContribution;\n', '    \n', '    bool crowdsaleHasStarted;\n', '    bool softCapReached;\n', '    bool hardCapReached;\n', '    bool crowdsaleHasSucessfulyEnded;\n', '    uint256 blocksInADay;\n', '    bool ownerHasClaimedTokens;\n', '    \n', '    uint256 lastEthReturnIndex;\n', '    mapping (address => bool) hasClaimedEthWhenFail;\n', '    \n', '    event CrowdsaleStarted(uint256 _blockNumber);\n', '    event CrowdsaleSoftCapReached(uint256 _blockNumber);\n', '    event CrowdsaleHardCapReached(uint256 _blockNumber);\n', '    event CrowdsaleEndedSuccessfuly(uint256 _blockNumber, uint256 _amountRaised);\n', '    event Crowdsale(uint256 _blockNumber, uint256 _ammountRaised);\n', '    event ErrorSendingETH(address _from, uint256 _amount);\n', '    \n', '    function ValusCrowdsale(){\n', '        \n', '        blocksInADay = 2950;\n', '        startBlock = 4363310;\n', '        endBlock = startBlock + blocksInADay * 29;      \n', '        minEthToRaise = 3030 * 10**18;                     \n', '        maxEthToRaise = 30303 * 10**18;                 \n', '        multisigAddress = 0x4e8FD5605028E12E1e7b1Fa60d437d310fa97Bb2;\n', '    }\n', '    \n', '  //  \n', '  /* User accessible methods */   \n', '  //  \n', '    \n', '    function () payable{\n', '      if(msg.value == 0) throw;\n', '      if (crowdsaleHasSucessfulyEnded || block.number > endBlock) throw;        // Throw if the Crowdsale has ended     \n', '      if (!crowdsaleHasStarted){                                                // Check if this is the first Crowdsale transaction       \n', '        if (block.number >= startBlock){                                        // Check if the Crowdsale should start        \n', '          crowdsaleHasStarted = true;                                           // Set that the Crowdsale has started         \n', '          CrowdsaleStarted(block.number);                                       // Raise CrowdsaleStarted event     \n', '        } else{\n', '          throw;\n', '        }\n', '      }\n', '      if (participantContribution[msg.sender] == 0){                            // Check if the sender is a new user       \n', '        participantIndex[nextFreeParticipantIndex] = msg.sender;                // Add a new user to the participant index       \n', '        nextFreeParticipantIndex += 1;\n', '      }  \n', '      if (maxEthToRaise > (totalEthRaised + msg.value)){                        // Check if the user sent too much ETH       \n', '        participantContribution[msg.sender] += msg.value;                       // Add contribution      \n', '        totalEthRaised += msg.value; // Add to total eth Raised\n', '        valusTokenContract.mintTokens(msg.sender, getValusTokenIssuance(block.number, msg.value));\n', '        if (!softCapReached && totalEthRaised >= minEthToRaise){                // Check if the min treshold has been reached one time        \n', '          CrowdsaleSoftCapReached(block.number);                                // Raise CrowdsalesoftCapReached event        \n', '          softCapReached = true;                                                // Set that the min treshold has been reached       \n', '        }     \n', '      }else{                                                                    // If user sent to much eth       \n', '        uint maxContribution = maxEthToRaise - totalEthRaised;                  // Calculate maximum contribution       \n', '        participantContribution[msg.sender] += maxContribution;                 // Add maximum contribution to account      \n', '        totalEthRaised += maxContribution;  \n', '        valusTokenContract.mintTokens(msg.sender, getValusTokenIssuance(block.number, maxContribution));\n', '        uint toReturn = msg.value - maxContribution;                            // Calculate how much should be returned       \n', '        crowdsaleHasSucessfulyEnded = true;                                     // Set that Crowdsale has successfully ended    \n', '        CrowdsaleHardCapReached(block.number);\n', '        hardCapReached = true;\n', '        CrowdsaleEndedSuccessfuly(block.number, totalEthRaised);      \n', '        if(!msg.sender.send(toReturn)){                                        // Refund the balance that is over the cap         \n', '          ErrorSendingETH(msg.sender, toReturn);                               // Raise event for manual return if transaction throws       \n', '        }     \n', '      }     \n', '    }\n', '    \n', '    /* Users can claim ETH by themselves if they want to in case of ETH failure */   \n', '    function claimEthIfFailed(){    \n', '      if (block.number <= endBlock || totalEthRaised >= minEthToRaise) throw; // Check if Crowdsale has failed    \n', '      if (participantContribution[msg.sender] == 0) throw;                    // Check if user has participated     \n', '      if (hasClaimedEthWhenFail[msg.sender]) throw;                           // Check if this account has already claimed ETH    \n', '      uint256 ethContributed = participantContribution[msg.sender];           // Get participant ETH Contribution     \n', '      hasClaimedEthWhenFail[msg.sender] = true;     \n', '      if (!msg.sender.send(ethContributed)){      \n', '        ErrorSendingETH(msg.sender, ethContributed);                          // Raise event if send failed, solve manually     \n', '      }   \n', '    } \n', '\n', '    /* Owner can return eth for multiple users in one call */  \n', '    function batchReturnEthIfFailed(uint256 _numberOfReturns) onlyOwner{    \n', '      if (block.number < endBlock || totalEthRaised >= minEthToRaise) throw;    // Check if Crowdsale failed  \n', '      address currentParticipantAddress;    \n', '      uint256 contribution;\n', '      for (uint cnt = 0; cnt < _numberOfReturns; cnt++){      \n', '        currentParticipantAddress = participantIndex[lastEthReturnIndex];       // Get next account       \n', '        if (currentParticipantAddress == 0x0) return;                           // Check if participants were reimbursed      \n', '        if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                // Check if user has manually recovered ETH         \n', '          contribution = participantContribution[currentParticipantAddress];    // Get accounts contribution        \n', '          hasClaimedEthWhenFail[msg.sender] = true;                             // Set that user got his ETH back         \n', '          if (!currentParticipantAddress.send(contribution)){                   // Send fund back to account          \n', '             ErrorSendingETH(currentParticipantAddress, contribution);           // Raise event if send failed, resolve manually         \n', '          }       \n', '        }       \n', '        lastEthReturnIndex += 1;    \n', '      }   \n', '    }\n', '      \n', '    /* Owner sets new address of escrow */\n', '    function changeMultisigAddress(address _newAddress) onlyOwner {     \n', '      multisigAddress = _newAddress;\n', '    } \n', '    \n', '    /* Show how many participants was */\n', '    function participantCount() constant returns(uint){\n', '      return nextFreeParticipantIndex;\n', '    }\n', '\n', '    /* Owner can claim reserved tokens on the end of crowsale */  \n', '    function claimTeamTokens(address _to) onlyOwner{     \n', '      if (!crowdsaleHasSucessfulyEnded) throw; \n', '      if (ownerHasClaimedTokens) throw;\n', '        \n', '      valusTokenContract.mintTokens(_to, valusTokenContract.totalSupply() * 49/51); /* 51% Crowdsale - 49% VALUS */\n', '      ownerHasClaimedTokens = true;\n', '    } \n', '      \n', '    /* Set token contract where mints will be done (tokens will be issued) */  \n', '    function setTokenContract(address _valusTokenContractAddress) onlyOwner {     \n', '      valusTokenContract = IValusToken(_valusTokenContractAddress);   \n', '    }   \n', '       \n', '    function getValusTokenIssuance(uint256 _blockNumber, uint256 _ethSent) constant returns(uint){\n', '      if (_blockNumber >= startBlock && _blockNumber < startBlock + blocksInADay * 2) return _ethSent * 3882;\n', '      if (_blockNumber >= startBlock + blocksInADay * 2 && _blockNumber < startBlock + blocksInADay * 7) return _ethSent * 3667; \n', '      if (_blockNumber >= startBlock + blocksInADay * 7 && _blockNumber < startBlock + blocksInADay * 14) return _ethSent * 3511; \n', '      if (_blockNumber >= startBlock + blocksInADay * 14 && _blockNumber < startBlock + blocksInADay * 21) return _ethSent * 3402; \n', '      if (_blockNumber >= startBlock + blocksInADay * 21 ) return _ethSent * 3300;\n', '    }\n', '    \n', '    /* Withdraw funds from contract */  \n', '    function withdrawEther() onlyOwner{     \n', '      if (this.balance == 0) throw;                                            // Check if there is balance on the contract     \n', '      if (totalEthRaised < minEthToRaise) throw;                               // Check if minEthToRaise treshold is exceeded     \n', '          \n', "      if(multisigAddress.send(this.balance)){}                                 // Send the contract's balance to multisig address   \n", '    }\n', '\n', '    function endCrowdsale() onlyOwner{\n', '      if (totalEthRaised < minEthToRaise) throw;\n', '      if (block.number < endBlock) throw;\n', '      crowdsaleHasSucessfulyEnded = true;\n', '      CrowdsaleEndedSuccessfuly(block.number, totalEthRaised);\n', '    }\n', '    \n', '    \n', '    function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner{\n', '    IERC20Token(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '    /* Getters */     \n', '    \n', '    function getVlsTokenAddress() constant returns(address _tokenAddress){    \n', '      return address(valusTokenContract);   \n', '    }   \n', '    \n', '    function crowdsaleInProgress() constant returns (bool answer){    \n', '      return crowdsaleHasStarted && !crowdsaleHasSucessfulyEnded;   \n', '    }   \n', '    \n', '    function participantContributionInEth(address _querryAddress) constant returns (uint256 answer){    \n', '      return participantContribution[_querryAddress];   \n', '    }\n', '    \n', '    /* Withdraw remaining balance to manually return where contract send has failed */  \n', '    function withdrawRemainingBalanceForManualRecovery() onlyOwner{     \n', '      if (this.balance == 0) throw;                                         // Check if there is balance on the contract    \n', '      if (block.number < endBlock) throw;                                   // Check if Crowdsale failed    \n', '      if (participantIndex[lastEthReturnIndex] != 0x0) throw;               // Check if all the participants have been reimbursed     \n', '      if (multisigAddress.send(this.balance)){}                             // Send remainder so it can be manually processed   \n', '    }\n', '}']