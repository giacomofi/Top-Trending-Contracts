['pragma solidity ^0.4.11;\n', '\n', '// VERSION LAVA(I)\n', '\n', '\n', '// --------------------------\n', '// here&#39;s how this works:\n', '// the current amount of dividends due to each token-holder&#39;s  is:\n', '//   previous_due + [ p(x) * t(x)/N ] + [ p(x+1) * t(x+1)/N ] + ...\n', '//   where p(x) is the x&#39;th payment received by the contract\n', '//         t(x) is the number of tokens held by the token-holder at the time of p(x)\n', '//         N    is the total number of tokens, which never changes\n', '//\n', '// assume that t(x) takes on 3 values, t(a), t(b) and t(c), during periods a, b, and c. then:\n', '// factoring:\n', '//   current_due = { (t(a) * [p(x) + p(x+1)] ...) +\n', '//                   (t(b) * [p(y) + p(y+1)] ...) +\n', '//                   (t(c) * [p(z) + p(z+1)] ...) } / N\n', '//\n', '// or\n', '//\n', '//   current_due = { (t(a) * period_a_fees) +\n', '//                   (t(b) * period_b_fees) +\n', '//                   (t(c) * period_c_fees) } / N\n', '//\n', '// if we designate current_due * N as current-points, then\n', '//\n', '//   currentPoints = {  (t(a) * period_a_fees) +\n', '//                      (t(b) * period_b_fees) +\n', '//                      (t(c) * period_c_fees) }\n', '//\n', '// or more succictly, if we recompute current points before a token-holder&#39;s number of\n', '// tokens, T, is about to change:\n', '//\n', '//   currentPoints = previous_points + (T * current-period-fees)\n', '//\n', '// when we want to do a payout, we&#39;ll calculate:\n', '//  current_due = current-points / N\n', '//\n', '// we&#39;ll keep track of a token-holder&#39;s current-period-points, which is:\n', '//   T * current-period-fees\n', '// by taking a snapshot of fees collected exactly when the current period began; that is, the when the\n', '// number of tokens last changed. that is, we keep a running count of total fees received\n', '//\n', '//   TotalFeesReceived = p(x) + p(x+1) + p(x+2)\n', '//\n', '// (which happily is the same for all token holders) then, before any token holder changes their number of\n', '// tokens we compute (for that token holder):\n', '//\n', '//  function calcCurPointsForAcct(acct) {\n', '//    currentPoints[acct] += (TotalFeesReceived - lastSnapshot[acct]) * T[acct]\n', '//    lastSnapshot[acct] = TotalFeesReceived\n', '//  }\n', '//\n', '// in the withdraw fcn, all we need is:\n', '//\n', '//  function withdraw(acct) {\n', '//    calcCurPointsForAcct(acct);\n', '//    current_amount_due = currentPoints[acct] / N\n', '//    currentPoints[acct] = 0;\n', '//    send(current_amount_due);\n', '//  }\n', '//\n', '//\n', '// special provisions for transfers from the old e4row contract (token-split transfers)\n', '// -------------------------------------------------------------------------------------\n', '// normally when a new acct is created, eg cuz tokens are transferred from one acct to another, we first call\n', '// calcCurPointsForAcct(acct) on the old acct; on the new acct we set:\n', '//  currentPoints[acct] = 0;\n', '//  lastSnapshot[acct] = TotalFeesReceived;\n', '//\n', '// this starts the new account with no credits for any dividends that have been collected so far, which is what\n', '// you would generally want. however, there is a case in which tokens are transferred from the old e4row contract.\n', '// in that case the tokens were reserved on this contract all along, and they earn dividends even before they are\n', '// assigned to an account. so for token-split transfers:\n', '//  currentPoints[acct] = 0;\n', '//  lastSnapshot[acct] = 0;\n', '//\n', '// then immediately call calcCurPointsForAcct(acct) for the new token-split account. he will get credit\n', '// for all the accumulated points, from the beginning of time.\n', '//\n', '// --------------------------\n', '\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', '// ---------------------------------\n', '// ABSTRACT standard token class\n', '// ---------------------------------\n', 'contract Token {\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '// --------------------------\n', '//  E4RowRewards - abstract e4 dividend contract\n', '// --------------------------\n', 'contract E4LavaRewards\n', '{\n', '        function checkDividends(address _addr) constant returns(uint _amount);\n', '        function withdrawDividends() public returns (uint namount);\n', '        function transferDividends(address _to) returns (bool success);\n', '        function getAccountInfo(address _addr) constant returns(uint _tokens, uint _snapshot, uint _points);\n', '\n', '}\n', '\n', '// --------------------------\n', '//  E4LavaOptin - abstract e4 optin contract\n', '// --------------------------\n', 'contract E4LavaOptIn\n', '{\n', '        function optInFromClassic() public;\n', '}\n', '\n', '\n', '// --------------------------\n', '//  E4ROW (LAVA) - token contract\n', '// --------------------------\n', 'contract E4Lava is Token, E4LavaRewards, E4LavaOptIn {\n', '        event StatEvent(string msg);\n', '        event StatEventI(string msg, uint val);\n', '\n', '        enum SettingStateValue  {debug, lockedRelease}\n', '\n', '        struct tokenAccount {\n', '                bool alloced;       // flag to ascert prior allocation\n', '                uint tokens;        // num tokens currently held in this acct\n', '                uint currentPoints; // updated before token balance changes, or before a withdrawal. credit for owning tokens\n', '                uint lastSnapshot;  // snapshot of global TotalPoints, last time we updated this acct&#39;s currentPoints\n', '        }\n', '\n', '// -----------------------------\n', '//  data storage\n', '// ----------------------------------------\n', '        uint constant NumOrigTokens         = 5762;   // number of old tokens, from original token contract\n', '        uint constant NewTokensPerOrigToken = 100000; // how many new tokens are created for each from original token\n', '        uint constant NewTokenSupply        = 5762 * 100000;\n', '        uint public numToksSwitchedOver;              // count old tokens that have been converted\n', '        uint public holdoverBalance;                  // funds received, but not yet distributed\n', '        uint public TotalFeesReceived;                // total fees received from partner contract(s)\n', '\n', '        address public developers;                    // developers token holding address\n', '        address public owner;                         // deployer executor\n', '        address public oldE4;                         // addr of old e4 token contract\n', '        address public oldE4RecycleBin;               // addr to transfer old tokens\n', '\n', '        uint public decimals;\n', '        string public symbol;\n', '\n', '        mapping (address => tokenAccount) holderAccounts;          // who holds how many tokens (high two bytes contain curPayId)\n', '        mapping (uint => address) holderIndexes;                   // for iteration thru holder\n', '        mapping (address => mapping (address => uint256)) allowed; // approvals\n', '        uint public numAccounts;\n', '\n', '        uint public payoutThreshold;                  // no withdrawals less than this amount, to avoid remainders\n', '        uint public rwGas;                            // reward gas\n', '        uint public optInXferGas;                     // gas used when optInFromClassic calls xfer on old contract\n', '        uint public optInFcnMinGas;                   // gas we need for the optInFromClassic fcn, *excluding* optInXferGas\n', '        uint public vestTime = 1525219201;            // 1 year past sale vest developer tokens\n', '\n', '        SettingStateValue public settingsState;\n', '\n', '\n', '        // --------------------\n', '        // contract constructor\n', '        // --------------------\n', '        function E4Lava()\n', '        {\n', '                owner = msg.sender;\n', '                developers = msg.sender;\n', '                decimals = 2;\n', '                symbol = "E4ROW";\n', '        }\n', '\n', '        // -----------------------------------\n', '        // use this to reset everything, will never be called after lockRelease\n', '        // -----------------------------------\n', '        function applySettings(SettingStateValue qState, uint _threshold, uint _rw, uint _optXferGas, uint _optFcnGas )\n', '        {\n', '                if (msg.sender != owner)\n', '                        return;\n', '\n', '                // these settings are permanently tweakable for performance adjustments\n', '                payoutThreshold = _threshold;\n', '                rwGas = _rw;\n', '                optInXferGas = _optXferGas;\n', '                optInFcnMinGas = _optFcnGas;\n', '\n', '                // this first test checks if already locked\n', '                if (settingsState == SettingStateValue.lockedRelease)\n', '                        return;\n', '\n', '                settingsState = qState;\n', '\n', '                // this second test allows locking without changing other permanent settings\n', '                // WARNING, MAKE SURE YOUR&#39;RE HAPPY WITH ALL SETTINGS\n', '                // BEFORE LOCKING\n', '\n', '                if (qState == SettingStateValue.lockedRelease) {\n', '                        StatEvent("Locking!");\n', '                        return;\n', '                }\n', '\n', '                // zero out all token holders.\n', '                // leave alloced on, leave num accounts\n', '                // cant delete them anyways\n', '\n', '                for (uint i = 0; i < numAccounts; i++ ) {\n', '                        address a = holderIndexes[i];\n', '                        if (a != address(0)) {\n', '                                holderAccounts[a].tokens = 0;\n', '                                holderAccounts[a].currentPoints = 0;\n', '                                holderAccounts[a].lastSnapshot = 0;\n', '                        }\n', '                }\n', '\n', '                numToksSwitchedOver = 0;\n', '\n', '                if (this.balance > 0) {\n', '                        if (!owner.call.gas(rwGas).value(this.balance)())\n', '                                StatEvent("ERROR!");\n', '                }\n', '                StatEvent("ok");\n', '\n', '        }\n', '\n', '\n', '        // ---------------------------------------------------\n', '        // allocate a new account by setting alloc to true\n', '        // add holder index, bump the num accounts\n', '        // ---------------------------------------------------\n', '        function addAccount(address _addr) internal  {\n', '                holderAccounts[_addr].alloced = true;\n', '                holderAccounts[_addr].tokens = 0;\n', '                holderAccounts[_addr].currentPoints = 0;\n', '                holderAccounts[_addr].lastSnapshot = TotalFeesReceived;\n', '                holderIndexes[numAccounts++] = _addr;\n', '        }\n', '\n', '\n', '// --------------------------------------\n', '// BEGIN ERC-20 from StandardToken\n', '// --------------------------------------\n', '\n', '        function totalSupply() constant returns (uint256 supply)\n', '        {\n', '                supply = NewTokenSupply;\n', '        }\n', '\n', '        // ----------------------------\n', '        // sender transfers tokens to a new acct\n', '        // do not use this fcn for a token-split transfer from the old token contract!\n', '        // ----------------------------\n', '        function transfer(address _to, uint256 _value) returns (bool success)\n', '        {\n', '                if ((msg.sender == developers)\n', '                        &&  (now < vestTime)) {\n', '                        //statEvent("Tokens not yet vested.");\n', '                        return false;\n', '                }\n', '\n', '                //Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n', '                //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn&#39;t wrap.\n', '                //Replace the if with this one instead.\n', '                //if (holderAccounts[msg.sender].tokens >= _value && balances[_to] + _value > holderAccounts[_to]) {\n', '                if (holderAccounts[msg.sender].tokens >= _value && _value > 0) {\n', '                    //first credit sender with points accrued so far.. must do this before number of held tokens changes\n', '                    calcCurPointsForAcct(msg.sender);\n', '                    holderAccounts[msg.sender].tokens -= _value;\n', '\n', '                    if (!holderAccounts[_to].alloced) {\n', '                        addAccount(_to);\n', '                    }\n', '                    //credit destination acct with points accrued so far.. must do this before number of held tokens changes\n', '                    calcCurPointsForAcct(_to);\n', '                    holderAccounts[_to].tokens += _value;\n', '\n', '                    Transfer(msg.sender, _to, _value);\n', '                    return true;\n', '                } else {\n', '                    return false;\n', '                }\n', '        }\n', '\n', '\n', '        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '                if ((_from == developers)\n', '                        &&  (now < vestTime)) {\n', '                        //statEvent("Tokens not yet vested.");\n', '                        return false;\n', '                }\n', '\n', '                //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '                //if (holderAccounts[_from].tokens >= _value && allowed[_from][msg.sender] >= _value && holderAccounts[_to].tokens + _value > holderAccounts[_to].tokens) {\n', '                if (holderAccounts[_from].tokens >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '\n', '                    calcCurPointsForAcct(_from);\n', '                    holderAccounts[_from].tokens -= _value;\n', '\n', '                    if (!holderAccounts[_to].alloced) {\n', '                        addAccount(_to);\n', '                    }\n', '                    //credit destination acct with points accrued so far.. must do this before number of held tokens changes\n', '                    calcCurPointsForAcct(_to);\n', '                    holderAccounts[_to].tokens += _value;\n', '\n', '                    allowed[_from][msg.sender] -= _value;\n', '                    Transfer(_from, _to, _value);\n', '                    return true;\n', '                } else {\n', '                    return false;\n', '                }\n', '        }\n', '\n', '\n', '        function balanceOf(address _owner) constant returns (uint256 balance) {\n', '                balance = holderAccounts[_owner].tokens;\n', '        }\n', '\n', '        function approve(address _spender, uint256 _value) returns (bool success) {\n', '                allowed[msg.sender][_spender] = _value;\n', '                Approval(msg.sender, _spender, _value);\n', '                return true;\n', '        }\n', '\n', '        function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '                return allowed[_owner][_spender];\n', '        }\n', '// ----------------------------------\n', '// END ERC20\n', '// ----------------------------------\n', '\n', '        // ----------------------------\n', '        // calc current points for a token holder; that is, points that are due to this token holder for all dividends\n', '        // received by the contract during the current "period". the period began the last time this fcn was called, at which\n', '        // time we updated the account&#39;s snapshot of the running point count, TotalFeesReceived. during the period the account&#39;s\n', '        // number of tokens must not have changed. so always call this fcn before changing the number of tokens.\n', '        // ----------------------------\n', '        function calcCurPointsForAcct(address _acct) internal {\n', '              holderAccounts[_acct].currentPoints += (TotalFeesReceived - holderAccounts[_acct].lastSnapshot) * holderAccounts[_acct].tokens;\n', '              holderAccounts[_acct].lastSnapshot = TotalFeesReceived;\n', '        }\n', '\n', '\n', '        // ---------------------------\n', '        // accept payment from a partner contract\n', '        // funds sent here are added to TotalFeesReceived\n', '        // WARNING! DO NOT CALL THIS FUNCTION LEST YOU LOSE YOUR MONEY\n', '        // ---------------------------\n', '        function () payable {\n', '                holdoverBalance += msg.value;\n', '                TotalFeesReceived += msg.value;\n', '                StatEventI("Payment", msg.value);\n', '        }\n', '\n', '        // ---------------------------\n', '        // one never knows if this will come in handy.\n', '        // ---------------------------\n', '        function blackHole() payable {\n', '                StatEventI("adjusted", msg.value);\n', '        }\n', '\n', '        // ----------------------------\n', '        // sender withdraw entire rewards/dividends\n', '        // ----------------------------\n', '        function withdrawDividends() public returns (uint _amount)\n', '        {\n', '                calcCurPointsForAcct(msg.sender);\n', '\n', '                _amount = holderAccounts[msg.sender].currentPoints / NewTokenSupply;\n', '                if (_amount <= payoutThreshold) {\n', '                        StatEventI("low Balance", _amount);\n', '                        return;\n', '                } else {\n', '                        if ((msg.sender == developers)\n', '                                &&  (now < vestTime)) {\n', '                                StatEvent("Tokens not yet vested.");\n', '                                _amount = 0;\n', '                                return;\n', '                        }\n', '\n', '                        uint _pointsUsed = _amount * NewTokenSupply;\n', '                        holderAccounts[msg.sender].currentPoints -= _pointsUsed;\n', '                        holdoverBalance -= _amount;\n', '                        if (!msg.sender.call.gas(rwGas).value(_amount)())\n', '                                throw;\n', '                }\n', '        }\n', '\n', '        // ----------------------------\n', '        // allow sender to transfer dividends\n', '        // ----------------------------\n', '        function transferDividends(address _to) returns (bool success)\n', '        {\n', '                if ((msg.sender == developers)\n', '                        &&  (now < vestTime)) {\n', '                        //statEvent("Tokens not yet vested.");\n', '                        return false;\n', '                }\n', '                calcCurPointsForAcct(msg.sender);\n', '                if (holderAccounts[msg.sender].currentPoints == 0) {\n', '                        StatEvent("Zero balance");\n', '                        return false;\n', '                }\n', '                if (!holderAccounts[_to].alloced) {\n', '                        addAccount(_to);\n', '                }\n', '                calcCurPointsForAcct(_to);\n', '                holderAccounts[_to].currentPoints += holderAccounts[msg.sender].currentPoints;\n', '                holderAccounts[msg.sender].currentPoints = 0;\n', '                StatEvent("Trasnfered Dividends");\n', '                return true;\n', '        }\n', '\n', '\n', '\n', '        // ----------------------------\n', '        // set gas for operations\n', '        // ----------------------------\n', '        function setOpGas(uint _rw, uint _optXferGas, uint _optFcnGas)\n', '        {\n', '                if (msg.sender != owner && msg.sender != developers) {\n', '                        //StatEvent("only owner calls");\n', '                        return;\n', '                } else {\n', '                        rwGas = _rw;\n', '                        optInXferGas = _optXferGas;\n', '                        optInFcnMinGas = _optFcnGas;\n', '                }\n', '        }\n', '\n', '\n', '        // ----------------------------\n', '        // check rewards.  pass in address of token holder\n', '        // ----------------------------\n', '        function checkDividends(address _addr) constant returns(uint _amount)\n', '        {\n', '                if (holderAccounts[_addr].alloced) {\n', '                   //don&#39;t call calcCurPointsForAcct here, cuz this is a constant fcn\n', '                   uint _currentPoints = holderAccounts[_addr].currentPoints +\n', '                        ((TotalFeesReceived - holderAccounts[_addr].lastSnapshot) * holderAccounts[_addr].tokens);\n', '                   _amount = _currentPoints / NewTokenSupply;\n', '\n', '                // low balance? let him see it -Etansky\n', '                  // if (_amount <= payoutThreshold) {\n', '                  //    _amount = 0;\n', '                  // }\n', '\n', '                }\n', '        }\n', '\n', '\n', '\n', '        // ----------------------------\n', '        // swap executor\n', '        // ----------------------------\n', '        function changeOwner(address _addr)\n', '        {\n', '                if (msg.sender != owner\n', '                        || settingsState == SettingStateValue.lockedRelease)\n', '                         throw;\n', '                owner = _addr;\n', '        }\n', '\n', '        // ----------------------------\n', '        // set developers account\n', '        // ----------------------------\n', '        function setDeveloper(address _addr)\n', '        {\n', '                if (msg.sender != owner\n', '                        || settingsState == SettingStateValue.lockedRelease)\n', '                         throw;\n', '                developers = _addr;\n', '        }\n', '\n', '        // ----------------------------\n', '        // set oldE4 Addresses\n', '        // ----------------------------\n', '        function setOldE4(address _oldE4, address _oldE4Recyle)\n', '        {\n', '                if (msg.sender != owner\n', '                        || settingsState == SettingStateValue.lockedRelease)\n', '                         throw;\n', '                oldE4 = _oldE4;\n', '                oldE4RecycleBin = _oldE4Recyle;\n', '        }\n', '\n', '        // ----------------------------\n', '        // get account info\n', '        // ----------------------------\n', '        function getAccountInfo(address _addr) constant returns(uint _tokens, uint _snapshot, uint _points)\n', '        {\n', '                _tokens = holderAccounts[_addr].tokens;\n', '                _snapshot = holderAccounts[_addr].lastSnapshot;\n', '                _points = holderAccounts[_addr].currentPoints;\n', '        }\n', '\n', '\n', '        // ----------------------------\n', '        // DEBUG ONLY - end this contract, suicide to developers\n', '        // ----------------------------\n', '        function haraKiri()\n', '        {\n', '                if (settingsState != SettingStateValue.debug)\n', '                        throw;\n', '                if (msg.sender != owner)\n', '                         throw;\n', '                suicide(developers);\n', '        }\n', '\n', '\n', '        // ----------------------------\n', '        // OPT IN FROM CLASSIC.\n', '        // All old token holders can opt into this new contract by calling this function.\n', '        // This "transferFrom"s tokens from the old addresses to the new recycleBin address\n', '        // which is a new address set up on the old contract.  Afterwhich new tokens\n', '        // are credited to the old holder.  Also the lastSnapShot is set to 0 then\n', '        // calcCredited points are called setting up the new signatoree all of his\n', '        // accrued dividends.\n', '        // ----------------------------\n', '        function optInFromClassic() public\n', '        {\n', '                if (oldE4 == address(0)) {\n', '                        StatEvent("config err");\n', '                        return;\n', '                }\n', '                // 1. check balance of msg.sender in old contract.\n', '                address nrequester = msg.sender;\n', '\n', '                // 2. make sure account not already allocd (in fact, it&#39;s ok if it&#39;s allocd, so long\n', '                // as it is empty now. the reason for this check is cuz we are going to credit him with\n', '                // dividends, according to his token count, from the begin of time.\n', '                if (holderAccounts[nrequester].tokens != 0) {\n', '                        StatEvent("Account has already has tokens!");\n', '                        return;\n', '                }\n', '\n', '                // 3. check his tok balance\n', '                Token iclassic = Token(oldE4);\n', '                uint _toks = iclassic.balanceOf(nrequester);\n', '                if (_toks == 0) {\n', '                        StatEvent("Nothing to do");\n', '                        return;\n', '                }\n', '\n', '                // must be 100 percent of holdings\n', '                if (iclassic.allowance(nrequester, address(this)) < _toks) {\n', '                        StatEvent("Please approve this contract to transfer");\n', '                        return;\n', '                }\n', '\n', '                // 4. before we do the transfer, make sure that we have at least enough gas for the\n', '                // transfer plus the remainder of this fcn.\n', '                if (msg.gas < optInXferGas + optInFcnMinGas)\n', '                        throw;\n', '\n', '                // 5. transfer his old toks to recyle bin\n', '                iclassic.transferFrom.gas(optInXferGas)(nrequester, oldE4RecycleBin, _toks);\n', '\n', '                // todo, error check?\n', '                if (iclassic.balanceOf(nrequester) == 0) {\n', '                        // success, add the account, set the tokens, set snapshot to zero\n', '                        if (!holderAccounts[nrequester].alloced)\n', '                                addAccount(nrequester);\n', '                        holderAccounts[nrequester].tokens = _toks * NewTokensPerOrigToken;\n', '                        holderAccounts[nrequester].lastSnapshot = 0;\n', '                        calcCurPointsForAcct(nrequester);\n', '                        numToksSwitchedOver += _toks;\n', '                        // no need to decrement points from a "holding account"\n', '                        // b/c there is no need to keep it.\n', '                        StatEvent("Success Switched Over");\n', '                } else\n', '                        StatEvent("Transfer Error! please contact Dev team!");\n', '\n', '\n', '        }\n', '\n', '\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '// VERSION LAVA(I)\n', '\n', '\n', '// --------------------------\n', "// here's how this works:\n", "// the current amount of dividends due to each token-holder's  is:\n", '//   previous_due + [ p(x) * t(x)/N ] + [ p(x+1) * t(x+1)/N ] + ...\n', "//   where p(x) is the x'th payment received by the contract\n", '//         t(x) is the number of tokens held by the token-holder at the time of p(x)\n', '//         N    is the total number of tokens, which never changes\n', '//\n', '// assume that t(x) takes on 3 values, t(a), t(b) and t(c), during periods a, b, and c. then:\n', '// factoring:\n', '//   current_due = { (t(a) * [p(x) + p(x+1)] ...) +\n', '//                   (t(b) * [p(y) + p(y+1)] ...) +\n', '//                   (t(c) * [p(z) + p(z+1)] ...) } / N\n', '//\n', '// or\n', '//\n', '//   current_due = { (t(a) * period_a_fees) +\n', '//                   (t(b) * period_b_fees) +\n', '//                   (t(c) * period_c_fees) } / N\n', '//\n', '// if we designate current_due * N as current-points, then\n', '//\n', '//   currentPoints = {  (t(a) * period_a_fees) +\n', '//                      (t(b) * period_b_fees) +\n', '//                      (t(c) * period_c_fees) }\n', '//\n', "// or more succictly, if we recompute current points before a token-holder's number of\n", '// tokens, T, is about to change:\n', '//\n', '//   currentPoints = previous_points + (T * current-period-fees)\n', '//\n', "// when we want to do a payout, we'll calculate:\n", '//  current_due = current-points / N\n', '//\n', "// we'll keep track of a token-holder's current-period-points, which is:\n", '//   T * current-period-fees\n', '// by taking a snapshot of fees collected exactly when the current period began; that is, the when the\n', '// number of tokens last changed. that is, we keep a running count of total fees received\n', '//\n', '//   TotalFeesReceived = p(x) + p(x+1) + p(x+2)\n', '//\n', '// (which happily is the same for all token holders) then, before any token holder changes their number of\n', '// tokens we compute (for that token holder):\n', '//\n', '//  function calcCurPointsForAcct(acct) {\n', '//    currentPoints[acct] += (TotalFeesReceived - lastSnapshot[acct]) * T[acct]\n', '//    lastSnapshot[acct] = TotalFeesReceived\n', '//  }\n', '//\n', '// in the withdraw fcn, all we need is:\n', '//\n', '//  function withdraw(acct) {\n', '//    calcCurPointsForAcct(acct);\n', '//    current_amount_due = currentPoints[acct] / N\n', '//    currentPoints[acct] = 0;\n', '//    send(current_amount_due);\n', '//  }\n', '//\n', '//\n', '// special provisions for transfers from the old e4row contract (token-split transfers)\n', '// -------------------------------------------------------------------------------------\n', '// normally when a new acct is created, eg cuz tokens are transferred from one acct to another, we first call\n', '// calcCurPointsForAcct(acct) on the old acct; on the new acct we set:\n', '//  currentPoints[acct] = 0;\n', '//  lastSnapshot[acct] = TotalFeesReceived;\n', '//\n', '// this starts the new account with no credits for any dividends that have been collected so far, which is what\n', '// you would generally want. however, there is a case in which tokens are transferred from the old e4row contract.\n', '// in that case the tokens were reserved on this contract all along, and they earn dividends even before they are\n', '// assigned to an account. so for token-split transfers:\n', '//  currentPoints[acct] = 0;\n', '//  lastSnapshot[acct] = 0;\n', '//\n', '// then immediately call calcCurPointsForAcct(acct) for the new token-split account. he will get credit\n', '// for all the accumulated points, from the beginning of time.\n', '//\n', '// --------------------------\n', '\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', '// ---------------------------------\n', '// ABSTRACT standard token class\n', '// ---------------------------------\n', 'contract Token {\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '// --------------------------\n', '//  E4RowRewards - abstract e4 dividend contract\n', '// --------------------------\n', 'contract E4LavaRewards\n', '{\n', '        function checkDividends(address _addr) constant returns(uint _amount);\n', '        function withdrawDividends() public returns (uint namount);\n', '        function transferDividends(address _to) returns (bool success);\n', '        function getAccountInfo(address _addr) constant returns(uint _tokens, uint _snapshot, uint _points);\n', '\n', '}\n', '\n', '// --------------------------\n', '//  E4LavaOptin - abstract e4 optin contract\n', '// --------------------------\n', 'contract E4LavaOptIn\n', '{\n', '        function optInFromClassic() public;\n', '}\n', '\n', '\n', '// --------------------------\n', '//  E4ROW (LAVA) - token contract\n', '// --------------------------\n', 'contract E4Lava is Token, E4LavaRewards, E4LavaOptIn {\n', '        event StatEvent(string msg);\n', '        event StatEventI(string msg, uint val);\n', '\n', '        enum SettingStateValue  {debug, lockedRelease}\n', '\n', '        struct tokenAccount {\n', '                bool alloced;       // flag to ascert prior allocation\n', '                uint tokens;        // num tokens currently held in this acct\n', '                uint currentPoints; // updated before token balance changes, or before a withdrawal. credit for owning tokens\n', "                uint lastSnapshot;  // snapshot of global TotalPoints, last time we updated this acct's currentPoints\n", '        }\n', '\n', '// -----------------------------\n', '//  data storage\n', '// ----------------------------------------\n', '        uint constant NumOrigTokens         = 5762;   // number of old tokens, from original token contract\n', '        uint constant NewTokensPerOrigToken = 100000; // how many new tokens are created for each from original token\n', '        uint constant NewTokenSupply        = 5762 * 100000;\n', '        uint public numToksSwitchedOver;              // count old tokens that have been converted\n', '        uint public holdoverBalance;                  // funds received, but not yet distributed\n', '        uint public TotalFeesReceived;                // total fees received from partner contract(s)\n', '\n', '        address public developers;                    // developers token holding address\n', '        address public owner;                         // deployer executor\n', '        address public oldE4;                         // addr of old e4 token contract\n', '        address public oldE4RecycleBin;               // addr to transfer old tokens\n', '\n', '        uint public decimals;\n', '        string public symbol;\n', '\n', '        mapping (address => tokenAccount) holderAccounts;          // who holds how many tokens (high two bytes contain curPayId)\n', '        mapping (uint => address) holderIndexes;                   // for iteration thru holder\n', '        mapping (address => mapping (address => uint256)) allowed; // approvals\n', '        uint public numAccounts;\n', '\n', '        uint public payoutThreshold;                  // no withdrawals less than this amount, to avoid remainders\n', '        uint public rwGas;                            // reward gas\n', '        uint public optInXferGas;                     // gas used when optInFromClassic calls xfer on old contract\n', '        uint public optInFcnMinGas;                   // gas we need for the optInFromClassic fcn, *excluding* optInXferGas\n', '        uint public vestTime = 1525219201;            // 1 year past sale vest developer tokens\n', '\n', '        SettingStateValue public settingsState;\n', '\n', '\n', '        // --------------------\n', '        // contract constructor\n', '        // --------------------\n', '        function E4Lava()\n', '        {\n', '                owner = msg.sender;\n', '                developers = msg.sender;\n', '                decimals = 2;\n', '                symbol = "E4ROW";\n', '        }\n', '\n', '        // -----------------------------------\n', '        // use this to reset everything, will never be called after lockRelease\n', '        // -----------------------------------\n', '        function applySettings(SettingStateValue qState, uint _threshold, uint _rw, uint _optXferGas, uint _optFcnGas )\n', '        {\n', '                if (msg.sender != owner)\n', '                        return;\n', '\n', '                // these settings are permanently tweakable for performance adjustments\n', '                payoutThreshold = _threshold;\n', '                rwGas = _rw;\n', '                optInXferGas = _optXferGas;\n', '                optInFcnMinGas = _optFcnGas;\n', '\n', '                // this first test checks if already locked\n', '                if (settingsState == SettingStateValue.lockedRelease)\n', '                        return;\n', '\n', '                settingsState = qState;\n', '\n', '                // this second test allows locking without changing other permanent settings\n', "                // WARNING, MAKE SURE YOUR'RE HAPPY WITH ALL SETTINGS\n", '                // BEFORE LOCKING\n', '\n', '                if (qState == SettingStateValue.lockedRelease) {\n', '                        StatEvent("Locking!");\n', '                        return;\n', '                }\n', '\n', '                // zero out all token holders.\n', '                // leave alloced on, leave num accounts\n', '                // cant delete them anyways\n', '\n', '                for (uint i = 0; i < numAccounts; i++ ) {\n', '                        address a = holderIndexes[i];\n', '                        if (a != address(0)) {\n', '                                holderAccounts[a].tokens = 0;\n', '                                holderAccounts[a].currentPoints = 0;\n', '                                holderAccounts[a].lastSnapshot = 0;\n', '                        }\n', '                }\n', '\n', '                numToksSwitchedOver = 0;\n', '\n', '                if (this.balance > 0) {\n', '                        if (!owner.call.gas(rwGas).value(this.balance)())\n', '                                StatEvent("ERROR!");\n', '                }\n', '                StatEvent("ok");\n', '\n', '        }\n', '\n', '\n', '        // ---------------------------------------------------\n', '        // allocate a new account by setting alloc to true\n', '        // add holder index, bump the num accounts\n', '        // ---------------------------------------------------\n', '        function addAccount(address _addr) internal  {\n', '                holderAccounts[_addr].alloced = true;\n', '                holderAccounts[_addr].tokens = 0;\n', '                holderAccounts[_addr].currentPoints = 0;\n', '                holderAccounts[_addr].lastSnapshot = TotalFeesReceived;\n', '                holderIndexes[numAccounts++] = _addr;\n', '        }\n', '\n', '\n', '// --------------------------------------\n', '// BEGIN ERC-20 from StandardToken\n', '// --------------------------------------\n', '\n', '        function totalSupply() constant returns (uint256 supply)\n', '        {\n', '                supply = NewTokenSupply;\n', '        }\n', '\n', '        // ----------------------------\n', '        // sender transfers tokens to a new acct\n', '        // do not use this fcn for a token-split transfer from the old token contract!\n', '        // ----------------------------\n', '        function transfer(address _to, uint256 _value) returns (bool success)\n', '        {\n', '                if ((msg.sender == developers)\n', '                        &&  (now < vestTime)) {\n', '                        //statEvent("Tokens not yet vested.");\n', '                        return false;\n', '                }\n', '\n', "                //Default assumes totalSupply can't be over max (2^256 - 1).\n", "                //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '                //Replace the if with this one instead.\n', '                //if (holderAccounts[msg.sender].tokens >= _value && balances[_to] + _value > holderAccounts[_to]) {\n', '                if (holderAccounts[msg.sender].tokens >= _value && _value > 0) {\n', '                    //first credit sender with points accrued so far.. must do this before number of held tokens changes\n', '                    calcCurPointsForAcct(msg.sender);\n', '                    holderAccounts[msg.sender].tokens -= _value;\n', '\n', '                    if (!holderAccounts[_to].alloced) {\n', '                        addAccount(_to);\n', '                    }\n', '                    //credit destination acct with points accrued so far.. must do this before number of held tokens changes\n', '                    calcCurPointsForAcct(_to);\n', '                    holderAccounts[_to].tokens += _value;\n', '\n', '                    Transfer(msg.sender, _to, _value);\n', '                    return true;\n', '                } else {\n', '                    return false;\n', '                }\n', '        }\n', '\n', '\n', '        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '                if ((_from == developers)\n', '                        &&  (now < vestTime)) {\n', '                        //statEvent("Tokens not yet vested.");\n', '                        return false;\n', '                }\n', '\n', '                //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '                //if (holderAccounts[_from].tokens >= _value && allowed[_from][msg.sender] >= _value && holderAccounts[_to].tokens + _value > holderAccounts[_to].tokens) {\n', '                if (holderAccounts[_from].tokens >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '\n', '                    calcCurPointsForAcct(_from);\n', '                    holderAccounts[_from].tokens -= _value;\n', '\n', '                    if (!holderAccounts[_to].alloced) {\n', '                        addAccount(_to);\n', '                    }\n', '                    //credit destination acct with points accrued so far.. must do this before number of held tokens changes\n', '                    calcCurPointsForAcct(_to);\n', '                    holderAccounts[_to].tokens += _value;\n', '\n', '                    allowed[_from][msg.sender] -= _value;\n', '                    Transfer(_from, _to, _value);\n', '                    return true;\n', '                } else {\n', '                    return false;\n', '                }\n', '        }\n', '\n', '\n', '        function balanceOf(address _owner) constant returns (uint256 balance) {\n', '                balance = holderAccounts[_owner].tokens;\n', '        }\n', '\n', '        function approve(address _spender, uint256 _value) returns (bool success) {\n', '                allowed[msg.sender][_spender] = _value;\n', '                Approval(msg.sender, _spender, _value);\n', '                return true;\n', '        }\n', '\n', '        function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '                return allowed[_owner][_spender];\n', '        }\n', '// ----------------------------------\n', '// END ERC20\n', '// ----------------------------------\n', '\n', '        // ----------------------------\n', '        // calc current points for a token holder; that is, points that are due to this token holder for all dividends\n', '        // received by the contract during the current "period". the period began the last time this fcn was called, at which\n', "        // time we updated the account's snapshot of the running point count, TotalFeesReceived. during the period the account's\n", '        // number of tokens must not have changed. so always call this fcn before changing the number of tokens.\n', '        // ----------------------------\n', '        function calcCurPointsForAcct(address _acct) internal {\n', '              holderAccounts[_acct].currentPoints += (TotalFeesReceived - holderAccounts[_acct].lastSnapshot) * holderAccounts[_acct].tokens;\n', '              holderAccounts[_acct].lastSnapshot = TotalFeesReceived;\n', '        }\n', '\n', '\n', '        // ---------------------------\n', '        // accept payment from a partner contract\n', '        // funds sent here are added to TotalFeesReceived\n', '        // WARNING! DO NOT CALL THIS FUNCTION LEST YOU LOSE YOUR MONEY\n', '        // ---------------------------\n', '        function () payable {\n', '                holdoverBalance += msg.value;\n', '                TotalFeesReceived += msg.value;\n', '                StatEventI("Payment", msg.value);\n', '        }\n', '\n', '        // ---------------------------\n', '        // one never knows if this will come in handy.\n', '        // ---------------------------\n', '        function blackHole() payable {\n', '                StatEventI("adjusted", msg.value);\n', '        }\n', '\n', '        // ----------------------------\n', '        // sender withdraw entire rewards/dividends\n', '        // ----------------------------\n', '        function withdrawDividends() public returns (uint _amount)\n', '        {\n', '                calcCurPointsForAcct(msg.sender);\n', '\n', '                _amount = holderAccounts[msg.sender].currentPoints / NewTokenSupply;\n', '                if (_amount <= payoutThreshold) {\n', '                        StatEventI("low Balance", _amount);\n', '                        return;\n', '                } else {\n', '                        if ((msg.sender == developers)\n', '                                &&  (now < vestTime)) {\n', '                                StatEvent("Tokens not yet vested.");\n', '                                _amount = 0;\n', '                                return;\n', '                        }\n', '\n', '                        uint _pointsUsed = _amount * NewTokenSupply;\n', '                        holderAccounts[msg.sender].currentPoints -= _pointsUsed;\n', '                        holdoverBalance -= _amount;\n', '                        if (!msg.sender.call.gas(rwGas).value(_amount)())\n', '                                throw;\n', '                }\n', '        }\n', '\n', '        // ----------------------------\n', '        // allow sender to transfer dividends\n', '        // ----------------------------\n', '        function transferDividends(address _to) returns (bool success)\n', '        {\n', '                if ((msg.sender == developers)\n', '                        &&  (now < vestTime)) {\n', '                        //statEvent("Tokens not yet vested.");\n', '                        return false;\n', '                }\n', '                calcCurPointsForAcct(msg.sender);\n', '                if (holderAccounts[msg.sender].currentPoints == 0) {\n', '                        StatEvent("Zero balance");\n', '                        return false;\n', '                }\n', '                if (!holderAccounts[_to].alloced) {\n', '                        addAccount(_to);\n', '                }\n', '                calcCurPointsForAcct(_to);\n', '                holderAccounts[_to].currentPoints += holderAccounts[msg.sender].currentPoints;\n', '                holderAccounts[msg.sender].currentPoints = 0;\n', '                StatEvent("Trasnfered Dividends");\n', '                return true;\n', '        }\n', '\n', '\n', '\n', '        // ----------------------------\n', '        // set gas for operations\n', '        // ----------------------------\n', '        function setOpGas(uint _rw, uint _optXferGas, uint _optFcnGas)\n', '        {\n', '                if (msg.sender != owner && msg.sender != developers) {\n', '                        //StatEvent("only owner calls");\n', '                        return;\n', '                } else {\n', '                        rwGas = _rw;\n', '                        optInXferGas = _optXferGas;\n', '                        optInFcnMinGas = _optFcnGas;\n', '                }\n', '        }\n', '\n', '\n', '        // ----------------------------\n', '        // check rewards.  pass in address of token holder\n', '        // ----------------------------\n', '        function checkDividends(address _addr) constant returns(uint _amount)\n', '        {\n', '                if (holderAccounts[_addr].alloced) {\n', "                   //don't call calcCurPointsForAcct here, cuz this is a constant fcn\n", '                   uint _currentPoints = holderAccounts[_addr].currentPoints +\n', '                        ((TotalFeesReceived - holderAccounts[_addr].lastSnapshot) * holderAccounts[_addr].tokens);\n', '                   _amount = _currentPoints / NewTokenSupply;\n', '\n', '                // low balance? let him see it -Etansky\n', '                  // if (_amount <= payoutThreshold) {\n', '                  //    _amount = 0;\n', '                  // }\n', '\n', '                }\n', '        }\n', '\n', '\n', '\n', '        // ----------------------------\n', '        // swap executor\n', '        // ----------------------------\n', '        function changeOwner(address _addr)\n', '        {\n', '                if (msg.sender != owner\n', '                        || settingsState == SettingStateValue.lockedRelease)\n', '                         throw;\n', '                owner = _addr;\n', '        }\n', '\n', '        // ----------------------------\n', '        // set developers account\n', '        // ----------------------------\n', '        function setDeveloper(address _addr)\n', '        {\n', '                if (msg.sender != owner\n', '                        || settingsState == SettingStateValue.lockedRelease)\n', '                         throw;\n', '                developers = _addr;\n', '        }\n', '\n', '        // ----------------------------\n', '        // set oldE4 Addresses\n', '        // ----------------------------\n', '        function setOldE4(address _oldE4, address _oldE4Recyle)\n', '        {\n', '                if (msg.sender != owner\n', '                        || settingsState == SettingStateValue.lockedRelease)\n', '                         throw;\n', '                oldE4 = _oldE4;\n', '                oldE4RecycleBin = _oldE4Recyle;\n', '        }\n', '\n', '        // ----------------------------\n', '        // get account info\n', '        // ----------------------------\n', '        function getAccountInfo(address _addr) constant returns(uint _tokens, uint _snapshot, uint _points)\n', '        {\n', '                _tokens = holderAccounts[_addr].tokens;\n', '                _snapshot = holderAccounts[_addr].lastSnapshot;\n', '                _points = holderAccounts[_addr].currentPoints;\n', '        }\n', '\n', '\n', '        // ----------------------------\n', '        // DEBUG ONLY - end this contract, suicide to developers\n', '        // ----------------------------\n', '        function haraKiri()\n', '        {\n', '                if (settingsState != SettingStateValue.debug)\n', '                        throw;\n', '                if (msg.sender != owner)\n', '                         throw;\n', '                suicide(developers);\n', '        }\n', '\n', '\n', '        // ----------------------------\n', '        // OPT IN FROM CLASSIC.\n', '        // All old token holders can opt into this new contract by calling this function.\n', '        // This "transferFrom"s tokens from the old addresses to the new recycleBin address\n', '        // which is a new address set up on the old contract.  Afterwhich new tokens\n', '        // are credited to the old holder.  Also the lastSnapShot is set to 0 then\n', '        // calcCredited points are called setting up the new signatoree all of his\n', '        // accrued dividends.\n', '        // ----------------------------\n', '        function optInFromClassic() public\n', '        {\n', '                if (oldE4 == address(0)) {\n', '                        StatEvent("config err");\n', '                        return;\n', '                }\n', '                // 1. check balance of msg.sender in old contract.\n', '                address nrequester = msg.sender;\n', '\n', "                // 2. make sure account not already allocd (in fact, it's ok if it's allocd, so long\n", '                // as it is empty now. the reason for this check is cuz we are going to credit him with\n', '                // dividends, according to his token count, from the begin of time.\n', '                if (holderAccounts[nrequester].tokens != 0) {\n', '                        StatEvent("Account has already has tokens!");\n', '                        return;\n', '                }\n', '\n', '                // 3. check his tok balance\n', '                Token iclassic = Token(oldE4);\n', '                uint _toks = iclassic.balanceOf(nrequester);\n', '                if (_toks == 0) {\n', '                        StatEvent("Nothing to do");\n', '                        return;\n', '                }\n', '\n', '                // must be 100 percent of holdings\n', '                if (iclassic.allowance(nrequester, address(this)) < _toks) {\n', '                        StatEvent("Please approve this contract to transfer");\n', '                        return;\n', '                }\n', '\n', '                // 4. before we do the transfer, make sure that we have at least enough gas for the\n', '                // transfer plus the remainder of this fcn.\n', '                if (msg.gas < optInXferGas + optInFcnMinGas)\n', '                        throw;\n', '\n', '                // 5. transfer his old toks to recyle bin\n', '                iclassic.transferFrom.gas(optInXferGas)(nrequester, oldE4RecycleBin, _toks);\n', '\n', '                // todo, error check?\n', '                if (iclassic.balanceOf(nrequester) == 0) {\n', '                        // success, add the account, set the tokens, set snapshot to zero\n', '                        if (!holderAccounts[nrequester].alloced)\n', '                                addAccount(nrequester);\n', '                        holderAccounts[nrequester].tokens = _toks * NewTokensPerOrigToken;\n', '                        holderAccounts[nrequester].lastSnapshot = 0;\n', '                        calcCurPointsForAcct(nrequester);\n', '                        numToksSwitchedOver += _toks;\n', '                        // no need to decrement points from a "holding account"\n', '                        // b/c there is no need to keep it.\n', '                        StatEvent("Success Switched Over");\n', '                } else\n', '                        StatEvent("Transfer Error! please contact Dev team!");\n', '\n', '\n', '        }\n', '\n', '\n', '\n', '}']
