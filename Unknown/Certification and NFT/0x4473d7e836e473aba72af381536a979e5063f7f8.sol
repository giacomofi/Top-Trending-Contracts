['pragma solidity ^0.4.13;\n', '\n', '/*\n', '\n', 'Cobinhood Presale Buyer\n', '========================\n', '\n', 'Buys Cobinhood tokens from the crowdsale on your behalf.\n', 'Author: /u/troythus, @troyth\n', 'Forked from: /u/Cintix\n', '\n', '*/\n', '\n', '// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', 'contract CobinhoodBuyer {\n', '  // Store the amount of ETH deposited by each account.\n', '  mapping (address => uint256) public balances;\n', '  // Track whether the contract has received the tokens yet.\n', '  bool public received_tokens;\n', '  // Track whether the contract has sent ETH to the presale contract yet.\n', '  bool public purchased_tokens;\n', '  // Record ETH value of tokens currently held by contract.\n', '  uint256 public contract_eth_value;\n', '  // Emergency kill switch in case a critical bug is found.\n', '  bool public kill_switch;\n', '\n', '  // SHA3 hash of kill switch password.\n', '  bytes32 password_hash = 0xe3ce8892378c33f21165c3fa9b1c106524b2352e16ea561d943008f11f0ecce0;\n', '  // Latest time contract is allowed to buy into the crowdsale.\n', '  uint256 public latest_buy_time = 1505109600;\n', '  // Maximum amount of user ETH contract will accept.  Reduces risk of hard cap related failure.\n', '  uint256 public eth_cap = 299 ether;\n', '  // Minimum amount of user ETH contract will accept.  Reduces risk of hard cap related failure.\n', '  uint256 public eth_min = 149 ether;\n', '  // The developer address.\n', '  address public developer = 0x0575C223f5b87Be4812926037912D45B31270d3B;\n', '  // The fee claimer&#39;s address.\n', '  address public fee_claimer = 0x9793661F48b61D0b8B6D39D53CAe694b101ff028;\n', '  // The crowdsale address.\n', '  address public sale = 0x0bb9fc3ba7bcf6e5d6f6fc15123ff8d5f96cee00;\n', '  // The token address.  Settable by the developer once Cobinhood announces it.\n', '  ERC20 public token;\n', '\n', '  // Allows the developer to set the token address because we don&#39;t know it yet.\n', '  function set_address(address _token) {\n', '    // Only allow the developer to set the token addresses.\n', '    require(msg.sender == developer);\n', '    // Set the token addresse.\n', '    token = ERC20(_token);\n', '  }\n', '\n', '  // Developer override of received_tokens to make sure tokens aren&#39;t stuck.\n', '  function force_received() {\n', '      require(msg.sender == developer);\n', '      received_tokens = true;\n', '  }\n', '\n', '  // Anyone can call to see if tokens have been received, and then set the flag to let withdrawls happen.\n', '  function received_tokens() {\n', '      if( token.balanceOf(address(this)) > 0){\n', '          received_tokens = true;\n', '      }\n', '  }\n', '\n', '  // Allows the developer or anyone with the password to shut down everything except withdrawals in emergencies.\n', '  function activate_kill_switch(string password) {\n', '    // Only activate the kill switch if the sender is the developer or the password is correct.\n', '    require(msg.sender == developer || sha3(password) == password_hash);\n', '\n', '    // Irreversibly activate the kill switch.\n', '    kill_switch = true;\n', '  }\n', '\n', '  // Withdraws all ETH deposited or tokens purchased by the given user.\n', '  function withdraw(address user){\n', '    // Only allow withdrawals after the contract has had a chance to buy in.\n', '    require(received_tokens || now > latest_buy_time);\n', '    // Short circuit to save gas if the user doesn&#39;t have a balance.\n', '    if (balances[user] == 0) return;\n', '    // If the contract failed to buy into the sale, withdraw the user&#39;s ETH.\n', '    if (!received_tokens || kill_switch) {\n', '      // Store the user&#39;s balance prior to withdrawal in a temporary variable.\n', '      uint256 eth_to_withdraw = balances[user];\n', '      // Update the user&#39;s balance prior to sending ETH to prevent recursive call.\n', '      balances[user] = 0;\n', '      // Return the user&#39;s funds.  Throws on failure to prevent loss of funds.\n', '      user.transfer(eth_to_withdraw);\n', '    }\n', '    // Withdraw the user&#39;s tokens if the contract has purchased them.\n', '    else {\n', '      // Retrieve current token balance of contract.\n', '      uint256 contract_token_balance = token.balanceOf(address(this));\n', '      // Disallow token withdrawals if there are no tokens to withdraw.\n', '      require(contract_token_balance != 0);\n', '      // Store the user&#39;s token balance in a temporary variable.\n', '      uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value;\n', '      // Update the value of tokens currently held by the contract.\n', '      contract_eth_value -= balances[user];\n', '      // Update the user&#39;s balance prior to sending to prevent recursive call.\n', '      balances[user] = 0;\n', '      // 1% fee if contract successfully bought tokens.\n', '      uint256 fee = tokens_to_withdraw / 100;\n', '      // Send the fee to the developer.\n', '      require(token.transfer(fee_claimer, fee));\n', '      // Send the funds.  Throws on failure to prevent loss of funds.\n', '      require(token.transfer(user, tokens_to_withdraw - fee));\n', '    }\n', '  }\n', '\n', '  // Send all ETH to the presale contract once total is between [149,299], callable by anyone.\n', '  function purchase(){\n', '    // Short circuit to save gas if the contract has already bought tokens.\n', '    if (purchased_tokens) return;\n', '    // Short circuit to save gas if the earliest buy time hasn&#39;t been reached.\n', '    if (now > latest_buy_time) return;\n', '    // Short circuit to save gas if kill switch is active.\n', '    if (kill_switch) return;\n', '    // Short circuit to save gas if the minimum buy in hasn&#39;t been achieved.\n', '    if (this.balance < eth_min) return;\n', '    // Record that the contract has bought the tokens.\n', '    purchased_tokens = true;\n', '    // Transfer all the funds to the crowdsale address\n', '    // to buy tokens.  Throws if the crowdsale hasn&#39;t started yet or has\n', '    // already completed, preventing loss of funds.\n', '    require(sale.call.value(this.balance)());\n', '  }\n', '\n', '  // Default function.  Called when a user sends ETH to the contract.\n', '  function () payable {\n', '    // Disallow deposits if kill switch is active.\n', '    require(!kill_switch);\n', '    // Only allow deposits if the contract hasn&#39;t already purchased the tokens.\n', '    require(!purchased_tokens);\n', '    // Only allow deposits that won&#39;t exceed the contract&#39;s ETH cap.\n', '    require(this.balance < eth_cap);\n', '    // Update records of deposited ETH to include the received amount.\n', '    balances[msg.sender] += msg.value;\n', '  }\n', '}']
['pragma solidity ^0.4.13;\n', '\n', '/*\n', '\n', 'Cobinhood Presale Buyer\n', '========================\n', '\n', 'Buys Cobinhood tokens from the crowdsale on your behalf.\n', 'Author: /u/troythus, @troyth\n', 'Forked from: /u/Cintix\n', '\n', '*/\n', '\n', '// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', 'contract CobinhoodBuyer {\n', '  // Store the amount of ETH deposited by each account.\n', '  mapping (address => uint256) public balances;\n', '  // Track whether the contract has received the tokens yet.\n', '  bool public received_tokens;\n', '  // Track whether the contract has sent ETH to the presale contract yet.\n', '  bool public purchased_tokens;\n', '  // Record ETH value of tokens currently held by contract.\n', '  uint256 public contract_eth_value;\n', '  // Emergency kill switch in case a critical bug is found.\n', '  bool public kill_switch;\n', '\n', '  // SHA3 hash of kill switch password.\n', '  bytes32 password_hash = 0xe3ce8892378c33f21165c3fa9b1c106524b2352e16ea561d943008f11f0ecce0;\n', '  // Latest time contract is allowed to buy into the crowdsale.\n', '  uint256 public latest_buy_time = 1505109600;\n', '  // Maximum amount of user ETH contract will accept.  Reduces risk of hard cap related failure.\n', '  uint256 public eth_cap = 299 ether;\n', '  // Minimum amount of user ETH contract will accept.  Reduces risk of hard cap related failure.\n', '  uint256 public eth_min = 149 ether;\n', '  // The developer address.\n', '  address public developer = 0x0575C223f5b87Be4812926037912D45B31270d3B;\n', "  // The fee claimer's address.\n", '  address public fee_claimer = 0x9793661F48b61D0b8B6D39D53CAe694b101ff028;\n', '  // The crowdsale address.\n', '  address public sale = 0x0bb9fc3ba7bcf6e5d6f6fc15123ff8d5f96cee00;\n', '  // The token address.  Settable by the developer once Cobinhood announces it.\n', '  ERC20 public token;\n', '\n', "  // Allows the developer to set the token address because we don't know it yet.\n", '  function set_address(address _token) {\n', '    // Only allow the developer to set the token addresses.\n', '    require(msg.sender == developer);\n', '    // Set the token addresse.\n', '    token = ERC20(_token);\n', '  }\n', '\n', "  // Developer override of received_tokens to make sure tokens aren't stuck.\n", '  function force_received() {\n', '      require(msg.sender == developer);\n', '      received_tokens = true;\n', '  }\n', '\n', '  // Anyone can call to see if tokens have been received, and then set the flag to let withdrawls happen.\n', '  function received_tokens() {\n', '      if( token.balanceOf(address(this)) > 0){\n', '          received_tokens = true;\n', '      }\n', '  }\n', '\n', '  // Allows the developer or anyone with the password to shut down everything except withdrawals in emergencies.\n', '  function activate_kill_switch(string password) {\n', '    // Only activate the kill switch if the sender is the developer or the password is correct.\n', '    require(msg.sender == developer || sha3(password) == password_hash);\n', '\n', '    // Irreversibly activate the kill switch.\n', '    kill_switch = true;\n', '  }\n', '\n', '  // Withdraws all ETH deposited or tokens purchased by the given user.\n', '  function withdraw(address user){\n', '    // Only allow withdrawals after the contract has had a chance to buy in.\n', '    require(received_tokens || now > latest_buy_time);\n', "    // Short circuit to save gas if the user doesn't have a balance.\n", '    if (balances[user] == 0) return;\n', "    // If the contract failed to buy into the sale, withdraw the user's ETH.\n", '    if (!received_tokens || kill_switch) {\n', "      // Store the user's balance prior to withdrawal in a temporary variable.\n", '      uint256 eth_to_withdraw = balances[user];\n', "      // Update the user's balance prior to sending ETH to prevent recursive call.\n", '      balances[user] = 0;\n', "      // Return the user's funds.  Throws on failure to prevent loss of funds.\n", '      user.transfer(eth_to_withdraw);\n', '    }\n', "    // Withdraw the user's tokens if the contract has purchased them.\n", '    else {\n', '      // Retrieve current token balance of contract.\n', '      uint256 contract_token_balance = token.balanceOf(address(this));\n', '      // Disallow token withdrawals if there are no tokens to withdraw.\n', '      require(contract_token_balance != 0);\n', "      // Store the user's token balance in a temporary variable.\n", '      uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value;\n', '      // Update the value of tokens currently held by the contract.\n', '      contract_eth_value -= balances[user];\n', "      // Update the user's balance prior to sending to prevent recursive call.\n", '      balances[user] = 0;\n', '      // 1% fee if contract successfully bought tokens.\n', '      uint256 fee = tokens_to_withdraw / 100;\n', '      // Send the fee to the developer.\n', '      require(token.transfer(fee_claimer, fee));\n', '      // Send the funds.  Throws on failure to prevent loss of funds.\n', '      require(token.transfer(user, tokens_to_withdraw - fee));\n', '    }\n', '  }\n', '\n', '  // Send all ETH to the presale contract once total is between [149,299], callable by anyone.\n', '  function purchase(){\n', '    // Short circuit to save gas if the contract has already bought tokens.\n', '    if (purchased_tokens) return;\n', "    // Short circuit to save gas if the earliest buy time hasn't been reached.\n", '    if (now > latest_buy_time) return;\n', '    // Short circuit to save gas if kill switch is active.\n', '    if (kill_switch) return;\n', "    // Short circuit to save gas if the minimum buy in hasn't been achieved.\n", '    if (this.balance < eth_min) return;\n', '    // Record that the contract has bought the tokens.\n', '    purchased_tokens = true;\n', '    // Transfer all the funds to the crowdsale address\n', "    // to buy tokens.  Throws if the crowdsale hasn't started yet or has\n", '    // already completed, preventing loss of funds.\n', '    require(sale.call.value(this.balance)());\n', '  }\n', '\n', '  // Default function.  Called when a user sends ETH to the contract.\n', '  function () payable {\n', '    // Disallow deposits if kill switch is active.\n', '    require(!kill_switch);\n', "    // Only allow deposits if the contract hasn't already purchased the tokens.\n", '    require(!purchased_tokens);\n', "    // Only allow deposits that won't exceed the contract's ETH cap.\n", '    require(this.balance < eth_cap);\n', '    // Update records of deposited ETH to include the received amount.\n', '    balances[msg.sender] += msg.value;\n', '  }\n', '}']
