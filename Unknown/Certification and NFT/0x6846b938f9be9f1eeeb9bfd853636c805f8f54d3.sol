['pragma solidity ^0.4.6;\n', '\n', 'contract RES { \n', '\n', '    /* Public variables of the token */\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    \n', '    uint public totalSupply;\n', '    \n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) public balanceOf;\n', '    \n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '\n', '    /* Bought or sold */\n', '\n', '    event Bought(address from, uint amount);\n', '    event Sold(address from, uint amount);\n', '    event BoughtViaJohan(address from, uint amount);\n', '\n', '    /* Initializes contract with name, symbol and decimals */\n', '\n', '    function RES() {\n', '        name = "RES";     \n', '        symbol = "RES";\n', '        decimals = 18;\n', '    }\n', '\n', '}\n', '\n', 'contract SwarmRedistribution is RES {\n', '    \n', '    address public JohanNygren;\n', '    bool public campaignOpen;    \n', '\n', '    struct dividendPathway {\n', '      address from;\n', '      uint amount;\n', '      uint timeStamp;\n', '    }\n', '\n', '    mapping(address => dividendPathway[]) public dividendPathways;\n', '    \n', '    mapping(address => uint256) public totalBasicIncome;\n', '\n', '    uint taxRate;\n', '\n', '    struct Node {\n', '      address node;\n', '      address parent;\n', '      uint index;\n', '    }\n', '    \n', '    /* Generate a swarm tree */\n', '    Node[] swarmTree;\n', '    \n', '    mapping(address => bool) inSwarmTree;\n', '    \n', '    bool JohanInSwarm;\n', '\n', '    event Swarm(address indexed leaf, address indexed node, uint256 share);\n', '\n', '    function SwarmRedistribution() {\n', '      \n', '    /* Tax-rate in parts per thousand */\n', '    taxRate = 20;\n', '    JohanNygren = 0x948176CB42B65d835Ee4324914B104B66fB93B52;\n', '    campaignOpen = true;\n', '    \n', '    }\n', '    \n', '    modifier onlyJohan {\n', '      if(msg.sender != JohanNygren) throw;\n', '      _;\n', '    }\n', '\n', '    modifier isOpen {\n', '      if(campaignOpen != true) throw;\n', '      _;\n', '    }\n', '    \n', '    function changeJohanNygrensAddress(address _newAddress) onlyJohan {\n', '      JohanNygren = _newAddress;\n', '    }\n', '    \n', '    function closeCampaign() onlyJohan {\n', '        campaignOpen = false;\n', '    }\n', '\n', '    function buy() isOpen public payable {\n', '      balanceOf[msg.sender] += msg.value;\n', '      totalSupply += msg.value;\n', '      Bought(msg.sender, msg.value);\n', '    }  \n', '\n', '    function buyViaJohan() isOpen public payable {\n', '      balanceOf[msg.sender] += msg.value;\n', '      totalSupply += msg.value;  \n', '\n', '      /* Create the dividend pathway */\n', '      dividendPathways[msg.sender].push(dividendPathway({\n', '                                      from: JohanNygren, \n', '                                      amount:  msg.value,\n', '                                      timeStamp: now\n', '                                    }));\n', '\n', '      BoughtViaJohan(msg.sender, msg.value);\n', '    }\n', '\n', '    function sell(uint256 _value) public {\n', '      if(balanceOf[msg.sender] < _value) throw;\n', '      balanceOf[msg.sender] -= _value;\n', '    \n', '      if (!msg.sender.send(_value)) throw;\n', '\n', '      totalSupply -= _value;\n', '      Sold(msg.sender, _value);\n', '\n', '    }\n', '\n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) isOpen {\n', '        /* reject transaction to self to prevent dividend pathway loops*/\n', '        if(_to == msg.sender) throw;\n', '        \n', '        /* if the sender doenst have enough balance then stop */\n', '        if (balanceOf[msg.sender] < _value) throw;\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n', '        \n', '        /* Calculate tax */\n', '        uint256 taxCollected = _value * taxRate / 1000;\n', '        uint256 sentAmount;\n', '\n', '        /* Create the dividend pathway */\n', '        dividendPathways[_to].push(dividendPathway({\n', '                                        from: msg.sender, \n', '                                        amount:  _value,\n', '                                        timeStamp: now\n', '                                      }));\n', '        \n', '        if(swarmRedistribution(_to, taxCollected) == true) {\n', '          sentAmount = _value;\n', '        }\n', '        else {\n', '          /* Return tax */\n', '          sentAmount = _value - taxCollected;\n', '        }\n', '        \n', '          /* Add and subtract new balances */\n', '\n', '          balanceOf[msg.sender] -= sentAmount;\n', '          balanceOf[_to] += _value - taxCollected;\n', '        \n', '\n', '        /* Notifiy anyone listening that this transfer took place */\n', '        Transfer(msg.sender, _to, sentAmount);\n', '    }\n', '\n', '    function swarmRedistribution(address _to, uint256 _taxCollected) internal returns (bool) {\n', '           iterateThroughSwarm(_to, now);\n', '           if(swarmTree.length != 0) {\n', '           return doSwarm(_to, _taxCollected);\n', '           }\n', '           else return false;\n', '      }\n', '\n', '    function iterateThroughSwarm(address _node, uint _timeStamp) internal {\n', '      if(dividendPathways[_node].length != 0) {\n', '        for(uint i = 0; i < dividendPathways[_node].length; i++) {\n', '          if(inSwarmTree[dividendPathways[_node][i].from] == false) { \n', '            \n', '            uint timeStamp = dividendPathways[_node][i].timeStamp;\n', '            if(timeStamp <= _timeStamp) {\n', '                \n', '              if(dividendPathways[_node][i].from == JohanNygren) JohanInSwarm = true;\n', '    \n', '                Node memory node = Node({\n', '                            node: dividendPathways[_node][i].from, \n', '                            parent: _node,\n', '                            index: i\n', '                          });\n', '                          \n', '                  swarmTree.push(node);\n', '                  inSwarmTree[node.node] = true;\n', '                  iterateThroughSwarm(node.node, timeStamp);\n', '              }\n', '          }\n', '        }\n', '      }\n', '    }\n', '\n', '    function doSwarm(address _leaf, uint256 _taxCollected) internal returns (bool) {\n', '      \n', '      uint256 share;\n', '      if(JohanInSwarm) share = _taxCollected;\n', '      else share = 0;\n', '    \n', '      for(uint i = 0; i < swarmTree.length; i++) {\n', '        \n', '        address node = swarmTree[i].node;\n', '        address parent = swarmTree[i].parent;\n', '        uint index = swarmTree[i].index;\n', '        \n', '        bool isJohan;\n', '        if(node == JohanNygren) isJohan = true;\n', '\n', '        if(isJohan) {\n', '          balanceOf[swarmTree[i].node] += share;\n', '        totalBasicIncome[node] += share;\n', '        }\n', '          \n', '        if(dividendPathways[parent][index].amount - _taxCollected > 0) {\n', '          dividendPathways[parent][index].amount -= _taxCollected; \n', '        }\n', '        else removeDividendPathway(parent, index);\n', '        \n', '        inSwarmTree[node] = false;\n', '        \n', '        /* Notifiy anyone listening that this swarm took place */\n', '        if(isJohan) Swarm(_leaf, swarmTree[i].node, share);\n', '      }\n', '      delete swarmTree;\n', '      bool JohanWasInSwarm = JohanInSwarm;\n', '      delete JohanInSwarm;\n', '\n', '      if(!JohanWasInSwarm) return false;\n', '      return true;\n', '    }\n', '    \n', '    function removeDividendPathway(address node, uint index) internal {\n', '                delete dividendPathways[node][index];\n', '                for (uint i = index; i < dividendPathways[node].length - 1; i++) {\n', '                        dividendPathways[node][i] = dividendPathways[node][i + 1];\n', '                }\n', '                dividendPathways[node].length--;\n', '        }\n', '\n', '}']