['pragma solidity ^0.3.5;\n', '\n', 'contract DepositHolder {\n', '    uint constant GUARANTEE_PERIOD = 365 days;\n', '    \n', '    event Claim(address addr, uint amount);\n', '    \n', '    struct Entry {\n', '        bytes16 next;\n', '        uint64 deposit;\n', '        uint64 expires;\n', '    }\n', '\n', '    address owner;\n', '    address auditor;\n', '    \n', '    mapping(bytes16=>Entry) entries;\n', '    bytes16 oldestHash;\n', '    bytes16 newestHash;\n', '    \n', '    uint public paidOut;\n', '    uint public totalPaidOut;\n', '    uint public depositCount;\n', '    \n', '    function DepositHolder() {\n', '        owner = msg.sender;\n', '        auditor = owner;\n', '    }\n', '    \n', '    modifier owner_only {\n', '        if(msg.sender != owner) throw;\n', '        _;\n', '    }\n', '    \n', '    modifier auditor_only {\n', '        if(msg.sender != auditor) throw;\n', '        _;\n', '    }\n', '    \n', '    function setOwner(address newOwner) owner_only {\n', '        owner = newOwner;\n', '    }\n', '    \n', '    function setAuditor(address newAuditor) auditor_only {\n', '        auditor = newAuditor;\n', '    }\n', '\n', '    /**\n', '     * @dev Lodge deposits for a set of address hashes. Automatically uses\n', '     *      expired deposits to pay for new ones.\n', '     * @param values A list of hashes of addresses to place deposits for.\n', '     *        Each value is the first 16 bytes of the keccak-256 hash of the\n', '     *        address the deposit is for.\n', '     * @param deposit The amount of the deposit on each address.\n', '     */\n', '    function deposit(bytes16[] values, uint64 deposit) owner_only {\n', '        uint required = values.length * deposit;\n', '        if(msg.value < required) {\n', '            throw;\n', '        } else if(msg.value > required) {\n', '            if(!msg.sender.send(msg.value - required))\n', '                throw;\n', '        }\n', '\n', '        extend(values, uint64(deposit));\n', '    }\n', '\n', '    function extend(bytes16[] values, uint64 deposit) private {\n', '        uint64 expires = uint64(now + GUARANTEE_PERIOD);\n', '\n', '        if(oldestHash == 0) {\n', '            oldestHash = values[0];\n', '            newestHash = values[0];\n', '        } else {\n', '            entries[newestHash].next = values[0];\n', '        }\n', '        \n', '        for(uint i = 0; i < values.length - 1; i++) {\n', '            if(entries[values[i]].expires != 0)\n', '                throw;\n', '            entries[values[i]] = Entry(values[i + 1], deposit, expires);\n', '        }\n', '        \n', '        newestHash = values[values.length - 1];\n', '        if(entries[newestHash].expires != 0)\n', '            throw;\n', '        entries[newestHash] = Entry(0, deposit, expires);\n', '        \n', '        depositCount += values.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw funds held for expired deposits.\n', '     * @param max Maximum number of deposits to claim.\n', '     */\n', '    function withdraw(uint max) owner_only {\n', '        uint recovered = recover(max);\n', '        if(!msg.sender.send(recovered))\n', '            throw;\n', '    }\n', '\n', '    function recover(uint max) private returns(uint recovered) {\n', '        // Iterate through entries deleting them, until we find one\n', "        // that's new enough, or hit the limit.\n", '        bytes16 ptr = oldestHash;\n', '        uint count;\n', '        for(uint i = 0; i < max && ptr != 0 && entries[ptr].expires < now; i++) {\n', '            recovered += entries[ptr].deposit;\n', '            ptr = entries[ptr].next;\n', '            count += 1;\n', '        }\n', '\n', '        oldestHash = ptr;\n', '        if(oldestHash == 0)\n', '            newestHash = 0;\n', '        \n', '        // Deduct any outstanding payouts from the recovered funds\n', '        if(paidOut > 0) {\n', '            if(recovered > paidOut) {\n', '                recovered -= paidOut;\n', '                paidOut = 0;\n', '            } else {\n', '                paidOut -= recovered;\n', '                recovered = 0;\n', '            }\n', '        }\n', '        \n', '        depositCount -= count;\n', '    }\n', '\n', '    /**\n', '     * @dev Fetches information on a future withdrawal event\n', '     * @param hash The point at which to start scanning; 0 for the first event.\n', '     * @return when Unix timestamp at which a withdrawal can next happen.\n', '     * @return count Number of addresses expiring at this time\n', '     * @return value Total amount withdrawable at this time\n', '     * @return next Hash of the start of the next withdrawal event, if any.\n', '     */\n', '    function nextWithdrawal(bytes16 hash) constant returns(uint when, uint count, uint value, bytes16 next) {\n', '        if(hash == 0) {\n', '            hash = oldestHash;\n', '        }\n', '        next = hash;\n', '        when = entries[hash].expires;\n', '        while(next != 0 && entries[next].expires == when) {\n', '            count += 1;\n', '            value += entries[next].deposit;\n', '            next = entries[next].next;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if a deposit is held for the provided address.\n', '     * @param addr The address to check.\n', '     * @return expires The unix timestamp at which the deposit on this address\n', '     *         expires, or 0 if there is no deposit.\n', '     * @return deposit The amount deposited against this address.\n', '     */\n', '    function check(address addr) constant returns (uint expires, uint deposit) {\n', '        Entry storage entry = entries[bytes16(sha3(addr))];\n', '        expires = entry.expires;\n', '        deposit = entry.deposit;\n', '    }\n', '    \n', '    /**\n', '     * @dev Pays out a claim.\n', '     * @param addr The address to pay.\n', '     * @param amount The amount to send.\n', '     */\n', '    function disburse(address addr, uint amount) auditor_only {\n', '        paidOut += amount;\n', '        totalPaidOut += amount;\n', '        Claim(addr, amount);\n', '        if(!addr.send(amount))\n', '            throw;\n', '    }\n', '    \n', '    /**\n', '     * @dev Deletes the contract, if no deposits are held.\n', '     */\n', '    function destroy() owner_only {\n', '        if(depositCount > 0)\n', '            throw;\n', '        selfdestruct(msg.sender);\n', '    }\n', '}']