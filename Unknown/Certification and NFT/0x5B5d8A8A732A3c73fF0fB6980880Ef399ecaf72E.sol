['/*\n', 'This file is part of the PROOF Contract.\n', '\n', 'The PROOF Contract is free software: you can redistribute it and/or\n', 'modify it under the terms of the GNU lesser General Public License as published\n', 'by the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', '\n', 'The PROOF Contract is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n', 'GNU lesser General Public License for more details.\n', '\n', 'You should have received a copy of the GNU lesser General Public License\n', 'along with the PROOF Contract. If not, see <http://www.gnu.org/licenses/>.\n', '\n', '@author Ilya Svirin <i.svirin@nordavind.ru>\n', '*/\n', '\n', 'pragma solidity ^0.4.0;\n', '\n', 'contract owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function owned() payable {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner {\n', '        require(owner == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _owner) onlyOwner public {\n', '        require(_owner != 0);\n', '        newOwner = _owner;\n', '    }\n', '    \n', '    function confirmOwner() public {\n', '        require(newOwner == msg.sender);\n', '        owner = newOwner;\n', '        delete newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) constant returns (uint);\n', '    function transfer(address to, uint value);\n', '    function allowance(address owner, address spender) constant returns (uint);\n', '    function transferFrom(address from, address to, uint value);\n', '    function approve(address spender, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', 'contract ManualMigration is owned, ERC20 {\n', '    mapping (address => uint) internal balances;\n', '    address public migrationHost;\n', '\n', '    function ManualMigration(address _migrationHost) payable owned() {\n', '        migrationHost = _migrationHost;\n', '        //balances[this] = ERC20(migrationHost).balanceOf(migrationHost);\n', '    }\n', '\n', '    function migrateManual(address _tokensHolder) onlyOwner {\n', '        require(migrationHost != 0);\n', '        uint tokens = ERC20(migrationHost).balanceOf(_tokensHolder);\n', '        tokens = tokens * 125 / 100;\n', '        balances[_tokensHolder] = tokens;\n', '        totalSupply += tokens;\n', '        Transfer(migrationHost, _tokensHolder, tokens);\n', '    }\n', '    \n', '    function sealManualMigration() onlyOwner {\n', '        delete migrationHost;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Crowdsale implementation\n', ' */\n', 'contract Crowdsale is ManualMigration {\n', '    uint    public etherPrice;\n', '    address public crowdsaleOwner;\n', '    uint    public totalLimitUSD;\n', '    uint    public minimalSuccessUSD;\n', '    uint    public collectedUSD;\n', '\n', '    enum State { Disabled, PreICO, CompletePreICO, Crowdsale, Enabled, Migration }\n', '    event NewState(State state);\n', '    State   public state = State.Disabled;\n', '    uint    public crowdsaleStartTime;\n', '    uint    public crowdsaleFinishTime;\n', '\n', '    modifier enabledState {\n', '        require(state == State.Enabled);\n', '        _;\n', '    }\n', '\n', '    modifier enabledOrMigrationState {\n', '        require(state == State.Enabled || state == State.Migration);\n', '        _;\n', '    }\n', '\n', '    struct Investor {\n', '        uint amountTokens;\n', '        uint amountWei;\n', '    }\n', '    mapping (address => Investor) public investors;\n', '    mapping (uint => address)     public investorsIter;\n', '    uint                          public numberOfInvestors;\n', '\n', '    function Crowdsale(address _migrationHost)\n', '        payable ManualMigration(_migrationHost) {\n', '    }\n', '    \n', '    function () payable {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        require(now < crowdsaleFinishTime);\n', '        uint valueWei = msg.value;\n', '        uint valueUSD = valueWei * etherPrice / 1000000000000000000;\n', "        if (collectedUSD + valueUSD > totalLimitUSD) { // don't need so much ether\n", '            valueUSD = totalLimitUSD - collectedUSD;\n', '            valueWei = valueUSD * 1000000000000000000 / etherPrice;\n', '            require(msg.sender.call.gas(3000000).value(msg.value - valueWei)());\n', '            collectedUSD = totalLimitUSD; // to be sure!\n', '        } else {\n', '            collectedUSD += valueUSD;\n', '        }\n', '        mintTokens(msg.sender, valueUSD, valueWei);\n', '    }\n', '\n', '    function depositUSD(address _who, uint _valueUSD) public onlyOwner {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        require(now < crowdsaleFinishTime);\n', '        require(collectedUSD + _valueUSD <= totalLimitUSD);\n', '        collectedUSD += _valueUSD;\n', '        mintTokens(_who, _valueUSD, 0);\n', '    }\n', '\n', '    function mintTokens(address _who, uint _valueUSD, uint _valueWei) internal {\n', '        uint tokensPerUSD = 100;\n', '        if (state == State.PreICO) {\n', '            if (now < crowdsaleStartTime + 1 days && _valueUSD >= 50000) {\n', '                tokensPerUSD = 150;\n', '            } else {\n', '                tokensPerUSD = 125;\n', '            }\n', '        } else if (state == State.Crowdsale) {\n', '            if (now < crowdsaleStartTime + 1 days) {\n', '                tokensPerUSD = 115;\n', '            } else if (now < crowdsaleStartTime + 1 weeks) {\n', '                tokensPerUSD = 110;\n', '            }\n', '        }\n', '        uint tokens = tokensPerUSD * _valueUSD;\n', '        require(balances[_who] + tokens > balances[_who]); // overflow\n', '        require(tokens > 0);\n', '        Investor storage inv = investors[_who];\n', '        if (inv.amountTokens == 0) { // new investor\n', '            investorsIter[numberOfInvestors++] = _who;\n', '        }\n', '        inv.amountTokens += tokens;\n', '        inv.amountWei += _valueWei;\n', '        balances[_who] += tokens;\n', '        Transfer(this, _who, tokens);\n', '        totalSupply += tokens;\n', '    }\n', '    \n', '    function startTokensSale(\n', '            address _crowdsaleOwner,\n', '            uint    _crowdsaleDurationDays,\n', '            uint    _totalLimitUSD,\n', '            uint    _minimalSuccessUSD,\n', '            uint    _etherPrice) public onlyOwner {\n', '        require(state == State.Disabled || state == State.CompletePreICO);\n', '        crowdsaleStartTime = now;\n', '        crowdsaleOwner = _crowdsaleOwner;\n', '        etherPrice = _etherPrice;\n', '        delete numberOfInvestors;\n', '        delete collectedUSD;\n', '        crowdsaleFinishTime = now + _crowdsaleDurationDays * 1 days;\n', '        totalLimitUSD = _totalLimitUSD;\n', '        minimalSuccessUSD = _minimalSuccessUSD;\n', '        if (state == State.Disabled) {\n', '            state = State.PreICO;\n', '        } else {\n', '            state = State.Crowdsale;\n', '        }\n', '        NewState(state);\n', '    }\n', '    \n', '    function timeToFinishTokensSale() public constant returns(uint t) {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        if (now > crowdsaleFinishTime) {\n', '            t = 0;\n', '        } else {\n', '            t = crowdsaleFinishTime - now;\n', '        }\n', '    }\n', '    \n', '    function finishTokensSale(uint _investorsToProcess) public {\n', '        require(state == State.PreICO || state == State.Crowdsale);\n', '        require(now >= crowdsaleFinishTime || collectedUSD == totalLimitUSD ||\n', '            (collectedUSD >= minimalSuccessUSD && msg.sender == owner));\n', '        if (collectedUSD < minimalSuccessUSD) {\n', '            // Investors can get their ether calling withdrawBack() function\n', '            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\n', '                address addr = investorsIter[--numberOfInvestors];\n', '                Investor memory inv = investors[addr];\n', '                balances[addr] -= inv.amountTokens;\n', '                totalSupply -= inv.amountTokens;\n', '                Transfer(addr, this, inv.amountTokens);\n', '                --_investorsToProcess;\n', '                delete investorsIter[numberOfInvestors];\n', '            }\n', '            if (numberOfInvestors > 0) {\n', '                return;\n', '            }\n', '            if (state == State.PreICO) {\n', '                state = State.Disabled;\n', '            } else {\n', '                state = State.CompletePreICO;\n', '            }\n', '        } else {\n', '            while (_investorsToProcess > 0 && numberOfInvestors > 0) {\n', '                --numberOfInvestors;\n', '                --_investorsToProcess;\n', '                delete investors[investorsIter[numberOfInvestors]];\n', '                delete investorsIter[numberOfInvestors];\n', '            }\n', '            if (numberOfInvestors > 0) {\n', '                return;\n', '            }\n', '            if (state == State.PreICO) {\n', '                require(crowdsaleOwner.call.gas(3000000).value(this.balance)());\n', '                state = State.CompletePreICO;\n', '            } else {\n', '                require(crowdsaleOwner.call.gas(3000000).value(minimalSuccessUSD * 1000000000000000000 / etherPrice)());\n', '                // Create additional tokens for owner (30% of complete totalSupply)\n', '                uint tokens = 3 * totalSupply / 7;\n', '                balances[owner] = tokens;\n', '                totalSupply += tokens;\n', '                Transfer(this, owner, tokens);\n', '                state = State.Enabled;\n', '            }\n', '        }\n', '        NewState(state);\n', '    }\n', '    \n', '    // This function must be called by token holder in case of crowdsale failed\n', '    function withdrawBack() public {\n', '        require(state == State.Disabled || state == State.CompletePreICO);\n', '        uint value = investors[msg.sender].amountWei;\n', '        if (value > 0) {\n', '            delete investors[msg.sender];\n', '            require(msg.sender.call.gas(3000000).value(value)());\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Abstract interface for PROOF operating from registered external controllers\n', ' */\n', 'contract Fund {\n', '    function transferFund(address _to, uint _value);\n', '}\n', '\n', '/**\n', ' * @title Token PROOF implementation\n', ' */\n', 'contract Token is Crowdsale, Fund {\n', '    \n', "    string  public standard    = 'Token 0.1';\n", "    string  public name        = 'PROOF';\n", '    string  public symbol      = "PF";\n', '    uint8   public decimals    = 0;\n', '\n', '    mapping (address => mapping (address => uint)) public allowed;\n', '    mapping (address => bool) public externalControllers;\n', '\n', '    modifier onlyTokenHolders {\n', '        require(balances[msg.sender] != 0);\n', '        _;\n', '    }\n', '\n', '    // Fix for the ERC20 short address attack\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    modifier externalController {\n', '        require(externalControllers[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function Token(address _migrationHost)\n', '        payable Crowdsale(_migrationHost) {}\n', '\n', '    function balanceOf(address who) constant returns (uint) {\n', '        return balances[who];\n', '    }\n', '\n', '    function transfer(address _to, uint _value)\n', '        public enabledState onlyPayloadSize(2 * 32) {\n', '        require(balances[msg.sender] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]); // overflow\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint _value)\n', '        public enabledState onlyPayloadSize(3 * 32) {\n', '        require(balances[_from] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]); // overflow\n', '        require(allowed[_from][msg.sender] >= _value);\n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public enabledState {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant enabledState\n', '        returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function transferFund(address _to, uint _value) public externalController {\n', '        require(balances[this] >= _value);\n', '        require(balances[_to] + _value >= balances[_to]); // overflow\n', '        balances[this] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(this, _to, _value);\n', '    }\n', '}\n', '\n', 'contract ProofVote is Token {\n', '\n', '    function ProofVote(address _migrationHost)\n', '        payable Token(_migrationHost) {}\n', '\n', '    event VotingStarted(uint weiReqFund, VoteReason voteReason);\n', '    event Voted(address indexed voter, bool inSupport);\n', '    event VotingFinished(bool inSupport);\n', '\n', '    enum Vote { NoVote, VoteYea, VoteNay }\n', '    enum VoteReason { Nothing, ReqFund, Migration, UpdateContract }\n', '\n', '    uint public weiReqFund;\n', '    uint public votingDeadline;\n', '    uint public numberOfVotes;\n', '    uint public yea;\n', '    uint public nay;\n', '    VoteReason  voteReason;\n', '    mapping (address => Vote) public votes;\n', '    mapping (uint => address) public votesIter;\n', '\n', '    address public migrationAgent;\n', '    address public migrationAgentCandidate;\n', '    address public externalControllerCandidate;\n', '\n', '    function startVoting(uint _weiReqFund) public enabledOrMigrationState onlyOwner {\n', '        require(_weiReqFund > 0);\n', '        internalStartVoting(_weiReqFund, VoteReason.ReqFund, 7);\n', '    }\n', '\n', '    function internalStartVoting(uint _weiReqFund, VoteReason _voteReason, uint _votingDurationDays) internal {\n', '        require(voteReason == VoteReason.Nothing && _weiReqFund <= this.balance);\n', '        weiReqFund = _weiReqFund;\n', '        votingDeadline = now + _votingDurationDays * 1 days;\n', '        voteReason = _voteReason;\n', '        delete yea;\n', '        delete nay;\n', '        VotingStarted(_weiReqFund, _voteReason);\n', '    }\n', '    \n', '    function votingInfo() public constant\n', '        returns(uint _weiReqFund, uint _timeToFinish, VoteReason _voteReason) {\n', '        _weiReqFund = weiReqFund;\n', '        _voteReason = voteReason;\n', '        if (votingDeadline <= now) {\n', '            _timeToFinish = 0;\n', '        } else {\n', '            _timeToFinish = votingDeadline - now;\n', '        }\n', '    }\n', '\n', '    function vote(bool _inSupport) public onlyTokenHolders returns (uint voteId) {\n', '        require(voteReason != VoteReason.Nothing);\n', '        require(votes[msg.sender] == Vote.NoVote);\n', '        require(votingDeadline > now);\n', '        voteId = numberOfVotes++;\n', '        votesIter[voteId] = msg.sender;\n', '        if (_inSupport) {\n', '            votes[msg.sender] = Vote.VoteYea;\n', '        } else {\n', '            votes[msg.sender] = Vote.VoteNay;\n', '        }\n', '        Voted(msg.sender, _inSupport);\n', '        return voteId;\n', '    }\n', '\n', '    function finishVoting(uint _votesToProcess) public returns (bool _inSupport) {\n', '        require(voteReason != VoteReason.Nothing);\n', '        require(now >= votingDeadline);\n', '\n', '        while (_votesToProcess > 0 && numberOfVotes > 0) {\n', '            address voter = votesIter[--numberOfVotes];\n', '            Vote v = votes[voter];\n', '            uint voteWeight = balances[voter];\n', '            if (v == Vote.VoteYea) {\n', '                yea += voteWeight;\n', '            } else if (v == Vote.VoteNay) {\n', '                nay += voteWeight;\n', '            }\n', '            delete votes[voter];\n', '            delete votesIter[numberOfVotes];\n', '            --_votesToProcess;\n', '        }\n', '        if (numberOfVotes > 0) {\n', '            _inSupport = false;\n', '            return;\n', '        }\n', '\n', '        _inSupport = (yea > nay);\n', '        uint weiForSend = weiReqFund;\n', '        delete weiReqFund;\n', '        delete votingDeadline;\n', '        delete numberOfVotes;\n', '\n', '        if (_inSupport) {\n', '            if (voteReason == VoteReason.ReqFund) {\n', '                require(owner.call.gas(3000000).value(weiForSend)());\n', '            } else if (voteReason == VoteReason.Migration) {\n', '                migrationAgent = migrationAgentCandidate;\n', '                require(migrationAgent.call.gas(3000000).value(this.balance)());\n', '                delete migrationAgentCandidate;\n', '                state = State.Migration;\n', '            } else if (voteReason == VoteReason.UpdateContract) {\n', '                externalControllers[externalControllerCandidate] = true;\n', '                delete externalControllerCandidate;\n', '            }\n', '        }\n', '\n', '        delete voteReason;\n', '        VotingFinished(_inSupport);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Migration agent intefrace for possibility of moving tokens\n', ' *        to another contract\n', ' */\n', 'contract MigrationAgent {\n', '    function migrateFrom(address _from, uint _value);\n', '}\n', '\n', '/**\n', ' * @title Migration functionality for possibility of moving tokens\n', ' *        to another contract\n', ' */\n', 'contract TokenMigration is ProofVote {\n', '    \n', '    uint public totalMigrated;\n', '\n', '    event Migrate(address indexed from, address indexed to, uint value);\n', '\n', '    function TokenMigration(address _migrationHost) payable ProofVote(_migrationHost) {}\n', '\n', '    // Migrate _value of tokens to the new token contract\n', '    function migrate() external {\n', '        require(state == State.Migration);\n', '        uint value = balances[msg.sender];\n', '        balances[msg.sender] -= value;\n', '        Transfer(msg.sender, this, value);\n', '        totalSupply -= value;\n', '        totalMigrated += value;\n', '        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\n', '        Migrate(msg.sender, migrationAgent, value);\n', '    }\n', '\n', '    function setMigrationAgent(address _agent) external onlyOwner {\n', '        require(migrationAgent == 0 && _agent != 0);\n', '        migrationAgentCandidate = _agent;\n', '        internalStartVoting(0, VoteReason.Migration, 2);\n', '    }\n', '}\n', '\n', 'contract ProofFund is TokenMigration {\n', '\n', '    function ProofFund(address _migrationHost)\n', '        payable TokenMigration(_migrationHost) {}\n', '\n', '    function addExternalController(address _externalControllerCandidate) public onlyOwner {\n', '        require(_externalControllerCandidate != 0);\n', '        externalControllerCandidate = _externalControllerCandidate;\n', '        internalStartVoting(0, VoteReason.UpdateContract, 2);\n', '    }\n', '\n', '    function removeExternalController(address _externalController) public onlyOwner {\n', '        delete externalControllers[_externalController];\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Proof interface\n', ' */\n', 'contract ProofAbstract {\n', '    function swypeCode(address _who) returns (uint16 _swype);\n', '    function setHash(address _who, uint16 _swype, bytes32 _hash);\n', '}\n', '\n', 'contract Proof is ProofFund {\n', '\n', '    uint    public priceInTokens;\n', '    uint    public teamFee;\n', '    address public proofImpl;\n', '\n', '    function Proof(address _migrationHost)\n', '        payable ProofFund(_migrationHost) {}\n', '\n', '    function setPrice(uint _priceInTokens) public onlyOwner {\n', '        require(_priceInTokens >= 2);\n', '        teamFee = _priceInTokens / 10;\n', '        if (teamFee == 0) {\n', '            teamFee = 1;\n', '        }\n', '        priceInTokens = _priceInTokens - teamFee;\n', '    }\n', '\n', '    function setProofImpl(address _proofImpl) public onlyOwner {\n', '        proofImpl = _proofImpl;\n', '    }\n', '\n', '    function swypeCode() public returns (uint16 _swype) {\n', '        require(proofImpl != 0);\n', '        _swype = ProofAbstract(proofImpl).swypeCode(msg.sender);\n', '    }\n', '    \n', '    function setHash(uint16 _swype, bytes32 _hash) public {\n', '        require(proofImpl != 0);\n', '        transfer(owner, teamFee);\n', '        transfer(this, priceInTokens);\n', '        ProofAbstract(proofImpl).setHash(msg.sender, _swype, _hash);\n', '    }\n', '}']