['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    Unpause();\n', '    return true;\n', '  }\n', '}\n', '\n', 'contract IMintableToken {\n', '    function mint(address _to, uint256 _amount) returns (bool);\n', '    function finishMinting() returns (bool);\n', '}\n', '\n', 'contract PricingStrategy {\n', '\n', '    using SafeMath for uint;\n', '\n', '    uint public rate0;\n', '    uint public rate1;\n', '    uint public rate2;\n', '\n', '    uint public threshold1;\n', '    uint public threshold2;\n', '\n', '    uint public minimumWeiAmount;\n', '\n', '    function PricingStrategy(\n', '        uint _rate0,\n', '        uint _rate1,\n', '        uint _rate2,\n', '        uint _minimumWeiAmount,\n', '        uint _threshold1,\n', '        uint _threshold2\n', '    ) {\n', '        require(_rate0 > 0);\n', '        require(_rate1 > 0);\n', '        require(_rate2 > 0);\n', '        require(_minimumWeiAmount > 0);\n', '        require(_threshold1 > 0);\n', '        require(_threshold2 > 0);\n', '\n', '        rate0 = _rate0;\n', '        rate1 = _rate1;\n', '        rate2 = _rate2;\n', '        minimumWeiAmount = _minimumWeiAmount;\n', '        threshold1 = _threshold1;\n', '        threshold2 = _threshold2;\n', '    }\n', '\n', '    /** Interface declaration. */\n', '    function isPricingStrategy() public constant returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /** Calculate the current price for buy in amount. */\n', '    function calculateTokenAmount(uint weiAmount) public constant returns (uint tokenAmount) {\n', '        uint bonusRate = 0;\n', '\n', '        if (weiAmount >= minimumWeiAmount) {\n', '            bonusRate = rate0;\n', '        }\n', '\n', '        if (weiAmount >= threshold1) {\n', '            bonusRate = rate1;\n', '        }\n', '\n', '        if (weiAmount >= threshold2) {\n', '            bonusRate = rate2;\n', '        }\n', '\n', '        return weiAmount.mul(bonusRate);\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract Reservation is Pausable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    /* Max investment count when we are still allowed to change the multisig address */\n', '    uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 500;\n', '\n', '    /* The token we are selling */\n', '    IMintableToken public token;\n', '\n', '    /* How we are going to price our offering */\n', '    PricingStrategy public pricingStrategy;\n', '\n', '    /* tokens will be transfered from this address */\n', '    address public multisigWallet;\n', '\n', '    /* if the funding goal is not reached, investors may withdraw their funds */\n', '    uint public minimumFundingGoal;\n', '\n', '    /* the UNIX timestamp start date of the reservation */\n', '    uint public startsAt;\n', '\n', '    /* the UNIX timestamp end date of the reservation */\n', '    uint public endsAt;\n', '\n', '    /* Maximum amount of tokens this reservation can sell. */\n', '    uint public tokensHardCap;\n', '\n', '    /* the number of tokens already sold through this contract*/\n', '    uint public tokensSold = 0;\n', '\n', '    /* How many wei of funding we have raised */\n', '    uint public weiRaised = 0;\n', '\n', '    /* How many distinct addresses have invested */\n', '    uint public investorCount = 0;\n', '\n', '    /* How much wei we have returned back to the contract after a failed crowdfund. */\n', '    uint public loadedRefund = 0;\n', '\n', '    /* How much wei we have given back to investors.*/\n', '    uint public weiRefunded = 0;\n', '\n', '    /** How much ETH each address has invested to this reservation */\n', '    mapping (address => uint256) public investedAmountOf;\n', '\n', '    /** How much tokens this reservation has credited for each investor address */\n', '    mapping (address => uint256) public tokenAmountOf;\n', '\n', '    /** Addresses that are allowed to invest even before ICO offical opens. Only for testing purpuses. */\n', '    mapping (address => bool) public earlyParticipantWhitelist;\n', '\n', '    /** State machine\n', '    *\n', '    * - Preparing: All contract initialization calls and variables have not been set yet\n', '    * - Prefunding: We have not passed start time yet\n', '    * - Funding: Active reservation\n', '    * - Success: Minimum funding goal reached\n', '    * - Failure: Minimum funding goal not reached before ending time\n', '    * - Refunding: Refunds are loaded on the contract for reclaim.\n', '    */\n', '    enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Refunding}\n', '\n', '    // A new investment was made\n', '    event Invested(address investor, uint weiAmount, uint tokenAmount);\n', '\n', '    // Refund was processed for a contributor\n', '    event Refund(address investor, uint weiAmount);\n', '\n', '    // Address early participation whitelist status changed\n', '    event Whitelisted(address addr, bool status);\n', '\n', '    // Reservation end time has been changed\n', '    event EndsAtChanged(uint endsAt);\n', '\n', '    function Reservation(\n', '        address _token, \n', '        address _pricingStrategy, \n', '        address _multisigWallet, \n', '        uint _start, \n', '        uint _end, \n', '        uint _tokensHardCap,\n', '        uint _minimumFundingGoal\n', '    ) {\n', '        require(_token != 0);\n', '        require(_pricingStrategy != 0);\n', '        require(_multisigWallet != 0);\n', '        require(_start != 0);\n', '        require(_end != 0);\n', '        require(_start < _end);\n', '        require(_tokensHardCap != 0);\n', '\n', '        token = IMintableToken(_token);\n', '        setPricingStrategy(_pricingStrategy);\n', '        multisigWallet = _multisigWallet;\n', '        startsAt = _start;\n', '        endsAt = _end;\n', '        tokensHardCap = _tokensHardCap;\n', '        minimumFundingGoal = _minimumFundingGoal;\n', '    }\n', '\n', '    /**\n', '    * Buy tokens\n', '    */\n', '    function() payable {\n', '        invest(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * Make an investment.\n', '    *\n', '    * Reservation must be running for one to invest.\n', '    * We must have not pressed the emergency brake.\n', '    *\n', '    * @param receiver The Ethereum address who receives the tokens\n', '    */\n', '    function invest(address receiver) whenNotPaused payable {\n', '\n', '        // Determine if it&#39;s a good time to accept investment from this participant\n', '        if (getState() == State.PreFunding) {\n', '            // Are we whitelisted for early deposit\n', '            require(earlyParticipantWhitelist[receiver]);\n', '        } else {\n', '            require(getState() == State.Funding);\n', '        }\n', '\n', '        uint weiAmount = msg.value;\n', '\n', '        // Account reservation sales separately, so that they do not count against pricing tranches\n', '        uint tokenAmount = pricingStrategy.calculateTokenAmount(weiAmount);\n', '\n', '        // Dust transaction\n', '        require(tokenAmount > 0);\n', '\n', '        if (investedAmountOf[receiver] == 0) {\n', '            // A new investor\n', '            investorCount++;\n', '        }\n', '\n', '        // Update investor\n', '        investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n', '        tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n', '\n', '        // Update totals\n', '        weiRaised = weiRaised.add(weiAmount);\n', '        tokensSold = tokensSold.add(tokenAmount);\n', '\n', '        // Check that we did not bust the cap\n', '        require(!isBreakingCap(tokensSold));\n', '\n', '        token.mint(receiver, tokenAmount);\n', '\n', '        // Pocket the money\n', '        multisigWallet.transfer(weiAmount);\n', '\n', '        // Tell us invest was success\n', '        Invested(receiver, weiAmount, tokenAmount);\n', '    }\n', '\n', '    /**\n', '    * Allow addresses to do early participation.\n', '    *\n', '    */\n', '    function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\n', '        earlyParticipantWhitelist[addr] = status;\n', '        Whitelisted(addr, status);\n', '    }\n', '\n', '    /**\n', '    * Allow reservation owner to close early or extend the reservation.\n', '    *\n', '    * This is useful e.g. for a manual soft cap implementation:\n', '    * - after X amount is reached determine manual closing\n', '    *\n', '    * This may put the reservation to an invalid state,\n', '    * but we trust owners know what they are doing.\n', '    *\n', '    */\n', '    function setEndsAt(uint time) onlyOwner {\n', '\n', '        require(now <= time);\n', '\n', '        endsAt = time;\n', '        EndsAtChanged(endsAt);\n', '    }\n', '\n', '    /**\n', '    * Allow to (re)set pricing strategy.\n', '    *\n', '    * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\n', '    */\n', '    function setPricingStrategy(address _pricingStrategy) onlyOwner {\n', '        pricingStrategy = PricingStrategy(_pricingStrategy);\n', '\n', '        // Don&#39;t allow setting bad agent\n', '        require(pricingStrategy.isPricingStrategy());\n', '    }\n', '\n', '    /**\n', '    * Allow to change the team multisig address in the case of emergency.\n', '    *\n', '    * This allows to save a deployed reservation wallet in the case the reservation has not yet begun\n', '    * (we have done only few test transactions). After the reservation is going\n', '    * then multisig address stays locked for the safety reasons.\n', '    */\n', '    function setMultisig(address addr) public onlyOwner {\n', '\n', '        require(investorCount <= MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE);\n', '\n', '        multisigWallet = addr;\n', '    }\n', '\n', '    /**\n', '    * Allow load refunds back on the contract for the refunding.\n', '    *\n', '    * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached..\n', '    */\n', '    function loadRefund() public payable inState(State.Failure) {\n', '        require(msg.value > 0);\n', '\n', '        loadedRefund = loadedRefund.add(msg.value);\n', '    }\n', '\n', '    /**\n', '    * Investors can claim refund.\n', '    *\n', '    * Note that any refunds from proxy buyers should be handled separately,\n', '    * and not through this contract.\n', '    */\n', '    function refund() public inState(State.Refunding) {\n', '        uint256 weiValue = investedAmountOf[msg.sender];\n', '        require(weiValue > 0);\n', '\n', '        investedAmountOf[msg.sender] = 0;\n', '        weiRefunded = weiRefunded.add(weiValue);\n', '        Refund(msg.sender, weiValue);\n', '        \n', '        msg.sender.transfer(weiValue);\n', '    }\n', '\n', '    /**\n', '    * Crowdfund state machine management.\n', '    *\n', '    * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale.\n', '    */\n', '    function getState() public constant returns (State) {\n', '        if (address(pricingStrategy) == 0)\n', '            return State.Preparing;\n', '        else if (block.timestamp < startsAt)\n', '            return State.PreFunding;\n', '        else if (block.timestamp <= endsAt && !isReservationFull())\n', '            return State.Funding;\n', '        else if (isMinimumGoalReached())\n', '            return State.Success;\n', '        else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised)\n', '            return State.Refunding;\n', '        else\n', '            return State.Failure;\n', '    }\n', '\n', '    /**\n', '    * @return true if the reservation has raised enough money to be a successful.\n', '    */\n', '    function isMinimumGoalReached() public constant returns (bool reached) {\n', '        return weiRaised >= minimumFundingGoal;\n', '    }\n', '\n', '    /**\n', '    * Called from invest() to confirm if the curret investment does not break our cap rule.\n', '    */\n', '    function isBreakingCap(uint tokensSoldTotal) constant returns (bool) {\n', '        return tokensSoldTotal > tokensHardCap;\n', '    }\n', '\n', '    function isReservationFull() public constant returns (bool) {\n', '        return tokensSold >= tokensHardCap;\n', '    }\n', '\n', '    //\n', '    // Modifiers\n', '    //\n', '\n', '    /** Modified allowing execution only if the reservation is currently running.  */\n', '    modifier inState(State state) {\n', '        require(getState() == state);\n', '        _;\n', '    }\n', '}']