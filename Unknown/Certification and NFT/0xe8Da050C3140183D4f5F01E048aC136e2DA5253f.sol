['pragma solidity ^0.4.15;\n', '\n', 'contract Addresses {\n', '\n', '    //2%\n', '    address public bounty;\n', '    \n', '    //5%\n', '    address public successFee;\n', '\n', '    //93%\n', '    address public addr1;\n', '\n', '    //93%\n', '    address public addr2;\n', '\n', '    //93%\n', '    address public addr3;\n', '\n', '    //93%\n', '    address public addr4;\n', '\n', '\n', '  function Addresses() {\n', '\n', '      //2%       //ORIGINAL\n', '      bounty = 0x0064952457905eBFB9c0292200A74B1d7414F081;\n', '                 //TEST\n', '   //   bounty = 0x1626079328312cdb1e731a934a547c6d81b3ee2c;\n', '      \n', '      //5%       //ORIGINAL\n', '      successFee = 0xdA39e0Ce2adf93129D04F53176c7Bfaaae8B051a;\n', '                 //TEST\n', '    //  successFee = 0xf280dacf47f33f442cf5fa9d20abaef4b6e9ca12;\n', '\n', '    //93%       //ORIGINAL\n', '      addr1 = 0x300b848558DC06E32658fFB8D59C859D0812CA6C;\n', '\n', '      //93%       //ORIGINAL\n', '      addr2 = 0x4388AD192b0DaaDBBaa86Be0AE7499b8D44C5f75;\n', '\n', '      //93%       //ORIGINAL\n', '      addr3 = 0x40C9E2D0807289b4c24B0e2c34277BDd7FaCfd87;\n', '\n', '      //93%       //ORIGINAL\n', '      addr4 = 0x4E3B219684b9570D0d81Cc13E5c0aAcafe2323B1;\n', '      \n', '\n', '     /* //93%       //TEST\n', '      addr1 = 0x1626079328312cdb1e731a934a547c6d81b3ee2c;\n', '\n', '      //93%       //TEST\n', '      addr2 = 0x1626079328312cdb1e731a934a547c6d81b3ee2c;\n', '\n', '      //93%       //TEST\n', '      addr3 = 0x1626079328312cdb1e731a934a547c6d81b3ee2c;\n', '\n', '      //93%       //TEST\n', '      addr4 = 0x1626079328312cdb1e731a934a547c6d81b3ee2c;*/\n', '  }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '    \n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', ' \n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', ' \n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', ' \n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a % b;\n', '    return c;\n', '  }\n', '  \n', '}\n', '\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  function approve(address _owner, address _spender, uint256 _value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Migrations {\n', '  address public owner;\n', '  uint public last_completed_migration;\n', '\n', '  modifier restricted() {\n', '    if (msg.sender == owner) _;\n', '  }\n', '\n', '  function Migrations() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function setCompleted(uint completed) restricted {\n', '    last_completed_migration = completed;\n', '  }\n', '\n', '  function upgrade(address new_address) restricted {\n', '    Migrations upgraded = Migrations(new_address);\n', '    upgraded.setCompleted(last_completed_migration);\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '    \n', '  address public owner;\n', ' \n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', ' \n', '}\n', '\n', 'contract BasicToken is ERC20Basic {\n', '    \n', '  using SafeMath for uint256;\n', ' \n', '  mapping(address => uint256) balances;\n', '\n', '  //18.10.2017 23:59 UTC\n', '  uint256 ico_finish = 1508284740;\n', '\n', '  modifier isFreeze() {\n', '    if(now < ico_finish) {\n', '      revert();\n', '    }\n', '    _;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) isFreeze returns (bool) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', ' \n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', ' \n', '}\n', '\n', 'contract StandardToken is ERC20, BasicToken {\n', ' \n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '  //14.10.2017 23:59 UTC\n', '  uint256 ico_finish = 1508025540;\n', '\n', '  modifier isFreeze() {\n', '    if(now < ico_finish) {\n', '      revert();\n', '    }\n', '    _;\n', '  }\n', ' \n', '  function transferFrom(address _from, address _to, uint256 _value) isFreeze returns (bool) {\n', '    var _allowance = allowed[_from][msg.sender];\n', ' \n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', ' \n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', ' \n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function approve(address _owner, address _spender, uint256 _value) returns (bool) {\n', ' \n', '    allowed[_owner][_spender] = _value;\n', '    Approval(_owner, _spender, _value);\n', '    return true;\n', '  }\n', ' \n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', ' \n', '}\n', '\n', 'contract MintableToken is StandardToken, Ownable {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  bool mintingFinished = false;\n', '\n', '  uint256 mintedTokens = 0;\n', '\n', '  event Mint(address indexed to, uint256 amount);\n', '\n', '  event MintFinished();\n', '\n', '  event ShowInfo(uint256 _info, string _message);\n', '\n', '  function setTotalSupply(uint256 _amount) public onlyOwner returns(uint256) {\n', '    totalSupply = _amount;\n', '    return totalSupply;\n', '  }\n', '\n', '  function getTotalTokenCount() public constant returns(uint256) {\n', '    return totalSupply;\n', '  }\n', '\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '\n', '  function finishMinting() public onlyOwner {\n', '    mintingFinished = true;\n', '  }\n', '  \n', '  function mint(address _address, uint256 _tokens) canMint onlyOwner public {\n', '\n', '    require(mintedTokens < totalSupply);\n', '\n', '    Mint(_address, _tokens);\n', '\n', '    balances[_address] = balances[_address].add(_tokens);\n', '\n', '    mintedTokens = mintedTokens.add(_tokens);\n', '  }\n', '\n', '  function burnTokens(address _address) onlyOwner public {\n', '    balances[_address] = 0;\n', '    totalSupply = 0;\n', '    mintedTokens = 0;\n', '  }\n', '\n', '  function burnFinish() onlyOwner public {\n', '    totalSupply = mintedTokens;\n', '  }\n', '\n', '}\n', '\n', 'contract SingleTokenCoin is MintableToken {\n', '    \n', '    string public constant name = "Start mining";\n', '    \n', '    string public constant symbol = "STM";\n', '    \n', '    uint32 public constant decimals = 2;\n', '    \n', '}\n', '\n', 'contract WrapperOraclize {\n', '    function update(string datasource, string arg) payable;\n', '    function update(uint timestamp, string datasource, string arg) payable;\n', '    function getWrapperBalance() constant returns(uint256);\n', '    function getWrapperData() constant returns(bytes32);\n', '    function getPrice(string datasource) constant returns(uint256);\n', '    function() external payable;\n', '}\n', '\n', 'contract Crowdsale is Ownable {\n', '\n', '  string public ETHUSD;\n', '\n', '  event ShowPrice(string price);\n', '\n', '    using SafeMath for uint256;\n', '\n', '    SingleTokenCoin public token = new SingleTokenCoin();\n', '\n', '    Addresses private addresses = new Addresses();\n', '\n', '    WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F);\n', '\n', '    uint256 private ico_start;\n', '    uint256 private ico_finish;\n', '\n', '    uint256 private rate;\n', '\n', '    uint256 private decimals;\n', '\n', '    uint256 private tax;\n', '\n', '    //Time-based Bonus Program\n', '    uint256 private firstBonusPhase;\n', '    uint256 private firstExtraBonus;\n', '\n', '    uint256 private secondBonusPhase;\n', '    uint256 private secondExtraBonus;\n', '\n', '    uint256 private thirdBonusPhase;\n', '    uint256 private thirdExtraBonus;\n', '\n', '    uint256 private fourBonusPhase;\n', '    uint256 private fourExtraBonus;\n', '\n', '    //Withdrow Phases\n', '    bool private firstWithdrowPhase;\n', '    bool private secondWithdrowPhase;\n', '    bool private thirdWithdrowPhase;\n', '    bool private fourWithdrowPhase;\n', '\n', '    uint256 private firstWithdrowAmount;\n', '    uint256 private secondWithdrowAmount;\n', '    uint256 private thirdWithdrowAmount;\n', '    uint256 private fourWithdrowAmount;\n', '\n', '    uint256 private totalETH;\n', '\n', '    uint256 private totalAmount;\n', '\n', '    bool private initialize = false;\n', '    \n', '    bool public mintingFinished = false;\n', '\n', '    //Storage for ICO Buyers ETH\n', '    mapping(address => uint256) private ico_buyers_eth;\n', '\n', '    //Storage for ICO Buyers Token\n', '    mapping(address => uint256) private ico_buyers_token;\n', '\n', '    address[] private investors;\n', '\n', '    mapping(address => bytes32) private privilegedWallets;\n', '    mapping(address => uint256) private manualAddresses;\n', '\n', '    address[] private manualAddressesCount;\n', '\n', '    address[] private privilegedWalletsCount;\n', '\n', '    bytes32 private g = "granted";\n', '\n', '    bytes32 private r = "revorked";\n', '\n', '    uint256 private soldTokens;\n', '    uint256 private mincup;\n', '\n', '    uint256 private minPrice;\n', '\n', '    event ShowInfo(uint256 _info);\n', '    event ShowInfoStr(string _info);\n', '    event ShowInfoBool(bool _info);\n', '\n', '    function Crowdsale() {\n', '\n', '      //set calculate rate from USD\n', '      rate = 3546099290780141; //0.0003 ETH //temp\n', '\n', '      decimals = 35460992907801; // 0.0000003 ETH // 2 decimals\n', '\n', '      tax = 36000000000000000; //tax && minimum price ~10$\n', '\n', '      //minPrice = decimals + tax; // ~10$\n', '\n', '      //18.09.2017 15:00 UTC (1505746800)\n', '      ico_start = 1505746800;\n', '\n', '      //17.10.2017 23:59 UTC (1508284740)\n', '      ico_finish = 1508284740;\n', '\n', '      totalAmount = 1020000000;\n', '\n', '      // 500 000 STM with 2 decimals\n', '      mincup = 50000000;\n', '      \n', '      mintingFinished = false;\n', '\n', '      setTotalSupply();\n', '\n', '      //Time-Based Bonus Phase\n', '      firstBonusPhase = ico_start.add(24 hours);\n', '      firstExtraBonus = 25;\n', '\n', '      secondBonusPhase = ico_start.add(168 hours);\n', '      secondExtraBonus = 15;\n', '\n', '      thirdBonusPhase = ico_start.add(336 hours);\n', '      thirdExtraBonus = 10;\n', '\n', '      fourBonusPhase = ico_start.add(480 hours);\n', '      fourExtraBonus = 5;\n', '\n', '      //Withdrow Phases\n', '      firstWithdrowPhase = false;\n', '      secondWithdrowPhase = false;\n', '      thirdWithdrowPhase = false;\n', '      fourWithdrowPhase = false;\n', '\n', '      firstWithdrowAmount = 50000000;\n', '      secondWithdrowAmount = 200000000;\n', '      thirdWithdrowAmount = 500000000;\n', '      fourWithdrowAmount = 1020000000;\n', '\n', '      totalETH = 0;\n', '\n', '      soldTokens = 0;\n', '\n', '      privilegedWalletsCount.push(msg.sender);\n', '      privilegedWallets[msg.sender] = g;\n', '\n', '    }\n', '\n', '      modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '      }\n', '\n', '    function() external payable {\n', '      mint();\n', '    }\n', '\n', '  function bytesToUInt(bytes32 v) constant returns (uint ret) {\n', '        if (v == 0x0) {\n', '            revert();\n', '        }\n', '\n', '        uint digit;\n', '\n', '        for (uint i = 0; i < 32; i++) {\n', '            digit = uint((uint(v) / (2 ** (8 * (31 - i)))) & 0xff);\n', '            if (digit == 0 || digit == 46) {\n', '                break;\n', '            }\n', '            else if (digit < 48 || digit > 57) {\n', '                revert();\n', '            }\n', '            ret *= 10;\n', '            ret += (digit - 48);\n', '        }\n', '        return ret;\n', '    }\n', '\n', '  function calculateRate() public payable returns(uint256) {\n', '    bytes32 result = getWrapperData();\n', '    uint256 usd = bytesToUInt(result);\n', '\n', '    uint256 price = 1 ether / usd; //price for 1 STM\n', '\n', '    return price;\n', '  }\n', '\n', '    function calculateWithdrow() private {\n', '      if (!firstWithdrowPhase && soldTokens >= firstWithdrowAmount && soldTokens < secondWithdrowAmount) {\n', '        sendToOwners(this.balance);\n', '      } else {\n', '        if (!secondWithdrowPhase && soldTokens >= secondWithdrowAmount && soldTokens < thirdWithdrowAmount) {\n', '          sendToOwners(this.balance);\n', '        } else {\n', '          if (!thirdWithdrowPhase && soldTokens >= thirdWithdrowAmount && soldTokens < fourWithdrowAmount) {\n', '            sendToOwners(this.balance);\n', '          } else {\n', '            if (!fourWithdrowPhase && soldTokens >= fourWithdrowAmount) {\n', '              sendToOwners(this.balance);\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '\n', '    modifier isInitialize() {\n', '      require(!initialize);\n', '      _;\n', '    }\n', '\n', '    function setTotalSupply() private isInitialize onlyOwner returns(uint256) {\n', '      initialize = true;\n', '      return token.setTotalSupply(totalAmount);\n', '    }\n', '\n', '    function sendToAddress(address _address, uint256 _tokens) canMint public {\n', '\n', '      if (grantedWallets(msg.sender) == false) {\n', '        revert();      \n', '      }\n', '\n', '      ShowInfo(_tokens);\n', '\n', '      uint256 currentTokens = _tokens;\n', '\n', '      uint256 timeBonus = calculateBonusForHours(currentTokens);\n', '\n', '      uint256 allTokens = currentTokens.add(timeBonus);   \n', '\n', '      token.approve(_address, this, allTokens);      \n', '\n', '      saveInfoAboutInvestors(_address, 0, allTokens, true);         \n', '\n', '      token.mint(_address, allTokens);\n', '\n', '      soldTokens = soldTokens + allTokens;\n', '      calculateWithdrow();\n', '    }\n', '\n', '    modifier isRefund() {\n', '      if (msg.value < tax) {\n', '        refund(msg.value);\n', '        revert();\n', '      }\n', '      _;\n', '    }\n', '\n', '    function grantedWallets(address _address) private returns(bool) {\n', '      if (privilegedWallets[_address] == g) {\n', '        return true;\n', '      }\n', '      return false;\n', '    }\n', '\n', '    modifier isICOFinished() {\n', '      if (now > ico_finish) {\n', '        finishMinting();\n', '        refund(msg.value);\n', '        revert();\n', '      }\n', '      _;\n', '    }\n', '\n', '    function getTokens() public constant returns(uint256) {\n', '      token.getTotalTokenCount();\n', '    }\n', '\n', '    function setPrivelegedWallet(address _address) public onlyOwner returns(bool) {\n', '      if (privilegedWalletsCount.length == 2) {\n', '        revert();\n', '      }\n', '\n', '      if (privilegedWallets[_address] != g && privilegedWallets[_address] != r) {\n', '        privilegedWalletsCount.push(_address);\n', '      }\n', '\n', '      privilegedWallets[_address] = g;\n', '\n', '      return true;\n', '    }\n', '\n', '    function setTransferOwnership(address _address) public onlyOwner {\n', '\n', '      removePrivelegedWallet(msg.sender);\n', '      setPrivelegedWallet(_address);\n', '\n', '      transferOwnership(_address);\n', '    }\n', '\n', '    function removePrivelegedWallet(address _address) public onlyOwner {\n', '      if (privilegedWallets[_address] == g) {\n', '        privilegedWallets[_address] = r;\n', '        delete privilegedWalletsCount[0];\n', '      } else {\n', '        revert();\n', '      }\n', '    }\n', '\n', '    //only for demonstrate Test Version\n', '    function setICODate(uint256 _time) public onlyOwner {\n', '      ico_start = _time;\n', '      ShowInfo(_time);\n', '    }\n', '\n', '    function getICODate() public constant returns(uint256) {\n', '      return ico_start;\n', '    }\n', '\n', '    function mint() public isRefund canMint isICOFinished payable {\n', '\n', '      rate = calculateRate();\n', '\n', '      decimals = rate / 100; //price for 0.01 STM\n', '\n', '      uint256 remainder = msg.value.mod(decimals);\n', '\n', '      uint256 eth = msg.value.sub(remainder);\n', '\n', '      if (remainder != 0) {\n', '        refund(remainder);\n', '      }\n', '\n', '      totalETH = totalETH + eth;\n', '\n', '      uint currentRate = rate / 100; //2 decimals\n', '\n', '      uint256 tokens = eth.div(currentRate);\n', '      uint256 timeBonus = calculateBonusForHours(tokens);\n', '\n', '      uint256 allTokens = tokens.add(timeBonus) + 100; // +100 - oraclize Tax\n', '\n', '      saveInfoAboutInvestors(msg.sender, eth, allTokens, false);\n', '\n', '      token.mint(msg.sender, allTokens);\n', '\n', '      soldTokens = soldTokens + allTokens;\n', '      calculateWithdrow();\n', '    }\n', '\n', '    function saveInfoAboutInvestors(address _address, uint256 _amount, uint256 _tokens, bool _isManual) private {\n', '\n', '      if (!_isManual) {\n', '        if (ico_buyers_token[_address] == 0) {\n', '          investors.push(_address);\n', '        }\n', '\n', '        // Store ETH of Investor\n', '        ico_buyers_eth[_address] = ico_buyers_eth[_address].add(_amount);\n', '\n', '        // Store Token of Investor\n', '        ico_buyers_token[_address] = ico_buyers_token[_address].add(_tokens);\n', '      \n', '      } else {\n', '        if(manualAddresses[_address] == 0) {\n', '          manualAddressesCount.push(_address);\n', '        }\n', '\n', '        manualAddresses[_address] = manualAddresses[_address].add(_tokens);\n', '      }\n', '    }\n', '\n', '    function getManualByAddress(address _address) public constant returns(uint256) {\n', '      return manualAddresses[_address];\n', '    }\n', '\n', '    function getManualInvestorsCount() public constant returns(uint256) {\n', '      return manualAddressesCount.length;\n', '    }\n', '\n', '    function getManualAddress(uint _index) public constant returns(address) {\n', '      return manualAddressesCount[_index];\n', '    }\n', '\n', '    function finishMinting() public onlyOwner {\n', '      if(mintingFinished) {\n', '        revert();\n', '      }\n', '\n', '      token.finishMinting();\n', '\n', '\n', '      ShowInfoBool(mintingFinished);\n', '      mintingFinished = true;\n', '      ShowInfoBool(mintingFinished);\n', '      \n', '      if (soldTokens < mincup) {\n', '        if(investors.length != 0) {\n', '          for (uint256 i=0; i < investors.length; i++) {\n', '            address addr = investors[i];  \n', '            token.burnTokens(addr);\n', '          }\n', '        }\n', '        \n', '        if(manualAddressesCount.length != 0) {\n', '          for (uint256 j=0; j < manualAddressesCount.length; j++) {\n', '            address manualAddr = manualAddressesCount[j];\n', '            token.burnTokens(manualAddr);\n', '          }\n', '        }\n', '      }\n', '\n', '      token.burnFinish();\n', '    }\n', '\n', '    function getFinishStatus() public constant returns(bool) {\n', '      return mintingFinished;\n', '    }\n', '\n', '    function manualRefund() public {\n', '      if (mintingFinished) {\n', '        if(ico_buyers_eth[msg.sender] != 0) {\n', '          uint256 amount = ico_buyers_eth[msg.sender];\n', '          msg.sender.transfer(amount);\n', '          ico_buyers_eth[msg.sender] = 0;\n', '        } else {\n', '          revert();\n', '        }\n', '      } else {\n', '        revert();\n', '      }\n', '      \n', '    }\n', '\n', '    function refund(uint256 _amount) private {\n', '      msg.sender.transfer(_amount);\n', '    }\n', '\n', '    function refund(address _address, uint256 _amount) private {\n', '      _address.transfer(_amount);\n', '    }\n', '\n', '    function getTokensManual(address _address) public constant returns(uint256) {\n', '      return manualAddresses[_address];\n', '    }\n', '\n', '    function calculateBonusForHours(uint256 _tokens) private returns(uint256) {\n', '\n', '      //Calculate for first bonus program\n', '      if (now >= ico_start && now <= firstBonusPhase ) {\n', '        return _tokens.mul(firstExtraBonus).div(100);\n', '      }\n', '\n', '      //Calculate for second bonus program\n', '      if (now > firstBonusPhase && now <= secondBonusPhase ) {\n', '        return _tokens.mul(secondExtraBonus).div(100);\n', '      }\n', '\n', '      //Calculate for third bonus program\n', '      if (now > secondBonusPhase && now <= thirdBonusPhase ) {\n', '        return _tokens.mul(thirdExtraBonus).div(100);\n', '      }\n', '\n', '      //Calculate for four bonus program\n', '      if (now > thirdBonusPhase && now <= fourBonusPhase ) {\n', '        return _tokens.mul(fourExtraBonus).div(100);\n', '      }\n', '\n', '      return 0;\n', '    }\n', '\n', '    function sendToOwners(uint256 _amount) private {\n', '      uint256 twoPercent = _amount.mul(2).div(100);\n', '      uint256 fivePercent = _amount.mul(5).div(100);\n', '      uint256 nineThreePercent = _amount.mul(93).div(100);\n', '\n', '// ----------ADDRESSES FOR PRODUCTION-------------\n', '\n', '      //NineThree Percent\n', '      addresses.addr1().transfer(nineThreePercent);\n', '      addresses.addr2().transfer(nineThreePercent);\n', '      addresses.addr3().transfer(nineThreePercent);\n', '      addresses.addr4().transfer(nineThreePercent);\n', '\n', '      if (!firstWithdrowPhase) {\n', '        addresses.addr1().transfer(nineThreePercent);\n', '        firstWithdrowPhase = true;\n', '      } else {\n', '        if (!secondWithdrowPhase) {\n', '          addresses.addr2().transfer(nineThreePercent);   \n', '          secondWithdrowPhase = true;       \n', '        } else {\n', '          if (!thirdWithdrowPhase) {\n', '            addresses.addr3().transfer(nineThreePercent);\n', '            thirdWithdrowPhase = true;                \n', '          } else {\n', '            if (!fourWithdrowPhase) {\n', '              addresses.addr4().transfer(nineThreePercent);\n', '              fourWithdrowPhase = true;                      \n', '            }\n', '          }\n', '        }\n', '      }\n', '\n', '\n', '      //Five Percent\n', '      addresses.successFee().transfer(fivePercent);\n', '      \n', '      //Two Percent\n', '      addresses.bounty().transfer(twoPercent);\n', '      \n', '    }\n', '\n', '    function getBalanceContract() public constant returns(uint256) {\n', '      return this.balance;\n', '    }\n', '\n', '    function getSoldToken() public constant returns(uint256) {\n', '      return soldTokens;\n', '    }\n', '\n', '    function getInvestorsTokens(address _address) public constant returns(uint256) {\n', '      return ico_buyers_token[_address];\n', '    }\n', '\n', '    function getInvestorsETH(address _address) public constant returns(uint256) {\n', '      return ico_buyers_eth[_address];\n', '    }\n', '\n', '    function getInvestors() public constant returns(uint256) {\n', '      return investors.length;\n', '    }\n', '\n', '    function getInvestorByValue(address _address) public constant returns(uint256) {\n', '      return ico_buyers_eth[_address];\n', '    }\n', '\n', '    //only for test version\n', '    function transfer(address _from, address _to, uint256 _amount) public returns(bool) {\n', '      return token.transferFrom(_from, _to, _amount);\n', '    }\n', '\n', '    function getInvestorByIndex(uint256 _index) public constant returns(address) {\n', '      return investors[_index];\n', '    }\n', '\n', '    function getLeftToken() public constant returns(uint256) {\n', '      if(token.totalSupply() != 0) {\n', '        return token.totalSupply() - soldTokens;\n', '      } else {\n', '        return soldTokens;\n', '      }\n', '    }\n', '\n', '    function getTotalToken() public constant returns(uint256) {\n', '      return token.totalSupply();\n', '    }\n', '\n', '    function getTotalETH() public constant returns(uint256) {\n', '      return totalETH;\n', '    }\n', '\n', '    function getCurrentPrice() public constant returns(uint256) {\n', '      \n', '      uint256 secondDiscount = calculateBonusForHours(rate);\n', '\n', '      uint256 investorDiscount = rate.sub(secondDiscount);\n', '\n', '      return investorDiscount * 10; //minimum 10$ //~10STM\n', '    }\n', '\n', '    function getContractAddress() public constant returns(address) {\n', '      return this;\n', '    }\n', '\n', '    function getOwner() public constant returns(address) {\n', '      return owner;\n', '    }\n', '\n', '    function sendOracleData() public payable {\n', '        if (msg.value != 0) {\n', '            wrapper.transfer(msg.value);\n', '        }\n', '      \n', '      wrapper.update("URL", "json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0");\n', '    }\n', '\n', '    function getQueryPrice(string datasource) constant returns(uint256) {\n', '      return wrapper.getPrice(datasource);\n', '    }\n', '\n', '    function checkWrapperBalance() public constant returns(uint256) {\n', '      return wrapper.getWrapperBalance();\n', '    }\n', '\n', '    function getWrapperData() constant returns(bytes32) {\n', '      return wrapper.getWrapperData();\n', '    }\n', '}']