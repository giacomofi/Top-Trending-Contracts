['pragma solidity ^0.4.11;\n', '\n', '/*******************************************************************************\n', ' * ERC Token Standard #20 Interface\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' *******************************************************************************/\n', 'contract ERC20Interface {\n', '  // Get the total token supply\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '\n', '  // Get the account balance of another account with address _owner\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '  // Send _value amount of tokens to address _to\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '  // Send _value amount of tokens from address _from to address _to\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '  // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '  // If this function is called again it overwrites the current allowance with _value.\n', '  // this function is required for some DEX functionality.\n', '  function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '  // Returns the amount which _spender is still allowed to withdraw from _owner\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '  // Triggered when tokens are transferred.\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/*******************************************************************************\n', ' * AICoin - Smart Contract with token and ballot handling\n', ' *******************************************************************************/\n', 'contract AICoin is ERC20Interface {\n', '\n', '  /* ******************************\n', '   * COIN data / functions\n', '   * ******************************/\n', '\n', '  /* Token constants */\n', '  string public constant name = &#39;AICoin&#39;;\n', '  string public constant symbol = &#39;XAI&#39;;\n', '  uint8 public constant decimals = 8;\n', '  string public constant smallestUnit = &#39;Hofstadter&#39;;\n', '\n', '  /* Token internal data */\n', '  address m_administrator;\n', '  uint256 m_totalSupply;\n', '\n', '  /* Current balances for each account */\n', '  mapping(address => uint256) balances;\n', '\n', '  /* Account holder approves the transfer of an amount to another account */\n', '  mapping(address => mapping (address => uint256)) allowed;\n', '\n', '  /* One-time create function: initialize the supply and set the admin address */\n', '  function AICoin (uint256 _initialSupply) {\n', '    m_administrator = msg.sender;\n', '    m_totalSupply = _initialSupply;\n', '    balances[msg.sender] = _initialSupply;\n', '  }\n', '\n', '  /* Get the admin address */\n', '  function administrator() constant returns (address adminAddress) {\n', '    return m_administrator;\n', '  }\n', '\n', '  /* Get the total coin supply */\n', '  function totalSupply() constant returns (uint256 totalSupply) {\n', '    return m_totalSupply;\n', '  }\n', '\n', '  /* Get the balance of a specific account by its address */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  /* Transfer an amount from the owner&#39;s account to an indicated account */\n', '  function transfer(address _to, uint256 _amount) returns (bool success) {\n', '    if (balances[msg.sender] >= _amount\n', '        && _amount > 0\n', '        && balances[_to] + _amount > balances[_to]\n', '        && (! accountHasCurrentVote(msg.sender))) {\n', '      balances[msg.sender] -= _amount;\n', '      balances[_to] += _amount;\n', '      Transfer(msg.sender, _to, _amount);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /* Send _value amount of tokens from address _from to address _to\n', '   * The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '   * tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '   * fees in sub-currencies; the command should fail unless the _from account has\n', '   * deliberately authorized the sender of the message via some mechanism; we propose\n', '   * these standardized APIs for approval:\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\n', '    if (balances[_from] >= _amount\n', '        && allowed[_from][msg.sender] >= _amount\n', '        && _amount > 0\n', '        && balances[_to] + _amount > balances[_to]\n', '        && (! accountHasCurrentVote(_from))) {\n', '      balances[_from] -= _amount;\n', '      allowed[_from][msg.sender] -= _amount;\n', '      balances[_to] += _amount;\n', '      Transfer(_from, _to, _amount);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /* Pre-authorize an address to withdraw from your account, up to the _value amount.\n', '   * Doing so (using transferFrom) reduces the remaining authorized amount,\n', '   * as well as the actual account balance)\n', '   * Subsequent calls to this function overwrite any existing authorized amount.\n', '   * Therefore, to cancel an authorization, simply write a zero amount.\n', '   */\n', '  function approve(address _spender, uint256 _amount) returns (bool success) {\n', '    allowed[msg.sender][_spender] = _amount;\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Get the currently authorized that can be withdrawn by account _spender from account _owner */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /* ******************************\n', '   * BALLOT data / functions\n', '   * ******************************/\n', '\n', '  /* Dev Note: creating a struct that contained a string, uint values and\n', '   * an array of option structs, etc, would consistently fail.\n', '   * So the ballot details are held in separate mappings with a common integer\n', '   * key for each ballot. The IDs are 1-indexed, sequential and contiguous.\n', '   */\n', '\n', '  /* Basic ballot details: time frame and number of options */\n', '  struct BallotDetails {\n', '    uint256 start;\n', '    uint256 end;\n', '    uint32 numOptions; // 1-indexed for readability\n', '    bool sealed;\n', '  }\n', '\n', '  uint32 public numBallots = 0; // 1-indexed for readability\n', '  mapping (uint32 => string) public ballotNames;\n', '  mapping (uint32 => BallotDetails) public ballotDetails;\n', '  mapping (uint32 => mapping (uint32 => string) ) public ballotOptions;\n', '\n', '  /* Create a new ballot and set the basic details (proposal description, dates)\n', '   * The ballot still need to have options added and then to be sealed\n', '   */\n', '  function adminAddBallot(string _proposal, uint256 _start, uint256 _end) {\n', '\n', '    /* Admin functions must be called by the contract creator. */\n', '    require(msg.sender == m_administrator);\n', '\n', '    /* Create and store the new ballot objects */\n', '    numBallots++;\n', '    uint32 ballotId = numBallots;\n', '    ballotNames[ballotId] = _proposal;\n', '    ballotDetails[ballotId] = BallotDetails(_start, _end, 0, false);\n', '  }\n', '\n', '  /* Create a new ballot and set the basic details (proposal description, dates)\n', '   * The ballot still need to have options added and then to be sealed\n', '   */\n', '  function adminAmendBallot(uint32 _ballotId, string _proposal, uint256 _start, uint256 _end) {\n', '\n', '    /* Admin functions must be called by the contract creator. */\n', '    require(msg.sender == m_administrator);\n', '\n', '    /* verify that the ballot exists */\n', '    require(_ballotId > 0 && _ballotId <= numBallots);\n', '\n', '    /* update the ballot object */\n', '    ballotNames[_ballotId] = _proposal;\n', '    ballotDetails[_ballotId].start = _start;\n', '    ballotDetails[_ballotId].end = _end;\n', '  }\n', '\n', '  /* Add an option to an existing Ballot\n', '   */\n', '  function adminAddBallotOption(uint32 _ballotId, string _option) {\n', '\n', '    /* Admin functions must be called by the contract creator. */\n', '    require(msg.sender == m_administrator);\n', '\n', '    /* verify that the ballot exists */\n', '    require(_ballotId > 0 && _ballotId <= numBallots);\n', '\n', '    /* cannot change a ballot once it is sealed */\n', '    if(isBallotSealed(_ballotId)) {\n', '      revert();\n', '    }\n', '\n', '    /* store the new ballot option */\n', '    ballotDetails[_ballotId].numOptions += 1;\n', '    uint32 optionId = ballotDetails[_ballotId].numOptions;\n', '    ballotOptions[_ballotId][optionId] = _option;\n', '  }\n', '\n', '  /* Amend and option in an existing Ballot\n', '   */\n', '  function adminEditBallotOption(uint32 _ballotId, uint32 _optionId, string _option) {\n', '\n', '    /* Admin functions must be called by the contract creator. */\n', '    require(msg.sender == m_administrator);\n', '\n', '    /* verify that the ballot exists */\n', '    require(_ballotId > 0 && _ballotId <= numBallots);\n', '\n', '    /* cannot change a ballot once it is sealed */\n', '    if(isBallotSealed(_ballotId)) {\n', '      revert();\n', '    }\n', '\n', '    /* validate the ballot option */\n', '    require(_optionId > 0 && _optionId <= ballotDetails[_ballotId].numOptions);\n', '\n', '    /* update the ballot option */\n', '    ballotOptions[_ballotId][_optionId] = _option;\n', '  }\n', '\n', '  /* Seal a ballot - after this the ballot is official and no changes can be made.\n', '   */\n', '  function adminSealBallot(uint32 _ballotId) {\n', '\n', '    /* Admin functions must be called by the contract creator. */\n', '    require(msg.sender == m_administrator);\n', '\n', '    /* verify that the ballot exists */\n', '    require(_ballotId > 0 && _ballotId <= numBallots);\n', '\n', '    /* cannot change a ballot once it is sealed */\n', '    if(isBallotSealed(_ballotId)) {\n', '      revert();\n', '    }\n', '\n', '    /* set the ballot seal flag */\n', '    ballotDetails[_ballotId].sealed = true;\n', '  }\n', '\n', '  /* Function to determine if a ballot is currently in progress, based on its\n', '   * start and end dates, and that it has been sealed.\n', '   */\n', '  function isBallotInProgress(uint32 _ballotId) private constant returns (bool) {\n', '    return (isBallotSealed(_ballotId)\n', '            && ballotDetails[_ballotId].start <= now\n', '            && ballotDetails[_ballotId].end >= now);\n', '  }\n', '\n', '  /* Function to determine if a ballot has ended, based on its end date */\n', '  function hasBallotEnded(uint32 _ballotId) private constant returns (bool) {\n', '    return (ballotDetails[_ballotId].end < now);\n', '  }\n', '\n', '  /* Function to determine if a ballot has been sealed, which means it has been\n', '   * authorized by the administrator and can no longer be changed.\n', '   */\n', '  function isBallotSealed(uint32 _ballotId) private returns (bool) {\n', '    return ballotDetails[_ballotId].sealed;\n', '  }\n', '\n', '  /* ******************************\n', '   * VOTING data / functions\n', '   * ******************************/\n', '\n', '  mapping (uint32 => mapping (address => uint256) ) public ballotVoters;\n', '  mapping (uint32 => mapping (uint32 => uint256) ) public ballotVoteCount;\n', '\n', '  /* function to allow a coin holder add to the vote count of an option in an\n', '   * active ballot. The votes added equals the balance of the account. Once this is called successfully\n', '   * the coins cannot be transferred out of the account until the end of the ballot.\n', '   *\n', '   * NB: The timing of the start and end of the voting period is determined by\n', '   * the timestamp of the block in which the transaction is included. As given by\n', '   * the current Ethereum standard this is *NOT* guaranteed to be accurate to any\n', '   * given external time source. Therefore, votes should be placed well in advance\n', '   * of the UTC end time of the Ballot.\n', '   */\n', '  function vote(uint32 _ballotId, uint32 _selectedOptionId) {\n', '\n', '    /* verify that the ballot exists */\n', '    require(_ballotId > 0 && _ballotId <= numBallots);\n', '\n', '    /* Ballot must be in progress in order to vote */\n', '    require(isBallotInProgress(_ballotId));\n', '\n', '    /* Calculate the balance which which the coin holder has not yet voted, which is the difference between\n', '     * the current balance for the senders address and the amount they already voted in this ballot.\n', '     * If the difference is zero, this attempt to vote will fail.\n', '     */\n', '    uint256 votableBalance = balanceOf(msg.sender) - ballotVoters[_ballotId][msg.sender];\n', '    require(votableBalance > 0);\n', '\n', '    /* validate the ballot option */\n', '    require(_selectedOptionId > 0 && _selectedOptionId <= ballotDetails[_ballotId].numOptions);\n', '\n', '    /* update the vote count and record the voter */\n', '    ballotVoteCount[_ballotId][_selectedOptionId] += votableBalance;\n', '    ballotVoters[_ballotId][msg.sender] += votableBalance;\n', '  }\n', '\n', '  /* function to determine if an address has already voted in a given ballot */\n', '  function hasAddressVotedInBallot(uint32 _ballotId, address _voter) constant returns (bool hasVoted) {\n', '    return ballotVoters[_ballotId][_voter] > 0;\n', '  }\n', '\n', '  /* function to determine if an account has voted in any current ballot */\n', '  function accountHasCurrentVote(address _voter) constant returns (bool) {\n', '    for(uint32 id = 1; id <= numBallots; id++) {\n', '      if (isBallotInProgress(id) && hasAddressVotedInBallot(id, _voter)) {\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/*******************************************************************************\n', ' * ERC Token Standard #20 Interface\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' *******************************************************************************/\n', 'contract ERC20Interface {\n', '  // Get the total token supply\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '\n', '  // Get the account balance of another account with address _owner\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '  // Send _value amount of tokens to address _to\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '  // Send _value amount of tokens from address _from to address _to\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '  // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '  // If this function is called again it overwrites the current allowance with _value.\n', '  // this function is required for some DEX functionality.\n', '  function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '  // Returns the amount which _spender is still allowed to withdraw from _owner\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '  // Triggered when tokens are transferred.\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/*******************************************************************************\n', ' * AICoin - Smart Contract with token and ballot handling\n', ' *******************************************************************************/\n', 'contract AICoin is ERC20Interface {\n', '\n', '  /* ******************************\n', '   * COIN data / functions\n', '   * ******************************/\n', '\n', '  /* Token constants */\n', "  string public constant name = 'AICoin';\n", "  string public constant symbol = 'XAI';\n", '  uint8 public constant decimals = 8;\n', "  string public constant smallestUnit = 'Hofstadter';\n", '\n', '  /* Token internal data */\n', '  address m_administrator;\n', '  uint256 m_totalSupply;\n', '\n', '  /* Current balances for each account */\n', '  mapping(address => uint256) balances;\n', '\n', '  /* Account holder approves the transfer of an amount to another account */\n', '  mapping(address => mapping (address => uint256)) allowed;\n', '\n', '  /* One-time create function: initialize the supply and set the admin address */\n', '  function AICoin (uint256 _initialSupply) {\n', '    m_administrator = msg.sender;\n', '    m_totalSupply = _initialSupply;\n', '    balances[msg.sender] = _initialSupply;\n', '  }\n', '\n', '  /* Get the admin address */\n', '  function administrator() constant returns (address adminAddress) {\n', '    return m_administrator;\n', '  }\n', '\n', '  /* Get the total coin supply */\n', '  function totalSupply() constant returns (uint256 totalSupply) {\n', '    return m_totalSupply;\n', '  }\n', '\n', '  /* Get the balance of a specific account by its address */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', "  /* Transfer an amount from the owner's account to an indicated account */\n", '  function transfer(address _to, uint256 _amount) returns (bool success) {\n', '    if (balances[msg.sender] >= _amount\n', '        && _amount > 0\n', '        && balances[_to] + _amount > balances[_to]\n', '        && (! accountHasCurrentVote(msg.sender))) {\n', '      balances[msg.sender] -= _amount;\n', '      balances[_to] += _amount;\n', '      Transfer(msg.sender, _to, _amount);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /* Send _value amount of tokens from address _from to address _to\n', '   * The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '   * tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '   * fees in sub-currencies; the command should fail unless the _from account has\n', '   * deliberately authorized the sender of the message via some mechanism; we propose\n', '   * these standardized APIs for approval:\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\n', '    if (balances[_from] >= _amount\n', '        && allowed[_from][msg.sender] >= _amount\n', '        && _amount > 0\n', '        && balances[_to] + _amount > balances[_to]\n', '        && (! accountHasCurrentVote(_from))) {\n', '      balances[_from] -= _amount;\n', '      allowed[_from][msg.sender] -= _amount;\n', '      balances[_to] += _amount;\n', '      Transfer(_from, _to, _amount);\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  /* Pre-authorize an address to withdraw from your account, up to the _value amount.\n', '   * Doing so (using transferFrom) reduces the remaining authorized amount,\n', '   * as well as the actual account balance)\n', '   * Subsequent calls to this function overwrite any existing authorized amount.\n', '   * Therefore, to cancel an authorization, simply write a zero amount.\n', '   */\n', '  function approve(address _spender, uint256 _amount) returns (bool success) {\n', '    allowed[msg.sender][_spender] = _amount;\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Get the currently authorized that can be withdrawn by account _spender from account _owner */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /* ******************************\n', '   * BALLOT data / functions\n', '   * ******************************/\n', '\n', '  /* Dev Note: creating a struct that contained a string, uint values and\n', '   * an array of option structs, etc, would consistently fail.\n', '   * So the ballot details are held in separate mappings with a common integer\n', '   * key for each ballot. The IDs are 1-indexed, sequential and contiguous.\n', '   */\n', '\n', '  /* Basic ballot details: time frame and number of options */\n', '  struct BallotDetails {\n', '    uint256 start;\n', '    uint256 end;\n', '    uint32 numOptions; // 1-indexed for readability\n', '    bool sealed;\n', '  }\n', '\n', '  uint32 public numBallots = 0; // 1-indexed for readability\n', '  mapping (uint32 => string) public ballotNames;\n', '  mapping (uint32 => BallotDetails) public ballotDetails;\n', '  mapping (uint32 => mapping (uint32 => string) ) public ballotOptions;\n', '\n', '  /* Create a new ballot and set the basic details (proposal description, dates)\n', '   * The ballot still need to have options added and then to be sealed\n', '   */\n', '  function adminAddBallot(string _proposal, uint256 _start, uint256 _end) {\n', '\n', '    /* Admin functions must be called by the contract creator. */\n', '    require(msg.sender == m_administrator);\n', '\n', '    /* Create and store the new ballot objects */\n', '    numBallots++;\n', '    uint32 ballotId = numBallots;\n', '    ballotNames[ballotId] = _proposal;\n', '    ballotDetails[ballotId] = BallotDetails(_start, _end, 0, false);\n', '  }\n', '\n', '  /* Create a new ballot and set the basic details (proposal description, dates)\n', '   * The ballot still need to have options added and then to be sealed\n', '   */\n', '  function adminAmendBallot(uint32 _ballotId, string _proposal, uint256 _start, uint256 _end) {\n', '\n', '    /* Admin functions must be called by the contract creator. */\n', '    require(msg.sender == m_administrator);\n', '\n', '    /* verify that the ballot exists */\n', '    require(_ballotId > 0 && _ballotId <= numBallots);\n', '\n', '    /* update the ballot object */\n', '    ballotNames[_ballotId] = _proposal;\n', '    ballotDetails[_ballotId].start = _start;\n', '    ballotDetails[_ballotId].end = _end;\n', '  }\n', '\n', '  /* Add an option to an existing Ballot\n', '   */\n', '  function adminAddBallotOption(uint32 _ballotId, string _option) {\n', '\n', '    /* Admin functions must be called by the contract creator. */\n', '    require(msg.sender == m_administrator);\n', '\n', '    /* verify that the ballot exists */\n', '    require(_ballotId > 0 && _ballotId <= numBallots);\n', '\n', '    /* cannot change a ballot once it is sealed */\n', '    if(isBallotSealed(_ballotId)) {\n', '      revert();\n', '    }\n', '\n', '    /* store the new ballot option */\n', '    ballotDetails[_ballotId].numOptions += 1;\n', '    uint32 optionId = ballotDetails[_ballotId].numOptions;\n', '    ballotOptions[_ballotId][optionId] = _option;\n', '  }\n', '\n', '  /* Amend and option in an existing Ballot\n', '   */\n', '  function adminEditBallotOption(uint32 _ballotId, uint32 _optionId, string _option) {\n', '\n', '    /* Admin functions must be called by the contract creator. */\n', '    require(msg.sender == m_administrator);\n', '\n', '    /* verify that the ballot exists */\n', '    require(_ballotId > 0 && _ballotId <= numBallots);\n', '\n', '    /* cannot change a ballot once it is sealed */\n', '    if(isBallotSealed(_ballotId)) {\n', '      revert();\n', '    }\n', '\n', '    /* validate the ballot option */\n', '    require(_optionId > 0 && _optionId <= ballotDetails[_ballotId].numOptions);\n', '\n', '    /* update the ballot option */\n', '    ballotOptions[_ballotId][_optionId] = _option;\n', '  }\n', '\n', '  /* Seal a ballot - after this the ballot is official and no changes can be made.\n', '   */\n', '  function adminSealBallot(uint32 _ballotId) {\n', '\n', '    /* Admin functions must be called by the contract creator. */\n', '    require(msg.sender == m_administrator);\n', '\n', '    /* verify that the ballot exists */\n', '    require(_ballotId > 0 && _ballotId <= numBallots);\n', '\n', '    /* cannot change a ballot once it is sealed */\n', '    if(isBallotSealed(_ballotId)) {\n', '      revert();\n', '    }\n', '\n', '    /* set the ballot seal flag */\n', '    ballotDetails[_ballotId].sealed = true;\n', '  }\n', '\n', '  /* Function to determine if a ballot is currently in progress, based on its\n', '   * start and end dates, and that it has been sealed.\n', '   */\n', '  function isBallotInProgress(uint32 _ballotId) private constant returns (bool) {\n', '    return (isBallotSealed(_ballotId)\n', '            && ballotDetails[_ballotId].start <= now\n', '            && ballotDetails[_ballotId].end >= now);\n', '  }\n', '\n', '  /* Function to determine if a ballot has ended, based on its end date */\n', '  function hasBallotEnded(uint32 _ballotId) private constant returns (bool) {\n', '    return (ballotDetails[_ballotId].end < now);\n', '  }\n', '\n', '  /* Function to determine if a ballot has been sealed, which means it has been\n', '   * authorized by the administrator and can no longer be changed.\n', '   */\n', '  function isBallotSealed(uint32 _ballotId) private returns (bool) {\n', '    return ballotDetails[_ballotId].sealed;\n', '  }\n', '\n', '  /* ******************************\n', '   * VOTING data / functions\n', '   * ******************************/\n', '\n', '  mapping (uint32 => mapping (address => uint256) ) public ballotVoters;\n', '  mapping (uint32 => mapping (uint32 => uint256) ) public ballotVoteCount;\n', '\n', '  /* function to allow a coin holder add to the vote count of an option in an\n', '   * active ballot. The votes added equals the balance of the account. Once this is called successfully\n', '   * the coins cannot be transferred out of the account until the end of the ballot.\n', '   *\n', '   * NB: The timing of the start and end of the voting period is determined by\n', '   * the timestamp of the block in which the transaction is included. As given by\n', '   * the current Ethereum standard this is *NOT* guaranteed to be accurate to any\n', '   * given external time source. Therefore, votes should be placed well in advance\n', '   * of the UTC end time of the Ballot.\n', '   */\n', '  function vote(uint32 _ballotId, uint32 _selectedOptionId) {\n', '\n', '    /* verify that the ballot exists */\n', '    require(_ballotId > 0 && _ballotId <= numBallots);\n', '\n', '    /* Ballot must be in progress in order to vote */\n', '    require(isBallotInProgress(_ballotId));\n', '\n', '    /* Calculate the balance which which the coin holder has not yet voted, which is the difference between\n', '     * the current balance for the senders address and the amount they already voted in this ballot.\n', '     * If the difference is zero, this attempt to vote will fail.\n', '     */\n', '    uint256 votableBalance = balanceOf(msg.sender) - ballotVoters[_ballotId][msg.sender];\n', '    require(votableBalance > 0);\n', '\n', '    /* validate the ballot option */\n', '    require(_selectedOptionId > 0 && _selectedOptionId <= ballotDetails[_ballotId].numOptions);\n', '\n', '    /* update the vote count and record the voter */\n', '    ballotVoteCount[_ballotId][_selectedOptionId] += votableBalance;\n', '    ballotVoters[_ballotId][msg.sender] += votableBalance;\n', '  }\n', '\n', '  /* function to determine if an address has already voted in a given ballot */\n', '  function hasAddressVotedInBallot(uint32 _ballotId, address _voter) constant returns (bool hasVoted) {\n', '    return ballotVoters[_ballotId][_voter] > 0;\n', '  }\n', '\n', '  /* function to determine if an account has voted in any current ballot */\n', '  function accountHasCurrentVote(address _voter) constant returns (bool) {\n', '    for(uint32 id = 1; id <= numBallots; id++) {\n', '      if (isBallotInProgress(id) && hasAddressVotedInBallot(id, _voter)) {\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '}']
