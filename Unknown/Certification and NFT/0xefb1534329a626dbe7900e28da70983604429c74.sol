['pragma solidity 0.4.11;\n', '\n', 'contract token { function transfer(address receiver, uint amount);\n', '                 function mintToken(address target, uint mintedAmount);\n', '                }\n', '\n', 'contract CrowdSale {\n', '    enum State {\n', '        Fundraising,\n', '        Failed,\n', '        Successful,\n', '        Closed\n', '    }\n', '    State public state = State.Fundraising;\n', '\n', '    struct Contribution {\n', '        uint amount;\n', '        address contributor;\n', '    }\n', '    Contribution[] contributions;\n', '\n', '    \n', '    \n', '    uint public totalRaised;\n', '    uint public currentBalance;\n', '    uint public deadline;\n', '    uint public completedAt;\n', '    uint public priceInWei;\n', '    uint public fundingMinimumTargetInWei; \n', '    uint public fundingMaximumTargetInWei; \n', '    token public tokenReward;\n', '    address public creator;\n', '    address public beneficiary; \n', '    string campaignUrl;\n', '    byte constant version = 1;\n', '\n', '    \n', '    event LogFundingReceived(address addr, uint amount, uint currentTotal);\n', '    event LogWinnerPaid(address winnerAddress);\n', '    event LogFundingSuccessful(uint totalRaised);\n', '    event LogFunderInitialized(\n', '        address creator,\n', '        address beneficiary,\n', '        string url,\n', '        uint _fundingMaximumTargetInEther, \n', '        uint256 deadline);\n', '\n', '\n', '    modifier inState(State _state) {\n', '        if (state != _state) throw;\n', '        _;\n', '    }\n', '\n', '     modifier isMinimum() {\n', '        if(msg.value < priceInWei) throw;\n', '        _;\n', '    }\n', '\n', '\n', '\n', '    modifier isCreator() {\n', '        if (msg.sender != creator) throw;\n', '        _;\n', '    }\n', '\n', '    \n', '    modifier atEndOfLifecycle() {\n', '        if(!((state == State.Failed || state == State.Successful) && completedAt + 1 hours < now)) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    \n', '    function CrowdSale(\n', '        uint _timeInMinutesForFundraising,\n', '        string _campaignUrl,\n', '        address _ifSuccessfulSendTo,\n', '        uint _fundingMinimumTargetInEther,\n', '        uint _fundingMaximumTargetInEther,\n', '        token _addressOfTokenUsedAsReward,\n', '        uint _etherCostOfEachToken)\n', '    {\n', '        creator = msg.sender;\n', '        beneficiary = _ifSuccessfulSendTo;\n', '        campaignUrl = _campaignUrl;\n', '        fundingMinimumTargetInWei = _fundingMinimumTargetInEther * 1 ether; \n', '        fundingMaximumTargetInWei = _fundingMaximumTargetInEther * 1 ether; \n', '        deadline = now + (_timeInMinutesForFundraising * 1 minutes);\n', '        currentBalance = 0;\n', '        tokenReward = token(_addressOfTokenUsedAsReward);\n', '        priceInWei = _etherCostOfEachToken ;\n', '        LogFunderInitialized(\n', '            creator,\n', '            beneficiary,\n', '            campaignUrl,\n', '            fundingMaximumTargetInWei,\n', '            deadline);\n', '    }\n', '\n', '    function contribute()\n', '    public\n', '    inState(State.Fundraising) isMinimum() payable returns (uint256)\n', '    {\n', '        uint256 amountInWei = msg.value;\n', '\n', '        \n', '        contributions.push(\n', '            Contribution({\n', '                amount: msg.value,\n', '                contributor: msg.sender\n', '                }) \n', '            );\n', '\n', '        totalRaised += msg.value;\n', '        currentBalance = totalRaised;\n', '\n', '\n', '        if(fundingMaximumTargetInWei != 0){\n', '            \n', '            tokenReward.transfer(msg.sender, amountInWei * 1000000000000000000 / priceInWei);\n', '        }\n', '        else{\n', '            tokenReward.mintToken(msg.sender, amountInWei * 1000000000000000000 / priceInWei);\n', '        }\n', '\n', '        LogFundingReceived(msg.sender, msg.value, totalRaised);\n', '\n', '        \n', '\n', '        checkIfFundingCompleteOrExpired();\n', '        return contributions.length - 1; \n', '    }\n', '\n', '    function checkIfFundingCompleteOrExpired() {\n', '        \n', '       \n', '        if (fundingMaximumTargetInWei != 0 && totalRaised > fundingMaximumTargetInWei) {\n', '            state = State.Successful;\n', '            LogFundingSuccessful(totalRaised);\n', '            payOut();\n', '            completedAt = now;\n', '            \n', '            } else if ( now > deadline )  {\n', '                if(totalRaised >= fundingMinimumTargetInWei){\n', '                    state = State.Successful;\n', '                    LogFundingSuccessful(totalRaised);\n', '                    payOut();  \n', '                    completedAt = now;\n', '                }\n', '                else{\n', '                    state = State.Failed; \n', '                    completedAt = now;\n', '                }\n', '            } \n', '        \n', '    }\n', '\n', '        function payOut()\n', '        public\n', '        inState(State.Successful)\n', '        {\n', '            \n', '            if(!beneficiary.send(this.balance)) {\n', '                throw;\n', '            }\n', '\n', '            state = State.Closed;\n', '            currentBalance = 0;\n', '            LogWinnerPaid(beneficiary);\n', '        }\n', '\n', '        function getRefund()\n', '        public\n', '        inState(State.Failed) \n', '        returns (bool)\n', '        {\n', '            for(uint i=0; i<=contributions.length; i++)\n', '            {\n', '                if(contributions[i].contributor == msg.sender){\n', '                    uint amountToRefund = contributions[i].amount;\n', '                    contributions[i].amount = 0;\n', '                    if(!contributions[i].contributor.send(amountToRefund)) {\n', '                        contributions[i].amount = amountToRefund;\n', '                        return false;\n', '                    }\n', '                    else{\n', '                        totalRaised -= amountToRefund;\n', '                        currentBalance = totalRaised;\n', '                    }\n', '                    return true;\n', '                }\n', '            }\n', '            return false;\n', '        }\n', '\n', '        function removeContract()\n', '        public\n', '        isCreator()\n', '        atEndOfLifecycle()\n', '        {\n', '            selfdestruct(msg.sender);\n', '            \n', '        }\n', '\n', '        function () { throw; }\n', '}']
['pragma solidity 0.4.11;\n', '\n', 'contract token { function transfer(address receiver, uint amount);\n', '                 function mintToken(address target, uint mintedAmount);\n', '                }\n', '\n', 'contract CrowdSale {\n', '    enum State {\n', '        Fundraising,\n', '        Failed,\n', '        Successful,\n', '        Closed\n', '    }\n', '    State public state = State.Fundraising;\n', '\n', '    struct Contribution {\n', '        uint amount;\n', '        address contributor;\n', '    }\n', '    Contribution[] contributions;\n', '\n', '    \n', '    \n', '    uint public totalRaised;\n', '    uint public currentBalance;\n', '    uint public deadline;\n', '    uint public completedAt;\n', '    uint public priceInWei;\n', '    uint public fundingMinimumTargetInWei; \n', '    uint public fundingMaximumTargetInWei; \n', '    token public tokenReward;\n', '    address public creator;\n', '    address public beneficiary; \n', '    string campaignUrl;\n', '    byte constant version = 1;\n', '\n', '    \n', '    event LogFundingReceived(address addr, uint amount, uint currentTotal);\n', '    event LogWinnerPaid(address winnerAddress);\n', '    event LogFundingSuccessful(uint totalRaised);\n', '    event LogFunderInitialized(\n', '        address creator,\n', '        address beneficiary,\n', '        string url,\n', '        uint _fundingMaximumTargetInEther, \n', '        uint256 deadline);\n', '\n', '\n', '    modifier inState(State _state) {\n', '        if (state != _state) throw;\n', '        _;\n', '    }\n', '\n', '     modifier isMinimum() {\n', '        if(msg.value < priceInWei) throw;\n', '        _;\n', '    }\n', '\n', '\n', '\n', '    modifier isCreator() {\n', '        if (msg.sender != creator) throw;\n', '        _;\n', '    }\n', '\n', '    \n', '    modifier atEndOfLifecycle() {\n', '        if(!((state == State.Failed || state == State.Successful) && completedAt + 1 hours < now)) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    \n', '    function CrowdSale(\n', '        uint _timeInMinutesForFundraising,\n', '        string _campaignUrl,\n', '        address _ifSuccessfulSendTo,\n', '        uint _fundingMinimumTargetInEther,\n', '        uint _fundingMaximumTargetInEther,\n', '        token _addressOfTokenUsedAsReward,\n', '        uint _etherCostOfEachToken)\n', '    {\n', '        creator = msg.sender;\n', '        beneficiary = _ifSuccessfulSendTo;\n', '        campaignUrl = _campaignUrl;\n', '        fundingMinimumTargetInWei = _fundingMinimumTargetInEther * 1 ether; \n', '        fundingMaximumTargetInWei = _fundingMaximumTargetInEther * 1 ether; \n', '        deadline = now + (_timeInMinutesForFundraising * 1 minutes);\n', '        currentBalance = 0;\n', '        tokenReward = token(_addressOfTokenUsedAsReward);\n', '        priceInWei = _etherCostOfEachToken ;\n', '        LogFunderInitialized(\n', '            creator,\n', '            beneficiary,\n', '            campaignUrl,\n', '            fundingMaximumTargetInWei,\n', '            deadline);\n', '    }\n', '\n', '    function contribute()\n', '    public\n', '    inState(State.Fundraising) isMinimum() payable returns (uint256)\n', '    {\n', '        uint256 amountInWei = msg.value;\n', '\n', '        \n', '        contributions.push(\n', '            Contribution({\n', '                amount: msg.value,\n', '                contributor: msg.sender\n', '                }) \n', '            );\n', '\n', '        totalRaised += msg.value;\n', '        currentBalance = totalRaised;\n', '\n', '\n', '        if(fundingMaximumTargetInWei != 0){\n', '            \n', '            tokenReward.transfer(msg.sender, amountInWei * 1000000000000000000 / priceInWei);\n', '        }\n', '        else{\n', '            tokenReward.mintToken(msg.sender, amountInWei * 1000000000000000000 / priceInWei);\n', '        }\n', '\n', '        LogFundingReceived(msg.sender, msg.value, totalRaised);\n', '\n', '        \n', '\n', '        checkIfFundingCompleteOrExpired();\n', '        return contributions.length - 1; \n', '    }\n', '\n', '    function checkIfFundingCompleteOrExpired() {\n', '        \n', '       \n', '        if (fundingMaximumTargetInWei != 0 && totalRaised > fundingMaximumTargetInWei) {\n', '            state = State.Successful;\n', '            LogFundingSuccessful(totalRaised);\n', '            payOut();\n', '            completedAt = now;\n', '            \n', '            } else if ( now > deadline )  {\n', '                if(totalRaised >= fundingMinimumTargetInWei){\n', '                    state = State.Successful;\n', '                    LogFundingSuccessful(totalRaised);\n', '                    payOut();  \n', '                    completedAt = now;\n', '                }\n', '                else{\n', '                    state = State.Failed; \n', '                    completedAt = now;\n', '                }\n', '            } \n', '        \n', '    }\n', '\n', '        function payOut()\n', '        public\n', '        inState(State.Successful)\n', '        {\n', '            \n', '            if(!beneficiary.send(this.balance)) {\n', '                throw;\n', '            }\n', '\n', '            state = State.Closed;\n', '            currentBalance = 0;\n', '            LogWinnerPaid(beneficiary);\n', '        }\n', '\n', '        function getRefund()\n', '        public\n', '        inState(State.Failed) \n', '        returns (bool)\n', '        {\n', '            for(uint i=0; i<=contributions.length; i++)\n', '            {\n', '                if(contributions[i].contributor == msg.sender){\n', '                    uint amountToRefund = contributions[i].amount;\n', '                    contributions[i].amount = 0;\n', '                    if(!contributions[i].contributor.send(amountToRefund)) {\n', '                        contributions[i].amount = amountToRefund;\n', '                        return false;\n', '                    }\n', '                    else{\n', '                        totalRaised -= amountToRefund;\n', '                        currentBalance = totalRaised;\n', '                    }\n', '                    return true;\n', '                }\n', '            }\n', '            return false;\n', '        }\n', '\n', '        function removeContract()\n', '        public\n', '        isCreator()\n', '        atEndOfLifecycle()\n', '        {\n', '            selfdestruct(msg.sender);\n', '            \n', '        }\n', '\n', '        function () { throw; }\n', '}']
