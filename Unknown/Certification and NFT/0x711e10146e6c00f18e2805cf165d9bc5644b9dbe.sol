['//A BurnableOpenPayment is instantiated with a specified payer and a commitThreshold.\n', '//The recipient is not set when the contract is instantiated.\n', '\n', '//The constructor is payable, so the contract can be instantiated with initial funds.\n', '//Only the payer can fund the Payment after instantiation.\n', '\n', '//All behavior of the contract is directed by the payer, but\n', '//the payer can never directly recover the payment,\n', '//unless he calls the recover() function before anyone else commit()s.\n', '\n', '//Anyone can become the recipient by contributing the commitThreshold with commit().\n', '//The recipient will never be changed once it&#39;s been set via commit().\n', '\n', '//The payer can at any time choose to burn or release to the recipient any amount of funds.\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', 'contract BurnableOpenPayment {\n', '    //BOP will start with a payer but no recipient (recipient==0x0)\n', '    address public payer;\n', '    address public recipient;\n', '    address constant burnAddress = 0x0;\n', '    \n', '    //Note that these will track, but not influence the BOP logic.\n', '    uint public amountDeposited;\n', '    uint public amountBurned;\n', '    uint public amountReleased;\n', '    \n', '    //payerString and recipientString enable rudimentary communication/publishing.\n', '    //Although the two parties might quickly move to another medium with better privacy or convenience,\n', '    //beginning with this is nice because it&#39;s already trustless/transparent/signed/pseudonymous/etc.\n', '    string public payerString;\n', '    string public recipientString;\n', '    \n', '    //Amount of ether a prospective recipient must pay to permanently become the recipient. See commit().\n', '    uint public commitThreshold;\n', '    \n', '    //What if the payer falls off the face of the planet?\n', '    //A BOP is instantiated with a chosen defaultAction, which cannot be changed after instantiation.\n', '    enum DefaultAction {None, Release, Burn}\n', '    DefaultAction public defaultAction;\n', '    \n', '    //if defaultAction != None, how long should we wait allowing the default action to be called?\n', '    uint public defaultTimeoutLength;\n', '    \n', '    //Calculated from defaultTimeoutLength in commit(),\n', '    //and recaluclated whenever the payer (or possibly the recipient) calls delayDefaultAction()\n', '    uint public defaultTriggerTime;\n', '    \n', '    //Most action happens in the Committed state.\n', '    enum State {Open, Committed, Expended}\n', '    State public state;\n', '    //Note that a BOP cannot go from Committed back to Open, but it can go from Expended back to Committed\n', '    //(this would retain the committed recipient). Search for Expended and Unexpended events to see how this works.\n', '    \n', '    modifier inState(State s) { require(s == state); _; }\n', '    modifier onlyPayer() { require(msg.sender == payer); _; }\n', '    modifier onlyRecipient() { require(msg.sender == recipient); _; }\n', '    modifier onlyPayerOrRecipient() { require((msg.sender == payer) || (msg.sender == recipient)); _; }\n', '    \n', '    event Created(address payer, uint commitThreshold, BurnableOpenPayment.DefaultAction defaultAction, uint defaultTimeoutLength, string initialPayerString);\n', '    event FundsAdded(uint amount);//The payer has added funds to the BOP.\n', '    event PayerStringUpdated(string newPayerString);\n', '    event RecipientStringUpdated(string newRecipientString);\n', '    event FundsRecovered();\n', '    event Committed(address recipient);\n', '    event FundsBurned(uint amount);\n', '    event FundsReleased(uint amount);\n', '    event Expended();\n', '    event Unexpended();\n', '    event DefaultActionDelayed();\n', '    event DefaultActionCalled();\n', '    \n', '    function BurnableOpenPayment(address _payer, uint _commitThreshold, DefaultAction _defaultAction, uint _defaultTimeoutLength, string _payerString)\n', '    public\n', '    payable {\n', '        Created(_payer, _commitThreshold, _defaultAction, _defaultTimeoutLength, _payerString);\n', '        \n', '        if (msg.value > 0) {\n', '            FundsAdded(msg.value);\n', '            amountDeposited += msg.value;\n', '        }\n', '            \n', '        state = State.Open;\n', '        payer = _payer;\n', '        \n', '        commitThreshold = _commitThreshold;\n', '        \n', '        defaultAction = _defaultAction;\n', '        if (defaultAction != DefaultAction.None) \n', '            defaultTimeoutLength = _defaultTimeoutLength;\n', '        \n', '        payerString = _payerString;\n', '    }\n', '    \n', '    function getFullState()\n', '    public\n', '    constant\n', '    returns (State, string, address, string, uint, uint, uint, uint) {\n', '        return (state, payerString, recipient, recipientString, amountDeposited, amountBurned, amountReleased, defaultTriggerTime);\n', '    }\n', '    \n', '    function addFunds()\n', '    public\n', '    onlyPayer()\n', '    payable {\n', '        require(msg.value > 0);\n', '        \n', '        FundsAdded(msg.value);\n', '        amountDeposited += msg.value;\n', '        if (state == State.Expended) {\n', '            state = State.Committed;\n', '            Unexpended();\n', '        }\n', '    }\n', '    \n', '    function recoverFunds()\n', '    public\n', '    onlyPayer()\n', '    inState(State.Open)\n', '    {\n', '        FundsRecovered();\n', '        selfdestruct(payer);\n', '    }\n', '    \n', '    function commit()\n', '    public\n', '    inState(State.Open)\n', '    payable\n', '    {\n', '        require(msg.value >= commitThreshold);\n', '        \n', '        if (msg.value > 0) {\n', '            FundsAdded(msg.value);\n', '            amountDeposited += msg.value;\n', '        }\n', '        \n', '        recipient = msg.sender;\n', '        state = State.Committed;\n', '        Committed(recipient);\n', '        \n', '        if (defaultAction != DefaultAction.None) {\n', '            defaultTriggerTime = now + defaultTimeoutLength;\n', '        }\n', '    }\n', '    \n', '    function internalBurn(uint amount)\n', '    private\n', '    inState(State.Committed)\n', '    {\n', '        burnAddress.transfer(amount);\n', '        \n', '        amountBurned += amount;\n', '        FundsBurned(amount);\n', '        \n', '        if (this.balance == 0) {\n', '            state = State.Expended;\n', '            Expended();\n', '        }\n', '    }\n', '    \n', '    function burn(uint amount)\n', '    public\n', '    inState(State.Committed)\n', '    onlyPayer()\n', '    {\n', '        internalBurn(amount);\n', '    }\n', '    \n', '    function internalRelease(uint amount)\n', '    private\n', '    inState(State.Committed)\n', '    {\n', '        recipient.transfer(amount);\n', '        \n', '        amountReleased += amount;\n', '        FundsReleased(amount);\n', '        \n', '        if (this.balance == 0) {\n', '            state = State.Expended;\n', '            Expended();\n', '        }\n', '    }\n', '    \n', '    function release(uint amount)\n', '    public\n', '    inState(State.Committed)\n', '    onlyPayer()\n', '    {\n', '        internalRelease(amount);\n', '    }\n', '    \n', '    function setPayerString(string _string)\n', '    public\n', '    onlyPayer()\n', '    {\n', '        payerString = _string;\n', '        PayerStringUpdated(payerString);\n', '    }\n', '    \n', '    function setRecipientString(string _string)\n', '    public\n', '    onlyRecipient()\n', '    {\n', '        recipientString = _string;\n', '        RecipientStringUpdated(recipientString);\n', '    }\n', '    \n', '    function delayDefaultAction()\n', '    public\n', '    onlyPayerOrRecipient()\n', '    inState(State.Committed)\n', '    {\n', '        require(defaultAction != DefaultAction.None);\n', '        \n', '        defaultTriggerTime = now + defaultTimeoutLength;\n', '        DefaultActionDelayed();\n', '    }\n', '    \n', '    function callDefaultAction()\n', '    public\n', '    onlyPayerOrRecipient()\n', '    inState(State.Committed)\n', '    {\n', '        require(defaultAction != DefaultAction.None);\n', '        require(now >= defaultTriggerTime);\n', '        \n', '        if (defaultAction == DefaultAction.Burn) {\n', '            internalBurn(this.balance);\n', '        }\n', '        else if (defaultAction == DefaultAction.Release) {\n', '            internalRelease(this.balance);\n', '        }\n', '        DefaultActionCalled();\n', '    }\n', '}\n', '\n', 'contract BurnableOpenPaymentFactory {\n', '    event NewBOP(address newBOPAddress, address payer, uint commitThreshold, BurnableOpenPayment.DefaultAction defaultAction, uint defaultTimeoutLength, string initialPayerString);\n', '    \n', '    function newBurnableOpenPayment(address payer, uint commitThreshold, BurnableOpenPayment.DefaultAction defaultAction, uint defaultTimeoutLength, string initialPayerString)\n', '    public\n', '    payable\n', '    returns (address) {\n', '        //pass along any ether to the constructor\n', '        address newBOPAddr = (new BurnableOpenPayment).value(msg.value)(payer, commitThreshold, defaultAction, defaultTimeoutLength, initialPayerString);\n', '        NewBOP(newBOPAddr, payer, commitThreshold, defaultAction, defaultTimeoutLength, initialPayerString);\n', '        return newBOPAddr;\n', '    }\n', '}']
['//A BurnableOpenPayment is instantiated with a specified payer and a commitThreshold.\n', '//The recipient is not set when the contract is instantiated.\n', '\n', '//The constructor is payable, so the contract can be instantiated with initial funds.\n', '//Only the payer can fund the Payment after instantiation.\n', '\n', '//All behavior of the contract is directed by the payer, but\n', '//the payer can never directly recover the payment,\n', '//unless he calls the recover() function before anyone else commit()s.\n', '\n', '//Anyone can become the recipient by contributing the commitThreshold with commit().\n', "//The recipient will never be changed once it's been set via commit().\n", '\n', '//The payer can at any time choose to burn or release to the recipient any amount of funds.\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', 'contract BurnableOpenPayment {\n', '    //BOP will start with a payer but no recipient (recipient==0x0)\n', '    address public payer;\n', '    address public recipient;\n', '    address constant burnAddress = 0x0;\n', '    \n', '    //Note that these will track, but not influence the BOP logic.\n', '    uint public amountDeposited;\n', '    uint public amountBurned;\n', '    uint public amountReleased;\n', '    \n', '    //payerString and recipientString enable rudimentary communication/publishing.\n', '    //Although the two parties might quickly move to another medium with better privacy or convenience,\n', "    //beginning with this is nice because it's already trustless/transparent/signed/pseudonymous/etc.\n", '    string public payerString;\n', '    string public recipientString;\n', '    \n', '    //Amount of ether a prospective recipient must pay to permanently become the recipient. See commit().\n', '    uint public commitThreshold;\n', '    \n', '    //What if the payer falls off the face of the planet?\n', '    //A BOP is instantiated with a chosen defaultAction, which cannot be changed after instantiation.\n', '    enum DefaultAction {None, Release, Burn}\n', '    DefaultAction public defaultAction;\n', '    \n', '    //if defaultAction != None, how long should we wait allowing the default action to be called?\n', '    uint public defaultTimeoutLength;\n', '    \n', '    //Calculated from defaultTimeoutLength in commit(),\n', '    //and recaluclated whenever the payer (or possibly the recipient) calls delayDefaultAction()\n', '    uint public defaultTriggerTime;\n', '    \n', '    //Most action happens in the Committed state.\n', '    enum State {Open, Committed, Expended}\n', '    State public state;\n', '    //Note that a BOP cannot go from Committed back to Open, but it can go from Expended back to Committed\n', '    //(this would retain the committed recipient). Search for Expended and Unexpended events to see how this works.\n', '    \n', '    modifier inState(State s) { require(s == state); _; }\n', '    modifier onlyPayer() { require(msg.sender == payer); _; }\n', '    modifier onlyRecipient() { require(msg.sender == recipient); _; }\n', '    modifier onlyPayerOrRecipient() { require((msg.sender == payer) || (msg.sender == recipient)); _; }\n', '    \n', '    event Created(address payer, uint commitThreshold, BurnableOpenPayment.DefaultAction defaultAction, uint defaultTimeoutLength, string initialPayerString);\n', '    event FundsAdded(uint amount);//The payer has added funds to the BOP.\n', '    event PayerStringUpdated(string newPayerString);\n', '    event RecipientStringUpdated(string newRecipientString);\n', '    event FundsRecovered();\n', '    event Committed(address recipient);\n', '    event FundsBurned(uint amount);\n', '    event FundsReleased(uint amount);\n', '    event Expended();\n', '    event Unexpended();\n', '    event DefaultActionDelayed();\n', '    event DefaultActionCalled();\n', '    \n', '    function BurnableOpenPayment(address _payer, uint _commitThreshold, DefaultAction _defaultAction, uint _defaultTimeoutLength, string _payerString)\n', '    public\n', '    payable {\n', '        Created(_payer, _commitThreshold, _defaultAction, _defaultTimeoutLength, _payerString);\n', '        \n', '        if (msg.value > 0) {\n', '            FundsAdded(msg.value);\n', '            amountDeposited += msg.value;\n', '        }\n', '            \n', '        state = State.Open;\n', '        payer = _payer;\n', '        \n', '        commitThreshold = _commitThreshold;\n', '        \n', '        defaultAction = _defaultAction;\n', '        if (defaultAction != DefaultAction.None) \n', '            defaultTimeoutLength = _defaultTimeoutLength;\n', '        \n', '        payerString = _payerString;\n', '    }\n', '    \n', '    function getFullState()\n', '    public\n', '    constant\n', '    returns (State, string, address, string, uint, uint, uint, uint) {\n', '        return (state, payerString, recipient, recipientString, amountDeposited, amountBurned, amountReleased, defaultTriggerTime);\n', '    }\n', '    \n', '    function addFunds()\n', '    public\n', '    onlyPayer()\n', '    payable {\n', '        require(msg.value > 0);\n', '        \n', '        FundsAdded(msg.value);\n', '        amountDeposited += msg.value;\n', '        if (state == State.Expended) {\n', '            state = State.Committed;\n', '            Unexpended();\n', '        }\n', '    }\n', '    \n', '    function recoverFunds()\n', '    public\n', '    onlyPayer()\n', '    inState(State.Open)\n', '    {\n', '        FundsRecovered();\n', '        selfdestruct(payer);\n', '    }\n', '    \n', '    function commit()\n', '    public\n', '    inState(State.Open)\n', '    payable\n', '    {\n', '        require(msg.value >= commitThreshold);\n', '        \n', '        if (msg.value > 0) {\n', '            FundsAdded(msg.value);\n', '            amountDeposited += msg.value;\n', '        }\n', '        \n', '        recipient = msg.sender;\n', '        state = State.Committed;\n', '        Committed(recipient);\n', '        \n', '        if (defaultAction != DefaultAction.None) {\n', '            defaultTriggerTime = now + defaultTimeoutLength;\n', '        }\n', '    }\n', '    \n', '    function internalBurn(uint amount)\n', '    private\n', '    inState(State.Committed)\n', '    {\n', '        burnAddress.transfer(amount);\n', '        \n', '        amountBurned += amount;\n', '        FundsBurned(amount);\n', '        \n', '        if (this.balance == 0) {\n', '            state = State.Expended;\n', '            Expended();\n', '        }\n', '    }\n', '    \n', '    function burn(uint amount)\n', '    public\n', '    inState(State.Committed)\n', '    onlyPayer()\n', '    {\n', '        internalBurn(amount);\n', '    }\n', '    \n', '    function internalRelease(uint amount)\n', '    private\n', '    inState(State.Committed)\n', '    {\n', '        recipient.transfer(amount);\n', '        \n', '        amountReleased += amount;\n', '        FundsReleased(amount);\n', '        \n', '        if (this.balance == 0) {\n', '            state = State.Expended;\n', '            Expended();\n', '        }\n', '    }\n', '    \n', '    function release(uint amount)\n', '    public\n', '    inState(State.Committed)\n', '    onlyPayer()\n', '    {\n', '        internalRelease(amount);\n', '    }\n', '    \n', '    function setPayerString(string _string)\n', '    public\n', '    onlyPayer()\n', '    {\n', '        payerString = _string;\n', '        PayerStringUpdated(payerString);\n', '    }\n', '    \n', '    function setRecipientString(string _string)\n', '    public\n', '    onlyRecipient()\n', '    {\n', '        recipientString = _string;\n', '        RecipientStringUpdated(recipientString);\n', '    }\n', '    \n', '    function delayDefaultAction()\n', '    public\n', '    onlyPayerOrRecipient()\n', '    inState(State.Committed)\n', '    {\n', '        require(defaultAction != DefaultAction.None);\n', '        \n', '        defaultTriggerTime = now + defaultTimeoutLength;\n', '        DefaultActionDelayed();\n', '    }\n', '    \n', '    function callDefaultAction()\n', '    public\n', '    onlyPayerOrRecipient()\n', '    inState(State.Committed)\n', '    {\n', '        require(defaultAction != DefaultAction.None);\n', '        require(now >= defaultTriggerTime);\n', '        \n', '        if (defaultAction == DefaultAction.Burn) {\n', '            internalBurn(this.balance);\n', '        }\n', '        else if (defaultAction == DefaultAction.Release) {\n', '            internalRelease(this.balance);\n', '        }\n', '        DefaultActionCalled();\n', '    }\n', '}\n', '\n', 'contract BurnableOpenPaymentFactory {\n', '    event NewBOP(address newBOPAddress, address payer, uint commitThreshold, BurnableOpenPayment.DefaultAction defaultAction, uint defaultTimeoutLength, string initialPayerString);\n', '    \n', '    function newBurnableOpenPayment(address payer, uint commitThreshold, BurnableOpenPayment.DefaultAction defaultAction, uint defaultTimeoutLength, string initialPayerString)\n', '    public\n', '    payable\n', '    returns (address) {\n', '        //pass along any ether to the constructor\n', '        address newBOPAddr = (new BurnableOpenPayment).value(msg.value)(payer, commitThreshold, defaultAction, defaultTimeoutLength, initialPayerString);\n', '        NewBOP(newBOPAddr, payer, commitThreshold, defaultAction, defaultTimeoutLength, initialPayerString);\n', '        return newBOPAddr;\n', '    }\n', '}']
