['pragma solidity ^0.4.11;\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', '    // this function isn&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function owner() public constant returns (address owner) { owner; }\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'contract IERC20Token {\n', '    // these functions aren&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function name() public constant returns (string name) { name; }\n', '    function symbol() public constant returns (string symbol) { symbol; }\n', '    function decimals() public constant returns (uint8 decimals) { decimals; }\n', '    function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '}\n', '\n', '/*\n', '    Token Holder interface\n', '*/\n', 'contract ITokenHolder is IOwned {\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\n', '}\n', '\n', '/*\n', '    Smart Token interface\n', '*/\n', 'contract ISmartToken is ITokenHolder, IERC20Token {\n', '    function disableTransfers(bool _disable) public;\n', '    function issue(address _to, uint256 _amount) public;\n', '    function destroy(address _from, uint256 _amount) public;\n', '}\n', '\n', '/*\n', '    Overflow protected math functions\n', '*/\n', 'contract SafeMath {\n', '    /**\n', '        constructor\n', '    */\n', '    function SafeMath() {\n', '    }\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', '/**\n', '    ERC20 Standard Token implementation\n', '*/\n', 'contract ERC20Token is IERC20Token, SafeMath {\n', '    string public standard = &#39;Token 0.1&#39;;\n', '    string public name = &#39;&#39;;\n', '    string public symbol = &#39;&#39;;\n', '    uint8 public decimals = 0;\n', '    uint256 public totalSupply = 0;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    /**\n', '        @dev constructor\n', '\n', '        @param _name        token name\n', '        @param _symbol      token symbol\n', '        @param _decimals    decimal points, for display purposes\n', '    */\n', '    function ERC20Token(string _name, string _symbol, uint8 _decimals) {\n', '        require(bytes(_name).length > 0 && bytes(_symbol).length > 0); // validate input\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    // validates an address - currently only checks that it isn&#39;t null\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev send coins\n', '        throws on any error rather then return a false flag to minimize user errors\n', '\n', '        @param _to      target address\n', '        @param _value   transfer amount\n', '\n', '        @return true if the transfer was successful, false if it wasn&#39;t\n', '    */\n', '    function transfer(address _to, uint256 _value)\n', '        public\n', '        validAddress(_to)\n', '        returns (bool success)\n', '    {\n', '        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @dev an account/contract attempts to get the coins\n', '        throws on any error rather then return a false flag to minimize user errors\n', '\n', '        @param _from    source address\n', '        @param _to      target address\n', '        @param _value   transfer amount\n', '\n', '        @return true if the transfer was successful, false if it wasn&#39;t\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        public\n', '        validAddress(_from)\n', '        validAddress(_to)\n', '        returns (bool success)\n', '    {\n', '        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);\n', '        balanceOf[_from] = safeSub(balanceOf[_from], _value);\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @dev allow another account/contract to spend some tokens on your behalf\n', '        throws on any error rather then return a false flag to minimize user errors\n', '\n', '        also, to minimize the risk of the approve/transferFrom attack vector\n', '        (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\n', '        in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\n', '\n', '        @param _spender approved address\n', '        @param _value   allowance amount\n', '\n', '        @return true if the approval was successful, false if it wasn&#39;t\n', '    */\n', '    function approve(address _spender, uint256 _value)\n', '        public\n', '        validAddress(_spender)\n', '        returns (bool success)\n', '    {\n', '        // if the allowance isn&#39;t 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\n', '        require(_value == 0 || allowance[msg.sender][_spender] == 0);\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still need to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', '/*\n', '    We consider every contract to be a &#39;token holder&#39; since it&#39;s currently not possible\n', '    for a contract to deny receiving tokens.\n', '\n', '    The TokenHolder&#39;s contract sole purpose is to provide a safety mechanism that allows\n', '    the owner to send tokens that were sent to the contract by mistake back to their sender.\n', '*/\n', 'contract TokenHolder is ITokenHolder, Owned {\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function TokenHolder() {\n', '    }\n', '\n', '    // validates an address - currently only checks that it isn&#39;t null\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev withdraws tokens held by the contract and sends them to an account\n', '        can only be called by the owner\n', '\n', '        @param _token   ERC20 token contract address\n', '        @param _to      account to receive the new amount\n', '        @param _amount  amount to withdraw\n', '    */\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_token)\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        assert(_token.transfer(_to, _amount));\n', '    }\n', '}\n', '\n', '/*\n', '    Smart Token v0.2\n', '\n', '    &#39;Owned&#39; is specified here for readability reasons\n', '*/\n', 'contract SmartToken is ISmartToken, ERC20Token, Owned, TokenHolder {\n', '    string public version = &#39;0.2&#39;;\n', '\n', '    bool public transfersEnabled = true;    // true if transfer/transferFrom are enabled, false if not\n', '\n', '    // triggered when a smart token is deployed - the _token address is defined for forward compatibility, in case we want to trigger the event from a factory\n', '    event NewSmartToken(address _token);\n', '    // triggered when the total supply is increased\n', '    event Issuance(uint256 _amount);\n', '    // triggered when the total supply is decreased\n', '    event Destruction(uint256 _amount);\n', '\n', '    /**\n', '        @dev constructor\n', '\n', '        @param _name       token name\n', '        @param _symbol     token short symbol, 1-6 characters\n', '        @param _decimals   for display purposes only\n', '    */\n', '    function SmartToken(string _name, string _symbol, uint8 _decimals)\n', '        ERC20Token(_name, _symbol, _decimals)\n', '    {\n', '        require(bytes(_symbol).length <= 6); // validate input\n', '        NewSmartToken(address(this));\n', '    }\n', '\n', '    // allows execution only when transfers aren&#39;t disabled\n', '    modifier transfersAllowed {\n', '        assert(transfersEnabled);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev disables/enables transfers\n', '        can only be called by the contract owner\n', '\n', '        @param _disable    true to disable transfers, false to enable them\n', '    */\n', '    function disableTransfers(bool _disable) public ownerOnly {\n', '        transfersEnabled = !_disable;\n', '    }\n', '\n', '    /**\n', '        @dev increases the token supply and sends the new tokens to an account\n', '        can only be called by the contract owner\n', '\n', '        @param _to         account to receive the new amount\n', '        @param _amount     amount to increase the supply by\n', '    */\n', '    function issue(address _to, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        totalSupply = safeAdd(totalSupply, _amount);\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _amount);\n', '\n', '        Issuance(_amount);\n', '        Transfer(this, _to, _amount);\n', '    }\n', '\n', '    /**\n', '        @dev removes tokens from an account and decreases the token supply\n', '        can only be called by the contract owner\n', '\n', '        @param _from       account to remove the amount from\n', '        @param _amount     amount to decrease the supply by\n', '    */\n', '    function destroy(address _from, uint256 _amount)\n', '        public\n', '        ownerOnly\n', '    {\n', '        balanceOf[_from] = safeSub(balanceOf[_from], _amount);\n', '        totalSupply = safeSub(totalSupply, _amount);\n', '\n', '        Transfer(_from, this, _amount);\n', '        Destruction(_amount);\n', '    }\n', '\n', '    // ERC20 standard method overrides with some extra functionality\n', '\n', '    /**\n', '        @dev send coins\n', '        throws on any error rather then return a false flag to minimize user errors\n', '        note that when transferring to the smart token&#39;s address, the coins are actually destroyed\n', '\n', '        @param _to      target address\n', '        @param _value   transfer amount\n', '\n', '        @return true if the transfer was successful, false if it wasn&#39;t\n', '    */\n', '    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) {\n', '        assert(super.transfer(_to, _value));\n', '\n', '        // transferring to the contract address destroys tokens\n', '        if (_to == address(this)) {\n', '            balanceOf[_to] -= _value;\n', '            totalSupply -= _value;\n', '            Destruction(_value);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @dev an account/contract attempts to get the coins\n', '        throws on any error rather then return a false flag to minimize user errors\n', '        note that when transferring to the smart token&#39;s address, the coins are actually destroyed\n', '\n', '        @param _from    source address\n', '        @param _to      target address\n', '        @param _value   transfer amount\n', '\n', '        @return true if the transfer was successful, false if it wasn&#39;t\n', '    */\n', '    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) {\n', '        assert(super.transferFrom(_from, _to, _value));\n', '\n', '        // transferring to the contract address destroys tokens\n', '        if (_to == address(this)) {\n', '            balanceOf[_to] -= _value;\n', '            totalSupply -= _value;\n', '            Destruction(_value);\n', '        }\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic authorization control functions, this simplifies\n', '/// & the implementation of "user permissions".\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwnerCandidate;\n', '\n', '    event OwnershipRequested(address indexed _by, address indexed _to);\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        if (msg.sender != owner) {\n', '            throw;\n', '        }\n', '\n', '        _;\n', '    }\n', '\n', '    /// @dev Proposes to transfer control of the contract to a newOwnerCandidate.\n', '    /// @param _newOwnerCandidate address The address to transfer ownership to.\n', '    function transferOwnership(address _newOwnerCandidate) onlyOwner {\n', '        require(_newOwnerCandidate != address(0));\n', '\n', '        newOwnerCandidate = _newOwnerCandidate;\n', '\n', '        OwnershipRequested(msg.sender, newOwnerCandidate);\n', '    }\n', '\n', '    /// @dev Accept ownership transfer. This method needs to be called by the perviously proposed owner.\n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwnerCandidate) {\n', '            owner = newOwnerCandidate;\n', '            newOwnerCandidate = address(0);\n', '\n', '            OwnershipTransferred(owner, newOwnerCandidate);\n', '        }\n', '    }\n', '}\n', '\n', '/// @title Math operations with safety checks\n', 'library SaferMath {\n', '    function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '\n', '/// @title Stox Smart Token\n', 'contract StoxSmartToken is SmartToken {\n', '    function StoxSmartToken() SmartToken(&#39;Stox&#39;, &#39;STX&#39;, 18) {\n', '        disableTransfers(true);\n', '    }\n', '}\n', '\n', '\n', '/// @title Vesting trustee\n', 'contract Trustee is Ownable {\n', '    using SaferMath for uint256;\n', '\n', '    // The address of the STX ERC20 token.\n', '    StoxSmartToken public stox;\n', '\n', '    struct Grant {\n', '        uint256 value;\n', '        uint256 start;\n', '        uint256 cliff;\n', '        uint256 end;\n', '        uint256 transferred;\n', '        bool revokable;\n', '    }\n', '\n', '    // Grants holder.\n', '    mapping (address => Grant) public grants;\n', '\n', '    // Total tokens available for vesting.\n', '    uint256 public totalVesting;\n', '\n', '    event NewGrant(address indexed _from, address indexed _to, uint256 _value);\n', '    event UnlockGrant(address indexed _holder, uint256 _value);\n', '    event RevokeGrant(address indexed _holder, uint256 _refund);\n', '\n', '    /// @dev Constructor that initializes the address of the StoxSmartToken contract.\n', '    /// @param _stox StoxSmartToken The address of the previously deployed StoxSmartToken smart contract.\n', '    function Trustee(StoxSmartToken _stox) {\n', '        require(_stox != address(0));\n', '\n', '        stox = _stox;\n', '    }\n', '\n', '    /// @dev Grant tokens to a specified address.\n', '    /// @param _to address The address to grant tokens to.\n', '    /// @param _value uint256 The amount of tokens to be granted.\n', '    /// @param _start uint256 The beginning of the vesting period.\n', '    /// @param _cliff uint256 Duration of the cliff period.\n', '    /// @param _end uint256 The end of the vesting period.\n', '    /// @param _revokable bool Whether the grant is revokable or not.\n', '    function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end, bool _revokable)\n', '        public onlyOwner {\n', '        require(_to != address(0));\n', '        require(_value > 0);\n', '\n', '        // Make sure that a single address can be granted tokens only once.\n', '        require(grants[_to].value == 0);\n', '\n', '        // Check for date inconsistencies that may cause unexpected behavior.\n', '        require(_start <= _cliff && _cliff <= _end);\n', '\n', '        // Check that this grant doesn&#39;t exceed the total amount of tokens currently available for vesting.\n', '        require(totalVesting.add(_value) <= stox.balanceOf(address(this)));\n', '\n', '        // Assign a new grant.\n', '        grants[_to] = Grant({\n', '            value: _value,\n', '            start: _start,\n', '            cliff: _cliff,\n', '            end: _end,\n', '            transferred: 0,\n', '            revokable: _revokable\n', '        });\n', '\n', '        // Tokens granted, reduce the total amount available for vesting.\n', '        totalVesting = totalVesting.add(_value);\n', '\n', '        NewGrant(msg.sender, _to, _value);\n', '    }\n', '\n', '    /// @dev Revoke the grant of tokens of a specifed address.\n', '    /// @param _holder The address which will have its tokens revoked.\n', '    function revoke(address _holder) public onlyOwner {\n', '        Grant grant = grants[_holder];\n', '\n', '        require(grant.revokable);\n', '\n', '        // Send the remaining STX back to the owner.\n', '        uint256 refund = grant.value.sub(grant.transferred);\n', '\n', '        // Remove the grant.\n', '        delete grants[_holder];\n', '\n', '        totalVesting = totalVesting.sub(refund);\n', '        stox.transfer(msg.sender, refund);\n', '\n', '        RevokeGrant(_holder, refund);\n', '    }\n', '\n', '    /// @dev Calculate the total amount of vested tokens of a holder at a given time.\n', '    /// @param _holder address The address of the holder.\n', '    /// @param _time uint256 The specific time.\n', '    /// @return a uint256 representing a holder&#39;s total amount of vested tokens.\n', '    function vestedTokens(address _holder, uint256 _time) public constant returns (uint256) {\n', '        Grant grant = grants[_holder];\n', '        if (grant.value == 0) {\n', '            return 0;\n', '        }\n', '\n', '        return calculateVestedTokens(grant, _time);\n', '    }\n', '\n', '    /// @dev Calculate amount of vested tokens at a specifc time.\n', '    /// @param _grant Grant The vesting grant.\n', '    /// @param _time uint256 The time to be checked\n', '    /// @return An uint256 representing the amount of vested tokens of a specific grant.\n', '    ///   |                         _/--------   vestedTokens rect\n', '    ///   |                       _/\n', '    ///   |                     _/\n', '    ///   |                   _/\n', '    ///   |                 _/\n', '    ///   |                /\n', '    ///   |              .|\n', '    ///   |            .  |\n', '    ///   |          .    |\n', '    ///   |        .      |\n', '    ///   |      .        |\n', '    ///   |    .          |\n', '    ///   +===+===========+---------+----------> time\n', '    ///     Start       Cliff      End\n', '    function calculateVestedTokens(Grant _grant, uint256 _time) private constant returns (uint256) {\n', '        // If we&#39;re before the cliff, then nothing is vested.\n', '        if (_time < _grant.cliff) {\n', '            return 0;\n', '        }\n', '\n', '        // If we&#39;re after the end of the vesting period - everything is vested;\n', '        if (_time >= _grant.end) {\n', '            return _grant.value;\n', '        }\n', '\n', '        // Interpolate all vested tokens: vestedTokens = tokens/// (time - start) / (end - start)\n', '         return _grant.value.mul(_time.sub(_grant.start)).div(_grant.end.sub(_grant.start));\n', '    }\n', '\n', '    /// @dev Unlock vested tokens and transfer them to their holder.\n', '    /// @return a uint256 representing the amount of vested tokens transferred to their holder.\n', '    function unlockVestedTokens() public {\n', '        Grant grant = grants[msg.sender];\n', '        require(grant.value != 0);\n', '\n', '        // Get the total amount of vested tokens, acccording to grant.\n', '        uint256 vested = calculateVestedTokens(grant, now);\n', '        if (vested == 0) {\n', '            return;\n', '        }\n', '\n', '        // Make sure the holder doesn&#39;t transfer more than what he already has.\n', '        uint256 transferable = vested.sub(grant.transferred);\n', '        if (transferable == 0) {\n', '            return;\n', '        }\n', '\n', '        grant.transferred = grant.transferred.add(transferable);\n', '        totalVesting = totalVesting.sub(transferable);\n', '        stox.transfer(msg.sender, transferable);\n', '\n', '        UnlockGrant(msg.sender, transferable);\n', '    }\n', '}\n', '\n', '\n', '/// @title Stox Smart Token sale\n', 'contract StoxSmartTokenSale is Ownable {\n', '    using SaferMath for uint256;\n', '\n', '    uint256 public constant DURATION = 14 days;\n', '\n', '    bool public isFinalized = false;\n', '    bool public isDistributed = false;\n', '\n', '    // The address of the STX ERC20 token.\n', '    StoxSmartToken public stox;\n', '\n', '    // The address of the token allocation trustee;\n', '    Trustee public trustee;\n', '\n', '    uint256 public startTime = 0;\n', '    uint256 public endTime = 0;\n', '    address public fundingRecipient;\n', '\n', '    uint256 public tokensSold = 0;\n', '\n', '    // TODO: update to the correct values.\n', '    uint256 public constant ETH_CAP = 148000;\n', '    uint256 public constant EXCHANGE_RATE = 200; // 200 STX for ETH\n', '    uint256 public constant TOKEN_SALE_CAP = ETH_CAP * EXCHANGE_RATE * 10 ** 18;\n', '\n', '    event TokensIssued(address indexed _to, uint256 _tokens);\n', '\n', '    /// @dev Throws if called when not during sale.\n', '    modifier onlyDuringSale() {\n', '        if (tokensSold >= TOKEN_SALE_CAP || now < startTime || now >= endTime) {\n', '            throw;\n', '        }\n', '\n', '        _;\n', '    }\n', '\n', '    /// @dev Throws if called before sale ends.\n', '    modifier onlyAfterSale() {\n', '        if (!(tokensSold >= TOKEN_SALE_CAP || now >= endTime)) {\n', '            throw;\n', '        }\n', '\n', '        _;\n', '    }\n', '\n', '    /// @dev Constructor that initializes the sale conditions.\n', '    /// @param _fundingRecipient address The address of the funding recipient.\n', '    /// @param _startTime uint256 The start time of the token sale.\n', '    function StoxSmartTokenSale(address _stox, address _fundingRecipient, uint256 _startTime) {\n', '        require(_stox != address(0));\n', '        require(_fundingRecipient != address(0));\n', '        require(_startTime > now);\n', '\n', '        stox = StoxSmartToken(_stox);\n', '\n', '        fundingRecipient = _fundingRecipient;\n', '        startTime = _startTime;\n', '        endTime = startTime + DURATION;\n', '    }\n', '\n', '    /// @dev Distributed tokens to the partners who have participated during the pre-sale.\n', '    function distributePartnerTokens() external onlyOwner {\n', '        require(!isDistributed);\n', '\n', '        assert(tokensSold == 0);\n', '        assert(stox.totalSupply() == 0);\n', '\n', '        // Distribute strategic tokens to partners. Please note, that this address doesn&#39;t represent a single entity or\n', '        // person and will be only used to distribute tokens to 30~ partners.\n', '        //\n', '        // Please expect to see token transfers from this address in the first 24 hours after the token sale ends.\n', '        issueTokens(0x9065260ef6830f6372F1Bde408DeC57Fe3150530, 14800000 * 10 ** 18);\n', '\n', '        isDistributed = true;\n', '    }\n', '\n', '    /// @dev Finalizes the token sale event.\n', '    function finalize() external onlyAfterSale {\n', '        if (isFinalized) {\n', '            throw;\n', '        }\n', '\n', '        // Grant vesting grants.\n', '        //\n', '        // TODO: use real addresses.\n', '        trustee = new Trustee(stox);\n', '\n', '        // Since only 50% of the tokens will be sold, we will automatically issue the same amount of sold STX to the\n', '        // trustee.\n', '        uint256 unsoldTokens = tokensSold;\n', '\n', '        // Issue 55% of the remaining tokens (== 27.5%) go to strategic parternships.\n', '        uint256 strategicPartnershipTokens = unsoldTokens.mul(55).div(100);\n', '\n', '        // Note: we will substract the bonus tokens from this grant, since they were already issued for the pre-sale\n', '        // strategic partners and should&#39;ve been taken from this allocation.\n', '        stox.issue(0xbC14105ccDdeAadB96Ba8dCE18b40C45b6bACf58, strategicPartnershipTokens);\n', '\n', '        // Issue the remaining tokens as vesting grants:\n', '        stox.issue(trustee, unsoldTokens.sub(strategicPartnershipTokens));\n', '\n', '        // 25% of the remaining tokens (== 12.5%) go to Invest.com, at uniform 12 months vesting schedule.\n', '        trustee.grant(0xb54c6a870d4aD65e23d471Fb7941aD271D323f5E, unsoldTokens.mul(25).div(100), now, now,\n', '            now.add(1 years), true);\n', '\n', '        // 20% of the remaining tokens (== 10%) go to Stox team, at uniform 24 months vesting schedule.\n', '        trustee.grant(0x4eB4Cd1D125d9d281709Ff38d65b99a6927b46c1, unsoldTokens.mul(20).div(100), now, now,\n', '            now.add(2 years), true);\n', '\n', '        // Re-enable transfers after the token sale.\n', '        stox.disableTransfers(false);\n', '\n', '        isFinalized = true;\n', '    }\n', '\n', '    /// @dev Create and sell tokens to the caller.\n', '    /// @param _recipient address The address of the recipient.\n', '    function create(address _recipient) public payable onlyDuringSale {\n', '        require(_recipient != address(0));\n', '        require(msg.value > 0);\n', '\n', '        assert(isDistributed);\n', '\n', '        uint256 tokens = SaferMath.min256(msg.value.mul(EXCHANGE_RATE), TOKEN_SALE_CAP.sub(tokensSold));\n', '        uint256 contribution = tokens.div(EXCHANGE_RATE);\n', '\n', '        issueTokens(_recipient, tokens);\n', '\n', '        // Transfer the funds to the funding recipient.\n', '        fundingRecipient.transfer(contribution);\n', '\n', '        // Refund the msg.sender, in the case that not all of its ETH was used. This can happen only when selling the\n', '        // last chunk of STX.\n', '        uint256 refund = msg.value.sub(contribution);\n', '        if (refund > 0) {\n', '            msg.sender.transfer(refund);\n', '        }\n', '    }\n', '\n', '    /// @dev Issues tokens for the recipient.\n', '    /// @param _recipient address The address of the recipient.\n', '    /// @param _tokens uint256 The amount of tokens to issue.\n', '    function issueTokens(address _recipient, uint256 _tokens) private {\n', '        // Update total sold tokens.\n', '        tokensSold = tokensSold.add(_tokens);\n', '\n', '        stox.issue(_recipient, _tokens);\n', '\n', '        TokensIssued(_recipient, _tokens);\n', '    }\n', '\n', '    /// @dev Fallback function that will delegate the request to create.\n', '    function () external payable onlyDuringSale {\n', '        create(msg.sender);\n', '    }\n', '\n', '    /// @dev Proposes to transfer control of the StoxSmartToken contract to a new owner.\n', '    /// @param _newOwnerCandidate address The address to transfer ownership to.\n', '    ///\n', '    /// Note that:\n', '    ///   1. The new owner will need to call StoxSmartToken&#39;s acceptOwnership directly in order to accept the ownership.\n', '    ///   2. Calling this method during the token sale will prevent the token sale to continue, since only the owner of\n', '    ///      the StoxSmartToken contract can issue new tokens.\n', '    function transferSmartTokenOwnership(address _newOwnerCandidate) external onlyOwner {\n', '        stox.transferOwnership(_newOwnerCandidate);\n', '    }\n', '\n', '    /// @dev Accepts new ownership on behalf of the StoxSmartToken contract. This can be used, by the token sale\n', '    /// contract itself to claim back ownership of the StoxSmartToken contract.\n', '    function acceptSmartTokenOwnership() external onlyOwner {\n', '        stox.acceptOwnership();\n', '    }\n', '\n', '    /// @dev Proposes to transfer control of the Trustee contract to a new owner.\n', '    /// @param _newOwnerCandidate address The address to transfer ownership to.\n', '    ///\n', '    /// Note that:\n', '    ///   1. The new owner will need to call Trustee&#39;s acceptOwnership directly in order to accept the ownership.\n', '    ///   2. Calling this method during the token sale won&#39;t be possible, as the Trustee is only created after its\n', '    ///      finalization.\n', '    function transferTrusteeOwnership(address _newOwnerCandidate) external onlyOwner {\n', '        trustee.transferOwnership(_newOwnerCandidate);\n', '    }\n', '\n', '    /// @dev Accepts new ownership on behalf of the Trustee contract. This can be used, by the token sale\n', '    /// contract itself to claim back ownership of the Trustee contract.\n', '    function acceptTrusteeOwnership() external onlyOwner {\n', '        trustee.acceptOwnership();\n', '    }\n', '}']