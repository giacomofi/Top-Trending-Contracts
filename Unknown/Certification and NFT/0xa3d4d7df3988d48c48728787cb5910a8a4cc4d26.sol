['contract Etheropt {\n', '\n', '  struct Option {\n', '    int strike;\n', '  }\n', '  struct Position {\n', '    mapping(uint => int) positions;\n', '    int cash;\n', '    bool expired;\n', '    bool hasPosition;\n', '  }\n', '  struct OptionChain {\n', '    uint expiration;\n', '    string underlying;\n', '    uint margin;\n', '    uint realityID;\n', '    bytes32 factHash;\n', '    address ethAddr;\n', '    mapping(uint => Option) options;\n', '    uint numOptions;\n', '    bool expired;\n', '    mapping(address => Position) positions;\n', '    uint numPositions;\n', '    uint numPositionsExpired;\n', '  }\n', '  mapping(uint => OptionChain) optionChains;\n', '  uint numOptionChains;\n', '  struct Account {\n', '    address user;\n', '    int capital;\n', '  }\n', '  mapping(bytes32 => int) orderFills; //keeps track of cumulative order fills\n', '  struct MarketMaker {\n', '    address user;\n', '    string server;\n', '  }\n', '  mapping(uint => MarketMaker) marketMakers; //starts at 1\n', '  uint public numMarketMakers = 0;\n', '  mapping(address => uint) marketMakerIDs;\n', '  mapping(uint => Account) accounts;\n', '  uint public numAccounts;\n', '  mapping(address => uint) accountIDs; //starts at 1\n', '\n', '  function Market() {\n', '  }\n', '\n', '  function getAccountID(address user) constant returns(uint) {\n', '    return accountIDs[user];\n', '  }\n', '\n', '  function getAccount(uint accountID) constant returns(address) {\n', '    return accounts[accountID].user;\n', '  }\n', '\n', '  function addFunds() {\n', '    if (accountIDs[msg.sender]>0) {\n', '      accounts[accountIDs[msg.sender]].capital += int(msg.value);\n', '    } else {\n', '      uint accountID = ++numAccounts;\n', '      accounts[accountID].user = msg.sender;\n', '      accounts[accountID].capital += int(msg.value);\n', '      accountIDs[msg.sender] = accountID;\n', '    }\n', '  }\n', '\n', '  function withdrawFunds(uint amount) {\n', '    if (accountIDs[msg.sender]>0) {\n', '      if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {\n', '        accounts[accountIDs[msg.sender]].capital -= int(amount);\n', '        msg.sender.send(amount);\n', '      }\n', '    }\n', '  }\n', '\n', '  function getFunds(address user, bool onlyAvailable) constant returns(int) {\n', '    if (accountIDs[user]>0) {\n', '      if (onlyAvailable == false) {\n', '        return accounts[accountIDs[user]].capital;\n', '      } else {\n', '        return accounts[accountIDs[user]].capital + getMaxLossAfterTrade(user, 0, 0, 0, 0);\n', '      }\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function getFundsAndAvailable(address user) constant returns(int, int) {\n', '    return (getFunds(user, false), getFunds(user, true));\n', '  }\n', '\n', '  function marketMaker(string server) {\n', '    if (msg.value>0) throw;\n', '    if (marketMakerIDs[msg.sender]>0) {\n', '      marketMakers[marketMakerIDs[msg.sender]].server = server;\n', '    } else {\n', '      int funds = getFunds(marketMakers[i].user, false);\n', '      uint marketMakerID = 0;\n', '      if (numMarketMakers<6) {\n', '        marketMakerID = ++numMarketMakers;\n', '      } else {\n', '        for (uint i=2; i<=numMarketMakers; i++) {\n', '          if (getFunds(marketMakers[i].user, false)<=funds && (marketMakerID==0 || getFunds(marketMakers[i].user, false)<getFunds(marketMakers[marketMakerID].user, false))) {\n', '            marketMakerID = i;\n', '          }\n', '        }\n', '      }\n', '      if (marketMakerID>0) {\n', '        marketMakerIDs[marketMakers[marketMakerID].user] = 0;\n', '        marketMakers[marketMakerID].user = msg.sender;\n', '        marketMakers[marketMakerID].server = server;\n', '        marketMakerIDs[msg.sender] = marketMakerID;\n', '      } else {\n', '        throw;\n', '      }\n', '    }\n', '  }\n', '\n', '  function getMarketMakers() constant returns(string, string, string, string, string, string) {\n', '    string[] memory servers = new string[](6);\n', '    for (uint i=1; i<=numMarketMakers; i++) {\n', '      servers[i-1] = marketMakers[i].server;\n', '    }\n', '    return (servers[0], servers[1], servers[2], servers[3], servers[4], servers[5]);\n', '  }\n', '\n', '  function getMarketMakerFunds() constant returns(int, int, int, int, int, int) {\n', '    int[] memory funds = new int[](6);\n', '    for (uint i=1; i<=numMarketMakers; i++) {\n', '      funds[i-1] = getFunds(marketMakers[i].user, false);\n', '    }\n', '    return (funds[0], funds[1], funds[2], funds[3], funds[4], funds[5]);\n', '  }\n', '\n', '  function getOptionChain(uint optionChainID) constant returns (uint, string, uint, uint, bytes32, address) {\n', '    return (optionChains[optionChainID].expiration, optionChains[optionChainID].underlying, optionChains[optionChainID].margin, optionChains[optionChainID].realityID, optionChains[optionChainID].factHash, optionChains[optionChainID].ethAddr);\n', '  }\n', '\n', '  function getMarket(address user) constant returns(uint[], int[], int[], int[]) {\n', '    uint[] memory optionIDs = new uint[](60);\n', '    int[] memory strikes = new int[](60);\n', '    int[] memory positions = new int[](60);\n', '    int[] memory cashes = new int[](60);\n', '    uint z = 0;\n', '    for (int optionChainID=int(numOptionChains)-1; optionChainID>=0 && z<60; optionChainID--) {\n', '      if (optionChains[uint(optionChainID)].expired == false) {\n', '        for (uint optionID=0; optionID<optionChains[uint(optionChainID)].numOptions; optionID++) {\n', '          optionIDs[z] = uint(optionChainID)*1000 + optionID;\n', '          strikes[z] = optionChains[uint(optionChainID)].options[optionID].strike;\n', '          positions[z] = optionChains[uint(optionChainID)].positions[user].positions[optionID];\n', '          cashes[z] = optionChains[uint(optionChainID)].positions[user].cash;\n', '          z++;\n', '        }\n', '      }\n', '    }\n', '    return (optionIDs, strikes, positions, cashes);\n', '  }\n', '\n', '  function expire(uint accountID, uint optionChainID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {\n', '    if (optionChains[optionChainID].expired == false) {\n', '      if (ecrecover(sha3(optionChains[optionChainID].factHash, value), v, r, s) == optionChains[optionChainID].ethAddr) {\n', '        uint lastAccount = numAccounts;\n', '        if (accountID==0) {\n', '          accountID = 1;\n', '        } else {\n', '          lastAccount = accountID;\n', '        }\n', '        for (accountID=accountID; accountID<=lastAccount; accountID++) {\n', '          if (optionChains[optionChainID].positions[accounts[accountID].user].expired == false) {\n', '            int result = optionChains[optionChainID].positions[accounts[accountID].user].cash / 1000000000000000000;\n', '            for (uint optionID=0; optionID<optionChains[optionChainID].numOptions; optionID++) {\n', '              int moneyness = getMoneyness(optionChains[optionChainID].options[optionID].strike, uint(value), optionChains[optionChainID].margin);\n', '              result += moneyness * optionChains[optionChainID].positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;\n', '            }\n', '            accounts[accountID].capital = accounts[accountID].capital + result;\n', '            optionChains[optionChainID].positions[accounts[accountID].user].expired = true;\n', '            optionChains[optionChainID].numPositionsExpired++;\n', '          }\n', '        }\n', '        if (optionChains[optionChainID].numPositionsExpired == optionChains[optionChainID].numPositions) {\n', '          optionChains[optionChainID].expired = true;\n', '        }\n', '      }\n', '    }\n', '  }\n', '\n', '  function getMoneyness(int strike, uint settlement, uint margin) constant returns(int) {\n', '    if (strike>=0) { //call\n', '      if (settlement>uint(strike)) {\n', '        if (settlement-uint(strike)<margin) {\n', '          return int(settlement-uint(strike));\n', '        } else {\n', '          return int(margin);\n', '        }\n', '      } else {\n', '        return 0;\n', '      }\n', '    } else { //put\n', '      if (settlement<uint(-strike)) {\n', '        if (uint(-strike)-settlement<margin) {\n', '          return int(uint(-strike)-settlement);\n', '        } else {\n', '          return int(margin);\n', '        }\n', '      } else {\n', '        return 0;\n', '      }\n', '    }\n', '  }\n', '\n', '  function addOptionChain(uint expiration, string underlying, uint margin, uint realityID, bytes32 factHash, address ethAddr, int[] strikes) {\n', '    uint optionChainID = 6;\n', '    if (numOptionChains<6) {\n', '      optionChainID = numOptionChains++;\n', '    } else {\n', '      for (uint i=0; i < numOptionChains && optionChainID>=6; i++) {\n', '        if (optionChains[i].expired==true || optionChains[i].numPositions==0 || optionChains[i].numOptions==0) {\n', '          optionChainID = i;\n', '        }\n', '      }\n', '    }\n', '    if (optionChainID<6) {\n', '      delete optionChains[optionChainID];\n', '      optionChains[optionChainID].expiration = expiration;\n', '      optionChains[optionChainID].underlying = underlying;\n', '      optionChains[optionChainID].margin = margin;\n', '      optionChains[optionChainID].realityID = realityID;\n', '      optionChains[optionChainID].factHash = factHash;\n', '      optionChains[optionChainID].ethAddr = ethAddr;\n', '      for (i=0; i < strikes.length; i++) {\n', '        if (optionChains[optionChainID].numOptions<10) {\n', '          uint optionID = optionChains[optionChainID].numOptions++;\n', '          Option option = optionChains[optionChainID].options[i];\n', '          option.strike = strikes[i];\n', '          optionChains[optionChainID].options[i] = option;\n', '        }\n', '      }\n', '    }\n', '  }\n', '\n', '  function orderMatchTest(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, address sender, int matchSize) constant returns(bool) {\n', '    if (block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(sender, false)+getMaxLossAfterTrade(sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function orderMatch(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, uint8 v, bytes32 r, bytes32 s, int matchSize) {\n', '    bytes32 hash = sha256(optionChainID, optionID, price, size, orderID, blockExpires);\n', '    if (ecrecover(hash, v, r, s) == addr && block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[hash]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[hash]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(msg.sender, false)+getMaxLossAfterTrade(msg.sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {\n', '      if (optionChains[optionChainID].positions[msg.sender].hasPosition == false) {\n', '        optionChains[optionChainID].positions[msg.sender].hasPosition = true;\n', '        optionChains[optionChainID].numPositions++;\n', '      }\n', '      if (optionChains[optionChainID].positions[addr].hasPosition == false) {\n', '        optionChains[optionChainID].positions[addr].hasPosition = true;\n', '        optionChains[optionChainID].numPositions++;\n', '      }\n', '      optionChains[optionChainID].positions[msg.sender].positions[optionID] += matchSize;\n', '      optionChains[optionChainID].positions[msg.sender].cash -= matchSize * int(price);\n', '      optionChains[optionChainID].positions[addr].positions[optionID] -= matchSize;\n', '      optionChains[optionChainID].positions[addr].cash += matchSize * int(price);\n', '      orderFills[hash] -= matchSize;\n', '    }\n', '  }\n', '\n', '  function getMaxLossAfterTrade(address user, uint optionChainID, uint optionID, int positionChange, int cashChange) constant returns(int) {\n', '    int totalMaxLoss = 0;\n', '    for (uint i=0; i<numOptionChains; i++) {\n', '      if (optionChains[i].positions[user].expired == false && optionChains[i].numOptions>0) {\n', '        bool maxLossInitialized = false;\n', '        int maxLoss = 0;\n', '        for (uint s=0; s<optionChains[i].numOptions; s++) {\n', '          int pnl = optionChains[i].positions[user].cash / 1000000000000000000;\n', '          if (i==optionChainID) {\n', '            pnl += cashChange / 1000000000000000000;\n', '          }\n', '          uint settlement = 0;\n', '          if (optionChains[i].options[s].strike<0) {\n', '            settlement = uint(-optionChains[i].options[s].strike);\n', '          } else {\n', '            settlement = uint(optionChains[i].options[s].strike);\n', '          }\n', '          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);\n', '          if (pnl<maxLoss || maxLossInitialized==false) {\n', '            maxLossInitialized = true;\n', '            maxLoss = pnl;\n', '          }\n', '          pnl = optionChains[i].positions[user].cash / 1000000000000000000;\n', '          if (i==optionChainID) {\n', '            pnl += cashChange / 1000000000000000000;\n', '          }\n', '          settlement = 0;\n', '          if (optionChains[i].options[s].strike<0) {\n', '            if (uint(-optionChains[i].options[s].strike)>optionChains[i].margin) {\n', '              settlement = uint(-optionChains[i].options[s].strike)-optionChains[i].margin;\n', '            } else {\n', '              settlement = 0;\n', '            }\n', '          } else {\n', '            settlement = uint(optionChains[i].options[s].strike)+optionChains[i].margin;\n', '          }\n', '          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);\n', '          if (pnl<maxLoss) {\n', '            maxLoss = pnl;\n', '          }\n', '        }\n', '        totalMaxLoss += maxLoss;\n', '      }\n', '    }\n', '    return totalMaxLoss;\n', '  }\n', '\n', '  function moneySumAtSettlement(address user, uint optionChainID, uint optionID, int positionChange, uint i, uint settlement) internal returns(int) {\n', '    int pnl = 0;\n', '    for (uint j=0; j<optionChains[i].numOptions; j++) {\n', '      pnl += optionChains[i].positions[user].positions[j] * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;\n', '      if (i==optionChainID && j==optionID) {\n', '        pnl += positionChange * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;\n', '      }\n', '    }\n', '    return pnl;\n', '  }\n', '\n', '  function min(uint a, uint b) constant returns(uint) {\n', '    if (a<b) {\n', '      return a;\n', '    } else {\n', '      return b;\n', '    }\n', '  }\n', '}']