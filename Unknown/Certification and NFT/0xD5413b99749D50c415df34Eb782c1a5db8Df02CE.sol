['pragma solidity ^0.4.13;\n', '\n', 'contract ERC20 {\n', '\n', '    function totalSupply() constant returns (uint totalSupply);\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '}\n', '\n', 'contract owned {\n', '    address public _owner;\n', '\n', '    function owned() {\n', '        _owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == _owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract mortal is owned {\n', '    function mortal() { \n', '    }\n', '\n', '    function kill() onlyOwner {\n', '        selfdestruct(_owner);\n', '    }\n', '}\n', '\n', 'contract hackethereumIco is mortal {\n', '    uint256 public _amountRaised;\n', '    uint256 public _deadline;\n', '\n', '    uint256 private _timeBetweenWithdrawCalls;\n', '    uint256 private _timeBetweenControlFlipCalls;\n', '\n', '    uint256 private _priceIncrease1;\n', '    uint256 private _priceIncrease2;\n', '\n', '    bool private _hackedTenuous;\n', '    bool private _hackedEducated;\n', '    bool private _hackedAdept;\n', '    bool private _whitehatActive;\n', '\n', '    bool private _initialised;\n', '    \n', '    address private _beneficiary;\n', '    address private _hackerTenuous;\n', '    address private _hackerEducated;\n', '    address private _hackerAdept;\n', '    address private _hackerDecisive;\n', '    address private _whitehat;\n', '\n', '    uint256 private _lastHack;\n', '    uint256 private _lastWhitehat;\n', '    uint256 private _lastControlFlip;\n', '\n', '    uint256 private _initialPrice;\n', '\n', '    uint256 private constant _participationThreshold =  50000000000000000;\n', '    uint256 private constant _participationMax       = 500000000000000000;\n', '\n', '    uint256 private constant _hackTokenThreshold     =  10000000000000000;\n', '\n', '    hackoin public _hackoinToken;\n', '    hackoin public _tenuousToken;\n', '    hackoin public _educatedToken;\n', '    hackoin public _adeptToken;\n', '\n', '    mapping(address => uint256) private _balanceOf;\n', '\n', '    event FundTransfer(address indexed backer, string indexed transferType, uint256 amount);\n', '\n', '    function hackethereumIco(\n', '        address ifSuccessfulSendTo,\n', '        address hackerTenuousAddress,\n', '        address hackerEducatedAddress,\n', '        address hackerAdeptAddress,\n', '        address hackerDecisiveAddress,\n', '        address whitehatAddress\n', '        // uint256 durationInMinutes,\n', '        // uint256 timeBetweenWithdrawMinutes,\n', '        // uint256 timeBetweenFlipMinutes\n', '        \n', '    ) {\n', '        _beneficiary = ifSuccessfulSendTo;\n', '        _hackerTenuous = hackerTenuousAddress;\n', '        _hackerEducated = hackerEducatedAddress;\n', '        _hackerAdept = hackerAdeptAddress;\n', '        _hackerDecisive = hackerDecisiveAddress;\n', '        _whitehat = whitehatAddress;\n', '    \n', '        _initialised = false;\n', '    }\n', '\n', '    function initialise() onlyOwner {\n', '        require(!_initialised);\n', '\n', '        _deadline = 1504301337; // Fri, 01 Sep 2017 21:28:57 // now + durationInMinutes * 1 minutes; //1504231337\n', '\n', '        _timeBetweenWithdrawCalls = 30 minutes;\n', '        _timeBetweenControlFlipCalls = 300 minutes;\n', '\n', '        _priceIncrease2 = _deadline - 4 days;\n', '        _priceIncrease1 = _priceIncrease2 - 6 days;\n', '\n', '        _lastHack = now;//_deadline + 1 days;\n', '        _lastWhitehat = now;//_deadline + 1 days;\n', '        _lastControlFlip = now;//_deadline + 1 days;\n', '\n', '        _initialPrice = 1;\n', '\n', '        address tokenContractAddress = new hackoin("Hackoin", "HK");\n', '        _hackoinToken = hackoin(tokenContractAddress);\n', '\n', '        address tenuousTokenContractAddress = new hackoin("Hackoin_Tenuous", "HKT");\n', '        address educatedTokenContractAddress = new hackoin("Hackoin_Educated", "HKE");\n', '        address adeptTokenContractAddress = new hackoin("Hackoin_Adept", "HKA");\n', '\n', '        _tenuousToken = hackoin(tenuousTokenContractAddress);\n', '        _educatedToken = hackoin(educatedTokenContractAddress);\n', '        _adeptToken = hackoin(adeptTokenContractAddress);\n', '\n', '        _hackoinToken.mintToken(msg.sender, _participationMax*2);\n', '        _tenuousToken.mintToken(msg.sender, _hackTokenThreshold*2);\n', '        _educatedToken.mintToken(msg.sender, _hackTokenThreshold*2);\n', '        _adeptToken.mintToken(msg.sender, _hackTokenThreshold*2);\n', '        _initialised = true;\n', '    }\n', '\n', '    function adjustTiming(uint256 timeBetweenWithdrawMinutes, uint256 timeBetweenFlipMinutes) onlyOwner {\n', '        _timeBetweenWithdrawCalls = timeBetweenWithdrawMinutes * 1 minutes;\n', '        _timeBetweenControlFlipCalls = timeBetweenFlipMinutes * 1 minutes;\n', '    }\n', '\n', '    function () payable {\n', '        require(now < _deadline);\n', '\n', '        uint256 amount = msg.value;\n', '\n', '        uint256 currentPrice;\n', '        if(now < _priceIncrease1)\n', '        {\n', '            currentPrice = _initialPrice;\n', '        }\n', '        else if (now < _priceIncrease2)\n', '        {\n', '            currentPrice = _initialPrice * 2;\n', '        }\n', '        else\n', '        {\n', '            currentPrice = _initialPrice * 4;\n', '        }\n', '\n', '        uint256 tokenAmount = amount / currentPrice;\n', '\n', '        require(tokenAmount > 0);\n', '        require(_balanceOf[msg.sender] + amount >= _balanceOf[msg.sender]);\n', '        require(this.balance + amount >= this.balance);\n', '\n', '        _balanceOf[msg.sender] += amount;\n', '        _amountRaised += amount;\n', '\n', '        _hackoinToken.mintToken(msg.sender, tokenAmount);\n', '        FundTransfer(msg.sender, "Ticket Purchase", amount);\n', '    }\n', '\n', '    modifier afterDeadline()\n', '    { \n', '        require (now >= _deadline); \n', '        _;\n', '    }\n', '\n', '    function withdrawFunds(uint256 amount) afterDeadline {\n', '        require(_beneficiary == msg.sender);\n', '\n', '        require(this.balance > 0);\n', '        require(amount <= this.balance);\n', '\n', '        if (_beneficiary.send(amount))\n', '        {\n', '            FundTransfer(_beneficiary, "Withdrawal", amount);\n', '        }\n', '    }\n', '\n', '    function hackDecisive(address targetAddress, uint256 amount) afterDeadline {\n', '        require(msg.data.length == 32*2+4);\n', '        require(_hackerDecisive == msg.sender);\n', '\n', '        require(_hackoinToken.balanceOf(targetAddress) >= _participationMax*2);\n', '\n', '        require(this.balance > 0);\n', '        require(amount <= this.balance);\n', '\n', '        if (targetAddress.send(amount))\n', '        {\n', '            FundTransfer(targetAddress, "Decisive hack", amount);\n', '        }\n', '    }\n', '\n', '    function whitehatRecover() afterDeadline {\n', '        require(_whitehat == msg.sender);\n', '        require(_whitehatActive);\n', '\n', '        require(_lastWhitehat + _timeBetweenWithdrawCalls < now);\n', '\n', '        require(this.balance > 0);\n', '\n', '        uint amount;\n', '        if(_amountRaised > 500 ether)\n', '        {\n', '            amount = _amountRaised / 50;\n', '        }\n', '        else if(_amountRaised > 100 ether)\n', '        {\n', '            amount = _amountRaised / 20;\n', '        }\n', '        else\n', '        {\n', '            amount = _amountRaised / 10;\n', '        }\n', '        \n', '        if(amount > this.balance)\n', '        {\n', '            amount = this.balance;\n', '        }\n', '\n', '        _lastWhitehat = now;\n', '\n', '        if (_whitehat.send(amount))\n', '        {\n', '            FundTransfer(_whitehat, "Whitehat recovery", amount);\n', '        }\n', '    }\n', '\n', '    function hack(address targetAddress) afterDeadline {\n', '        require(msg.data.length == 32+4);\n', '\n', '        require(_hackerTenuous == msg.sender || _hackerEducated == msg.sender || _hackerAdept == msg.sender);\n', '        require(_hackedTenuous);\n', '        require(_hackedEducated);\n', '        require(_hackedAdept);\n', '        require(!_whitehatActive);\n', '\n', '        require(_lastHack + _timeBetweenWithdrawCalls < now);\n', '\n', '        require(this.balance > 0);\n', '\n', '        require(_hackoinToken.balanceOf(targetAddress) >= _participationThreshold);\n', '\n', '        require(_tenuousToken.balanceOf(targetAddress) >= _hackTokenThreshold);\n', '        require(_educatedToken.balanceOf(targetAddress) >= _hackTokenThreshold);\n', '        require(_adeptToken.balanceOf(targetAddress) >= _hackTokenThreshold);\n', '\n', '        uint minAmount;\n', '        if(_amountRaised > 500 ether)\n', '        {\n', '            minAmount = _amountRaised / 500;\n', '        }\n', '        else if(_amountRaised > 100 ether)\n', '        {\n', '            minAmount = _amountRaised / 200;\n', '        }\n', '        else\n', '        {\n', '            minAmount = _amountRaised / 100;\n', '        }\n', '\n', '\n', '        uint256 participationAmount = _hackoinToken.balanceOf(targetAddress);\n', '        if(participationAmount > _participationMax)\n', '        {\n', '            participationAmount = _participationMax;\n', '        }\n', '\n', '        uint256 ratio = participationAmount / _participationThreshold;\n', '        uint256 amount = minAmount * ratio;\n', '        \n', '        if(amount > this.balance)\n', '        {\n', '            amount = this.balance;\n', '        }\n', '\n', '        _lastHack = now;\n', '\n', '        if (targetAddress.send(amount))\n', '        {\n', '            FundTransfer(targetAddress, "Hack", amount);\n', '        }\n', '    }\n', '\n', '    function hackTenuous(address targetAddress) afterDeadline {\n', '        require(msg.data.length == 32+4);\n', '        require(_hackerTenuous == msg.sender);\n', '\n', '        if(!_hackedTenuous) {\n', '            require(_lastControlFlip + _timeBetweenControlFlipCalls < now);\n', '        }\n', '\n', '        _hackedTenuous = true;\n', '\n', '        if(_tenuousToken.balanceOf(targetAddress) == 0) {\n', '            _tenuousToken.mintToken(targetAddress, _hackTokenThreshold);\n', '        }\n', '    }\n', '\n', '    function hackEducated(address targetAddress) afterDeadline {\n', '        require(msg.data.length == 32+4);\n', '        require(_hackerEducated == msg.sender);\n', '        require(_hackedTenuous);\n', '\n', '        if(!_hackedEducated) {\n', '            require(_lastControlFlip + _timeBetweenControlFlipCalls < now);\n', '        }\n', '\n', '        _hackedEducated = true;\n', '\n', '        if(_educatedToken.balanceOf(targetAddress) == 0) {\n', '            _educatedToken.mintToken(targetAddress, _hackTokenThreshold);\n', '        }\n', '    }\n', '\n', '    function hackAdept(address targetAddress) afterDeadline {\n', '        require(msg.data.length == 32+4);\n', '        require(_hackerAdept == msg.sender);\n', '        require(_hackedTenuous && _hackedEducated);\n', '\n', '        if(!_hackedAdept) {\n', '            require(_lastControlFlip + _timeBetweenControlFlipCalls < now);\n', '            _lastControlFlip = now;\n', '        }\n', '\n', '        _whitehatActive = false;\n', '        _hackedAdept = true;\n', '\n', '        if(_adeptToken.balanceOf(targetAddress) == 0) {\n', '            _adeptToken.mintToken(targetAddress, _hackTokenThreshold);\n', '        }\n', '    }\n', '\n', '    function whiteHat() afterDeadline {\n', '        require(_whitehat == msg.sender);\n', '        require(_lastControlFlip + _timeBetweenControlFlipCalls < now);\n', '        _hackedTenuous = false;\n', '        _hackedEducated = false;\n', '        _hackedAdept = false;\n', '\n', '        if(!_whitehatActive){\n', '            _lastControlFlip = now;\n', '        }\n', '\n', '        _whitehatActive = true;\n', '    }\n', '\n', '    function kill() onlyOwner {\n', '        _hackoinToken.kill();\n', '        _tenuousToken.kill();\n', '        _educatedToken.kill();\n', '        _adeptToken.kill();\n', '        mortal.kill();\n', '    }\n', '\n', '    // function transferHackoinTokenOwnership(address newOwner) onlyOwner afterDeadline {\n', '    //     require(msg.data.length == 32+4);\n', '    //     _hackoinToken.transferOwnership(newOwner);\n', '    // }\n', '\n', '    // function transferTenuousTokenOwnership(address newOwner) onlyOwner afterDeadline {\n', '    //     require(msg.data.length == 32+4);\n', '    //     _tenuousToken.transferOwnership(newOwner);\n', '    // }\n', '\n', '    // function transferEducatedTokenOwnership(address newOwner) onlyOwner afterDeadline {\n', '    //     require(msg.data.length == 32+4);\n', '    //     _educatedToken.transferOwnership(newOwner);\n', '    // }\n', '\n', '    // function transferAdeptTokenOwnership(address newOwner) onlyOwner afterDeadline {\n', '    //     require(msg.data.length == 32+4);\n', '    //     _adeptToken.transferOwnership(newOwner);\n', '    // }\n', '}\n', '\n', 'contract hackoin is ERC20, owned, mortal {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public constant decimals = 16;\n', '\n', '    uint256 public _totalSupply;\n', '\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    function hackoin(string _name, string _symbol) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        _totalSupply = 0;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        require(msg.data.length == 32*2+4);\n', '\n', '        require(balances[msg.sender] >= _value);\n', '        require(_value > 0);\n', '        require(balances[_to] + _value >= balances[_to]);\n', '\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\n', '        require(msg.data.length == 32*3+4);\n', '\n', '        require(balances[_from] >= _amount);\n', '        require(allowed[_from][msg.sender] >= _amount);\n', '        require(_amount > 0);\n', '        require(balances[_to] + _amount > balances[_to]);\n', '\n', '        balances[_from] -= _amount;\n', '        allowed[_from][msg.sender] -= _amount;\n', '        balances[_to] += _amount;\n', '        Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n', '        require(msg.data.length == 32*2+4);\n', '\n', '        balances[target] += mintedAmount;\n', '        _totalSupply += mintedAmount;\n', '        Transfer(0, _owner, mintedAmount);\n', '        Transfer(_owner, target, mintedAmount);\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256 totalSupply) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        require(msg.data.length == 32+4);\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        require(msg.data.length == 32*2+4);\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        require(msg.data.length == 32*2+4);\n', '        return allowed[_owner][_spender];\n', '    }\n', '}']