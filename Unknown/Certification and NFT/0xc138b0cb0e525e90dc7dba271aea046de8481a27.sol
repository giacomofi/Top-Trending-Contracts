['// Copyright New Alchemy Limited, 2017. All rights reserved.\n', 'pragma solidity >=0.4.10;\n', '\n', '// Just the bits of ERC20 that we need.\n', 'contract Token {\n', '    function balanceOf(address addr) returns(uint);\n', '    function transfer(address to, uint amount) returns(bool);\n', '}\n', '\n', '// Receiver is the contract that takes contributions\n', 'contract Receiver {\n', '    event StartSale();\n', '    event EndSale();\n', '    event EtherIn(address from, uint amount);\n', '\n', '    address public owner;    // contract owner\n', '    address public newOwner; // new contract owner for two-way ownership handshake\n', '    string public notice;    // arbitrary public notice text\n', '\n', '    Sale public sale;\n', '\n', '    function Receiver() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlySale() {\n', '        require(msg.sender == address(sale));\n', '        _;\n', '    }\n', '\n', '    function live() constant returns(bool) {\n', '        return sale.live();\n', '    }\n', '\n', '    // callback from sale contract when the sale begins\n', '    function start() onlySale {\n', '        StartSale();\n', '    }\n', '\n', '    // callback from sale contract when sale ends\n', '    function end() onlySale {\n', '        EndSale();\n', '    }\n', '\n', '    function () payable {\n', '        // forward everything to the sale contract\n', '        EtherIn(msg.sender, msg.value);\n', '        require(sale.call.value(msg.value)());\n', '    }\n', '\n', '    // 1st half of ownership change\n', '    function changeOwner(address next) onlyOwner {\n', '        newOwner = next;\n', '    }\n', '\n', '    // 2nd half of ownership change\n', '    function acceptOwnership() {\n', '        require(msg.sender == newOwner);\n', '        owner = msg.sender;\n', '        newOwner = 0;\n', '    }\n', '\n', '    // put some text in the contract\n', '    function setNotice(string note) onlyOwner {\n', '        notice = note;\n', '    }\n', '\n', '    // set the target sale address\n', '    function setSale(address s) onlyOwner {\n', '        sale = Sale(s);\n', '    }\n', '\n', '    // Ether gets sent to the main sale contract,\n', '    // but tokens get sent here, so we still need\n', '    // withdrawal methods.\n', '\n', '    // withdraw tokens to owner\n', '    function withdrawToken(address token) onlyOwner {\n', '        Token t = Token(token);\n', '        require(t.transfer(msg.sender, t.balanceOf(this)));\n', '    }\n', '\n', '    // refund early/late tokens\n', '    function refundToken(address token, address sender, uint amount) onlyOwner {\n', '        Token t = Token(token);\n', '        require(t.transfer(sender, amount));\n', '    }\n', '}\n', '\n', 'contract Sale {\n', '    // once the balance of this contract exceeds the\n', '    // soft-cap, the sale should stay open for no more\n', '    // than this amount of time\n', '    uint public constant SOFTCAP_TIME = 4 hours;\n', '\n', '    address public owner;    // contract owner\n', '    address public newOwner; // new contract owner for two-way ownership handshake\n', '    string public notice;    // arbitrary public notice text\n', '    uint public start;       // start time of sale\n', '    uint public end;         // end time of sale\n', '    uint public cap;         // Ether hard cap\n', '    uint public softcap;     // Ether soft cap\n', '    bool public live;        // sale is live right now\n', '\n', '    Receiver public r0;\n', '    Receiver public r1;\n', '    Receiver public r2;\n', '\n', '    function Sale() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // tell the receivers that the sale has begun\n', '    function emitBegin() internal {\n', '        r0.start();\n', '        r1.start();\n', '        r2.start();\n', '    }\n', '\n', '    // tell the receivers that the sale is over\n', '    function emitEnd() internal {\n', '        r0.end();\n', '        r1.end();\n', '        r2.end();\n', '    }\n', '\n', '    function () payable {\n', '        // only accept contributions from receiver contracts\n', '        require(msg.sender == address(r0) || msg.sender == address(r1) || msg.sender == address(r2));\n', '        require(block.timestamp >= start);\n', '\n', '        // if we&#39;ve gone past the softcap, make sure the sale\n', '        // stays open for no longer than SOFTCAP_TIME past the current block\n', '        if (this.balance > softcap && block.timestamp < end && (end - block.timestamp) > SOFTCAP_TIME)\n', '            end = block.timestamp + SOFTCAP_TIME;\n', '\n', '        // If we&#39;ve reached end-of-sale conditions, accept\n', '        // this as the last contribution and emit the EndSale event.\n', '        // (Technically this means we allow exactly one contribution\n', '        // after the end of the sale.)\n', '        // Conversely, if we haven&#39;t started the sale yet, emit\n', '        // the StartSale event.\n', '        if (block.timestamp > end || this.balance > cap) {\n', '            require(live);\n', '            live = false;\n', '            emitEnd();\n', '        } else if (!live) {\n', '            live = true;\n', '            emitBegin();\n', '        }\n', '    }\n', '\n', '    function init(uint _start, uint _end, uint _cap, uint _softcap) onlyOwner {\n', '        start = _start;\n', '        end = _end;\n', '        cap = _cap;\n', '        softcap = _softcap;\n', '    }\n', '\n', '    function setReceivers(address a, address b, address c) onlyOwner {\n', '        r0 = Receiver(a);\n', '        r1 = Receiver(b);\n', '        r2 = Receiver(c);\n', '    }\n', '\n', '    // 1st half of ownership change\n', '    function changeOwner(address next) onlyOwner {\n', '        newOwner = next;\n', '    }\n', '\n', '    // 2nd half of ownership change\n', '    function acceptOwnership() {\n', '        require(msg.sender == newOwner);\n', '        owner = msg.sender;\n', '        newOwner = 0;\n', '    }\n', '\n', '    // put some text in the contract\n', '    function setNotice(string note) onlyOwner {\n', '        notice = note;\n', '    }\n', '\n', '    // withdraw all of the Ether\n', '    function withdraw() onlyOwner {\n', '        msg.sender.transfer(this.balance);\n', '    }\n', '\n', '    // withdraw some of the Ether\n', '    function withdrawSome(uint value) onlyOwner {\n', '        require(value <= this.balance);\n', '        msg.sender.transfer(value);\n', '    }\n', '\n', '    // withdraw tokens to owner\n', '    function withdrawToken(address token) onlyOwner {\n', '        Token t = Token(token);\n', '        require(t.transfer(msg.sender, t.balanceOf(this)));\n', '    }\n', '\n', '    // refund early/late tokens\n', '    function refundToken(address token, address sender, uint amount) onlyOwner {\n', '        Token t = Token(token);\n', '        require(t.transfer(sender, amount));\n', '    }\n', '}']