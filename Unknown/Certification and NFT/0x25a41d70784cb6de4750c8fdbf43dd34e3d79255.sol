['pragma solidity ^0.4.15;\n', '\n', 'contract ETHLotteryManagerInterface {\n', '    function register();\n', '}\n', '\n', 'contract ETHLotteryInterface {\n', '    function accumulate();\n', '}\n', '\n', 'contract ETHLottery {\n', '    bytes32 public name = &#39;ETHLottery - Last 1 Byte Lottery&#39;;\n', '    address public manager_address;\n', '    address public owner;\n', '    bool public open;\n', '    uint256 public jackpot;\n', '    uint256 public fee;\n', '    uint256 public owner_fee;\n', '    uint256 public create_block;\n', '    uint256 public result_block;\n', '    uint256 public winners_count;\n', '    bytes32 public result_hash;\n', '    bytes1 public result;\n', '    address public accumulated_from;\n', '    address public accumulate_to;\n', '\n', '    mapping (bytes1 => address[]) bettings;\n', '    mapping (address => uint256) credits;\n', '\n', '    event Balance(uint256 _balance);\n', '    event Result(bytes1 _result);\n', '    event Open(bool _open);\n', '    event Play(address indexed _sender, bytes1 _byte, uint256 _time);\n', '    event Withdraw(address indexed _sender, uint256 _amount, uint256 _time);\n', '    event Destroy();\n', '    event Accumulate(address _accumulate_to, uint256 _amount);\n', '\n', '    function ETHLottery(address _manager, uint256 _fee, uint256 _jackpot, uint256 _owner_fee, address _accumulated_from) {\n', '        owner = msg.sender;\n', '        open = true;\n', '        create_block = block.number;\n', '        manager_address = _manager;\n', '        fee = _fee;\n', '        jackpot = _jackpot;\n', '        owner_fee = _owner_fee;\n', '        // accumulate\n', '        if (_accumulated_from != owner) {\n', '            accumulated_from = _accumulated_from;\n', '            ETHLotteryInterface lottery = ETHLotteryInterface(accumulated_from);\n', '            lottery.accumulate();\n', '        }\n', '        // register with manager\n', '        ETHLotteryManagerInterface manager = ETHLotteryManagerInterface(manager_address);\n', '        manager.register();\n', '        Open(open);\n', '    }\n', '\n', '    modifier isOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier isOriginalOwner() {\n', '        // used tx.origin on purpose instead of\n', '        // msg.sender, as we want to get the original\n', '        // starter of the transaction to be owner\n', '        require(tx.origin == owner);\n', '        _;\n', '    }\n', '\n', '    modifier isOpen() {\n', '        require(open);\n', '        _;\n', '    }\n', '\n', '    modifier isClosed() {\n', '        require(!open);\n', '        _;\n', '    }\n', '\n', '    modifier isPaid() {\n', '        require(msg.value >= fee);\n', '        _;\n', '    }\n', '\n', '    modifier hasPrize() {\n', '        require(credits[msg.sender] > 0);\n', '        _;\n', '    }\n', '\n', '    modifier isAccumulated() {\n', '        require(result_hash != 0 && winners_count == 0);\n', '        _;\n', '    }\n', '\n', '    modifier hasResultHash() {\n', '        require(\n', '            block.number >= result_block &&\n', '            block.number <= result_block + 256 &&\n', '            block.blockhash(result_block) != result_hash\n', '            );\n', '        _;\n', '    }\n', '\n', '    function play(bytes1 _byte) payable isOpen isPaid returns (bool) {\n', '        bettings[_byte].push(msg.sender);\n', '        if (this.balance >= jackpot) {\n', '            uint256 owner_fee_amount = (this.balance * owner_fee) / 100;\n', '            // this is the transaction which\n', '            // will generate the block used\n', '            // to count until the 10th in order\n', '            // to get the lottery result.\n', '            if (!owner.send(owner_fee_amount)) {\n', '                return false;\n', '            }\n', '            open = false;\n', '            // block offset hardcoded to 10\n', '            result_block = block.number + 10;\n', '            Open(open);\n', '        }\n', '        Balance(this.balance);\n', '        Play(msg.sender, _byte, now);\n', '        return true;\n', '    }\n', '\n', '    // This method is only used if we miss the 256th block\n', '    // containing the result hash, lottery() should be used instead\n', '    // this method as this is duplicated from lottery()\n', '    function manual_lottery(bytes32 _result_hash) isClosed isOwner {\n', '        result_hash = _result_hash;\n', '        result = result_hash[31];\n', '        address[] storage winners = bettings[result];\n', '        winners_count = winners.length;\n', '        if (winners_count > 0) {\n', '            uint256 credit = this.balance / winners_count;\n', '            for (uint256 i = 0; i < winners_count; i++) {\n', '                credits[winners[i]] = credit;\n', '            }\n', '        }\n', '        Result(result);\n', '    }\n', '\n', '    function lottery() isClosed hasResultHash isOwner {\n', '        result_hash = block.blockhash(result_block);\n', '        // get last byte (31st) from block hash as result\n', '        result = result_hash[31];\n', '        address[] storage winners = bettings[result];\n', '        winners_count = winners.length;\n', '        if (winners_count > 0) {\n', '            uint256 credit = this.balance / winners_count;\n', '            for (uint256 i = 0; i < winners_count; i++) {\n', '                credits[winners[i]] = credit;\n', '            }\n', '        }\n', '        Result(result);\n', '    }\n', '\n', '    function withdraw() isClosed hasPrize returns (bool) {\n', '        uint256 credit = credits[msg.sender];\n', '        // zero credit before send preventing re-entrancy\n', '        // as msg.sender can be a contract and call us back\n', '        credits[msg.sender] = 0;\n', '        if (!msg.sender.send(credit)) {\n', '            // transfer failed, return credit for withdraw\n', '            credits[msg.sender] = credit;\n', '            return false;\n', '        }\n', '        Withdraw(msg.sender, credit, now);\n', '        return true;\n', '    }\n', '\n', '    function accumulate() isOriginalOwner isClosed isAccumulated {\n', '        accumulate_to = msg.sender;\n', '        if (msg.sender.send(this.balance)) {\n', '            Accumulate(msg.sender, this.balance);\n', '        }\n', '    }\n', '\n', '    function destruct() isClosed isOwner {\n', '        Destroy();\n', '        selfdestruct(owner);\n', '    }\n', '}']