['pragma solidity ^0.4.2;\n', '\n', '/*\n', ' *\n', ' * This file is part of Pass DAO.\n', ' *\n', ' * The Token Manager smart contract is used for the management of tokens\n', ' * by a client smart contract (the Dao). Defines the functions to set new funding rules,\n', ' * create or reward tokens, check token balances, send tokens and send\n', ' * tokens on behalf of a 3rd party and the corresponding approval process.\n', ' *\n', '*/\n', '\n', '/// @title Token Manager smart contract of the Pass Decentralized Autonomous Organisation\n', 'contract PassTokenManagerInterface {\n', '    \n', '    struct fundingData {\n', '        // True if public funding without a main partner\n', '        bool publicCreation; \n', '        // The address which sets partners and manages the funding in case of private funding\n', '        address mainPartner;\n', '        // The maximum amount (in wei) of the funding\n', '        uint maxAmountToFund;\n', '        // The actual funded amount (in wei)\n', '        uint fundedAmount;\n', '        // A unix timestamp, denoting the start time of the funding\n', '        uint startTime; \n', '        // A unix timestamp, denoting the closing time of the funding\n', '        uint closingTime;  \n', '        // The price multiplier for a share or a token without considering the inflation rate\n', '        uint initialPriceMultiplier;\n', '        // Rate per year in percentage applied to the share or token price \n', '        uint inflationRate; \n', '        // Index of the client proposal\n', '        uint proposalID;\n', '    } \n', '\n', '    // Address of the creator of the smart contract\n', '    address public creator;\n', '    // Address of the Dao    \n', '    address public client;\n', '    // Address of the recipient;\n', '    address public recipient;\n', '    \n', '    // The token name for display purpose\n', '    string public name;\n', '    // The token symbol for display purpose\n', '    string public symbol;\n', '    // The quantity of decimals for display purpose\n', '    uint8 public decimals;\n', '\n', '    // Total amount of tokens\n', '    uint256 totalSupply;\n', '\n', '    // Array with all balances\n', '    mapping (address => uint256) balances;\n', '    // Array with all allowances\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    // Map of the result (in wei) of fundings\n', '    mapping (uint => uint) fundedAmount;\n', '    \n', '    // If true, the shares or tokens can be transfered\n', '    bool public transferable;\n', '    // Map of blocked Dao share accounts. Points to the date when the share holder can transfer shares\n', '    mapping (address => uint) public blockedDeadLine; \n', '\n', '    // Rules for the actual funding and the contractor token price\n', '    fundingData[2] public FundingRules;\n', '    \n', '    /// @return The total supply of shares or tokens \n', '    function TotalSupply() constant external returns (uint256);\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '     function balanceOf(address _owner) constant external returns (uint256 balance);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Quantity of remaining tokens of _owner that _spender is allowed to spend\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n', '\n', '    /// @param _proposalID The index of the Dao proposal\n', '    /// @return The result (in wei) of the funding\n', '    function FundedAmount(uint _proposalID) constant external returns (uint);\n', '\n', '    /// @param _saleDate in case of presale, the date of the presale\n', '    /// @return the share or token price divisor condidering the sale date and the inflation rate\n', '    function priceDivisor(uint _saleDate) constant internal returns (uint);\n', '    \n', '    /// @return the actual price divisor of a share or token\n', '    function actualPriceDivisor() constant external returns (uint);\n', '\n', '    /// @return The maximal amount a main partner can fund at this moment\n', '    /// @param _mainPartner The address of the main parner\n', '    function fundingMaxAmount(address _mainPartner) constant external returns (uint);\n', '\n', '    // Modifier that allows only the client to manage this account manager\n', '    modifier onlyClient {if (msg.sender != client) throw; _;}\n', '\n', '    // Modifier that allows only the main partner to manage the actual funding\n', '    modifier onlyMainPartner {if (msg.sender !=  FundingRules[0].mainPartner) throw; _;}\n', '    \n', '    // Modifier that allows only the contractor propose set the token price or withdraw\n', '    modifier onlyContractor {if (recipient == 0 || (msg.sender != recipient && msg.sender != creator)) throw; _;}\n', '    \n', '    // Modifier for Dao functions\n', '    modifier onlyDao {if (recipient != 0) throw; _;}\n', '    \n', '    /// @dev The constructor function\n', '    /// @param _creator The address of the creator of the smart contract\n', '    /// @param _client The address of the client or Dao\n', '    /// @param _recipient The recipient of this manager\n', '    //function TokenManager(\n', '        //address _creator,\n', '        //address _client,\n', '        //address _recipient\n', '    //);\n', '\n', '    /// @param _tokenName The token name for display purpose\n', '    /// @param _tokenSymbol The token symbol for display purpose\n', '    /// @param _tokenDecimals The quantity of decimals for display purpose\n', '    /// @param _initialSupplyRecipient The recipient of the initial supply (not mandatory)\n', '    /// @param _initialSupply The initial supply of tokens for the recipient (not mandatory)\n', '    /// @param _transferable True if allows the transfer of tokens\n', '    function initToken(\n', '        string _tokenName,\n', '        string _tokenSymbol,\n', '        uint8 _tokenDecimals,\n', '        address _initialSupplyRecipient,\n', '        uint256 _initialSupply,\n', '        bool _transferable\n', '       );\n', '\n', '    /// @param _initialPriceMultiplier The initial price multiplier of contractor tokens\n', "    /// @param _inflationRate If 0, the contractor token price doesn't change during the funding\n", '    /// @param _closingTime The initial price and inflation rate can be changed after this date\n', '    function setTokenPriceProposal(        \n', '        uint _initialPriceMultiplier, \n', '        uint _inflationRate,\n', '        uint _closingTime\n', '    );\n', '\n', '    /// @notice Function to set a funding. Can be private or public\n', '    /// @param _mainPartner The address of the smart contract to manage a private funding\n', '    /// @param _publicCreation True if public funding\n', '    /// @param _initialPriceMultiplier Price multiplier without considering any inflation rate\n', '    /// @param _maxAmountToFund The maximum amount (in wei) of the funding\n', '    /// @param _minutesFundingPeriod Period in minutes of the funding\n', "    /// @param _inflationRate If 0, the token price doesn't change during the funding\n", '    /// @param _proposalID Index of the client proposal (not mandatory)\n', '    function setFundingRules(\n', '        address _mainPartner,\n', '        bool _publicCreation, \n', '        uint _initialPriceMultiplier, \n', '        uint _maxAmountToFund, \n', '        uint _minutesFundingPeriod, \n', '        uint _inflationRate,\n', '        uint _proposalID\n', '    ) external;\n', '    \n', '    /// @dev Internal function for the creation of shares or tokens\n', '    /// @param _recipient The recipient address of shares or tokens\n', '    /// @param _amount The funded amount (in wei)\n', '    /// @param _saleDate In case of presale, the date of the presale\n', '    /// @return Whether the creation was successful or not\n', '    function createToken(\n', '        address _recipient, \n', '        uint _amount,\n', '        uint _saleDate\n', '    ) internal returns (bool success);\n', '\n', '    /// @notice Function used by the main partner to set the start time of the funding\n', '    /// @param _startTime The unix start date of the funding \n', '    function setFundingStartTime(uint _startTime) external;\n', '\n', '    /// @notice Function used by the main partner to reward shares or tokens\n', '    /// @param _recipient The address of the recipient of shares or tokens\n', '    /// @param _amount The amount (in Wei) to calculate the quantity of shares or tokens to create\n', '    /// @param _date The unix date to consider for the share or token price calculation\n', '    /// @return Whether the transfer was successful or not\n', '    function rewardToken(\n', '        address _recipient, \n', '        uint _amount,\n', '        uint _date\n', '        ) external;\n', '\n', '    /// @dev Internal function to close the actual funding\n', '    function closeFunding() internal;\n', '    \n', '    /// @notice Function used by the main partner to set the funding fueled\n', '    function setFundingFueled() external;\n', '\n', '    /// @notice Function to able the transfer of Dao shares or contractor tokens\n', '    function ableTransfer();\n', '\n', '    /// @notice Function to disable the transfer of Dao shares\n', '    function disableTransfer();\n', '\n', '    /// @notice Function used by the client to block the transfer of shares from and to a share holder\n', '    /// @param _shareHolder The address of the share holder\n', '    /// @param _deadLine When the account will be unblocked\n', '    function blockTransfer(address _shareHolder, uint _deadLine) external;\n', '\n', '    /// @dev Internal function to send `_value` token to `_to` from `_From`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The quantity of shares or tokens to be transferred\n', '    /// @return Whether the function was successful or not \n', '    function transferFromTo(\n', '        address _from,\n', '        address _to, \n', '        uint256 _value\n', '        ) internal returns (bool);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The quantity of shares or tokens to be transferred\n', '    function transfer(address _to, uint256 _value);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The quantity of shares or tokens to be transferred\n', '    function transferFrom(\n', '        address _from, \n', '        address _to, \n', '        uint256 _value\n', '        ) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    event TokensCreated(address indexed Sender, address indexed TokenHolder, uint Quantity);\n', '    event FundingRulesSet(address indexed MainPartner, uint indexed FundingProposalId, uint indexed StartTime, uint ClosingTime);\n', '    event FundingFueled(uint indexed FundingProposalID, uint FundedAmount);\n', '    event TransferAble();\n', '    event TransferDisable();\n', '\n', '}    \n', '\n', 'contract PassTokenManager is PassTokenManagerInterface {\n', '    \n', '    function TotalSupply() constant external returns (uint256) {\n', '        return totalSupply;\n', '    }\n', '\n', '     function balanceOf(address _owner) constant external returns (uint256 balance) {\n', '        return balances[_owner];\n', '     }\n', '\n', '    function allowance(address _owner, address _spender) constant external returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function FundedAmount(uint _proposalID) constant external returns (uint) {\n', '        return fundedAmount[_proposalID];\n', '    }\n', '\n', '    function priceDivisor(uint _saleDate) constant internal returns (uint) {\n', '        uint _date = _saleDate;\n', '        \n', '        if (_saleDate > FundingRules[0].closingTime) _date = FundingRules[0].closingTime;\n', '        if (_saleDate < FundingRules[0].startTime) _date = FundingRules[0].startTime;\n', '\n', '        return 100 + 100*FundingRules[0].inflationRate*(_date - FundingRules[0].startTime)/(100*365 days);\n', '    }\n', '    \n', '    function actualPriceDivisor() constant external returns (uint) {\n', '        return priceDivisor(now);\n', '    }\n', '\n', '    function fundingMaxAmount(address _mainPartner) constant external returns (uint) {\n', '        \n', '        if (now > FundingRules[0].closingTime\n', '            || now < FundingRules[0].startTime\n', '            || _mainPartner != FundingRules[0].mainPartner) {\n', '            return 0;   \n', '        } else {\n', '            return FundingRules[0].maxAmountToFund;\n', '        }\n', '        \n', '    }\n', '\n', '    function PassTokenManager(\n', '        address _creator,\n', '        address _client,\n', '        address _recipient\n', '    ) {\n', '        \n', '        if (_creator == 0 \n', '            || _client == 0 \n', '            || _client == _recipient \n', '            || _client == address(this) \n', '            || _recipient == address(this)) throw;\n', '\n', '        creator = _creator; \n', '        client = _client;\n', '        recipient = _recipient;\n', '        \n', '    }\n', '   \n', '    function initToken(\n', '        string _tokenName,\n', '        string _tokenSymbol,\n', '        uint8 _tokenDecimals,\n', '        address _initialSupplyRecipient,\n', '        uint256 _initialSupply,\n', '        bool _transferable) {\n', '           \n', '        if (_initialSupplyRecipient == address(this)\n', '            || decimals != 0\n', '            || msg.sender != creator\n', '            || totalSupply != 0) throw;\n', '            \n', '        name = _tokenName;\n', '        symbol = _tokenSymbol;\n', '        decimals = _tokenDecimals;\n', '          \n', '        if (_transferable) {\n', '            transferable = true;\n', '            TransferAble();\n', '        } else {\n', '            transferable = false;\n', '            TransferDisable();\n', '        }\n', '        \n', '        balances[_initialSupplyRecipient] = _initialSupply; \n', '        totalSupply = _initialSupply;\n', '        TokensCreated(msg.sender, _initialSupplyRecipient, _initialSupply);\n', '           \n', '    }\n', '    \n', '    function setTokenPriceProposal(        \n', '        uint _initialPriceMultiplier, \n', '        uint _inflationRate,\n', '        uint _closingTime\n', '    ) onlyContractor {\n', '        \n', '        if (_closingTime < now \n', '            || now < FundingRules[1].closingTime) throw;\n', '        \n', '        FundingRules[1].initialPriceMultiplier = _initialPriceMultiplier;\n', '        FundingRules[1].inflationRate = _inflationRate;\n', '        FundingRules[1].startTime = now;\n', '        FundingRules[1].closingTime = _closingTime;\n', '        \n', '    }\n', '    \n', '    function setFundingRules(\n', '        address _mainPartner,\n', '        bool _publicCreation, \n', '        uint _initialPriceMultiplier,\n', '        uint _maxAmountToFund, \n', '        uint _minutesFundingPeriod, \n', '        uint _inflationRate,\n', '        uint _proposalID\n', '    ) external onlyClient {\n', '\n', '        if (now < FundingRules[0].closingTime\n', '            || _mainPartner == address(this)\n', '            || _mainPartner == client\n', '            || (!_publicCreation && _mainPartner == 0)\n', '            || (_publicCreation && _mainPartner != 0)\n', '            || (recipient == 0 && _initialPriceMultiplier == 0)\n', '            || (recipient != 0 \n', '                && (FundingRules[1].initialPriceMultiplier == 0\n', '                    || _inflationRate < FundingRules[1].inflationRate\n', '                    || now < FundingRules[1].startTime\n', '                    || FundingRules[1].closingTime < now + (_minutesFundingPeriod * 1 minutes)))\n', '            || _maxAmountToFund == 0\n', '            || _minutesFundingPeriod == 0\n', '            ) throw;\n', '\n', '        FundingRules[0].startTime = now;\n', '        FundingRules[0].closingTime = now + _minutesFundingPeriod * 1 minutes;\n', '            \n', '        FundingRules[0].mainPartner = _mainPartner;\n', '        FundingRules[0].publicCreation = _publicCreation;\n', '        \n', '        if (recipient == 0) FundingRules[0].initialPriceMultiplier = _initialPriceMultiplier;\n', '        else FundingRules[0].initialPriceMultiplier = FundingRules[1].initialPriceMultiplier;\n', '        \n', '        if (recipient == 0) FundingRules[0].inflationRate = _inflationRate;\n', '        else FundingRules[0].inflationRate = FundingRules[1].inflationRate;\n', '        \n', '        FundingRules[0].fundedAmount = 0;\n', '        FundingRules[0].maxAmountToFund = _maxAmountToFund;\n', '\n', '        FundingRules[0].proposalID = _proposalID;\n', '\n', '        FundingRulesSet(_mainPartner, _proposalID, FundingRules[0].startTime, FundingRules[0].closingTime);\n', '            \n', '    } \n', '    \n', '    function createToken(\n', '        address _recipient, \n', '        uint _amount,\n', '        uint _saleDate\n', '    ) internal returns (bool success) {\n', '\n', '        if (now > FundingRules[0].closingTime\n', '            || now < FundingRules[0].startTime\n', '            ||_saleDate > FundingRules[0].closingTime\n', '            || _saleDate < FundingRules[0].startTime\n', '            || FundingRules[0].fundedAmount + _amount > FundingRules[0].maxAmountToFund) return;\n', '\n', '        uint _a = _amount*FundingRules[0].initialPriceMultiplier;\n', '        uint _multiplier = 100*_a;\n', '        uint _quantity = _multiplier/priceDivisor(_saleDate);\n', '        if (_a/_amount != FundingRules[0].initialPriceMultiplier\n', '            || _multiplier/100 != _a\n', '            || totalSupply + _quantity <= totalSupply \n', '            || totalSupply + _quantity <= _quantity) return;\n', '\n', '        balances[_recipient] += _quantity;\n', '        totalSupply += _quantity;\n', '        FundingRules[0].fundedAmount += _amount;\n', '\n', '        TokensCreated(msg.sender, _recipient, _quantity);\n', '        \n', '        if (FundingRules[0].fundedAmount == FundingRules[0].maxAmountToFund) closeFunding();\n', '        \n', '        return true;\n', '\n', '    }\n', '\n', '    function setFundingStartTime(uint _startTime) external onlyMainPartner {\n', '        if (now > FundingRules[0].closingTime) throw;\n', '        FundingRules[0].startTime = _startTime;\n', '    }\n', '    \n', '    function rewardToken(\n', '        address _recipient, \n', '        uint _amount,\n', '        uint _date\n', '        ) external onlyMainPartner {\n', '\n', '        uint _saleDate;\n', '        if (_date == 0) _saleDate = now; else _saleDate = _date;\n', '\n', '        if (!createToken(_recipient, _amount, _saleDate)) throw;\n', '\n', '    }\n', '\n', '    function closeFunding() internal {\n', '        if (recipient == 0) fundedAmount[FundingRules[0].proposalID] = FundingRules[0].fundedAmount;\n', '        FundingRules[0].closingTime = now;\n', '    }\n', '    \n', '    function setFundingFueled() external onlyMainPartner {\n', '        if (now > FundingRules[0].closingTime) throw;\n', '        closeFunding();\n', '        if (recipient == 0) FundingFueled(FundingRules[0].proposalID, FundingRules[0].fundedAmount);\n', '    }\n', '    \n', '    function ableTransfer() onlyClient {\n', '        if (!transferable) {\n', '            transferable = true;\n', '            TransferAble();\n', '        }\n', '    }\n', '\n', '    function disableTransfer() onlyClient {\n', '        if (transferable) {\n', '            transferable = false;\n', '            TransferDisable();\n', '        }\n', '    }\n', '    \n', '    function blockTransfer(address _shareHolder, uint _deadLine) external onlyClient onlyDao {\n', '        if (_deadLine > blockedDeadLine[_shareHolder]) {\n', '            blockedDeadLine[_shareHolder] = _deadLine;\n', '        }\n', '    }\n', '    \n', '    function transferFromTo(\n', '        address _from,\n', '        address _to, \n', '        uint256 _value\n', '        ) internal returns (bool) {  \n', '\n', '        if (transferable\n', '            && now > blockedDeadLine[_from]\n', '            && now > blockedDeadLine[_to]\n', '            && _to != address(this)\n', '            && balances[_from] >= _value\n', '            && balances[_to] + _value > balances[_to]\n', '            && balances[_to] + _value >= _value\n', '        ) {\n', '            balances[_from] -= _value;\n', '            balances[_to] += _value;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '        \n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) {  \n', '        if (!transferFromTo(msg.sender, _to, _value)) throw;\n', '    }\n', '\n', '    function transferFrom(\n', '        address _from, \n', '        address _to, \n', '        uint256 _value\n', '        ) returns (bool success) { \n', '        \n', '        if (allowed[_from][msg.sender] < _value\n', '            || !transferFromTo(_from, _to, _value)) throw;\n', '            \n', '        allowed[_from][msg.sender] -= _value;\n', '\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '}    \n', '  \n', '\n', 'pragma solidity ^0.4.2;\n', '\n', '/*\n', ' *\n', ' * This file is part of Pass DAO.\n', ' *\n', ' * The Manager smart contract is used for the management of accounts and tokens.\n', ' * Allows to receive or withdraw ethers and to buy Dao shares.\n', ' * The contract derives to the Token Manager smart contract for the management of tokens.\n', ' *\n', ' * Recipient is 0 for the Dao account manager and the address of\n', " * contractor's recipient for the contractors's mahagers.\n", ' *\n', '*/\n', '\n', '/// @title Manager smart contract of the Pass Decentralized Autonomous Organisation\n', 'contract PassManagerInterface is PassTokenManagerInterface {\n', '\n', '    struct proposal {\n', '        // Amount (in wei) of the proposal\n', '        uint amount;\n', '        // A description of the proposal\n', '        string description;\n', "        // The hash of the proposal's document\n", '        bytes32 hashOfTheDocument;\n', '        // A unix timestamp, denoting the date when the proposal was created\n', '        uint dateOfProposal;\n', '        // The sum amount (in wei) ordered for this proposal \n', '        uint orderAmount;\n', '        // A unix timestamp, denoting the date of the last order for the approved proposal\n', '        uint dateOfOrder;\n', '    }\n', '        \n', '    // Proposals to work for the client\n', '    proposal[] public proposals;\n', '    \n', '    /// @dev The constructor function\n', '    /// @param _creator The address of the creator\n', '    /// @param _client The address of the Dao\n', '    /// @param _recipient The address of the recipient. 0 for the Dao\n', '    //function PassManager(\n', '        //address _creator,\n', '        //address _client,\n', '        //address _recipient\n', '    //) PassTokenManager(\n', '        //_creator,\n', '        //_client,\n', '        //_recipient);\n', '\n', '    /// @notice Fallback function to allow sending ethers to this smart contract\n', '    function () payable;\n', '    \n', '    /// @notice Function to update the recipent address\n', '    /// @param _newRecipient The adress of the recipient\n', '    function updateRecipient(address _newRecipient);\n', '\n', '    /// @notice Function to buy Dao shares according to the funding rules \n', '    /// with `msg.sender` as the beneficiary\n', '    function buyShares() payable;\n', '    \n', '    /// @notice Function to buy Dao shares according to the funding rules \n', '    /// @param _recipient The beneficiary of the created shares\n', '    function buySharesFor(address _recipient) payable;\n', '\n', '    /// @notice Function to make a proposal to work for the client\n', '    /// @param _amount The amount (in wei) of the proposal\n', '    /// @param _description String describing the proposal\n', '    /// @param _hashOfTheDocument The hash of the proposal document\n', '    /// @return The index of the contractor proposal\n', '    function newProposal(\n', '        uint _amount,\n', '        string _description, \n', '        bytes32 _hashOfTheDocument\n', '    ) returns (uint);\n', '    \n', '    /// @notice Function used by the client to order according to the contractor proposal\n', '    /// @param _proposalID The index of the contractor proposal\n', '    /// @param _amount The amount (in wei) of the order\n', '    /// @return Whether the order was made or not\n', '    function order(\n', '        uint _proposalID,\n', '        uint _amount\n', '    ) external returns (bool) ;\n', '    \n', '    /// @notice Function used by the client to send ethers from the Dao manager\n', '    /// @param _recipient The address to send to\n', '    /// @param _amount The amount (in wei) to send\n', '    /// @return Whether the transfer was successful or not\n', '    function sendTo(\n', '        address _recipient, \n', '        uint _amount\n', '    ) external returns (bool);\n', '\n', '    /// @notice Function to allow contractors to withdraw ethers\n', '    /// @param _amount The amount (in wei) to withdraw\n', '    function withdraw(uint _amount);\n', '    \n', '    event ProposalAdded(uint indexed ProposalID, uint Amount, string Description);\n', '    event Order(uint indexed ProposalID, uint Amount);\n', '    event Withdawal(address indexed Recipient, uint Amount);\n', '\n', '}    \n', '\n', 'contract PassManager is PassManagerInterface, PassTokenManager {\n', '\n', '    function PassManager(\n', '        address _creator,\n', '        address _client,\n', '        address _recipient\n', '    ) PassTokenManager(\n', '        _creator,\n', '        _client,\n', '        _recipient\n', '        ) {\n', '        proposals.length = 1;\n', '    }\n', '\n', '    function () payable {}\n', '\n', '    function updateRecipient(address _newRecipient) onlyContractor {\n', '\n', '        if (_newRecipient == 0 \n', '            || _newRecipient == client) throw;\n', '\n', '        recipient = _newRecipient;\n', '    } \n', '\n', '    function buyShares() payable {\n', '        buySharesFor(msg.sender);\n', '    } \n', '    \n', '    function buySharesFor(address _recipient) payable onlyDao {\n', '        \n', '        if (!FundingRules[0].publicCreation \n', '            || !createToken(_recipient, msg.value, now)) throw;\n', '\n', '    }\n', '   \n', '    function newProposal(\n', '        uint _amount,\n', '        string _description, \n', '        bytes32 _hashOfTheDocument\n', '    ) onlyContractor returns (uint) {\n', '\n', '        uint _proposalID = proposals.length++;\n', '        proposal c = proposals[_proposalID];\n', '\n', '        c.amount = _amount;\n', '        c.description = _description;\n', '        c.hashOfTheDocument = _hashOfTheDocument; \n', '        c.dateOfProposal = now;\n', '        \n', '        ProposalAdded(_proposalID, c.amount, c.description);\n', '        \n', '        return _proposalID;\n', '        \n', '    }\n', '    \n', '    function order(\n', '        uint _proposalID,\n', '        uint _orderAmount\n', '    ) external onlyClient returns (bool) {\n', '    \n', '        proposal c = proposals[_proposalID];\n', '        \n', '        uint _sum = c.orderAmount + _orderAmount;\n', '        if (_sum > c.amount\n', '            || _sum < c.orderAmount\n', '            || _sum < _orderAmount) return; \n', '\n', '        c.orderAmount = _sum;\n', '        c.dateOfOrder = now;\n', '        \n', '        Order(_proposalID, _orderAmount);\n', '        \n', '        return true;\n', '\n', '    }\n', '\n', '    function sendTo(\n', '        address _recipient,\n', '        uint _amount\n', '    ) external onlyClient onlyDao returns (bool) {\n', '    \n', '        if (_recipient.send(_amount)) return true;\n', '        else return false;\n', '\n', '    }\n', '   \n', '    function withdraw(uint _amount) onlyContractor {\n', '        if (!recipient.send(_amount)) throw;\n', '        Withdawal(recipient, _amount);\n', '    }\n', '    \n', '}    \n', '\n', 'contract PassManagerCreator {\n', '    event NewPassManager(address Creator, address Client, address Recipient, address PassManager);\n', '    function createManager(\n', '        address _client,\n', '        address _recipient\n', '        ) returns (PassManager) {\n', '        PassManager _passManager = new PassManager(\n', '            msg.sender,\n', '            _client,\n', '            _recipient\n', '        );\n', '        NewPassManager(msg.sender, _client, _recipient, _passManager);\n', '        return _passManager;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.4.2;\n', '\n', '/*\n', 'This file is part of Pass DAO.\n', '\n', 'Pass DAO is free software: you can redistribute it and/or modify\n', 'it under the terms of the GNU lesser General Public License as published by\n', 'the Free Software Foundation, either version 3 of the License, or\n', '(at your option) any later version.\n', '\n', 'Pass DAO is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', 'GNU lesser General Public License for more details.\n', '\n', 'You should have received a copy of the GNU lesser General Public License\n', 'along with Pass DAO.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '/*\n', 'Smart contract for a Decentralized Autonomous Organization (DAO)\n', 'to automate organizational governance and decision-making.\n', '*/\n', '\n', '/// @title Pass Decentralized Autonomous Organisation\n', 'contract PassDaoInterface {\n', '\n', '    struct BoardMeeting {        \n', '        // Address of the creator of the board meeting for a proposal\n', '        address creator;  \n', '        // Index to identify the proposal to pay a contractor or fund the Dao\n', '        uint proposalID;\n', '        // Index to identify the proposal to update the Dao rules \n', '        uint daoRulesProposalID; \n', '        // unix timestamp, denoting the end of the set period of a proposal before the board meeting \n', '        uint setDeadline;\n', '        // Fees (in wei) paid by the creator of the board meeting\n', '        uint fees;\n', '        // Total of fees (in wei) rewarded to the voters or to the Dao account manager for the balance\n', '        uint totalRewardedAmount;\n', '        // A unix timestamp, denoting the end of the voting period\n', '        uint votingDeadline;\n', "        // True if the proposal's votes have yet to be counted, otherwise False\n", '        bool open; \n', '        // A unix timestamp, denoting the date of the execution of the approved proposal\n', '        uint dateOfExecution;\n', '        // Number of shares in favor of the proposal\n', '        uint yea; \n', '        // Number of shares opposed to the proposal\n', '        uint nay; \n', '        // mapping to indicate if a shareholder has voted\n', '        mapping (address => bool) hasVoted;  \n', '    }\n', '\n', '    struct Proposal {\n', '        // Index to identify the board meeting of the proposal\n', '        uint boardMeetingID;\n', '        // The contractor manager smart contract\n', '        PassManager contractorManager;\n', '        // The index of the contractor proposal\n', '        uint contractorProposalID;\n', '        // The amount (in wei) of the proposal\n', '        uint amount; \n', '        // True if the proposal foresees a contractor token creation\n', '        bool tokenCreation;\n', '        // True if public funding without a main partner\n', '        bool publicShareCreation; \n', '        // The address which sets partners and manages the funding in case of private funding\n', '        address mainPartner;\n', '        // The initial price multiplier of Dao shares at the beginning of the funding\n', '        uint initialSharePriceMultiplier; \n', '        // The inflation rate to calculate the actual contractor share price\n', '        uint inflationRate;\n', '        // A unix timestamp, denoting the start time of the funding\n', '        uint minutesFundingPeriod;\n', '        // True if the proposal is closed\n', '        bool open; \n', '    }\n', '\n', '    struct Rules {\n', '        // Index to identify the board meeting that decides to apply or not the Dao rules\n', '        uint boardMeetingID;  \n', '        // The quorum needed for each proposal is calculated by totalSupply / minQuorumDivisor\n', '        uint minQuorumDivisor;  \n', '        // Minimum fees (in wei) to create a proposal\n', '        uint minBoardMeetingFees; \n', '        // Period in minutes to consider or set a proposal before the voting procedure\n', '        uint minutesSetProposalPeriod; \n', '        // The minimum debate period in minutes that a generic proposal can have\n', '        uint minMinutesDebatePeriod;\n', '        // The inflation rate to calculate the reward of fees to voters during a board meeting \n', '        uint feesRewardInflationRate;\n', '        // True if the dao rules allow the transfer of shares\n', '        bool transferable;\n', '    } \n', '\n', '    // The creator of the Dao\n', '    address creator;\n', '    // The minimum periods in minutes \n', '    uint public minMinutesPeriods;\n', '    // The maximum period in minutes for proposals (set+debate)\n', '    uint public maxMinutesProposalPeriod;\n', '    // The maximum funding period in minutes for funding proposals\n', '    uint public maxMinutesFundingPeriod;\n', '    // The maximum inflation rate for share price or rewards to voters\n', '    uint public maxInflationRate;\n', '\n', '    // The Dao manager smart contract\n', '    PassManager public daoManager;\n', '    \n', '    // Map to allow the share holders to withdraw board meeting fees\n', '    mapping (address => uint) public pendingFeesWithdrawals;\n', '\n', '    // Board meetings to vote for or against a proposal\n', '    BoardMeeting[] public BoardMeetings; \n', '    // Proposals to pay a contractor or fund the Dao\n', '    Proposal[] public Proposals;\n', '    // Proposals to update the Dao rules\n', '    Rules[] public DaoRulesProposals;\n', '    // The current Dao rules\n', '    Rules public DaoRules; \n', '    \n', '    /// @dev The constructor function\n', '    //function PassDao();\n', '\n', '    /// @dev Function to initialize the Dao\n', '    /// @param _daoManager Address of the Dao manager smart contract\n', '    /// @param _maxInflationRate The maximum inflation rate for contractor and funding proposals\n', '    /// @param _minMinutesPeriods The minimum periods in minutes\n', '    /// @param _maxMinutesFundingPeriod The maximum funding period in minutes for funding proposals\n', '    /// @param _maxMinutesProposalPeriod The maximum period in minutes for proposals (set+debate)\n', '    /// @param _minQuorumDivisor The initial minimum quorum divisor for the proposals\n', '    /// @param _minBoardMeetingFees The amount (in wei) to make a proposal and ask for a board meeting\n', '    /// @param _minutesSetProposalPeriod The minimum period in minutes before a board meeting\n', '    /// @param _minMinutesDebatePeriod The minimum period in minutes of the board meetings\n', '    /// @param _feesRewardInflationRate The inflation rate to calculate the reward of fees to voters during a board meeting\n', '    function initDao(\n', '        address _daoManager,\n', '        uint _maxInflationRate,\n', '        uint _minMinutesPeriods,\n', '        uint _maxMinutesFundingPeriod,\n', '        uint _maxMinutesProposalPeriod,\n', '        uint _minQuorumDivisor,\n', '        uint _minBoardMeetingFees,\n', '        uint _minutesSetProposalPeriod,\n', '        uint _minMinutesDebatePeriod,\n', '        uint _feesRewardInflationRate\n', '        );\n', '    \n', '    /// @dev Internal function to create a board meeting\n', '    /// @param _proposalID The index of the proposal if for a contractor or for a funding\n', '    /// @param _daoRulesProposalID The index of the proposal if Dao rules\n', '    /// @param _minutesDebatingPeriod The duration in minutes of the meeting\n', '    /// @return the index of the board meeting\n', '    function newBoardMeeting(\n', '        uint _proposalID, \n', '        uint _daoRulesProposalID, \n', '        uint _minutesDebatingPeriod\n', '    ) internal returns (uint);\n', '    \n', '    /// @notice Function to make a proposal to pay a contractor or fund the Dao\n', '    /// @param _contractorManager Address of the contractor manager smart contract\n', '    /// @param _contractorProposalID Index of the contractor proposal of the contractor manager\n', '    /// @param _amount The amount (in wei) of the proposal\n', '    /// @param _tokenCreation True if the proposal foresees a contractor token creation\n', '    /// @param _publicShareCreation True if public funding without a main partner\n', '    /// @param _mainPartner The address which sets partners and manage the funding \n', '    /// in case of private funding (not mandatory)\n', '    /// @param _initialSharePriceMultiplier The initial price multiplier of shares\n', "    /// @param _inflationRate If 0, the share price doesn't change during the funding (not mandatory)\n", '    /// @param _minutesFundingPeriod Period in minutes of the funding\n', '    /// @param _minutesDebatingPeriod Period in minutes of the board meeting to vote on the proposal\n', '    /// @return The index of the proposal\n', '    function newProposal(\n', '        address _contractorManager,\n', '        uint _contractorProposalID,\n', '        uint _amount, \n', '        bool _publicShareCreation,\n', '        bool _tokenCreation,\n', '        address _mainPartner,\n', '        uint _initialSharePriceMultiplier, \n', '        uint _inflationRate,\n', '        uint _minutesFundingPeriod,\n', '        uint _minutesDebatingPeriod\n', '    ) payable returns (uint);\n', '\n', '    /// @notice Function to make a proposal to change the Dao rules \n', '    /// @param _minQuorumDivisor If 5, the minimum quorum is 20%\n', '    /// @param _minBoardMeetingFees The amount (in wei) to make a proposal and ask for a board meeting\n', '    /// @param _minutesSetProposalPeriod Minimum period in minutes before a board meeting\n', '    /// @param _minMinutesDebatePeriod The minimum period in minutes of the board meetings\n', '    /// @param _feesRewardInflationRate The inflation rate to calculate the reward of fees to voters during a board meeting\n', '    /// @param _transferable True if the proposal foresees to allow the transfer of Dao shares\n', '    /// @param _minutesDebatingPeriod Period in minutes of the board meeting to vote on the proposal\n', '    function newDaoRulesProposal(\n', '        uint _minQuorumDivisor, \n', '        uint _minBoardMeetingFees,\n', '        uint _minutesSetProposalPeriod,\n', '        uint _minMinutesDebatePeriod,\n', '        uint _feesRewardInflationRate,\n', '        bool _transferable,\n', '        uint _minutesDebatingPeriod\n', '    ) payable returns (uint);\n', '    \n', '    /// @notice Function to vote during a board meeting\n', '    /// @param _boardMeetingID The index of the board meeting\n', '    /// @param _supportsProposal True if the proposal is supported\n', '    function vote(\n', '        uint _boardMeetingID, \n', '        bool _supportsProposal\n', '    );\n', '\n', '    /// @notice Function to execute a board meeting decision and close the board meeting\n', '    /// @param _boardMeetingID The index of the board meeting\n', '    /// @return Whether the proposal was executed or not\n', '    function executeDecision(uint _boardMeetingID) returns (bool);\n', '    \n', '    /// @notice Function to order a contractor proposal\n', '    /// @param _proposalID The index of the proposal\n', '    /// @return Whether the proposal was ordered and the proposal amount sent or not\n', '    function orderContractorProposal(uint _proposalID) returns (bool);   \n', '\n', '    /// @notice Function to withdraw the rewarded board meeting fees\n', '    /// @return Whether the withdraw was successful or not    \n', '    function withdrawBoardMeetingFees() returns (bool);\n', '\n', '    /// @return The minimum quorum for proposals to pass \n', '    function minQuorum() constant returns (uint);\n', '    \n', '    event ProposalAdded(uint indexed ProposalID, address indexed ContractorManager, uint ContractorProposalID, \n', '            uint amount, address indexed MainPartner, uint InitialSharePriceMultiplier, uint MinutesFundingPeriod);\n', '    event DaoRulesProposalAdded(uint indexed DaoRulesProposalID, uint MinQuorumDivisor, uint MinBoardMeetingFees, \n', '            uint MinutesSetProposalPeriod, uint MinMinutesDebatePeriod, uint FeesRewardInflationRate, bool Transferable);\n', '    event SentToContractor(uint indexed ContractorProposalID, address indexed ContractorManagerAddress, uint AmountSent);\n', '    event BoardMeetingClosed(uint indexed BoardMeetingID, uint FeesGivenBack, bool ProposalExecuted);\n', '    \n', '}\n', '\n', 'contract PassDao is PassDaoInterface {\n', '\n', '    function PassDao() {}\n', '    \n', '    function initDao(\n', '        address _daoManager,\n', '        uint _maxInflationRate,\n', '        uint _minMinutesPeriods,\n', '        uint _maxMinutesFundingPeriod,\n', '        uint _maxMinutesProposalPeriod,\n', '        uint _minQuorumDivisor,\n', '        uint _minBoardMeetingFees,\n', '        uint _minutesSetProposalPeriod,\n', '        uint _minMinutesDebatePeriod,\n', '        uint _feesRewardInflationRate\n', '        ) {\n', '            \n', '        \n', '        if (DaoRules.minQuorumDivisor != 0) throw;\n', '\n', '        daoManager = PassManager(_daoManager);\n', '\n', '        maxInflationRate = _maxInflationRate;\n', '        minMinutesPeriods = _minMinutesPeriods;\n', '        maxMinutesFundingPeriod = _maxMinutesFundingPeriod;\n', '        maxMinutesProposalPeriod = _maxMinutesProposalPeriod;\n', '        \n', '        DaoRules.minQuorumDivisor = _minQuorumDivisor;\n', '        DaoRules.minBoardMeetingFees = _minBoardMeetingFees;\n', '        DaoRules.minutesSetProposalPeriod = _minutesSetProposalPeriod;\n', '        DaoRules.minMinutesDebatePeriod = _minMinutesDebatePeriod;\n', '        DaoRules.feesRewardInflationRate = _feesRewardInflationRate;\n', '\n', '        BoardMeetings.length = 1; \n', '        Proposals.length = 1;\n', '        DaoRulesProposals.length = 1;\n', '        \n', '    }\n', '    \n', '    function newBoardMeeting(\n', '        uint _proposalID, \n', '        uint _daoRulesProposalID, \n', '        uint _minutesDebatingPeriod\n', '    ) internal returns (uint) {\n', '\n', '        if (msg.value < DaoRules.minBoardMeetingFees\n', '            || DaoRules.minutesSetProposalPeriod + _minutesDebatingPeriod > maxMinutesProposalPeriod\n', '            || now + ((DaoRules.minutesSetProposalPeriod + _minutesDebatingPeriod) * 1 minutes) < now\n', '            || _minutesDebatingPeriod < DaoRules.minMinutesDebatePeriod\n', '            || msg.sender == address(this)) throw;\n', '\n', '        uint _boardMeetingID = BoardMeetings.length++;\n', '        BoardMeeting b = BoardMeetings[_boardMeetingID];\n', '\n', '        b.creator = msg.sender;\n', '\n', '        b.proposalID = _proposalID;\n', '        b.daoRulesProposalID = _daoRulesProposalID;\n', '\n', '        b.fees = msg.value;\n', '        \n', '        b.setDeadline = now + (DaoRules.minutesSetProposalPeriod * 1 minutes);        \n', '        b.votingDeadline = b.setDeadline + (_minutesDebatingPeriod * 1 minutes); \n', '\n', '        b.open = true; \n', '\n', '        return _boardMeetingID;\n', '\n', '    }\n', '\n', '    function newProposal(\n', '        address _contractorManager,\n', '        uint _contractorProposalID,\n', '        uint _amount, \n', '        bool _tokenCreation,\n', '        bool _publicShareCreation,\n', '        address _mainPartner,\n', '        uint _initialSharePriceMultiplier, \n', '        uint _inflationRate,\n', '        uint _minutesFundingPeriod,\n', '        uint _minutesDebatingPeriod\n', '    ) payable returns (uint) {\n', '\n', '        if ((_contractorManager != 0 && _contractorProposalID == 0)\n', '            || (_contractorManager == 0 \n', '                && (_initialSharePriceMultiplier == 0\n', '                    || _contractorProposalID != 0)\n', '            || (_tokenCreation && _publicShareCreation)\n', '            || (_initialSharePriceMultiplier != 0\n', '                && (_minutesFundingPeriod < minMinutesPeriods\n', '                    || _inflationRate > maxInflationRate\n', '                    || _minutesFundingPeriod > maxMinutesFundingPeriod)))) throw;\n', '\n', '        uint _proposalID = Proposals.length++;\n', '        Proposal p = Proposals[_proposalID];\n', '\n', '        p.contractorManager = PassManager(_contractorManager);\n', '        p.contractorProposalID = _contractorProposalID;\n', '        \n', '        p.amount = _amount;\n', '        p.tokenCreation = _tokenCreation;\n', '\n', '        p.publicShareCreation = _publicShareCreation;\n', '        p.mainPartner = _mainPartner;\n', '        p.initialSharePriceMultiplier = _initialSharePriceMultiplier;\n', '        p.inflationRate = _inflationRate;\n', '        p.minutesFundingPeriod = _minutesFundingPeriod;\n', '\n', '        p.boardMeetingID = newBoardMeeting(_proposalID, 0, _minutesDebatingPeriod);   \n', '\n', '        p.open = true;\n', '        \n', '        ProposalAdded(_proposalID, p.contractorManager, p.contractorProposalID, p.amount, p.mainPartner, \n', '            p.initialSharePriceMultiplier, _minutesFundingPeriod);\n', '\n', '        return _proposalID;\n', '        \n', '    }\n', '\n', '    function newDaoRulesProposal(\n', '        uint _minQuorumDivisor, \n', '        uint _minBoardMeetingFees,\n', '        uint _minutesSetProposalPeriod,\n', '        uint _minMinutesDebatePeriod,\n', '        uint _feesRewardInflationRate,\n', '        bool _transferable,\n', '        uint _minutesDebatingPeriod\n', '    ) payable returns (uint) {\n', '    \n', '        if (_minQuorumDivisor <= 1\n', '            || _minQuorumDivisor > 10\n', '            || _minutesSetProposalPeriod < minMinutesPeriods\n', '            || _minMinutesDebatePeriod < minMinutesPeriods\n', '            || _minutesSetProposalPeriod + _minMinutesDebatePeriod > maxMinutesProposalPeriod\n', '            || _feesRewardInflationRate > maxInflationRate\n', '            ) throw; \n', '        \n', '        uint _DaoRulesProposalID = DaoRulesProposals.length++;\n', '        Rules r = DaoRulesProposals[_DaoRulesProposalID];\n', '\n', '        r.minQuorumDivisor = _minQuorumDivisor;\n', '        r.minBoardMeetingFees = _minBoardMeetingFees;\n', '        r.minutesSetProposalPeriod = _minutesSetProposalPeriod;\n', '        r.minMinutesDebatePeriod = _minMinutesDebatePeriod;\n', '        r.feesRewardInflationRate = _feesRewardInflationRate;\n', '        r.transferable = _transferable;\n', '        \n', '        r.boardMeetingID = newBoardMeeting(0, _DaoRulesProposalID, _minutesDebatingPeriod);     \n', '\n', '        DaoRulesProposalAdded(_DaoRulesProposalID, _minQuorumDivisor, _minBoardMeetingFees, \n', '            _minutesSetProposalPeriod, _minMinutesDebatePeriod, _feesRewardInflationRate ,_transferable);\n', '\n', '        return _DaoRulesProposalID;\n', '        \n', '    }\n', '    \n', '    function vote(\n', '        uint _boardMeetingID, \n', '        bool _supportsProposal\n', '    ) {\n', '        \n', '        BoardMeeting b = BoardMeetings[_boardMeetingID];\n', '\n', '        if (b.hasVoted[msg.sender] \n', '            || now < b.setDeadline\n', '            || now > b.votingDeadline) throw;\n', '\n', '        uint _balance = uint(daoManager.balanceOf(msg.sender));\n', '        if (_balance == 0) throw;\n', '        \n', '        b.hasVoted[msg.sender] = true;\n', '\n', '        if (_supportsProposal) b.yea += _balance;\n', '        else b.nay += _balance; \n', '\n', '        if (b.fees > 0 && b.proposalID != 0 && Proposals[b.proposalID].contractorProposalID != 0) {\n', '\n', '            uint _a = 100*b.fees;\n', '            if ((_a/100 != b.fees) || ((_a*_balance)/_a != _balance)) throw;\n', '            uint _multiplier = (_a*_balance)/uint(daoManager.TotalSupply());\n', '\n', '            uint _divisor = 100 + 100*DaoRules.feesRewardInflationRate*(now - b.setDeadline)/(100*365 days);\n', '\n', '            uint _rewardedamount = _multiplier/_divisor;\n', '            \n', '            if (b.totalRewardedAmount + _rewardedamount > b.fees) _rewardedamount = b.fees - b.totalRewardedAmount;\n', '            b.totalRewardedAmount += _rewardedamount;\n', '            pendingFeesWithdrawals[msg.sender] += _rewardedamount;\n', '        }\n', '\n', '        daoManager.blockTransfer(msg.sender, b.votingDeadline);\n', '\n', '    }\n', '\n', '    function executeDecision(uint _boardMeetingID) returns (bool) {\n', '\n', '        BoardMeeting b = BoardMeetings[_boardMeetingID];\n', '        Proposal p = Proposals[b.proposalID];\n', '        \n', '        if (now < b.votingDeadline || !b.open) throw;\n', '        \n', '        b.open = false;\n', '        if (p.contractorProposalID == 0) p.open = false;\n', '\n', '        uint _fees;\n', '        uint _minQuorum = minQuorum();\n', '\n', '        if (b.fees > 0\n', '            && (b.proposalID == 0 || p.contractorProposalID == 0)\n', '            && b.yea + b.nay >= _minQuorum) {\n', '                    _fees = b.fees;\n', '                    b.fees = 0;\n', '                    pendingFeesWithdrawals[b.creator] += _fees;\n', '        }        \n', '\n', '        if (b.fees - b.totalRewardedAmount > 0) {\n', '            if (!daoManager.send(b.fees - b.totalRewardedAmount)) throw;\n', '        }\n', '        \n', '        if (b.yea + b.nay < _minQuorum || b.yea <= b.nay) {\n', '            p.open = false;\n', '            BoardMeetingClosed(_boardMeetingID, _fees, false);\n', '            return;\n', '        }\n', '\n', '        b.dateOfExecution = now;\n', '\n', '        if (b.proposalID != 0) {\n', '            \n', '            if (p.initialSharePriceMultiplier != 0) {\n', '\n', '                daoManager.setFundingRules(p.mainPartner, p.publicShareCreation, p.initialSharePriceMultiplier, \n', '                    p.amount, p.minutesFundingPeriod, p.inflationRate, b.proposalID);\n', '\n', '                if (p.contractorProposalID != 0 && p.tokenCreation) {\n', '                    p.contractorManager.setFundingRules(p.mainPartner, p.publicShareCreation, 0, \n', '                        p.amount, p.minutesFundingPeriod, maxInflationRate, b.proposalID);\n', '                }\n', '\n', '            }\n', '\n', '        } else {\n', '\n', '            Rules r = DaoRulesProposals[b.daoRulesProposalID];\n', '            DaoRules.boardMeetingID = r.boardMeetingID;\n', '\n', '            DaoRules.minQuorumDivisor = r.minQuorumDivisor;\n', '            DaoRules.minMinutesDebatePeriod = r.minMinutesDebatePeriod; \n', '            DaoRules.minBoardMeetingFees = r.minBoardMeetingFees;\n', '            DaoRules.minutesSetProposalPeriod = r.minutesSetProposalPeriod;\n', '            DaoRules.feesRewardInflationRate = r.feesRewardInflationRate;\n', '\n', '            DaoRules.transferable = r.transferable;\n', '            if (r.transferable) daoManager.ableTransfer();\n', '            else daoManager.disableTransfer();\n', '        }\n', '            \n', '        BoardMeetingClosed(_boardMeetingID, _fees, true);\n', '\n', '        return true;\n', '        \n', '    }\n', '    \n', '    function orderContractorProposal(uint _proposalID) returns (bool) {\n', '        \n', '        Proposal p = Proposals[_proposalID];\n', '        BoardMeeting b = BoardMeetings[p.boardMeetingID];\n', '\n', '        if (b.open || !p.open) throw;\n', '        \n', '        uint _amount = p.amount;\n', '\n', '        if (p.initialSharePriceMultiplier != 0) {\n', '            _amount = daoManager.FundedAmount(_proposalID);\n', '            if (_amount == 0 && now < b.dateOfExecution + (p.minutesFundingPeriod * 1 minutes)) return;\n', '        }\n', '        \n', '        p.open = false;   \n', '\n', '        if (_amount == 0 || !p.contractorManager.order(p.contractorProposalID, _amount)) return;\n', '        \n', '        if (!daoManager.sendTo(p.contractorManager, _amount)) throw;\n', '        SentToContractor(p.contractorProposalID, address(p.contractorManager), _amount);\n', '        \n', '        return true;\n', '\n', '    }\n', '    \n', '    function withdrawBoardMeetingFees() returns (bool) {\n', '\n', '        uint _amount = pendingFeesWithdrawals[msg.sender];\n', '\n', '        pendingFeesWithdrawals[msg.sender] = 0;\n', '\n', '        if (msg.sender.send(_amount)) {\n', '            return true;\n', '        } else {\n', '            pendingFeesWithdrawals[msg.sender] = _amount;\n', '            return false;\n', '        }\n', '\n', '    }\n', '\n', '    function minQuorum() constant returns (uint) {\n', '        return (uint(daoManager.TotalSupply()) / DaoRules.minQuorumDivisor);\n', '    }\n', '    \n', '}']