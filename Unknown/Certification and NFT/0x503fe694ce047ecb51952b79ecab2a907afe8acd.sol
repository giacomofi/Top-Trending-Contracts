['pragma solidity ^0.4.11;\n', '\n', '\n', 'contract MaptPricing {\n', '  // MAPT TOKEN PRICE:\n', '  uint256 constant MAPT_IN_ETH = 100; // 1 MAPT = 0.01 ETH\n', '\n', '  uint256 constant FRACTIONAL_DIVIDER = 100;\n', '  uint256 constant DEFAULT_MULTIPLIER = 1 * FRACTIONAL_DIVIDER;\n', '\n', '  uint constant MIN_ETH = 100 ether;\n', '\n', '  uint256[4] prices;\n', '  uint256[3] dates;\n', '  mapping (uint256 => uint256[]) rules;\n', '\n', '  function MaptPricing() {\n', '  }\n', '\n', '  function createPricing() {\n', '    prices[0] = 3000 ether;\n', '    prices[1] = 1500 ether;\n', '    prices[2] = 300 ether;\n', '    prices[3] = 100 ether;\n', '\n', '    dates[0] = 7 days;\n', '    dates[1] = 14 days;\n', '    dates[2] = 140 days;\n', '\n', '    rules[0] = [200, 150, 130, 120];\n', '    rules[1] = [200, 145, 125, 115];\n', '    rules[2] = [200, 145, 125, 115];\n', '  }\n', '\n', '  function calculatePrice(uint valueWei, uint256 timeSinceStart, uint decimals) public returns (uint tokenAmount) {\n', '    uint Z = 1231231;\n', '    uint m = 0;\n', '    uint ip = Z;\n', '    uint dp = Z;\n', '    uint tokens;\n', '\n', '    require(valueWei >= MIN_ETH);\n', '\n', '    if (valueWei >= prices[0]) ip = 0;\n', '    else for (uint i = 1; i < prices.length && ip == Z; i++) {\n', '      if (valueWei < prices[i-1] && valueWei >= prices[i]) ip = i;\n', '    }\n', '\n', '    if (ip == Z) {\n', '      m = DEFAULT_MULTIPLIER;\n', '    } else {\n', '      if (timeSinceStart <= dates[0]) {\n', '        dp = 0;\n', '      } else {\n', '        for (i = 1; i < dates.length && dp == Z; i++) {\n', '          if (timeSinceStart > dates[i-1] && timeSinceStart < dates[i]) {\n', '            dp = i;\n', '          }\n', '        }\n', '        //later on\n', '        if (timeSinceStart > dates[dates.length-1]) {\n', '          dp = dates.length-1;\n', '        }\n', '      }\n', '\n', '      if (dp == Z) {\n', '        m = DEFAULT_MULTIPLIER;\n', '      } else {\n', '        m = (rules[dp])[ip];\n', '      }\n', '    }\n', '\n', '    tokens = valueWei * MAPT_IN_ETH;\n', '\n', '    uint d = decimals;\n', '    d++;\n', '\n', '    uint res = tokens * m / DEFAULT_MULTIPLIER;\n', '\n', '    return res;\n', '  }\n', '}\n', '\n', 'contract MaptPresaleToken {\n', '\n', '    uint constant MIN_TRANSACTION_AMOUNT_ETH = 100 ether;\n', '\n', '    MaptPricing priceRules = new MaptPricing();\n', '    uint public PRESALE_START_DATE = 1503313200; //Mon Aug 21 12:00:00 +00 2017\n', '    uint public PRESALE_END_DATE = PRESALE_START_DATE + 30 days;\n', '\n', '    function MaptPresaleToken(address _tokenManager, address _escrow) {\n', '        tokenManager = _tokenManager;\n', '        escrow = _escrow;\n', '        priceRules.createPricing();\n', '    }\n', '\n', '    string public constant name = "MAT Presale Token";\n', '    string public constant symbol = "MAPT";\n', '    uint   public constant decimals = 18;\n', '\n', '    uint public constant TOKEN_SUPPLY_LIMIT = 2800000 * 1 ether / 1 wei;\n', '\n', '    enum Phase {\n', '        Created,\n', '        Running,\n', '        Paused,\n', '        Migrating,\n', '        Migrated\n', '    }\n', '\n', '    Phase public currentPhase = Phase.Created;\n', '\n', '    uint public totalSupply = 0;\n', '\n', '    address public tokenManager;\n', '\n', '    address public escrow;\n', '\n', '    address public crowdsaleManager;\n', '\n', '    mapping (address => uint256) private balanceTable;\n', '\n', '    modifier onlyTokenManager()     { if(msg.sender != tokenManager) throw; _; }\n', '    modifier onlyCrowdsaleManager() { if(msg.sender != crowdsaleManager) throw; _; }\n', '\n', '    event LogBuy(address indexed owner, uint etherWeiIncoming, uint tokensSold);\n', '    event LogBuyForFiat(address indexed owner, uint tokensSold);\n', '    event LogBurn(address indexed owner, uint value);\n', '    event LogPhaseSwitch(Phase newPhase);\n', '    event LogEscrow(uint balance);\n', '    event LogEscrowReq(uint balance);\n', '    event LogStartDate(uint newdate, uint oldDate);\n', '\n', '    function() payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function burnTokens(address _owner)\n', '        public\n', '        onlyCrowdsaleManager\n', '        returns (uint)\n', '    {\n', '        if(currentPhase != Phase.Migrating) return 1;\n', '\n', '        uint tokens = balanceTable[_owner];\n', '        if(tokens == 0) return 2;\n', '        totalSupply -= tokens;\n', '        balanceTable[_owner] = 0;\n', '        LogBurn(_owner, tokens);\n', '\n', '        if(totalSupply == 0) {\n', '            currentPhase = Phase.Migrated;\n', '            LogPhaseSwitch(Phase.Migrated);\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256) {\n', '        return balanceTable[_owner];\n', '    }\n', '\n', '    function setPresalePhaseUInt(uint phase)\n', '        public\n', '        onlyTokenManager\n', '    {\n', '      require( uint(Phase.Migrated) >= phase && phase >= 0 );\n', '      setPresalePhase(Phase(phase));\n', '    }\n', '\n', '    function setPresalePhase(Phase _nextPhase)\n', '        public\n', '        onlyTokenManager\n', '    {\n', '      _setPresalePhase(_nextPhase);\n', '    }\n', '\n', '    function _setPresalePhase(Phase _nextPhase)\n', '        private\n', '    {\n', '        bool canSwitchPhase\n', '            =  (currentPhase == Phase.Created && _nextPhase == Phase.Running)\n', '            || (currentPhase == Phase.Running && _nextPhase == Phase.Paused)\n', '            || ((currentPhase == Phase.Running || currentPhase == Phase.Paused)\n', '                && _nextPhase == Phase.Migrating\n', '                && crowdsaleManager != 0x0)\n', '            || (currentPhase == Phase.Paused && _nextPhase == Phase.Running)\n', '            || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated\n', '                && totalSupply == 0);\n', '\n', '        if(!canSwitchPhase) throw;\n', '        currentPhase = _nextPhase;\n', '        LogPhaseSwitch(_nextPhase);\n', '    }\n', '\n', '    function setCrowdsaleManager(address _mgr)\n', '        public\n', '        onlyTokenManager\n', '    {\n', '        if(currentPhase == Phase.Migrating) throw;\n', '        crowdsaleManager = _mgr;\n', '    }\n', '\n', '    function setStartDate(uint _date)\n', '        public\n', '        onlyTokenManager\n', '    {\n', '        if(currentPhase != Phase.Created) throw;\n', '        LogStartDate(_date, PRESALE_START_DATE);\n', '        PRESALE_START_DATE = _date;\n', '        PRESALE_END_DATE = PRESALE_START_DATE + 30 days;\n', '    }\n', '\n', '    function buyTokens(address _buyer)\n', '        public\n', '        payable\n', '    {\n', '        require(totalSupply < TOKEN_SUPPLY_LIMIT);\n', '        uint valueWei = msg.value;\n', '\n', '        require(currentPhase == Phase.Running);\n', '        require(valueWei >= MIN_TRANSACTION_AMOUNT_ETH);\n', '        require(now >= PRESALE_START_DATE);\n', '        require(now <= PRESALE_END_DATE);\n', '\n', '        uint timeSinceStart = now - PRESALE_START_DATE;\n', '        uint newTokens = priceRules.calculatePrice(valueWei, timeSinceStart, 18);\n', '\n', '        require(newTokens > 0);\n', '        require(totalSupply + newTokens <= TOKEN_SUPPLY_LIMIT);\n', '\n', '        totalSupply += newTokens;\n', '        balanceTable[_buyer] += newTokens;\n', '\n', '        LogBuy(_buyer, valueWei, newTokens);\n', '    }\n', '\n', '    function buyTokensForFiat(address _buyer, uint tokens)\n', '        public\n', '        onlyTokenManager\n', '    {\n', '      require(currentPhase == Phase.Running);\n', '      require(tokens > 0);\n', '\n', '      uint newTokens = tokens;\n', '      require (totalSupply + newTokens <= TOKEN_SUPPLY_LIMIT);\n', '      totalSupply += newTokens;\n', '      balanceTable[_buyer] += newTokens;\n', '\n', '      LogBuyForFiat(_buyer, newTokens);\n', '    }\n', '\n', '    function withdrawEther(uint bal)\n', '        public\n', '        onlyTokenManager\n', '        returns (uint)\n', '    {\n', '        LogEscrowReq(bal);\n', '        if(this.balance >= bal) {\n', '            escrow.transfer(bal);\n', '            LogEscrow(bal);\n', '            return 0;\n', '        }\n', '        return 1;\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '\n', 'contract MaptPricing {\n', '  // MAPT TOKEN PRICE:\n', '  uint256 constant MAPT_IN_ETH = 100; // 1 MAPT = 0.01 ETH\n', '\n', '  uint256 constant FRACTIONAL_DIVIDER = 100;\n', '  uint256 constant DEFAULT_MULTIPLIER = 1 * FRACTIONAL_DIVIDER;\n', '\n', '  uint constant MIN_ETH = 100 ether;\n', '\n', '  uint256[4] prices;\n', '  uint256[3] dates;\n', '  mapping (uint256 => uint256[]) rules;\n', '\n', '  function MaptPricing() {\n', '  }\n', '\n', '  function createPricing() {\n', '    prices[0] = 3000 ether;\n', '    prices[1] = 1500 ether;\n', '    prices[2] = 300 ether;\n', '    prices[3] = 100 ether;\n', '\n', '    dates[0] = 7 days;\n', '    dates[1] = 14 days;\n', '    dates[2] = 140 days;\n', '\n', '    rules[0] = [200, 150, 130, 120];\n', '    rules[1] = [200, 145, 125, 115];\n', '    rules[2] = [200, 145, 125, 115];\n', '  }\n', '\n', '  function calculatePrice(uint valueWei, uint256 timeSinceStart, uint decimals) public returns (uint tokenAmount) {\n', '    uint Z = 1231231;\n', '    uint m = 0;\n', '    uint ip = Z;\n', '    uint dp = Z;\n', '    uint tokens;\n', '\n', '    require(valueWei >= MIN_ETH);\n', '\n', '    if (valueWei >= prices[0]) ip = 0;\n', '    else for (uint i = 1; i < prices.length && ip == Z; i++) {\n', '      if (valueWei < prices[i-1] && valueWei >= prices[i]) ip = i;\n', '    }\n', '\n', '    if (ip == Z) {\n', '      m = DEFAULT_MULTIPLIER;\n', '    } else {\n', '      if (timeSinceStart <= dates[0]) {\n', '        dp = 0;\n', '      } else {\n', '        for (i = 1; i < dates.length && dp == Z; i++) {\n', '          if (timeSinceStart > dates[i-1] && timeSinceStart < dates[i]) {\n', '            dp = i;\n', '          }\n', '        }\n', '        //later on\n', '        if (timeSinceStart > dates[dates.length-1]) {\n', '          dp = dates.length-1;\n', '        }\n', '      }\n', '\n', '      if (dp == Z) {\n', '        m = DEFAULT_MULTIPLIER;\n', '      } else {\n', '        m = (rules[dp])[ip];\n', '      }\n', '    }\n', '\n', '    tokens = valueWei * MAPT_IN_ETH;\n', '\n', '    uint d = decimals;\n', '    d++;\n', '\n', '    uint res = tokens * m / DEFAULT_MULTIPLIER;\n', '\n', '    return res;\n', '  }\n', '}\n', '\n', 'contract MaptPresaleToken {\n', '\n', '    uint constant MIN_TRANSACTION_AMOUNT_ETH = 100 ether;\n', '\n', '    MaptPricing priceRules = new MaptPricing();\n', '    uint public PRESALE_START_DATE = 1503313200; //Mon Aug 21 12:00:00 +00 2017\n', '    uint public PRESALE_END_DATE = PRESALE_START_DATE + 30 days;\n', '\n', '    function MaptPresaleToken(address _tokenManager, address _escrow) {\n', '        tokenManager = _tokenManager;\n', '        escrow = _escrow;\n', '        priceRules.createPricing();\n', '    }\n', '\n', '    string public constant name = "MAT Presale Token";\n', '    string public constant symbol = "MAPT";\n', '    uint   public constant decimals = 18;\n', '\n', '    uint public constant TOKEN_SUPPLY_LIMIT = 2800000 * 1 ether / 1 wei;\n', '\n', '    enum Phase {\n', '        Created,\n', '        Running,\n', '        Paused,\n', '        Migrating,\n', '        Migrated\n', '    }\n', '\n', '    Phase public currentPhase = Phase.Created;\n', '\n', '    uint public totalSupply = 0;\n', '\n', '    address public tokenManager;\n', '\n', '    address public escrow;\n', '\n', '    address public crowdsaleManager;\n', '\n', '    mapping (address => uint256) private balanceTable;\n', '\n', '    modifier onlyTokenManager()     { if(msg.sender != tokenManager) throw; _; }\n', '    modifier onlyCrowdsaleManager() { if(msg.sender != crowdsaleManager) throw; _; }\n', '\n', '    event LogBuy(address indexed owner, uint etherWeiIncoming, uint tokensSold);\n', '    event LogBuyForFiat(address indexed owner, uint tokensSold);\n', '    event LogBurn(address indexed owner, uint value);\n', '    event LogPhaseSwitch(Phase newPhase);\n', '    event LogEscrow(uint balance);\n', '    event LogEscrowReq(uint balance);\n', '    event LogStartDate(uint newdate, uint oldDate);\n', '\n', '    function() payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    function burnTokens(address _owner)\n', '        public\n', '        onlyCrowdsaleManager\n', '        returns (uint)\n', '    {\n', '        if(currentPhase != Phase.Migrating) return 1;\n', '\n', '        uint tokens = balanceTable[_owner];\n', '        if(tokens == 0) return 2;\n', '        totalSupply -= tokens;\n', '        balanceTable[_owner] = 0;\n', '        LogBurn(_owner, tokens);\n', '\n', '        if(totalSupply == 0) {\n', '            currentPhase = Phase.Migrated;\n', '            LogPhaseSwitch(Phase.Migrated);\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256) {\n', '        return balanceTable[_owner];\n', '    }\n', '\n', '    function setPresalePhaseUInt(uint phase)\n', '        public\n', '        onlyTokenManager\n', '    {\n', '      require( uint(Phase.Migrated) >= phase && phase >= 0 );\n', '      setPresalePhase(Phase(phase));\n', '    }\n', '\n', '    function setPresalePhase(Phase _nextPhase)\n', '        public\n', '        onlyTokenManager\n', '    {\n', '      _setPresalePhase(_nextPhase);\n', '    }\n', '\n', '    function _setPresalePhase(Phase _nextPhase)\n', '        private\n', '    {\n', '        bool canSwitchPhase\n', '            =  (currentPhase == Phase.Created && _nextPhase == Phase.Running)\n', '            || (currentPhase == Phase.Running && _nextPhase == Phase.Paused)\n', '            || ((currentPhase == Phase.Running || currentPhase == Phase.Paused)\n', '                && _nextPhase == Phase.Migrating\n', '                && crowdsaleManager != 0x0)\n', '            || (currentPhase == Phase.Paused && _nextPhase == Phase.Running)\n', '            || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated\n', '                && totalSupply == 0);\n', '\n', '        if(!canSwitchPhase) throw;\n', '        currentPhase = _nextPhase;\n', '        LogPhaseSwitch(_nextPhase);\n', '    }\n', '\n', '    function setCrowdsaleManager(address _mgr)\n', '        public\n', '        onlyTokenManager\n', '    {\n', '        if(currentPhase == Phase.Migrating) throw;\n', '        crowdsaleManager = _mgr;\n', '    }\n', '\n', '    function setStartDate(uint _date)\n', '        public\n', '        onlyTokenManager\n', '    {\n', '        if(currentPhase != Phase.Created) throw;\n', '        LogStartDate(_date, PRESALE_START_DATE);\n', '        PRESALE_START_DATE = _date;\n', '        PRESALE_END_DATE = PRESALE_START_DATE + 30 days;\n', '    }\n', '\n', '    function buyTokens(address _buyer)\n', '        public\n', '        payable\n', '    {\n', '        require(totalSupply < TOKEN_SUPPLY_LIMIT);\n', '        uint valueWei = msg.value;\n', '\n', '        require(currentPhase == Phase.Running);\n', '        require(valueWei >= MIN_TRANSACTION_AMOUNT_ETH);\n', '        require(now >= PRESALE_START_DATE);\n', '        require(now <= PRESALE_END_DATE);\n', '\n', '        uint timeSinceStart = now - PRESALE_START_DATE;\n', '        uint newTokens = priceRules.calculatePrice(valueWei, timeSinceStart, 18);\n', '\n', '        require(newTokens > 0);\n', '        require(totalSupply + newTokens <= TOKEN_SUPPLY_LIMIT);\n', '\n', '        totalSupply += newTokens;\n', '        balanceTable[_buyer] += newTokens;\n', '\n', '        LogBuy(_buyer, valueWei, newTokens);\n', '    }\n', '\n', '    function buyTokensForFiat(address _buyer, uint tokens)\n', '        public\n', '        onlyTokenManager\n', '    {\n', '      require(currentPhase == Phase.Running);\n', '      require(tokens > 0);\n', '\n', '      uint newTokens = tokens;\n', '      require (totalSupply + newTokens <= TOKEN_SUPPLY_LIMIT);\n', '      totalSupply += newTokens;\n', '      balanceTable[_buyer] += newTokens;\n', '\n', '      LogBuyForFiat(_buyer, newTokens);\n', '    }\n', '\n', '    function withdrawEther(uint bal)\n', '        public\n', '        onlyTokenManager\n', '        returns (uint)\n', '    {\n', '        LogEscrowReq(bal);\n', '        if(this.balance >= bal) {\n', '            escrow.transfer(bal);\n', '            LogEscrow(bal);\n', '            return 0;\n', '        }\n', '        return 1;\n', '    }\n', '}']
