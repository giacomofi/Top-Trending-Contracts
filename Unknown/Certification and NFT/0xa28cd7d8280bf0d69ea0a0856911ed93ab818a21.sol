['pragma solidity ^0.4.1;\n', '\n', 'contract Destination {\n', '    function recover(address _from, address _to) returns(bool);\n', '}\n', '\n', 'contract RecoveryWithTenant {\n', '    event Recovery(uint indexed nonce, address indexed from, address indexed to);\n', '    event Setup(uint indexed nonce, address indexed user);\n', '    \n', '    //1: user not existing\n', '    //2: conflict, user exists already\n', '    //3: signature not by tenant\n', '    //4: nonce/signature used before\n', '    //5: contract call failed\n', '    //6: oracle access denied\n', '    //8: requested user not found\n', '    event Error(uint indexed nonce, uint code);\n', '    \n', '    struct User {\n', '        address addr;\n', '    }\n', '    \n', '    mapping (address => uint) userIndex;\n', '    User[] public users;\n', '\n', '    address public oracle;\n', '    address public tenant;\n', '    mapping(uint => bool) nonceUsed;\n', '    address public callDestination;\n', '\n', '\n', '    modifier onlyOracle() {\n', '        if (msg.sender == oracle) {\n', '            _;\n', '        }\n', '        Error(0, 6);\n', '    }\n', '    \n', '    modifier noEther() {\n', '        if (msg.value > 0) throw;\n', '        _;\n', '    }\n', '\n', '    function RecoveryWithTenant() {\n', '        oracle = msg.sender;\n', '        tenant = msg.sender;\n', '        users.length++;\n', '    }\n', '    \n', '    //############# INTERNAL FUNCTIONS\n', '    \n', '    function _checkSigned(bytes32 _hash, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool) {\n', '        address recovered = ecrecover(_hash, _v, _r, _s);\n', '\n', '        if (tenant != recovered) {\n', '            Error(_nonce, 3);\n', '            return false;\n', '        }\n', '        if (nonceUsed[_nonce]) {\n', '            Error(_nonce, 4);\n', '            return false;\n', '        }\n', '        nonceUsed[_nonce] = true; \n', '        return true;\n', '    }\n', '    \n', '    \n', '    //############# PUBLIC FUNCTIONS\n', '    \n', '    function setOracle(address _newOracle) noEther onlyOracle {\n', '        oracle = _newOracle;\n', '    }\n', '    \n', '    function configure(address _tenant, address _callDestination, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {\n', '        if(tenant != oracle && !_checkSigned(sha3(_tenant, _callDestination, _nonce), _nonce, _v, _r, _s))\n', '            return false;\n', '        tenant = _tenant;\n', '        callDestination = _callDestination;\n', '        return true;\n', '    }\n', '    \n', '    \n', '    function addUser(address _userAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {\n', '        if(userIndex[_userAddr] > 0) {\n', '            Error(_nonce, 2);\n', '            return false;\n', '        }\n', '        if(!_checkSigned(sha3(_userAddr, _nonce), _nonce, _v, _r, _s))\n', '            return false;\n', '        uint posUser = users.length++;\n', '        userIndex[_userAddr] = posUser;\n', '        users[posUser] = User(_userAddr);\n', '        Setup(_nonce, _userAddr);\n', '        return true;\n', '    }\n', '    \n', '    function recoverUser(address _oldAddr, address _newAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {\n', '        uint userPos = userIndex[_oldAddr];\n', '        if (userPos == 0) {\n', "            Error(_nonce, 1); //user doesn't exsit\n", '            return false;\n', '        }\n', '        \n', '        if (!_checkSigned(sha3(_oldAddr, _newAddr, _nonce), _nonce, _v, _r, _s))\n', '            return false;\n', '        bool result = Destination(callDestination).recover(_oldAddr, _newAddr);\n', '        if (result) {\n', '            users[userPos].addr = _newAddr;\n', '            delete userIndex[_oldAddr];\n', '            userIndex[_newAddr] = userPos;\n', '            Recovery(_nonce, _oldAddr, _newAddr);\n', '            return true;\n', '        }\n', '        Error(_nonce, 5);\n', '        return false;\n', '    }\n', '\n', '    function () noEther {\n', '        throw;\n', '    }\n', '    \n', '    //############# STATIC FUNCTIONS\n', '    \n', '    function isUser(address _userAddr) constant returns (bool) {\n', '        return (userIndex[_userAddr] > 0);\n', '    }\n', '\n', '}']