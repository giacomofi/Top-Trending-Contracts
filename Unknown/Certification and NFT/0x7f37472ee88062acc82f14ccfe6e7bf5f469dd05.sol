['pragma solidity ^0.4.8;\n', '\n', '\n', '//\n', '// FOR REFERENCE - INCLUDE  iE4RowEscrow  (interface) CONTRACT at the top .....\n', '//\n', '\n', 'contract iE4RowEscrow {\n', '        function getNumGamesStarted() constant returns (int ngames);\n', '}\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', '// ---------------------------------\n', '// ABSTRACT standard token class\n', '// ---------------------------------\n', 'contract Token { \n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '// --------------------------\n', '//  E4RowRewards - abstract e4 dividend contract\n', '// --------------------------\n', 'contract E4RowRewards\n', '{\n', '        function checkDividends(address _addr) constant returns(uint _amount);\n', '        function withdrawDividends() public returns (uint namount);\n', '}\n', '\n', '// --------------------------\n', '//  Finney Chip - token contract\n', '// --------------------------\n', 'contract E4Token is Token, E4RowRewards {\n', '        event StatEvent(string msg);\n', '        event StatEventI(string msg, uint val);\n', '\n', '        enum SettingStateValue  {debug, release, lockedRelease}\n', '        enum IcoStatusValue {anouncement, saleOpen, saleClosed, failed, succeeded}\n', '\n', '\n', '\n', '\n', '        struct tokenAccount {\n', '                bool alloced; // flag to ascert prior allocation\n', '                uint tokens; // num tokens\n', '                uint balance; // rewards balance\n', '        }\n', '// -----------------------------\n', '//  data storage\n', '// ----------------------------------------\n', '        address developers; // developers token holding address\n', '        address public owner; // deployer executor\n', '        address founderOrg; // founder orginaization contract\n', '        address auxPartner; // aux partner (pr/auditing) - 1 percent upon close\n', '        address e4_partner; // e4row  contract addresses\n', '\n', '\n', '        mapping (address => tokenAccount) holderAccounts ; // who holds how many tokens (high two bytes contain curPayId)\n', '        mapping (uint => address) holderIndexes ; // for iteration thru holder\n', '        uint numAccounts;\n', '\n', '        uint partnerCredits; // amount partner (e4row)  has paid\n', '        mapping (address => mapping (address => uint256)) allowed; // approvals\n', '\n', '\n', '        uint maxMintableTokens; // ...\n', '        uint minIcoTokenGoal;// token goal by sale end\n', '        uint minUsageGoal; //  num games goal by usage deadline\n', '        uint public  tokenPrice; // price per token\n', '        uint public payoutThreshold; // threshold till payout\n', '\n', '        uint totalTokenFundsReceived;   // running total of token funds received\n', '        uint public totalTokensMinted;  // total number of tokens minted\n', '        uint public holdoverBalance;            // hold this amount until threshhold before reward payout\n', '        int public payoutBalance;               // hold this amount until threshhold before reward payout\n', '        int prOrigPayoutBal;                    // original payout balance before run\n', '        uint prOrigTokensMint;                  // tokens minted at start of pay run\n', '        uint public curPayoutId;                // current payout id\n', '        uint public lastPayoutIndex;            // payout idx between run segments\n', '        uint public maxPaysPer;                 // num pays per segment\n', '        uint public minPayInterval;             // min interval between start pay run\n', '\n', '\n', '        uint fundingStart;              // funding start time immediately after anouncement\n', '        uint fundingDeadline;           // funding end time\n', '        uint usageDeadline;             // deadline where minimum usage needs to be met before considered success\n', '        uint public lastPayoutTime;     // timestamp of last payout time\n', '        uint vestTime;          // 1 year past sale vest developer tokens\n', '        uint numDevTokens;      // 10 per cent of tokens after close to developers\n', '        bool developersGranted;                 // flag\n', '        uint remunerationStage;         // 0 for not yet, 1 for 10 percent, 2 for remaining  upon succeeded.\n', '        uint public remunerationBalance;        // remuneration balance to release token funds\n', '        uint auxPartnerBalance;         // aux partner balance - 1 percent\n', '        uint rmGas; // remuneration gas\n', '        uint rwGas; // reward gas\n', '        uint rfGas; // refund gas\n', '\n', '        IcoStatusValue icoStatus;  // current status of ico\n', '        SettingStateValue public settingsState;\n', '\n', '\n', '        // --------------------\n', '        // contract constructor\n', '        // --------------------\n', '        function E4Token() \n', '        {\n', '                owner = msg.sender;\n', '                developers = msg.sender;\n', '        }\n', '\n', '        // -----------------------------------\n', '        // use this to reset everything, will never be called after lockRelease\n', '        // -----------------------------------\n', '        function applySettings(SettingStateValue qState, uint _saleStart, uint _saleEnd, uint _usageEnd, uint _minUsage, uint _tokGoal, uint  _maxMintable, uint _threshold, uint _price, uint _mpp, uint _mpi )\n', '        {\n', '                if (msg.sender != owner) \n', '                        return;\n', '\n', '                // these settings are permanently tweakable for performance adjustments\n', '                payoutThreshold = _threshold;\n', '                maxPaysPer = _mpp;\n', '                minPayInterval = _mpi;\n', '\n', '                if (settingsState == SettingStateValue.lockedRelease)\n', '                        return;\n', '\n', '                settingsState = qState;\n', '                icoStatus = IcoStatusValue.anouncement;\n', '\n', '                rmGas = 100000; // remuneration gas\n', '                rwGas = 10000; // reward gas\n', '                rfGas = 10000; // refund gas\n', '\n', '\n', '                // zero out all token holders.  \n', '                // leave alloced on, leave num accounts\n', '                // cant delete them anyways\n', '\n', '                if (totalTokensMinted > 0) {\n', '                        for (uint i = 0; i < numAccounts; i++ ) {\n', '                                address a = holderIndexes[i];\n', '                                if (a != address(0)) {\n', '                                        holderAccounts[a].tokens = 0;\n', '                                        holderAccounts[a].balance = 0;\n', '                                }\n', '                        }\n', '                }\n', '                // do not reset numAccounts!\n', '\n', '                totalTokensMinted = 0; // this will erase\n', '                totalTokenFundsReceived = 0; // this will erase.\n', '                e4_partner = address(0); // must be reset again\n', '\n', '                fundingStart =  _saleStart;\n', '                fundingDeadline = _saleEnd;\n', '                usageDeadline = _usageEnd;\n', '                minUsageGoal = _minUsage;\n', '                minIcoTokenGoal = _tokGoal;\n', '                maxMintableTokens = _maxMintable;\n', '                tokenPrice = _price;\n', '\n', '                vestTime = fundingStart + (365 days);\n', '                numDevTokens = 0;\n', '\n', '                holdoverBalance = 0;\n', '                payoutBalance = 0;\n', '                curPayoutId = 1;\n', '                lastPayoutIndex = 0;\n', '                remunerationStage = 0;\n', '                remunerationBalance = 0;\n', '\n', '                auxPartnerBalance = 0;\n', '\n', '                if (this.balance > 0) {\n', '                        if (!owner.call.gas(rfGas).value(this.balance)())\n', '                                StatEvent("ERROR!");\n', '                }\n', '                StatEvent("ok");\n', '\n', '        }\n', '\n', '\n', '        // ---------------------------------------------------\n', '        // tokens held reserve the top two bytes for the payid last paid.\n', '        // this is so holders at the top of the list dont transfer tokens \n', '        // to themselves on the bottom of the list thus scamming the \n', '        // system. this function deconstructs the tokenheld value.\n', '        // ---------------------------------------------------\n', '        function getPayIdAndHeld(uint _tokHeld) internal returns (uint _payId, uint _held)\n', '        {\n', '                _payId = (_tokHeld / (2 ** 48)) & 0xffff;\n', '                _held = _tokHeld & 0xffffffffffff;\n', '        }\n', '        function getHeld(uint _tokHeld) internal  returns (uint _held)\n', '        {\n', '                _held = _tokHeld & 0xffffffffffff;\n', '        }\n', '        // ---------------------------------------------------\n', '        // allocate a new account by setting alloc to true\n', '        // set the top to bytes of tokens to cur pay id to leave out of current round\n', '        // add holder index, bump the num accounts\n', '        // ---------------------------------------------------\n', '        function addAccount(address _addr) internal  {\n', '                holderAccounts[_addr].alloced = true;\n', '                holderAccounts[_addr].tokens = (curPayoutId * (2 ** 48));\n', '                holderIndexes[numAccounts++] = _addr;\n', '        }\n', '\n', '\n', '// --------------------------------------\n', '// BEGIN ERC-20 from StandardToken\n', '// --------------------------------------\n', '        function totalSupply() constant returns (uint256 supply)\n', '        {\n', '                if (icoStatus == IcoStatusValue.saleOpen\n', '                        || icoStatus == IcoStatusValue.anouncement)\n', '                        supply = maxMintableTokens;\n', '                else\n', '                        supply = totalTokensMinted;\n', '        }\n', '\n', '        function transfer(address _to, uint256 _value) returns (bool success) {\n', '\n', '                if ((msg.sender == developers) \n', '                        &&  (now < vestTime)) {\n', '                        //statEvent("Tokens not yet vested.");\n', '                        return false;\n', '                }\n', '\n', '\n', "                //Default assumes totalSupply can't be over max (2^256 - 1).\n", "                //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '                //Replace the if with this one instead.\n', '                //if (holderAccounts[msg.sender] >= _value && balances[_to] + _value > holderAccounts[_to]) {\n', '\n', '                var (pidFrom, heldFrom) = getPayIdAndHeld(holderAccounts[msg.sender].tokens);\n', '                if (heldFrom >= _value && _value > 0) {\n', '\n', '                    holderAccounts[msg.sender].tokens -= _value;\n', '\n', '                    if (!holderAccounts[_to].alloced) {\n', '                        addAccount(_to);\n', '                    }\n', '\n', '                    uint newHeld = _value + getHeld(holderAccounts[_to].tokens);\n', '                    holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48));\n', '                    Transfer(msg.sender, _to, _value);\n', '                    return true;\n', '                } else { \n', '                        return false; \n', '                }\n', '        }\n', '\n', '        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '\n', '                if ((_from == developers) \n', '                        &&  (now < vestTime)) {\n', '                        //statEvent("Tokens not yet vested.");\n', '                        return false;\n', '                }\n', '\n', '\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '\n', '                var (pidFrom, heldFrom) = getPayIdAndHeld(holderAccounts[_from].tokens);\n', '                if (heldFrom >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '                    holderAccounts[_from].tokens -= _value;\n', '\n', '                    if (!holderAccounts[_to].alloced)\n', '                        addAccount(_to);\n', '\n', '                    uint newHeld = _value + getHeld(holderAccounts[_to].tokens);\n', '\n', '                    holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48));\n', '                    allowed[_from][msg.sender] -= _value;\n', '                    Transfer(_from, _to, _value);\n', '                    return true;\n', '                } else { \n', '                    return false; \n', '                }\n', '        }\n', '\n', '\n', '        function balanceOf(address _owner) constant returns (uint256 balance) {\n', '                // vars default to 0\n', '                if (holderAccounts[_owner].alloced) {\n', '                        balance = getHeld(holderAccounts[_owner].tokens);\n', '                } \n', '        }\n', '\n', '        function approve(address _spender, uint256 _value) returns (bool success) {\n', '                allowed[msg.sender][_spender] = _value;\n', '                Approval(msg.sender, _spender, _value);\n', '                return true;\n', '        }\n', '\n', '        function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '                return allowed[_owner][_spender];\n', '        }\n', '// ----------------------------------\n', '// END ERC20\n', '// ----------------------------------\n', '\n', '  \n', '        // -------------------------------------------\n', '        // check the alloced\n', '        // -------------------------------------------\n', '        function holderExists(address _addr) returns(bool _exist)\n', '        {\n', '                _exist = holderAccounts[_addr].alloced;\n', '        }\n', '\n', '\n', '\n', '        // -------------------------------------------\n', '        // default payable function.\n', '        // if sender is e4row  partner, this is a rake fee payment\n', '        // otherwise this is a token purchase.\n', '        // tokens only purchaseable between tokenfundingstart and end\n', '        // -------------------------------------------\n', '        function () payable {\n', '                if (msg.sender == e4_partner) {\n', '                     feePayment(); // from e4row game escrow contract\n', '                } else {\n', '                     purchaseToken();\n', '                }\n', '        }\n', '\n', '        // -----------------------------\n', '        // purchase token function - tokens only sold during sale period up until the max tokens\n', '        // purchase price is tokenPrice.  all units in wei.\n', '        // purchaser will not be included in current pay run\n', '        // -----------------------------\n', '        function purchaseToken() payable {\n', '\n', '                uint nvalue = msg.value; // being careful to preserve msg.value\n', '                address npurchaser = msg.sender;\n', '                if (nvalue < tokenPrice) \n', '                        throw;\n', '\n', '                uint qty = nvalue/tokenPrice;\n', '                updateIcoStatus();\n', '                if (icoStatus != IcoStatusValue.saleOpen) // purchase is closed\n', '                        throw;\n', '                if (totalTokensMinted + qty > maxMintableTokens)\n', '                        throw;\n', '                if (!holderAccounts[npurchaser].alloced)\n', '                        addAccount(npurchaser);\n', '\n', '                // purchaser waits for next payrun. otherwise can disrupt cur pay run\n', '                uint newHeld = qty + getHeld(holderAccounts[npurchaser].tokens);\n', '                holderAccounts[npurchaser].tokens = newHeld | (curPayoutId * (2 ** 48));\n', '\n', '                totalTokensMinted += qty;\n', '                totalTokenFundsReceived += nvalue;\n', '\n', '                if (totalTokensMinted == maxMintableTokens) {\n', '                        icoStatus = IcoStatusValue.saleClosed;\n', '                        //test unnecessary -  if (getNumTokensPurchased() >= minIcoTokenGoal)\n', '                        doDeveloperGrant();\n', '                        StatEventI("Purchased,Granted", qty);\n', '                } else\n', '                        StatEventI("Purchased", qty);\n', '\n', '        }\n', '\n', '\n', '        // ---------------------------\n', '        // accept payment from e4row contract\n', '        // ---------------------------\n', '        function feePayment() payable  \n', '        {\n', '                if (msg.sender != e4_partner) {\n', '                        StatEvent("forbidden");\n', '                        return; // thank you\n', '                }\n', '                uint nfvalue = msg.value; // preserve value in case changed in dev grant\n', '\n', '                updateIcoStatus();\n', '\n', '                holdoverBalance += nfvalue;\n', '                partnerCredits += nfvalue;\n', '                StatEventI("Payment", nfvalue);\n', '\n', '                if (holdoverBalance > payoutThreshold\n', '                        || payoutBalance > 0)\n', '                        doPayout();\n', '\n', '\n', '        }\n', '\n', '        // ---------------------------\n', '        // set the e4row partner, this is only done once\n', '        // ---------------------------\n', '        function setE4RowPartner(address _addr) public\n', '        {\n', '        // ONLY owner can set and ONLY ONCE! (unless "unlocked" debug)\n', '        // once its locked. ONLY ONCE!\n', '                if (msg.sender == owner) {\n', '                        if ((e4_partner == address(0)) || (settingsState == SettingStateValue.debug)) {\n', '                                e4_partner = _addr;\n', '                                partnerCredits = 0;\n', '                                //StatEventI("E4-Set", 0);\n', '                        } else {\n', '                                StatEvent("Already Set");\n', '                        }\n', '                }\n', '        }\n', '\n', '        // ----------------------------\n', '        // return the total tokens purchased\n', '        // ----------------------------\n', '        function getNumTokensPurchased() constant returns(uint _purchased)\n', '        {\n', '                _purchased = totalTokensMinted-numDevTokens;\n', '        }\n', '\n', '        // ----------------------------\n', '        // return the num games as reported from the e4row  contract\n', '        // ----------------------------\n', '        function getNumGames() constant returns(uint _games)\n', '        {\n', '                //_games = 0;\n', '                if (e4_partner != address(0)) {\n', '                        iE4RowEscrow pe4 = iE4RowEscrow(e4_partner);\n', '                        _games = uint(pe4.getNumGamesStarted());\n', '                } \n', '                //else\n', '                //StatEvent("Empty E4");\n', '        }\n', '\n', '        // ------------------------------------------------\n', '        // get the founders, auxPartner, developer\n', '        // --------------------------------------------------\n', '        function getSpecialAddresses() constant returns (address _fndr, address _aux, address _dev, address _e4)\n', '        {\n', '                //if (_sender == owner) { // no msg.sender on constant functions at least in mew\n', '                        _fndr = founderOrg;\n', '                        _aux = auxPartner;\n', '                        _dev = developers;\n', '                        _e4  = e4_partner;\n', '                //}\n', '        }\n', '\n', '\n', '\n', '        // ----------------------------\n', '        // update the ico status\n', '        // ----------------------------\n', '        function updateIcoStatus() public\n', '        {\n', '                if (icoStatus == IcoStatusValue.succeeded \n', '                        || icoStatus == IcoStatusValue.failed)\n', '                        return;\n', '                else if (icoStatus == IcoStatusValue.anouncement) {\n', '                        if (now > fundingStart && now <= fundingDeadline) {\n', '                                icoStatus = IcoStatusValue.saleOpen;\n', '\n', '                        } else if (now > fundingDeadline) {\n', '                                // should not be here - this will eventually fail\n', '                                icoStatus = IcoStatusValue.saleClosed;\n', '                        }\n', '                } else {\n', '                        uint numP = getNumTokensPurchased();\n', '                        uint numG = getNumGames();\n', '                        if ((now > fundingDeadline && numP < minIcoTokenGoal)\n', '                                || (now > usageDeadline && numG < minUsageGoal)) {\n', '                                icoStatus = IcoStatusValue.failed;\n', '                        } else if ((now > fundingDeadline) // dont want to prevent more token sales\n', '                                && (numP >= minIcoTokenGoal)\n', '                                && (numG >= minUsageGoal)) {\n', '                                icoStatus = IcoStatusValue.succeeded; // hooray\n', '                        }\n', '                        if (icoStatus == IcoStatusValue.saleOpen\n', '                                && ((numP >= maxMintableTokens)\n', '                                || (now > fundingDeadline))) {\n', '                                        icoStatus = IcoStatusValue.saleClosed;\n', '                                }\n', '                }\n', '\n', '                if (!developersGranted\n', '                        && icoStatus != IcoStatusValue.saleOpen \n', '                        && icoStatus != IcoStatusValue.anouncement\n', '                        && getNumTokensPurchased() >= minIcoTokenGoal) {\n', '                                doDeveloperGrant(); // grant whenever status goes from open to anything...\n', '                }\n', '\n', '\n', '        }\n', '\n', '\n', '        // ----------------------------\n', '        // request refund. Caller must call to request and receive refund \n', '        // WARNING - withdraw rewards/dividends before calling.\n', '        // YOU HAVE BEEN WARNED\n', '        // ----------------------------\n', '        function requestRefund()\n', '        {\n', '                address nrequester = msg.sender;\n', '                updateIcoStatus();\n', '\n', '                uint ntokens = getHeld(holderAccounts[nrequester].tokens);\n', '                if (icoStatus != IcoStatusValue.failed)\n', '                        StatEvent("No Refund");\n', '                else if (ntokens == 0)\n', '                        StatEvent("No Tokens");\n', '                else {\n', '                        uint nrefund = ntokens * tokenPrice;\n', '                        if (getNumTokensPurchased() >= minIcoTokenGoal)\n', '                                nrefund -= (nrefund /10); // only 90 percent b/c 10 percent payout\n', '\n', '                        holderAccounts[developers].tokens += ntokens;\n', '                        holderAccounts[nrequester].tokens = 0;\n', '                        if (holderAccounts[nrequester].balance > 0) {\n', '                                // see above warning!!\n', '                                if (!holderAccounts[developers].alloced) \n', '                                        addAccount(developers);\n', '                                holderAccounts[developers].balance += holderAccounts[nrequester].balance;\n', '                                holderAccounts[nrequester].balance = 0;\n', '                        }\n', '\n', '                        if (!nrequester.call.gas(rfGas).value(nrefund)())\n', '                                throw;\n', '                        //StatEventI("Refunded", nrefund);\n', '                }\n', '        }\n', '\n', '\n', '\n', '        // ---------------------------------------------------\n', '        // payout rewards to all token holders\n', '        // use a second holding variable called PayoutBalance to do \n', '        // the actual payout from b/c too much gas to iterate thru \n', '        // each payee. Only start a new run at most once per "minpayinterval".\n', '        // Its done in runs of "maxPaysPer"\n', '        // we use special coding for the holderAccounts to avoid a hack\n', '        // of getting paid at the top of the list then transfering tokens\n', '        // to another address at the bottom of the list.\n', '        // because of that each holderAccounts entry gets the payoutid stamped upon it (top two bytes)\n', '        // also a token transfer will transfer the payout id.\n', '        // ---------------------------------------------------\n', '        function doPayout()  internal\n', '        {\n', '                if (totalTokensMinted == 0)\n', '                        return;\n', '\n', '                if ((holdoverBalance > 0) \n', '                        && (payoutBalance == 0)\n', '                        && (now > (lastPayoutTime+minPayInterval))) {\n', '                        // start a new run\n', '                        curPayoutId++;\n', '                        if (curPayoutId >= 32768)\n', '                                curPayoutId = 1;\n', '                        lastPayoutTime = now;\n', '                        payoutBalance = int(holdoverBalance);\n', '                        prOrigPayoutBal = payoutBalance;\n', '                        prOrigTokensMint = totalTokensMinted;\n', '                        holdoverBalance = 0;\n', '                        lastPayoutIndex = 0;\n', '                        StatEventI("StartRun", uint(curPayoutId));\n', '                } else if (payoutBalance > 0) {\n', '                        // work down the p.o.b\n', '                        uint nAmount;\n', '                        uint nPerTokDistrib = uint(prOrigPayoutBal)/prOrigTokensMint;\n', '                        uint paids = 0;\n', '                        uint i; // intentional\n', '                        for (i = lastPayoutIndex; (paids < maxPaysPer) && (i < numAccounts) && (payoutBalance > 0); i++ ) {\n', '                                address a = holderIndexes[i];\n', '                                if (a == address(0)) {\n', '                                        continue;\n', '                                }\n', '                                var (pid, held) = getPayIdAndHeld(holderAccounts[a].tokens);\n', '                                if ((held > 0) && (pid != curPayoutId)) {\n', '                                        nAmount = nPerTokDistrib * held;\n', '                                        if (int(nAmount) <= payoutBalance){\n', '                                                holderAccounts[a].balance += nAmount; \n', '                                                holderAccounts[a].tokens = (curPayoutId * (2 ** 48)) | held;\n', '                                                payoutBalance -= int(nAmount);\n', '                                                paids++;\n', '                                        }\n', '                                }\n', '                        }\n', '                        lastPayoutIndex = i;\n', '                        if (lastPayoutIndex >= numAccounts || payoutBalance <= 0) {\n', '                                lastPayoutIndex = 0;\n', '                                if (payoutBalance > 0)\n', '                                        holdoverBalance += uint(payoutBalance);// put back any leftovers\n', '                                payoutBalance = 0;\n', '                                StatEventI("RunComplete", uint(prOrigPayoutBal) );\n', '\n', '                        } else {\n', '                                StatEventI("PayRun", nPerTokDistrib );\n', '                        }\n', '                }\n', '\n', '        }\n', '\n', '\n', '        // ----------------------------\n', '        // sender withdraw entire rewards/dividends\n', '        // ----------------------------\n', '        function withdrawDividends() public returns (uint _amount)\n', '        {\n', '                if (holderAccounts[msg.sender].balance == 0) { \n', '                        //_amount = 0;\n', '                        StatEvent("0 Balance");\n', '                        return;\n', '                } else {\n', '                        if ((msg.sender == developers) \n', '                                &&  (now < vestTime)) {\n', '                                //statEvent("Tokens not yet vested.");\n', '                                //_amount = 0;\n', '                                return;\n', '                        }\n', '\n', '                        _amount = holderAccounts[msg.sender].balance; \n', '                        holderAccounts[msg.sender].balance = 0; \n', '                        if (!msg.sender.call.gas(rwGas).value(_amount)())\n', '                                throw;\n', '                        //StatEventI("Paid", _amount);\n', '\n', '                }\n', '\n', '        }\n', '\n', '        // ----------------------------\n', '        // set gas for operations\n', '        // ----------------------------\n', '        function setOpGas(uint _rm, uint _rf, uint _rw)\n', '        {\n', '                if (msg.sender != owner && msg.sender != developers) {\n', '                        //StatEvent("only owner calls");\n', '                        return;\n', '                } else {\n', '                        rmGas = _rm;\n', '                        rfGas = _rf;\n', '                        rwGas = _rw;\n', '                }\n', '        }\n', '\n', '        // ----------------------------\n', '        // get gas for operations\n', '        // ----------------------------\n', '        function getOpGas() constant returns (uint _rm, uint _rf, uint _rw)\n', '        {\n', '                _rm = rmGas;\n', '                _rf = rfGas;\n', '                _rw = rwGas;\n', '        }\n', ' \n', '\n', '        // ----------------------------\n', '        // check rewards.  pass in address of token holder\n', '        // ----------------------------\n', '        function checkDividends(address _addr) constant returns(uint _amount)\n', '        {\n', '                if (holderAccounts[_addr].alloced)\n', '                        _amount = holderAccounts[_addr].balance;\n', '        }\n', '\n', '\n', '        // ------------------------------------------------\n', '        // icoCheckup - check up call for administrators\n', '        // after sale is closed if min ico tokens sold, 10 percent will be distributed to \n', '        // company to cover various operating expenses\n', '        // after sale and usage dealines have been met, remaining 90 percent will be distributed to\n', '        // company.\n', '        // ------------------------------------------------\n', '        function icoCheckup() public\n', '        {\n', '                if (msg.sender != owner && msg.sender != developers)\n', '                        throw;\n', '\n', '                uint nmsgmask;\n', '                //nmsgmask = 0;\n', '\n', '                if (icoStatus == IcoStatusValue.saleClosed) {\n', '                        if ((getNumTokensPurchased() >= minIcoTokenGoal)\n', '                                && (remunerationStage == 0 )) {\n', '                                remunerationStage = 1;\n', '                                remunerationBalance = (totalTokenFundsReceived/100)*9; // 9 percent\n', '                                auxPartnerBalance =  (totalTokenFundsReceived/100); // 1 percent\n', '                                nmsgmask |= 1;\n', '                        } \n', '                }\n', '                if (icoStatus == IcoStatusValue.succeeded) {\n', '\n', '                        if (remunerationStage == 0 ) {\n', '                                remunerationStage = 1;\n', '                                remunerationBalance = (totalTokenFundsReceived/100)*9; \n', '                                auxPartnerBalance =  (totalTokenFundsReceived/100);\n', '                                nmsgmask |= 4;\n', '                        }\n', '                        if (remunerationStage == 1) { // we have already suceeded\n', '                                remunerationStage = 2;\n', '                                remunerationBalance += totalTokenFundsReceived - (totalTokenFundsReceived/10); // 90 percent\n', '                                nmsgmask |= 8;\n', '                        }\n', '\n', '                }\n', '\n', '                uint ntmp;\n', '\n', '                if (remunerationBalance > 0) { \n', '                // only pay one entity per call, dont want to run out of gas\n', '                                ntmp = remunerationBalance;\n', '                                remunerationBalance = 0;\n', '                                if (!founderOrg.call.gas(rmGas).value(ntmp)()) {\n', '                                        remunerationBalance = ntmp;\n', '                                        nmsgmask |= 32;\n', '                                } else {\n', '                                        nmsgmask |= 64;\n', '                                }\n', '                } else  if (auxPartnerBalance > 0) {\n', '                // note the "else" only pay one entity per call, dont want to run out of gas\n', '                        ntmp = auxPartnerBalance;\n', '                        auxPartnerBalance = 0;\n', '                        if (!auxPartner.call.gas(rmGas).value(ntmp)()) {\n', '                                auxPartnerBalance = ntmp;\n', '                                nmsgmask |= 128;\n', '                        }  else {\n', '                                nmsgmask |= 256;\n', '                        }\n', '\n', '                } \n', '\n', '                StatEventI("ico-checkup", nmsgmask);\n', '        }\n', '\n', '\n', '        // ----------------------------\n', '        // swap executor\n', '        // ----------------------------\n', '        function changeOwner(address _addr) \n', '        {\n', '                if (msg.sender != owner\n', '                        || settingsState == SettingStateValue.lockedRelease)\n', '                         throw;\n', '\n', '                owner = _addr;\n', '        }\n', '\n', '        // ----------------------------\n', '        // swap developers account\n', '        // ----------------------------\n', '        function changeDevevoperAccont(address _addr) \n', '        {\n', '                if (msg.sender != owner\n', '                        || settingsState == SettingStateValue.lockedRelease)\n', '                         throw;\n', '                developers = _addr;\n', '        }\n', '\n', '        // ----------------------------\n', '        // change founder\n', '        // ----------------------------\n', '        function changeFounder(address _addr) \n', '        {\n', '                if (msg.sender != owner\n', '                        || settingsState == SettingStateValue.lockedRelease)\n', '                         throw;\n', '                founderOrg = _addr;\n', '        }\n', '\n', '        // ----------------------------\n', '        // change auxPartner\n', '        // ----------------------------\n', '        function changeAuxPartner(address _aux) \n', '        {\n', '                if (msg.sender != owner\n', '                        || settingsState == SettingStateValue.lockedRelease)\n', '                         throw;\n', '                auxPartner = _aux;\n', '        }\n', '\n', '\n', '        // ----------------------------\n', '        // DEBUG ONLY - end this contract, suicide to developers\n', '        // ----------------------------\n', '        function haraKiri()\n', '        {\n', '                if (settingsState != SettingStateValue.debug)\n', '                        throw;\n', '                if (msg.sender != owner)\n', '                         throw;\n', '                suicide(developers);\n', '        }\n', '\n', '        // ----------------------------\n', '        // get all ico status, funding and usage info\n', '        // ----------------------------\n', '        function getIcoInfo() constant returns(IcoStatusValue _status, uint _saleStart, uint _saleEnd, uint _usageEnd, uint _saleGoal, uint _usageGoal, uint _sold, uint _used, uint _funds, uint _credits, uint _remuStage, uint _vest)\n', '        {\n', '                _status = icoStatus;\n', '                _saleStart = fundingStart;\n', '                _saleEnd = fundingDeadline;\n', '                _usageEnd = usageDeadline;\n', '                _vest = vestTime;\n', '                _saleGoal = minIcoTokenGoal;\n', '                _usageGoal = minUsageGoal;\n', '                _sold = getNumTokensPurchased();\n', '                _used = getNumGames();\n', '                _funds = totalTokenFundsReceived;\n', '                _credits = partnerCredits;\n', '                _remuStage = remunerationStage;\n', '        }\n', '\n', '        function flushDividends()\n', '        {\n', '                if ((msg.sender != owner) && (msg.sender != developers))\n', '                        return;\n', '                if (holdoverBalance > 0 || payoutBalance > 0)\n', '                        doPayout();\n', '        }\n', '\n', '        function doDeveloperGrant() internal\n', '        {\n', '                if (!developersGranted) {\n', '                        developersGranted = true;\n', '                        numDevTokens = totalTokensMinted/10;\n', '                        totalTokensMinted += numDevTokens;\n', '                        if (!holderAccounts[developers].alloced) \n', '                                addAccount(developers);\n', '                        uint newHeld = getHeld(holderAccounts[developers].tokens) + numDevTokens;\n', '                        holderAccounts[developers].tokens = newHeld |  (curPayoutId * (2 ** 48));\n', '\n', '                }\n', '        }\n', '\n', '\n', '}']