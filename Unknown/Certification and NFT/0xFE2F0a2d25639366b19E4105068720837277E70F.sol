['pragma solidity ^0.4.2;\n', 'contract token { \n', '    function transfer(address, uint256){  }\n', '    function balanceOf(address) constant returns (uint256) { }\n', '}\n', '\n', '/// @title FairAuction contract\n', '/// @author Christopher Grant - <<span class="__cf_email__" data-cfemail="8be8e3f9e2f8ffe4fbe3eef9cbefeee7fbe3e2a5e6eaf9e0eefff8">[email&#160;protected]</span>>\n', 'contract FairAuction {\n', '    /* State */\n', '    address public beneficiary;\n', '    uint public amountRaised; uint public startTime; uint public deadline; uint public memberCount; uint public crowdsaleCap;\n', '    uint256 public tokenSupply;\n', '    token public tokenReward;\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping (uint => address) accountIndex;\n', '    bool public finalized;\n', '\n', '    /* Events */\n', '    event TokenAllocation(address recipient, uint amount);\n', '    event Finalized(address beneficiary, uint amountRaised);\n', '    event FundTransfer(address backer, uint amount);\n', '    event FundClaim(address claimant, uint amount);\n', '\n', '    /* Initialize relevant crowdsale contract details */\n', '    function FairAuction(\n', '        address fundedAddress,\n', '        uint epochStartTime,\n', '        uint durationInMinutes,\n', '        uint256 capOnCrowdsale,\n', '        token contractAddressOfRewardToken\n', '    ) {\n', '        beneficiary = fundedAddress;\n', '        startTime = epochStartTime;\n', '        deadline = startTime + (durationInMinutes * 1 minutes);\n', '        tokenReward = token(contractAddressOfRewardToken);\n', '        crowdsaleCap = capOnCrowdsale * 1 ether;\n', '        finalized = false;\n', '    }\n', '\n', '    /* default function (called whenever funds are sent to the FairAuction) */\n', '    function () payable {\n', '        /* Ensure that auction is ongoing */\n', '        if (now < startTime) throw;\n', '        if (now >= deadline) throw;\n', '\n', '        uint amount = msg.value;\n', '\n', '        /* Ensure that we do not pass the cap */\n', '        if (amountRaised + amount > crowdsaleCap) throw;\n', '\n', '        uint256 existingBalance = balanceOf[msg.sender];\n', '\n', '        /* Tally new members (helps iteration later) */\n', '        if (existingBalance == 0) {\n', '            accountIndex[memberCount] = msg.sender;\n', '            memberCount += 1;\n', '        } \n', '        \n', '        /* Track contribution amount */\n', '        balanceOf[msg.sender] = existingBalance + amount;\n', '        amountRaised += amount;\n', '\n', '        /* Fire FundTransfer event */\n', '        FundTransfer(msg.sender, amount);\n', '    }\n', '\n', '    /* finalize() can be called once the FairAuction has ended, which will allow withdrawals */\n', '    function finalize() {\n', '        /* Nothing to finalize */\n', '        if (amountRaised == 0) throw;\n', '\n', '        /* Auction still ongoing */\n', '        if (now < deadline) {\n', '            /* Don&#39;t terminate auction before cap is reached */\n', '            if (amountRaised < crowdsaleCap) throw;\n', '        }\n', '\n', '        /* Snapshot available supply of reward tokens */\n', '        tokenSupply = tokenReward.balanceOf(this);\n', '\n', '        /* Mark the FairAuction as finalized */\n', '        finalized = true;\n', '        /* Fire Finalized event */\n', '        Finalized(beneficiary, amountRaised);\n', '    }\n', '\n', '    /* individualClaim() can be called by any auction participant once the FairAuction is finalized, to claim the tokens they are owed from the auction */\n', '    function individualClaim() {\n', '        /* Only allow once auction has been finalized */\n', '        if (!finalized) throw;\n', '\n', '        /* Grant tokens due */\n', '        tokenReward.transfer(msg.sender, (balanceOf[msg.sender] * tokenSupply / amountRaised));\n', '        /* Fire TokenAllocation event */\n', '        TokenAllocation(msg.sender, (balanceOf[msg.sender] * tokenSupply / amountRaised));\n', '        /* Prevent repeat-withdrawals */\n', '        balanceOf[msg.sender] = 0;\n', '    }\n', '\n', '    /* beneficiarySend() can be called once the FairAuction is finalized, to send the crowdsale proceeds to their destination address */\n', '    function beneficiarySend() {\n', '        /* Only allow once auction has been finalized */\n', '        if (!finalized) throw;\n', '\n', '        /* Send proceeds to beneficiary */\n', '        if (beneficiary.send(amountRaised)) {\n', '            /* Fire FundClaim event */\n', '            FundClaim(beneficiary, amountRaised);\n', '        }\n', '    }\n', '\n', '    /* automaticWithdrawLoop() can be called once the FairAuction is finalized to automatically allocate a batch of auctioned tokens */\n', '    function automaticWithdrawLoop(uint startIndex, uint endIndex) {\n', '        /* Only allow once auction has been finalized */\n', '        if (!finalized) throw;\n', '        \n', '        /* Distribute auctioned tokens fairly among a batch of participants. */\n', '        for (uint i=startIndex; i<=endIndex && i<memberCount; i++) {\n', '            /* Should not occur */\n', '            if (accountIndex[i] == 0)\n', '                continue;\n', '            /* Grant tokens due */\n', '            tokenReward.transfer(accountIndex[i], (balanceOf[accountIndex[i]] * tokenSupply / amountRaised));\n', '            /* Fire TokenAllocation event */\n', '            TokenAllocation(accountIndex[i], (balanceOf[accountIndex[i]] * tokenSupply / amountRaised));\n', '            /* Prevent repeat-withdrawals */\n', '            balanceOf[accountIndex[i]] = 0;\n', '        }\n', '    }\n', '}']