['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);  \n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * Ethereum Request for comments #20\n', ' * Интерфейс стандарта токенов\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '\n', '    // Возвращает баланс адреса\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    \n', '    // Отправляет токены _value на адрес _to\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    \n', '    // Отправляет токены _value с адреса _from на адрес _to\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    \n', '    // Позволяет адресу _spender снимать <= _value с вашего аккаунта\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    \n', '    // Возвращает сколько _spender может снимать с вашего аккаунта\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', 'contract RelestToken is ERC20, Ownable {\n', '    using SafeMath for uint256;\n', '    string public name = "Relest";\n', '    string public symbol = "REST";\n', '    uint256 public decimals = 8;\n', '    uint public ethRaised = 0;\n', '    address wallet = 0xC487f60b6fA6d7CC1e51908b383385CbfC6c30B5;\n', '\n', '    uint256 public minEth = 1 ether / 10;\n', '    uint256 public priceRate = 1000; // 1 ETH = 1000 RST\n', '    uint256 step1Price = 1500;\n', '    uint256 step2Price = 1300;\n', '    uint256 step3Price = 1150;\n', '    \n', '    uint256 minPriceRate = 1000;\n', '    uint256 public ethGoal = 1000 ether;\n', '\n', '    uint256 public startPreICOTimestamp = 1502287200; // 09.08.2017 14:00 (GMT)\n', '    uint256 public endPreICOTimestamp = 1502632800; // 13.08.2017 14:00 (GMT)\n', '\n', '    uint256 public startICOTimestamp = 1505743200; // 18.09.2017 14:00 (GMT)\n', '    uint256 step1End = 1505750400; // 18.09.2017 16:00 (GMT)\n', '    uint256 step2End = 1505829600; // 19.09.2017 14:00 (GMT)\n', '    uint256 step3End = 1506348000; // 25.09.2017 14:00 (GMT)\n', '    uint256 public endICOTimestamp = 1506952800; // 02.10.2017 14:00 (GMT)\n', '\n', '    bool public preSaleGoalReached = false; // true if ethGoal is reached\n', '    bool public preSaleStarted = false;\n', '    bool public preSaleEnded = false;\n', '    bool public SaleStarted = false;\n', '    bool public SaleEnded = false;\n', '    bool public isFinalized = false;\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    event TokenPurchase(address indexed sender, address indexed beneficiary, uint ethAmount, uint tokenAmount);\n', '    event Mint(address indexed to, uint256 amount);\n', '    event Bounty(address indexed to, uint256 amount);\n', '\n', '    // MODIFIERS\n', '    \n', '    modifier validPurchase() {\n', '        assert(msg.value >= minEth && msg.sender != 0x0);\n', '        _;\n', '    }\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    function RelestToken() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '        require(preSaleEnded && SaleEnded);\n', '        require(_to != 0x0 && _value > 0 && balances[msg.sender] >= _value && \n', '            balances[_to] + _value > balances[_to]);\n', '        balances[_to] += _value;\n', '        balances[msg.sender] -= _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '        require(preSaleEnded && SaleEnded);\n', '        require(_to != 0x0 && _value > 0 && balances[msg.sender] >= _value && \n', '            balances[_to] + _value > balances[_to] && allowed[_from][msg.sender] >= _value);\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    function approve(address _spender, uint _value) returns (bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    function () payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '    function checkPeriod() returns (bool) {\n', '    \tbool within = false;\n', '        if(now > startPreICOTimestamp && now < endPreICOTimestamp && !preSaleGoalReached) { // pre-ICO\n', '            preSaleStarted = true;\n', '            preSaleEnded = false;\n', '            SaleStarted = false;\n', '            SaleEnded = false;\n', '            within = true;\n', '        } else if(now > startICOTimestamp && now < endICOTimestamp) { // ICO\n', '            SaleStarted = true;\n', '            SaleEnded = false;\n', '            preSaleEnded = true;\n', '            within = true;\n', '        } else if(now > endICOTimestamp) { // after ICO\n', '            preSaleEnded = true;\n', '            SaleEnded = true;\n', '        } else if(now < startPreICOTimestamp) { // before pre-ICO\n', '            preSaleStarted = false;\n', '            preSaleEnded = false;\n', '            SaleStarted = false;\n', '            SaleEnded = false;\n', '        }else { // between pre-ICO and ICO\n', '        \tpreSaleStarted = true;\n', '        \tpreSaleEnded = true;\n', '        \tSaleStarted = false;\n', '        \tSaleEnded = false;\n', '        }\n', '        return within;\n', '    }\n', '    function buyTokens(address beneficiary) payable validPurchase {\n', '    \tassert(checkPeriod());\n', '        uint256 ethAmount = msg.value;\n', '        if(preSaleStarted && !preSaleEnded) {\n', '            priceRate = 2000;\n', '        }\n', '        if(SaleStarted && !SaleEnded) {\n', '            if(now >= startICOTimestamp && now <= step1End) {\n', '                priceRate = step1Price;\n', '            }\n', '            else if(now > step1End && now <= step2End) {\n', '                priceRate = step2Price;\n', '            }\n', '            else if(now > step2End && now <= step3End) {\n', '                priceRate = step3Price;\n', '            }\n', '            else {\n', '                priceRate = minPriceRate;\n', '            }\n', '        }\n', '        uint256 tokenAmount = ethAmount.mul(priceRate);\n', '        tokenAmount = tokenAmount.div(1e10);\n', '        ethRaised = ethRaised.add(ethAmount);\n', '        mint(beneficiary, tokenAmount);\n', '        TokenPurchase(msg.sender, beneficiary, ethAmount, tokenAmount);\n', '        wallet.transfer(msg.value);\n', '        if(preSaleStarted && !preSaleEnded && ethRaised >= ethGoal) {\n', '            preSaleEnded = true;\n', '            preSaleGoalReached = true;\n', '        }\n', '    }\n', '\n', '    function finalize() onlyOwner {\n', '        require(now > endICOTimestamp && SaleEnded && !isFinalized);\n', '        uint256 tokensLeft = (totalSupply * 30) / 70; // rest 30% of tokens\n', '        Bounty(wallet, tokensLeft);\n', '        mint(wallet, tokensLeft);\n', '        isFinalized = true;\n', '    }\n', '\n', '    function mint(address receiver, uint256 _amount) returns (bool success){\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[receiver] = balances[receiver].add(_amount);\n', '        Mint(receiver, _amount);\n', '        return true;\n', '    }\n', '}\n', '// &#175;\\_(ツ)_/&#175;']
['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);  \n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * Ethereum Request for comments #20\n', ' * Интерфейс стандарта токенов\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '\n', '    // Возвращает баланс адреса\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    \n', '    // Отправляет токены _value на адрес _to\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    \n', '    // Отправляет токены _value с адреса _from на адрес _to\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    \n', '    // Позволяет адресу _spender снимать <= _value с вашего аккаунта\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    \n', '    // Возвращает сколько _spender может снимать с вашего аккаунта\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', 'contract RelestToken is ERC20, Ownable {\n', '    using SafeMath for uint256;\n', '    string public name = "Relest";\n', '    string public symbol = "REST";\n', '    uint256 public decimals = 8;\n', '    uint public ethRaised = 0;\n', '    address wallet = 0xC487f60b6fA6d7CC1e51908b383385CbfC6c30B5;\n', '\n', '    uint256 public minEth = 1 ether / 10;\n', '    uint256 public priceRate = 1000; // 1 ETH = 1000 RST\n', '    uint256 step1Price = 1500;\n', '    uint256 step2Price = 1300;\n', '    uint256 step3Price = 1150;\n', '    \n', '    uint256 minPriceRate = 1000;\n', '    uint256 public ethGoal = 1000 ether;\n', '\n', '    uint256 public startPreICOTimestamp = 1502287200; // 09.08.2017 14:00 (GMT)\n', '    uint256 public endPreICOTimestamp = 1502632800; // 13.08.2017 14:00 (GMT)\n', '\n', '    uint256 public startICOTimestamp = 1505743200; // 18.09.2017 14:00 (GMT)\n', '    uint256 step1End = 1505750400; // 18.09.2017 16:00 (GMT)\n', '    uint256 step2End = 1505829600; // 19.09.2017 14:00 (GMT)\n', '    uint256 step3End = 1506348000; // 25.09.2017 14:00 (GMT)\n', '    uint256 public endICOTimestamp = 1506952800; // 02.10.2017 14:00 (GMT)\n', '\n', '    bool public preSaleGoalReached = false; // true if ethGoal is reached\n', '    bool public preSaleStarted = false;\n', '    bool public preSaleEnded = false;\n', '    bool public SaleStarted = false;\n', '    bool public SaleEnded = false;\n', '    bool public isFinalized = false;\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    event TokenPurchase(address indexed sender, address indexed beneficiary, uint ethAmount, uint tokenAmount);\n', '    event Mint(address indexed to, uint256 amount);\n', '    event Bounty(address indexed to, uint256 amount);\n', '\n', '    // MODIFIERS\n', '    \n', '    modifier validPurchase() {\n', '        assert(msg.value >= minEth && msg.sender != 0x0);\n', '        _;\n', '    }\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(msg.data.length >= size + 4);\n', '        _;\n', '    }\n', '\n', '    function RelestToken() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '        require(preSaleEnded && SaleEnded);\n', '        require(_to != 0x0 && _value > 0 && balances[msg.sender] >= _value && \n', '            balances[_to] + _value > balances[_to]);\n', '        balances[_to] += _value;\n', '        balances[msg.sender] -= _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '        require(preSaleEnded && SaleEnded);\n', '        require(_to != 0x0 && _value > 0 && balances[msg.sender] >= _value && \n', '            balances[_to] + _value > balances[_to] && allowed[_from][msg.sender] >= _value);\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    function approve(address _spender, uint _value) returns (bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    function () payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '    function checkPeriod() returns (bool) {\n', '    \tbool within = false;\n', '        if(now > startPreICOTimestamp && now < endPreICOTimestamp && !preSaleGoalReached) { // pre-ICO\n', '            preSaleStarted = true;\n', '            preSaleEnded = false;\n', '            SaleStarted = false;\n', '            SaleEnded = false;\n', '            within = true;\n', '        } else if(now > startICOTimestamp && now < endICOTimestamp) { // ICO\n', '            SaleStarted = true;\n', '            SaleEnded = false;\n', '            preSaleEnded = true;\n', '            within = true;\n', '        } else if(now > endICOTimestamp) { // after ICO\n', '            preSaleEnded = true;\n', '            SaleEnded = true;\n', '        } else if(now < startPreICOTimestamp) { // before pre-ICO\n', '            preSaleStarted = false;\n', '            preSaleEnded = false;\n', '            SaleStarted = false;\n', '            SaleEnded = false;\n', '        }else { // between pre-ICO and ICO\n', '        \tpreSaleStarted = true;\n', '        \tpreSaleEnded = true;\n', '        \tSaleStarted = false;\n', '        \tSaleEnded = false;\n', '        }\n', '        return within;\n', '    }\n', '    function buyTokens(address beneficiary) payable validPurchase {\n', '    \tassert(checkPeriod());\n', '        uint256 ethAmount = msg.value;\n', '        if(preSaleStarted && !preSaleEnded) {\n', '            priceRate = 2000;\n', '        }\n', '        if(SaleStarted && !SaleEnded) {\n', '            if(now >= startICOTimestamp && now <= step1End) {\n', '                priceRate = step1Price;\n', '            }\n', '            else if(now > step1End && now <= step2End) {\n', '                priceRate = step2Price;\n', '            }\n', '            else if(now > step2End && now <= step3End) {\n', '                priceRate = step3Price;\n', '            }\n', '            else {\n', '                priceRate = minPriceRate;\n', '            }\n', '        }\n', '        uint256 tokenAmount = ethAmount.mul(priceRate);\n', '        tokenAmount = tokenAmount.div(1e10);\n', '        ethRaised = ethRaised.add(ethAmount);\n', '        mint(beneficiary, tokenAmount);\n', '        TokenPurchase(msg.sender, beneficiary, ethAmount, tokenAmount);\n', '        wallet.transfer(msg.value);\n', '        if(preSaleStarted && !preSaleEnded && ethRaised >= ethGoal) {\n', '            preSaleEnded = true;\n', '            preSaleGoalReached = true;\n', '        }\n', '    }\n', '\n', '    function finalize() onlyOwner {\n', '        require(now > endICOTimestamp && SaleEnded && !isFinalized);\n', '        uint256 tokensLeft = (totalSupply * 30) / 70; // rest 30% of tokens\n', '        Bounty(wallet, tokensLeft);\n', '        mint(wallet, tokensLeft);\n', '        isFinalized = true;\n', '    }\n', '\n', '    function mint(address receiver, uint256 _amount) returns (bool success){\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[receiver] = balances[receiver].add(_amount);\n', '        Mint(receiver, _amount);\n', '        return true;\n', '    }\n', '}\n', '// ¯\\_(ツ)_/¯']
