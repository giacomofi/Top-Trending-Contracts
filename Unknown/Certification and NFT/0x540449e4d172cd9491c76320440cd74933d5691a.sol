['pragma solidity ^0.4.8;\n', '\n', '// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) constant returns (uint);\n', '    function allowance(address owner, address spender) constant returns (uint);\n', '\n', '    function transfer(address to, uint value) returns (bool ok);\n', '    function transferFrom(address from, address to, uint value) returns (bool ok);\n', '    function approve(address spender, uint value) returns (bool ok);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function assert(bool assertion) internal {\n', '        if (!assertion) {\n', '            throw;\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\n', '/// @author Stefan George - <<span class="__cf_email__" data-cfemail="4132352427202f6f26242e33262401222e2f32242f3238326f2f2435">[email&#160;protected]</span>>\n', 'contract MultiSigWallet {\n', '\n', '    // flag to determine if address is for a real contract or not\n', '    bool public isMultiSigWallet = false;\n', '\n', '    uint constant public MAX_OWNER_COUNT = 50;\n', '\n', '    event Confirmation(address indexed sender, uint indexed transactionId);\n', '    event Revocation(address indexed sender, uint indexed transactionId);\n', '    event Submission(uint indexed transactionId);\n', '    event Execution(uint indexed transactionId);\n', '    event ExecutionFailure(uint indexed transactionId);\n', '    event Deposit(address indexed sender, uint value);\n', '    event OwnerAddition(address indexed owner);\n', '    event OwnerRemoval(address indexed owner);\n', '    event RequirementChange(uint required);\n', '\n', '    mapping (uint => Transaction) public transactions;\n', '    mapping (uint => mapping (address => bool)) public confirmations;\n', '    mapping (address => bool) public isOwner;\n', '    address[] public owners;\n', '    uint public required;\n', '    uint public transactionCount;\n', '\n', '    struct Transaction {\n', '    address destination;\n', '    uint value;\n', '    bytes data;\n', '    bool executed;\n', '    }\n', '\n', '    modifier onlyWallet() {\n', '        if (msg.sender != address(this)) throw;\n', '        _;\n', '    }\n', '\n', '    modifier ownerDoesNotExist(address owner) {\n', '        if (isOwner[owner]) throw;\n', '        _;\n', '    }\n', '\n', '    modifier ownerExists(address owner) {\n', '        if (!isOwner[owner]) throw;\n', '        _;\n', '    }\n', '\n', '    modifier transactionExists(uint transactionId) {\n', '        if (transactions[transactionId].destination == 0) throw;\n', '        _;\n', '    }\n', '\n', '    modifier confirmed(uint transactionId, address owner) {\n', '        if (!confirmations[transactionId][owner]) throw;\n', '        _;\n', '    }\n', '\n', '    modifier notConfirmed(uint transactionId, address owner) {\n', '        if (confirmations[transactionId][owner]) throw;\n', '        _;\n', '    }\n', '\n', '    modifier notExecuted(uint transactionId) {\n', '        if (transactions[transactionId].executed) throw;\n', '        _;\n', '    }\n', '\n', '    modifier notNull(address _address) {\n', '        if (_address == 0) throw;\n', '        _;\n', '    }\n', '\n', '    modifier validRequirement(uint ownerCount, uint _required) {\n', '        if (ownerCount > MAX_OWNER_COUNT) throw;\n', '        if (_required > ownerCount) throw;\n', '        if (_required == 0) throw;\n', '        if (ownerCount == 0) throw;\n', '        _;\n', '    }\n', '\n', '    /// @dev Fallback function allows to deposit ether.\n', '    function()\n', '    payable\n', '    {\n', '        if (msg.value > 0)\n', '        Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '    /// @dev Contract constructor sets initial owners and required number of confirmations.\n', '    /// @param _owners List of initial owners.\n', '    /// @param _required Number of required confirmations.\n', '    function MultiSigWallet(address[] _owners, uint _required)\n', '    public\n', '    validRequirement(_owners.length, _required)\n', '    {\n', '        for (uint i=0; i<_owners.length; i++) {\n', '            if (isOwner[_owners[i]] || _owners[i] == 0) throw;\n', '            isOwner[_owners[i]] = true;\n', '        }\n', '        isMultiSigWallet = true;\n', '        owners = _owners;\n', '        required = _required;\n', '    }\n', '\n', '    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n', '    /// @param owner Address of new owner.\n', '    function addOwner(address owner)\n', '    public\n', '    onlyWallet\n', '    ownerDoesNotExist(owner)\n', '    notNull(owner)\n', '    validRequirement(owners.length + 1, required)\n', '    {\n', '        isOwner[owner] = true;\n', '        owners.push(owner);\n', '        OwnerAddition(owner);\n', '    }\n', '\n', '    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n', '    /// @param owner Address of owner.\n', '    function removeOwner(address owner)\n', '    public\n', '    onlyWallet\n', '    ownerExists(owner)\n', '    {\n', '        isOwner[owner] = false;\n', '        for (uint i=0; i<owners.length - 1; i++)\n', '        if (owners[i] == owner) {\n', '            owners[i] = owners[owners.length - 1];\n', '            break;\n', '        }\n', '        owners.length -= 1;\n', '        if (required > owners.length)\n', '        changeRequirement(owners.length);\n', '        OwnerRemoval(owner);\n', '    }\n', '\n', '    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n', '    /// @param owner Address of owner to be replaced.\n', '    /// @param newOwner Address of new owner.\n', '    /// @param index the indx of the owner to be replaced\n', '    function replaceOwnerIndexed(address owner, address newOwner, uint index)\n', '    public\n', '    onlyWallet\n', '    ownerExists(owner)\n', '    ownerDoesNotExist(newOwner)\n', '    {\n', '        if (owners[index] != owner) throw;\n', '        owners[index] = newOwner;\n', '        isOwner[owner] = false;\n', '        isOwner[newOwner] = true;\n', '        OwnerRemoval(owner);\n', '        OwnerAddition(newOwner);\n', '    }\n', '\n', '\n', '    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n', '    /// @param _required Number of required confirmations.\n', '    function changeRequirement(uint _required)\n', '    public\n', '    onlyWallet\n', '    validRequirement(owners.length, _required)\n', '    {\n', '        required = _required;\n', '        RequirementChange(_required);\n', '    }\n', '\n', '    /// @dev Allows an owner to submit and confirm a transaction.\n', '    /// @param destination Transaction target address.\n', '    /// @param value Transaction ether value.\n', '    /// @param data Transaction data payload.\n', '    /// @return Returns transaction ID.\n', '    function submitTransaction(address destination, uint value, bytes data)\n', '    public\n', '    returns (uint transactionId)\n', '    {\n', '        transactionId = addTransaction(destination, value, data);\n', '        confirmTransaction(transactionId);\n', '    }\n', '\n', '    /// @dev Allows an owner to confirm a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    function confirmTransaction(uint transactionId)\n', '    public\n', '    ownerExists(msg.sender)\n', '    transactionExists(transactionId)\n', '    notConfirmed(transactionId, msg.sender)\n', '    {\n', '        confirmations[transactionId][msg.sender] = true;\n', '        Confirmation(msg.sender, transactionId);\n', '        executeTransaction(transactionId);\n', '    }\n', '\n', '    /// @dev Allows an owner to revoke a confirmation for a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    function revokeConfirmation(uint transactionId)\n', '    public\n', '    ownerExists(msg.sender)\n', '    confirmed(transactionId, msg.sender)\n', '    notExecuted(transactionId)\n', '    {\n', '        confirmations[transactionId][msg.sender] = false;\n', '        Revocation(msg.sender, transactionId);\n', '    }\n', '\n', '    /// @dev Returns the confirmation status of a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    /// @return Confirmation status.\n', '    function isConfirmed(uint transactionId)\n', '    public\n', '    constant\n', '    returns (bool)\n', '    {\n', '        uint count = 0;\n', '        for (uint i=0; i<owners.length; i++) {\n', '            if (confirmations[transactionId][owners[i]])\n', '            count += 1;\n', '            if (count == required)\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Internal functions\n', '     */\n', '\n', '    /// @dev Allows anyone to execute a confirmed transaction.\n', '    /// @param transactionId Transaction ID.\n', '    function executeTransaction(uint transactionId)\n', '    internal\n', '    notExecuted(transactionId)\n', '    {\n', '        if (isConfirmed(transactionId)) {\n', '            Transaction tx = transactions[transactionId];\n', '            tx.executed = true;\n', '            if (tx.destination.call.value(tx.value)(tx.data))\n', '            Execution(transactionId);\n', '            else {\n', '                ExecutionFailure(transactionId);\n', '                tx.executed = false;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n', '    /// @param destination Transaction target address.\n', '    /// @param value Transaction ether value.\n', '    /// @param data Transaction data payload.\n', '    /// @return Returns transaction ID.\n', '    function addTransaction(address destination, uint value, bytes data)\n', '    internal\n', '    notNull(destination)\n', '    returns (uint transactionId)\n', '    {\n', '        transactionId = transactionCount;\n', '        transactions[transactionId] = Transaction({\n', '        destination: destination,\n', '        value: value,\n', '        data: data,\n', '        executed: false\n', '        });\n', '        transactionCount += 1;\n', '        Submission(transactionId);\n', '    }\n', '\n', '    /*\n', '     * Web3 call functions\n', '     */\n', '    /// @dev Returns number of confirmations of a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    /// @return Number of confirmations.\n', '    function getConfirmationCount(uint transactionId)\n', '    public\n', '    constant\n', '    returns (uint count)\n', '    {\n', '        for (uint i=0; i<owners.length; i++)\n', '        if (confirmations[transactionId][owners[i]])\n', '        count += 1;\n', '    }\n', '\n', '    /// @dev Returns total number of transactions after filers are applied.\n', '    /// @param pending Include pending transactions.\n', '    /// @param executed Include executed transactions.\n', '    /// @return Total number of transactions after filters are applied.\n', '    function getTransactionCount(bool pending, bool executed)\n', '    public\n', '    constant\n', '    returns (uint count)\n', '    {\n', '        for (uint i=0; i<transactionCount; i++)\n', '        if ((pending && !transactions[i].executed) ||\n', '        (executed && transactions[i].executed))\n', '        count += 1;\n', '    }\n', '\n', '    /// @dev Returns list of owners.\n', '    /// @return List of owner addresses.\n', '    function getOwners()\n', '    public\n', '    constant\n', '    returns (address[])\n', '    {\n', '        return owners;\n', '    }\n', '\n', '    /// @dev Returns array with owner addresses, which confirmed transaction.\n', '    /// @param transactionId Transaction ID.\n', '    /// @return Returns array of owner addresses.\n', '    function getConfirmations(uint transactionId)\n', '    public\n', '    constant\n', '    returns (address[] _confirmations)\n', '    {\n', '        address[] memory confirmationsTemp = new address[](owners.length);\n', '        uint count = 0;\n', '        uint i;\n', '        for (i=0; i<owners.length; i++)\n', '        if (confirmations[transactionId][owners[i]]) {\n', '            confirmationsTemp[count] = owners[i];\n', '            count += 1;\n', '        }\n', '        _confirmations = new address[](count);\n', '        for (i=0; i<count; i++)\n', '        _confirmations[i] = confirmationsTemp[i];\n', '    }\n', '\n', '    /// @dev Returns list of transaction IDs in defined range.\n', '    /// @param from Index start position of transaction array.\n', '    /// @param to Index end position of transaction array.\n', '    /// @param pending Include pending transactions.\n', '    /// @param executed Include executed transactions.\n', '    /// @return Returns array of transaction IDs.\n', '    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n', '    public\n', '    constant\n', '    returns (uint[] _transactionIds)\n', '    {\n', '        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n', '        uint count = 0;\n', '        uint i;\n', '        for (i=0; i<transactionCount; i++)\n', '        if ((pending && !transactions[i].executed) ||\n', '        (executed && transactions[i].executed))\n', '        {\n', '            transactionIdsTemp[count] = i;\n', '            count += 1;\n', '        }\n', '        _transactionIds = new uint[](to - from);\n', '        for (i=from; i<to; i++)\n', '        _transactionIds[i - from] = transactionIdsTemp[i];\n', '    }\n', '\n', '}\n', '\n', 'contract UpgradeAgent is SafeMath {\n', '    address public owner;\n', '\n', '    bool public isUpgradeAgent;\n', '\n', '    function upgradeFrom(address _from, uint256 _value) public;\n', '\n', '    function finalizeUpgrade() public;\n', '\n', '    function setOriginalSupply() public;\n', '}\n', '\n', '/// @title Time-locked vault of tokens allocated to DecentBet after 365 days\n', 'contract DecentBetVault is SafeMath {\n', '\n', '    // flag to determine if address is for a real contract or not\n', '    bool public isDecentBetVault = false;\n', '\n', '    DecentBetToken decentBetToken;\n', '\n', '    address decentBetMultisig;\n', '\n', '    uint256 unlockedAtTime;\n', '\n', '    // smaller lock for testing\n', '    uint256 public constant timeOffset = 1 years;\n', '\n', '    /// @notice Constructor function sets the DecentBet Multisig address and\n', '    /// total number of locked tokens to transfer\n', '    function DecentBetVault(address _decentBetMultisig) /** internal */ {\n', '        if (_decentBetMultisig == 0x0) throw;\n', '        decentBetToken = DecentBetToken(msg.sender);\n', '        decentBetMultisig = _decentBetMultisig;\n', '        isDecentBetVault = true;\n', '\n', '        // 1 year later\n', '        unlockedAtTime = safeAdd(getTime(), timeOffset);\n', '    }\n', '\n', '    /// @notice Transfer locked tokens to Decent.bet&#39;s multisig wallet\n', '    function unlock() external {\n', '        // Wait your turn!\n', '        if (getTime() < unlockedAtTime) throw;\n', '        // Will fail if allocation (and therefore toTransfer) is 0.\n', '        if (!decentBetToken.transfer(decentBetMultisig, decentBetToken.balanceOf(this))) throw;\n', '    }\n', '\n', '    function getTime() internal returns (uint256) {\n', '        return now;\n', '    }\n', '\n', '    // disallow ETH payments to TimeVault\n', '    function() payable {\n', '        throw;\n', '    }\n', '\n', '}\n', '\n', '\n', '/// @title DecentBet crowdsale contract\n', 'contract DecentBetToken is SafeMath, ERC20 {\n', '\n', '    // flag to determine if address is for a real contract or not\n', '    bool public isDecentBetToken = false;\n', '\n', '    // State machine\n', '    enum State{Waiting, PreSale, CommunitySale, PublicSale, Success}\n', '\n', '    // Token information\n', '    string public constant name = "Decent.Bet Token";\n', '\n', '    string public constant symbol = "DBET";\n', '\n', '    uint256 public constant decimals = 18;  // decimal places\n', '\n', '    uint256 public constant housePercentOfTotal = 10;\n', '\n', '    uint256 public constant vaultPercentOfTotal = 18;\n', '\n', '    uint256 public constant bountyPercentOfTotal = 2;\n', '\n', '    uint256 public constant crowdfundPercentOfTotal = 70;\n', '\n', '    uint256 public constant hundredPercent = 100;\n', '\n', '    mapping (address => uint256) balances;\n', '\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    // Authorized addresses\n', '    address public team;\n', '\n', '    // Upgrade information\n', '    bool public finalizedUpgrade = false;\n', '\n', '    address public upgradeMaster;\n', '\n', '    UpgradeAgent public upgradeAgent;\n', '\n', '    uint256 public totalUpgraded;\n', '\n', '    // Crowdsale information\n', '    bool public finalizedCrowdfunding = false;\n', '\n', '    // Whitelisted addresses for pre-sale\n', '    address[] public preSaleWhitelist;\n', '    mapping (address => bool) public preSaleAllowed;\n', '\n', '    // Whitelisted addresses from community\n', '    address[] public communitySaleWhitelist;\n', '    mapping (address => bool) public communitySaleAllowed;\n', '    uint[2] public communitySaleCap = [100000 ether, 200000 ether];\n', '    mapping (address => uint[2]) communitySalePurchases;\n', '\n', '    uint256 public preSaleStartTime; // Pre-sale start block timestamp\n', '    uint256 public fundingStartTime; // crowdsale start block timestamp\n', '    uint256 public fundingEndTime; // crowdsale end block timestamp\n', '    // DBET:ETH exchange rate - Needs to be updated at time of ICO.\n', '    // Price of ETH/0.125. For example: If ETH/USD = 300, it would be 2400 DBETs per ETH.\n', '    uint256 public baseTokensPerEther;\n', '    uint256 public tokenCreationMax = safeMul(250000 ether, 1000); // A maximum of 250M DBETs can be minted during ICO.\n', '\n', '    // Amount of tokens alloted to pre-sale investors.\n', '    uint256 public preSaleAllotment;\n', '    // Address of pre-sale investors.\n', '    address public preSaleAddress;\n', '\n', '    // for testing on testnet\n', '    //uint256 public constant tokenCreationMax = safeMul(10 ether, baseTokensPerEther);\n', '    //uint256 public constant tokenCreationMin = safeMul(3 ether, baseTokensPerEther);\n', '\n', '    address public decentBetMultisig;\n', '\n', '    DecentBetVault public timeVault; // DecentBet&#39;s time-locked vault\n', '\n', '    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event UpgradeFinalized(address sender, address upgradeAgent);\n', '\n', '    event UpgradeAgentSet(address agent);\n', '\n', '    // Allow only the team address to continue\n', '    modifier onlyTeam() {\n', '        if(msg.sender != team) throw;\n', '        _;\n', '    }\n', '\n', '    function DecentBetToken(address _decentBetMultisig,\n', '    address _upgradeMaster, address _team,\n', '    uint256 _baseTokensPerEther, uint256 _fundingStartTime,\n', '    uint256 _fundingEndTime) {\n', '\n', '        if (_decentBetMultisig == 0) throw;\n', '        if (_team == 0) throw;\n', '        if (_upgradeMaster == 0) throw;\n', '        if (_baseTokensPerEther == 0) throw;\n', '\n', '        // For testing/dev\n', '        //         if(_fundingStartTime == 0) throw;\n', '        // Crowdsale can only officially start during/after the current block timestamp.\n', '        if (_fundingStartTime < getTime()) throw;\n', '\n', '        if (_fundingEndTime <= _fundingStartTime) throw;\n', '\n', '        isDecentBetToken = true;\n', '\n', '        upgradeMaster = _upgradeMaster;\n', '        team = _team;\n', '\n', '        baseTokensPerEther = _baseTokensPerEther;\n', '\n', '        preSaleStartTime = _fundingStartTime - 1 days;\n', '        fundingStartTime = _fundingStartTime;\n', '        fundingEndTime = _fundingEndTime;\n', '\n', '        // Pre-sale issuance from pre-sale contract\n', '        // 0x7be601aab2f40cc23653965749b84e5cb8cfda43\n', '        preSaleAddress = 0x87f7beeda96216ec2a325e417a45ed262495686b;\n', '        preSaleAllotment = 45000000 ether;\n', '\n', '        balances[preSaleAddress] = preSaleAllotment;\n', '        totalSupply = safeAdd(totalSupply, preSaleAllotment);\n', '\n', '        timeVault = new DecentBetVault(_decentBetMultisig);\n', '        if (!timeVault.isDecentBetVault()) throw;\n', '\n', '        decentBetMultisig = _decentBetMultisig;\n', '        if (!MultiSigWallet(decentBetMultisig).isMultiSigWallet()) throw;\n', '    }\n', '\n', '    function balanceOf(address who) constant returns (uint) {\n', '        return balances[who];\n', '    }\n', '\n', '    /// @notice Transfer `value` DBET tokens from sender&#39;s account\n', '    /// `msg.sender` to provided account address `to`.\n', '    /// @notice This function is disabled during the funding.\n', '    /// @dev Required state: Success\n', '    /// @param to The address of the recipient\n', '    /// @param value The number of DBETs to transfer\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address to, uint256 value) returns (bool ok) {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if crowdfunding was not a success.\n', '        uint256 senderBalance = balances[msg.sender];\n', '        if (senderBalance >= value && value > 0) {\n', '            senderBalance = safeSub(senderBalance, value);\n', '            balances[msg.sender] = senderBalance;\n', '            balances[to] = safeAdd(balances[to], value);\n', '            Transfer(msg.sender, to, value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @notice Transfer `value` DBET tokens from sender &#39;from&#39;\n', '    /// to provided account address `to`.\n', '    /// @notice This function is disabled during the funding.\n', '    /// @dev Required state: Success\n', '    /// @param from The address of the sender\n', '    /// @param to The address of the recipient\n', '    /// @param value The number of DBETs to transfer\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address from, address to, uint256 value) returns (bool ok) {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if not in Success state.\n', '        // protect against wrapping uints\n', '        if (balances[from] >= value &&\n', '        allowed[from][msg.sender] >= value &&\n', '        safeAdd(balances[to], value) > balances[to])\n', '        {\n', '            balances[to] = safeAdd(balances[to], value);\n', '            balances[from] = safeSub(balances[from], value);\n', '            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], value);\n', '            Transfer(from, to, value);\n', '            return true;\n', '        }\n', '        else {return false;}\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `spender` to spend `value` tokens\n', '    /// @param spender The address of the account able to transfer the tokens\n', '    /// @param value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address spender, uint256 value) returns (bool ok) {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if not in Success state.\n', '        allowed[msg.sender][spender] = value;\n', '        Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /// @param owner The address of the account owning tokens\n', '    /// @param spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address owner, address spender) constant returns (uint) {\n', '        return allowed[owner][spender];\n', '    }\n', '\n', '    // Token upgrade functionality\n', '\n', '    /// @notice Upgrade tokens to the new token contract.\n', '    /// @dev Required state: Success\n', '    /// @param value The number of tokens to upgrade\n', '    function upgrade(uint256 value) external {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if not in Success state.\n', '        if (upgradeAgent.owner() == 0x0) throw;\n', '        // need a real upgradeAgent address\n', '        if (finalizedUpgrade) throw;\n', '        // cannot upgrade if finalized\n', '\n', '        // Validate input value.\n', '        if (value == 0) throw;\n', '        if (value > balances[msg.sender]) throw;\n', '\n', '        // update the balances here first before calling out (reentrancy)\n', '        balances[msg.sender] = safeSub(balances[msg.sender], value);\n', '        totalSupply = safeSub(totalSupply, value);\n', '        totalUpgraded = safeAdd(totalUpgraded, value);\n', '        upgradeAgent.upgradeFrom(msg.sender, value);\n', '        Upgrade(msg.sender, upgradeAgent, value);\n', '    }\n', '\n', '    /// @notice Set address of upgrade target contract and enable upgrade\n', '    /// process.\n', '    /// @dev Required state: Success\n', '    /// @param agent The address of the UpgradeAgent contract\n', '    function setUpgradeAgent(address agent) external {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if not in Success state.\n', '        if (agent == 0x0) throw;\n', '        // don&#39;t set agent to nothing\n', '        if (msg.sender != upgradeMaster) throw;\n', '        // Only a master can designate the next agent\n', '        upgradeAgent = UpgradeAgent(agent);\n', '        if (!upgradeAgent.isUpgradeAgent()) throw;\n', '        // this needs to be called in success condition to guarantee the invariant is true\n', '        upgradeAgent.setOriginalSupply();\n', '        UpgradeAgentSet(upgradeAgent);\n', '    }\n', '\n', '    /// @notice Set address of upgrade target contract and enable upgrade\n', '    /// process.\n', '    /// @dev Required state: Success\n', '    /// @param master The address that will manage upgrades, not the upgradeAgent contract address\n', '    function setUpgradeMaster(address master) external {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if not in Success state.\n', '        if (master == 0x0) throw;\n', '        if (msg.sender != upgradeMaster) throw;\n', '        // Only a master can designate the next master\n', '        upgradeMaster = master;\n', '    }\n', '\n', '    /// @notice finalize the upgrade\n', '    /// @dev Required state: Success\n', '    function finalizeUpgrade() external {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if not in Success state.\n', '        if (upgradeAgent.owner() == 0x0) throw;\n', '        // we need a valid upgrade agent\n', '        if (msg.sender != upgradeMaster) throw;\n', '        // only upgradeMaster can finalize\n', '        if (finalizedUpgrade) throw;\n', '        // can&#39;t finalize twice\n', '\n', '        finalizedUpgrade = true;\n', '        // prevent future upgrades\n', '\n', '        upgradeAgent.finalizeUpgrade();\n', '        // call finalize upgrade on new contract\n', '        UpgradeFinalized(msg.sender, upgradeAgent);\n', '    }\n', '\n', '    // Allow users to purchase by sending Ether to the contract\n', '    function() payable {\n', '        invest();\n', '    }\n', '\n', '    // Updates tokens per ETH rates before the pre-sale\n', '    function updateBaseTokensPerEther(uint _baseTokensPerEther) onlyTeam {\n', '        if(getState() != State.Waiting) throw;\n', '\n', '        baseTokensPerEther = _baseTokensPerEther;\n', '    }\n', '\n', '    // Returns the current rate after adding bonuses for the time period\n', '    function getTokensAtCurrentRate(uint weiValue) constant returns (uint) {\n', '        /* Pre-sale */\n', '        if(getTime() >= preSaleStartTime && getTime() < fundingStartTime) {\n', '            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 120)), 100); // 20% bonus\n', '        }\n', '\n', '        /* Community sale */\n', '        else if(getTime() >= fundingStartTime && getTime() < fundingStartTime + 1 days) {\n', '            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 120)), 100); // 20% bonus\n', '        } else if(getTime() >= (fundingStartTime + 1 days) && getTime() < fundingStartTime + 2 days) {\n', '            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 120)), 100); // 20% bonus\n', '        }\n', '\n', '        /* Public sale */\n', '        else if(getTime() >= (fundingStartTime + 2 days) && getTime() < fundingStartTime + 1 weeks) {\n', '            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 110)), 100); // 10% bonus\n', '        } else if(getTime() >= fundingStartTime + 1 weeks && getTime() < fundingStartTime + 2 weeks) {\n', '            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 105)), 100); // 5% bonus\n', '        } else if(getTime() >= fundingStartTime + 2 weeks && getTime() < fundingEndTime) {\n', '            return safeMul(weiValue, baseTokensPerEther); // 0% bonus\n', '        }\n', '    }\n', '\n', '    // Allows the owner to add an address to the pre-sale whitelist.\n', '    function addToPreSaleWhitelist(address _address) onlyTeam {\n', '\n', '        // Add to pre-sale whitelist only if state is Waiting right now.\n', '        if(getState() != State.Waiting) throw;\n', '\n', '        // Address already added to whitelist.\n', '        if (preSaleAllowed[_address]) throw;\n', '\n', '        preSaleWhitelist.push(_address);\n', '        preSaleAllowed[_address] = true;\n', '    }\n', '\n', '    // Allows the owner to add an address to the community whitelist.\n', '    function addToCommunitySaleWhitelist(address[] addresses) onlyTeam {\n', '\n', '        // Add to community sale whitelist only if state is Waiting or Presale right now.\n', '        if(getState() != State.Waiting &&\n', '        getState() != State.PreSale) throw;\n', '\n', '        for(uint i = 0; i < addresses.length; i++) {\n', '            if(!communitySaleAllowed[addresses[i]]) {\n', '                communitySaleWhitelist.push(addresses[i]);\n', '                communitySaleAllowed[addresses[i]] = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Create tokens when funding is active.\n', '    /// @dev Required state: Funding\n', '    /// @dev State transition: -> Funding Success (only if cap reached)\n', '    function invest() payable {\n', '\n', '        // Abort if not in PreSale, CommunitySale or PublicSale state.\n', '        if (getState() != State.PreSale &&\n', '        getState() != State.CommunitySale &&\n', '        getState() != State.PublicSale) throw;\n', '\n', '        // User hasn&#39;t been whitelisted for pre-sale.\n', '        if(getState() == State.PreSale && !preSaleAllowed[msg.sender]) throw;\n', '\n', '        // User hasn&#39;t been whitelisted for community sale.\n', '        if(getState() == State.CommunitySale && !communitySaleAllowed[msg.sender]) throw;\n', '\n', '        // Do not allow creating 0 tokens.\n', '        if (msg.value == 0) throw;\n', '\n', '        // multiply by exchange rate to get newly created token amount\n', '        uint256 createdTokens = getTokensAtCurrentRate(msg.value);\n', '\n', '        allocateTokens(msg.sender, createdTokens);\n', '    }\n', '\n', '    // Allocates tokens to an investors&#39; address\n', '    function allocateTokens(address _address, uint amount) internal {\n', '\n', '        // we are creating tokens, so increase the totalSupply.\n', '        totalSupply = safeAdd(totalSupply, amount);\n', '\n', '        // don&#39;t go over the limit!\n', '        if (totalSupply > tokenCreationMax) throw;\n', '\n', '        // Don&#39;t allow community whitelisted addresses to purchase more than their cap.\n', '        if(getState() == State.CommunitySale) {\n', '            // Community sale day 1.\n', '            // Whitelisted addresses can purchase a maximum of 100k DBETs (10k USD).\n', '            if(getTime() >= fundingStartTime &&\n', '            getTime() < fundingStartTime + 1 days) {\n', '                if(safeAdd(communitySalePurchases[msg.sender][0], amount) > communitySaleCap[0])\n', '                throw;\n', '                else\n', '                communitySalePurchases[msg.sender][0] =\n', '                safeAdd(communitySalePurchases[msg.sender][0], amount);\n', '            }\n', '\n', '            // Community sale day 2.\n', '            // Whitelisted addresses can purchase a maximum of 200k DBETs (20k USD).\n', '            else if(getTime() >= (fundingStartTime + 1 days) &&\n', '            getTime() < fundingStartTime + 2 days) {\n', '                if(safeAdd(communitySalePurchases[msg.sender][1], amount) > communitySaleCap[1])\n', '                throw;\n', '                else\n', '                communitySalePurchases[msg.sender][1] =\n', '                safeAdd(communitySalePurchases[msg.sender][1], amount);\n', '            }\n', '        }\n', '\n', '        // Assign new tokens to the sender.\n', '        balances[_address] = safeAdd(balances[_address], amount);\n', '\n', '        // Log token creation event\n', '        Transfer(0, _address, amount);\n', '    }\n', '\n', '    /// @notice Finalize crowdfunding\n', '    /// @dev If cap was reached or crowdfunding has ended then:\n', '    /// create DBET for the DecentBet Multisig and team,\n', '    /// transfer ETH to the DecentBet Multisig address.\n', '    /// @dev Required state: Success\n', '    function finalizeCrowdfunding() external {\n', '        // Abort if not in Funding Success state.\n', '        if (getState() != State.Success) throw;\n', '        // don&#39;t finalize unless we won\n', '        if (finalizedCrowdfunding) throw;\n', '        // can&#39;t finalize twice (so sneaky!)\n', '\n', '        // prevent more creation of tokens\n', '        finalizedCrowdfunding = true;\n', '\n', '        // Founder&#39;s supply : 18% of total goes to vault, time locked for 6 months\n', '        uint256 vaultTokens = safeDiv(safeMul(totalSupply, vaultPercentOfTotal), crowdfundPercentOfTotal);\n', '        balances[timeVault] = safeAdd(balances[timeVault], vaultTokens);\n', '        Transfer(0, timeVault, vaultTokens);\n', '\n', '        // House: 10% of total goes to Decent.bet for initial house setup\n', '        uint256 houseTokens = safeDiv(safeMul(totalSupply, housePercentOfTotal), crowdfundPercentOfTotal);\n', '        balances[timeVault] = safeAdd(balances[decentBetMultisig], houseTokens);\n', '        Transfer(0, decentBetMultisig, houseTokens);\n', '\n', '        // Bounties: 2% of total goes to Decent bet for bounties\n', '        uint256 bountyTokens = safeDiv(safeMul(totalSupply, bountyPercentOfTotal), crowdfundPercentOfTotal);\n', '        balances[decentBetMultisig] = safeAdd(balances[decentBetMultisig], bountyTokens);\n', '        Transfer(0, decentBetMultisig, bountyTokens);\n', '\n', '        // Transfer ETH to the DBET Multisig address.\n', '        if (!decentBetMultisig.send(this.balance)) throw;\n', '    }\n', '\n', '    // Interface marker\n', '    function isDecentBetCrowdsale() returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function getTime() constant returns (uint256) {\n', '        return now;\n', '    }\n', '\n', '    /// @notice This manages the crowdfunding state machine\n', '    /// We make it a function and do not assign the result to a variable\n', '    /// So there is no chance of the variable being stale\n', '    function getState() public constant returns (State){\n', '        /* Successful if crowdsale was finalized */\n', '        if(finalizedCrowdfunding) return State.Success;\n', '\n', '        /* Pre-sale not started */\n', '        else if (getTime() < preSaleStartTime) return State.Waiting;\n', '\n', '        /* Pre-sale */\n', '        else if (getTime() >= preSaleStartTime &&\n', '        getTime() < fundingStartTime &&\n', '        totalSupply < tokenCreationMax) return State.PreSale;\n', '\n', '        /* Community sale */\n', '        else if (getTime() >= fundingStartTime &&\n', '        getTime() < fundingStartTime + 2 days &&\n', '        totalSupply < tokenCreationMax) return State.CommunitySale;\n', '\n', '        /* Public sale */\n', '        else if (getTime() >= (fundingStartTime + 2 days) &&\n', '        getTime() < fundingEndTime &&\n', '        totalSupply < tokenCreationMax) return State.PublicSale;\n', '\n', '        /* Success */\n', '        else if (getTime() >= fundingEndTime ||\n', '        totalSupply == tokenCreationMax) return State.Success;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.8;\n', '\n', '// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) constant returns (uint);\n', '    function allowance(address owner, address spender) constant returns (uint);\n', '\n', '    function transfer(address to, uint value) returns (bool ok);\n', '    function transferFrom(address from, address to, uint value) returns (bool ok);\n', '    function approve(address spender, uint value) returns (bool ok);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '// accepted from zeppelin-solidity https://github.com/OpenZeppelin/zeppelin-solidity\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function assert(bool assertion) internal {\n', '        if (!assertion) {\n', '            throw;\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\n', '/// @author Stefan George - <stefan.george@consensys.net>\n', 'contract MultiSigWallet {\n', '\n', '    // flag to determine if address is for a real contract or not\n', '    bool public isMultiSigWallet = false;\n', '\n', '    uint constant public MAX_OWNER_COUNT = 50;\n', '\n', '    event Confirmation(address indexed sender, uint indexed transactionId);\n', '    event Revocation(address indexed sender, uint indexed transactionId);\n', '    event Submission(uint indexed transactionId);\n', '    event Execution(uint indexed transactionId);\n', '    event ExecutionFailure(uint indexed transactionId);\n', '    event Deposit(address indexed sender, uint value);\n', '    event OwnerAddition(address indexed owner);\n', '    event OwnerRemoval(address indexed owner);\n', '    event RequirementChange(uint required);\n', '\n', '    mapping (uint => Transaction) public transactions;\n', '    mapping (uint => mapping (address => bool)) public confirmations;\n', '    mapping (address => bool) public isOwner;\n', '    address[] public owners;\n', '    uint public required;\n', '    uint public transactionCount;\n', '\n', '    struct Transaction {\n', '    address destination;\n', '    uint value;\n', '    bytes data;\n', '    bool executed;\n', '    }\n', '\n', '    modifier onlyWallet() {\n', '        if (msg.sender != address(this)) throw;\n', '        _;\n', '    }\n', '\n', '    modifier ownerDoesNotExist(address owner) {\n', '        if (isOwner[owner]) throw;\n', '        _;\n', '    }\n', '\n', '    modifier ownerExists(address owner) {\n', '        if (!isOwner[owner]) throw;\n', '        _;\n', '    }\n', '\n', '    modifier transactionExists(uint transactionId) {\n', '        if (transactions[transactionId].destination == 0) throw;\n', '        _;\n', '    }\n', '\n', '    modifier confirmed(uint transactionId, address owner) {\n', '        if (!confirmations[transactionId][owner]) throw;\n', '        _;\n', '    }\n', '\n', '    modifier notConfirmed(uint transactionId, address owner) {\n', '        if (confirmations[transactionId][owner]) throw;\n', '        _;\n', '    }\n', '\n', '    modifier notExecuted(uint transactionId) {\n', '        if (transactions[transactionId].executed) throw;\n', '        _;\n', '    }\n', '\n', '    modifier notNull(address _address) {\n', '        if (_address == 0) throw;\n', '        _;\n', '    }\n', '\n', '    modifier validRequirement(uint ownerCount, uint _required) {\n', '        if (ownerCount > MAX_OWNER_COUNT) throw;\n', '        if (_required > ownerCount) throw;\n', '        if (_required == 0) throw;\n', '        if (ownerCount == 0) throw;\n', '        _;\n', '    }\n', '\n', '    /// @dev Fallback function allows to deposit ether.\n', '    function()\n', '    payable\n', '    {\n', '        if (msg.value > 0)\n', '        Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '    /// @dev Contract constructor sets initial owners and required number of confirmations.\n', '    /// @param _owners List of initial owners.\n', '    /// @param _required Number of required confirmations.\n', '    function MultiSigWallet(address[] _owners, uint _required)\n', '    public\n', '    validRequirement(_owners.length, _required)\n', '    {\n', '        for (uint i=0; i<_owners.length; i++) {\n', '            if (isOwner[_owners[i]] || _owners[i] == 0) throw;\n', '            isOwner[_owners[i]] = true;\n', '        }\n', '        isMultiSigWallet = true;\n', '        owners = _owners;\n', '        required = _required;\n', '    }\n', '\n', '    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n', '    /// @param owner Address of new owner.\n', '    function addOwner(address owner)\n', '    public\n', '    onlyWallet\n', '    ownerDoesNotExist(owner)\n', '    notNull(owner)\n', '    validRequirement(owners.length + 1, required)\n', '    {\n', '        isOwner[owner] = true;\n', '        owners.push(owner);\n', '        OwnerAddition(owner);\n', '    }\n', '\n', '    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n', '    /// @param owner Address of owner.\n', '    function removeOwner(address owner)\n', '    public\n', '    onlyWallet\n', '    ownerExists(owner)\n', '    {\n', '        isOwner[owner] = false;\n', '        for (uint i=0; i<owners.length - 1; i++)\n', '        if (owners[i] == owner) {\n', '            owners[i] = owners[owners.length - 1];\n', '            break;\n', '        }\n', '        owners.length -= 1;\n', '        if (required > owners.length)\n', '        changeRequirement(owners.length);\n', '        OwnerRemoval(owner);\n', '    }\n', '\n', '    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n', '    /// @param owner Address of owner to be replaced.\n', '    /// @param newOwner Address of new owner.\n', '    /// @param index the indx of the owner to be replaced\n', '    function replaceOwnerIndexed(address owner, address newOwner, uint index)\n', '    public\n', '    onlyWallet\n', '    ownerExists(owner)\n', '    ownerDoesNotExist(newOwner)\n', '    {\n', '        if (owners[index] != owner) throw;\n', '        owners[index] = newOwner;\n', '        isOwner[owner] = false;\n', '        isOwner[newOwner] = true;\n', '        OwnerRemoval(owner);\n', '        OwnerAddition(newOwner);\n', '    }\n', '\n', '\n', '    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n', '    /// @param _required Number of required confirmations.\n', '    function changeRequirement(uint _required)\n', '    public\n', '    onlyWallet\n', '    validRequirement(owners.length, _required)\n', '    {\n', '        required = _required;\n', '        RequirementChange(_required);\n', '    }\n', '\n', '    /// @dev Allows an owner to submit and confirm a transaction.\n', '    /// @param destination Transaction target address.\n', '    /// @param value Transaction ether value.\n', '    /// @param data Transaction data payload.\n', '    /// @return Returns transaction ID.\n', '    function submitTransaction(address destination, uint value, bytes data)\n', '    public\n', '    returns (uint transactionId)\n', '    {\n', '        transactionId = addTransaction(destination, value, data);\n', '        confirmTransaction(transactionId);\n', '    }\n', '\n', '    /// @dev Allows an owner to confirm a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    function confirmTransaction(uint transactionId)\n', '    public\n', '    ownerExists(msg.sender)\n', '    transactionExists(transactionId)\n', '    notConfirmed(transactionId, msg.sender)\n', '    {\n', '        confirmations[transactionId][msg.sender] = true;\n', '        Confirmation(msg.sender, transactionId);\n', '        executeTransaction(transactionId);\n', '    }\n', '\n', '    /// @dev Allows an owner to revoke a confirmation for a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    function revokeConfirmation(uint transactionId)\n', '    public\n', '    ownerExists(msg.sender)\n', '    confirmed(transactionId, msg.sender)\n', '    notExecuted(transactionId)\n', '    {\n', '        confirmations[transactionId][msg.sender] = false;\n', '        Revocation(msg.sender, transactionId);\n', '    }\n', '\n', '    /// @dev Returns the confirmation status of a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    /// @return Confirmation status.\n', '    function isConfirmed(uint transactionId)\n', '    public\n', '    constant\n', '    returns (bool)\n', '    {\n', '        uint count = 0;\n', '        for (uint i=0; i<owners.length; i++) {\n', '            if (confirmations[transactionId][owners[i]])\n', '            count += 1;\n', '            if (count == required)\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Internal functions\n', '     */\n', '\n', '    /// @dev Allows anyone to execute a confirmed transaction.\n', '    /// @param transactionId Transaction ID.\n', '    function executeTransaction(uint transactionId)\n', '    internal\n', '    notExecuted(transactionId)\n', '    {\n', '        if (isConfirmed(transactionId)) {\n', '            Transaction tx = transactions[transactionId];\n', '            tx.executed = true;\n', '            if (tx.destination.call.value(tx.value)(tx.data))\n', '            Execution(transactionId);\n', '            else {\n', '                ExecutionFailure(transactionId);\n', '                tx.executed = false;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n', '    /// @param destination Transaction target address.\n', '    /// @param value Transaction ether value.\n', '    /// @param data Transaction data payload.\n', '    /// @return Returns transaction ID.\n', '    function addTransaction(address destination, uint value, bytes data)\n', '    internal\n', '    notNull(destination)\n', '    returns (uint transactionId)\n', '    {\n', '        transactionId = transactionCount;\n', '        transactions[transactionId] = Transaction({\n', '        destination: destination,\n', '        value: value,\n', '        data: data,\n', '        executed: false\n', '        });\n', '        transactionCount += 1;\n', '        Submission(transactionId);\n', '    }\n', '\n', '    /*\n', '     * Web3 call functions\n', '     */\n', '    /// @dev Returns number of confirmations of a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    /// @return Number of confirmations.\n', '    function getConfirmationCount(uint transactionId)\n', '    public\n', '    constant\n', '    returns (uint count)\n', '    {\n', '        for (uint i=0; i<owners.length; i++)\n', '        if (confirmations[transactionId][owners[i]])\n', '        count += 1;\n', '    }\n', '\n', '    /// @dev Returns total number of transactions after filers are applied.\n', '    /// @param pending Include pending transactions.\n', '    /// @param executed Include executed transactions.\n', '    /// @return Total number of transactions after filters are applied.\n', '    function getTransactionCount(bool pending, bool executed)\n', '    public\n', '    constant\n', '    returns (uint count)\n', '    {\n', '        for (uint i=0; i<transactionCount; i++)\n', '        if ((pending && !transactions[i].executed) ||\n', '        (executed && transactions[i].executed))\n', '        count += 1;\n', '    }\n', '\n', '    /// @dev Returns list of owners.\n', '    /// @return List of owner addresses.\n', '    function getOwners()\n', '    public\n', '    constant\n', '    returns (address[])\n', '    {\n', '        return owners;\n', '    }\n', '\n', '    /// @dev Returns array with owner addresses, which confirmed transaction.\n', '    /// @param transactionId Transaction ID.\n', '    /// @return Returns array of owner addresses.\n', '    function getConfirmations(uint transactionId)\n', '    public\n', '    constant\n', '    returns (address[] _confirmations)\n', '    {\n', '        address[] memory confirmationsTemp = new address[](owners.length);\n', '        uint count = 0;\n', '        uint i;\n', '        for (i=0; i<owners.length; i++)\n', '        if (confirmations[transactionId][owners[i]]) {\n', '            confirmationsTemp[count] = owners[i];\n', '            count += 1;\n', '        }\n', '        _confirmations = new address[](count);\n', '        for (i=0; i<count; i++)\n', '        _confirmations[i] = confirmationsTemp[i];\n', '    }\n', '\n', '    /// @dev Returns list of transaction IDs in defined range.\n', '    /// @param from Index start position of transaction array.\n', '    /// @param to Index end position of transaction array.\n', '    /// @param pending Include pending transactions.\n', '    /// @param executed Include executed transactions.\n', '    /// @return Returns array of transaction IDs.\n', '    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n', '    public\n', '    constant\n', '    returns (uint[] _transactionIds)\n', '    {\n', '        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n', '        uint count = 0;\n', '        uint i;\n', '        for (i=0; i<transactionCount; i++)\n', '        if ((pending && !transactions[i].executed) ||\n', '        (executed && transactions[i].executed))\n', '        {\n', '            transactionIdsTemp[count] = i;\n', '            count += 1;\n', '        }\n', '        _transactionIds = new uint[](to - from);\n', '        for (i=from; i<to; i++)\n', '        _transactionIds[i - from] = transactionIdsTemp[i];\n', '    }\n', '\n', '}\n', '\n', 'contract UpgradeAgent is SafeMath {\n', '    address public owner;\n', '\n', '    bool public isUpgradeAgent;\n', '\n', '    function upgradeFrom(address _from, uint256 _value) public;\n', '\n', '    function finalizeUpgrade() public;\n', '\n', '    function setOriginalSupply() public;\n', '}\n', '\n', '/// @title Time-locked vault of tokens allocated to DecentBet after 365 days\n', 'contract DecentBetVault is SafeMath {\n', '\n', '    // flag to determine if address is for a real contract or not\n', '    bool public isDecentBetVault = false;\n', '\n', '    DecentBetToken decentBetToken;\n', '\n', '    address decentBetMultisig;\n', '\n', '    uint256 unlockedAtTime;\n', '\n', '    // smaller lock for testing\n', '    uint256 public constant timeOffset = 1 years;\n', '\n', '    /// @notice Constructor function sets the DecentBet Multisig address and\n', '    /// total number of locked tokens to transfer\n', '    function DecentBetVault(address _decentBetMultisig) /** internal */ {\n', '        if (_decentBetMultisig == 0x0) throw;\n', '        decentBetToken = DecentBetToken(msg.sender);\n', '        decentBetMultisig = _decentBetMultisig;\n', '        isDecentBetVault = true;\n', '\n', '        // 1 year later\n', '        unlockedAtTime = safeAdd(getTime(), timeOffset);\n', '    }\n', '\n', "    /// @notice Transfer locked tokens to Decent.bet's multisig wallet\n", '    function unlock() external {\n', '        // Wait your turn!\n', '        if (getTime() < unlockedAtTime) throw;\n', '        // Will fail if allocation (and therefore toTransfer) is 0.\n', '        if (!decentBetToken.transfer(decentBetMultisig, decentBetToken.balanceOf(this))) throw;\n', '    }\n', '\n', '    function getTime() internal returns (uint256) {\n', '        return now;\n', '    }\n', '\n', '    // disallow ETH payments to TimeVault\n', '    function() payable {\n', '        throw;\n', '    }\n', '\n', '}\n', '\n', '\n', '/// @title DecentBet crowdsale contract\n', 'contract DecentBetToken is SafeMath, ERC20 {\n', '\n', '    // flag to determine if address is for a real contract or not\n', '    bool public isDecentBetToken = false;\n', '\n', '    // State machine\n', '    enum State{Waiting, PreSale, CommunitySale, PublicSale, Success}\n', '\n', '    // Token information\n', '    string public constant name = "Decent.Bet Token";\n', '\n', '    string public constant symbol = "DBET";\n', '\n', '    uint256 public constant decimals = 18;  // decimal places\n', '\n', '    uint256 public constant housePercentOfTotal = 10;\n', '\n', '    uint256 public constant vaultPercentOfTotal = 18;\n', '\n', '    uint256 public constant bountyPercentOfTotal = 2;\n', '\n', '    uint256 public constant crowdfundPercentOfTotal = 70;\n', '\n', '    uint256 public constant hundredPercent = 100;\n', '\n', '    mapping (address => uint256) balances;\n', '\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    // Authorized addresses\n', '    address public team;\n', '\n', '    // Upgrade information\n', '    bool public finalizedUpgrade = false;\n', '\n', '    address public upgradeMaster;\n', '\n', '    UpgradeAgent public upgradeAgent;\n', '\n', '    uint256 public totalUpgraded;\n', '\n', '    // Crowdsale information\n', '    bool public finalizedCrowdfunding = false;\n', '\n', '    // Whitelisted addresses for pre-sale\n', '    address[] public preSaleWhitelist;\n', '    mapping (address => bool) public preSaleAllowed;\n', '\n', '    // Whitelisted addresses from community\n', '    address[] public communitySaleWhitelist;\n', '    mapping (address => bool) public communitySaleAllowed;\n', '    uint[2] public communitySaleCap = [100000 ether, 200000 ether];\n', '    mapping (address => uint[2]) communitySalePurchases;\n', '\n', '    uint256 public preSaleStartTime; // Pre-sale start block timestamp\n', '    uint256 public fundingStartTime; // crowdsale start block timestamp\n', '    uint256 public fundingEndTime; // crowdsale end block timestamp\n', '    // DBET:ETH exchange rate - Needs to be updated at time of ICO.\n', '    // Price of ETH/0.125. For example: If ETH/USD = 300, it would be 2400 DBETs per ETH.\n', '    uint256 public baseTokensPerEther;\n', '    uint256 public tokenCreationMax = safeMul(250000 ether, 1000); // A maximum of 250M DBETs can be minted during ICO.\n', '\n', '    // Amount of tokens alloted to pre-sale investors.\n', '    uint256 public preSaleAllotment;\n', '    // Address of pre-sale investors.\n', '    address public preSaleAddress;\n', '\n', '    // for testing on testnet\n', '    //uint256 public constant tokenCreationMax = safeMul(10 ether, baseTokensPerEther);\n', '    //uint256 public constant tokenCreationMin = safeMul(3 ether, baseTokensPerEther);\n', '\n', '    address public decentBetMultisig;\n', '\n', "    DecentBetVault public timeVault; // DecentBet's time-locked vault\n", '\n', '    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event UpgradeFinalized(address sender, address upgradeAgent);\n', '\n', '    event UpgradeAgentSet(address agent);\n', '\n', '    // Allow only the team address to continue\n', '    modifier onlyTeam() {\n', '        if(msg.sender != team) throw;\n', '        _;\n', '    }\n', '\n', '    function DecentBetToken(address _decentBetMultisig,\n', '    address _upgradeMaster, address _team,\n', '    uint256 _baseTokensPerEther, uint256 _fundingStartTime,\n', '    uint256 _fundingEndTime) {\n', '\n', '        if (_decentBetMultisig == 0) throw;\n', '        if (_team == 0) throw;\n', '        if (_upgradeMaster == 0) throw;\n', '        if (_baseTokensPerEther == 0) throw;\n', '\n', '        // For testing/dev\n', '        //         if(_fundingStartTime == 0) throw;\n', '        // Crowdsale can only officially start during/after the current block timestamp.\n', '        if (_fundingStartTime < getTime()) throw;\n', '\n', '        if (_fundingEndTime <= _fundingStartTime) throw;\n', '\n', '        isDecentBetToken = true;\n', '\n', '        upgradeMaster = _upgradeMaster;\n', '        team = _team;\n', '\n', '        baseTokensPerEther = _baseTokensPerEther;\n', '\n', '        preSaleStartTime = _fundingStartTime - 1 days;\n', '        fundingStartTime = _fundingStartTime;\n', '        fundingEndTime = _fundingEndTime;\n', '\n', '        // Pre-sale issuance from pre-sale contract\n', '        // 0x7be601aab2f40cc23653965749b84e5cb8cfda43\n', '        preSaleAddress = 0x87f7beeda96216ec2a325e417a45ed262495686b;\n', '        preSaleAllotment = 45000000 ether;\n', '\n', '        balances[preSaleAddress] = preSaleAllotment;\n', '        totalSupply = safeAdd(totalSupply, preSaleAllotment);\n', '\n', '        timeVault = new DecentBetVault(_decentBetMultisig);\n', '        if (!timeVault.isDecentBetVault()) throw;\n', '\n', '        decentBetMultisig = _decentBetMultisig;\n', '        if (!MultiSigWallet(decentBetMultisig).isMultiSigWallet()) throw;\n', '    }\n', '\n', '    function balanceOf(address who) constant returns (uint) {\n', '        return balances[who];\n', '    }\n', '\n', "    /// @notice Transfer `value` DBET tokens from sender's account\n", '    /// `msg.sender` to provided account address `to`.\n', '    /// @notice This function is disabled during the funding.\n', '    /// @dev Required state: Success\n', '    /// @param to The address of the recipient\n', '    /// @param value The number of DBETs to transfer\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address to, uint256 value) returns (bool ok) {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if crowdfunding was not a success.\n', '        uint256 senderBalance = balances[msg.sender];\n', '        if (senderBalance >= value && value > 0) {\n', '            senderBalance = safeSub(senderBalance, value);\n', '            balances[msg.sender] = senderBalance;\n', '            balances[to] = safeAdd(balances[to], value);\n', '            Transfer(msg.sender, to, value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', "    /// @notice Transfer `value` DBET tokens from sender 'from'\n", '    /// to provided account address `to`.\n', '    /// @notice This function is disabled during the funding.\n', '    /// @dev Required state: Success\n', '    /// @param from The address of the sender\n', '    /// @param to The address of the recipient\n', '    /// @param value The number of DBETs to transfer\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address from, address to, uint256 value) returns (bool ok) {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if not in Success state.\n', '        // protect against wrapping uints\n', '        if (balances[from] >= value &&\n', '        allowed[from][msg.sender] >= value &&\n', '        safeAdd(balances[to], value) > balances[to])\n', '        {\n', '            balances[to] = safeAdd(balances[to], value);\n', '            balances[from] = safeSub(balances[from], value);\n', '            allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], value);\n', '            Transfer(from, to, value);\n', '            return true;\n', '        }\n', '        else {return false;}\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `spender` to spend `value` tokens\n', '    /// @param spender The address of the account able to transfer the tokens\n', '    /// @param value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address spender, uint256 value) returns (bool ok) {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if not in Success state.\n', '        allowed[msg.sender][spender] = value;\n', '        Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /// @param owner The address of the account owning tokens\n', '    /// @param spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address owner, address spender) constant returns (uint) {\n', '        return allowed[owner][spender];\n', '    }\n', '\n', '    // Token upgrade functionality\n', '\n', '    /// @notice Upgrade tokens to the new token contract.\n', '    /// @dev Required state: Success\n', '    /// @param value The number of tokens to upgrade\n', '    function upgrade(uint256 value) external {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if not in Success state.\n', '        if (upgradeAgent.owner() == 0x0) throw;\n', '        // need a real upgradeAgent address\n', '        if (finalizedUpgrade) throw;\n', '        // cannot upgrade if finalized\n', '\n', '        // Validate input value.\n', '        if (value == 0) throw;\n', '        if (value > balances[msg.sender]) throw;\n', '\n', '        // update the balances here first before calling out (reentrancy)\n', '        balances[msg.sender] = safeSub(balances[msg.sender], value);\n', '        totalSupply = safeSub(totalSupply, value);\n', '        totalUpgraded = safeAdd(totalUpgraded, value);\n', '        upgradeAgent.upgradeFrom(msg.sender, value);\n', '        Upgrade(msg.sender, upgradeAgent, value);\n', '    }\n', '\n', '    /// @notice Set address of upgrade target contract and enable upgrade\n', '    /// process.\n', '    /// @dev Required state: Success\n', '    /// @param agent The address of the UpgradeAgent contract\n', '    function setUpgradeAgent(address agent) external {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if not in Success state.\n', '        if (agent == 0x0) throw;\n', "        // don't set agent to nothing\n", '        if (msg.sender != upgradeMaster) throw;\n', '        // Only a master can designate the next agent\n', '        upgradeAgent = UpgradeAgent(agent);\n', '        if (!upgradeAgent.isUpgradeAgent()) throw;\n', '        // this needs to be called in success condition to guarantee the invariant is true\n', '        upgradeAgent.setOriginalSupply();\n', '        UpgradeAgentSet(upgradeAgent);\n', '    }\n', '\n', '    /// @notice Set address of upgrade target contract and enable upgrade\n', '    /// process.\n', '    /// @dev Required state: Success\n', '    /// @param master The address that will manage upgrades, not the upgradeAgent contract address\n', '    function setUpgradeMaster(address master) external {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if not in Success state.\n', '        if (master == 0x0) throw;\n', '        if (msg.sender != upgradeMaster) throw;\n', '        // Only a master can designate the next master\n', '        upgradeMaster = master;\n', '    }\n', '\n', '    /// @notice finalize the upgrade\n', '    /// @dev Required state: Success\n', '    function finalizeUpgrade() external {\n', '        if (getState() != State.Success) throw;\n', '        // Abort if not in Success state.\n', '        if (upgradeAgent.owner() == 0x0) throw;\n', '        // we need a valid upgrade agent\n', '        if (msg.sender != upgradeMaster) throw;\n', '        // only upgradeMaster can finalize\n', '        if (finalizedUpgrade) throw;\n', "        // can't finalize twice\n", '\n', '        finalizedUpgrade = true;\n', '        // prevent future upgrades\n', '\n', '        upgradeAgent.finalizeUpgrade();\n', '        // call finalize upgrade on new contract\n', '        UpgradeFinalized(msg.sender, upgradeAgent);\n', '    }\n', '\n', '    // Allow users to purchase by sending Ether to the contract\n', '    function() payable {\n', '        invest();\n', '    }\n', '\n', '    // Updates tokens per ETH rates before the pre-sale\n', '    function updateBaseTokensPerEther(uint _baseTokensPerEther) onlyTeam {\n', '        if(getState() != State.Waiting) throw;\n', '\n', '        baseTokensPerEther = _baseTokensPerEther;\n', '    }\n', '\n', '    // Returns the current rate after adding bonuses for the time period\n', '    function getTokensAtCurrentRate(uint weiValue) constant returns (uint) {\n', '        /* Pre-sale */\n', '        if(getTime() >= preSaleStartTime && getTime() < fundingStartTime) {\n', '            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 120)), 100); // 20% bonus\n', '        }\n', '\n', '        /* Community sale */\n', '        else if(getTime() >= fundingStartTime && getTime() < fundingStartTime + 1 days) {\n', '            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 120)), 100); // 20% bonus\n', '        } else if(getTime() >= (fundingStartTime + 1 days) && getTime() < fundingStartTime + 2 days) {\n', '            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 120)), 100); // 20% bonus\n', '        }\n', '\n', '        /* Public sale */\n', '        else if(getTime() >= (fundingStartTime + 2 days) && getTime() < fundingStartTime + 1 weeks) {\n', '            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 110)), 100); // 10% bonus\n', '        } else if(getTime() >= fundingStartTime + 1 weeks && getTime() < fundingStartTime + 2 weeks) {\n', '            return safeDiv(safeMul(weiValue, safeMul(baseTokensPerEther, 105)), 100); // 5% bonus\n', '        } else if(getTime() >= fundingStartTime + 2 weeks && getTime() < fundingEndTime) {\n', '            return safeMul(weiValue, baseTokensPerEther); // 0% bonus\n', '        }\n', '    }\n', '\n', '    // Allows the owner to add an address to the pre-sale whitelist.\n', '    function addToPreSaleWhitelist(address _address) onlyTeam {\n', '\n', '        // Add to pre-sale whitelist only if state is Waiting right now.\n', '        if(getState() != State.Waiting) throw;\n', '\n', '        // Address already added to whitelist.\n', '        if (preSaleAllowed[_address]) throw;\n', '\n', '        preSaleWhitelist.push(_address);\n', '        preSaleAllowed[_address] = true;\n', '    }\n', '\n', '    // Allows the owner to add an address to the community whitelist.\n', '    function addToCommunitySaleWhitelist(address[] addresses) onlyTeam {\n', '\n', '        // Add to community sale whitelist only if state is Waiting or Presale right now.\n', '        if(getState() != State.Waiting &&\n', '        getState() != State.PreSale) throw;\n', '\n', '        for(uint i = 0; i < addresses.length; i++) {\n', '            if(!communitySaleAllowed[addresses[i]]) {\n', '                communitySaleWhitelist.push(addresses[i]);\n', '                communitySaleAllowed[addresses[i]] = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Create tokens when funding is active.\n', '    /// @dev Required state: Funding\n', '    /// @dev State transition: -> Funding Success (only if cap reached)\n', '    function invest() payable {\n', '\n', '        // Abort if not in PreSale, CommunitySale or PublicSale state.\n', '        if (getState() != State.PreSale &&\n', '        getState() != State.CommunitySale &&\n', '        getState() != State.PublicSale) throw;\n', '\n', "        // User hasn't been whitelisted for pre-sale.\n", '        if(getState() == State.PreSale && !preSaleAllowed[msg.sender]) throw;\n', '\n', "        // User hasn't been whitelisted for community sale.\n", '        if(getState() == State.CommunitySale && !communitySaleAllowed[msg.sender]) throw;\n', '\n', '        // Do not allow creating 0 tokens.\n', '        if (msg.value == 0) throw;\n', '\n', '        // multiply by exchange rate to get newly created token amount\n', '        uint256 createdTokens = getTokensAtCurrentRate(msg.value);\n', '\n', '        allocateTokens(msg.sender, createdTokens);\n', '    }\n', '\n', "    // Allocates tokens to an investors' address\n", '    function allocateTokens(address _address, uint amount) internal {\n', '\n', '        // we are creating tokens, so increase the totalSupply.\n', '        totalSupply = safeAdd(totalSupply, amount);\n', '\n', "        // don't go over the limit!\n", '        if (totalSupply > tokenCreationMax) throw;\n', '\n', "        // Don't allow community whitelisted addresses to purchase more than their cap.\n", '        if(getState() == State.CommunitySale) {\n', '            // Community sale day 1.\n', '            // Whitelisted addresses can purchase a maximum of 100k DBETs (10k USD).\n', '            if(getTime() >= fundingStartTime &&\n', '            getTime() < fundingStartTime + 1 days) {\n', '                if(safeAdd(communitySalePurchases[msg.sender][0], amount) > communitySaleCap[0])\n', '                throw;\n', '                else\n', '                communitySalePurchases[msg.sender][0] =\n', '                safeAdd(communitySalePurchases[msg.sender][0], amount);\n', '            }\n', '\n', '            // Community sale day 2.\n', '            // Whitelisted addresses can purchase a maximum of 200k DBETs (20k USD).\n', '            else if(getTime() >= (fundingStartTime + 1 days) &&\n', '            getTime() < fundingStartTime + 2 days) {\n', '                if(safeAdd(communitySalePurchases[msg.sender][1], amount) > communitySaleCap[1])\n', '                throw;\n', '                else\n', '                communitySalePurchases[msg.sender][1] =\n', '                safeAdd(communitySalePurchases[msg.sender][1], amount);\n', '            }\n', '        }\n', '\n', '        // Assign new tokens to the sender.\n', '        balances[_address] = safeAdd(balances[_address], amount);\n', '\n', '        // Log token creation event\n', '        Transfer(0, _address, amount);\n', '    }\n', '\n', '    /// @notice Finalize crowdfunding\n', '    /// @dev If cap was reached or crowdfunding has ended then:\n', '    /// create DBET for the DecentBet Multisig and team,\n', '    /// transfer ETH to the DecentBet Multisig address.\n', '    /// @dev Required state: Success\n', '    function finalizeCrowdfunding() external {\n', '        // Abort if not in Funding Success state.\n', '        if (getState() != State.Success) throw;\n', "        // don't finalize unless we won\n", '        if (finalizedCrowdfunding) throw;\n', "        // can't finalize twice (so sneaky!)\n", '\n', '        // prevent more creation of tokens\n', '        finalizedCrowdfunding = true;\n', '\n', "        // Founder's supply : 18% of total goes to vault, time locked for 6 months\n", '        uint256 vaultTokens = safeDiv(safeMul(totalSupply, vaultPercentOfTotal), crowdfundPercentOfTotal);\n', '        balances[timeVault] = safeAdd(balances[timeVault], vaultTokens);\n', '        Transfer(0, timeVault, vaultTokens);\n', '\n', '        // House: 10% of total goes to Decent.bet for initial house setup\n', '        uint256 houseTokens = safeDiv(safeMul(totalSupply, housePercentOfTotal), crowdfundPercentOfTotal);\n', '        balances[timeVault] = safeAdd(balances[decentBetMultisig], houseTokens);\n', '        Transfer(0, decentBetMultisig, houseTokens);\n', '\n', '        // Bounties: 2% of total goes to Decent bet for bounties\n', '        uint256 bountyTokens = safeDiv(safeMul(totalSupply, bountyPercentOfTotal), crowdfundPercentOfTotal);\n', '        balances[decentBetMultisig] = safeAdd(balances[decentBetMultisig], bountyTokens);\n', '        Transfer(0, decentBetMultisig, bountyTokens);\n', '\n', '        // Transfer ETH to the DBET Multisig address.\n', '        if (!decentBetMultisig.send(this.balance)) throw;\n', '    }\n', '\n', '    // Interface marker\n', '    function isDecentBetCrowdsale() returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function getTime() constant returns (uint256) {\n', '        return now;\n', '    }\n', '\n', '    /// @notice This manages the crowdfunding state machine\n', '    /// We make it a function and do not assign the result to a variable\n', '    /// So there is no chance of the variable being stale\n', '    function getState() public constant returns (State){\n', '        /* Successful if crowdsale was finalized */\n', '        if(finalizedCrowdfunding) return State.Success;\n', '\n', '        /* Pre-sale not started */\n', '        else if (getTime() < preSaleStartTime) return State.Waiting;\n', '\n', '        /* Pre-sale */\n', '        else if (getTime() >= preSaleStartTime &&\n', '        getTime() < fundingStartTime &&\n', '        totalSupply < tokenCreationMax) return State.PreSale;\n', '\n', '        /* Community sale */\n', '        else if (getTime() >= fundingStartTime &&\n', '        getTime() < fundingStartTime + 2 days &&\n', '        totalSupply < tokenCreationMax) return State.CommunitySale;\n', '\n', '        /* Public sale */\n', '        else if (getTime() >= (fundingStartTime + 2 days) &&\n', '        getTime() < fundingEndTime &&\n', '        totalSupply < tokenCreationMax) return State.PublicSale;\n', '\n', '        /* Success */\n', '        else if (getTime() >= fundingEndTime ||\n', '        totalSupply == tokenCreationMax) return State.Success;\n', '    }\n', '\n', '}']
