['pragma solidity ^0.4.11;\n', '\n', '/// @title STABLE Project ICO\n', '/// @author Konrad Szałapak <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d9b2b6b7abb8bdf7aaa3b8b5b8a9b8b299beb4b8b0b5f7bab6b4">[email&#160;protected]</a>>\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender != owner) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '}\n', '  \n', '/* New ERC23 contract interface */\n', 'contract ERC223 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) constant returns (uint);\n', '  \n', '    function name() constant returns (string _name);\n', '    function symbol() constant returns (string _symbol);\n', '    function decimals() constant returns (uint8 _decimals);\n', '    function totalSupply() constant returns (uint256 _supply);\n', '\n', '    function transfer(address to, uint value) returns (bool ok);\n', '    function transfer(address to, uint value, bytes data) returns (bool ok);\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '}\n', '\n', '/*\n', '* Contract that is working with ERC223 tokens\n', '*/\n', 'contract ContractReceiver {\n', '    function tokenFallback(address _from, uint _value, bytes _data);\n', '}\n', '\n', '/**\n', '* ERC23 token by Dexaran\n', '*\n', '* https://github.com/Dexaran/ERC23-tokens\n', '*/\n', ' \n', ' \n', '/* https://github.com/LykkeCity/EthereumApiDotNetCore/blob/master/src/ContractBuilder/contracts/token/SafeMath.sol */\n', 'contract SafeMath {\n', '    uint256 constant public MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x > MAX_UINT256 - y) throw;\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x < y) throw;\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) return 0;\n', '        if (x > MAX_UINT256 / y) throw;\n', '        return x * y;\n', '    }\n', '}\n', '\n', '/**\n', '* Stable Awareness Token - STA\n', '*/\n', 'contract ERC223Token_STA is ERC223, SafeMath, Ownable {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    mapping(address => uint) balances;\n', '    \n', '    // stable:\n', '    uint256 public icoEndBlock;                              // last block number of ICO \n', '    uint256 public maxSupply;                                // maximum token supply\n', '    uint256 public minedTokenCount;                          // counter of mined tokens\n', '    address public icoAddress;                               // address of ICO contract    \n', '    uint256 private multiplier;                              // for managing token fractionals\n', '    struct Miner {                                           // struct for mined tokens data\n', '        uint256 block;\n', '        address minerAddress;\n', '    }\n', '    mapping (uint256 => Miner) public minedTokens;           // mined tokens data\n', '    event MessageClaimMiningReward(address indexed miner, uint256 block, uint256 sta);  // notifies clients about sta winning miner\n', '    event Burn(address indexed from, uint256 value);         // notifies clients about the amount burnt\n', '    \n', '    function ERC223Token_STA() {\n', '        decimals = 8;\n', '        multiplier = 10**uint256(decimals);\n', '        maxSupply = 10000000000;                             // Maximum possible supply == 100 STA\n', '        name = "STABLE STA Token";                           // Set the name for display purposes\n', '        symbol = "STA";                                      // Set the symbol for display purposes\n', '        icoEndBlock = 4230150;  // INIT                      // last block number for ICO\n', '        totalSupply = 0;                                     // Update total supply\n', '        // balances[msg.sender] = totalSupply;               // Give the creator all initial tokens\n', '    }\n', ' \n', '    // trigger rewarding a miner with STA token:\n', '    function claimMiningReward() {  \n', '        if (icoAddress == address(0)) throw;                         // ICO address must be set up first\n', '        if (msg.sender != icoAddress && msg.sender != owner) throw;  // triggering enabled only for ICO or owner\n', '        if (block.number > icoEndBlock) throw;                       // rewarding enabled only before the end of ICO\n', '        if (minedTokenCount * multiplier >= maxSupply) throw; \n', '        if (minedTokenCount > 0) {\n', '            for (uint256 i = 0; i < minedTokenCount; i++) {\n', '                if (minedTokens[i].block == block.number) throw; \n', '            }\n', '        }\n', '        totalSupply += 1 * multiplier;\n', '        balances[block.coinbase] += 1 * multiplier;                  // reward miner with one STA token\n', '        minedTokens[minedTokenCount] = Miner(block.number, block.coinbase);\n', '        minedTokenCount += 1;\n', '        MessageClaimMiningReward(block.coinbase, block.number, 1 * multiplier);\n', '    } \n', '    \n', '    function selfDestroy() onlyOwner {\n', '        if (block.number <= icoEndBlock+14*3456) throw;           // allow to suicide STA token after around 2 weeks (25s/block) from the end of ICO\n', '        suicide(this); \n', '    }\n', '    // /stable\n', '   \n', '    // Function to access name of token .\n', '    function name() constant returns (string _name) {\n', '        return name;\n', '    }\n', '    // Function to access symbol of token .\n', '    function symbol() constant returns (string _symbol) {\n', '        return symbol;\n', '    }\n', '    // Function to access decimals of token .\n', '    function decimals() constant returns (uint8 _decimals) {\n', '        return decimals;\n', '    }\n', '    // Function to access total supply of tokens .\n', '    function totalSupply() constant returns (uint256 _totalSupply) {\n', '        return totalSupply;\n', '    }\n', '    function minedTokenCount() constant returns (uint256 _minedTokenCount) {\n', '        return minedTokenCount;\n', '    }\n', '    function icoAddress() constant returns (address _icoAddress) {\n', '        return icoAddress;\n', '    }\n', '\n', '    // Function that is called when a user or another contract wants to transfer funds .\n', '    function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, _data);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '  \n', '    // Standard function transfer similar to ERC20 transfer with no _data .\n', '    // Added due to backwards compatibility reasons .\n', '    function transfer(address _to, uint _value) returns (bool success) {\n', '        bytes memory empty;\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, empty);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, empty);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) private returns (bool is_contract) {\n', '        uint length;\n', '        _addr = _addr;  // workaround for Mist&#39;s inability to compile\n', '        is_contract = is_contract;  // workaround for Mist&#39;s inability to compile\n', '        assembly {\n', '                //retrieve the size of the code on target address, this needs assembly\n', '                length := extcodesize(_addr)\n', '        }\n', '        if(length>0) {\n', '            return true;\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    //function that is called when transaction target is an address\n', '    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) throw;\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '  \n', '    //function that is called when transaction target is a contract\n', '    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) throw;\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\t\n', '    function burn(address _address, uint256 _value) returns (bool success) {\n', '        if (icoAddress == address(0)) throw;\n', '        if (msg.sender != owner && msg.sender != icoAddress) throw; // only owner and ico contract are allowed\n', '        if (balances[_address] < _value) throw;                     // Check if the sender has enough tokens\n', '        balances[_address] -= _value;                               // Subtract from the sender\n', '        totalSupply -= _value;                               \n', '        Burn(_address, _value);\n', '        return true;\n', '    }\n', '\t\n', '    /* setting ICO address for allowing execution from the ICO contract */\n', '    function setIcoAddress(address _address) onlyOwner {\n', '        if (icoAddress == address(0)) {\n', '            icoAddress = _address;\n', '        }    \n', '        else throw;\n', '    }\n', '}\n', '\n', '/**\n', '* Stable Token - STB\n', '*/\n', 'contract ERC223Token_STB is ERC223, SafeMath, Ownable {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    mapping(address => uint) balances;\n', '    \n', '    // stable:\n', '    uint256 public maxSupply;\n', '    uint256 public icoEndBlock;\n', '    address public icoAddress;\n', '\t\n', '    function ERC223Token_STB() {\n', '        totalSupply = 0;                                     // Update total supply\n', '        maxSupply = 1000000000000;                           // Maximum possible supply of STB == 100M STB\n', '        name = "STABLE STB Token";                           // Set the name for display purposes\n', '        decimals = 4;                                        // Amount of decimals for display purposes\n', '        symbol = "STB";                                      // Set the symbol for display purposes\n', '        icoEndBlock = 4230150;  // INIT                      // last block number of ICO  // INIT PARAM             \n', '        //balances[msg.sender] = totalSupply;                // Give the creator all initial tokens       \n', '    }\n', '    \n', '    // Function to access max supply of tokens .\n', '    function maxSupply() constant returns (uint256 _maxSupply) {\n', '        return maxSupply;\n', '    }\n', '    // /stable\n', '  \n', '    // Function to access name of token .\n', '    function name() constant returns (string _name) {\n', '        return name;\n', '    }\n', '    // Function to access symbol of token .\n', '    function symbol() constant returns (string _symbol) {\n', '        return symbol;\n', '    }\n', '    // Function to access decimals of token .\n', '    function decimals() constant returns (uint8 _decimals) {\n', '        return decimals;\n', '    }\n', '    // Function to access total supply of tokens .\n', '    function totalSupply() constant returns (uint256 _totalSupply) {\n', '        return totalSupply;\n', '    }\n', '    function icoAddress() constant returns (address _icoAddress) {\n', '        return icoAddress;\n', '    }\n', '\n', '    // Function that is called when a user or another contract wants to transfer funds .\n', '    function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, _data);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '  \n', '    // Standard function transfer similar to ERC20 transfer with no _data .\n', '    // Added due to backwards compatibility reasons .\n', '    function transfer(address _to, uint _value) returns (bool success) {\n', '        bytes memory empty;\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, empty);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, empty);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) private returns (bool is_contract) {\n', '        uint length;\n', '        _addr = _addr;  // workaround for Mist&#39;s inability to compile\n', '        is_contract = is_contract;  // workaround for Mist&#39;s inability to compile\n', '        assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '        }\n', '        if(length>0) {\n', '            return true;\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    //function that is called when transaction target is an address\n', '    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) throw;\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '  \n', '    //function that is called when transaction target is a contract\n', '    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) throw;\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /* setting ICO address for allowing execution from the ICO contract */\n', '    function setIcoAddress(address _address) onlyOwner {\n', '        if (icoAddress == address(0)) {\n', '            icoAddress = _address;\n', '        }    \n', '        else throw;\n', '    }\n', '\n', '    /* mint new tokens */\n', '    function mint(address _receiver, uint256 _amount) {\n', '        if (icoAddress == address(0)) throw;\n', '        if (msg.sender != icoAddress && msg.sender != owner) throw;     // mint allowed only for ICO contract and owner\n', '        // if (block.number <= icoEndBlock) throw;                      // mint allowed only after ICO\n', '        if (safeAdd(totalSupply, _amount) > maxSupply) throw;\n', '        totalSupply = safeAdd(totalSupply, _amount); \n', '        balances[_receiver] = safeAdd(balances[_receiver], _amount);\n', '        Transfer(0, _receiver, _amount, new bytes(0)); \n', '    }\n', '    \n', '    function selfDestroy() onlyOwner { // TEST ONLY\n', '        suicide(this); \n', '    }\n', '}\n', '\n', '/* main contract - ICO */\n', 'contract StableICO is Ownable, SafeMath {\n', '    uint256 public crowdfundingTarget;         // ICO target, in wei\n', '    ERC223Token_STA public sta;                // address of STA token\n', '    ERC223Token_STB public stb;                // address of STB token\n', '    address public beneficiary;                // where the donation is transferred after successful ICO\n', '    uint256 public icoStartBlock;              // number of start block of ICO\n', '    uint256 public icoEndBlock;                // number of end block of ICO\n', '    bool public isIcoFinished;                 // boolean for ICO status - is ICO finished?\n', '    bool public isIcoSucceeded;                // boolean for ICO status - is crowdfunding target reached?\n', '    bool public isDonatedEthTransferred;       // boolean for ICO status - is donation transferred to the secure account?\n', '    bool public isStbMintedForStaEx;           // boolean for ICO status - is extra STB tokens minted for covering exchange of STA token?\n', '    uint256 public receivedStaAmount;          // amount of received STA tokens from rewarded miners\n', '    uint256 public totalFunded;                // amount of ETH donations\n', '    uint256 public ownersEth;                  // amount of ETH transferred to ICO contract by the owner\n', '    uint256 public oneStaIsStb;                // one STA value in STB\n', '    \n', '    struct Donor {                                                      // struct for ETH donations\n', '        address donorAddress;\n', '        uint256 ethAmount;\n', '        uint256 block;\n', '        bool exchangedOrRefunded;\n', '        uint256 stbAmount;\n', '    }\n', '    mapping (uint256 => Donor) public donations;                        // storage for ETH donations\n', '    uint256 public donationNum;                                         // counter of ETH donations\n', '\t\n', '    struct Miner {                                                      // struct for received STA tokens\n', '        address minerAddress;\n', '        uint256 staAmount;\n', '        uint256 block;\n', '        bool exchanged;\n', '        uint256 stbAmount;\n', '    }\n', '    mapping (uint256 => Miner) public receivedSta;                      // storage for received STA tokens\n', '    uint256 public minerNum;                                            // counter of STA receives\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value); \n', '    \n', '    event MessageExchangeEthStb(address from, uint256 eth, uint256 stb);\n', '    event MessageExchangeStaStb(address from, uint256 sta, uint256 stb);\n', '    event MessageReceiveEth(address from, uint256 eth, uint256 block);\n', '    event MessageReceiveSta(address from, uint256 sta, uint256 block);\n', '    event MessageReceiveStb(address from, uint256 stb, uint256 block, bytes data);  // it should never happen\n', '    event MessageRefundEth(address donor_address, uint256 eth);\n', '  \n', '    /* constructor */\n', '    function StableICO() {\n', '        crowdfundingTarget = 200000000000000000; // INIT (test: 0.2 ETH)\n', '        sta = ERC223Token_STA(0xe1e8f9bd535384a345c2a7a29a15df8fc345ad9c);  // INIT\n', '        stb = ERC223Token_STB(0x1e46a3f0552c5acf8ced4fe21a789b412f0e792a);  // INIT\n', '        beneficiary = 0x29ef9329bc15b7c11d047217618186b52bb4c8ff;  // INIT\n', '        icoStartBlock = 4230000;  // INIT\n', '        icoEndBlock = 4230150;  // INIT\n', '    }\t\t\n', '    \n', '    /* trigger rewarding the miner with STA token */\n', '    function claimMiningReward() public onlyOwner {\n', '        sta.claimMiningReward();\n', '    }\n', '\t\n', '    /* Receiving STA from miners - during and after ICO */\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) {\n', '        if (block.number < icoStartBlock) throw;\n', '        if (msg.sender == address(sta)) {\n', '            if (_value < 50000000) throw; // minimum 0.5 STA\n', '            if (block.number < icoEndBlock+14*3456) {  // allow STA tokens exchange for around 14 days (25s/block) after ICO\n', '                receivedSta[minerNum] = Miner(_from, _value, block.number, false, 0);\n', '                minerNum += 1;\n', '                receivedStaAmount = safeAdd(receivedStaAmount, _value);\n', '                MessageReceiveSta(_from, _value, block.number);\n', '            } else throw;\t\n', '        } else if(msg.sender == address(stb)) {\n', '            MessageReceiveStb(_from, _value, block.number, _data);\n', '        } else {\n', '            throw; // other tokens\n', '        }\n', '    }\n', '\n', '    /* Receiving ETH */\n', '    function () payable {\n', '\n', '        if (msg.value < 10000000000000000) throw;  // minimum 0.1 ETH  TEST: 0.01ETH\n', '\t\t\n', '        // before ICO (pre-ico)\n', '        if (block.number < icoStartBlock) {\n', '            if (msg.sender == owner) {\n', '                ownersEth = safeAdd(ownersEth, msg.value);\n', '            } else {\n', '                totalFunded = safeAdd(totalFunded, msg.value);\n', '                donations[donationNum] = Donor(msg.sender, msg.value, block.number, false, 0);\n', '                donationNum += 1;\n', '                MessageReceiveEth(msg.sender, msg.value, block.number);\n', '            }    \n', '        } \n', '        // during ICO\n', '        else if (block.number >= icoStartBlock && block.number <= icoEndBlock) {\n', '            if (msg.sender != owner) {\n', '                totalFunded = safeAdd(totalFunded, msg.value);\n', '                donations[donationNum] = Donor(msg.sender, msg.value, block.number, false, 0);\n', '                donationNum += 1;\n', '                MessageReceiveEth(msg.sender, msg.value, block.number);\n', '            } else ownersEth = safeAdd(ownersEth, msg.value);\n', '        }\n', '        // after ICO - first ETH transfer is returned to the sender\n', '        else if (block.number > icoEndBlock) {\n', '            if (!isIcoFinished) {\n', '                isIcoFinished = true;\n', '                msg.sender.transfer(msg.value);  // return ETH to the sender\n', '                if (totalFunded >= crowdfundingTarget) {\n', '                    isIcoSucceeded = true;\n', '                    exchangeStaStb(0, minerNum);\n', '                    exchangeEthStb(0, donationNum);\n', '                    drawdown();\n', '                } else {\n', '                    refund(0, donationNum);\n', '                }\t\n', '            } else {\n', '                if (msg.sender != owner) throw;  // WARNING: senders ETH may be lost (if transferred after finished ICO)\n', '                ownersEth = safeAdd(ownersEth, msg.value);\n', '            }    \n', '        } else {\n', '            throw;  // WARNING: senders ETH may be lost (if transferred after finished ICO)\n', '        }\n', '    }\n', '\n', '    /* send STB to the miners who returned STA tokens - after successful ICO */\n', '    function exchangeStaStb(uint256 _from, uint256 _to) private {  \n', '        if (!isIcoSucceeded) throw;\n', '        if (_from >= _to) return;  // skip the function if there is invalid range given for loop\n', '        uint256 _sta2stb = 10**4; \n', '        uint256 _wei2stb = 10**14; \n', '\n', '        if (!isStbMintedForStaEx) {\n', '            uint256 _mintAmount = (10*totalFunded)*5/1000 / _wei2stb;  // 0.5% extra STB minting for STA covering\n', '            oneStaIsStb = _mintAmount / 100;\n', '            stb.mint(address(this), _mintAmount);\n', '            isStbMintedForStaEx = true;\n', '        }\t\n', '\t\t\t\n', '        /* exchange */\n', '        uint256 _toBurn = 0;\n', '        for (uint256 i = _from; i < _to; i++) {\n', '            if (receivedSta[i].exchanged) continue;  // skip already exchanged STA\n', '            stb.transfer(receivedSta[i].minerAddress, receivedSta[i].staAmount/_sta2stb * oneStaIsStb / 10**4);\n', '            receivedSta[i].exchanged = true;\n', '            receivedSta[i].stbAmount = receivedSta[i].staAmount/_sta2stb * oneStaIsStb / 10**4;\n', '            _toBurn += receivedSta[i].staAmount;\n', '            MessageExchangeStaStb(receivedSta[i].minerAddress, receivedSta[i].staAmount, \n', '              receivedSta[i].staAmount/_sta2stb * oneStaIsStb / 10**4);\n', '        }\n', '        sta.burn(address(this), _toBurn);  // burn received and processed STA tokens\n', '    }\n', '\t\n', '    /* send STB to the donors - after successful ICO */\n', '    function exchangeEthStb(uint256 _from, uint256 _to) private { \n', '        if (!isIcoSucceeded) throw;\n', '        if (_from >= _to) return;  // skip the function if there is invalid range given for loop\n', '        uint256 _wei2stb = 10**14; // calculate eth to stb exchange\n', '        uint _pb = (icoEndBlock - icoStartBlock)/4; \n', '        uint _bonus;\n', '\n', '        /* mint */\n', '        uint256 _mintAmount = 0;\n', '        for (uint256 i = _from; i < _to; i++) {\n', '            if (donations[i].exchangedOrRefunded) continue;  // skip already minted STB\n', '            if (donations[i].block < icoStartBlock + _pb) _bonus = 6;  // first period; bonus in %\n', '            else if (donations[i].block >= icoStartBlock + _pb && donations[i].block < icoStartBlock + 2*_pb) _bonus = 4;  // 2nd\n', '            else if (donations[i].block >= icoStartBlock + 2*_pb && donations[i].block < icoStartBlock + 3*_pb) _bonus = 2;  // 3rd\n', '            else _bonus = 0;  // 4th\n', '            _mintAmount += 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100);\n', '        }\n', '        stb.mint(address(this), _mintAmount);\n', '\n', '        /* exchange */\n', '        for (i = _from; i < _to; i++) {\n', '            if (donations[i].exchangedOrRefunded) continue;  // skip already exchanged ETH\n', '            if (donations[i].block < icoStartBlock + _pb) _bonus = 6;  // first period; bonus in %\n', '            else if (donations[i].block >= icoStartBlock + _pb && donations[i].block < icoStartBlock + 2*_pb) _bonus = 4;  // 2nd\n', '            else if (donations[i].block >= icoStartBlock + 2*_pb && donations[i].block < icoStartBlock + 3*_pb) _bonus = 2;  // 3rd\n', '            else _bonus = 0;  // 4th\n', '            stb.transfer(donations[i].donorAddress, 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100) );\n', '            donations[i].exchangedOrRefunded = true;\n', '            donations[i].stbAmount = 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100);\n', '            MessageExchangeEthStb(donations[i].donorAddress, donations[i].ethAmount, \n', '              10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100));\n', '        }\n', '    }\n', '  \n', '    // send funds to the ICO beneficiary account - after successful ICO\n', '    function drawdown() private {\n', '        if (!isIcoSucceeded || isDonatedEthTransferred) throw;\n', '        beneficiary.transfer(totalFunded);  \n', '        isDonatedEthTransferred = true;\n', '    }\n', '  \n', '    /* refund ETH - after unsuccessful ICO */\n', '    function refund(uint256 _from, uint256 _to) private {\n', '        if (!isIcoFinished || isIcoSucceeded) throw;\n', '        if (_from >= _to) return;\n', '        for (uint256 i = _from; i < _to; i++) {\n', '            if (donations[i].exchangedOrRefunded) continue;\n', '            donations[i].donorAddress.transfer(donations[i].ethAmount);\n', '            donations[i].exchangedOrRefunded = true;\n', '            MessageRefundEth(donations[i].donorAddress, donations[i].ethAmount);\n', '        }\n', '    }\n', '    \n', '    // send owner&#39;s funds to the ICO owner - after ICO\n', '    function transferEthToOwner(uint256 _amount) public onlyOwner { \n', '        if (!isIcoFinished || _amount <= 0 || _amount > ownersEth) throw;\n', '        owner.transfer(_amount); \n', '        ownersEth -= _amount;\n', '    }    \n', '\n', '    // send STB to the ICO owner - after ICO\n', '    function transferStbToOwner(uint256 _amount) public onlyOwner { \n', '        if (!isIcoFinished || _amount <= 0) throw;\n', '        stb.transfer(owner, _amount); \n', '    }    \n', '    \n', '    \n', '    /* backup functions to be executed "manually" - in case of a critical ethereum platform failure \n', '      during automatic function execution */\n', '    function backup_finishIcoVars() public onlyOwner {\n', '        if (block.number <= icoEndBlock || isIcoFinished) throw;\n', '        isIcoFinished = true;\n', '        if (totalFunded >= crowdfundingTarget) isIcoSucceeded = true;\n', '    }\n', '    function backup_exchangeStaStb(uint256 _from, uint256 _to) public onlyOwner { \n', '        exchangeStaStb(_from, _to);\n', '    }\n', '    function backup_exchangeEthStb(uint256 _from, uint256 _to) public onlyOwner { \n', '        exchangeEthStb(_from, _to);\n', '    }\n', '    function backup_drawdown() public onlyOwner { \n', '        drawdown();\n', '    }\n', '    function backup_drawdown_amount(uint256 _amount) public onlyOwner {\n', '        if (!isIcoSucceeded) throw;\n', '        beneficiary.transfer(_amount);  \n', '    }\n', '    function backup_refund(uint256 _from, uint256 _to) public onlyOwner { \n', '        refund(_from, _to);\n', '    }\n', '    /* /backup */\n', '\n', '    function selfDestroy() onlyOwner { // TEST ONLY\n', '        suicide(this); \n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/// @title STABLE Project ICO\n', '/// @author Konrad Szałapak <konrad.szalapak@gmail.com>\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender != owner) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '}\n', '  \n', '/* New ERC23 contract interface */\n', 'contract ERC223 {\n', '    uint public totalSupply;\n', '    function balanceOf(address who) constant returns (uint);\n', '  \n', '    function name() constant returns (string _name);\n', '    function symbol() constant returns (string _symbol);\n', '    function decimals() constant returns (uint8 _decimals);\n', '    function totalSupply() constant returns (uint256 _supply);\n', '\n', '    function transfer(address to, uint value) returns (bool ok);\n', '    function transfer(address to, uint value, bytes data) returns (bool ok);\n', '    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '}\n', '\n', '/*\n', '* Contract that is working with ERC223 tokens\n', '*/\n', 'contract ContractReceiver {\n', '    function tokenFallback(address _from, uint _value, bytes _data);\n', '}\n', '\n', '/**\n', '* ERC23 token by Dexaran\n', '*\n', '* https://github.com/Dexaran/ERC23-tokens\n', '*/\n', ' \n', ' \n', '/* https://github.com/LykkeCity/EthereumApiDotNetCore/blob/master/src/ContractBuilder/contracts/token/SafeMath.sol */\n', 'contract SafeMath {\n', '    uint256 constant public MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x > MAX_UINT256 - y) throw;\n', '        return x + y;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x < y) throw;\n', '        return x - y;\n', '    }\n', '\n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) return 0;\n', '        if (x > MAX_UINT256 / y) throw;\n', '        return x * y;\n', '    }\n', '}\n', '\n', '/**\n', '* Stable Awareness Token - STA\n', '*/\n', 'contract ERC223Token_STA is ERC223, SafeMath, Ownable {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    mapping(address => uint) balances;\n', '    \n', '    // stable:\n', '    uint256 public icoEndBlock;                              // last block number of ICO \n', '    uint256 public maxSupply;                                // maximum token supply\n', '    uint256 public minedTokenCount;                          // counter of mined tokens\n', '    address public icoAddress;                               // address of ICO contract    \n', '    uint256 private multiplier;                              // for managing token fractionals\n', '    struct Miner {                                           // struct for mined tokens data\n', '        uint256 block;\n', '        address minerAddress;\n', '    }\n', '    mapping (uint256 => Miner) public minedTokens;           // mined tokens data\n', '    event MessageClaimMiningReward(address indexed miner, uint256 block, uint256 sta);  // notifies clients about sta winning miner\n', '    event Burn(address indexed from, uint256 value);         // notifies clients about the amount burnt\n', '    \n', '    function ERC223Token_STA() {\n', '        decimals = 8;\n', '        multiplier = 10**uint256(decimals);\n', '        maxSupply = 10000000000;                             // Maximum possible supply == 100 STA\n', '        name = "STABLE STA Token";                           // Set the name for display purposes\n', '        symbol = "STA";                                      // Set the symbol for display purposes\n', '        icoEndBlock = 4230150;  // INIT                      // last block number for ICO\n', '        totalSupply = 0;                                     // Update total supply\n', '        // balances[msg.sender] = totalSupply;               // Give the creator all initial tokens\n', '    }\n', ' \n', '    // trigger rewarding a miner with STA token:\n', '    function claimMiningReward() {  \n', '        if (icoAddress == address(0)) throw;                         // ICO address must be set up first\n', '        if (msg.sender != icoAddress && msg.sender != owner) throw;  // triggering enabled only for ICO or owner\n', '        if (block.number > icoEndBlock) throw;                       // rewarding enabled only before the end of ICO\n', '        if (minedTokenCount * multiplier >= maxSupply) throw; \n', '        if (minedTokenCount > 0) {\n', '            for (uint256 i = 0; i < minedTokenCount; i++) {\n', '                if (minedTokens[i].block == block.number) throw; \n', '            }\n', '        }\n', '        totalSupply += 1 * multiplier;\n', '        balances[block.coinbase] += 1 * multiplier;                  // reward miner with one STA token\n', '        minedTokens[minedTokenCount] = Miner(block.number, block.coinbase);\n', '        minedTokenCount += 1;\n', '        MessageClaimMiningReward(block.coinbase, block.number, 1 * multiplier);\n', '    } \n', '    \n', '    function selfDestroy() onlyOwner {\n', '        if (block.number <= icoEndBlock+14*3456) throw;           // allow to suicide STA token after around 2 weeks (25s/block) from the end of ICO\n', '        suicide(this); \n', '    }\n', '    // /stable\n', '   \n', '    // Function to access name of token .\n', '    function name() constant returns (string _name) {\n', '        return name;\n', '    }\n', '    // Function to access symbol of token .\n', '    function symbol() constant returns (string _symbol) {\n', '        return symbol;\n', '    }\n', '    // Function to access decimals of token .\n', '    function decimals() constant returns (uint8 _decimals) {\n', '        return decimals;\n', '    }\n', '    // Function to access total supply of tokens .\n', '    function totalSupply() constant returns (uint256 _totalSupply) {\n', '        return totalSupply;\n', '    }\n', '    function minedTokenCount() constant returns (uint256 _minedTokenCount) {\n', '        return minedTokenCount;\n', '    }\n', '    function icoAddress() constant returns (address _icoAddress) {\n', '        return icoAddress;\n', '    }\n', '\n', '    // Function that is called when a user or another contract wants to transfer funds .\n', '    function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, _data);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '  \n', '    // Standard function transfer similar to ERC20 transfer with no _data .\n', '    // Added due to backwards compatibility reasons .\n', '    function transfer(address _to, uint _value) returns (bool success) {\n', '        bytes memory empty;\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, empty);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, empty);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) private returns (bool is_contract) {\n', '        uint length;\n', "        _addr = _addr;  // workaround for Mist's inability to compile\n", "        is_contract = is_contract;  // workaround for Mist's inability to compile\n", '        assembly {\n', '                //retrieve the size of the code on target address, this needs assembly\n', '                length := extcodesize(_addr)\n', '        }\n', '        if(length>0) {\n', '            return true;\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    //function that is called when transaction target is an address\n', '    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) throw;\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '  \n', '    //function that is called when transaction target is a contract\n', '    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) throw;\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\t\n', '    function burn(address _address, uint256 _value) returns (bool success) {\n', '        if (icoAddress == address(0)) throw;\n', '        if (msg.sender != owner && msg.sender != icoAddress) throw; // only owner and ico contract are allowed\n', '        if (balances[_address] < _value) throw;                     // Check if the sender has enough tokens\n', '        balances[_address] -= _value;                               // Subtract from the sender\n', '        totalSupply -= _value;                               \n', '        Burn(_address, _value);\n', '        return true;\n', '    }\n', '\t\n', '    /* setting ICO address for allowing execution from the ICO contract */\n', '    function setIcoAddress(address _address) onlyOwner {\n', '        if (icoAddress == address(0)) {\n', '            icoAddress = _address;\n', '        }    \n', '        else throw;\n', '    }\n', '}\n', '\n', '/**\n', '* Stable Token - STB\n', '*/\n', 'contract ERC223Token_STB is ERC223, SafeMath, Ownable {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    mapping(address => uint) balances;\n', '    \n', '    // stable:\n', '    uint256 public maxSupply;\n', '    uint256 public icoEndBlock;\n', '    address public icoAddress;\n', '\t\n', '    function ERC223Token_STB() {\n', '        totalSupply = 0;                                     // Update total supply\n', '        maxSupply = 1000000000000;                           // Maximum possible supply of STB == 100M STB\n', '        name = "STABLE STB Token";                           // Set the name for display purposes\n', '        decimals = 4;                                        // Amount of decimals for display purposes\n', '        symbol = "STB";                                      // Set the symbol for display purposes\n', '        icoEndBlock = 4230150;  // INIT                      // last block number of ICO  // INIT PARAM             \n', '        //balances[msg.sender] = totalSupply;                // Give the creator all initial tokens       \n', '    }\n', '    \n', '    // Function to access max supply of tokens .\n', '    function maxSupply() constant returns (uint256 _maxSupply) {\n', '        return maxSupply;\n', '    }\n', '    // /stable\n', '  \n', '    // Function to access name of token .\n', '    function name() constant returns (string _name) {\n', '        return name;\n', '    }\n', '    // Function to access symbol of token .\n', '    function symbol() constant returns (string _symbol) {\n', '        return symbol;\n', '    }\n', '    // Function to access decimals of token .\n', '    function decimals() constant returns (uint8 _decimals) {\n', '        return decimals;\n', '    }\n', '    // Function to access total supply of tokens .\n', '    function totalSupply() constant returns (uint256 _totalSupply) {\n', '        return totalSupply;\n', '    }\n', '    function icoAddress() constant returns (address _icoAddress) {\n', '        return icoAddress;\n', '    }\n', '\n', '    // Function that is called when a user or another contract wants to transfer funds .\n', '    function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, _data);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '  \n', '    // Standard function transfer similar to ERC20 transfer with no _data .\n', '    // Added due to backwards compatibility reasons .\n', '    function transfer(address _to, uint _value) returns (bool success) {\n', '        bytes memory empty;\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, empty);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, empty);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) private returns (bool is_contract) {\n', '        uint length;\n', "        _addr = _addr;  // workaround for Mist's inability to compile\n", "        is_contract = is_contract;  // workaround for Mist's inability to compile\n", '        assembly {\n', '            //retrieve the size of the code on target address, this needs assembly\n', '            length := extcodesize(_addr)\n', '        }\n', '        if(length>0) {\n', '            return true;\n', '        }\n', '        else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    //function that is called when transaction target is an address\n', '    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) throw;\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '  \n', '    //function that is called when transaction target is a contract\n', '    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n', '        if (balanceOf(msg.sender) < _value) throw;\n', '        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n', '        balances[_to] = safeAdd(balanceOf(_to), _value);\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        Transfer(msg.sender, _to, _value, _data);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /* setting ICO address for allowing execution from the ICO contract */\n', '    function setIcoAddress(address _address) onlyOwner {\n', '        if (icoAddress == address(0)) {\n', '            icoAddress = _address;\n', '        }    \n', '        else throw;\n', '    }\n', '\n', '    /* mint new tokens */\n', '    function mint(address _receiver, uint256 _amount) {\n', '        if (icoAddress == address(0)) throw;\n', '        if (msg.sender != icoAddress && msg.sender != owner) throw;     // mint allowed only for ICO contract and owner\n', '        // if (block.number <= icoEndBlock) throw;                      // mint allowed only after ICO\n', '        if (safeAdd(totalSupply, _amount) > maxSupply) throw;\n', '        totalSupply = safeAdd(totalSupply, _amount); \n', '        balances[_receiver] = safeAdd(balances[_receiver], _amount);\n', '        Transfer(0, _receiver, _amount, new bytes(0)); \n', '    }\n', '    \n', '    function selfDestroy() onlyOwner { // TEST ONLY\n', '        suicide(this); \n', '    }\n', '}\n', '\n', '/* main contract - ICO */\n', 'contract StableICO is Ownable, SafeMath {\n', '    uint256 public crowdfundingTarget;         // ICO target, in wei\n', '    ERC223Token_STA public sta;                // address of STA token\n', '    ERC223Token_STB public stb;                // address of STB token\n', '    address public beneficiary;                // where the donation is transferred after successful ICO\n', '    uint256 public icoStartBlock;              // number of start block of ICO\n', '    uint256 public icoEndBlock;                // number of end block of ICO\n', '    bool public isIcoFinished;                 // boolean for ICO status - is ICO finished?\n', '    bool public isIcoSucceeded;                // boolean for ICO status - is crowdfunding target reached?\n', '    bool public isDonatedEthTransferred;       // boolean for ICO status - is donation transferred to the secure account?\n', '    bool public isStbMintedForStaEx;           // boolean for ICO status - is extra STB tokens minted for covering exchange of STA token?\n', '    uint256 public receivedStaAmount;          // amount of received STA tokens from rewarded miners\n', '    uint256 public totalFunded;                // amount of ETH donations\n', '    uint256 public ownersEth;                  // amount of ETH transferred to ICO contract by the owner\n', '    uint256 public oneStaIsStb;                // one STA value in STB\n', '    \n', '    struct Donor {                                                      // struct for ETH donations\n', '        address donorAddress;\n', '        uint256 ethAmount;\n', '        uint256 block;\n', '        bool exchangedOrRefunded;\n', '        uint256 stbAmount;\n', '    }\n', '    mapping (uint256 => Donor) public donations;                        // storage for ETH donations\n', '    uint256 public donationNum;                                         // counter of ETH donations\n', '\t\n', '    struct Miner {                                                      // struct for received STA tokens\n', '        address minerAddress;\n', '        uint256 staAmount;\n', '        uint256 block;\n', '        bool exchanged;\n', '        uint256 stbAmount;\n', '    }\n', '    mapping (uint256 => Miner) public receivedSta;                      // storage for received STA tokens\n', '    uint256 public minerNum;                                            // counter of STA receives\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value); \n', '    \n', '    event MessageExchangeEthStb(address from, uint256 eth, uint256 stb);\n', '    event MessageExchangeStaStb(address from, uint256 sta, uint256 stb);\n', '    event MessageReceiveEth(address from, uint256 eth, uint256 block);\n', '    event MessageReceiveSta(address from, uint256 sta, uint256 block);\n', '    event MessageReceiveStb(address from, uint256 stb, uint256 block, bytes data);  // it should never happen\n', '    event MessageRefundEth(address donor_address, uint256 eth);\n', '  \n', '    /* constructor */\n', '    function StableICO() {\n', '        crowdfundingTarget = 200000000000000000; // INIT (test: 0.2 ETH)\n', '        sta = ERC223Token_STA(0xe1e8f9bd535384a345c2a7a29a15df8fc345ad9c);  // INIT\n', '        stb = ERC223Token_STB(0x1e46a3f0552c5acf8ced4fe21a789b412f0e792a);  // INIT\n', '        beneficiary = 0x29ef9329bc15b7c11d047217618186b52bb4c8ff;  // INIT\n', '        icoStartBlock = 4230000;  // INIT\n', '        icoEndBlock = 4230150;  // INIT\n', '    }\t\t\n', '    \n', '    /* trigger rewarding the miner with STA token */\n', '    function claimMiningReward() public onlyOwner {\n', '        sta.claimMiningReward();\n', '    }\n', '\t\n', '    /* Receiving STA from miners - during and after ICO */\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) {\n', '        if (block.number < icoStartBlock) throw;\n', '        if (msg.sender == address(sta)) {\n', '            if (_value < 50000000) throw; // minimum 0.5 STA\n', '            if (block.number < icoEndBlock+14*3456) {  // allow STA tokens exchange for around 14 days (25s/block) after ICO\n', '                receivedSta[minerNum] = Miner(_from, _value, block.number, false, 0);\n', '                minerNum += 1;\n', '                receivedStaAmount = safeAdd(receivedStaAmount, _value);\n', '                MessageReceiveSta(_from, _value, block.number);\n', '            } else throw;\t\n', '        } else if(msg.sender == address(stb)) {\n', '            MessageReceiveStb(_from, _value, block.number, _data);\n', '        } else {\n', '            throw; // other tokens\n', '        }\n', '    }\n', '\n', '    /* Receiving ETH */\n', '    function () payable {\n', '\n', '        if (msg.value < 10000000000000000) throw;  // minimum 0.1 ETH  TEST: 0.01ETH\n', '\t\t\n', '        // before ICO (pre-ico)\n', '        if (block.number < icoStartBlock) {\n', '            if (msg.sender == owner) {\n', '                ownersEth = safeAdd(ownersEth, msg.value);\n', '            } else {\n', '                totalFunded = safeAdd(totalFunded, msg.value);\n', '                donations[donationNum] = Donor(msg.sender, msg.value, block.number, false, 0);\n', '                donationNum += 1;\n', '                MessageReceiveEth(msg.sender, msg.value, block.number);\n', '            }    \n', '        } \n', '        // during ICO\n', '        else if (block.number >= icoStartBlock && block.number <= icoEndBlock) {\n', '            if (msg.sender != owner) {\n', '                totalFunded = safeAdd(totalFunded, msg.value);\n', '                donations[donationNum] = Donor(msg.sender, msg.value, block.number, false, 0);\n', '                donationNum += 1;\n', '                MessageReceiveEth(msg.sender, msg.value, block.number);\n', '            } else ownersEth = safeAdd(ownersEth, msg.value);\n', '        }\n', '        // after ICO - first ETH transfer is returned to the sender\n', '        else if (block.number > icoEndBlock) {\n', '            if (!isIcoFinished) {\n', '                isIcoFinished = true;\n', '                msg.sender.transfer(msg.value);  // return ETH to the sender\n', '                if (totalFunded >= crowdfundingTarget) {\n', '                    isIcoSucceeded = true;\n', '                    exchangeStaStb(0, minerNum);\n', '                    exchangeEthStb(0, donationNum);\n', '                    drawdown();\n', '                } else {\n', '                    refund(0, donationNum);\n', '                }\t\n', '            } else {\n', '                if (msg.sender != owner) throw;  // WARNING: senders ETH may be lost (if transferred after finished ICO)\n', '                ownersEth = safeAdd(ownersEth, msg.value);\n', '            }    \n', '        } else {\n', '            throw;  // WARNING: senders ETH may be lost (if transferred after finished ICO)\n', '        }\n', '    }\n', '\n', '    /* send STB to the miners who returned STA tokens - after successful ICO */\n', '    function exchangeStaStb(uint256 _from, uint256 _to) private {  \n', '        if (!isIcoSucceeded) throw;\n', '        if (_from >= _to) return;  // skip the function if there is invalid range given for loop\n', '        uint256 _sta2stb = 10**4; \n', '        uint256 _wei2stb = 10**14; \n', '\n', '        if (!isStbMintedForStaEx) {\n', '            uint256 _mintAmount = (10*totalFunded)*5/1000 / _wei2stb;  // 0.5% extra STB minting for STA covering\n', '            oneStaIsStb = _mintAmount / 100;\n', '            stb.mint(address(this), _mintAmount);\n', '            isStbMintedForStaEx = true;\n', '        }\t\n', '\t\t\t\n', '        /* exchange */\n', '        uint256 _toBurn = 0;\n', '        for (uint256 i = _from; i < _to; i++) {\n', '            if (receivedSta[i].exchanged) continue;  // skip already exchanged STA\n', '            stb.transfer(receivedSta[i].minerAddress, receivedSta[i].staAmount/_sta2stb * oneStaIsStb / 10**4);\n', '            receivedSta[i].exchanged = true;\n', '            receivedSta[i].stbAmount = receivedSta[i].staAmount/_sta2stb * oneStaIsStb / 10**4;\n', '            _toBurn += receivedSta[i].staAmount;\n', '            MessageExchangeStaStb(receivedSta[i].minerAddress, receivedSta[i].staAmount, \n', '              receivedSta[i].staAmount/_sta2stb * oneStaIsStb / 10**4);\n', '        }\n', '        sta.burn(address(this), _toBurn);  // burn received and processed STA tokens\n', '    }\n', '\t\n', '    /* send STB to the donors - after successful ICO */\n', '    function exchangeEthStb(uint256 _from, uint256 _to) private { \n', '        if (!isIcoSucceeded) throw;\n', '        if (_from >= _to) return;  // skip the function if there is invalid range given for loop\n', '        uint256 _wei2stb = 10**14; // calculate eth to stb exchange\n', '        uint _pb = (icoEndBlock - icoStartBlock)/4; \n', '        uint _bonus;\n', '\n', '        /* mint */\n', '        uint256 _mintAmount = 0;\n', '        for (uint256 i = _from; i < _to; i++) {\n', '            if (donations[i].exchangedOrRefunded) continue;  // skip already minted STB\n', '            if (donations[i].block < icoStartBlock + _pb) _bonus = 6;  // first period; bonus in %\n', '            else if (donations[i].block >= icoStartBlock + _pb && donations[i].block < icoStartBlock + 2*_pb) _bonus = 4;  // 2nd\n', '            else if (donations[i].block >= icoStartBlock + 2*_pb && donations[i].block < icoStartBlock + 3*_pb) _bonus = 2;  // 3rd\n', '            else _bonus = 0;  // 4th\n', '            _mintAmount += 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100);\n', '        }\n', '        stb.mint(address(this), _mintAmount);\n', '\n', '        /* exchange */\n', '        for (i = _from; i < _to; i++) {\n', '            if (donations[i].exchangedOrRefunded) continue;  // skip already exchanged ETH\n', '            if (donations[i].block < icoStartBlock + _pb) _bonus = 6;  // first period; bonus in %\n', '            else if (donations[i].block >= icoStartBlock + _pb && donations[i].block < icoStartBlock + 2*_pb) _bonus = 4;  // 2nd\n', '            else if (donations[i].block >= icoStartBlock + 2*_pb && donations[i].block < icoStartBlock + 3*_pb) _bonus = 2;  // 3rd\n', '            else _bonus = 0;  // 4th\n', '            stb.transfer(donations[i].donorAddress, 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100) );\n', '            donations[i].exchangedOrRefunded = true;\n', '            donations[i].stbAmount = 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100);\n', '            MessageExchangeEthStb(donations[i].donorAddress, donations[i].ethAmount, \n', '              10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100));\n', '        }\n', '    }\n', '  \n', '    // send funds to the ICO beneficiary account - after successful ICO\n', '    function drawdown() private {\n', '        if (!isIcoSucceeded || isDonatedEthTransferred) throw;\n', '        beneficiary.transfer(totalFunded);  \n', '        isDonatedEthTransferred = true;\n', '    }\n', '  \n', '    /* refund ETH - after unsuccessful ICO */\n', '    function refund(uint256 _from, uint256 _to) private {\n', '        if (!isIcoFinished || isIcoSucceeded) throw;\n', '        if (_from >= _to) return;\n', '        for (uint256 i = _from; i < _to; i++) {\n', '            if (donations[i].exchangedOrRefunded) continue;\n', '            donations[i].donorAddress.transfer(donations[i].ethAmount);\n', '            donations[i].exchangedOrRefunded = true;\n', '            MessageRefundEth(donations[i].donorAddress, donations[i].ethAmount);\n', '        }\n', '    }\n', '    \n', "    // send owner's funds to the ICO owner - after ICO\n", '    function transferEthToOwner(uint256 _amount) public onlyOwner { \n', '        if (!isIcoFinished || _amount <= 0 || _amount > ownersEth) throw;\n', '        owner.transfer(_amount); \n', '        ownersEth -= _amount;\n', '    }    \n', '\n', '    // send STB to the ICO owner - after ICO\n', '    function transferStbToOwner(uint256 _amount) public onlyOwner { \n', '        if (!isIcoFinished || _amount <= 0) throw;\n', '        stb.transfer(owner, _amount); \n', '    }    \n', '    \n', '    \n', '    /* backup functions to be executed "manually" - in case of a critical ethereum platform failure \n', '      during automatic function execution */\n', '    function backup_finishIcoVars() public onlyOwner {\n', '        if (block.number <= icoEndBlock || isIcoFinished) throw;\n', '        isIcoFinished = true;\n', '        if (totalFunded >= crowdfundingTarget) isIcoSucceeded = true;\n', '    }\n', '    function backup_exchangeStaStb(uint256 _from, uint256 _to) public onlyOwner { \n', '        exchangeStaStb(_from, _to);\n', '    }\n', '    function backup_exchangeEthStb(uint256 _from, uint256 _to) public onlyOwner { \n', '        exchangeEthStb(_from, _to);\n', '    }\n', '    function backup_drawdown() public onlyOwner { \n', '        drawdown();\n', '    }\n', '    function backup_drawdown_amount(uint256 _amount) public onlyOwner {\n', '        if (!isIcoSucceeded) throw;\n', '        beneficiary.transfer(_amount);  \n', '    }\n', '    function backup_refund(uint256 _from, uint256 _to) public onlyOwner { \n', '        refund(_from, _to);\n', '    }\n', '    /* /backup */\n', '\n', '    function selfDestroy() onlyOwner { // TEST ONLY\n', '        suicide(this); \n', '    }\n', '}']
