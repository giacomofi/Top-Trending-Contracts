['/**\n', ' * SimpleRegistrar lets you claim a subdomain name for yourself and configure it\n', ' * all in one step. This one is deployed at registrar.gimmethe.eth.\n', ' * \n', ' * To use it, simply call register() with the name you want and the appropriate\n', ' * fee (initially 0.01 ether, but adjustable over time; call fee() to get the\n', ' * current price). For example, in a web3 console:\n', ' * \n', ' *     var simpleRegistrarContract = web3.eth.contract([{"constant":true,"inputs":[],"name":"fee","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function"},{"constant":false,"inputs":[{"name":"name","type":"string"}],"name":"register","outputs":[],"payable":true,"type":"function"}]);\n', ' *     var simpleRegistrar = simpleRegistrarContract.at("0x1bebbc372772817d5d11a06ee2a4eba33ab6ee65");\n', " *     simpleRegistrar.register('myname', {from: accounts[0], value: simpleRegistrar.fee(), gas: 150000});\n", ' * \n', ' * SimpleRegistrar will take care of everything: registering your subdomain,\n', ' * setting up a resolver, and pointing that resolver at the account that called\n', ' * it.\n', ' * \n', ' * Funds received from running this service are reinvested into building new\n', ' * ENS tools and utilities.\n', ' * \n', ' * Note that the Deed owning gimmethe.eth is not currently in a holding\n', ' * contract, so I could theoretically change the registrar at any time. This is\n', ' * a temporary measure, as it may be necessary to replace this contract with an\n', ' * updated one as ENS best practices change. You have only my word that I will\n', ' * never interfere with a properly registered subdomain of gimmethe.eth.\n', ' * \n', ' * Author: Nick Johnson <nick@arachnidlabs.com>\n', ' * Copyright 2017, Nick Johnson\n', ' * Licensed under the Apache Public License, version 2.0.\n', ' */\n', 'pragma solidity ^0.4.10;\n', '\n', 'contract AbstractENS {\n', '    function owner(bytes32 node) constant returns(address);\n', '    function resolver(bytes32 node) constant returns(address);\n', '    function ttl(bytes32 node) constant returns(uint64);\n', '    function setOwner(bytes32 node, address owner);\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner);\n', '    function setResolver(bytes32 node, address resolver);\n', '    function setTTL(bytes32 node, uint64 ttl);\n', '}\n', '\n', 'contract owned {\n', '    address owner;\n', '    \n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier owner_only() {\n', '        if(msg.sender != owner) throw;\n', '        _;\n', '    }\n', '    \n', '    function setOwner(address _owner) owner_only {\n', '        owner = _owner;\n', '    }\n', '}\n', '\n', 'contract Resolver {\n', '    function setAddr(bytes32 node, address addr);\n', '}\n', '\n', 'contract ReverseRegistrar {\n', '    function claim(address owner) returns (bytes32 node);\n', '}\n', '\n', 'contract SimpleRegistrar is owned {\n', "    // namehash('addr.reverse')\n", '    bytes32 constant RR_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n', '\n', '    event HashRegistered(bytes32 indexed hash, address indexed owner);\n', '\n', '    AbstractENS public ens;\n', '    bytes32 public rootNode;\n', '    uint public fee;\n', '    // Temporary until we have a public address for it\n', '    Resolver public resolver;\n', '    \n', '    function SimpleRegistrar(AbstractENS _ens, bytes32 _rootNode, uint _fee, Resolver _resolver) {\n', '        ens = _ens;\n', '        rootNode = _rootNode;\n', '        fee = _fee;\n', '        resolver = _resolver;\n', '        \n', '        // Assign reverse record to sender\n', '        ReverseRegistrar(ens.owner(RR_NODE)).claim(msg.sender);\n', '    }\n', '    \n', '    function withdraw() owner_only {\n', '        if(!msg.sender.send(this.balance)) throw;\n', '    }\n', '    \n', '    function setFee(uint _fee) owner_only {\n', '        fee = _fee;\n', '    }\n', '    \n', '    function setResolver(Resolver _resolver) owner_only {\n', '        resolver = _resolver;\n', '    }\n', '    \n', '    modifier can_register(bytes32 label) {\n', '        if(ens.owner(sha3(rootNode, label)) != 0 || msg.value < fee) throw;\n', '        _;\n', '    }\n', '    \n', '    function register(string name) payable can_register(sha3(name)) {\n', '        var label = sha3(name);\n', '        \n', '        // First register the name to ourselves\n', '        ens.setSubnodeOwner(rootNode, label, this);\n', '        \n', '        // Now set a resolver up\n', '        var node = sha3(rootNode, label);\n', '        ens.setResolver(node, resolver);\n', '        resolver.setAddr(node, msg.sender);\n', '        \n', '        // Now transfer ownership to the user\n', '        ens.setOwner(node, msg.sender);\n', '        \n', '        HashRegistered(label, msg.sender);\n', '        \n', '        // Send any excess ether back\n', '        if(msg.value > fee) {\n', '            if(!msg.sender.send(msg.value - fee)) throw;\n', '        }\n', '    }\n', '}']