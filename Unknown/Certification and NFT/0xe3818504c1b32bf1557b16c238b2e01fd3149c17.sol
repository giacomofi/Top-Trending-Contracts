['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control \n', ' * functions, this simplifies the implementation of "user permissions". \n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /** \n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner. \n', '   */\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to. \n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract TeamAllocation is Ownable {\n', '  using SafeMath for uint;\n', '  //uint public constant lockedTeamAllocationTokens = 16000000;\n', '  uint public unlockedAt;\n', '  PillarToken plr;\n', '  mapping (address => uint) allocations;\n', '  uint tokensCreated = 0;\n', '  uint constant public lockedTeamAllocationTokens = 16000000e18;\n', '  //address of the team storage vault\n', '  address public teamStorageVault = 0x3f5D90D5Cc0652AAa40519114D007Bf119Afe1Cf;\n', '\n', '  function TeamAllocation() {\n', '    plr = PillarToken(msg.sender);\n', '    // Locked time of approximately 9 months before team members are able to redeeem tokens.\n', '    uint nineMonths = 9 * 30 days;\n', '    unlockedAt = now.add(nineMonths);\n', '    //2% tokens from the Marketing bucket which are locked for 9 months\n', '    allocations[teamStorageVault] = lockedTeamAllocationTokens;\n', '  }\n', '\n', '  function getTotalAllocation() returns (uint){\n', '      return lockedTeamAllocationTokens;\n', '  }\n', '\n', '  function unlock() external payable {\n', '    if (now < unlockedAt) throw;\n', '\n', '    if (tokensCreated == 0) {\n', '      tokensCreated = plr.balanceOf(this);\n', '    }\n', '    //transfer the locked tokens to the teamStorageAddress\n', '    plr.transfer(teamStorageVault, tokensCreated);\n', '  }\n', '}\n', '\n', 'contract UnsoldAllocation is Ownable {\n', '  using SafeMath for uint;\n', '  uint unlockedAt;\n', '  uint allocatedTokens;\n', '  PillarToken plr;\n', '  mapping (address => uint) allocations;\n', '\n', '  uint tokensCreated = 0;\n', '\n', '  /*\n', '    Split among team members\n', '    Tokens reserved for Team: 1,000,000\n', '    Tokens reserved for 20|30 projects: 1,000,000\n', '    Tokens reserved for future sale: 1,000,000\n', '  */\n', '\n', '  function UnsoldAllocation(uint _lockTime, address _owner, uint _tokens) {\n', '    if(_lockTime == 0) throw;\n', '\n', '    if(_owner == address(0)) throw;\n', '\n', '    plr = PillarToken(msg.sender);\n', '    uint lockTime = _lockTime * 1 years;\n', '    unlockedAt = now.add(lockTime);\n', '    allocatedTokens = _tokens;\n', '    allocations[_owner] = _tokens;\n', '  }\n', '\n', '  function getTotalAllocation()returns(uint){\n', '      return allocatedTokens;\n', '  }\n', '\n', '  function unlock() external payable {\n', '    if (now < unlockedAt) throw;\n', '\n', '    if (tokensCreated == 0) {\n', '      tokensCreated = plr.balanceOf(this);\n', '    }\n', '\n', '    var allocation = allocations[msg.sender];\n', '    allocations[msg.sender] = 0;\n', '    var toTransfer = (tokensCreated.mul(allocation)).div(allocatedTokens);\n', '    plr.transfer(msg.sender, toTransfer);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    if (paused) throw;\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    if (!paused) throw;\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    Unpause();\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function transfer(address to, uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances. \n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint;\n', '\n', '  mapping(address => uint) balances;\n', '\n', '  /**\n', '   * @dev Fix for the ERC20 short address attack.\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '     if(msg.data.length < size + 4) {\n', '       throw;\n', '     }\n', '     _;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '  function transferFrom(address from, address to, uint value);\n', '  function approve(address spender, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implemantation of the basic standart token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint _value) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '/// @title PillarToken - Crowdfunding code for the Pillar Project\n', '/// @author Parthasarathy Ramanujam, Gustavo Guimaraes, Ronak Thacker\n', 'contract PillarToken is StandardToken, Ownable {\n', '\n', '    using SafeMath for uint;\n', '    string public constant name = "PILLAR";\n', '    string public constant symbol = "PLR";\n', '    uint public constant decimals = 18;\n', '\n', '    TeamAllocation public teamAllocation;\n', '    UnsoldAllocation public unsoldTokens;\n', '    UnsoldAllocation public twentyThirtyAllocation;\n', '    UnsoldAllocation public futureSaleAllocation;\n', '\n', '    uint constant public minTokensForSale  = 32000000e18;\n', '\n', '    uint constant public maxPresaleTokens             =  48000000e18;\n', '    uint constant public totalAvailableForSale        = 528000000e18;\n', '    uint constant public futureTokens                 = 120000000e18;\n', '    uint constant public twentyThirtyTokens           =  80000000e18;\n', '    uint constant public lockedTeamAllocationTokens   =  16000000e18;\n', '    uint constant public unlockedTeamAllocationTokens =   8000000e18;\n', '\n', '    address public unlockedTeamStorageVault = 0x4162Ad6EEc341e438eAbe85f52a941B078210819;\n', '    address public twentyThirtyVault = 0xe72bA5c6F63Ddd395DF9582800E2821cE5a05D75;\n', '    address public futureSaleVault = 0xf0231160Bd1a2a2D25aed2F11B8360EbF56F6153;\n', '    address unsoldVault;\n', '\n', '    //Storage years\n', '    uint constant coldStorageYears = 10;\n', '    uint constant futureStorageYears = 3;\n', '\n', '    uint totalPresale = 0;\n', '\n', '    // Funding amount in ether\n', '    uint public constant tokenPrice  = 0.0005 ether;\n', '\n', '    // Multisigwallet where the proceeds will be stored.\n', '    address public pillarTokenFactory;\n', '\n', '    uint fundingStartBlock;\n', '    uint fundingStopBlock;\n', '\n', '    // flags whether ICO is afoot.\n', '    bool fundingMode;\n', '\n', '    //total used tokens\n', '    uint totalUsedTokens;\n', '\n', '    event Refund(address indexed _from,uint256 _value);\n', '    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n', '    event MoneyAddedForRefund(address _from, uint256 _value,uint256 _total);\n', '\n', '    modifier isNotFundable() {\n', '        if (fundingMode) throw;\n', '        _;\n', '    }\n', '\n', '    modifier isFundable() {\n', '        if (!fundingMode) throw;\n', '        _;\n', '    }\n', '\n', '    //@notice  Constructor of PillarToken\n', '    //@param `_pillarTokenFactory` - multisigwallet address to store proceeds.\n', '    //@param `_icedWallet` - Multisigwallet address to which unsold tokens are assigned\n', '    function PillarToken(address _pillarTokenFactory, address _icedWallet) {\n', '      if(_pillarTokenFactory == address(0)) throw;\n', '      if(_icedWallet == address(0)) throw;\n', '\n', '      pillarTokenFactory = _pillarTokenFactory;\n', '      totalUsedTokens = 0;\n', '      totalSupply = 800000000e18;\n', '      unsoldVault = _icedWallet;\n', '\n', '      //allot 8 million of the 24 million marketing tokens to an address\n', '      balances[unlockedTeamStorageVault] = unlockedTeamAllocationTokens;\n', '\n', '      //allocate tokens for 2030 wallet locked in for 3 years\n', '      futureSaleAllocation = new UnsoldAllocation(futureStorageYears,futureSaleVault,futureTokens);\n', '      balances[address(futureSaleAllocation)] = futureTokens;\n', '\n', '      //allocate tokens for future wallet locked in for 3 years\n', '      twentyThirtyAllocation = new UnsoldAllocation(futureStorageYears,twentyThirtyVault,twentyThirtyTokens);\n', '      balances[address(twentyThirtyAllocation)] = twentyThirtyTokens;\n', '\n', '      fundingMode = false;\n', '    }\n', '\n', '    //@notice Fallback function that accepts the ether and allocates tokens to\n', '    //the msg.sender corresponding to msg.value\n', '    function() payable isFundable external {\n', '      purchase();\n', '    }\n', '\n', '    //@notice function that accepts the ether and allocates tokens to\n', '    //the msg.sender corresponding to msg.value\n', '    function purchase() payable isFundable {\n', '      if(block.number < fundingStartBlock) throw;\n', '      if(block.number > fundingStopBlock) throw;\n', '      if(totalUsedTokens >= totalAvailableForSale) throw;\n', '\n', '      if (msg.value < tokenPrice) throw;\n', '\n', '      uint numTokens = msg.value.div(tokenPrice);\n', '      if(numTokens < 1) throw;\n', '      //transfer money to PillarTokenFactory MultisigWallet\n', '      pillarTokenFactory.transfer(msg.value);\n', '\n', '      uint tokens = numTokens.mul(1e18);\n', '      totalUsedTokens = totalUsedTokens.add(tokens);\n', '      if (totalUsedTokens > totalAvailableForSale) throw;\n', '\n', '      balances[msg.sender] = balances[msg.sender].add(tokens);\n', '\n', '      //fire the event notifying the transfer of tokens\n', '      Transfer(0, msg.sender, tokens);\n', '    }\n', '\n', '    //@notice Function reports the number of tokens available for sale\n', '    function numberOfTokensLeft() constant returns (uint256) {\n', '      uint tokensAvailableForSale = totalAvailableForSale.sub(totalUsedTokens);\n', '      return tokensAvailableForSale;\n', '    }\n', '\n', '    //@notice Finalize the ICO, send team allocation tokens\n', '    //@notice send any remaining balance to the MultisigWallet\n', '    //@notice unsold tokens will be sent to icedwallet\n', '    function finalize() isFundable onlyOwner external {\n', '      if (block.number <= fundingStopBlock) throw;\n', '\n', '      if (totalUsedTokens < minTokensForSale) throw;\n', '\n', '      if(unsoldVault == address(0)) throw;\n', '\n', '      // switch funding mode off\n', '      fundingMode = false;\n', '\n', '      //Allot team tokens to a smart contract which will frozen for 9 months\n', '      teamAllocation = new TeamAllocation();\n', '      balances[address(teamAllocation)] = lockedTeamAllocationTokens;\n', '\n', '      //allocate unsold tokens to iced storage\n', '      uint totalUnSold = numberOfTokensLeft();\n', '      if(totalUnSold > 0) {\n', '        unsoldTokens = new UnsoldAllocation(coldStorageYears,unsoldVault,totalUnSold);\n', '        balances[address(unsoldTokens)] = totalUnSold;\n', '      }\n', '\n', '      //transfer any balance available to Pillar Multisig Wallet\n', '      pillarTokenFactory.transfer(this.balance);\n', '    }\n', '\n', '    //@notice Function that can be called by purchasers to refund\n', '    //@notice Used only in case the ICO isn&#39;t successful.\n', '    function refund() isFundable external {\n', '      if(block.number <= fundingStopBlock) throw;\n', '      if(totalUsedTokens >= minTokensForSale) throw;\n', '\n', '      uint plrValue = balances[msg.sender];\n', '      if(plrValue == 0) throw;\n', '\n', '      balances[msg.sender] = 0;\n', '\n', '      uint ethValue = plrValue.mul(tokenPrice).div(1e18);\n', '      msg.sender.transfer(ethValue);\n', '      Refund(msg.sender, ethValue);\n', '    }\n', '\n', '    //@notice Function used for funding in case of refund.\n', '    //@notice Can be called only by the Owner\n', '    function allocateForRefund() external payable onlyOwner returns (uint){\n', '      //does nothing just accepts and stores the ether\n', '      MoneyAddedForRefund(msg.sender,msg.value,this.balance);\n', '      return this.balance;\n', '    }\n', '\n', '    //@notice Function to allocate tokens to an user.\n', '    //@param `_to` the address of an user\n', '    //@param `_tokens` number of tokens to be allocated.\n', '    //@notice Can be called only when funding is not active and only by the owner\n', '    function allocateTokens(address _to,uint _tokens) isNotFundable onlyOwner external {\n', '      uint numOfTokens = _tokens.mul(1e18);\n', '      totalPresale = totalPresale.add(numOfTokens);\n', '\n', '      if(totalPresale > maxPresaleTokens) throw;\n', '\n', '      balances[_to] = balances[_to].add(numOfTokens);\n', '    }\n', '\n', '    //@notice Function to unPause the contract.\n', '    //@notice Can be called only when funding is active and only by the owner\n', '    function unPauseTokenSale() onlyOwner isNotFundable external returns (bool){\n', '      fundingMode = true;\n', '      return fundingMode;\n', '    }\n', '\n', '    //@notice Function to pause the contract.\n', '    //@notice Can be called only when funding is active and only by the owner\n', '    function pauseTokenSale() onlyOwner isFundable external returns (bool){\n', '      fundingMode = false;\n', '      return !fundingMode;\n', '    }\n', '\n', '    //@notice Function to start the contract.\n', '    //@param `_fundingStartBlock` - block from when ICO commences\n', '    //@param `_fundingStopBlock` - block from when ICO ends.\n', '    //@notice Can be called only when funding is not active and only by the owner\n', '    function startTokenSale(uint _fundingStartBlock, uint _fundingStopBlock) onlyOwner isNotFundable external returns (bool){\n', '      if(_fundingStopBlock <= _fundingStartBlock) throw;\n', '\n', '      fundingStartBlock = _fundingStartBlock;\n', '      fundingStopBlock = _fundingStopBlock;\n', '      fundingMode = true;\n', '      return fundingMode;\n', '    }\n', '\n', '    //@notice Function to get the current funding status.\n', '    function fundingStatus() external constant returns (bool){\n', '      return fundingMode;\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control \n', ' * functions, this simplifies the implementation of "user permissions". \n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /** \n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner. \n', '   */\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to. \n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', 'contract TeamAllocation is Ownable {\n', '  using SafeMath for uint;\n', '  //uint public constant lockedTeamAllocationTokens = 16000000;\n', '  uint public unlockedAt;\n', '  PillarToken plr;\n', '  mapping (address => uint) allocations;\n', '  uint tokensCreated = 0;\n', '  uint constant public lockedTeamAllocationTokens = 16000000e18;\n', '  //address of the team storage vault\n', '  address public teamStorageVault = 0x3f5D90D5Cc0652AAa40519114D007Bf119Afe1Cf;\n', '\n', '  function TeamAllocation() {\n', '    plr = PillarToken(msg.sender);\n', '    // Locked time of approximately 9 months before team members are able to redeeem tokens.\n', '    uint nineMonths = 9 * 30 days;\n', '    unlockedAt = now.add(nineMonths);\n', '    //2% tokens from the Marketing bucket which are locked for 9 months\n', '    allocations[teamStorageVault] = lockedTeamAllocationTokens;\n', '  }\n', '\n', '  function getTotalAllocation() returns (uint){\n', '      return lockedTeamAllocationTokens;\n', '  }\n', '\n', '  function unlock() external payable {\n', '    if (now < unlockedAt) throw;\n', '\n', '    if (tokensCreated == 0) {\n', '      tokensCreated = plr.balanceOf(this);\n', '    }\n', '    //transfer the locked tokens to the teamStorageAddress\n', '    plr.transfer(teamStorageVault, tokensCreated);\n', '  }\n', '}\n', '\n', 'contract UnsoldAllocation is Ownable {\n', '  using SafeMath for uint;\n', '  uint unlockedAt;\n', '  uint allocatedTokens;\n', '  PillarToken plr;\n', '  mapping (address => uint) allocations;\n', '\n', '  uint tokensCreated = 0;\n', '\n', '  /*\n', '    Split among team members\n', '    Tokens reserved for Team: 1,000,000\n', '    Tokens reserved for 20|30 projects: 1,000,000\n', '    Tokens reserved for future sale: 1,000,000\n', '  */\n', '\n', '  function UnsoldAllocation(uint _lockTime, address _owner, uint _tokens) {\n', '    if(_lockTime == 0) throw;\n', '\n', '    if(_owner == address(0)) throw;\n', '\n', '    plr = PillarToken(msg.sender);\n', '    uint lockTime = _lockTime * 1 years;\n', '    unlockedAt = now.add(lockTime);\n', '    allocatedTokens = _tokens;\n', '    allocations[_owner] = _tokens;\n', '  }\n', '\n', '  function getTotalAllocation()returns(uint){\n', '      return allocatedTokens;\n', '  }\n', '\n', '  function unlock() external payable {\n', '    if (now < unlockedAt) throw;\n', '\n', '    if (tokensCreated == 0) {\n', '      tokensCreated = plr.balanceOf(this);\n', '    }\n', '\n', '    var allocation = allocations[msg.sender];\n', '    allocations[msg.sender] = 0;\n', '    var toTransfer = (tokensCreated.mul(allocation)).div(allocatedTokens);\n', '    plr.transfer(msg.sender, toTransfer);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS paused\n', '   */\n', '  modifier whenNotPaused() {\n', '    if (paused) throw;\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev modifier to allow actions only when the contract IS NOT paused\n', '   */\n', '  modifier whenPaused {\n', '    if (!paused) throw;\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused returns (bool) {\n', '    paused = true;\n', '    Pause();\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused returns (bool) {\n', '    paused = false;\n', '    Unpause();\n', '    return true;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function transfer(address to, uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances. \n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint;\n', '\n', '  mapping(address => uint) balances;\n', '\n', '  /**\n', '   * @dev Fix for the ERC20 short address attack.\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '     if(msg.data.length < size + 4) {\n', '       throw;\n', '     }\n', '     _;\n', '  }\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '  function transferFrom(address from, address to, uint value);\n', '  function approve(address spender, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implemantation of the basic standart token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // if (_value > _allowance) throw;\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint _value) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '/// @title PillarToken - Crowdfunding code for the Pillar Project\n', '/// @author Parthasarathy Ramanujam, Gustavo Guimaraes, Ronak Thacker\n', 'contract PillarToken is StandardToken, Ownable {\n', '\n', '    using SafeMath for uint;\n', '    string public constant name = "PILLAR";\n', '    string public constant symbol = "PLR";\n', '    uint public constant decimals = 18;\n', '\n', '    TeamAllocation public teamAllocation;\n', '    UnsoldAllocation public unsoldTokens;\n', '    UnsoldAllocation public twentyThirtyAllocation;\n', '    UnsoldAllocation public futureSaleAllocation;\n', '\n', '    uint constant public minTokensForSale  = 32000000e18;\n', '\n', '    uint constant public maxPresaleTokens             =  48000000e18;\n', '    uint constant public totalAvailableForSale        = 528000000e18;\n', '    uint constant public futureTokens                 = 120000000e18;\n', '    uint constant public twentyThirtyTokens           =  80000000e18;\n', '    uint constant public lockedTeamAllocationTokens   =  16000000e18;\n', '    uint constant public unlockedTeamAllocationTokens =   8000000e18;\n', '\n', '    address public unlockedTeamStorageVault = 0x4162Ad6EEc341e438eAbe85f52a941B078210819;\n', '    address public twentyThirtyVault = 0xe72bA5c6F63Ddd395DF9582800E2821cE5a05D75;\n', '    address public futureSaleVault = 0xf0231160Bd1a2a2D25aed2F11B8360EbF56F6153;\n', '    address unsoldVault;\n', '\n', '    //Storage years\n', '    uint constant coldStorageYears = 10;\n', '    uint constant futureStorageYears = 3;\n', '\n', '    uint totalPresale = 0;\n', '\n', '    // Funding amount in ether\n', '    uint public constant tokenPrice  = 0.0005 ether;\n', '\n', '    // Multisigwallet where the proceeds will be stored.\n', '    address public pillarTokenFactory;\n', '\n', '    uint fundingStartBlock;\n', '    uint fundingStopBlock;\n', '\n', '    // flags whether ICO is afoot.\n', '    bool fundingMode;\n', '\n', '    //total used tokens\n', '    uint totalUsedTokens;\n', '\n', '    event Refund(address indexed _from,uint256 _value);\n', '    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n', '    event MoneyAddedForRefund(address _from, uint256 _value,uint256 _total);\n', '\n', '    modifier isNotFundable() {\n', '        if (fundingMode) throw;\n', '        _;\n', '    }\n', '\n', '    modifier isFundable() {\n', '        if (!fundingMode) throw;\n', '        _;\n', '    }\n', '\n', '    //@notice  Constructor of PillarToken\n', '    //@param `_pillarTokenFactory` - multisigwallet address to store proceeds.\n', '    //@param `_icedWallet` - Multisigwallet address to which unsold tokens are assigned\n', '    function PillarToken(address _pillarTokenFactory, address _icedWallet) {\n', '      if(_pillarTokenFactory == address(0)) throw;\n', '      if(_icedWallet == address(0)) throw;\n', '\n', '      pillarTokenFactory = _pillarTokenFactory;\n', '      totalUsedTokens = 0;\n', '      totalSupply = 800000000e18;\n', '      unsoldVault = _icedWallet;\n', '\n', '      //allot 8 million of the 24 million marketing tokens to an address\n', '      balances[unlockedTeamStorageVault] = unlockedTeamAllocationTokens;\n', '\n', '      //allocate tokens for 2030 wallet locked in for 3 years\n', '      futureSaleAllocation = new UnsoldAllocation(futureStorageYears,futureSaleVault,futureTokens);\n', '      balances[address(futureSaleAllocation)] = futureTokens;\n', '\n', '      //allocate tokens for future wallet locked in for 3 years\n', '      twentyThirtyAllocation = new UnsoldAllocation(futureStorageYears,twentyThirtyVault,twentyThirtyTokens);\n', '      balances[address(twentyThirtyAllocation)] = twentyThirtyTokens;\n', '\n', '      fundingMode = false;\n', '    }\n', '\n', '    //@notice Fallback function that accepts the ether and allocates tokens to\n', '    //the msg.sender corresponding to msg.value\n', '    function() payable isFundable external {\n', '      purchase();\n', '    }\n', '\n', '    //@notice function that accepts the ether and allocates tokens to\n', '    //the msg.sender corresponding to msg.value\n', '    function purchase() payable isFundable {\n', '      if(block.number < fundingStartBlock) throw;\n', '      if(block.number > fundingStopBlock) throw;\n', '      if(totalUsedTokens >= totalAvailableForSale) throw;\n', '\n', '      if (msg.value < tokenPrice) throw;\n', '\n', '      uint numTokens = msg.value.div(tokenPrice);\n', '      if(numTokens < 1) throw;\n', '      //transfer money to PillarTokenFactory MultisigWallet\n', '      pillarTokenFactory.transfer(msg.value);\n', '\n', '      uint tokens = numTokens.mul(1e18);\n', '      totalUsedTokens = totalUsedTokens.add(tokens);\n', '      if (totalUsedTokens > totalAvailableForSale) throw;\n', '\n', '      balances[msg.sender] = balances[msg.sender].add(tokens);\n', '\n', '      //fire the event notifying the transfer of tokens\n', '      Transfer(0, msg.sender, tokens);\n', '    }\n', '\n', '    //@notice Function reports the number of tokens available for sale\n', '    function numberOfTokensLeft() constant returns (uint256) {\n', '      uint tokensAvailableForSale = totalAvailableForSale.sub(totalUsedTokens);\n', '      return tokensAvailableForSale;\n', '    }\n', '\n', '    //@notice Finalize the ICO, send team allocation tokens\n', '    //@notice send any remaining balance to the MultisigWallet\n', '    //@notice unsold tokens will be sent to icedwallet\n', '    function finalize() isFundable onlyOwner external {\n', '      if (block.number <= fundingStopBlock) throw;\n', '\n', '      if (totalUsedTokens < minTokensForSale) throw;\n', '\n', '      if(unsoldVault == address(0)) throw;\n', '\n', '      // switch funding mode off\n', '      fundingMode = false;\n', '\n', '      //Allot team tokens to a smart contract which will frozen for 9 months\n', '      teamAllocation = new TeamAllocation();\n', '      balances[address(teamAllocation)] = lockedTeamAllocationTokens;\n', '\n', '      //allocate unsold tokens to iced storage\n', '      uint totalUnSold = numberOfTokensLeft();\n', '      if(totalUnSold > 0) {\n', '        unsoldTokens = new UnsoldAllocation(coldStorageYears,unsoldVault,totalUnSold);\n', '        balances[address(unsoldTokens)] = totalUnSold;\n', '      }\n', '\n', '      //transfer any balance available to Pillar Multisig Wallet\n', '      pillarTokenFactory.transfer(this.balance);\n', '    }\n', '\n', '    //@notice Function that can be called by purchasers to refund\n', "    //@notice Used only in case the ICO isn't successful.\n", '    function refund() isFundable external {\n', '      if(block.number <= fundingStopBlock) throw;\n', '      if(totalUsedTokens >= minTokensForSale) throw;\n', '\n', '      uint plrValue = balances[msg.sender];\n', '      if(plrValue == 0) throw;\n', '\n', '      balances[msg.sender] = 0;\n', '\n', '      uint ethValue = plrValue.mul(tokenPrice).div(1e18);\n', '      msg.sender.transfer(ethValue);\n', '      Refund(msg.sender, ethValue);\n', '    }\n', '\n', '    //@notice Function used for funding in case of refund.\n', '    //@notice Can be called only by the Owner\n', '    function allocateForRefund() external payable onlyOwner returns (uint){\n', '      //does nothing just accepts and stores the ether\n', '      MoneyAddedForRefund(msg.sender,msg.value,this.balance);\n', '      return this.balance;\n', '    }\n', '\n', '    //@notice Function to allocate tokens to an user.\n', '    //@param `_to` the address of an user\n', '    //@param `_tokens` number of tokens to be allocated.\n', '    //@notice Can be called only when funding is not active and only by the owner\n', '    function allocateTokens(address _to,uint _tokens) isNotFundable onlyOwner external {\n', '      uint numOfTokens = _tokens.mul(1e18);\n', '      totalPresale = totalPresale.add(numOfTokens);\n', '\n', '      if(totalPresale > maxPresaleTokens) throw;\n', '\n', '      balances[_to] = balances[_to].add(numOfTokens);\n', '    }\n', '\n', '    //@notice Function to unPause the contract.\n', '    //@notice Can be called only when funding is active and only by the owner\n', '    function unPauseTokenSale() onlyOwner isNotFundable external returns (bool){\n', '      fundingMode = true;\n', '      return fundingMode;\n', '    }\n', '\n', '    //@notice Function to pause the contract.\n', '    //@notice Can be called only when funding is active and only by the owner\n', '    function pauseTokenSale() onlyOwner isFundable external returns (bool){\n', '      fundingMode = false;\n', '      return !fundingMode;\n', '    }\n', '\n', '    //@notice Function to start the contract.\n', '    //@param `_fundingStartBlock` - block from when ICO commences\n', '    //@param `_fundingStopBlock` - block from when ICO ends.\n', '    //@notice Can be called only when funding is not active and only by the owner\n', '    function startTokenSale(uint _fundingStartBlock, uint _fundingStopBlock) onlyOwner isNotFundable external returns (bool){\n', '      if(_fundingStopBlock <= _fundingStartBlock) throw;\n', '\n', '      fundingStartBlock = _fundingStartBlock;\n', '      fundingStopBlock = _fundingStopBlock;\n', '      fundingMode = true;\n', '      return fundingMode;\n', '    }\n', '\n', '    //@notice Function to get the current funding status.\n', '    function fundingStatus() external constant returns (bool){\n', '      return fundingMode;\n', '    }\n', '}']
