['pragma solidity ^0.4.8;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' * By OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/contracts/SafeMath.sol\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    if(!(a == 0 || c / a == b)) throw;\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    if(!(b <= a)) throw;\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    if(!(c >= a)) throw;\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', 'contract ContractReceiver{\n', '    function tokenFallback(address _from, uint256 _value, bytes  _data) external;\n', '}\n', '\n', '\n', '//Basic ERC23 token, backward compatible with ERC20 transfer function.\n', '//Based in part on code by open-zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git\n', 'contract ERC23BasicToken {\n', '    using SafeMath for uint256;\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) balances;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '    function tokenFallback(address _from, uint256 _value, bytes  _data) external {\n', '        throw;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value, bytes _data) returns (bool success) {\n', '\n', '        //Standard ERC23 transfer function\n', '\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, _data);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) {\n', '\n', '        //standard function transfer similar to ERC20 transfer with no _data\n', '        //added due to backwards compatibility reasons\n', '\n', '        bytes memory empty;\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, empty);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, empty);\n', '        }\n', '    }\n', '\n', '    function transferToAddress(address _to, uint256 _value, bytes _data) internal {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '     }\n', '\n', '    function transferToContract(address _to, uint256 _value, bytes _data) internal {\n', '        balances[msg.sender] = balances[msg.sender].sub( _value);\n', '        balances[_to] = balances[_to].add( _value);\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        Transfer(msg.sender, _to, _value);    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) returns (bool is_contract) {\n', '          uint256 length;\n', '          assembly {\n', '              //retrieve the size of the code on target address, this needs assembly\n', '              length := extcodesize(_addr)\n', '          }\n', '          if(length>0) {\n', '              return true;\n', '          }\n', '          else {\n', '              return false;\n', '          }\n', '    }\n', '}\n', '\n', 'contract ERC23StandardToken is ERC23BasicToken {\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    event Approval (address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) {\n', '        var _allowance = allowed[_from][msg.sender];\n', '\n', '        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '        // if (_value > _allowance) throw;\n', '\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) {\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '// Based in part on code by Open-Zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git\n', '// Based in part on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', 'contract OpusToken is ERC23StandardToken {\n', '    string public constant name = "Opus Token";\n', '    string public constant symbol = "OPT";\n', '    uint256 public constant decimals = 18;\n', '    address public multisig=address(0x1426c1f91b923043F7C5FbabC6e369e7cBaef3f0); //multisig wallet, to which all contributions will be sent\n', '    address public foundation; //owner address\n', '    address public candidate; //owner candidate in 2-phase ownership transfer\n', '\n', '    mapping (address => uint256) contributions; //keeps track of ether contributions in Wei of each contributor address\n', '    uint256 public startBlock = 4023333; //pre-crowdsale start block (30min ealier than estimate) \n', '    uint256 public preEndBlock = 4057233; //pre-crowdsale end block(1h after estimated time)\n', '    uint256 public phase1StartBlock = 4066633; //Crowdsale start block (1h earlier)\n', '    uint256 public phase1EndBlock = 4100233; //Week 1 end block (estimate)\n', '    uint256 public phase2EndBlock = 4133833; //Week 2 end block (estimate)\n', '    uint256 public phase3EndBlock = 4201433; //Week 4 end block (2h later)\n', '    uint256 public endBlock = 4201433; //whole crowdsale end block\n', '    uint256 public crowdsaleTokenSupply = 900000000 * (10**18); //Amount of tokens for sale during crowdsale\n', '    uint256 public ecosystemTokenSupply = 100000000 * (10**18); //Tokens for supporting the Opus eco-system, e.g. purchasing music licenses, artist bounties, etc.\n', '    uint256 public foundationTokenSupply = 600000000 * (10**18); //Tokens distributed to the Opus foundation, developers and angel investors\n', '    uint256 public crowdsaleTokenSold = 0; //Keeps track of the amount of tokens sold during the crowdsale\n', '    uint256 public presaleEtherRaised = 0; //Keeps track of the Ether raised during the crowdsale\n', '    uint256 public transferLockup = 9600;\n', '    bool public halted = false; //Halt crowdsale in emergency\n', '    event Halt(); //Halt event\n', '    event Unhalt(); //Unhalt event\n', '\n', '    modifier onlyFoundation() {\n', '        //only do if call is from owner modifier\n', '        if (msg.sender != foundation) throw;\n', '        _;\n', '    }\n', '\n', '    modifier crowdsaleTransferLock() {\n', '        // lockup during and after 48h of end of crowdsale\n', '        if (block.number <= endBlock.add(transferLockup)) throw;\n', '        _;\n', '    }\n', '\n', '    modifier whenNotHalted() {\n', '        // only do when not halted modifier\n', '        if (halted) throw;\n', '        _;\n', '    }\n', '\n', '    //Constructor: set multisig crowdsale recipient wallet address and fund the foundation\n', '    //Initialize total supply and allocate ecosystem & foundation tokens\n', '  \tfunction OpusToken() {\n', '        foundation = msg.sender;\n', '        totalSupply = ecosystemTokenSupply.add(foundationTokenSupply);\n', '        balances[foundation] = totalSupply;\n', '  \t}\n', '\n', '    //Fallback function when receiving Ether.\n', '    function() payable {\n', '        buy();\n', '    }\n', '\n', '\n', '    //Halt ICO in case of emergency.\n', '    function halt() onlyFoundation {\n', '        halted = true;\n', '        Halt();\n', '    }\n', '\n', '    function unhalt() onlyFoundation {\n', '        halted = false;\n', '        Unhalt();\n', '    }\n', '\n', '    function buy() payable {\n', '        buyRecipient(msg.sender);\n', '    }\n', '\n', '    //Allow addresses to buy token for another account\n', '    function buyRecipient(address recipient) public payable whenNotHalted {\n', '        if(msg.value == 0) throw;\n', '        if(!(preCrowdsaleOn()||crowdsaleOn())) throw;//only allows during presale/crowdsale\n', '        if(contributions[recipient].add(msg.value)>perAddressCap()) throw;//per address cap\n', '        uint256 tokens = msg.value.mul(returnRate()); //decimals=18, so no need to adjust for unit\n', '        if(crowdsaleTokenSold.add(tokens)>crowdsaleTokenSupply) throw;//max supply limit\n', '\n', '        balances[recipient] = balances[recipient].add(tokens);\n', '        totalSupply = totalSupply.add(tokens);\n', '        presaleEtherRaised = presaleEtherRaised.add(msg.value);\n', '        contributions[recipient] = contributions[recipient].add(msg.value);\n', '        crowdsaleTokenSold = crowdsaleTokenSold.add(tokens);\n', '        if(crowdsaleTokenSold == crowdsaleTokenSupply){\n', '        //If crowdsale token sold out, end crowdsale\n', '            if(block.number < preEndBlock) {\n', '                preEndBlock = block.number;\n', '            }\n', '            endBlock = block.number;\n', '        }\n', '        if (!multisig.send(msg.value)) throw; //immediately send Ether to multisig address\n', '        Transfer(this, recipient, tokens);\n', '    }\n', '\n', '    //Burns the specified amount of tokens from the foundation\n', '    //Used to burn unspent funds in foundation DAO\n', '    function burn(uint256 _value) external onlyFoundation returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Transfer(msg.sender, address(0), _value);\n', '        return true;\n', '    }\n', '\n', '    //2-phase ownership transfer;\n', '    //prevent transferring ownership to non-existent addresses by accident.\n', '    function proposeFoundationTransfer(address newFoundation) external onlyFoundation {\n', '        //propose new owner\n', '        candidate = newFoundation;\n', '    }\n', '\n', '    function cancelFoundationTransfer() external onlyFoundation {\n', '        candidate = address(0);\n', '    }\n', '\n', '    function acceptFoundationTransfer() external {\n', '        //new owner accept transfer to complete transfer\n', '        if(msg.sender != candidate) throw;\n', '        foundation = candidate;\n', '        candidate = address(0);\n', '    }\n', '\n', '    //Allow to change the recipient multisig address\n', '    function setMultisig(address addr) external onlyFoundation {\n', '      \tif (addr == address(0)) throw;\n', '      \tmultisig = addr;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value, bytes _data) public crowdsaleTransferLock returns (bool success) {\n', '        return super.transfer(_to, _value, _data);\n', '    }\n', '\n', '\t  function transfer(address _to, uint256 _value) public crowdsaleTransferLock {\n', '        super.transfer(_to, _value);\n', '\t  }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public crowdsaleTransferLock {\n', '        super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    //Return rate of token against ether.\n', '    function returnRate() public constant returns(uint256) {\n', '        if (block.number>=startBlock && block.number<=preEndBlock) return 8888; //Pre-crowdsale\n', '        if (block.number>=phase1StartBlock && block.number<=phase1EndBlock) return 8000; //Crowdsale phase1\n', '        if (block.number>phase1EndBlock && block.number<=phase2EndBlock) return 7500; //Phase2\n', '        if (block.number>phase2EndBlock && block.number<=phase3EndBlock) return 7000; //Phase3\n', '    }\n', '\n', '    //per address cap in Wei: 1000 ether + 1% of ether received at the given time.\n', '    function perAddressCap() public constant returns(uint256) {\n', '        uint256 baseline = 1000 * (10**18);\n', '        return baseline.add(presaleEtherRaised.div(100));\n', '    }\n', '\n', '    function preCrowdsaleOn() public constant returns (bool) {\n', '        //return whether presale is on according to block number\n', '        return (block.number>=startBlock && block.number<=preEndBlock);\n', '    }\n', '\n', '    function crowdsaleOn() public constant returns (bool) {\n', '        //return whether crowdsale is on according to block number\n', '        return (block.number>=phase1StartBlock && block.number<=endBlock);\n', '    }\n', '\n', '\n', '    function getEtherRaised() external constant returns (uint256) {\n', '        //getter function for etherRaised\n', '        return presaleEtherRaised;\n', '    }\n', '\n', '    function getTokenSold() external constant returns (uint256) {\n', '        //getter function for crowdsaleTokenSold\n', '        return crowdsaleTokenSold;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.8;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' * By OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/contracts/SafeMath.sol\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    if(!(a == 0 || c / a == b)) throw;\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    if(!(b <= a)) throw;\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    if(!(c >= a)) throw;\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', 'contract ContractReceiver{\n', '    function tokenFallback(address _from, uint256 _value, bytes  _data) external;\n', '}\n', '\n', '\n', '//Basic ERC23 token, backward compatible with ERC20 transfer function.\n', '//Based in part on code by open-zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git\n', 'contract ERC23BasicToken {\n', '    using SafeMath for uint256;\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) balances;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '    function tokenFallback(address _from, uint256 _value, bytes  _data) external {\n', '        throw;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value, bytes _data) returns (bool success) {\n', '\n', '        //Standard ERC23 transfer function\n', '\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, _data);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) {\n', '\n', '        //standard function transfer similar to ERC20 transfer with no _data\n', '        //added due to backwards compatibility reasons\n', '\n', '        bytes memory empty;\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, empty);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, empty);\n', '        }\n', '    }\n', '\n', '    function transferToAddress(address _to, uint256 _value, bytes _data) internal {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '     }\n', '\n', '    function transferToContract(address _to, uint256 _value, bytes _data) internal {\n', '        balances[msg.sender] = balances[msg.sender].sub( _value);\n', '        balances[_to] = balances[_to].add( _value);\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        Transfer(msg.sender, _to, _value);    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) returns (bool is_contract) {\n', '          uint256 length;\n', '          assembly {\n', '              //retrieve the size of the code on target address, this needs assembly\n', '              length := extcodesize(_addr)\n', '          }\n', '          if(length>0) {\n', '              return true;\n', '          }\n', '          else {\n', '              return false;\n', '          }\n', '    }\n', '}\n', '\n', 'contract ERC23StandardToken is ERC23BasicToken {\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    event Approval (address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) {\n', '        var _allowance = allowed[_from][msg.sender];\n', '\n', '        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '        // if (_value > _allowance) throw;\n', '\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) {\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '// Based in part on code by Open-Zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git\n', '// Based in part on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', 'contract OpusToken is ERC23StandardToken {\n', '    string public constant name = "Opus Token";\n', '    string public constant symbol = "OPT";\n', '    uint256 public constant decimals = 18;\n', '    address public multisig=address(0x1426c1f91b923043F7C5FbabC6e369e7cBaef3f0); //multisig wallet, to which all contributions will be sent\n', '    address public foundation; //owner address\n', '    address public candidate; //owner candidate in 2-phase ownership transfer\n', '\n', '    mapping (address => uint256) contributions; //keeps track of ether contributions in Wei of each contributor address\n', '    uint256 public startBlock = 4023333; //pre-crowdsale start block (30min ealier than estimate) \n', '    uint256 public preEndBlock = 4057233; //pre-crowdsale end block(1h after estimated time)\n', '    uint256 public phase1StartBlock = 4066633; //Crowdsale start block (1h earlier)\n', '    uint256 public phase1EndBlock = 4100233; //Week 1 end block (estimate)\n', '    uint256 public phase2EndBlock = 4133833; //Week 2 end block (estimate)\n', '    uint256 public phase3EndBlock = 4201433; //Week 4 end block (2h later)\n', '    uint256 public endBlock = 4201433; //whole crowdsale end block\n', '    uint256 public crowdsaleTokenSupply = 900000000 * (10**18); //Amount of tokens for sale during crowdsale\n', '    uint256 public ecosystemTokenSupply = 100000000 * (10**18); //Tokens for supporting the Opus eco-system, e.g. purchasing music licenses, artist bounties, etc.\n', '    uint256 public foundationTokenSupply = 600000000 * (10**18); //Tokens distributed to the Opus foundation, developers and angel investors\n', '    uint256 public crowdsaleTokenSold = 0; //Keeps track of the amount of tokens sold during the crowdsale\n', '    uint256 public presaleEtherRaised = 0; //Keeps track of the Ether raised during the crowdsale\n', '    uint256 public transferLockup = 9600;\n', '    bool public halted = false; //Halt crowdsale in emergency\n', '    event Halt(); //Halt event\n', '    event Unhalt(); //Unhalt event\n', '\n', '    modifier onlyFoundation() {\n', '        //only do if call is from owner modifier\n', '        if (msg.sender != foundation) throw;\n', '        _;\n', '    }\n', '\n', '    modifier crowdsaleTransferLock() {\n', '        // lockup during and after 48h of end of crowdsale\n', '        if (block.number <= endBlock.add(transferLockup)) throw;\n', '        _;\n', '    }\n', '\n', '    modifier whenNotHalted() {\n', '        // only do when not halted modifier\n', '        if (halted) throw;\n', '        _;\n', '    }\n', '\n', '    //Constructor: set multisig crowdsale recipient wallet address and fund the foundation\n', '    //Initialize total supply and allocate ecosystem & foundation tokens\n', '  \tfunction OpusToken() {\n', '        foundation = msg.sender;\n', '        totalSupply = ecosystemTokenSupply.add(foundationTokenSupply);\n', '        balances[foundation] = totalSupply;\n', '  \t}\n', '\n', '    //Fallback function when receiving Ether.\n', '    function() payable {\n', '        buy();\n', '    }\n', '\n', '\n', '    //Halt ICO in case of emergency.\n', '    function halt() onlyFoundation {\n', '        halted = true;\n', '        Halt();\n', '    }\n', '\n', '    function unhalt() onlyFoundation {\n', '        halted = false;\n', '        Unhalt();\n', '    }\n', '\n', '    function buy() payable {\n', '        buyRecipient(msg.sender);\n', '    }\n', '\n', '    //Allow addresses to buy token for another account\n', '    function buyRecipient(address recipient) public payable whenNotHalted {\n', '        if(msg.value == 0) throw;\n', '        if(!(preCrowdsaleOn()||crowdsaleOn())) throw;//only allows during presale/crowdsale\n', '        if(contributions[recipient].add(msg.value)>perAddressCap()) throw;//per address cap\n', '        uint256 tokens = msg.value.mul(returnRate()); //decimals=18, so no need to adjust for unit\n', '        if(crowdsaleTokenSold.add(tokens)>crowdsaleTokenSupply) throw;//max supply limit\n', '\n', '        balances[recipient] = balances[recipient].add(tokens);\n', '        totalSupply = totalSupply.add(tokens);\n', '        presaleEtherRaised = presaleEtherRaised.add(msg.value);\n', '        contributions[recipient] = contributions[recipient].add(msg.value);\n', '        crowdsaleTokenSold = crowdsaleTokenSold.add(tokens);\n', '        if(crowdsaleTokenSold == crowdsaleTokenSupply){\n', '        //If crowdsale token sold out, end crowdsale\n', '            if(block.number < preEndBlock) {\n', '                preEndBlock = block.number;\n', '            }\n', '            endBlock = block.number;\n', '        }\n', '        if (!multisig.send(msg.value)) throw; //immediately send Ether to multisig address\n', '        Transfer(this, recipient, tokens);\n', '    }\n', '\n', '    //Burns the specified amount of tokens from the foundation\n', '    //Used to burn unspent funds in foundation DAO\n', '    function burn(uint256 _value) external onlyFoundation returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Transfer(msg.sender, address(0), _value);\n', '        return true;\n', '    }\n', '\n', '    //2-phase ownership transfer;\n', '    //prevent transferring ownership to non-existent addresses by accident.\n', '    function proposeFoundationTransfer(address newFoundation) external onlyFoundation {\n', '        //propose new owner\n', '        candidate = newFoundation;\n', '    }\n', '\n', '    function cancelFoundationTransfer() external onlyFoundation {\n', '        candidate = address(0);\n', '    }\n', '\n', '    function acceptFoundationTransfer() external {\n', '        //new owner accept transfer to complete transfer\n', '        if(msg.sender != candidate) throw;\n', '        foundation = candidate;\n', '        candidate = address(0);\n', '    }\n', '\n', '    //Allow to change the recipient multisig address\n', '    function setMultisig(address addr) external onlyFoundation {\n', '      \tif (addr == address(0)) throw;\n', '      \tmultisig = addr;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value, bytes _data) public crowdsaleTransferLock returns (bool success) {\n', '        return super.transfer(_to, _value, _data);\n', '    }\n', '\n', '\t  function transfer(address _to, uint256 _value) public crowdsaleTransferLock {\n', '        super.transfer(_to, _value);\n', '\t  }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public crowdsaleTransferLock {\n', '        super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    //Return rate of token against ether.\n', '    function returnRate() public constant returns(uint256) {\n', '        if (block.number>=startBlock && block.number<=preEndBlock) return 8888; //Pre-crowdsale\n', '        if (block.number>=phase1StartBlock && block.number<=phase1EndBlock) return 8000; //Crowdsale phase1\n', '        if (block.number>phase1EndBlock && block.number<=phase2EndBlock) return 7500; //Phase2\n', '        if (block.number>phase2EndBlock && block.number<=phase3EndBlock) return 7000; //Phase3\n', '    }\n', '\n', '    //per address cap in Wei: 1000 ether + 1% of ether received at the given time.\n', '    function perAddressCap() public constant returns(uint256) {\n', '        uint256 baseline = 1000 * (10**18);\n', '        return baseline.add(presaleEtherRaised.div(100));\n', '    }\n', '\n', '    function preCrowdsaleOn() public constant returns (bool) {\n', '        //return whether presale is on according to block number\n', '        return (block.number>=startBlock && block.number<=preEndBlock);\n', '    }\n', '\n', '    function crowdsaleOn() public constant returns (bool) {\n', '        //return whether crowdsale is on according to block number\n', '        return (block.number>=phase1StartBlock && block.number<=endBlock);\n', '    }\n', '\n', '\n', '    function getEtherRaised() external constant returns (uint256) {\n', '        //getter function for etherRaised\n', '        return presaleEtherRaised;\n', '    }\n', '\n', '    function getTokenSold() external constant returns (uint256) {\n', '        //getter function for crowdsaleTokenSold\n', '        return crowdsaleTokenSold;\n', '    }\n', '\n', '}']
