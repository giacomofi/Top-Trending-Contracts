['//! FeeRegistrar contract.\n', '//! By Parity Technologies, 2017.\n', '//! Released under the Apache Licence 2.\n', '\n', 'pragma solidity ^0.4.16;\n', '\n', '// From Owned.sol\n', 'contract Owned {\n', '  /// STORAGE\n', '  address public owner = msg.sender;\n', '\n', '  /// EVENTS\n', '  event NewOwner(address indexed old, address indexed current);\n', '\n', '  /// MODIFIERS\n', '  modifier only_owner { require (msg.sender == owner); _; }\n', '\n', '  /// RESTRICTED PUBLIC METHODS\n', '  function setOwner(address _new) public only_owner { NewOwner(owner, _new); owner = _new; }\n', '}\n', '\n', '/// @title Delegated Contract\n', '/// @notice This contract can be used to have a a system of delegates\n', '/// who can be authorized to execute certain methods. A (super-)owner\n', '/// is set, who can modify the delegates.\n', 'contract Delegated is Owned {\n', '  /// STORAGE\n', '  mapping (address => bool) delegates;\n', '\n', '  /// MODIFIERS\n', '  modifier only_delegate { require (msg.sender == owner || delegates[msg.sender]); _; }\n', '\n', '  /// PUBLIC METHODS\n', '  function delegate(address who) public constant returns (bool) { return who == owner || delegates[who]; }\n', '\n', '  /// RESTRICTED PUBLIC METHODS\n', '  function addDelegate(address _new) public only_owner { delegates[_new] = true; }\n', '  function removeDelegate(address _old) public only_owner { delete delegates[_old]; }\n', '}\n', '\n', '/// @title Fee Registrar\n', '/// @author Nicolas Gotchac <nicolas@parity.io>\n', '/// @notice This contract records fee payments. The address who deploys the contract\n', '/// is set as the `owner` of the contract (which can be later modified). The `fee`\n', '/// which users will have to pay must be specified, as well as the address of the treasury\n', '/// to which the fee will be forwarded to.\n', '/// A payment is a transaction with the value set as the `fee` value, and an address is\n', '/// given as an argument. The given address will be marked as _paid for_, and the number\n', '/// of times it was paid for will be recorded. We also record who is at the origin of the\n', '/// payment.\n', '/// For example, Alice can pay for Bob, and Eve can pay for Bob as well. This contract\n', '/// will record that Bob is marked as paid, 2 times, by Alice and Eve.\n', '/// A payment can be revoked by specified delegates, and the fund should be restored to\n', '/// the payer of the fee.\n', 'contract FeeRegistrar is Delegated {\n', '  /// STORAGE\n', '  address public treasury;\n', '  uint public fee;\n', '\n', '  // a mapping of addresses to the origin of payments struct\n', '  mapping(address => address[]) s_paid;\n', '\n', '\n', '  /// EVENTS\n', '  event Paid (address who, address payer);\n', '\n', '\n', '  /// CONSTRUCTOR\n', '\n', '  /// @notice Contructor method of the contract, which\n', '  /// will set the `treasury` where payments will be send to,\n', '  /// and the `fee` users have to pay\n', '  /// @param _treasury The address to which the payments will be forwarded\n', '  /// @param _fee The fee users have to pay, in wei\n', '  function FeeRegistrar (address _treasury, uint _fee) public {\n', '    owner = msg.sender;\n', '    treasury = _treasury;\n', '    fee = _fee;\n', '  }\n', '\n', '\n', '  /// PUBLIC CONSTANT METHODS\n', '\n', '  /// @notice Returns for the given address the number of times\n', '  /// it was paid for, and an array of addresses who actually paid for the fee\n', '  /// (as one might pay the fee for another address)\n', '  /// @param who The address of the payer whose info we check\n', '  /// @return The count (number of payments) and the origins (the senders of the\n', '  /// payment)\n', '  function payer (address who) public constant returns (uint count, address[] origins) {\n', '    address[] memory m_origins = s_paid[who];\n', '\n', '    return (m_origins.length, m_origins);\n', '  }\n', '\n', '  /// @notice Returns whether the given address paid or not\n', '  /// @param who The address whose payment status we check\n', '  /// @ return Whether the address is marked as paid or not\n', '  function paid (address who) public constant returns (bool) {\n', '    return s_paid[who].length > 0;\n', '  }\n', '\n', '\n', '  /// PUBLIC METHODS\n', '\n', '  /// @notice This method is used to pay for the fee. You can pay\n', '  /// the fee for one address (then marked as paid), from another\n', '  /// address. The origin of the transaction, the\n', '  /// fee payer (`msg.sender`) is stored in an array.\n', '  /// The value of the transaction must\n', '  /// match the fee that was set in the contructor.\n', "  /// The only restriction is that you can't pay for the null\n", '  /// address.\n', "  /// You also can't pay more than 10 times for the same address\n", '  /// The value that is received is directly transfered to the\n', '  /// `treasury`.\n', '  /// @param who The address which should be marked as paid.\n', '  function pay (address who) external payable {\n', '    // We first check that the given address is not the null address\n', '    require(who != 0x0);\n', '    // Then check that the value matches with the fee\n', '    require(msg.value == fee);\n', '    // Maximum 10 payments per address\n', '    require(s_paid[who].length < 10);\n', '\n', '    s_paid[who].push(msg.sender);\n', '\n', '    // Send the paid event\n', '    Paid(who, msg.sender);\n', '\n', '    // Send the message value to the treasury\n', '    treasury.transfer(msg.value);\n', '  }\n', '\n', '\n', '  /// RESTRICTED (owner or delegate only) PUBLIC METHODS\n', '\n', '  /// @notice This method can only be called by the contract\n', '  /// owner, and can be used to virtually create a new payment,\n', '  /// by `origin` for `who`.\n', '  /// @param who The address that `origin` paid for\n', '  /// @param origin The virtual sender of the payment\n', '  function inject (address who, address origin) external only_owner {\n', '    // Add the origin address to the list of payers\n', '    s_paid[who].push(origin);\n', '    // Emit the `Paid` event\n', '    Paid(who, origin);\n', '  }\n', '\n', '  /// @notice This method can be called by authorized persons only,\n', '  /// and can issue a refund of the fee to the `origin` address who\n', '  /// paid the fee for `who`.\n', '  /// @param who The address that `origin` paid for\n', '  /// @param origin The sender of the payment, to which we shall\n', '  /// send the refund\n', '  function revoke (address who, address origin) payable external only_delegate {\n', '    // The value must match the current fee, so we can refund\n', "    // the payer, since the contract doesn't hold anything.\n", '    require(msg.value == fee);\n', '    bool found;\n', '\n', '    // Go through the list of payers to find\n', '    // the remove the right one\n', '    // NB : this list is limited to 10 items,\n', '    //      @see the `pay` method\n', '    for (uint i = 0; i < s_paid[who].length; i++) {\n', '      if (s_paid[who][i] != origin) {\n', '        continue;\n', '      }\n', '\n', '      // If the origin payer is found\n', '      found = true;\n', '\n', '      uint last = s_paid[who].length - 1;\n', '\n', '      // Switch the last element of the array\n', '      // with the one to remove\n', '      s_paid[who][i] = s_paid[who][last];\n', '\n', '      // Remove the last element of the array\n', '      delete s_paid[who][last];\n', '      s_paid[who].length -= 1;\n', '\n', '      break;\n', '    }\n', '\n', '    // Ensure that the origin payer has been found\n', '    require(found);\n', '\n', '    // Refund the fee to the origin payer\n', '    origin.transfer(msg.value);\n', '  }\n', '\n', '  /// @notice Change the address of the treasury, the address to which\n', '  /// the payments are forwarded to. Only the owner of the contract\n', '  /// can execute this method.\n', '  /// @param _treasury The new treasury address\n', '  function setTreasury (address _treasury) external only_owner {\n', '    treasury = _treasury;\n', '  }\n', '}']