['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Contracts that should not own Contracts\n', ' * @author Remco Bloemen <<span class="__cf_email__" data-cfemail="8efcebe3ede1cebc">[email&#160;protected]</span>π.com>\n', ' * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\n', ' * of this contract to reclaim ownership of the contracts.\n', ' */\n', 'contract HasNoContracts is Ownable {\n', '\n', '  /**\n', '   * @dev Reclaim ownership of Ownable contracts\n', '   * @param contractAddr The address of the Ownable to be reclaimed.\n', '   */\n', '  function reclaimContract(address contractAddr) external onlyOwner {\n', '    Ownable contractInst = Ownable(contractAddr);\n', '    contractInst.transferOwnership(owner);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Contracts that should not own Tokens\n', ' * @author Remco Bloemen <<span class="__cf_email__" data-cfemail="83f1e6eee0ecc3b1">[email&#160;protected]</span>π.com>\n', ' * @dev This blocks incoming ERC23 tokens to prevent accidental loss of tokens.\n', ' * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\n', ' * owner to reclaim the tokens.\n', ' */\n', 'contract reclaimTokens is Ownable {\n', '\n', '  /**\n', '   * @dev Reclaim all ERC20Basic compatible tokens\n', '   * @param tokenAddr address The address of the token contract\n', '   */\n', '  function reclaimToken(address tokenAddr) external onlyOwner {\n', '    ERC20Basic tokenInst = ERC20Basic(tokenAddr);\n', '    uint256 balance = tokenInst.balanceOf(this);\n', '    tokenInst.transfer(owner, balance);\n', '  }\n', '}\n', '\n', 'contract ExperimentalPreICO is reclaimTokens, HasNoContracts {\n', '  using SafeMath for uint256;\n', '\n', '  address public beneficiary;\n', '  bool public fundingGoalReached = false;\n', '  bool public crowdsaleClosed = false;\n', '  ERC20Basic public rewardToken;\n', '  uint256 public fundingGoal;\n', '  uint256 public fundingCap;\n', '  uint256 public paymentMin;\n', '  uint256 public paymentMax;\n', '  uint256 public amountRaised;\n', '  uint256 public rate;\n', '\n', '  mapping(address => uint256) public balanceOf;\n', '  mapping(address => bool) public whitelistedAddresses;\n', '  event GoalReached(address beneficiaryAddress, uint256 amount);\n', '  event FundTransfer(address backer, uint256 amount, bool isContribution);\n', '\n', '  /**\n', '   * @dev data structure to hold information about campaign contributors\n', '   */\n', '  function ExperimentalPreICO(address _wallet,\n', '                              uint256 _goalInEthers,\n', '                              uint256 _capInEthers,\n', '                              uint256 _minPaymentInEthers,\n', '                              uint256 _maxPaymentInEthers,\n', '                              uint256 _rate,\n', '                              address _rewardToken) {\n', '    require(_goalInEthers > 0);\n', '    require(_capInEthers >= _goalInEthers);\n', '    require(_minPaymentInEthers > 0);\n', '    require(_maxPaymentInEthers > _minPaymentInEthers);\n', '    require(_rate > 0);\n', '    require(_wallet != 0x0);\n', '    beneficiary = _wallet;\n', '    fundingGoal = _goalInEthers.mul(1 ether);\n', '    fundingCap = _capInEthers.mul(1 ether);\n', '    paymentMin = _minPaymentInEthers.mul(1 ether);\n', '    paymentMax = _maxPaymentInEthers.mul(1 ether);\n', '    rate = _rate;\n', '    rewardToken = ERC20Basic(_rewardToken);\n', '  }\n', '\n', '  /**\n', '   * @dev The default function that is called whenever anyone sends funds to the contract\n', '   */\n', '  function () external payable crowdsaleActive {\n', '    require(validPurchase());\n', '\n', '    uint256 amount = msg.value;\n', '    balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);\n', '    amountRaised = amountRaised.add(amount);\n', '    rewardToken.transfer(msg.sender, amount.mul(rate));\n', '    FundTransfer(msg.sender, amount, true);\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called when crowdsale is still open.\n', '   */\n', '  modifier crowdsaleEnded() {\n', '    require(crowdsaleClosed == true);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called when crowdsale has closed.\n', '   */\n', '  modifier crowdsaleActive() {\n', '    require(crowdsaleClosed == false);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev return true if the transaction can buy tokens\n', '   */\n', '  function validPurchase() internal returns (bool) {\n', '    bool whitelisted = whitelistedAddresses[msg.sender] == true;\n', '    bool validAmmount = msg.value >= paymentMin && msg.value <= paymentMax;\n', '    bool availableFunding = fundingCap >= amountRaised.add(msg.value);\n', '    return whitelisted && validAmmount && availableFunding;\n', '  }\n', '\n', '  /**\n', '   * @dev checks if the goal has been reached\n', '   */\n', '  function checkGoal() external onlyOwner {\n', '    if (amountRaised >= fundingGoal){\n', '      fundingGoalReached = true;\n', '      GoalReached(beneficiary, amountRaised);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev ends or resumes the crowdsale\n', '   */\n', '  function endCrowdsale() external onlyOwner {\n', '    crowdsaleClosed = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows backers to withdraw their funds in the crowdsale was unsuccessful,\n', '   * and allow the owner to send the amount raised to the beneficiary\n', '   */\n', '  function safeWithdrawal() external crowdsaleEnded {\n', '    if (!fundingGoalReached) {\n', '      uint256 amount = balanceOf[msg.sender];\n', '      balanceOf[msg.sender] = 0;\n', '      if (amount > 0) {\n', '        if (msg.sender.send(amount)) {\n', '          FundTransfer(msg.sender, amount, false);\n', '        } else {\n', '          balanceOf[msg.sender] = amount;\n', '        }\n', '      }\n', '    }\n', '\n', '    if (fundingGoalReached && owner == msg.sender) {\n', '      if (beneficiary.send(amountRaised)) {\n', '        FundTransfer(beneficiary, amountRaised, false);\n', '      } else {\n', '        //If we fail to send the funds to beneficiary, unlock funders balance\n', '        fundingGoalReached = false;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Whitelists a list of addresses\n', '   */\n', '  function whitelistAddress (address[] addresses) external onlyOwner crowdsaleActive {\n', '    for (uint i = 0; i < addresses.length; i++) {\n', '      whitelistedAddresses[addresses[i]] = true;\n', '    }\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Contracts that should not own Contracts\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\n', ' * of this contract to reclaim ownership of the contracts.\n', ' */\n', 'contract HasNoContracts is Ownable {\n', '\n', '  /**\n', '   * @dev Reclaim ownership of Ownable contracts\n', '   * @param contractAddr The address of the Ownable to be reclaimed.\n', '   */\n', '  function reclaimContract(address contractAddr) external onlyOwner {\n', '    Ownable contractInst = Ownable(contractAddr);\n', '    contractInst.transferOwnership(owner);\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Contracts that should not own Tokens\n', ' * @author Remco Bloemen <remco@2π.com>\n', ' * @dev This blocks incoming ERC23 tokens to prevent accidental loss of tokens.\n', ' * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\n', ' * owner to reclaim the tokens.\n', ' */\n', 'contract reclaimTokens is Ownable {\n', '\n', '  /**\n', '   * @dev Reclaim all ERC20Basic compatible tokens\n', '   * @param tokenAddr address The address of the token contract\n', '   */\n', '  function reclaimToken(address tokenAddr) external onlyOwner {\n', '    ERC20Basic tokenInst = ERC20Basic(tokenAddr);\n', '    uint256 balance = tokenInst.balanceOf(this);\n', '    tokenInst.transfer(owner, balance);\n', '  }\n', '}\n', '\n', 'contract ExperimentalPreICO is reclaimTokens, HasNoContracts {\n', '  using SafeMath for uint256;\n', '\n', '  address public beneficiary;\n', '  bool public fundingGoalReached = false;\n', '  bool public crowdsaleClosed = false;\n', '  ERC20Basic public rewardToken;\n', '  uint256 public fundingGoal;\n', '  uint256 public fundingCap;\n', '  uint256 public paymentMin;\n', '  uint256 public paymentMax;\n', '  uint256 public amountRaised;\n', '  uint256 public rate;\n', '\n', '  mapping(address => uint256) public balanceOf;\n', '  mapping(address => bool) public whitelistedAddresses;\n', '  event GoalReached(address beneficiaryAddress, uint256 amount);\n', '  event FundTransfer(address backer, uint256 amount, bool isContribution);\n', '\n', '  /**\n', '   * @dev data structure to hold information about campaign contributors\n', '   */\n', '  function ExperimentalPreICO(address _wallet,\n', '                              uint256 _goalInEthers,\n', '                              uint256 _capInEthers,\n', '                              uint256 _minPaymentInEthers,\n', '                              uint256 _maxPaymentInEthers,\n', '                              uint256 _rate,\n', '                              address _rewardToken) {\n', '    require(_goalInEthers > 0);\n', '    require(_capInEthers >= _goalInEthers);\n', '    require(_minPaymentInEthers > 0);\n', '    require(_maxPaymentInEthers > _minPaymentInEthers);\n', '    require(_rate > 0);\n', '    require(_wallet != 0x0);\n', '    beneficiary = _wallet;\n', '    fundingGoal = _goalInEthers.mul(1 ether);\n', '    fundingCap = _capInEthers.mul(1 ether);\n', '    paymentMin = _minPaymentInEthers.mul(1 ether);\n', '    paymentMax = _maxPaymentInEthers.mul(1 ether);\n', '    rate = _rate;\n', '    rewardToken = ERC20Basic(_rewardToken);\n', '  }\n', '\n', '  /**\n', '   * @dev The default function that is called whenever anyone sends funds to the contract\n', '   */\n', '  function () external payable crowdsaleActive {\n', '    require(validPurchase());\n', '\n', '    uint256 amount = msg.value;\n', '    balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);\n', '    amountRaised = amountRaised.add(amount);\n', '    rewardToken.transfer(msg.sender, amount.mul(rate));\n', '    FundTransfer(msg.sender, amount, true);\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called when crowdsale is still open.\n', '   */\n', '  modifier crowdsaleEnded() {\n', '    require(crowdsaleClosed == true);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called when crowdsale has closed.\n', '   */\n', '  modifier crowdsaleActive() {\n', '    require(crowdsaleClosed == false);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev return true if the transaction can buy tokens\n', '   */\n', '  function validPurchase() internal returns (bool) {\n', '    bool whitelisted = whitelistedAddresses[msg.sender] == true;\n', '    bool validAmmount = msg.value >= paymentMin && msg.value <= paymentMax;\n', '    bool availableFunding = fundingCap >= amountRaised.add(msg.value);\n', '    return whitelisted && validAmmount && availableFunding;\n', '  }\n', '\n', '  /**\n', '   * @dev checks if the goal has been reached\n', '   */\n', '  function checkGoal() external onlyOwner {\n', '    if (amountRaised >= fundingGoal){\n', '      fundingGoalReached = true;\n', '      GoalReached(beneficiary, amountRaised);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev ends or resumes the crowdsale\n', '   */\n', '  function endCrowdsale() external onlyOwner {\n', '    crowdsaleClosed = true;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows backers to withdraw their funds in the crowdsale was unsuccessful,\n', '   * and allow the owner to send the amount raised to the beneficiary\n', '   */\n', '  function safeWithdrawal() external crowdsaleEnded {\n', '    if (!fundingGoalReached) {\n', '      uint256 amount = balanceOf[msg.sender];\n', '      balanceOf[msg.sender] = 0;\n', '      if (amount > 0) {\n', '        if (msg.sender.send(amount)) {\n', '          FundTransfer(msg.sender, amount, false);\n', '        } else {\n', '          balanceOf[msg.sender] = amount;\n', '        }\n', '      }\n', '    }\n', '\n', '    if (fundingGoalReached && owner == msg.sender) {\n', '      if (beneficiary.send(amountRaised)) {\n', '        FundTransfer(beneficiary, amountRaised, false);\n', '      } else {\n', '        //If we fail to send the funds to beneficiary, unlock funders balance\n', '        fundingGoalReached = false;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Whitelists a list of addresses\n', '   */\n', '  function whitelistAddress (address[] addresses) external onlyOwner crowdsaleActive {\n', '    for (uint i = 0; i < addresses.length; i++) {\n', '      whitelistedAddresses[addresses[i]] = true;\n', '    }\n', '  }\n', '\n', '}']
