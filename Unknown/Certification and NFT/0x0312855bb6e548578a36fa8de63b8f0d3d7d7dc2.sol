['/*\n', 'Welcome to * Bet On Hash *\n', '\n', 'this is a round based bet game\n', 'a round consists of 6 players\n', '\n', 'you bet on the first byte of the 6th players block hash (unpredictable, 50% chance)\n', '\n', '** to join: send one byte data (0x01 or 0x81) with a bet amount of 1 ether to the contract address\n', '\n', 'if your data byte is less than 0x80 you bet the last players block hash first byte is less than 0x80\n', 'if your data byte is greater than or equal 0x80 you bet the last players block hash first byte is greater than or equal 0x80\n', '\n', 'if you lose your bet your bet amount goes to the pool for winners\n', '\n', 'if you win your bet:\n', '\t* you will get back 100% of your payment\n', '\t* you will win a proportional part of the winner pool (win amount = winner pool / winners - 1%) \n', '\n', '  ** in the best case you can win 4.95 Ether **\n', '\n', 'payout is triggered when a player starts the next round\n', '\n', 'additional rules:\n', 'each address can only play once per round\n', 'every additional payment during the same round will be paid back immediatly\n', 'every payment below the bet value is considered as a donation for the winner pool\n', 'every amount that is exceeding the bet value will be paid back\n', 'if nobody wins in a round, the paid amounts will raise the winner pool for the next round\n', '\n', '** if you pay to the contract, you agree that you may lose (50% chance!) the paid amount **\n', '\n', '*/\n', '\n', 'contract BetOnHashV84 {\n', '  struct Player {\n', '    address addr;\n', '    byte bet;\n', '  }\n', '  \n', '  Player[] public players;\n', '  bool public active;\n', '  uint public betAmount;\n', '  uint public playersPerRound;\n', '  uint public round;\n', '  uint public winPool;\n', '  byte public betByte;\n', '\n', '  uint lastPlayersBlockNumber;\n', '  address owner;\n', '  \n', '  modifier onlyowner { if (msg.sender == owner) _ }\n', '  \n', '  function BetOnHashV84() {\n', '    owner = msg.sender;\n', '    betAmount = 1 ether;\n', '    round = 1;\n', '    playersPerRound = 6;\n', '    active = true;\n', '    winPool = 0;\n', '  }\n', '  \n', '  function finishRound() internal {\n', '    //get block hash of last player\n', '    bytes32 betHash = block.blockhash(lastPlayersBlockNumber);\n', '    betByte = byte(betHash);\n', '    byte bet;\n', '    uint8 ix; \n', '    \n', '    //check win or loss, calculate winnPool\n', '    address[] memory winners = new address[](playersPerRound);\n', '    uint8 numWinners=0;\n', '    for(ix=0; ix < players.length; ix++) {\n', '      Player p = players[ix];\n', '      if(p.bet < 0x80 && betByte < 0x80 || p.bet >= 0x80 && betByte >= 0x80) {\n', '        //player won\n', '        winners[numWinners++] = p.addr;\n', '      } \n', '      else winPool += betAmount;\n', '    }\n', '    \n', '    //calculate winners payouts and pay out\n', '    if(numWinners > 0) {\n', '      uint winAmount = (winPool / numWinners) * 99 / 100;\n', '      for(ix = 0; ix < numWinners; ix++) {\n', '        if(!winners[ix].send(betAmount + winAmount)) throw;\n', '      }\n', '      winPool = 0;\n', '    }\n', '    \n', '    //start next round\n', '    round++;\n', '    delete players;\n', '  }\n', '  \n', '  function reject() internal {\n', '    msg.sender.send(msg.value);\n', '  }\n', '  \n', '  function join() internal {\n', '    //finish round if next players block is above last players block\n', '    if(players.length >= playersPerRound) { \n', '      if(block.number > lastPlayersBlockNumber) finishRound(); \n', '      else {reject(); return;}  //too many players in one block -> pay back\n', '    }\n', '\n', '    //payments below bet amount are considered as donation for the winner pool\n', '    if(msg.value < betAmount) {\n', '      winPool += msg.value; \n', '      return;\n', '    }\n', '    \n', '    //no data sent -> pay back\n', '    if(msg.data.length < 1) {reject();return;}\n', '    \n', '    //prevent players to play more than once per round:\n', '    for(uint8 i = 0; i < players.length; i++)\n', '      if(msg.sender == players[i].addr) {reject(); return;}\n', '    \n', '    //to much paid -> pay back all above bet amount\n', '    if(msg.value > betAmount) {\n', '      msg.sender.send(msg.value - betAmount);\n', '    }\n', '    \n', '    //register player\n', '    players.push( Player(msg.sender, msg.data[0]) );\n', '    lastPlayersBlockNumber = block.number;\n', '  }\n', '  \n', '  function () {\n', '    if(active) join();\n', '    else throw;\n', '  }\n', '  \n', '  function paybackLast() onlyowner returns (bool) {\n', '    if(players.length == 0) return true;\n', '    if (players[players.length - 1].addr.send(betAmount)) {\n', '      players.length--;\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '  \n', '  //if something goes wrong, the owner can trigger pay back\n', '  function paybackAll() onlyowner returns (bool) {\n', '    while(players.length > 0) {if(!paybackLast()) return false;}\n', '    return true;\n', '  }\n', '  \n', '  function collectFees() onlyowner {\n', '    uint playersEther = winPool;\n', '    uint8 ix;\n', '    for(ix=0; ix < players.length; ix++) playersEther += betAmount;\n', '    uint fees = this.balance - playersEther;\n', '    if(fees > 0) owner.send(fees);\n', '  }\n', '  \n', '  function changeOwner(address _owner) onlyowner {\n', '    owner = _owner;\n', '  }\n', '  \n', '  function setPlayersPerRound(uint num) onlyowner {\n', '    if(players.length > 0) finishRound();\n', '    playersPerRound = num;\n', '  }\n', '  \n', '  function stop() onlyowner {\n', '    active = false;\n', '    paybackAll();\n', '  }\n', '  \n', '  function numberOfPlayersInCurrentRound() constant returns (uint count) {\n', '    count = players.length;\n', '  }\n', '\n', '  //contract can only be destructed if all payments where paid back  \n', '  function kill() onlyowner {\n', '    if(!active && paybackAll()) \n', '      selfdestruct(owner);\n', '  }\n', '}']