['pragma solidity ^0.4.16;\n', '\n', '\n', '/**\n', ' * @title WeBetCrypto\n', ' * @author AL_X\n', ' * @dev The WBC ERC-223 Token Contract\n', ' */\n', 'contract WeBetCrypto {\n', '    string public name = "We Bet Crypto";\n', '    string public symbol = "WBC";\n', '\t\n', '    address public selfAddress;\n', '    address public admin;\n', '    address[] private users;\n', '\t\n', '    uint8 public decimals = 7;\n', '    uint256 public relativeDateSave;\n', '    uint256 public totalFunds;\n', '    uint256 public totalSupply = 300000000000000;\n', '    uint256 public pricePerEther;\n', '    uint256 private amountInCirculation;\n', '    uint256 private currentProfits;\n', '    uint256 private currentIteration;\n', '\tuint256 private actualProfitSplit;\n', '\t\n', '    bool public DAppReady;\n', '    bool public isFrozen;\n', '\tbool public splitInService = true;\n', '\tbool private hasICORun;\n', '    bool private running;\n', '\tbool[4] private devApprovals;\n', '\t\n', '    mapping(address => uint256) balances;\n', '    mapping(address => uint256) monthlyLimit;\n', '\t\n', '    mapping(address => bool) isAdded;\n', '    mapping(address => bool) freezeUser;\n', '\t\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\tmapping (address => mapping (address => uint256)) cooldown;\n', '\t\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event CurrentTLSNProof(address indexed _from, string _proof);\n', '    \n', '\t/**\n', '\t * @notice Ensures admin is caller\n', '\t */\n', '    modifier isAdmin() {\n', '        require(msg.sender == admin);\n', '        //Continue executing rest of method body\n', '        _;\n', '    }\n', '    \n', '    /**\n', '\t * @notice Re-entry protection\n', '\t */\n', '    modifier isRunning() {\n', '        require(!running);\n', '        running = true;\n', '        _;\n', '        running = false;\n', '    }\n', '    \n', '\t/**\n', '\t * @notice Ensures system isn&#39;t frozen\n', '\t */\n', '    modifier requireThaw() {\n', '        require(!isFrozen);\n', '        _;\n', '    }\n', '    \n', '\t/**\n', '\t * @notice Ensures player isn&#39;t logged in on platform\n', '\t */\n', '    modifier userNotPlaying(address _user) {\n', '        require(!freezeUser[_user]);\n', '        _;\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Ensures function runs only once\n', '\t */\n', '\tmodifier oneTime() {\n', '\t\trequire(!hasICORun);\n', '\t\t_;\n', '\t}\n', '    \n', '\t/**\n', '\t * @notice Ensures WBC DApp is online\n', '\t */\n', '    modifier DAppOnline() {\n', '        require(DAppReady);\n', '        _;\n', '    }\n', '    \n', '    /**\n', '\t * @notice SafeMath Library safeSub Import\n', '\t * @dev \n', '\t        Since we are dealing with a limited currency\n', '\t        circulation of 30 million tokens and values\n', '\t        that will not surpass the uint256 limit, only\n', '\t        safeSub is required to prevent underflows.\n', '\t */\n', '    function safeSub(uint256 a, uint256 b) internal constant returns (uint256 z) {\n', '        assert((z = a - b) <= a);\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice WBC Constructor\n', '\t * @dev \n', '\t        Constructor function containing proper initializations such as \n', '\t        token distribution to the team members and pushing the first \n', '\t        profit split to 6 months when the DApp will already be live.\n', '\t */\n', '    function WeBetCrypto() {\n', '        admin = msg.sender;\n', '        selfAddress = this;\n', '        balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = 22500000000000;\n', '        addUser(0x166Cb48973C2447dafFA8EFd3526da18076088de);\n', '        Transfer(selfAddress, 0x166Cb48973C2447dafFA8EFd3526da18076088de, 22500000000000);\n', '        balances[0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF] = 15000000000000;\n', '        addUser(0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF);\n', '        Transfer(selfAddress, 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF, 15000000000000);\n', '        balances[0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d] = 5000000000000;\n', '        addUser(0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d);\n', '        Transfer(selfAddress, 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d, 5000000000000);\n', '        balances[0x06908Df389Cf2589375b6908D0b1c8FcC34721B5] = 2500000000000;\n', '        addUser(0x06908Df389Cf2589375b6908D0b1c8FcC34721B5);\n', '        Transfer(selfAddress, 0x06908Df389Cf2589375b6908D0b1c8FcC34721B5, 2500000000000);\n', '        balances[0xEdBd4c6757DC425321584a91bDB355Ce65c42b13] = 2500000000000;\n', '        addUser(0xEdBd4c6757DC425321584a91bDB355Ce65c42b13);\n', '        Transfer(selfAddress, 0xEdBd4c6757DC425321584a91bDB355Ce65c42b13, 2500000000000);\n', '        balances[0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858] = 2500000000000;\n', '        addUser(0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858);\n', '        Transfer(selfAddress, 0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858, 2500000000000);\n', '        relativeDateSave = now + 180 days;\n', '        pricePerEther = 33209;\n', '        balances[selfAddress] = 250000000000000;\n', '    }\n', '    \n', '    /**\n', '     * @notice Check the name of the token ~ ERC-20 Standard\n', '     * @return {\n', '\t\t\t\t\t"_name": "The token name"\n', '\t\t\t\t}\n', '     */\n', '    function name() external constant returns (string _name) {\n', '        return name;\n', '    }\n', '    \n', '\t/**\n', '     * @notice Check the symbol of the token ~ ERC-20 Standard\n', '     * @return {\n', '\t\t\t\t\t"_symbol": "The token symbol"\n', '\t\t\t\t}\n', '     */\n', '    function symbol() external constant returns (string _symbol) {\n', '        return symbol;\n', '    }\n', '    \n', '    /**\n', '     * @notice Check the decimals of the token ~ ERC-20 Standard\n', '     * @return {\n', '\t\t\t\t\t"_decimals": "The token decimals"\n', '\t\t\t\t}\n', '     */\n', '    function decimals() external constant returns (uint8 _decimals) {\n', '        return decimals;\n', '    }\n', '    \n', '    /**\n', '     * @notice Check the total supply of the token ~ ERC-20 Standard\n', '     * @return {\n', '\t\t\t\t\t"_totalSupply": "Total supply of tokens"\n', '\t\t\t\t}\n', '     */\n', '    function totalSupply() external constant returns (uint256 _totalSupply) {\n', '        return totalSupply;\n', '    }\n', '    \n', '    /**\n', '     * @notice Query the available balance of an address ~ ERC-20 Standard\n', '\t * @param _owner The address whose balance we wish to retrieve\n', '     * @return {\n', '\t\t\t\t\t"balance": "Balance of the address"\n', '\t\t\t\t}\n', '     */\n', '    function balanceOf(address _owner) external constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Query the amount of tokens the spender address can withdraw from the owner address ~ ERC-20 Standard\n', '\t * @param _owner The address who owns the tokens\n', '\t * @param _spender The address who can withdraw the tokens\n', '\t * @return {\n', '\t\t\t\t\t"remaining": "Remaining withdrawal amount"\n', '\t\t\t\t}\n', '     */\n', '    function allowance(address _owner, address _spender) external constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    /**\n', '     * @notice Transfer tokens from an address to another ~ ERC-20 Standard\n', '\t * @dev \n', '\t        Adjusts the monthly limit in case the _from address is the Casino\n', '\t        and ensures that the user isn&#39;t logged in when retrieving funds\n', '\t        so as to prevent against a race attack with the Casino.\n', '     * @param _from The address whose balance we will transfer\n', '     * @param _to The recipient address\n', '\t * @param _value The amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) external requireThaw userNotPlaying(_to) {\n', '\t\trequire(cooldown[_from][_to] <= now);\n', '        var _allowance = allowed[_from][_to];\n', '        if (_from == selfAddress) {\n', '            monthlyLimit[_to] = safeSub(monthlyLimit[_to], _value);\n', '        }\n', '        balances[_to] = balances[_to]+_value;\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        allowed[_from][_to] = safeSub(_allowance, _value);\n', '        addUser(_to);\n', '        Transfer(_from, _to, _value);\n', '    }\n', '    \n', '    /**\n', '\t * @notice Authorize an address to retrieve funds from you ~ ERC-20 Standard\n', '\t * @dev \n', '\t        Each approval comes with a default cooldown of 30 minutes\n', '\t        to prevent against the ERC-20 race attack.\n', '\t * @param _spender The address you wish to authorize\n', '\t * @param _value The amount of tokens you wish to authorize\n', '\t */\n', '    function approve(address _spender, uint256 _value) external {\n', '        allowed[msg.sender][_spender] = _value;\n', '\t\tcooldown[msg.sender][_spender] = now + 30 minutes;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Authorize an address to retrieve funds from you with a custom cooldown ~ ERC-20 Standard\n', '\t * @dev Allowing custom cooldown for the ERC-20 race attack prevention.\n', '\t * @param _spender The address you wish to authorize\n', '\t * @param _value The amount of tokens you wish to authorize\n', '\t * @param _cooldown The amount of seconds the recipient needs to wait before withdrawing the balance\n', '\t */\n', '    function approve(address _spender, uint256 _value, uint256 _cooldown) external {\n', '        allowed[msg.sender][_spender] = _value;\n', '\t\tcooldown[msg.sender][_spender] = now + _cooldown;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '    \n', '    /**\n', '\t * @notice Transfer the specified amount to the target address ~ ERC-20 Standard\n', '\t * @dev \n', '\t        A boolean is returned so that callers of the function \n', '\t        will know if their transaction went through.\n', '\t * @param _to The address you wish to send the tokens to\n', '\t * @param _value The amount of tokens you wish to send\n', '\t * @return {\n', '\t\t\t\t\t"success": "Transaction success"\n', '\t\t\t\t}\n', '     */\n', '    function transfer(address _to, uint256 _value) external isRunning requireThaw returns (bool success){\n', '        bytes memory empty;\n', '        if (_to == selfAddress) {\n', '            return transferToSelf(_value, empty);\n', '        } else if (isContract(_to)) {\n', '            return transferToContract(_to, _value, empty);\n', '        } else {\n', '            return transferToAddress(_to, _value, empty);\n', '        }\n', '    }\n', '    \n', '    /**\n', '\t * @notice Check whether address is a contract ~ ERC-223 Proposed Standard\n', '\t * @param _address The address to check\n', '\t * @return {\n', '\t\t\t\t\t"is_contract": "Result of query"\n', '\t\t\t\t}\n', '     */\n', '    function isContract(address _address) internal returns (bool is_contract) {\n', '        uint length;\n', '        assembly {\n', '            length := extcodesize(_address)\n', '        }\n', '        return length > 0;\n', '    }\n', '    \n', '    /**\n', '\t * @notice Transfer the specified amount to the target address with embedded bytes data ~ ERC-223 Proposed Standard\n', '\t * @dev Includes an extra transferToSelf function to handle Casino deposits\n', '\t * @param _to The address to transfer to\n', '\t * @param _value The amount of tokens to transfer\n', '\t * @param _data Any extra embedded data of the transaction\n', '\t * @return {\n', '\t\t\t\t\t"success": "Transaction success"\n', '\t\t\t\t}\n', '     */\n', '    function transfer(address _to, uint256 _value, bytes _data) external isRunning requireThaw returns (bool success){\n', '        if (_to == selfAddress) {\n', '            return transferToSelf(_value, _data);\n', '        } else if (isContract(_to)) {\n', '            return transferToContract(_to, _value, _data);\n', '        } else {\n', '            return transferToAddress(_to, _value, _data);\n', '        }\n', '    }\n', '    \n', '    /**\n', '\t * @notice Handles transfer to an ECA (Externally Controlled Account), a normal account ~ ERC-223 Proposed Standard\n', '\t * @param _to The address to transfer to\n', '\t * @param _value The amount of tokens to transfer\n', '\t * @param _data Any extra embedded data of the transaction\n', '\t * @return {\n', '\t\t\t\t\t"success": "Transaction success"\n', '\t\t\t\t}\n', '     */\n', '    function transferToAddress(address _to, uint256 _value, bytes _data) internal returns (bool success) {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = balances[_to]+_value;\n', '        addUser(_to);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '\t * @notice Handles transfer to a contract ~ ERC-223 Proposed Standard\n', '\t * @param _to The address to transfer to\n', '\t * @param _value The amount of tokens to transfer\n', '\t * @param _data Any extra embedded data of the transaction\n', '\t * @return {\n', '\t\t\t\t\t"success": "Transaction success"\n', '\t\t\t\t}\n', '     */\n', '    function transferToContract(address _to, uint256 _value, bytes _data) internal returns (bool success) {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = balances[_to]+_value;\n', '        WeBetCrypto rec = WeBetCrypto(_to);\n', '        rec.tokenFallback(msg.sender, _value, _data);\n', '        addUser(_to);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '\t * @notice Handles Casino deposits ~ Custom ERC-223 Proposed Standard Addition\n', '\t * @param _value The amount of tokens to transfer\n', '\t * @param _data Any extra embedded data of the transaction\n', '\t * @return {\n', '\t\t\t\t\t"success": "Transaction success"\n', '\t\t\t\t}\n', '     */\n', '    function transferToSelf(uint256 _value, bytes _data) internal returns (bool success) {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[selfAddress] = balances[selfAddress]+_value;\n', '        Transfer(msg.sender, selfAddress, _value);\n', '\t\tallowed[selfAddress][msg.sender] = _value + allowed[selfAddress][msg.sender];\n', '\t\tApproval(selfAddress, msg.sender, allowed[selfAddress][msg.sender]);\n', '        return true;\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Empty tokenFallback method to ensure ERC-223 compatibility\n', '\t * @param _sender The address who sent the ERC-223 tokens\n', '\t * @param _value The amount of tokens the address sent to this contract\n', '\t * @param _data Any embedded data of the transaction\n', '\t */\n', '\tfunction tokenFallback(address _sender, uint256 _value, bytes _data) {}\n', '\t\n', '\t/**\n', '\t * @notice Check the cooldown remaining until the allowee can withdraw the balance\n', '\t * @param _allower The holder of the balance\n', '\t * @param _allowee The recipient of the balance\n', '\t * @return {\n', '\t\t\t\t\t"remaining": "Cooldown remaining in seconds"\n', '\t\t\t\t}\n', '     */\n', '\tfunction checkCooldown(address _allower, address _allowee) external constant returns (uint256 remaining) {\n', '\t\tif (cooldown[_allower][_allowee] > now) {\n', '\t\t\treturn (cooldown[_allower][_allowee] - now);\n', '\t\t} else {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t}\n', '\t\n', '\t/**\n', '\t * @notice Check how much Casino withdrawal balance remains for address\n', '\t * @param _owner The address to check\n', '\t * @return {\n', '\t\t\t\t\t"remaining": "Withdrawal balance remaining"\n', '\t\t\t\t}\n', '     */\n', '    function checkMonthlyLimit(address _owner) external constant returns (uint256 remaining) {\n', '        return monthlyLimit[_owner];\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Retrieve ERC Tokens sent to contract\n', '\t * @dev Feel free to contact us and retrieve your ERC tokens should you wish so.\n', '\t * @param _token The token contract address\n', '\t */\n', '    function claimTokens(address _token) isAdmin external { \n', '\t\trequire(_token != selfAddress);\n', '        WeBetCrypto token = WeBetCrypto(_token); \n', '        uint balance = token.balanceOf(selfAddress); \n', '        token.transfer(admin, balance); \n', '    }\n', '    \n', '\t/**\n', '\t * @notice Freeze token circulation - splitProfits internal\n', '\t * @dev \n', '\t        Ensures that one doesn&#39;t transfer his total balance mid-split to \n', '\t        an account later in the split queue in order to receive twice the\n', '\t        monthly profits\n', '\t */\n', '    function assetFreeze() internal {\n', '        isFrozen = true;\n', '    }\n', '    \n', '\t/**\n', '\t * @notice Re-enable token circulation - splitProfits internal\n', '\t */\n', '    function assetThaw() internal {\n', '        isFrozen = false;\n', '    }\n', '    \n', '\t/**\n', '\t * @notice Freeze token circulation\n', '\t * @dev To be used only in extreme circumstances.\n', '\t */\n', '    function emergencyFreeze() isAdmin external {\n', '        isFrozen = true;\n', '    }\n', '    \n', '\t/**\n', '\t * @notice Re-enable token circulation\n', '\t * @dev To be used only in extreme circumstances\n', '\t */\n', '    function emergencyThaw() isAdmin external {\n', '        isFrozen = false;\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Disable the splitting function\n', '\t * @dev \n', '\t        To be used in case the system is upgraded to a \n', '\t        node.js operated profit reward system via the \n', '\t\t\talterBankBalance function. Ensures scalability \n', '\t\t\tin case userbase gets too big.\n', '\t */\n', '\tfunction emergencySplitToggle() isAdmin external {\n', '\t\tsplitInService = !splitInService;\n', '\t}\n', '    \n', '\t/**\n', '\t * @notice Adjust the price of Ether according to Coin Market Cap&#39;s API\n', '\t * @dev \n', '\t        The subfolder is public domain so anyone can verify that we indeed got the price\n', '\t        from a trusted source at the time we updated it. 2 decimal precision is achieved\n', '\t        by multiplying the price of Ether by 100 and then offsetting the multiplication\n', '\t        in the calculation the price is used in. The TLSNotaryProof string can be added\n', '\t        to the end of https://webetcrypto.io/TLSNotary/ to get the perspective TLS proof.\n', '\t * @param newPrice The new Ethereum price with 2 decimal precision\n', '\t * @param TLSNotaryProof The webetcrypto.io subfolder the TLSNotary proof is stored\n', '\t */\n', '    function setPriceOfEther(uint256 newPrice, string TLSNotaryProof) external isAdmin {\n', '        pricePerEther = newPrice;\n', '        CurrentTLSNProof(selfAddress, TLSNotaryProof);\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Get the current 2-decimal precision price per token\n', '\t * @dev \n', '\t        The price retains the 2 decimal precision by multiplying it with\n', '\t        100 and offsetting that in the calculations the price is used in.\n', '\t        For example 50 means each token costs 0.50$.\n', '\t * @return {\n', '\t\t\t\t\t"price": "Price of a single WBC Token"\n', '\t\t\t\t}\n', '     */\n', '\tfunction getPricePerToken() public constant returns (uint256 price) {\n', '        if (balances[selfAddress] > 200000000000000) {\n', '            return 50;\n', '        } else if (balances[selfAddress] > 150000000000000) {\n', '\t\t\treturn 200;\n', '\t\t} else if (balances[selfAddress] > 100000000000000) {\n', '\t\t\treturn 400;\n', '\t\t} else {\n', '\t\t\treturn 550;\n', '        }\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Convert Wei to WBC tokens\n', '\t * @dev \n', '\t\t    The _value is multiplied by 10^7 because of the 7 decimal precision\n', '\t\t\tof WBC and to ensure that a user can invest less than 1 ether and \n', '\t\t\tstill get his WBC tokens, preventing rounding errors. A hard cap\n', '\t\t\tof 500k WBC tokens per purchase is enforced so as to prevent users\n', '\t\t\tfrom buying large amounts at a higher or lower Ether price due to \n', '\t\t\thourly price updates.\n', '\t * @param _value The amount of Wei to convert\n', '\t * @return {\n', '\t\t\t\t\t"tokenAmount": "Amount of WBC Tokens input is worth"\n', '\t\t\t\t}\n', '     */\n', '\tfunction calculateTokenAmount(uint256 _value) internal returns (uint256 tokenAmount) {\n', '\t\ttokenAmount = ((_value*(10**7)/1 ether)*pricePerEther)/getPricePerToken();\n', '\t\tassert(tokenAmount <= 5000000000000);\n', '\t}\n', '\t\n', '\t/**\n', '\t * @notice Add the address to the user list \n', '\t * @dev Used for the splitting function to take it into account\n', '\t * @param _user User to add to database\n', '\t */\n', '\tfunction addUser(address _user) internal {\n', '\t\tif (!isAdded[_user]) {\n', '            users.push(_user);\n', '            monthlyLimit[_user] = 5000000000000;\n', '            isAdded[_user] = true;\n', '        }\n', '\t}\n', '    \n', '\t/**\n', '\t * @notice Split the monthly profits of the Casino to the users\n', '\t * @dev \n', '\t\t\tThe formula that calculates the profit a user is owed can be seen on \n', '\t\t\tthe white paper. The actualProfitSplit variable stores the actual values\n', '\t   \t\tthat are distributed to the users to prevent rounding errors from burning \n', '\t\t\ttokens. Since gas requirements will spike the more users use our platform,\n', '\t\t\ta loop-state-save is implemented to ensure scalability.\n', '\t */\n', '    function splitProfits() external {\n', '\t\trequire(splitInService);\n', '        uint i;\n', '        if (!isFrozen) {\n', '            require(now >= relativeDateSave);\n', '            assetFreeze();\n', '            require(balances[selfAddress] > 30000000000000);\n', '            relativeDateSave = now + 30 days;\n', '            currentProfits = ((balances[selfAddress]-30000000000000)/10)*7; \n', '            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\n', '            currentIteration = 0;\n', '\t\t\tactualProfitSplit = 0;\n', '        } else {\n', '            for (i = currentIteration; i < users.length; i++) {\n', '                monthlyLimit[users[i]] = 5000000000000;\n', '                if (msg.gas < 240000) {\n', '                    currentIteration = i;\n', '                    break;\n', '                }\n', '\t\t\t\tif (allowed[selfAddress][users[i]] == 0) {\n', '\t\t\t\t\tcheckSplitEnd(i);\n', '\t\t\t\t\tcontinue;\n', '\t\t\t\t} else if ((balances[users[i]]/allowed[selfAddress][users[i]]) < 19) {\n', '\t\t\t\t\tcheckSplitEnd(i);\n', '                    continue;\n', '                }\n', '\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\n', '                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\n', '\t\t\t\tcheckSplitEnd(i);\n', '                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits);\n', '            }\n', '        }\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Change variables on split end\n', '\t * @param i The current index of the split loop\n', '\t */\n', '\tfunction checkSplitEnd(uint256 i) internal {\n', '\t\tif (i == users.length-1) {\n', '\t\t\tassetThaw();\n', '\t\t\tbalances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] + currentProfits/22;\n', '\t\t\tbalances[selfAddress] = balances[selfAddress] - actualProfitSplit - currentProfits/22;\n', '\t\t}\n', '\t}\n', '\t\n', '\t/**\n', '\t * @notice Split the unsold WBC of the ICO\n', '\t * @dev \n', '\t\t\tOne time function to distribute the unsold tokens.\n', '\t */\n', '    function ICOSplit() external isAdmin oneTime {\n', '        uint i;\n', '        if (!isFrozen) {\n', '            require((relativeDateSave - now) >= (relativeDateSave - 150 days));\n', '            assetFreeze();\n', '            require(balances[selfAddress] > 50000000000000);\n', '            currentProfits = ((balances[selfAddress] - 50000000000000) / 10) * 7; \n', '            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\n', '            currentIteration = 0;\n', '\t\t\tactualProfitSplit = 0;\n', '        } else {\n', '            for (i = currentIteration; i < users.length; i++) {\n', '                if (msg.gas < 240000) {\n', '                    currentIteration = i;\n', '                    break;\n', '                }\n', '\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\n', '                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\n', '                if (i == users.length-1) {\n', '                    assetThaw();\n', '                    balances[selfAddress] = balances[selfAddress] - actualProfitSplit;\n', '\t\t\t\t\thasICORun = true;\n', '                }\n', '                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits);\n', '            }\n', '        }\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Sign that the DApp is ready\n', '\t * @dev \n', '\t        Only the core team members have access to this function. This is \n', '\t        created as an extra layer of security for investors and users of \n', '\t\t\tthe coin, since a multi-signature approval is required before the \n', '\t\t\tfunction that alters the Casino balance is used.\n', '\t */\n', '    function assureDAppIsReady() external {\n', '        if (msg.sender == 0x166Cb48973C2447dafFA8EFd3526da18076088de) {\n', '            devApprovals[0] = true;\n', '        } else if (msg.sender == 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d) {\n', '            devApprovals[1] = true;\n', '        } else if (msg.sender == 0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc) {\n', '            devApprovals[2] = true;\n', '        } else if (msg.sender == 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF) {\n', '            devApprovals[3] = true;\n', '        } else {\n', '\t\t\trevert();\n', '\t\t}\n', '    }\n', '\t\n', '\t/**\n', '     * @notice Verify that the DApp is ready\n', '\t * @dev \n', '\t\t\tSince iterating through the devApprovals array costs gas\n', '\t\t\tand the functions with the DAppOnline modifier are going\n', '\t\t\tto be repetitively used, it is better to store the DApp\n', '\t\t\tstate in a variable that needs to be altered once.\n', '\t */\n', '    function isDAppReady() external isAdmin {\n', '        uint8 numOfApprovals = 0;\n', '        for (uint i = 0; i < devApprovals.length; i++) {\n', '            if (devApprovals[i]) {\n', '                numOfApprovals++;\n', '            }\n', '        }\n', '        DAppReady = (numOfApprovals>=2);\n', '    }\n', '    \n', '\t/**\n', '\t * @notice Rise or lower user bank balance - Backend Function\n', '\t * @dev \n', '\t        This allows real-time adjustment of the balance a user has within the Casino to\n', '\t\t\trepresent earnings and losses. Underflow impossible since only bets can lower the\n', '\t\t\tbalance.\n', '\t * @param _toAlter The address whose Casino balance to alter\n', '\t * @param _amount The amount to alter it by\n', '\t */\n', '    function alterBankBalance(address _toAlter, uint256 _amount, bool sign) external DAppOnline isAdmin {\n', '        if (sign && (_amount+allowed[selfAddress][_toAlter]) > allowed[selfAddress][_toAlter]) {\n', '\t\t\tallowed[selfAddress][_toAlter] = _amount + allowed[selfAddress][_toAlter];\n', '\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\n', '        } else {\n', '            allowed[selfAddress][_toAlter] = safeSub(allowed[selfAddress][_toAlter], _amount);\n', '\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\n', '        }\n', '    }\n', '    \n', '\t/**\n', '\t * @notice Freeze user during platform use - Backend Function\n', '\t * @dev Prevents against the ERC-20 race attack on the Casino\n', '\t * @param _user The user to freeze\n', '\t */\n', '    function loginUser(address _user) external DAppOnline isAdmin {\n', '        freezeUser[_user] = true;\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice De-Freeze user - Backend Function\n', '     * @dev Used when a user logs out or loses connection with the DApp\n', '\t * @param _user The user to de-freeze\n', '\t */\n', '\tfunction logoutUser(address _user) external DAppOnline isAdmin {\n', '\t\tfreezeUser[_user] = false;\n', '\t}\n', '    \n', '    /**\n', '\t * @notice Fallback function \n', '\t * @dev Triggered when Ether is sent to the contract. Throws intentionally to refund the sender.\n', '\t */\n', '    function() payable {\n', '\t\trevert();\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Purchase WBC Tokens for Address - ICO\n', '\t * @param _recipient The recipient of the WBC tokens\n', '\t */\n', '\tfunction buyTokensForAddress(address _recipient) external payable {\n', '        totalFunds = totalFunds + msg.value;\n', '        require(msg.value > 0);\n', '\t\trequire(_recipient != admin);\n', '\t\trequire((totalFunds/1 ether)*pricePerEther < 6000000000);\n', '        addUser(_recipient);\n', '\t\tuint tokenAmount = calculateTokenAmount(msg.value);\n', '\t\tbalances[selfAddress] = balances[selfAddress] - tokenAmount;\n', '\t\tassert(balances[selfAddress] >= 50000000000000);\n', '        balances[_recipient] = balances[_recipient] + tokenAmount;\n', '        Transfer(selfAddress, _recipient, tokenAmount);\n', '        address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de;\n', '        etherTransfer.transfer(msg.value);\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Purchase WBC Tokens for Self - ICO\n', '\t */\n', '\tfunction buyTokensForSelf() external payable {\n', '        totalFunds = totalFunds + msg.value;\n', '\t\taddress etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de;\n', '        require(msg.value > 0);\n', '\t\trequire(msg.sender != etherTransfer);\n', '\t\trequire((totalFunds/1 ether)*pricePerEther < 6000000000);\n', '        addUser(msg.sender);\n', '\t\tuint tokenAmount = calculateTokenAmount(msg.value);\n', '\t\tbalances[selfAddress] = balances[selfAddress] - tokenAmount;\n', '\t\tassert(balances[selfAddress] >= 50000000000000);\n', '        balances[msg.sender] = balances[msg.sender] + tokenAmount;\n', '        Transfer(selfAddress, msg.sender, tokenAmount);\n', '        etherTransfer.transfer(msg.value);\n', '    }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', '\n', '/**\n', ' * @title WeBetCrypto\n', ' * @author AL_X\n', ' * @dev The WBC ERC-223 Token Contract\n', ' */\n', 'contract WeBetCrypto {\n', '    string public name = "We Bet Crypto";\n', '    string public symbol = "WBC";\n', '\t\n', '    address public selfAddress;\n', '    address public admin;\n', '    address[] private users;\n', '\t\n', '    uint8 public decimals = 7;\n', '    uint256 public relativeDateSave;\n', '    uint256 public totalFunds;\n', '    uint256 public totalSupply = 300000000000000;\n', '    uint256 public pricePerEther;\n', '    uint256 private amountInCirculation;\n', '    uint256 private currentProfits;\n', '    uint256 private currentIteration;\n', '\tuint256 private actualProfitSplit;\n', '\t\n', '    bool public DAppReady;\n', '    bool public isFrozen;\n', '\tbool public splitInService = true;\n', '\tbool private hasICORun;\n', '    bool private running;\n', '\tbool[4] private devApprovals;\n', '\t\n', '    mapping(address => uint256) balances;\n', '    mapping(address => uint256) monthlyLimit;\n', '\t\n', '    mapping(address => bool) isAdded;\n', '    mapping(address => bool) freezeUser;\n', '\t\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\tmapping (address => mapping (address => uint256)) cooldown;\n', '\t\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event CurrentTLSNProof(address indexed _from, string _proof);\n', '    \n', '\t/**\n', '\t * @notice Ensures admin is caller\n', '\t */\n', '    modifier isAdmin() {\n', '        require(msg.sender == admin);\n', '        //Continue executing rest of method body\n', '        _;\n', '    }\n', '    \n', '    /**\n', '\t * @notice Re-entry protection\n', '\t */\n', '    modifier isRunning() {\n', '        require(!running);\n', '        running = true;\n', '        _;\n', '        running = false;\n', '    }\n', '    \n', '\t/**\n', "\t * @notice Ensures system isn't frozen\n", '\t */\n', '    modifier requireThaw() {\n', '        require(!isFrozen);\n', '        _;\n', '    }\n', '    \n', '\t/**\n', "\t * @notice Ensures player isn't logged in on platform\n", '\t */\n', '    modifier userNotPlaying(address _user) {\n', '        require(!freezeUser[_user]);\n', '        _;\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Ensures function runs only once\n', '\t */\n', '\tmodifier oneTime() {\n', '\t\trequire(!hasICORun);\n', '\t\t_;\n', '\t}\n', '    \n', '\t/**\n', '\t * @notice Ensures WBC DApp is online\n', '\t */\n', '    modifier DAppOnline() {\n', '        require(DAppReady);\n', '        _;\n', '    }\n', '    \n', '    /**\n', '\t * @notice SafeMath Library safeSub Import\n', '\t * @dev \n', '\t        Since we are dealing with a limited currency\n', '\t        circulation of 30 million tokens and values\n', '\t        that will not surpass the uint256 limit, only\n', '\t        safeSub is required to prevent underflows.\n', '\t */\n', '    function safeSub(uint256 a, uint256 b) internal constant returns (uint256 z) {\n', '        assert((z = a - b) <= a);\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice WBC Constructor\n', '\t * @dev \n', '\t        Constructor function containing proper initializations such as \n', '\t        token distribution to the team members and pushing the first \n', '\t        profit split to 6 months when the DApp will already be live.\n', '\t */\n', '    function WeBetCrypto() {\n', '        admin = msg.sender;\n', '        selfAddress = this;\n', '        balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = 22500000000000;\n', '        addUser(0x166Cb48973C2447dafFA8EFd3526da18076088de);\n', '        Transfer(selfAddress, 0x166Cb48973C2447dafFA8EFd3526da18076088de, 22500000000000);\n', '        balances[0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF] = 15000000000000;\n', '        addUser(0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF);\n', '        Transfer(selfAddress, 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF, 15000000000000);\n', '        balances[0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d] = 5000000000000;\n', '        addUser(0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d);\n', '        Transfer(selfAddress, 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d, 5000000000000);\n', '        balances[0x06908Df389Cf2589375b6908D0b1c8FcC34721B5] = 2500000000000;\n', '        addUser(0x06908Df389Cf2589375b6908D0b1c8FcC34721B5);\n', '        Transfer(selfAddress, 0x06908Df389Cf2589375b6908D0b1c8FcC34721B5, 2500000000000);\n', '        balances[0xEdBd4c6757DC425321584a91bDB355Ce65c42b13] = 2500000000000;\n', '        addUser(0xEdBd4c6757DC425321584a91bDB355Ce65c42b13);\n', '        Transfer(selfAddress, 0xEdBd4c6757DC425321584a91bDB355Ce65c42b13, 2500000000000);\n', '        balances[0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858] = 2500000000000;\n', '        addUser(0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858);\n', '        Transfer(selfAddress, 0x4309Fb4B31aA667673d69db1072E6dcD50Fd8858, 2500000000000);\n', '        relativeDateSave = now + 180 days;\n', '        pricePerEther = 33209;\n', '        balances[selfAddress] = 250000000000000;\n', '    }\n', '    \n', '    /**\n', '     * @notice Check the name of the token ~ ERC-20 Standard\n', '     * @return {\n', '\t\t\t\t\t"_name": "The token name"\n', '\t\t\t\t}\n', '     */\n', '    function name() external constant returns (string _name) {\n', '        return name;\n', '    }\n', '    \n', '\t/**\n', '     * @notice Check the symbol of the token ~ ERC-20 Standard\n', '     * @return {\n', '\t\t\t\t\t"_symbol": "The token symbol"\n', '\t\t\t\t}\n', '     */\n', '    function symbol() external constant returns (string _symbol) {\n', '        return symbol;\n', '    }\n', '    \n', '    /**\n', '     * @notice Check the decimals of the token ~ ERC-20 Standard\n', '     * @return {\n', '\t\t\t\t\t"_decimals": "The token decimals"\n', '\t\t\t\t}\n', '     */\n', '    function decimals() external constant returns (uint8 _decimals) {\n', '        return decimals;\n', '    }\n', '    \n', '    /**\n', '     * @notice Check the total supply of the token ~ ERC-20 Standard\n', '     * @return {\n', '\t\t\t\t\t"_totalSupply": "Total supply of tokens"\n', '\t\t\t\t}\n', '     */\n', '    function totalSupply() external constant returns (uint256 _totalSupply) {\n', '        return totalSupply;\n', '    }\n', '    \n', '    /**\n', '     * @notice Query the available balance of an address ~ ERC-20 Standard\n', '\t * @param _owner The address whose balance we wish to retrieve\n', '     * @return {\n', '\t\t\t\t\t"balance": "Balance of the address"\n', '\t\t\t\t}\n', '     */\n', '    function balanceOf(address _owner) external constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Query the amount of tokens the spender address can withdraw from the owner address ~ ERC-20 Standard\n', '\t * @param _owner The address who owns the tokens\n', '\t * @param _spender The address who can withdraw the tokens\n', '\t * @return {\n', '\t\t\t\t\t"remaining": "Remaining withdrawal amount"\n', '\t\t\t\t}\n', '     */\n', '    function allowance(address _owner, address _spender) external constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    /**\n', '     * @notice Transfer tokens from an address to another ~ ERC-20 Standard\n', '\t * @dev \n', '\t        Adjusts the monthly limit in case the _from address is the Casino\n', "\t        and ensures that the user isn't logged in when retrieving funds\n", '\t        so as to prevent against a race attack with the Casino.\n', '     * @param _from The address whose balance we will transfer\n', '     * @param _to The recipient address\n', '\t * @param _value The amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) external requireThaw userNotPlaying(_to) {\n', '\t\trequire(cooldown[_from][_to] <= now);\n', '        var _allowance = allowed[_from][_to];\n', '        if (_from == selfAddress) {\n', '            monthlyLimit[_to] = safeSub(monthlyLimit[_to], _value);\n', '        }\n', '        balances[_to] = balances[_to]+_value;\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        allowed[_from][_to] = safeSub(_allowance, _value);\n', '        addUser(_to);\n', '        Transfer(_from, _to, _value);\n', '    }\n', '    \n', '    /**\n', '\t * @notice Authorize an address to retrieve funds from you ~ ERC-20 Standard\n', '\t * @dev \n', '\t        Each approval comes with a default cooldown of 30 minutes\n', '\t        to prevent against the ERC-20 race attack.\n', '\t * @param _spender The address you wish to authorize\n', '\t * @param _value The amount of tokens you wish to authorize\n', '\t */\n', '    function approve(address _spender, uint256 _value) external {\n', '        allowed[msg.sender][_spender] = _value;\n', '\t\tcooldown[msg.sender][_spender] = now + 30 minutes;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Authorize an address to retrieve funds from you with a custom cooldown ~ ERC-20 Standard\n', '\t * @dev Allowing custom cooldown for the ERC-20 race attack prevention.\n', '\t * @param _spender The address you wish to authorize\n', '\t * @param _value The amount of tokens you wish to authorize\n', '\t * @param _cooldown The amount of seconds the recipient needs to wait before withdrawing the balance\n', '\t */\n', '    function approve(address _spender, uint256 _value, uint256 _cooldown) external {\n', '        allowed[msg.sender][_spender] = _value;\n', '\t\tcooldown[msg.sender][_spender] = now + _cooldown;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '    \n', '    /**\n', '\t * @notice Transfer the specified amount to the target address ~ ERC-20 Standard\n', '\t * @dev \n', '\t        A boolean is returned so that callers of the function \n', '\t        will know if their transaction went through.\n', '\t * @param _to The address you wish to send the tokens to\n', '\t * @param _value The amount of tokens you wish to send\n', '\t * @return {\n', '\t\t\t\t\t"success": "Transaction success"\n', '\t\t\t\t}\n', '     */\n', '    function transfer(address _to, uint256 _value) external isRunning requireThaw returns (bool success){\n', '        bytes memory empty;\n', '        if (_to == selfAddress) {\n', '            return transferToSelf(_value, empty);\n', '        } else if (isContract(_to)) {\n', '            return transferToContract(_to, _value, empty);\n', '        } else {\n', '            return transferToAddress(_to, _value, empty);\n', '        }\n', '    }\n', '    \n', '    /**\n', '\t * @notice Check whether address is a contract ~ ERC-223 Proposed Standard\n', '\t * @param _address The address to check\n', '\t * @return {\n', '\t\t\t\t\t"is_contract": "Result of query"\n', '\t\t\t\t}\n', '     */\n', '    function isContract(address _address) internal returns (bool is_contract) {\n', '        uint length;\n', '        assembly {\n', '            length := extcodesize(_address)\n', '        }\n', '        return length > 0;\n', '    }\n', '    \n', '    /**\n', '\t * @notice Transfer the specified amount to the target address with embedded bytes data ~ ERC-223 Proposed Standard\n', '\t * @dev Includes an extra transferToSelf function to handle Casino deposits\n', '\t * @param _to The address to transfer to\n', '\t * @param _value The amount of tokens to transfer\n', '\t * @param _data Any extra embedded data of the transaction\n', '\t * @return {\n', '\t\t\t\t\t"success": "Transaction success"\n', '\t\t\t\t}\n', '     */\n', '    function transfer(address _to, uint256 _value, bytes _data) external isRunning requireThaw returns (bool success){\n', '        if (_to == selfAddress) {\n', '            return transferToSelf(_value, _data);\n', '        } else if (isContract(_to)) {\n', '            return transferToContract(_to, _value, _data);\n', '        } else {\n', '            return transferToAddress(_to, _value, _data);\n', '        }\n', '    }\n', '    \n', '    /**\n', '\t * @notice Handles transfer to an ECA (Externally Controlled Account), a normal account ~ ERC-223 Proposed Standard\n', '\t * @param _to The address to transfer to\n', '\t * @param _value The amount of tokens to transfer\n', '\t * @param _data Any extra embedded data of the transaction\n', '\t * @return {\n', '\t\t\t\t\t"success": "Transaction success"\n', '\t\t\t\t}\n', '     */\n', '    function transferToAddress(address _to, uint256 _value, bytes _data) internal returns (bool success) {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = balances[_to]+_value;\n', '        addUser(_to);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '\t * @notice Handles transfer to a contract ~ ERC-223 Proposed Standard\n', '\t * @param _to The address to transfer to\n', '\t * @param _value The amount of tokens to transfer\n', '\t * @param _data Any extra embedded data of the transaction\n', '\t * @return {\n', '\t\t\t\t\t"success": "Transaction success"\n', '\t\t\t\t}\n', '     */\n', '    function transferToContract(address _to, uint256 _value, bytes _data) internal returns (bool success) {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = balances[_to]+_value;\n', '        WeBetCrypto rec = WeBetCrypto(_to);\n', '        rec.tokenFallback(msg.sender, _value, _data);\n', '        addUser(_to);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '\t * @notice Handles Casino deposits ~ Custom ERC-223 Proposed Standard Addition\n', '\t * @param _value The amount of tokens to transfer\n', '\t * @param _data Any extra embedded data of the transaction\n', '\t * @return {\n', '\t\t\t\t\t"success": "Transaction success"\n', '\t\t\t\t}\n', '     */\n', '    function transferToSelf(uint256 _value, bytes _data) internal returns (bool success) {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[selfAddress] = balances[selfAddress]+_value;\n', '        Transfer(msg.sender, selfAddress, _value);\n', '\t\tallowed[selfAddress][msg.sender] = _value + allowed[selfAddress][msg.sender];\n', '\t\tApproval(selfAddress, msg.sender, allowed[selfAddress][msg.sender]);\n', '        return true;\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Empty tokenFallback method to ensure ERC-223 compatibility\n', '\t * @param _sender The address who sent the ERC-223 tokens\n', '\t * @param _value The amount of tokens the address sent to this contract\n', '\t * @param _data Any embedded data of the transaction\n', '\t */\n', '\tfunction tokenFallback(address _sender, uint256 _value, bytes _data) {}\n', '\t\n', '\t/**\n', '\t * @notice Check the cooldown remaining until the allowee can withdraw the balance\n', '\t * @param _allower The holder of the balance\n', '\t * @param _allowee The recipient of the balance\n', '\t * @return {\n', '\t\t\t\t\t"remaining": "Cooldown remaining in seconds"\n', '\t\t\t\t}\n', '     */\n', '\tfunction checkCooldown(address _allower, address _allowee) external constant returns (uint256 remaining) {\n', '\t\tif (cooldown[_allower][_allowee] > now) {\n', '\t\t\treturn (cooldown[_allower][_allowee] - now);\n', '\t\t} else {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t}\n', '\t\n', '\t/**\n', '\t * @notice Check how much Casino withdrawal balance remains for address\n', '\t * @param _owner The address to check\n', '\t * @return {\n', '\t\t\t\t\t"remaining": "Withdrawal balance remaining"\n', '\t\t\t\t}\n', '     */\n', '    function checkMonthlyLimit(address _owner) external constant returns (uint256 remaining) {\n', '        return monthlyLimit[_owner];\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Retrieve ERC Tokens sent to contract\n', '\t * @dev Feel free to contact us and retrieve your ERC tokens should you wish so.\n', '\t * @param _token The token contract address\n', '\t */\n', '    function claimTokens(address _token) isAdmin external { \n', '\t\trequire(_token != selfAddress);\n', '        WeBetCrypto token = WeBetCrypto(_token); \n', '        uint balance = token.balanceOf(selfAddress); \n', '        token.transfer(admin, balance); \n', '    }\n', '    \n', '\t/**\n', '\t * @notice Freeze token circulation - splitProfits internal\n', '\t * @dev \n', "\t        Ensures that one doesn't transfer his total balance mid-split to \n", '\t        an account later in the split queue in order to receive twice the\n', '\t        monthly profits\n', '\t */\n', '    function assetFreeze() internal {\n', '        isFrozen = true;\n', '    }\n', '    \n', '\t/**\n', '\t * @notice Re-enable token circulation - splitProfits internal\n', '\t */\n', '    function assetThaw() internal {\n', '        isFrozen = false;\n', '    }\n', '    \n', '\t/**\n', '\t * @notice Freeze token circulation\n', '\t * @dev To be used only in extreme circumstances.\n', '\t */\n', '    function emergencyFreeze() isAdmin external {\n', '        isFrozen = true;\n', '    }\n', '    \n', '\t/**\n', '\t * @notice Re-enable token circulation\n', '\t * @dev To be used only in extreme circumstances\n', '\t */\n', '    function emergencyThaw() isAdmin external {\n', '        isFrozen = false;\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Disable the splitting function\n', '\t * @dev \n', '\t        To be used in case the system is upgraded to a \n', '\t        node.js operated profit reward system via the \n', '\t\t\talterBankBalance function. Ensures scalability \n', '\t\t\tin case userbase gets too big.\n', '\t */\n', '\tfunction emergencySplitToggle() isAdmin external {\n', '\t\tsplitInService = !splitInService;\n', '\t}\n', '    \n', '\t/**\n', "\t * @notice Adjust the price of Ether according to Coin Market Cap's API\n", '\t * @dev \n', '\t        The subfolder is public domain so anyone can verify that we indeed got the price\n', '\t        from a trusted source at the time we updated it. 2 decimal precision is achieved\n', '\t        by multiplying the price of Ether by 100 and then offsetting the multiplication\n', '\t        in the calculation the price is used in. The TLSNotaryProof string can be added\n', '\t        to the end of https://webetcrypto.io/TLSNotary/ to get the perspective TLS proof.\n', '\t * @param newPrice The new Ethereum price with 2 decimal precision\n', '\t * @param TLSNotaryProof The webetcrypto.io subfolder the TLSNotary proof is stored\n', '\t */\n', '    function setPriceOfEther(uint256 newPrice, string TLSNotaryProof) external isAdmin {\n', '        pricePerEther = newPrice;\n', '        CurrentTLSNProof(selfAddress, TLSNotaryProof);\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Get the current 2-decimal precision price per token\n', '\t * @dev \n', '\t        The price retains the 2 decimal precision by multiplying it with\n', '\t        100 and offsetting that in the calculations the price is used in.\n', '\t        For example 50 means each token costs 0.50$.\n', '\t * @return {\n', '\t\t\t\t\t"price": "Price of a single WBC Token"\n', '\t\t\t\t}\n', '     */\n', '\tfunction getPricePerToken() public constant returns (uint256 price) {\n', '        if (balances[selfAddress] > 200000000000000) {\n', '            return 50;\n', '        } else if (balances[selfAddress] > 150000000000000) {\n', '\t\t\treturn 200;\n', '\t\t} else if (balances[selfAddress] > 100000000000000) {\n', '\t\t\treturn 400;\n', '\t\t} else {\n', '\t\t\treturn 550;\n', '        }\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Convert Wei to WBC tokens\n', '\t * @dev \n', '\t\t    The _value is multiplied by 10^7 because of the 7 decimal precision\n', '\t\t\tof WBC and to ensure that a user can invest less than 1 ether and \n', '\t\t\tstill get his WBC tokens, preventing rounding errors. A hard cap\n', '\t\t\tof 500k WBC tokens per purchase is enforced so as to prevent users\n', '\t\t\tfrom buying large amounts at a higher or lower Ether price due to \n', '\t\t\thourly price updates.\n', '\t * @param _value The amount of Wei to convert\n', '\t * @return {\n', '\t\t\t\t\t"tokenAmount": "Amount of WBC Tokens input is worth"\n', '\t\t\t\t}\n', '     */\n', '\tfunction calculateTokenAmount(uint256 _value) internal returns (uint256 tokenAmount) {\n', '\t\ttokenAmount = ((_value*(10**7)/1 ether)*pricePerEther)/getPricePerToken();\n', '\t\tassert(tokenAmount <= 5000000000000);\n', '\t}\n', '\t\n', '\t/**\n', '\t * @notice Add the address to the user list \n', '\t * @dev Used for the splitting function to take it into account\n', '\t * @param _user User to add to database\n', '\t */\n', '\tfunction addUser(address _user) internal {\n', '\t\tif (!isAdded[_user]) {\n', '            users.push(_user);\n', '            monthlyLimit[_user] = 5000000000000;\n', '            isAdded[_user] = true;\n', '        }\n', '\t}\n', '    \n', '\t/**\n', '\t * @notice Split the monthly profits of the Casino to the users\n', '\t * @dev \n', '\t\t\tThe formula that calculates the profit a user is owed can be seen on \n', '\t\t\tthe white paper. The actualProfitSplit variable stores the actual values\n', '\t   \t\tthat are distributed to the users to prevent rounding errors from burning \n', '\t\t\ttokens. Since gas requirements will spike the more users use our platform,\n', '\t\t\ta loop-state-save is implemented to ensure scalability.\n', '\t */\n', '    function splitProfits() external {\n', '\t\trequire(splitInService);\n', '        uint i;\n', '        if (!isFrozen) {\n', '            require(now >= relativeDateSave);\n', '            assetFreeze();\n', '            require(balances[selfAddress] > 30000000000000);\n', '            relativeDateSave = now + 30 days;\n', '            currentProfits = ((balances[selfAddress]-30000000000000)/10)*7; \n', '            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\n', '            currentIteration = 0;\n', '\t\t\tactualProfitSplit = 0;\n', '        } else {\n', '            for (i = currentIteration; i < users.length; i++) {\n', '                monthlyLimit[users[i]] = 5000000000000;\n', '                if (msg.gas < 240000) {\n', '                    currentIteration = i;\n', '                    break;\n', '                }\n', '\t\t\t\tif (allowed[selfAddress][users[i]] == 0) {\n', '\t\t\t\t\tcheckSplitEnd(i);\n', '\t\t\t\t\tcontinue;\n', '\t\t\t\t} else if ((balances[users[i]]/allowed[selfAddress][users[i]]) < 19) {\n', '\t\t\t\t\tcheckSplitEnd(i);\n', '                    continue;\n', '                }\n', '\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\n', '                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\n', '\t\t\t\tcheckSplitEnd(i);\n', '                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits);\n', '            }\n', '        }\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Change variables on split end\n', '\t * @param i The current index of the split loop\n', '\t */\n', '\tfunction checkSplitEnd(uint256 i) internal {\n', '\t\tif (i == users.length-1) {\n', '\t\t\tassetThaw();\n', '\t\t\tbalances[0x166Cb48973C2447dafFA8EFd3526da18076088de] = balances[0x166Cb48973C2447dafFA8EFd3526da18076088de] + currentProfits/22;\n', '\t\t\tbalances[selfAddress] = balances[selfAddress] - actualProfitSplit - currentProfits/22;\n', '\t\t}\n', '\t}\n', '\t\n', '\t/**\n', '\t * @notice Split the unsold WBC of the ICO\n', '\t * @dev \n', '\t\t\tOne time function to distribute the unsold tokens.\n', '\t */\n', '    function ICOSplit() external isAdmin oneTime {\n', '        uint i;\n', '        if (!isFrozen) {\n', '            require((relativeDateSave - now) >= (relativeDateSave - 150 days));\n', '            assetFreeze();\n', '            require(balances[selfAddress] > 50000000000000);\n', '            currentProfits = ((balances[selfAddress] - 50000000000000) / 10) * 7; \n', '            amountInCirculation = safeSub(300000000000000, balances[selfAddress]);\n', '            currentIteration = 0;\n', '\t\t\tactualProfitSplit = 0;\n', '        } else {\n', '            for (i = currentIteration; i < users.length; i++) {\n', '                if (msg.gas < 240000) {\n', '                    currentIteration = i;\n', '                    break;\n', '                }\n', '\t\t\t\tactualProfitSplit += (balances[users[i]]*currentProfits)/amountInCirculation;\n', '                balances[users[i]] += (balances[users[i]]*currentProfits)/amountInCirculation;\n', '                if (i == users.length-1) {\n', '                    assetThaw();\n', '                    balances[selfAddress] = balances[selfAddress] - actualProfitSplit;\n', '\t\t\t\t\thasICORun = true;\n', '                }\n', '                Transfer(selfAddress, users[i], (balances[users[i]]/amountInCirculation)*currentProfits);\n', '            }\n', '        }\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Sign that the DApp is ready\n', '\t * @dev \n', '\t        Only the core team members have access to this function. This is \n', '\t        created as an extra layer of security for investors and users of \n', '\t\t\tthe coin, since a multi-signature approval is required before the \n', '\t\t\tfunction that alters the Casino balance is used.\n', '\t */\n', '    function assureDAppIsReady() external {\n', '        if (msg.sender == 0x166Cb48973C2447dafFA8EFd3526da18076088de) {\n', '            devApprovals[0] = true;\n', '        } else if (msg.sender == 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d) {\n', '            devApprovals[1] = true;\n', '        } else if (msg.sender == 0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc) {\n', '            devApprovals[2] = true;\n', '        } else if (msg.sender == 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF) {\n', '            devApprovals[3] = true;\n', '        } else {\n', '\t\t\trevert();\n', '\t\t}\n', '    }\n', '\t\n', '\t/**\n', '     * @notice Verify that the DApp is ready\n', '\t * @dev \n', '\t\t\tSince iterating through the devApprovals array costs gas\n', '\t\t\tand the functions with the DAppOnline modifier are going\n', '\t\t\tto be repetitively used, it is better to store the DApp\n', '\t\t\tstate in a variable that needs to be altered once.\n', '\t */\n', '    function isDAppReady() external isAdmin {\n', '        uint8 numOfApprovals = 0;\n', '        for (uint i = 0; i < devApprovals.length; i++) {\n', '            if (devApprovals[i]) {\n', '                numOfApprovals++;\n', '            }\n', '        }\n', '        DAppReady = (numOfApprovals>=2);\n', '    }\n', '    \n', '\t/**\n', '\t * @notice Rise or lower user bank balance - Backend Function\n', '\t * @dev \n', '\t        This allows real-time adjustment of the balance a user has within the Casino to\n', '\t\t\trepresent earnings and losses. Underflow impossible since only bets can lower the\n', '\t\t\tbalance.\n', '\t * @param _toAlter The address whose Casino balance to alter\n', '\t * @param _amount The amount to alter it by\n', '\t */\n', '    function alterBankBalance(address _toAlter, uint256 _amount, bool sign) external DAppOnline isAdmin {\n', '        if (sign && (_amount+allowed[selfAddress][_toAlter]) > allowed[selfAddress][_toAlter]) {\n', '\t\t\tallowed[selfAddress][_toAlter] = _amount + allowed[selfAddress][_toAlter];\n', '\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\n', '        } else {\n', '            allowed[selfAddress][_toAlter] = safeSub(allowed[selfAddress][_toAlter], _amount);\n', '\t\t\tApproval(selfAddress, _toAlter, allowed[selfAddress][_toAlter]);\n', '        }\n', '    }\n', '    \n', '\t/**\n', '\t * @notice Freeze user during platform use - Backend Function\n', '\t * @dev Prevents against the ERC-20 race attack on the Casino\n', '\t * @param _user The user to freeze\n', '\t */\n', '    function loginUser(address _user) external DAppOnline isAdmin {\n', '        freezeUser[_user] = true;\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice De-Freeze user - Backend Function\n', '     * @dev Used when a user logs out or loses connection with the DApp\n', '\t * @param _user The user to de-freeze\n', '\t */\n', '\tfunction logoutUser(address _user) external DAppOnline isAdmin {\n', '\t\tfreezeUser[_user] = false;\n', '\t}\n', '    \n', '    /**\n', '\t * @notice Fallback function \n', '\t * @dev Triggered when Ether is sent to the contract. Throws intentionally to refund the sender.\n', '\t */\n', '    function() payable {\n', '\t\trevert();\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Purchase WBC Tokens for Address - ICO\n', '\t * @param _recipient The recipient of the WBC tokens\n', '\t */\n', '\tfunction buyTokensForAddress(address _recipient) external payable {\n', '        totalFunds = totalFunds + msg.value;\n', '        require(msg.value > 0);\n', '\t\trequire(_recipient != admin);\n', '\t\trequire((totalFunds/1 ether)*pricePerEther < 6000000000);\n', '        addUser(_recipient);\n', '\t\tuint tokenAmount = calculateTokenAmount(msg.value);\n', '\t\tbalances[selfAddress] = balances[selfAddress] - tokenAmount;\n', '\t\tassert(balances[selfAddress] >= 50000000000000);\n', '        balances[_recipient] = balances[_recipient] + tokenAmount;\n', '        Transfer(selfAddress, _recipient, tokenAmount);\n', '        address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de;\n', '        etherTransfer.transfer(msg.value);\n', '    }\n', '\t\n', '\t/**\n', '\t * @notice Purchase WBC Tokens for Self - ICO\n', '\t */\n', '\tfunction buyTokensForSelf() external payable {\n', '        totalFunds = totalFunds + msg.value;\n', '\t\taddress etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de;\n', '        require(msg.value > 0);\n', '\t\trequire(msg.sender != etherTransfer);\n', '\t\trequire((totalFunds/1 ether)*pricePerEther < 6000000000);\n', '        addUser(msg.sender);\n', '\t\tuint tokenAmount = calculateTokenAmount(msg.value);\n', '\t\tbalances[selfAddress] = balances[selfAddress] - tokenAmount;\n', '\t\tassert(balances[selfAddress] >= 50000000000000);\n', '        balances[msg.sender] = balances[msg.sender] + tokenAmount;\n', '        Transfer(selfAddress, msg.sender, tokenAmount);\n', '        etherTransfer.transfer(msg.value);\n', '    }\n', '}']
