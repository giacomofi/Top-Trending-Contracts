['/**\n', ' *  The Option token contract complies with the ERC20 standard.\n', ' *  This contract implements american option.\n', ' *  Holders of the Option tokens can make a purchase of the underlying asset\n', ' *  at the price of Strike until the Expiration time.\n', ' *  The Strike price and Expiration date are set once and can&#39;t be changed.\n', ' *  Author: Alexey Bukhteyev\n', ' **/\n', '\n', 'pragma solidity ^0.4.4;\n', '\n', 'contract ERC20 {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '\n', '    function name() public constant returns(string);\n', '    function symbol() public constant returns(string);\n', '\n', '    function totalSupply() public constant returns(uint256 supply);\n', '    function balanceOf(address _owner) public constant returns(uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns(bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success);\n', '    function approve(address _spender, uint256 _value) public returns(bool success);\n', '    function allowance(address _owner, address _spender) public constant returns(uint256 remaining);\n', '    function decimals() public constant returns(uint8);\n', '}\n', '\n', '/*\n', '    Allows to recreate OptionToken contract on the same address.\n', '    Just create new TokenHolders(OptionToken) and reinitiallize OptionToken using it&#39;s address\n', '*/\n', 'contract TokenHolders {\n', '    address public owner;\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '\n', '    /*\n', '        TokenHolders contract is being connected to OptionToken on creation.\n', '        Nobody can modify balanceOf and allowance except OptionToken\n', '    */\n', '\n', '    function validate() external constant returns (bool);\n', '\n', '    function setBalance(address _to, uint256 _value) external;\n', '\n', '    /* Send some of your tokens to a given address */\n', '    function transfer(address _from, address _to, uint256 _value) public returns(bool success);\n', '\n', '    /* Allow another contract or person to spend some tokens in your behalf */\n', '    function approve(address _sender, address _spender, uint256 _value) public returns(bool success);\n', '\n', '    /* A contract or  person attempts to get the tokens of somebody else.\n', '     *  This is only allowed if the token holder approved. */\n', '    function transferWithAllowance(address _origin, address _from, address _to, uint256 _value)\n', '    public returns(bool success);\n', '}\n', '\n', '/*\n', '    This ERC20 contract is a basic option contract that implements a token which\n', '    allows to token holder to buy some asset for the fixed strike price before expiration date.\n', '*/\n', 'contract OptionToken {\n', '    string public standard = &#39;ERC20&#39;;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    address public owner;\n', '\n', '    // Option characteristics\n', '    uint256 public expiration = 1512172800; //02.12.2017 Use unix timespamp\n', '    uint256 public strike = 20000000000;\n', '\n', '    ERC20 public baseToken;\n', '    TokenHolders public tokenHolders;\n', '\n', '    bool _initialized = false;\n', '\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    // ERC20 events\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '\n', '    // OptionToken events\n', '    event Deposit(address indexed from, uint256 value);\n', '    event Redeem(address indexed from, uint256 value, uint256 ethvalue);\n', '    event Issue(address indexed issuer, uint256 value);\n', '\n', '    // Only set owner on the constructor\n', '    function OptionToken() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // ERC20 functions\n', '    function balanceOf(address _owner) public constant returns(uint256 balance) {\n', '        return tokenHolders.balanceOf(_owner);\n', '    }\n', '\n', '    function totalSupply() public constant returns(uint256 supply) {\n', '        // total supply is a balance of this contract in base tokens\n', '        return baseToken.balanceOf(this);\n', '    }\n', '\n', '    /* Send some of your tokens to a given address */\n', '    function transfer(address _to, uint256 _value) public returns(bool success) {\n', '        if(now > expiration)\n', '            return false;\n', '\n', '        if(!tokenHolders.transfer(msg.sender, _to, _value))\n', '            return false;\n', '\n', '        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\n', '        return true;\n', '    }\n', '\n', '    /* Allow another contract or person to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value) public returns(bool success) {\n', '        if(now > expiration)\n', '            return false;\n', '\n', '        if(!tokenHolders.approve(msg.sender, _spender, _value))\n', '            return false;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /* A contract or  person attempts to get the tokens of somebody else.\n', '     *  This is only allowed if the token holder approved. */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {\n', '        if(now > expiration)\n', '            return false;\n', '\n', '        if(!tokenHolders.transferWithAllowance(msg.sender, _from, _to, _value))\n', '            return false;\n', '\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns(uint256 remaining) {\n', '        return tokenHolders.allowance(_owner, _spender);\n', '    }\n', '\n', '    // OptionToken functions\n', '\n', '    /*\n', '        Then we should pass base token contract address to init() function.\n', '        Only contract creator can call init() and only once\n', '    */\n', '    function init(ERC20 _baseToken, TokenHolders _tokenHolders, string _name, string _symbol,\n', '                uint256 _exp, uint256 _strike) public returns(bool success) {\n', '        require(msg.sender == owner && !_initialized);\n', '\n', '        baseToken = _baseToken;\n', '        tokenHolders = _tokenHolders;\n', '\n', '        // if baseToken.totalSupply() is zero - something is wrong\n', '        assert(baseToken.totalSupply() != 0);\n', '        // validate tokenHolders contract owner - it should be OptionToken\n', '        assert(tokenHolders.validate());\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '        expiration = _exp;\n', '        strike = _strike;\n', '\n', '        decimals = baseToken.decimals();\n', '\n', '        _initialized = true;\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        Allows to increase totalSupply and get OptionTokens to their balance.\n', '        Before calling depositTokens the caller should approve the transfer for this contract address\n', '        using ERC20.approve().\n', '        Actually should be called by contract owner, because no ETH payout will be done for token transfer.\n', '    */\n', '    function issue(uint256 _value) public returns(bool success) {\n', '        require(now <= expiration && _initialized);\n', '\n', '        uint256 receiver_balance = balanceOf(msg.sender) + _value;\n', '        assert(receiver_balance >= _value);\n', '\n', '        // check if transfer failed\n', '        if(!baseToken.transferFrom(msg.sender, this, _value))\n', '            revert();\n', '\n', '        tokenHolders.setBalance(msg.sender, receiver_balance);\n', '        Issue(msg.sender, receiver_balance);\n', '\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        Buy base tokens for the strike price\n', '    */\n', '    function() public payable {\n', '        require(now <= expiration && _initialized); // the contract should be initialized!\n', '        uint256 available = balanceOf(msg.sender); // balance of option holder\n', '\n', '        // check if there are tokens for sale\n', '        require(available > 0);\n', '\n', '        uint256 tokens = msg.value / (strike);\n', '        assert(tokens > 0 && tokens <= msg.value);\n', '\n', '        uint256 change = 0;\n', '        uint256 eth_to_transfer = 0;\n', '\n', '        if(tokens > available) {\n', '            tokens = available; // send all available tokens\n', '        }\n', '\n', '        // calculate the change for the operation\n', '        eth_to_transfer = tokens * strike;\n', '        assert(eth_to_transfer >= tokens);\n', '        change = msg.value - eth_to_transfer;\n', '        assert(change < msg.value);\n', '\n', '        if(!baseToken.transfer(msg.sender, tokens)) {\n', '            revert(); // error, revert transaction\n', '        }\n', '\n', '        uint256 new_balance = balanceOf(msg.sender) - tokens;\n', '        tokenHolders.setBalance(msg.sender, new_balance);\n', '\n', '        // new balance should be less then old balance\n', '        assert(balanceOf(msg.sender) < available);\n', '\n', '        if(change > 0) {\n', '            msg.sender.transfer(change); // return the change\n', '        }\n', '\n', '        if(eth_to_transfer > 0) {\n', '            owner.transfer(eth_to_transfer); // transfer eth for tokens to the contract owner\n', '        }\n', '\n', '        Redeem(msg.sender, tokens, eth_to_transfer);\n', '    }\n', '\n', '    /*\n', '        Allows the the contract owner to withdraw all unsold base tokens,\n', '        also deinitializes the token\n', '    */\n', '    function withdraw() public returns(bool success) {\n', '        require(msg.sender == owner);\n', '        if(now <= expiration || !_initialized)\n', '            return false;\n', '\n', '        // transfer all tokens\n', '        baseToken.transfer(owner, totalSupply());\n', '\n', '        // perform deinitialization\n', '        baseToken = ERC20(0);\n', '        tokenHolders = TokenHolders(0);\n', '        _initialized = false;\n', '        return true;\n', '    }\n', '}']
['/**\n', ' *  The Option token contract complies with the ERC20 standard.\n', ' *  This contract implements american option.\n', ' *  Holders of the Option tokens can make a purchase of the underlying asset\n', ' *  at the price of Strike until the Expiration time.\n', " *  The Strike price and Expiration date are set once and can't be changed.\n", ' *  Author: Alexey Bukhteyev\n', ' **/\n', '\n', 'pragma solidity ^0.4.4;\n', '\n', 'contract ERC20 {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '\n', '    function name() public constant returns(string);\n', '    function symbol() public constant returns(string);\n', '\n', '    function totalSupply() public constant returns(uint256 supply);\n', '    function balanceOf(address _owner) public constant returns(uint256 balance);\n', '    function transfer(address _to, uint256 _value) public returns(bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success);\n', '    function approve(address _spender, uint256 _value) public returns(bool success);\n', '    function allowance(address _owner, address _spender) public constant returns(uint256 remaining);\n', '    function decimals() public constant returns(uint8);\n', '}\n', '\n', '/*\n', '    Allows to recreate OptionToken contract on the same address.\n', "    Just create new TokenHolders(OptionToken) and reinitiallize OptionToken using it's address\n", '*/\n', 'contract TokenHolders {\n', '    address public owner;\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '\n', '    /*\n', '        TokenHolders contract is being connected to OptionToken on creation.\n', '        Nobody can modify balanceOf and allowance except OptionToken\n', '    */\n', '\n', '    function validate() external constant returns (bool);\n', '\n', '    function setBalance(address _to, uint256 _value) external;\n', '\n', '    /* Send some of your tokens to a given address */\n', '    function transfer(address _from, address _to, uint256 _value) public returns(bool success);\n', '\n', '    /* Allow another contract or person to spend some tokens in your behalf */\n', '    function approve(address _sender, address _spender, uint256 _value) public returns(bool success);\n', '\n', '    /* A contract or  person attempts to get the tokens of somebody else.\n', '     *  This is only allowed if the token holder approved. */\n', '    function transferWithAllowance(address _origin, address _from, address _to, uint256 _value)\n', '    public returns(bool success);\n', '}\n', '\n', '/*\n', '    This ERC20 contract is a basic option contract that implements a token which\n', '    allows to token holder to buy some asset for the fixed strike price before expiration date.\n', '*/\n', 'contract OptionToken {\n', "    string public standard = 'ERC20';\n", '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    address public owner;\n', '\n', '    // Option characteristics\n', '    uint256 public expiration = 1512172800; //02.12.2017 Use unix timespamp\n', '    uint256 public strike = 20000000000;\n', '\n', '    ERC20 public baseToken;\n', '    TokenHolders public tokenHolders;\n', '\n', '    bool _initialized = false;\n', '\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    // ERC20 events\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '\n', '    // OptionToken events\n', '    event Deposit(address indexed from, uint256 value);\n', '    event Redeem(address indexed from, uint256 value, uint256 ethvalue);\n', '    event Issue(address indexed issuer, uint256 value);\n', '\n', '    // Only set owner on the constructor\n', '    function OptionToken() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // ERC20 functions\n', '    function balanceOf(address _owner) public constant returns(uint256 balance) {\n', '        return tokenHolders.balanceOf(_owner);\n', '    }\n', '\n', '    function totalSupply() public constant returns(uint256 supply) {\n', '        // total supply is a balance of this contract in base tokens\n', '        return baseToken.balanceOf(this);\n', '    }\n', '\n', '    /* Send some of your tokens to a given address */\n', '    function transfer(address _to, uint256 _value) public returns(bool success) {\n', '        if(now > expiration)\n', '            return false;\n', '\n', '        if(!tokenHolders.transfer(msg.sender, _to, _value))\n', '            return false;\n', '\n', '        Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\n', '        return true;\n', '    }\n', '\n', '    /* Allow another contract or person to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value) public returns(bool success) {\n', '        if(now > expiration)\n', '            return false;\n', '\n', '        if(!tokenHolders.approve(msg.sender, _spender, _value))\n', '            return false;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /* A contract or  person attempts to get the tokens of somebody else.\n', '     *  This is only allowed if the token holder approved. */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {\n', '        if(now > expiration)\n', '            return false;\n', '\n', '        if(!tokenHolders.transferWithAllowance(msg.sender, _from, _to, _value))\n', '            return false;\n', '\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public constant returns(uint256 remaining) {\n', '        return tokenHolders.allowance(_owner, _spender);\n', '    }\n', '\n', '    // OptionToken functions\n', '\n', '    /*\n', '        Then we should pass base token contract address to init() function.\n', '        Only contract creator can call init() and only once\n', '    */\n', '    function init(ERC20 _baseToken, TokenHolders _tokenHolders, string _name, string _symbol,\n', '                uint256 _exp, uint256 _strike) public returns(bool success) {\n', '        require(msg.sender == owner && !_initialized);\n', '\n', '        baseToken = _baseToken;\n', '        tokenHolders = _tokenHolders;\n', '\n', '        // if baseToken.totalSupply() is zero - something is wrong\n', '        assert(baseToken.totalSupply() != 0);\n', '        // validate tokenHolders contract owner - it should be OptionToken\n', '        assert(tokenHolders.validate());\n', '\n', '        name = _name;\n', '        symbol = _symbol;\n', '        expiration = _exp;\n', '        strike = _strike;\n', '\n', '        decimals = baseToken.decimals();\n', '\n', '        _initialized = true;\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        Allows to increase totalSupply and get OptionTokens to their balance.\n', '        Before calling depositTokens the caller should approve the transfer for this contract address\n', '        using ERC20.approve().\n', '        Actually should be called by contract owner, because no ETH payout will be done for token transfer.\n', '    */\n', '    function issue(uint256 _value) public returns(bool success) {\n', '        require(now <= expiration && _initialized);\n', '\n', '        uint256 receiver_balance = balanceOf(msg.sender) + _value;\n', '        assert(receiver_balance >= _value);\n', '\n', '        // check if transfer failed\n', '        if(!baseToken.transferFrom(msg.sender, this, _value))\n', '            revert();\n', '\n', '        tokenHolders.setBalance(msg.sender, receiver_balance);\n', '        Issue(msg.sender, receiver_balance);\n', '\n', '        return true;\n', '    }\n', '\n', '    /*\n', '        Buy base tokens for the strike price\n', '    */\n', '    function() public payable {\n', '        require(now <= expiration && _initialized); // the contract should be initialized!\n', '        uint256 available = balanceOf(msg.sender); // balance of option holder\n', '\n', '        // check if there are tokens for sale\n', '        require(available > 0);\n', '\n', '        uint256 tokens = msg.value / (strike);\n', '        assert(tokens > 0 && tokens <= msg.value);\n', '\n', '        uint256 change = 0;\n', '        uint256 eth_to_transfer = 0;\n', '\n', '        if(tokens > available) {\n', '            tokens = available; // send all available tokens\n', '        }\n', '\n', '        // calculate the change for the operation\n', '        eth_to_transfer = tokens * strike;\n', '        assert(eth_to_transfer >= tokens);\n', '        change = msg.value - eth_to_transfer;\n', '        assert(change < msg.value);\n', '\n', '        if(!baseToken.transfer(msg.sender, tokens)) {\n', '            revert(); // error, revert transaction\n', '        }\n', '\n', '        uint256 new_balance = balanceOf(msg.sender) - tokens;\n', '        tokenHolders.setBalance(msg.sender, new_balance);\n', '\n', '        // new balance should be less then old balance\n', '        assert(balanceOf(msg.sender) < available);\n', '\n', '        if(change > 0) {\n', '            msg.sender.transfer(change); // return the change\n', '        }\n', '\n', '        if(eth_to_transfer > 0) {\n', '            owner.transfer(eth_to_transfer); // transfer eth for tokens to the contract owner\n', '        }\n', '\n', '        Redeem(msg.sender, tokens, eth_to_transfer);\n', '    }\n', '\n', '    /*\n', '        Allows the the contract owner to withdraw all unsold base tokens,\n', '        also deinitializes the token\n', '    */\n', '    function withdraw() public returns(bool success) {\n', '        require(msg.sender == owner);\n', '        if(now <= expiration || !_initialized)\n', '            return false;\n', '\n', '        // transfer all tokens\n', '        baseToken.transfer(owner, totalSupply());\n', '\n', '        // perform deinitialization\n', '        baseToken = ERC20(0);\n', '        tokenHolders = TokenHolders(0);\n', '        _initialized = false;\n', '        return true;\n', '    }\n', '}']
