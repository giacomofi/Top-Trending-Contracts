['pragma solidity ^ 0.4.15;\n', '\n', '/**\n', '*library name : SafeMath\n', '*purpose : be the library for the smart contract for the swap between the godz and ether\n', '*goal : to achieve the secure basic math operations\n', '*/\n', 'library SafeMath {\n', '\n', '  /*function name : mul*/\n', '  /*purpose : be the funcion for safe multiplicate*/\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    /*assert(a == 0 || c / a == b);*/\n', '    return c;\n', '  }\n', '\n', '  /*function name : div*/\n', '  /*purpose : be the funcion for safe division*/\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  /*function name : sub*/\n', '  /*purpose : be the funcion for safe substract*/\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    /*assert(b <= a);*/\n', '    return a - b;\n', '  }\n', '\n', '  /*function name : add*/\n', '  /*purpose : be the funcion for safe sum*/\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    /*assert(c >= a);*/\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', '*contract name : ReentryProtected\n', '*/\n', 'contract ReentryProtected{\n', '    /*The reentry protection state mutex.*/\n', '    bool __reMutex;\n', '\n', '    /**\n', '    *This modifier can be used on functions with external calls to\n', '    *prevent reentry attacks.\n', '    *Constraints:\n', '    *Protected functions must have only one point of exit.\n', '    *Protected functions cannot use the `return` keyword\n', '    *Protected functions return values must be through return parameters.\n', '    */\n', '    modifier preventReentry() {\n', '        require(!__reMutex);\n', '        __reMutex = true;\n', '        _;\n', '        delete __reMutex;\n', '        return;\n', '    }\n', '\n', '    /**\n', '    *This modifier can be applied to public access state mutation functions\n', '    *to protect against reentry if a `preventReentry` function has already\n', '    *set the mutex. This prevents the contract from being reenter under a\n', '    *different memory context which can break state variable integrity.\n', '    */\n', '    modifier noReentry() {\n', '        require(!__reMutex);\n', '        _;\n', '    }\n', '}\n', '\n', '/**\n', '*contract name : GodzSwapGodzEtherCompliance\n', '*purpose : be the smart contract for compliance of the greater than usd5000\n', '*/\n', 'contract GodzSwapGodzEtherCompliance{\n', '    //address of the owner of the contract\n', '    address public owner;\n', '    \n', '    /*structure for store the sale*/\n', '    struct GodzBuyAccounts\n', '    {\n', '        uint256 amount;/*amount sent*/\n', '        address account;/*account that sent*/\n', '        uint sendGodz;/*if send the godz back*/\n', '    }\n', '\n', '    /*mapping of the acounts that send more than usd5000*/\n', '    mapping(uint=>GodzBuyAccounts) public accountsHolding;\n', '    \n', '    /*index of the account information*/\n', '    uint public indexAccount = 0;\n', '\n', '    /*account information*/\n', '    address public swapContract;/*address of the swap contract*/\n', '\n', '\n', '    /*function name : GodzSwapGodzEtherCompliance*/\n', '    /*purpose : be the constructor and the setter of the owner*/\n', '    /*goal : to set the owner of the contract*/    \n', '    function GodzSwapGodzEtherCompliance()\n', '    {\n', '        /*sets the owner of the contract than compliance with the greater than usd5000 maximiun*/\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /*function name : setHolderInformation*/\n', '    /*purpose : be the setter of the swap contract and wallet holder*/\n', '    /*goal : to set de swap contract address and the wallet holder address*/    \n', '    function setHolderInformation(address _swapContract)\n', '    {    \n', '        /*if the owner is setting the information of the holder and the swap*/\n', '        if (msg.sender==owner)\n', '        {\n', '            /*address of the swap contract*/\n', '            swapContract = _swapContract;\n', '        }\n', '    }\n', '\n', '    /*function name : SaveAccountBuyingGodz*/\n', '    /*purpose : be the safe function that map the account that send it*/\n', '    /*goal : to store the account information*/\n', '    function SaveAccountBuyingGodz(address account, uint256 amount) public returns (bool success) \n', '    {\n', '        /*if the sender is the swapContract*/\n', '        if (msg.sender==swapContract)\n', '        {\n', '            /*increment the index*/\n', '            indexAccount += 1;\n', '            /*store the account informacion*/\n', '            accountsHolding[indexAccount].account = account;\n', '            accountsHolding[indexAccount].amount = amount;\n', '            accountsHolding[indexAccount].sendGodz = 0;\n', '            /*transfer the ether to the wallet holder*/\n', '            /*account save was completed*/\n', '            return true;\n', '        }\n', '        else\n', '        {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /*function name : setSendGodz*/\n', '    /*purpose : be the flag update for the compliance account*/\n', '    /*goal : to get the flag on the account*/\n', '    function setSendGodz(uint index) public \n', '    {\n', '        if (owner == msg.sender)\n', '        {\n', '            accountsHolding[index].sendGodz = 1;\n', '        }\n', '    }\n', '\n', '    /*function name : getAccountInformation*/\n', '    /*purpose : be the getter of the information of the account*/\n', '    /*goal : to get the amount and the acount of a compliance account*/\n', '    function getAccountInformation(uint index) public returns (address account, uint256 amount, uint sendGodz)\n', '    {\n', '        /*return the account of a compliance*/\n', '        return (accountsHolding[index].account, accountsHolding[index].amount, accountsHolding[index].sendGodz);\n', '    }\n', '}\n', '\n', '/**\n', '*contract name : GodzSwapGodzEther\n', '*purpose : be the smart contract for the swap between the godz and ether\n', '*goal : to achieve the swap transfers\n', '*/\n', 'contract GodzSwapGodzEther  is ReentryProtected{\n', '    address public seller;/*address of the owner of the contract creation*/\n', '    address public tokenContract;/*address of the erc20 token smart contract for the swap*/\n', '    address public complianceContract;/*compliance contract*/\n', '    address public complianceWallet;/*compliance wallet address*/\n', '    uint256 public sellPrice;/*value price of the swap*/\n', '    uint256 public sellQuantity;/*quantity value of the swap*/\n', '\n', '    /*function name : GodzSwapGodzEther*/\n', '    /*purpose : be the constructor of the swap smart contract*/\n', '    /*goal : register the basic information of the swap smart contract*/\n', '    function GodzSwapGodzEther(\n', '    address token,\n', '    address complianceC,\n', '    address complianceW\n', '    ){\n', '        tokenContract = token;\n', '        /*owner of the quantity of supply of the erc20 token*/\n', '        seller = msg.sender;\n', '        /*swap price of the token supply*/\n', '        sellPrice = 0.00625 * 1 ether;\n', '        /*total quantity to swap*/\n', '        sellQuantity = SafeMath.mul(210000000, 1 ether);\n', '        /*compliance contract store accounts*/\n', '        complianceContract = complianceC;\n', '        /*compliance wallet holder*/\n', '        complianceWallet = complianceW;\n', '    }\n', '\n', '    /*function name : () payable*/\n', '    /*purpose : be the swap executor*/\n', '    /*goal : to transfer the godz to the investor and the ether to the owner of the godz*/\n', '    function() payable preventReentry\n', '    {\n', '        /*address of the buyer*/\n', '        address buyer = msg.sender;\n', '\n', '        /*value paid and receive on the swap call*/\n', '        uint256 valuePaid = msg.value;\n', '\n', '        /*set the quantity of godz on behalf of the ether that is send to this function*/\n', '  \t\t  uint256 buyQuantity = SafeMath.mul((SafeMath.div(valuePaid, sellPrice)), 1 ether);\n', '\n', '        /*gets the balance of the owner of the godz*/\n', '        uint256 balanceSeller = Token(tokenContract).balanceOf(seller);\n', '\n', '        /*get the allowance of the owner of the godz*/\n', '  \t\tuint256 balanceAllowed = Token(tokenContract).allowance(seller,this);\n', '\n', '        if (seller!=buyer) /*if the seller of godz on swap is different than the investor buying*/\n', '        {\n', '            /*if the balance and the allowance match a valid quantity swap*/\n', '      \t\tif ((balanceAllowed >= buyQuantity) && (balanceSeller >= buyQuantity))\n', '            {\n', '                /*if the msg.value(ether sent) is greater than compliance, store it and sent to the wallet holder*/\n', '                if (valuePaid>(20 * 1 ether))\n', '                {\n', '                    /*transfer the value(ether) to the compliance holder wallet*/\n', '                    complianceWallet.transfer(valuePaid);\n', '                    /*save the account information*/\n', '                    require(GodzSwapGodzEtherCompliance(complianceContract).SaveAccountBuyingGodz(buyer, valuePaid));\n', '                }\n', '                else\n', '                {\n', '                    /*transfer the ether inside to the seller of the godz*/\n', '                    seller.transfer(valuePaid);\n', '                    /*call the transferfrom function of the erc20 token smart contract*/\n', '                    require(Token(tokenContract).transferFrom(seller, buyer, buyQuantity));\n', '                }\n', '            }\n', '            else/*if not a valid match between allowance and balance of the owner of godz, return the ether*/\n', '            {\n', '                /*send back the ether received*/\n', '                buyer.transfer(valuePaid);\n', '            }\n', '        }\n', '    }\n', '\n', '    /*function name : safeWithdrawal*/\n', '    /*purpose : be the safe withrow function in case of the contract keep ether inside*/\n', '    /*goal : to transfer the ether to the owner of the swap contract*/\n', '    function safeWithdrawal()\n', '    {\n', '        /*requires that the contract call is the owner of the swap contract*/\n', '        /*require(seller == msg.sender);*/\n', '        /*if the seller of the godz is the call contract address*/\n', '        if (seller == msg.sender)\n', '        {\n', '            /*transfer the ether inside to the seller of the godz*/\n', '            seller.transfer(this.balance);\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', '*contract name : tokenRecipient\n', '*/\n', 'contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n', '\n', '/**\n', '*contract name : Token\n', '*/\n', 'contract Token {\n', '    /*using the secure math library for basic math operations*/\n', '    using SafeMath for uint256;\n', '\n', '    /* Public variables of the token */\n', '    string public standard = &#39;DSCS.GODZ.TOKEN&#39;;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function Token(\n', '        uint256 initialSupply,\n', '        string tokenName,\n', '        uint8 decimalUnits,\n', '        string tokenSymbol\n', '        ) {\n', '        balanceOf[msg.sender] = initialSupply;                  /* Give the creator all initial tokens*/\n', '        totalSupply = initialSupply;                            /* Update total supply*/\n', '        name = tokenName;                                       /* Set the name for display purposes*/\n', '        symbol = tokenSymbol;                                   /* Set the symbol for display purposes*/\n', '        decimals = decimalUnits;                                /* Amount of decimals for display purposes*/\n', '    }\n', '\n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) {\n', '        if (_to == 0x0) revert();                               /* Prevent transfer to 0x0 address. Use burn() instead*/\n', '        if (balanceOf[msg.sender] < _value) revert();           /* Check if the sender has enough*/\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); /* Check for overflows*/\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);                        /* Subtract from the sender*/\n', '        balanceOf[_to] = balanceOf[_to].add(_value);                               /* Add the same to the recipient*/\n', '        Transfer(msg.sender, _to, _value);                      /* Notify anyone listening that this transfer took place*/\n', '    }\n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value)\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /* Approve and then communicate the approved contract in a single tx */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /* A contract attempts to get the coins but transfer from the origin*/\n', '    function transferFromOrigin(address _to, uint256 _value)  returns (bool success) {\n', '        address origin = tx.origin;\n', '        if (origin == 0x0) revert();\n', '        if (_to == 0x0) revert();                                /* Prevent transfer to 0x0 address.*/\n', '        if (balanceOf[origin] < _value) revert();                /* Check if the sender has enough*/\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  /* Check for overflows*/\n', '        balanceOf[origin] = balanceOf[origin].sub(_value);       /* Subtract from the sender*/\n', '        balanceOf[_to] = balanceOf[_to].add(_value);             /* Add the same to the recipient*/\n', '        return true;\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (_to == 0x0) revert();                                /* Prevent transfer to 0x0 address.*/\n', '        if (balanceOf[_from] < _value) revert();                 /* Check if the sender has enough*/\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  /* Check for overflows*/\n', '        if (_value > allowance[_from][msg.sender]) revert();     /* Check allowance*/\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);                              /* Subtract from the sender*/\n', '        balanceOf[_to] = balanceOf[_to].add(_value);                                /* Add the same to the recipient*/\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '}']
['pragma solidity ^ 0.4.15;\n', '\n', '/**\n', '*library name : SafeMath\n', '*purpose : be the library for the smart contract for the swap between the godz and ether\n', '*goal : to achieve the secure basic math operations\n', '*/\n', 'library SafeMath {\n', '\n', '  /*function name : mul*/\n', '  /*purpose : be the funcion for safe multiplicate*/\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    /*assert(a == 0 || c / a == b);*/\n', '    return c;\n', '  }\n', '\n', '  /*function name : div*/\n', '  /*purpose : be the funcion for safe division*/\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  /*function name : sub*/\n', '  /*purpose : be the funcion for safe substract*/\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    /*assert(b <= a);*/\n', '    return a - b;\n', '  }\n', '\n', '  /*function name : add*/\n', '  /*purpose : be the funcion for safe sum*/\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    /*assert(c >= a);*/\n', '    return c;\n', '  }\n', '}\n', '\n', '/**\n', '*contract name : ReentryProtected\n', '*/\n', 'contract ReentryProtected{\n', '    /*The reentry protection state mutex.*/\n', '    bool __reMutex;\n', '\n', '    /**\n', '    *This modifier can be used on functions with external calls to\n', '    *prevent reentry attacks.\n', '    *Constraints:\n', '    *Protected functions must have only one point of exit.\n', '    *Protected functions cannot use the `return` keyword\n', '    *Protected functions return values must be through return parameters.\n', '    */\n', '    modifier preventReentry() {\n', '        require(!__reMutex);\n', '        __reMutex = true;\n', '        _;\n', '        delete __reMutex;\n', '        return;\n', '    }\n', '\n', '    /**\n', '    *This modifier can be applied to public access state mutation functions\n', '    *to protect against reentry if a `preventReentry` function has already\n', '    *set the mutex. This prevents the contract from being reenter under a\n', '    *different memory context which can break state variable integrity.\n', '    */\n', '    modifier noReentry() {\n', '        require(!__reMutex);\n', '        _;\n', '    }\n', '}\n', '\n', '/**\n', '*contract name : GodzSwapGodzEtherCompliance\n', '*purpose : be the smart contract for compliance of the greater than usd5000\n', '*/\n', 'contract GodzSwapGodzEtherCompliance{\n', '    //address of the owner of the contract\n', '    address public owner;\n', '    \n', '    /*structure for store the sale*/\n', '    struct GodzBuyAccounts\n', '    {\n', '        uint256 amount;/*amount sent*/\n', '        address account;/*account that sent*/\n', '        uint sendGodz;/*if send the godz back*/\n', '    }\n', '\n', '    /*mapping of the acounts that send more than usd5000*/\n', '    mapping(uint=>GodzBuyAccounts) public accountsHolding;\n', '    \n', '    /*index of the account information*/\n', '    uint public indexAccount = 0;\n', '\n', '    /*account information*/\n', '    address public swapContract;/*address of the swap contract*/\n', '\n', '\n', '    /*function name : GodzSwapGodzEtherCompliance*/\n', '    /*purpose : be the constructor and the setter of the owner*/\n', '    /*goal : to set the owner of the contract*/    \n', '    function GodzSwapGodzEtherCompliance()\n', '    {\n', '        /*sets the owner of the contract than compliance with the greater than usd5000 maximiun*/\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /*function name : setHolderInformation*/\n', '    /*purpose : be the setter of the swap contract and wallet holder*/\n', '    /*goal : to set de swap contract address and the wallet holder address*/    \n', '    function setHolderInformation(address _swapContract)\n', '    {    \n', '        /*if the owner is setting the information of the holder and the swap*/\n', '        if (msg.sender==owner)\n', '        {\n', '            /*address of the swap contract*/\n', '            swapContract = _swapContract;\n', '        }\n', '    }\n', '\n', '    /*function name : SaveAccountBuyingGodz*/\n', '    /*purpose : be the safe function that map the account that send it*/\n', '    /*goal : to store the account information*/\n', '    function SaveAccountBuyingGodz(address account, uint256 amount) public returns (bool success) \n', '    {\n', '        /*if the sender is the swapContract*/\n', '        if (msg.sender==swapContract)\n', '        {\n', '            /*increment the index*/\n', '            indexAccount += 1;\n', '            /*store the account informacion*/\n', '            accountsHolding[indexAccount].account = account;\n', '            accountsHolding[indexAccount].amount = amount;\n', '            accountsHolding[indexAccount].sendGodz = 0;\n', '            /*transfer the ether to the wallet holder*/\n', '            /*account save was completed*/\n', '            return true;\n', '        }\n', '        else\n', '        {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /*function name : setSendGodz*/\n', '    /*purpose : be the flag update for the compliance account*/\n', '    /*goal : to get the flag on the account*/\n', '    function setSendGodz(uint index) public \n', '    {\n', '        if (owner == msg.sender)\n', '        {\n', '            accountsHolding[index].sendGodz = 1;\n', '        }\n', '    }\n', '\n', '    /*function name : getAccountInformation*/\n', '    /*purpose : be the getter of the information of the account*/\n', '    /*goal : to get the amount and the acount of a compliance account*/\n', '    function getAccountInformation(uint index) public returns (address account, uint256 amount, uint sendGodz)\n', '    {\n', '        /*return the account of a compliance*/\n', '        return (accountsHolding[index].account, accountsHolding[index].amount, accountsHolding[index].sendGodz);\n', '    }\n', '}\n', '\n', '/**\n', '*contract name : GodzSwapGodzEther\n', '*purpose : be the smart contract for the swap between the godz and ether\n', '*goal : to achieve the swap transfers\n', '*/\n', 'contract GodzSwapGodzEther  is ReentryProtected{\n', '    address public seller;/*address of the owner of the contract creation*/\n', '    address public tokenContract;/*address of the erc20 token smart contract for the swap*/\n', '    address public complianceContract;/*compliance contract*/\n', '    address public complianceWallet;/*compliance wallet address*/\n', '    uint256 public sellPrice;/*value price of the swap*/\n', '    uint256 public sellQuantity;/*quantity value of the swap*/\n', '\n', '    /*function name : GodzSwapGodzEther*/\n', '    /*purpose : be the constructor of the swap smart contract*/\n', '    /*goal : register the basic information of the swap smart contract*/\n', '    function GodzSwapGodzEther(\n', '    address token,\n', '    address complianceC,\n', '    address complianceW\n', '    ){\n', '        tokenContract = token;\n', '        /*owner of the quantity of supply of the erc20 token*/\n', '        seller = msg.sender;\n', '        /*swap price of the token supply*/\n', '        sellPrice = 0.00625 * 1 ether;\n', '        /*total quantity to swap*/\n', '        sellQuantity = SafeMath.mul(210000000, 1 ether);\n', '        /*compliance contract store accounts*/\n', '        complianceContract = complianceC;\n', '        /*compliance wallet holder*/\n', '        complianceWallet = complianceW;\n', '    }\n', '\n', '    /*function name : () payable*/\n', '    /*purpose : be the swap executor*/\n', '    /*goal : to transfer the godz to the investor and the ether to the owner of the godz*/\n', '    function() payable preventReentry\n', '    {\n', '        /*address of the buyer*/\n', '        address buyer = msg.sender;\n', '\n', '        /*value paid and receive on the swap call*/\n', '        uint256 valuePaid = msg.value;\n', '\n', '        /*set the quantity of godz on behalf of the ether that is send to this function*/\n', '  \t\t  uint256 buyQuantity = SafeMath.mul((SafeMath.div(valuePaid, sellPrice)), 1 ether);\n', '\n', '        /*gets the balance of the owner of the godz*/\n', '        uint256 balanceSeller = Token(tokenContract).balanceOf(seller);\n', '\n', '        /*get the allowance of the owner of the godz*/\n', '  \t\tuint256 balanceAllowed = Token(tokenContract).allowance(seller,this);\n', '\n', '        if (seller!=buyer) /*if the seller of godz on swap is different than the investor buying*/\n', '        {\n', '            /*if the balance and the allowance match a valid quantity swap*/\n', '      \t\tif ((balanceAllowed >= buyQuantity) && (balanceSeller >= buyQuantity))\n', '            {\n', '                /*if the msg.value(ether sent) is greater than compliance, store it and sent to the wallet holder*/\n', '                if (valuePaid>(20 * 1 ether))\n', '                {\n', '                    /*transfer the value(ether) to the compliance holder wallet*/\n', '                    complianceWallet.transfer(valuePaid);\n', '                    /*save the account information*/\n', '                    require(GodzSwapGodzEtherCompliance(complianceContract).SaveAccountBuyingGodz(buyer, valuePaid));\n', '                }\n', '                else\n', '                {\n', '                    /*transfer the ether inside to the seller of the godz*/\n', '                    seller.transfer(valuePaid);\n', '                    /*call the transferfrom function of the erc20 token smart contract*/\n', '                    require(Token(tokenContract).transferFrom(seller, buyer, buyQuantity));\n', '                }\n', '            }\n', '            else/*if not a valid match between allowance and balance of the owner of godz, return the ether*/\n', '            {\n', '                /*send back the ether received*/\n', '                buyer.transfer(valuePaid);\n', '            }\n', '        }\n', '    }\n', '\n', '    /*function name : safeWithdrawal*/\n', '    /*purpose : be the safe withrow function in case of the contract keep ether inside*/\n', '    /*goal : to transfer the ether to the owner of the swap contract*/\n', '    function safeWithdrawal()\n', '    {\n', '        /*requires that the contract call is the owner of the swap contract*/\n', '        /*require(seller == msg.sender);*/\n', '        /*if the seller of the godz is the call contract address*/\n', '        if (seller == msg.sender)\n', '        {\n', '            /*transfer the ether inside to the seller of the godz*/\n', '            seller.transfer(this.balance);\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', '*contract name : tokenRecipient\n', '*/\n', 'contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n', '\n', '/**\n', '*contract name : Token\n', '*/\n', 'contract Token {\n', '    /*using the secure math library for basic math operations*/\n', '    using SafeMath for uint256;\n', '\n', '    /* Public variables of the token */\n', "    string public standard = 'DSCS.GODZ.TOKEN';\n", '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */\n', '    function Token(\n', '        uint256 initialSupply,\n', '        string tokenName,\n', '        uint8 decimalUnits,\n', '        string tokenSymbol\n', '        ) {\n', '        balanceOf[msg.sender] = initialSupply;                  /* Give the creator all initial tokens*/\n', '        totalSupply = initialSupply;                            /* Update total supply*/\n', '        name = tokenName;                                       /* Set the name for display purposes*/\n', '        symbol = tokenSymbol;                                   /* Set the symbol for display purposes*/\n', '        decimals = decimalUnits;                                /* Amount of decimals for display purposes*/\n', '    }\n', '\n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) {\n', '        if (_to == 0x0) revert();                               /* Prevent transfer to 0x0 address. Use burn() instead*/\n', '        if (balanceOf[msg.sender] < _value) revert();           /* Check if the sender has enough*/\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); /* Check for overflows*/\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);                        /* Subtract from the sender*/\n', '        balanceOf[_to] = balanceOf[_to].add(_value);                               /* Add the same to the recipient*/\n', '        Transfer(msg.sender, _to, _value);                      /* Notify anyone listening that this transfer took place*/\n', '    }\n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value)\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /* Approve and then communicate the approved contract in a single tx */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /* A contract attempts to get the coins but transfer from the origin*/\n', '    function transferFromOrigin(address _to, uint256 _value)  returns (bool success) {\n', '        address origin = tx.origin;\n', '        if (origin == 0x0) revert();\n', '        if (_to == 0x0) revert();                                /* Prevent transfer to 0x0 address.*/\n', '        if (balanceOf[origin] < _value) revert();                /* Check if the sender has enough*/\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  /* Check for overflows*/\n', '        balanceOf[origin] = balanceOf[origin].sub(_value);       /* Subtract from the sender*/\n', '        balanceOf[_to] = balanceOf[_to].add(_value);             /* Add the same to the recipient*/\n', '        return true;\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (_to == 0x0) revert();                                /* Prevent transfer to 0x0 address.*/\n', '        if (balanceOf[_from] < _value) revert();                 /* Check if the sender has enough*/\n', '        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  /* Check for overflows*/\n', '        if (_value > allowance[_from][msg.sender]) revert();     /* Check allowance*/\n', '        balanceOf[_from] = balanceOf[_from].sub(_value);                              /* Subtract from the sender*/\n', '        balanceOf[_to] = balanceOf[_to].add(_value);                                /* Add the same to the recipient*/\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '}']
