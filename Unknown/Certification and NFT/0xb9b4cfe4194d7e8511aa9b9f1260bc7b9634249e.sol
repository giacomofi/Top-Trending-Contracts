['pragma solidity ^0.4.10;\n', '\n', 'contract IERC20Token {\n', '    function totalSupply() public constant returns ( uint256 supply ) { supply; }\n', '    function balanceOf( address _owner ) public constant returns ( uint256 balance ) { _owner; balance; }\n', '    function allowance( address _owner, address _spender ) public constant returns ( uint256 remaining ) { _owner; _spender; remaining; }\n', '\n', '  function transfer( address _to, uint256 _value ) public returns ( bool success );\n', '  function transferFrom( address _from, address _to, uint256 _value ) public returns ( bool success );\n', '  function approve( address _spender, uint256 _value ) public returns ( bool success );\n', '}\n', '\n', 'contract RegaUtils {\n', '  modifier validAddress( address _address ) {\n', '    require( _address != 0x0 );\n', '    _;\n', '  }\n', '\n', '  // Overflow checked math\n', '  function safeAdd( uint256 x, uint256 y ) internal returns( uint256 ) {\n', '    uint256 z = x + y;\n', '    assert( z >= x );\n', '    return z;\n', '  }\n', '\n', '  function safeSub( uint256 x, uint256 y ) internal returns( uint256 ) {\n', '    assert( x >= y);\n', '    return x - y;\n', '  }\n', '}\n', '\n', 'contract ERC20Token is IERC20Token, RegaUtils {\n', '  uint256 public totalSupply = 0;\n', '  mapping( address => uint256 ) public balanceOf;\n', '  mapping( address => mapping( address => uint256 ) ) public allowance;\n', '\n', '  event Transfer( address indexed _from, address indexed _to, uint256 _value );\n', '  event Approval( address indexed _owner, address indexed _spender, uint256 _value );\n', '\n', '  function transfer( address _to, uint256 _value ) validAddress( _to )\n', '    returns( bool success )\n', '  {\n', '    balanceOf[ msg.sender ] = safeSub( balanceOf[ msg.sender ], _value );\n', '    balanceOf[ _to ] = safeAdd( balanceOf[ _to ], _value );\n', '    Transfer( msg.sender, _to, _value );\n', '    return true;\n', '  }\n', '\n', '  function transferFrom( address _from, address _to, uint256 _value ) validAddress( _from ) validAddress( _to )\n', '    returns( bool success )\n', '  {\n', '    allowance[ _from ][ msg.sender ] = safeSub( allowance[ _from ][ msg.sender ], _value );\n', '    balanceOf[ _from] = safeSub( balanceOf[_from], _value );\n', '    balanceOf[ _to] = safeAdd( balanceOf[_to], _value );\n', '    Transfer( _from, _to, _value );\n', '    return true;\n', '  }\n', '\n', '  function approve( address _spender, uint256 _value ) validAddress( _spender )\n', '    returns( bool success)\n', '  {\n', '    require( _value == 0 || allowance[ msg.sender ][ _spender ] == 0 );\n', '\n', '    allowance[ msg.sender ][ _spender ] = _value;\n', '    Approval( msg.sender, _spender, _value );\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract IApplyPreICO {\n', '  function applyTokens( address owner, uint tokens );\n', '}\n', '\n', 'contract PreICOToken is ERC20Token {\n', '\n', '  string public constant name = "REGA Risk Sharing preICO Token";\n', '  string public constant symbol = "RST-P";\n', '  uint8 public constant decimals = 10;\n', '\n', '  address public board;\n', '  address public owner;\n', '  uint public weiForToken;\n', '  uint public notMoreThan;\n', '  uint public notLessThan;\n', '  uint public tokensLimit;\n', '  uint public totalEther = 0;\n', '  address[] public holders;\n', '  bool public closed;\n', '  IApplyPreICO public rst;\n', '\n', '  event Issuance( address _to, uint _tokens, uint _amount, uint _sentBack );\n', '\n', '  modifier ownerOnly() {\n', '    require( msg.sender == owner );\n', '    _;\n', '  }\n', '\n', '  modifier boardOnly() {\n', '    require( msg.sender == board );\n', '    _;\n', '  }\n', '\n', '  modifier opened() {\n', '    require(!closed && weiForToken > 0 && totalSupply < tokensLimit);\n', '    _;\n', '  }\n', '\n', '  function PreICOToken( address _board ) {\n', '    board = _board;\n', '    owner = msg.sender;\n', '    weiForToken = 5 * uint(10)**(18-2-decimals); // 0.05 Ether\n', '    notMoreThan = 700 * uint(10)**decimals;\n', '    notLessThan = 100 * uint(10)**decimals;\n', '    tokensLimit = 30000 * uint(10)**decimals;\n', '    closed = true;\n', '  }\n', '\n', '  function() payable opened {\n', '      issueInternal( msg.sender, msg.value, true );\n', '  }\n', '\n', '  function setNotMoreThan( uint _notMoreThan ) public boardOnly {\n', '    notMoreThan = _notMoreThan * uint(10)**decimals;\n', '  }\n', '\n', '  function setNotLessThan( uint _notLessThan ) public boardOnly {\n', '    notLessThan = _notLessThan * uint(10)**decimals;\n', '  }\n', '\n', '  function setTokensLimit( uint _limit ) public boardOnly {\n', '    tokensLimit = _limit * uint(10)**decimals;\n', '  }\n', '\n', '  function setOpen( bool _open ) public boardOnly {\n', '    closed = !_open;\n', '  }\n', '\n', '  function setRST( IApplyPreICO _rst ) public boardOnly {\n', '    closed = true;\n', '    rst = _rst;\n', '  }\n', '\n', '  function getHoldersCount() public constant returns (uint count) {\n', '    count = holders.length;\n', '  }\n', '\n', '  function issue(address to, uint256 amount) public boardOnly validAddress(to) {\n', '    issueInternal( to, amount, false );\n', '  }\n', '\n', '  function buy() public payable opened {\n', '    issueInternal( msg.sender, msg.value, true );\n', '  }\n', '\n', '  function withdraw( uint amount ) public boardOnly {\n', '    board.transfer( amount );\n', '  }\n', '\n', '  function issueInternal(address to, uint256 amount, bool returnExcess) internal {\n', '    uint tokens = amount / weiForToken;\n', '    require( weiForToken > 0 && safeAdd(totalSupply, tokens) < tokensLimit && (balanceOf[to] < notMoreThan || notMoreThan == 0) && safeAdd(balanceOf[to], tokens) >= notLessThan );\n', '    uint sendBack = 0;\n', '    if( notMoreThan > 0 && safeAdd(balanceOf[to], tokens) > notMoreThan ) {\n', '      tokens = notMoreThan - balanceOf[to];\n', '      sendBack = amount - tokens * weiForToken;\n', '    }\n', '\n', '    totalEther = safeAdd(totalEther, amount - sendBack);\n', '    balanceOf[to] = safeAdd(balanceOf[to], tokens);\n', '    totalSupply = safeAdd(totalSupply, tokens);\n', '    holders.push(to);\n', '    if( returnExcess && sendBack > 0 && sendBack < amount )\n', '      to.transfer( sendBack );\n', '    Issuance(to, tokens, amount, returnExcess ? sendBack : 0);\n', '    Transfer( this, to, tokens );\n', '  }\n', '\n', '  function moveToRST() validAddress(rst) {\n', '    sendToRstForAddress( msg.sender );\n', '  }\n', '\n', '  function sendToRST( address from ) validAddress(rst) {\n', '    sendToRstForAddress( from );\n', '  }\n', '\n', '  function sendToRstForAddress( address from ) internal {\n', '    require( closed );\n', '    uint amount = balanceOf[from];\n', '    if( amount > 0 ) {\n', '      balanceOf[from] = 0;\n', '      rst.applyTokens( from, amount );\n', '      Transfer( from, rst, amount );\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.10;\n', '\n', 'contract IERC20Token {\n', '    function totalSupply() public constant returns ( uint256 supply ) { supply; }\n', '    function balanceOf( address _owner ) public constant returns ( uint256 balance ) { _owner; balance; }\n', '    function allowance( address _owner, address _spender ) public constant returns ( uint256 remaining ) { _owner; _spender; remaining; }\n', '\n', '  function transfer( address _to, uint256 _value ) public returns ( bool success );\n', '  function transferFrom( address _from, address _to, uint256 _value ) public returns ( bool success );\n', '  function approve( address _spender, uint256 _value ) public returns ( bool success );\n', '}\n', '\n', 'contract RegaUtils {\n', '  modifier validAddress( address _address ) {\n', '    require( _address != 0x0 );\n', '    _;\n', '  }\n', '\n', '  // Overflow checked math\n', '  function safeAdd( uint256 x, uint256 y ) internal returns( uint256 ) {\n', '    uint256 z = x + y;\n', '    assert( z >= x );\n', '    return z;\n', '  }\n', '\n', '  function safeSub( uint256 x, uint256 y ) internal returns( uint256 ) {\n', '    assert( x >= y);\n', '    return x - y;\n', '  }\n', '}\n', '\n', 'contract ERC20Token is IERC20Token, RegaUtils {\n', '  uint256 public totalSupply = 0;\n', '  mapping( address => uint256 ) public balanceOf;\n', '  mapping( address => mapping( address => uint256 ) ) public allowance;\n', '\n', '  event Transfer( address indexed _from, address indexed _to, uint256 _value );\n', '  event Approval( address indexed _owner, address indexed _spender, uint256 _value );\n', '\n', '  function transfer( address _to, uint256 _value ) validAddress( _to )\n', '    returns( bool success )\n', '  {\n', '    balanceOf[ msg.sender ] = safeSub( balanceOf[ msg.sender ], _value );\n', '    balanceOf[ _to ] = safeAdd( balanceOf[ _to ], _value );\n', '    Transfer( msg.sender, _to, _value );\n', '    return true;\n', '  }\n', '\n', '  function transferFrom( address _from, address _to, uint256 _value ) validAddress( _from ) validAddress( _to )\n', '    returns( bool success )\n', '  {\n', '    allowance[ _from ][ msg.sender ] = safeSub( allowance[ _from ][ msg.sender ], _value );\n', '    balanceOf[ _from] = safeSub( balanceOf[_from], _value );\n', '    balanceOf[ _to] = safeAdd( balanceOf[_to], _value );\n', '    Transfer( _from, _to, _value );\n', '    return true;\n', '  }\n', '\n', '  function approve( address _spender, uint256 _value ) validAddress( _spender )\n', '    returns( bool success)\n', '  {\n', '    require( _value == 0 || allowance[ msg.sender ][ _spender ] == 0 );\n', '\n', '    allowance[ msg.sender ][ _spender ] = _value;\n', '    Approval( msg.sender, _spender, _value );\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', 'contract IApplyPreICO {\n', '  function applyTokens( address owner, uint tokens );\n', '}\n', '\n', 'contract PreICOToken is ERC20Token {\n', '\n', '  string public constant name = "REGA Risk Sharing preICO Token";\n', '  string public constant symbol = "RST-P";\n', '  uint8 public constant decimals = 10;\n', '\n', '  address public board;\n', '  address public owner;\n', '  uint public weiForToken;\n', '  uint public notMoreThan;\n', '  uint public notLessThan;\n', '  uint public tokensLimit;\n', '  uint public totalEther = 0;\n', '  address[] public holders;\n', '  bool public closed;\n', '  IApplyPreICO public rst;\n', '\n', '  event Issuance( address _to, uint _tokens, uint _amount, uint _sentBack );\n', '\n', '  modifier ownerOnly() {\n', '    require( msg.sender == owner );\n', '    _;\n', '  }\n', '\n', '  modifier boardOnly() {\n', '    require( msg.sender == board );\n', '    _;\n', '  }\n', '\n', '  modifier opened() {\n', '    require(!closed && weiForToken > 0 && totalSupply < tokensLimit);\n', '    _;\n', '  }\n', '\n', '  function PreICOToken( address _board ) {\n', '    board = _board;\n', '    owner = msg.sender;\n', '    weiForToken = 5 * uint(10)**(18-2-decimals); // 0.05 Ether\n', '    notMoreThan = 700 * uint(10)**decimals;\n', '    notLessThan = 100 * uint(10)**decimals;\n', '    tokensLimit = 30000 * uint(10)**decimals;\n', '    closed = true;\n', '  }\n', '\n', '  function() payable opened {\n', '      issueInternal( msg.sender, msg.value, true );\n', '  }\n', '\n', '  function setNotMoreThan( uint _notMoreThan ) public boardOnly {\n', '    notMoreThan = _notMoreThan * uint(10)**decimals;\n', '  }\n', '\n', '  function setNotLessThan( uint _notLessThan ) public boardOnly {\n', '    notLessThan = _notLessThan * uint(10)**decimals;\n', '  }\n', '\n', '  function setTokensLimit( uint _limit ) public boardOnly {\n', '    tokensLimit = _limit * uint(10)**decimals;\n', '  }\n', '\n', '  function setOpen( bool _open ) public boardOnly {\n', '    closed = !_open;\n', '  }\n', '\n', '  function setRST( IApplyPreICO _rst ) public boardOnly {\n', '    closed = true;\n', '    rst = _rst;\n', '  }\n', '\n', '  function getHoldersCount() public constant returns (uint count) {\n', '    count = holders.length;\n', '  }\n', '\n', '  function issue(address to, uint256 amount) public boardOnly validAddress(to) {\n', '    issueInternal( to, amount, false );\n', '  }\n', '\n', '  function buy() public payable opened {\n', '    issueInternal( msg.sender, msg.value, true );\n', '  }\n', '\n', '  function withdraw( uint amount ) public boardOnly {\n', '    board.transfer( amount );\n', '  }\n', '\n', '  function issueInternal(address to, uint256 amount, bool returnExcess) internal {\n', '    uint tokens = amount / weiForToken;\n', '    require( weiForToken > 0 && safeAdd(totalSupply, tokens) < tokensLimit && (balanceOf[to] < notMoreThan || notMoreThan == 0) && safeAdd(balanceOf[to], tokens) >= notLessThan );\n', '    uint sendBack = 0;\n', '    if( notMoreThan > 0 && safeAdd(balanceOf[to], tokens) > notMoreThan ) {\n', '      tokens = notMoreThan - balanceOf[to];\n', '      sendBack = amount - tokens * weiForToken;\n', '    }\n', '\n', '    totalEther = safeAdd(totalEther, amount - sendBack);\n', '    balanceOf[to] = safeAdd(balanceOf[to], tokens);\n', '    totalSupply = safeAdd(totalSupply, tokens);\n', '    holders.push(to);\n', '    if( returnExcess && sendBack > 0 && sendBack < amount )\n', '      to.transfer( sendBack );\n', '    Issuance(to, tokens, amount, returnExcess ? sendBack : 0);\n', '    Transfer( this, to, tokens );\n', '  }\n', '\n', '  function moveToRST() validAddress(rst) {\n', '    sendToRstForAddress( msg.sender );\n', '  }\n', '\n', '  function sendToRST( address from ) validAddress(rst) {\n', '    sendToRstForAddress( from );\n', '  }\n', '\n', '  function sendToRstForAddress( address from ) internal {\n', '    require( closed );\n', '    uint amount = balanceOf[from];\n', '    if( amount > 0 ) {\n', '      balanceOf[from] = 0;\n', '      rst.applyTokens( from, amount );\n', '      Transfer( from, rst, amount );\n', '    }\n', '  }\n', '}']
