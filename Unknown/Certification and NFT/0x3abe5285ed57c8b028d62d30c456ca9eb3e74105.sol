['pragma solidity ^0.4.13;\n', '\n', 'contract Owned {\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    // This contract only defines a modifier and a few useful functions\n', '    // The function body is inserted where the special symbol "_" in the\n', '    // definition of a modifier appears.\n', '    modifier onlyOwner { if (msg.sender == owner) _; }\n', '\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    // This is a general safty function that allows the owner to do a lot\n', '    //  of things in the unlikely event that something goes wrong\n', '    // _dst is the contract being called making this like a 1/1 multisig\n', '    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n', '        _dst.call.value(_value)(_data);\n', '    }\n', '}\n', '\n', 'contract ChooseWHGReturnAddress is Owned {\n', '\n', '    mapping (address => address) returnAddresses;\n', '    uint public endDate;\n', '\n', '    /// @param _endDate After this time, if `requestReturn()` has not been called\n', '    /// the upgraded parity multisig will be locked in as the &#39;returnAddr&#39;\n', '    function ChooseWHGReturnAddress(uint _endDate) {\n', '        endDate = _endDate;\n', '    }\n', '\n', '    /////////////////////////\n', '    //   IMPORTANT\n', '    /////////////////////////\n', '    // @dev The `returnAddr` can be changed only once.\n', '    //  We will send the funds to the chosen address. This is Crypto, if the\n', '    //  address is wrong, your funds could be lost, please, proceed with extreme\n', '    //  caution and treat this like you are sending all of your funds to this\n', '    //  address.\n', '\n', '    /// @notice This function is used to choose an address for returning the funds.\n', '    ///  This function can only be called once, PLEASE READ THE NOTE ABOVE.\n', '    /// @param _returnAddr The address that will receive the recued funds\n', '    function requestReturn(address _returnAddr) {\n', '\n', '        // After the end date, the newly deployed parity multisig will be\n', '        //  chosen if no transaction is made.\n', '        require(now <= endDate);\n', '\n', '        require(returnAddresses[msg.sender] == 0x0);\n', '        returnAddresses[msg.sender] = _returnAddr;\n', '        ReturnRequested(msg.sender, _returnAddr);\n', '    }\n', '    /// @notice This is a simple getter function that will be used to return the\n', '    ///  address that the WHG will return the funds to\n', '    /// @param _addr The address of the newly deployed parity multisig\n', '    /// @return address The chosen address that the funds will be returned to\n', '    function getReturnAddress(address _addr) constant returns (address) {\n', '        if (returnAddresses[_addr] == 0x0) {\n', '            return _addr;\n', '        } else {\n', '            return returnAddresses[_addr];\n', '        }\n', '    }\n', '\n', '    function isReturnRequested(address _addr) constant returns (bool) {\n', '        return returnAddresses[_addr] != 0x0;\n', '    }\n', '\n', '    event ReturnRequested(address indexed origin, address indexed returnAddress);\n', '}']
['pragma solidity ^0.4.13;\n', '\n', 'contract Owned {\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    address public owner;\n', '\n', '    // This contract only defines a modifier and a few useful functions\n', '    // The function body is inserted where the special symbol "_" in the\n', '    // definition of a modifier appears.\n', '    modifier onlyOwner { if (msg.sender == owner) _; }\n', '\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        owner = _newOwner;\n', '    }\n', '\n', '    // This is a general safty function that allows the owner to do a lot\n', '    //  of things in the unlikely event that something goes wrong\n', '    // _dst is the contract being called making this like a 1/1 multisig\n', '    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n', '        _dst.call.value(_value)(_data);\n', '    }\n', '}\n', '\n', 'contract ChooseWHGReturnAddress is Owned {\n', '\n', '    mapping (address => address) returnAddresses;\n', '    uint public endDate;\n', '\n', '    /// @param _endDate After this time, if `requestReturn()` has not been called\n', "    /// the upgraded parity multisig will be locked in as the 'returnAddr'\n", '    function ChooseWHGReturnAddress(uint _endDate) {\n', '        endDate = _endDate;\n', '    }\n', '\n', '    /////////////////////////\n', '    //   IMPORTANT\n', '    /////////////////////////\n', '    // @dev The `returnAddr` can be changed only once.\n', '    //  We will send the funds to the chosen address. This is Crypto, if the\n', '    //  address is wrong, your funds could be lost, please, proceed with extreme\n', '    //  caution and treat this like you are sending all of your funds to this\n', '    //  address.\n', '\n', '    /// @notice This function is used to choose an address for returning the funds.\n', '    ///  This function can only be called once, PLEASE READ THE NOTE ABOVE.\n', '    /// @param _returnAddr The address that will receive the recued funds\n', '    function requestReturn(address _returnAddr) {\n', '\n', '        // After the end date, the newly deployed parity multisig will be\n', '        //  chosen if no transaction is made.\n', '        require(now <= endDate);\n', '\n', '        require(returnAddresses[msg.sender] == 0x0);\n', '        returnAddresses[msg.sender] = _returnAddr;\n', '        ReturnRequested(msg.sender, _returnAddr);\n', '    }\n', '    /// @notice This is a simple getter function that will be used to return the\n', '    ///  address that the WHG will return the funds to\n', '    /// @param _addr The address of the newly deployed parity multisig\n', '    /// @return address The chosen address that the funds will be returned to\n', '    function getReturnAddress(address _addr) constant returns (address) {\n', '        if (returnAddresses[_addr] == 0x0) {\n', '            return _addr;\n', '        } else {\n', '            return returnAddresses[_addr];\n', '        }\n', '    }\n', '\n', '    function isReturnRequested(address _addr) constant returns (bool) {\n', '        return returnAddresses[_addr] != 0x0;\n', '    }\n', '\n', '    event ReturnRequested(address indexed origin, address indexed returnAddress);\n', '}']
