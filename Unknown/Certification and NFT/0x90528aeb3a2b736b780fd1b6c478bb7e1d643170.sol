['pragma solidity ^0.4.11;\n', '\n', '/* taking ideas from FirstBlood token */\n', 'contract SafeMath {\n', '\n', '    /* function assert(bool assertion) internal { */\n', '    /*   if (!assertion) { */\n', '    /*     throw; */\n', '    /*   } */\n', '    /* }      // assert no longer needed once solidity is on 0.4.10 */\n', '\n', '    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x + y;\n', '      assert((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) internal returns(uint256) {\n', '      assert(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n', '\n', 'contract Token is owned {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    \n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is SafeMath, Token {\n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '            balances[_to] = safeAdd(balances[_to], _value);\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] = safeAdd(balances[_to], _value);\n', '            balances[_from] = safeSub(balances[_from], _value);\n', '            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract XPAToken is StandardToken {\n', '\n', '    // metadata\n', '    string public constant name = "XPlay Token";\n', '    string public constant symbol = "XPA";\n', '    uint256 public constant decimals = 18;\n', '    string public version = "1.0";\n', '\n', '    // contracts\n', '    address public ethFundDeposit;      // deposit address of ETH for XPlay Ltd.\n', '    address public xpaFundDeposit;      // deposit address for XPlay Ltd. use and XPA User Fund\n', '\n', '    // crowdsale parameters\n', '    bool public isFinalized;              // switched to true in operational state\n', '    uint256 public fundingStartBlock;\n', '    uint256 public fundingEndBlock;\n', '    uint256 public crowdsaleSupply = 0;         // crowdsale supply\n', '    uint256 public tokenExchangeRate = 23000;   // 23000 XPA tokens per 1 ETH\n', '    uint256 public constant tokenCreationCap =  10 * (10**9) * 10**decimals;\n', '    uint256 public tokenCrowdsaleCap =  4 * (10**8) * 10**decimals;\n', '\n', '    // events\n', '    event CreateXPA(address indexed _to, uint256 _value);\n', '\n', '    // constructor\n', '    function XPAToken(\n', '        address _ethFundDeposit,\n', '        address _xpaFundDeposit,\n', '        uint256 _tokenExchangeRate,\n', '        uint256 _fundingStartBlock,\n', '        uint256 _fundingEndBlock)\n', '    {\n', '        isFinalized = false;                   //controls pre through crowdsale state\n', '        ethFundDeposit = _ethFundDeposit;\n', '        xpaFundDeposit = _xpaFundDeposit;\n', '        tokenExchangeRate = _tokenExchangeRate;\n', '        fundingStartBlock = _fundingStartBlock;\n', '        fundingEndBlock = _fundingEndBlock;\n', '        totalSupply = tokenCreationCap;\n', '        balances[xpaFundDeposit] = tokenCreationCap;    // deposit all XPA to XPlay Ltd.\n', '        CreateXPA(xpaFundDeposit, tokenCreationCap);    // logs deposit of XPlay Ltd. fund\n', '    }\n', '\n', '    function () payable {\n', '        assert(!isFinalized);\n', '        require(block.number >= fundingStartBlock);\n', '        require(block.number < fundingEndBlock);\n', '        require(msg.value > 0);\n', '\n', '        uint256 tokens = safeMult(msg.value, tokenExchangeRate);    // check that we&#39;re not over totals\n', '        crowdsaleSupply = safeAdd(crowdsaleSupply, tokens);\n', '\n', '        // return money if something goes wrong\n', '        require(tokenCrowdsaleCap >= crowdsaleSupply);\n', '\n', '        balances[msg.sender] += tokens;     // add amount of XPA to sender\n', '        balances[xpaFundDeposit] = safeSub(balances[xpaFundDeposit], tokens); // subtracts amount from XPlay&#39;s balance\n', '        CreateXPA(msg.sender, tokens);      // logs token creation\n', '\n', '    }\n', '    /// @dev Accepts ether and creates new XPA tokens.\n', '    function createTokens() payable external {\n', '        assert(!isFinalized);\n', '        require(block.number >= fundingStartBlock);\n', '        require(block.number < fundingEndBlock);\n', '        require(msg.value > 0);\n', '\n', '        uint256 tokens = safeMult(msg.value, tokenExchangeRate);    // check that we&#39;re not over totals\n', '        crowdsaleSupply = safeAdd(crowdsaleSupply, tokens);\n', '\n', '        // return money if something goes wrong\n', '        require(tokenCrowdsaleCap >= crowdsaleSupply);\n', '\n', '        balances[msg.sender] += tokens;     // add amount of XPA to sender\n', '        balances[xpaFundDeposit] = safeSub(balances[xpaFundDeposit], tokens); // subtracts amount from XPlay&#39;s balance\n', '        CreateXPA(msg.sender, tokens);      // logs token creation\n', '    }\n', '\n', '    /* Approve and then communicate the approved contract in a single tx */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        returns (bool success) {    \n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '    /// @dev Update crowdsale parameter\n', '    function updateParams(\n', '        uint256 _tokenExchangeRate,\n', '        uint256 _tokenCrowdsaleCap,\n', '        uint256 _fundingStartBlock,\n', '        uint256 _fundingEndBlock) onlyOwner external \n', '    {\n', '        assert(block.number < fundingStartBlock);\n', '        assert(!isFinalized);\n', '      \n', '        // update system parameters\n', '        tokenExchangeRate = _tokenExchangeRate;\n', '        tokenCrowdsaleCap = _tokenCrowdsaleCap;\n', '        fundingStartBlock = _fundingStartBlock;\n', '        fundingEndBlock = _fundingEndBlock;\n', '    }\n', '    /// @dev Ends the funding period and sends the ETH home\n', '    function finalize() onlyOwner external {\n', '        assert(!isFinalized);\n', '      \n', '        // move to operational\n', '        isFinalized = true;\n', '        assert(ethFundDeposit.send(this.balance));              // send the eth to XPlay ltd.\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/* taking ideas from FirstBlood token */\n', 'contract SafeMath {\n', '\n', '    /* function assert(bool assertion) internal { */\n', '    /*   if (!assertion) { */\n', '    /*     throw; */\n', '    /*   } */\n', '    /* }      // assert no longer needed once solidity is on 0.4.10 */\n', '\n', '    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x + y;\n', '      assert((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) internal returns(uint256) {\n', '      assert(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', '\n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n', '\n', 'contract Token is owned {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    \n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is SafeMath, Token {\n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '            balances[_to] = safeAdd(balances[_to], _value);\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /* A contract attempts to get the coins */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] = safeAdd(balances[_to], _value);\n', '            balances[_from] = safeSub(balances[_from], _value);\n', '            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /* Allow another contract to spend some tokens in your behalf */\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        assert((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /* This creates an array with all balances */\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract XPAToken is StandardToken {\n', '\n', '    // metadata\n', '    string public constant name = "XPlay Token";\n', '    string public constant symbol = "XPA";\n', '    uint256 public constant decimals = 18;\n', '    string public version = "1.0";\n', '\n', '    // contracts\n', '    address public ethFundDeposit;      // deposit address of ETH for XPlay Ltd.\n', '    address public xpaFundDeposit;      // deposit address for XPlay Ltd. use and XPA User Fund\n', '\n', '    // crowdsale parameters\n', '    bool public isFinalized;              // switched to true in operational state\n', '    uint256 public fundingStartBlock;\n', '    uint256 public fundingEndBlock;\n', '    uint256 public crowdsaleSupply = 0;         // crowdsale supply\n', '    uint256 public tokenExchangeRate = 23000;   // 23000 XPA tokens per 1 ETH\n', '    uint256 public constant tokenCreationCap =  10 * (10**9) * 10**decimals;\n', '    uint256 public tokenCrowdsaleCap =  4 * (10**8) * 10**decimals;\n', '\n', '    // events\n', '    event CreateXPA(address indexed _to, uint256 _value);\n', '\n', '    // constructor\n', '    function XPAToken(\n', '        address _ethFundDeposit,\n', '        address _xpaFundDeposit,\n', '        uint256 _tokenExchangeRate,\n', '        uint256 _fundingStartBlock,\n', '        uint256 _fundingEndBlock)\n', '    {\n', '        isFinalized = false;                   //controls pre through crowdsale state\n', '        ethFundDeposit = _ethFundDeposit;\n', '        xpaFundDeposit = _xpaFundDeposit;\n', '        tokenExchangeRate = _tokenExchangeRate;\n', '        fundingStartBlock = _fundingStartBlock;\n', '        fundingEndBlock = _fundingEndBlock;\n', '        totalSupply = tokenCreationCap;\n', '        balances[xpaFundDeposit] = tokenCreationCap;    // deposit all XPA to XPlay Ltd.\n', '        CreateXPA(xpaFundDeposit, tokenCreationCap);    // logs deposit of XPlay Ltd. fund\n', '    }\n', '\n', '    function () payable {\n', '        assert(!isFinalized);\n', '        require(block.number >= fundingStartBlock);\n', '        require(block.number < fundingEndBlock);\n', '        require(msg.value > 0);\n', '\n', "        uint256 tokens = safeMult(msg.value, tokenExchangeRate);    // check that we're not over totals\n", '        crowdsaleSupply = safeAdd(crowdsaleSupply, tokens);\n', '\n', '        // return money if something goes wrong\n', '        require(tokenCrowdsaleCap >= crowdsaleSupply);\n', '\n', '        balances[msg.sender] += tokens;     // add amount of XPA to sender\n', "        balances[xpaFundDeposit] = safeSub(balances[xpaFundDeposit], tokens); // subtracts amount from XPlay's balance\n", '        CreateXPA(msg.sender, tokens);      // logs token creation\n', '\n', '    }\n', '    /// @dev Accepts ether and creates new XPA tokens.\n', '    function createTokens() payable external {\n', '        assert(!isFinalized);\n', '        require(block.number >= fundingStartBlock);\n', '        require(block.number < fundingEndBlock);\n', '        require(msg.value > 0);\n', '\n', "        uint256 tokens = safeMult(msg.value, tokenExchangeRate);    // check that we're not over totals\n", '        crowdsaleSupply = safeAdd(crowdsaleSupply, tokens);\n', '\n', '        // return money if something goes wrong\n', '        require(tokenCrowdsaleCap >= crowdsaleSupply);\n', '\n', '        balances[msg.sender] += tokens;     // add amount of XPA to sender\n', "        balances[xpaFundDeposit] = safeSub(balances[xpaFundDeposit], tokens); // subtracts amount from XPlay's balance\n", '        CreateXPA(msg.sender, tokens);      // logs token creation\n', '    }\n', '\n', '    /* Approve and then communicate the approved contract in a single tx */\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n', '        returns (bool success) {    \n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', '    /// @dev Update crowdsale parameter\n', '    function updateParams(\n', '        uint256 _tokenExchangeRate,\n', '        uint256 _tokenCrowdsaleCap,\n', '        uint256 _fundingStartBlock,\n', '        uint256 _fundingEndBlock) onlyOwner external \n', '    {\n', '        assert(block.number < fundingStartBlock);\n', '        assert(!isFinalized);\n', '      \n', '        // update system parameters\n', '        tokenExchangeRate = _tokenExchangeRate;\n', '        tokenCrowdsaleCap = _tokenCrowdsaleCap;\n', '        fundingStartBlock = _fundingStartBlock;\n', '        fundingEndBlock = _fundingEndBlock;\n', '    }\n', '    /// @dev Ends the funding period and sends the ETH home\n', '    function finalize() onlyOwner external {\n', '        assert(!isFinalized);\n', '      \n', '        // move to operational\n', '        isFinalized = true;\n', '        assert(ethFundDeposit.send(this.balance));              // send the eth to XPlay ltd.\n', '    }\n', '}']
