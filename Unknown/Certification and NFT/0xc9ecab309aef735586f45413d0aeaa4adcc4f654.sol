['pragma solidity ^0.4.8;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' * By OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/contracts/SafeMath.sol\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    if(!(a == 0 || c / a == b)) throw;\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    if(!(b <= a)) throw;\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    if(!(c >= a)) throw;\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', 'contract ContractReceiver{\n', '    function tokenFallback(address _from, uint256 _value, bytes  _data) external;\n', '}\n', '\n', '\n', '//Basic ERC23 token, backward compatible with ERC20 transfer function.\n', '//Based in part on code by open-zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git\n', 'contract ERC23BasicToken {\n', '    using SafeMath for uint256;\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) balances;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '\n', '    /*\n', '       * Fix for the ERC20 short address attack  \n', '      */\n', '      modifier onlyPayloadSize(uint size) {\n', '         if(msg.data.length < size + 4) {\n', '           throw;\n', '         }\n', '         _;\n', '      }\n', '\n', '\n', '    function tokenFallback(address _from, uint256 _value, bytes  _data) external {\n', '        _from;\n', '        _value;\n', '        _data;\n', '        throw;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value, bytes _data)  returns (bool success) {\n', '\n', '        //Standard ERC23 transfer function\n', '\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, _data);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {\n', '\n', '        //standard function transfer similar to ERC20 transfer with no _data\n', '        //added due to backwards compatibility reasons\n', '\n', '        bytes memory empty;\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, empty);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, empty);\n', '        }\n', '    }\n', '\n', '    function transferToAddress(address _to, uint256 _value, bytes _data)  internal {\n', '        _data;\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '     }\n', '\n', '    function transferToContract(address _to, uint256 _value, bytes _data)  internal {\n', '        balances[msg.sender] = balances[msg.sender].sub( _value);\n', '        balances[_to] = balances[_to].add( _value);\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        Transfer(msg.sender, _to, _value);    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) returns (bool is_contract) {\n', '            _addr;\n', '          uint256 length;\n', '          assembly {\n', '              //retrieve the size of the code on target address, this needs assembly\n', '              length := extcodesize(_addr)\n', '          }\n', '          if(length>0) {\n', '              return true;\n', '          }\n', '          else {\n', '              return false;\n', '          }\n', '    }\n', '}\n', '\n', 'contract ERC23StandardToken is ERC23BasicToken {\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    event Approval (address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) {\n', '        var _allowance = allowed[_from][msg.sender];\n', '\n', '        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '        // if (_value > _allowance) throw;\n', '\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) {\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '// Based in part on code by Open-Zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git\n', '// Based in part on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', 'contract Profit1000 is ERC23StandardToken {\n', '    string public constant name = "Profit 1000 Token";\n', '    string public constant symbol = "1000";\n', '    uint256 public constant decimals = 18;\n', '    address public multisig=address(0x871D9225C237049c2FB82A32647511128741A616); //multisig wallet, to which all contributions will be sent\n', '    address public foundation; //owner address\n', '    address public candidate; //owner candidate in 2-phase ownership transfer\n', '    uint256 public hour_blocks = 212; // every hour blocks \n', '    uint256 public day_blocks = hour_blocks * 24 ; // every day blocks \n', '\n', '    mapping (address => uint256) contributions; //keeps track of ether contributions in Wei of each contributor address\n', '    uint256 public startBlock = 4070472; //crowdsale start block \n', '    uint256 public endBlock = startBlock + day_blocks * 30; // whole crowdsale end block (30 days , 1 month)\n', '    uint256 public crowdsaleTokenSupply = 800 * (10**18); //Amount of tokens for sale during crowdsale\n', '    uint256 public foundationTokenSupply = 200 * (10**18); //Tokens for  team\n', '    uint256 public crowdsaleTokenSold = 0; //Keeps track of the amount of tokens sold during the crowdsale\n', '    uint256 public presaleEtherRaised = 0; //Keeps track of the Ether raised during the crowdsale\n', '    \n', '    bool public halted = false; //Halt crowdsale in emergency\n', '    event Halt(); //Halt event\n', '    event Unhalt(); //Unhalt event\n', '\n', '    modifier onlyFoundation() {\n', '        //only do if call is from owner modifier\n', '        if (msg.sender != foundation) throw;\n', '        _;\n', '    }\n', '\n', '\n', '    modifier whenNotHalted() {\n', '        // only do when not halted modifier\n', '        if (halted) throw;\n', '        _;\n', '    }\n', '\n', '    //Constructor: set multisig crowdsale recipient wallet address and fund the foundation\n', '    //Initialize total supply and allocate ecosystem & foundation tokens\n', '  \tfunction Profit1000() {\n', '        foundation = msg.sender;\n', '        totalSupply = foundationTokenSupply;\n', '        balances[foundation] = totalSupply;\n', '  \t}\n', '\n', '    //Fallback function when receiving Ether.\n', '    function() payable {\n', '        buy();\n', '    }\n', '\n', '\n', '    //Halt ICO in case of emergency.\n', '    function halt() onlyFoundation {\n', '        halted = true;\n', '        Halt();\n', '    }\n', '\n', '    function unhalt() onlyFoundation {\n', '        halted = false;\n', '        Unhalt();\n', '    }\n', '\n', '    function buy() payable {\n', '        buyRecipient(msg.sender);\n', '    }\n', '\n', '    //Allow addresses to buy token for another account\n', '    function buyRecipient(address recipient) public payable whenNotHalted {\n', '        if(msg.value == 0) throw;\n', '        if(!crowdsaleOn()) throw;//only allows during presale/crowdsale\n', '        if(contributions[recipient].add(msg.value)>perAddressCap()) throw;//per address cap\n', '        uint256 tokens = msg.value.mul(returnRate()); //decimals=18, so no need to adjust for unit\n', '        if(crowdsaleTokenSold.add(tokens)>crowdsaleTokenSupply) throw;//max supply limit\n', '\n', '        balances[recipient] = balances[recipient].add(tokens);\n', '        totalSupply = totalSupply.add(tokens);\n', '        presaleEtherRaised = presaleEtherRaised.add(msg.value);\n', '        contributions[recipient] = contributions[recipient].add(msg.value);\n', '        crowdsaleTokenSold = crowdsaleTokenSold.add(tokens);\n', '        if(crowdsaleTokenSold == crowdsaleTokenSupply ){\n', '            //If crowdsale token sold out, end crowdsale\n', '            endBlock = block.number;\n', '        }\n', '        if (!multisig.send(msg.value)) throw; //immediately send Ether to multisig address\n', '        Transfer(this, recipient, tokens);\n', '    }\n', '\n', '    //Burns the specified amount of tokens from the foundation\n', '    //Used to burn unspent funds in foundation DAO\n', '    function burn(uint256 _value) external onlyFoundation returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Transfer(msg.sender, address(0), _value);\n', '        return true;\n', '    }\n', '\n', '    //2-phase ownership transfer;\n', '    //prevent transferring ownership to non-existent addresses by accident.\n', '    function proposeFoundationTransfer(address newFoundation) external onlyFoundation {\n', '        //propose new owner\n', '        candidate = newFoundation;\n', '    }\n', '\n', '    function cancelFoundationTransfer() external onlyFoundation {\n', '        candidate = address(0);\n', '    }\n', '\n', '    function acceptFoundationTransfer() external {\n', '        //new owner accept transfer to complete transfer\n', '        if(msg.sender != candidate) throw;\n', '        foundation = candidate;\n', '        candidate = address(0);\n', '    }\n', '\n', '    //Allow to change the recipient multisig address\n', '    function setMultisig(address addr) external onlyFoundation {\n', '      \tif (addr == address(0)) throw;\n', '      \tmultisig = addr;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value, bytes _data) public  returns (bool success) {\n', '        return super.transfer(_to, _value, _data);\n', '    }\n', '\n', '\t  function transfer(address _to, uint256 _value) public  {\n', '        super.transfer(_to, _value);\n', '\t  }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public  {\n', '        super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    //Return rate of token against ether.\n', '    function returnRate() public constant returns(uint256) {\n', '        if (block.number>=startBlock && block.number<=endBlock) return 4; // ICO\n', '        return 0;// out of ICO \n', '    }\n', '\n', '    //per address cap in Wei: 1000 ether + 1% of ether received at the given time.\n', '    function perAddressCap() public constant returns(uint256) {\n', '        uint256 baseline = 1000 * (10**18);\n', '        return baseline.add(presaleEtherRaised.div(100));\n', '    }\n', '\n', '    function crowdsaleOn() public constant returns (bool) {\n', '        //return whether crowdsale is on according to block number\n', '        return (block.number>=startBlock && block.number<=endBlock);\n', '    }\n', '\n', '\n', '    function getEtherRaised() external constant returns (uint256) {\n', '        //getter function for etherRaised\n', '        return presaleEtherRaised;\n', '    }\n', '\n', '    function getTokenSold() external constant returns (uint256) {\n', '        //getter function for crowdsaleTokenSold\n', '        return crowdsaleTokenSold;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.8;\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' * By OpenZeppelin: https://github.com/OpenZeppelin/zeppelin-solidity/contracts/SafeMath.sol\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    if(!(a == 0 || c / a == b)) throw;\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    if(!(b <= a)) throw;\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    if(!(c >= a)) throw;\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', 'contract ContractReceiver{\n', '    function tokenFallback(address _from, uint256 _value, bytes  _data) external;\n', '}\n', '\n', '\n', '//Basic ERC23 token, backward compatible with ERC20 transfer function.\n', '//Based in part on code by open-zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git\n', 'contract ERC23BasicToken {\n', '    using SafeMath for uint256;\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) balances;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    \n', '\n', '    /*\n', '       * Fix for the ERC20 short address attack  \n', '      */\n', '      modifier onlyPayloadSize(uint size) {\n', '         if(msg.data.length < size + 4) {\n', '           throw;\n', '         }\n', '         _;\n', '      }\n', '\n', '\n', '    function tokenFallback(address _from, uint256 _value, bytes  _data) external {\n', '        _from;\n', '        _value;\n', '        _data;\n', '        throw;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value, bytes _data)  returns (bool success) {\n', '\n', '        //Standard ERC23 transfer function\n', '\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, _data);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, _data);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {\n', '\n', '        //standard function transfer similar to ERC20 transfer with no _data\n', '        //added due to backwards compatibility reasons\n', '\n', '        bytes memory empty;\n', '        if(isContract(_to)) {\n', '            transferToContract(_to, _value, empty);\n', '        }\n', '        else {\n', '            transferToAddress(_to, _value, empty);\n', '        }\n', '    }\n', '\n', '    function transferToAddress(address _to, uint256 _value, bytes _data)  internal {\n', '        _data;\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '     }\n', '\n', '    function transferToContract(address _to, uint256 _value, bytes _data)  internal {\n', '        balances[msg.sender] = balances[msg.sender].sub( _value);\n', '        balances[_to] = balances[_to].add( _value);\n', '        ContractReceiver receiver = ContractReceiver(_to);\n', '        receiver.tokenFallback(msg.sender, _value, _data);\n', '        Transfer(msg.sender, _to, _value);    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n', '    function isContract(address _addr) returns (bool is_contract) {\n', '            _addr;\n', '          uint256 length;\n', '          assembly {\n', '              //retrieve the size of the code on target address, this needs assembly\n', '              length := extcodesize(_addr)\n', '          }\n', '          if(length>0) {\n', '              return true;\n', '          }\n', '          else {\n', '              return false;\n', '          }\n', '    }\n', '}\n', '\n', 'contract ERC23StandardToken is ERC23BasicToken {\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    event Approval (address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) {\n', '        var _allowance = allowed[_from][msg.sender];\n', '\n', '        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '        // if (_value > _allowance) throw;\n', '\n', '        balances[_to] = balances[_to].add(_value);\n', '        balances[_from] = balances[_from].sub(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) {\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '// Based in part on code by Open-Zeppelin: https://github.com/OpenZeppelin/zeppelin-solidity.git\n', '// Based in part on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', 'contract Profit1000 is ERC23StandardToken {\n', '    string public constant name = "Profit 1000 Token";\n', '    string public constant symbol = "1000";\n', '    uint256 public constant decimals = 18;\n', '    address public multisig=address(0x871D9225C237049c2FB82A32647511128741A616); //multisig wallet, to which all contributions will be sent\n', '    address public foundation; //owner address\n', '    address public candidate; //owner candidate in 2-phase ownership transfer\n', '    uint256 public hour_blocks = 212; // every hour blocks \n', '    uint256 public day_blocks = hour_blocks * 24 ; // every day blocks \n', '\n', '    mapping (address => uint256) contributions; //keeps track of ether contributions in Wei of each contributor address\n', '    uint256 public startBlock = 4070472; //crowdsale start block \n', '    uint256 public endBlock = startBlock + day_blocks * 30; // whole crowdsale end block (30 days , 1 month)\n', '    uint256 public crowdsaleTokenSupply = 800 * (10**18); //Amount of tokens for sale during crowdsale\n', '    uint256 public foundationTokenSupply = 200 * (10**18); //Tokens for  team\n', '    uint256 public crowdsaleTokenSold = 0; //Keeps track of the amount of tokens sold during the crowdsale\n', '    uint256 public presaleEtherRaised = 0; //Keeps track of the Ether raised during the crowdsale\n', '    \n', '    bool public halted = false; //Halt crowdsale in emergency\n', '    event Halt(); //Halt event\n', '    event Unhalt(); //Unhalt event\n', '\n', '    modifier onlyFoundation() {\n', '        //only do if call is from owner modifier\n', '        if (msg.sender != foundation) throw;\n', '        _;\n', '    }\n', '\n', '\n', '    modifier whenNotHalted() {\n', '        // only do when not halted modifier\n', '        if (halted) throw;\n', '        _;\n', '    }\n', '\n', '    //Constructor: set multisig crowdsale recipient wallet address and fund the foundation\n', '    //Initialize total supply and allocate ecosystem & foundation tokens\n', '  \tfunction Profit1000() {\n', '        foundation = msg.sender;\n', '        totalSupply = foundationTokenSupply;\n', '        balances[foundation] = totalSupply;\n', '  \t}\n', '\n', '    //Fallback function when receiving Ether.\n', '    function() payable {\n', '        buy();\n', '    }\n', '\n', '\n', '    //Halt ICO in case of emergency.\n', '    function halt() onlyFoundation {\n', '        halted = true;\n', '        Halt();\n', '    }\n', '\n', '    function unhalt() onlyFoundation {\n', '        halted = false;\n', '        Unhalt();\n', '    }\n', '\n', '    function buy() payable {\n', '        buyRecipient(msg.sender);\n', '    }\n', '\n', '    //Allow addresses to buy token for another account\n', '    function buyRecipient(address recipient) public payable whenNotHalted {\n', '        if(msg.value == 0) throw;\n', '        if(!crowdsaleOn()) throw;//only allows during presale/crowdsale\n', '        if(contributions[recipient].add(msg.value)>perAddressCap()) throw;//per address cap\n', '        uint256 tokens = msg.value.mul(returnRate()); //decimals=18, so no need to adjust for unit\n', '        if(crowdsaleTokenSold.add(tokens)>crowdsaleTokenSupply) throw;//max supply limit\n', '\n', '        balances[recipient] = balances[recipient].add(tokens);\n', '        totalSupply = totalSupply.add(tokens);\n', '        presaleEtherRaised = presaleEtherRaised.add(msg.value);\n', '        contributions[recipient] = contributions[recipient].add(msg.value);\n', '        crowdsaleTokenSold = crowdsaleTokenSold.add(tokens);\n', '        if(crowdsaleTokenSold == crowdsaleTokenSupply ){\n', '            //If crowdsale token sold out, end crowdsale\n', '            endBlock = block.number;\n', '        }\n', '        if (!multisig.send(msg.value)) throw; //immediately send Ether to multisig address\n', '        Transfer(this, recipient, tokens);\n', '    }\n', '\n', '    //Burns the specified amount of tokens from the foundation\n', '    //Used to burn unspent funds in foundation DAO\n', '    function burn(uint256 _value) external onlyFoundation returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Transfer(msg.sender, address(0), _value);\n', '        return true;\n', '    }\n', '\n', '    //2-phase ownership transfer;\n', '    //prevent transferring ownership to non-existent addresses by accident.\n', '    function proposeFoundationTransfer(address newFoundation) external onlyFoundation {\n', '        //propose new owner\n', '        candidate = newFoundation;\n', '    }\n', '\n', '    function cancelFoundationTransfer() external onlyFoundation {\n', '        candidate = address(0);\n', '    }\n', '\n', '    function acceptFoundationTransfer() external {\n', '        //new owner accept transfer to complete transfer\n', '        if(msg.sender != candidate) throw;\n', '        foundation = candidate;\n', '        candidate = address(0);\n', '    }\n', '\n', '    //Allow to change the recipient multisig address\n', '    function setMultisig(address addr) external onlyFoundation {\n', '      \tif (addr == address(0)) throw;\n', '      \tmultisig = addr;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value, bytes _data) public  returns (bool success) {\n', '        return super.transfer(_to, _value, _data);\n', '    }\n', '\n', '\t  function transfer(address _to, uint256 _value) public  {\n', '        super.transfer(_to, _value);\n', '\t  }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public  {\n', '        super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    //Return rate of token against ether.\n', '    function returnRate() public constant returns(uint256) {\n', '        if (block.number>=startBlock && block.number<=endBlock) return 4; // ICO\n', '        return 0;// out of ICO \n', '    }\n', '\n', '    //per address cap in Wei: 1000 ether + 1% of ether received at the given time.\n', '    function perAddressCap() public constant returns(uint256) {\n', '        uint256 baseline = 1000 * (10**18);\n', '        return baseline.add(presaleEtherRaised.div(100));\n', '    }\n', '\n', '    function crowdsaleOn() public constant returns (bool) {\n', '        //return whether crowdsale is on according to block number\n', '        return (block.number>=startBlock && block.number<=endBlock);\n', '    }\n', '\n', '\n', '    function getEtherRaised() external constant returns (uint256) {\n', '        //getter function for etherRaised\n', '        return presaleEtherRaised;\n', '    }\n', '\n', '    function getTokenSold() external constant returns (uint256) {\n', '        //getter function for crowdsaleTokenSold\n', '        return crowdsaleTokenSold;\n', '    }\n', '\n', '}']
