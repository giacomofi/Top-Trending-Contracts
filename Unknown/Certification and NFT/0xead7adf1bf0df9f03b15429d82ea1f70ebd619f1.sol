['pragma solidity ^0.4.13;\n', 'contract token { \n', '   function mintToken(address target, uint256 mintedAmount);\n', '}\n', '\n', 'contract owned { \n', '    address public owner;\n', '    \n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Crowdsale is owned {\n', '    address public beneficiary;\n', '    \n', '    uint256 public preICOLimit;\n', '    uint256 public totalLimit;\n', '    \n', '    uint256 public pricePreICO;\n', '    uint256 public priceICO;\n', '\n', '    bool preICOClosed = false;\n', '    bool ICOClosed = false;\n', '\n', '    bool preICOWithdrawn = false;\n', '    bool ICOWithdrawn = false;\n', '\n', '    bool public preICOActive = false;\n', '    bool public ICOActive = false;\n', '\n', '    uint256 public preICORaised; \n', '    uint256 public ICORaised; \n', '    uint256 public totalRaised; \n', '\n', '    token public tokenReward;\n', '\n', '    event FundTransfer(address backer, uint256 amount, bool isContribution);\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '\n', '    function Crowdsale() {\n', '        preICOLimit = 5000000 * 1 ether;\n', '        totalLimit = 45000000 * 1 ether; //50m hard cap minus 2.5m for mining and minus 2.5m for bounty\n', '        pricePreICO = 375;\n', '        priceICO = 250;\n', '    }\n', '\n', '    function init(address beneficiaryAddress, token tokenAddress)  onlyOwner {\n', '        beneficiary = beneficiaryAddress;\n', '        tokenReward = token(tokenAddress);\n', '    }\n', '\n', '    function () payable {\n', '        require (preICOActive || ICOActive);\n', '        uint256 amount = msg.value;\n', '\n', '        require (amount >= 0.05 * 1 ether); //0.05 - minimum contribution limit\n', '\n', '        //mintToken method will work only for owner of the token.\n', '        //So we need to execute transferOwnership from the token contract and pass ICO contract address as a parameter.\n', '        //By doing so we will lock minting function to ICO contract only (so no minting will be available after ICO).\n', '        if(preICOActive)\n', '        {\n', '    \t    tokenReward.mintToken(msg.sender, amount * pricePreICO);\n', '            preICORaised += amount;\n', '        }\n', '        if(ICOActive)\n', '        {\n', '    \t    tokenReward.mintToken(msg.sender, amount * priceICO);\n', '            ICORaised += amount;\n', '        }\n', '\n', '        balanceOf[msg.sender] += amount;\n', '        totalRaised += amount;\n', '        FundTransfer(msg.sender, amount, true);\n', '\n', '        if(preICORaised >= preICOLimit)\n', '        {\n', '            preICOActive = false;\n', '            preICOClosed = true;\n', '        }\n', '        \n', '        if(totalRaised >= totalLimit)\n', '        {\n', '            preICOActive = false;\n', '            ICOActive = false;\n', '            preICOClosed = true;\n', '            ICOClosed = true;\n', '        }\n', '    }\n', '    \n', '    function startPreICO() onlyOwner {\n', '        require(!preICOClosed);\n', '        require(!preICOActive);\n', '        require(!ICOClosed);\n', '        require(!ICOActive);\n', '        \n', '        preICOActive = true;\n', '    }\n', '    function stopPreICO() onlyOwner {\n', '        require(preICOActive);\n', '        \n', '        preICOActive = false;\n', '        preICOClosed = true;\n', '    }\n', '    function startICO() onlyOwner {\n', '        require(preICOClosed);\n', '        require(!ICOClosed);\n', '        require(!ICOActive);\n', '        \n', '        ICOActive = true;\n', '    }\n', '    function stopICO() onlyOwner {\n', '        require(ICOActive);\n', '        \n', '        ICOActive = false;\n', '        ICOClosed = true;\n', '    }\n', '\n', '\n', '    //withdrawal raised funds to beneficiary\n', '    function withdrawFunds() onlyOwner {\n', '\trequire ((!preICOWithdrawn && preICOClosed) || (!ICOWithdrawn && ICOClosed));\n', '\n', '            //withdraw results of preICO\n', '            if(!preICOWithdrawn && preICOClosed)\n', '            {\n', '                if (beneficiary.send(preICORaised)) {\n', '                    preICOWithdrawn = true;\n', '                    FundTransfer(beneficiary, preICORaised, false);\n', '                }\n', '            }\n', '            //withdraw results of ICO\n', '            if(!ICOWithdrawn && ICOClosed)\n', '            {\n', '                if (beneficiary.send(ICORaised)) {\n', '                    ICOWithdrawn = true;\n', '                    FundTransfer(beneficiary, ICORaised, false);\n', '                }\n', '            }\n', '    }\n', '}']
['pragma solidity ^0.4.13;\n', 'contract token { \n', '   function mintToken(address target, uint256 mintedAmount);\n', '}\n', '\n', 'contract owned { \n', '    address public owner;\n', '    \n', '    function owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Crowdsale is owned {\n', '    address public beneficiary;\n', '    \n', '    uint256 public preICOLimit;\n', '    uint256 public totalLimit;\n', '    \n', '    uint256 public pricePreICO;\n', '    uint256 public priceICO;\n', '\n', '    bool preICOClosed = false;\n', '    bool ICOClosed = false;\n', '\n', '    bool preICOWithdrawn = false;\n', '    bool ICOWithdrawn = false;\n', '\n', '    bool public preICOActive = false;\n', '    bool public ICOActive = false;\n', '\n', '    uint256 public preICORaised; \n', '    uint256 public ICORaised; \n', '    uint256 public totalRaised; \n', '\n', '    token public tokenReward;\n', '\n', '    event FundTransfer(address backer, uint256 amount, bool isContribution);\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '\n', '    function Crowdsale() {\n', '        preICOLimit = 5000000 * 1 ether;\n', '        totalLimit = 45000000 * 1 ether; //50m hard cap minus 2.5m for mining and minus 2.5m for bounty\n', '        pricePreICO = 375;\n', '        priceICO = 250;\n', '    }\n', '\n', '    function init(address beneficiaryAddress, token tokenAddress)  onlyOwner {\n', '        beneficiary = beneficiaryAddress;\n', '        tokenReward = token(tokenAddress);\n', '    }\n', '\n', '    function () payable {\n', '        require (preICOActive || ICOActive);\n', '        uint256 amount = msg.value;\n', '\n', '        require (amount >= 0.05 * 1 ether); //0.05 - minimum contribution limit\n', '\n', '        //mintToken method will work only for owner of the token.\n', '        //So we need to execute transferOwnership from the token contract and pass ICO contract address as a parameter.\n', '        //By doing so we will lock minting function to ICO contract only (so no minting will be available after ICO).\n', '        if(preICOActive)\n', '        {\n', '    \t    tokenReward.mintToken(msg.sender, amount * pricePreICO);\n', '            preICORaised += amount;\n', '        }\n', '        if(ICOActive)\n', '        {\n', '    \t    tokenReward.mintToken(msg.sender, amount * priceICO);\n', '            ICORaised += amount;\n', '        }\n', '\n', '        balanceOf[msg.sender] += amount;\n', '        totalRaised += amount;\n', '        FundTransfer(msg.sender, amount, true);\n', '\n', '        if(preICORaised >= preICOLimit)\n', '        {\n', '            preICOActive = false;\n', '            preICOClosed = true;\n', '        }\n', '        \n', '        if(totalRaised >= totalLimit)\n', '        {\n', '            preICOActive = false;\n', '            ICOActive = false;\n', '            preICOClosed = true;\n', '            ICOClosed = true;\n', '        }\n', '    }\n', '    \n', '    function startPreICO() onlyOwner {\n', '        require(!preICOClosed);\n', '        require(!preICOActive);\n', '        require(!ICOClosed);\n', '        require(!ICOActive);\n', '        \n', '        preICOActive = true;\n', '    }\n', '    function stopPreICO() onlyOwner {\n', '        require(preICOActive);\n', '        \n', '        preICOActive = false;\n', '        preICOClosed = true;\n', '    }\n', '    function startICO() onlyOwner {\n', '        require(preICOClosed);\n', '        require(!ICOClosed);\n', '        require(!ICOActive);\n', '        \n', '        ICOActive = true;\n', '    }\n', '    function stopICO() onlyOwner {\n', '        require(ICOActive);\n', '        \n', '        ICOActive = false;\n', '        ICOClosed = true;\n', '    }\n', '\n', '\n', '    //withdrawal raised funds to beneficiary\n', '    function withdrawFunds() onlyOwner {\n', '\trequire ((!preICOWithdrawn && preICOClosed) || (!ICOWithdrawn && ICOClosed));\n', '\n', '            //withdraw results of preICO\n', '            if(!preICOWithdrawn && preICOClosed)\n', '            {\n', '                if (beneficiary.send(preICORaised)) {\n', '                    preICOWithdrawn = true;\n', '                    FundTransfer(beneficiary, preICORaised, false);\n', '                }\n', '            }\n', '            //withdraw results of ICO\n', '            if(!ICOWithdrawn && ICOClosed)\n', '            {\n', '                if (beneficiary.send(ICORaised)) {\n', '                    ICOWithdrawn = true;\n', '                    FundTransfer(beneficiary, ICORaised, false);\n', '                }\n', '            }\n', '    }\n', '}']
