['pragma solidity ^0.4.11;\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', '    // this function isn&#39;t abstract since the compiler emits automatically generated getter functions as external\n', '    function owner() public constant returns (address owner) { owner; }\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', '/*\n', '    Utilities & Common Modifiers\n', '*/\n', 'contract Utils {\n', '    /**\n', '        constructor\n', '    */\n', '    function Utils() {\n', '    }\n', '\n', '    // verifies that an amount is greater than zero\n', '    modifier greaterThanZero(uint256 _amount) {\n', '        require(_amount > 0);\n', '        _;\n', '    }\n', '\n', '    // validates an address - currently only checks that it isn&#39;t null\n', '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    // Overflow protected math functions\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    Bancor Formula interface\n', '*/\n', 'contract IBancorFormula {\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _depositAmount) public constant returns (uint256);\n', '    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _sellAmount) public constant returns (uint256);\n', '}\n', '\n', '/**\n', '    @dev the BancorFormulaProxy is an owned contract that serves as a single point of access\n', '    to the BancorFormula contract from all BancorChanger contract instances.\n', '    it allows upgrading the BancorFormula contract without the need to update each and every\n', '    BancorChanger contract instance individually.\n', '*/\n', 'contract BancorFormulaProxy is IBancorFormula, Owned, Utils {\n', '    IBancorFormula public formula;  // bancor calculation formula contract\n', '\n', '    /**\n', '        @dev constructor\n', '\n', '        @param _formula address of a bancor formula contract\n', '    */\n', '    function BancorFormulaProxy(IBancorFormula _formula)\n', '        validAddress(_formula)\n', '    {\n', '        formula = _formula;\n', '    }\n', '\n', '    /*\n', '        @dev allows the owner to update the formula contract address\n', '\n', '        @param _formula    address of a bancor formula contract\n', '    */\n', '    function setFormula(IBancorFormula _formula)\n', '        public\n', '        ownerOnly\n', '        validAddress(_formula)\n', '        notThis(_formula)\n', '    {\n', '        formula = _formula;\n', '    }\n', '\n', '    /**\n', '        @dev proxy for the bancor formula purchase return calculation\n', '\n', '        @param _supply             token total supply\n', '        @param _reserveBalance     total reserve\n', '        @param _reserveRatio       constant reserve ratio, 1-1000000\n', '        @param _depositAmount      deposit amount, in reserve token\n', '\n', '        @return purchase return amount\n', '    */\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _depositAmount) public constant returns (uint256) {\n', '        return formula.calculatePurchaseReturn(_supply, _reserveBalance, _reserveRatio, _depositAmount);\n', '     }\n', '\n', '    /**\n', '        @dev proxy for the bancor formula sale return calculation\n', '\n', '        @param _supply             token total supply\n', '        @param _reserveBalance     total reserve\n', '        @param _reserveRatio       constant reserve ratio, 1-1000000\n', '        @param _sellAmount         sell amount, in the token itself\n', '\n', '        @return sale return amount\n', '    */\n', '    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _sellAmount) public constant returns (uint256) {\n', '        return formula.calculateSaleReturn(_supply, _reserveBalance, _reserveRatio, _sellAmount);\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'contract IOwned {\n', "    // this function isn't abstract since the compiler emits automatically generated getter functions as external\n", '    function owner() public constant returns (address owner) { owner; }\n', '\n', '    function transferOwnership(address _newOwner) public;\n', '    function acceptOwnership() public;\n', '}\n', '\n', '/*\n', '    Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    /**\n', '        @dev constructor\n', '    */\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '        @dev allows transferring the contract ownership\n', '        the new owner still needs to accept the transfer\n', '        can only be called by the contract owner\n', '\n', '        @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public ownerOnly {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '        @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', '/*\n', '    Utilities & Common Modifiers\n', '*/\n', 'contract Utils {\n', '    /**\n', '        constructor\n', '    */\n', '    function Utils() {\n', '    }\n', '\n', '    // verifies that an amount is greater than zero\n', '    modifier greaterThanZero(uint256 _amount) {\n', '        require(_amount > 0);\n', '        _;\n', '    }\n', '\n', "    // validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        require(_address != 0x0);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        require(_address != address(this));\n', '        _;\n', '    }\n', '\n', '    // Overflow protected math functions\n', '\n', '    /**\n', '        @dev returns the sum of _x and _y, asserts if the calculation overflows\n', '\n', '        @param _x   value 1\n', '        @param _y   value 2\n', '\n', '        @return sum\n', '    */\n', '    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        assert(z >= _x);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\n', '\n', '        @param _x   minuend\n', '        @param _y   subtrahend\n', '\n', '        @return difference\n', '    */\n', '    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        assert(_x >= _y);\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\n', '\n', '        @param _x   factor 1\n', '        @param _y   factor 2\n', '\n', '        @return product\n', '    */\n', '    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\n', '        uint256 z = _x * _y;\n', '        assert(_x == 0 || z / _x == _y);\n', '        return z;\n', '    }\n', '}\n', '\n', '/*\n', '    Bancor Formula interface\n', '*/\n', 'contract IBancorFormula {\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _depositAmount) public constant returns (uint256);\n', '    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _sellAmount) public constant returns (uint256);\n', '}\n', '\n', '/**\n', '    @dev the BancorFormulaProxy is an owned contract that serves as a single point of access\n', '    to the BancorFormula contract from all BancorChanger contract instances.\n', '    it allows upgrading the BancorFormula contract without the need to update each and every\n', '    BancorChanger contract instance individually.\n', '*/\n', 'contract BancorFormulaProxy is IBancorFormula, Owned, Utils {\n', '    IBancorFormula public formula;  // bancor calculation formula contract\n', '\n', '    /**\n', '        @dev constructor\n', '\n', '        @param _formula address of a bancor formula contract\n', '    */\n', '    function BancorFormulaProxy(IBancorFormula _formula)\n', '        validAddress(_formula)\n', '    {\n', '        formula = _formula;\n', '    }\n', '\n', '    /*\n', '        @dev allows the owner to update the formula contract address\n', '\n', '        @param _formula    address of a bancor formula contract\n', '    */\n', '    function setFormula(IBancorFormula _formula)\n', '        public\n', '        ownerOnly\n', '        validAddress(_formula)\n', '        notThis(_formula)\n', '    {\n', '        formula = _formula;\n', '    }\n', '\n', '    /**\n', '        @dev proxy for the bancor formula purchase return calculation\n', '\n', '        @param _supply             token total supply\n', '        @param _reserveBalance     total reserve\n', '        @param _reserveRatio       constant reserve ratio, 1-1000000\n', '        @param _depositAmount      deposit amount, in reserve token\n', '\n', '        @return purchase return amount\n', '    */\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _depositAmount) public constant returns (uint256) {\n', '        return formula.calculatePurchaseReturn(_supply, _reserveBalance, _reserveRatio, _depositAmount);\n', '     }\n', '\n', '    /**\n', '        @dev proxy for the bancor formula sale return calculation\n', '\n', '        @param _supply             token total supply\n', '        @param _reserveBalance     total reserve\n', '        @param _reserveRatio       constant reserve ratio, 1-1000000\n', '        @param _sellAmount         sell amount, in the token itself\n', '\n', '        @return sale return amount\n', '    */\n', '    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint32 _reserveRatio, uint256 _sellAmount) public constant returns (uint256) {\n', '        return formula.calculateSaleReturn(_supply, _reserveBalance, _reserveRatio, _sellAmount);\n', '    }\n', '}']
