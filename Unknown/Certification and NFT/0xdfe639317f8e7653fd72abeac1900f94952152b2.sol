['pragma solidity ^0.4.11;\n', '\n', 'contract DGDb_Auction{\n', '    \n', '    Badge public badge_obj;\n', '    \n', '    address public beneficiary;\n', '    uint public expiry_date;\n', '    \n', '    address public highest_bidder;\n', '    uint public highest_bid;\n', '    mapping(address => uint) pending_returns;\n', '    \n', '    \n', '    function DGDb_Auction(address beneficiary_address, address badge_address, uint duration_in_days){\n', '        beneficiary = beneficiary_address;\n', '        badge_obj = Badge(badge_address);\n', '        expiry_date = now + duration_in_days * 1 days;\n', '    }\n', '    \n', '    // This function is called every time someone sends ether to this contract\n', '    function() payable {\n', '        require(now < (expiry_date));\n', '        require(msg.value > highest_bid);\n', '        \n', '        uint num_badges = badge_obj.balanceOf(this);\n', '        require(num_badges > 0);\n', '        \n', '        if (highest_bidder != 0) {\n', '            pending_returns[highest_bidder] += highest_bid;\n', '        }\n', '        \n', '        highest_bidder = msg.sender;\n', '        highest_bid = msg.value;\n', '    }\n', '    \n', '    // Bidders that have been outbid can call this to retrieve their ETH\n', '    function withdraw_ether() returns (bool) {\n', '        uint amount = pending_returns[msg.sender];\n', '        if (amount > 0) {\n', '            pending_returns[msg.sender] = 0;\n', '            if (!msg.sender.send(amount)) {\n', '                pending_returns[msg.sender] = amount;\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    // For winner (or creator if no bids) to retrieve badge\n', '    function withdraw_badge() {\n', '        require(now >= (expiry_date));\n', '        \n', '        uint num_badges = badge_obj.balanceOf(this);\n', '        \n', '        if (highest_bid > 0){\n', '            badge_obj.transfer(highest_bidder, num_badges);\n', '        } else {\n', '            badge_obj.transfer(beneficiary, num_badges);\n', '        }\n', '    }\n', '    \n', '    // For auction creator to retrieve ETH 1 day after auction ends\n', '    function end_auction() {\n', '        require(msg.sender == beneficiary);\n', '        require(now > (expiry_date + 1 days));\n', '        selfdestruct(beneficiary);\n', '    }\n', '}\n', '\n', 'contract Badge{\n', 'function Badge();\n', 'function approve(address _spender,uint256 _value)returns(bool success);\n', 'function setOwner(address _owner)returns(bool success);\n', 'function totalSupply()constant returns(uint256 );\n', 'function transferFrom(address _from,address _to,uint256 _value)returns(bool success);\n', 'function subtractSafely(uint256 a,uint256 b)returns(uint256 );\n', 'function mint(address _owner,uint256 _amount)returns(bool success);\n', 'function safeToAdd(uint256 a,uint256 b)returns(bool );\n', 'function balanceOf(address _owner)constant returns(uint256 balance);\n', 'function owner()constant returns(address );\n', 'function transfer(address _to,uint256 _value)returns(bool success);\n', 'function addSafely(uint256 a,uint256 b)returns(uint256 result);\n', 'function locked()constant returns(bool );\n', 'function allowance(address _owner,address _spender)constant returns(uint256 remaining);\n', 'function safeToSubtract(uint256 a,uint256 b)returns(bool );\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'contract DGDb_Auction{\n', '    \n', '    Badge public badge_obj;\n', '    \n', '    address public beneficiary;\n', '    uint public expiry_date;\n', '    \n', '    address public highest_bidder;\n', '    uint public highest_bid;\n', '    mapping(address => uint) pending_returns;\n', '    \n', '    \n', '    function DGDb_Auction(address beneficiary_address, address badge_address, uint duration_in_days){\n', '        beneficiary = beneficiary_address;\n', '        badge_obj = Badge(badge_address);\n', '        expiry_date = now + duration_in_days * 1 days;\n', '    }\n', '    \n', '    // This function is called every time someone sends ether to this contract\n', '    function() payable {\n', '        require(now < (expiry_date));\n', '        require(msg.value > highest_bid);\n', '        \n', '        uint num_badges = badge_obj.balanceOf(this);\n', '        require(num_badges > 0);\n', '        \n', '        if (highest_bidder != 0) {\n', '            pending_returns[highest_bidder] += highest_bid;\n', '        }\n', '        \n', '        highest_bidder = msg.sender;\n', '        highest_bid = msg.value;\n', '    }\n', '    \n', '    // Bidders that have been outbid can call this to retrieve their ETH\n', '    function withdraw_ether() returns (bool) {\n', '        uint amount = pending_returns[msg.sender];\n', '        if (amount > 0) {\n', '            pending_returns[msg.sender] = 0;\n', '            if (!msg.sender.send(amount)) {\n', '                pending_returns[msg.sender] = amount;\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    // For winner (or creator if no bids) to retrieve badge\n', '    function withdraw_badge() {\n', '        require(now >= (expiry_date));\n', '        \n', '        uint num_badges = badge_obj.balanceOf(this);\n', '        \n', '        if (highest_bid > 0){\n', '            badge_obj.transfer(highest_bidder, num_badges);\n', '        } else {\n', '            badge_obj.transfer(beneficiary, num_badges);\n', '        }\n', '    }\n', '    \n', '    // For auction creator to retrieve ETH 1 day after auction ends\n', '    function end_auction() {\n', '        require(msg.sender == beneficiary);\n', '        require(now > (expiry_date + 1 days));\n', '        selfdestruct(beneficiary);\n', '    }\n', '}\n', '\n', 'contract Badge{\n', 'function Badge();\n', 'function approve(address _spender,uint256 _value)returns(bool success);\n', 'function setOwner(address _owner)returns(bool success);\n', 'function totalSupply()constant returns(uint256 );\n', 'function transferFrom(address _from,address _to,uint256 _value)returns(bool success);\n', 'function subtractSafely(uint256 a,uint256 b)returns(uint256 );\n', 'function mint(address _owner,uint256 _amount)returns(bool success);\n', 'function safeToAdd(uint256 a,uint256 b)returns(bool );\n', 'function balanceOf(address _owner)constant returns(uint256 balance);\n', 'function owner()constant returns(address );\n', 'function transfer(address _to,uint256 _value)returns(bool success);\n', 'function addSafely(uint256 a,uint256 b)returns(uint256 result);\n', 'function locked()constant returns(bool );\n', 'function allowance(address _owner,address _spender)constant returns(uint256 remaining);\n', 'function safeToSubtract(uint256 a,uint256 b)returns(bool );\n', '}']
