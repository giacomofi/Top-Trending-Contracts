['pragma solidity ^0.4.11;\n', '\n', '/*\n', '  Copyright 2017, Anton Egorov (Mothership Foundation)\n', '  Copyright 2017, Klaus Hott (BlockchainLabs.nz)\n', '  Copyright 2017, Jorge Izquierdo (Aragon Foundation)\n', '  Copyright 2017, Jordi Baylina (Giveth)\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '  it under the terms of the GNU General Public License as published by\n', '  the Free Software Foundation, either version 3 of the License, or\n', '  (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '  but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '  GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '  Based on SampleCampaign-TokenController.sol from https://github.com/Giveth/minime\n', '  Original contract is https://github.com/status-im/status-network-token/blob/master/contracts/StatusContribution.sol\n', '*/\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', 'contract Controlled {\n', '  /// @notice The address of the controller is the only address that can call\n', '  ///  a function with this modifier\n', '  modifier onlyController { if (msg.sender != controller) throw; _; }\n', '\n', '  address public controller;\n', '\n', '  function Controlled() { controller = msg.sender;}\n', '\n', '  /// @notice Changes the controller of the contract\n', '  /// @param _newController The new controller of the contract\n', '  function changeController(address _newController) onlyController {\n', '    controller = _newController;\n', '  }\n', '}\n', '\n', 'contract Refundable {\n', '  function refund(address th, uint amount) returns (bool);\n', '}\n', '\n', '/// @dev The token controller contract must implement these functions\n', 'contract TokenController {\n', '  /// @notice Called when `_owner` sends ether to the MiniMe Token contract\n', '  /// @param _owner The address that sent the ether to create tokens\n', '  /// @return True if the ether is accepted, false if it throws\n', '  function proxyPayment(address _owner) payable returns(bool);\n', '\n', '  /// @notice Notifies the controller about a token transfer allowing the\n', '  ///  controller to react if desired\n', '  /// @param _from The origin of the transfer\n', '  /// @param _to The destination of the transfer\n', '  /// @param _amount The amount of the transfer\n', '  /// @return False if the controller does not authorize the transfer\n', '  function onTransfer(address _from, address _to, uint _amount) returns(bool);\n', '\n', '  /// @notice Notifies the controller about an approval allowing the\n', '  ///  controller to react if desired\n', '  /// @param _owner The address that calls `approve()`\n', '  /// @param _spender The spender in the `approve()` call\n', '  /// @param _amount The amount in the `approve()` call\n', '  /// @return False if the controller does not authorize the approval\n', '  function onApprove(address _owner, address _spender, uint _amount)\n', '    returns(bool);\n', '}\n', '\n', 'contract ERC20Token {\n', '  /* This is a slight change to the ERC20 base standard.\n', '     function totalSupply() constant returns (uint256 supply);\n', '     is replaced with:\n', '     uint256 public totalSupply;\n', '     This automatically creates a getter function for the totalSupply.\n', '     This is moved to the base contract since public getter functions are not\n', '     currently recognised as an implementation of the matching abstract\n', '     function by the compiler.\n', '  */\n', '  /// total amount of tokens\n', '  function totalSupply() constant returns (uint256 balance);\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of tokens to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Burnable is Controlled {\n', '  /// @notice The address of the controller is the only address that can call\n', '  ///  a function with this modifier, also the burner can call but also the\n', '  /// target of the function must be the burner\n', '  modifier onlyControllerOrBurner(address target) {\n', '    assert(msg.sender == controller || (msg.sender == burner && msg.sender == target));\n', '    _;\n', '  }\n', '\n', '  modifier onlyBurner {\n', '    assert(msg.sender == burner);\n', '    _;\n', '  }\n', '  address public burner;\n', '\n', '  function Burnable() { burner = msg.sender;}\n', '\n', '  /// @notice Changes the burner of the contract\n', '  /// @param _newBurner The new burner of the contract\n', '  function changeBurner(address _newBurner) onlyBurner {\n', '    burner = _newBurner;\n', '  }\n', '}\n', '\n', 'contract MiniMeTokenI is ERC20Token, Burnable {\n', '\n', '      string public name;                //The Token&#39;s name: e.g. DigixDAO Tokens\n', '      uint8 public decimals;             //Number of decimals of the smallest unit\n', '      string public symbol;              //An identifier: e.g. REP\n', '      string public version = &#39;MMT_0.1&#39;; //An arbitrary versioning scheme\n', '\n', '///////////////////\n', '// ERC20 Methods\n', '///////////////////\n', '\n', '\n', '    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n', '    ///  its behalf, and then a function is triggered in the contract that is\n', '    ///  being approved, `_spender`. This allows users to use their tokens to\n', '    ///  interact with contracts in one function call instead of two\n', '    /// @param _spender The address of the contract able to transfer the tokens\n', '    /// @param _amount The amount of tokens to be approved for transfer\n', '    /// @return True if the function call was successful\n', '    function approveAndCall(\n', '        address _spender,\n', '        uint256 _amount,\n', '        bytes _extraData\n', '    ) returns (bool success);\n', '\n', '////////////////\n', '// Query balance and totalSupply in History\n', '////////////////\n', '\n', '    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @param _blockNumber The block number when the balance is queried\n', '    /// @return The balance at `_blockNumber`\n', '    function balanceOfAt(\n', '        address _owner,\n', '        uint _blockNumber\n', '    ) constant returns (uint);\n', '\n', '    /// @notice Total amount of tokens at a specific `_blockNumber`.\n', '    /// @param _blockNumber The block number when the totalSupply is queried\n', '    /// @return The total amount of tokens at `_blockNumber`\n', '    function totalSupplyAt(uint _blockNumber) constant returns(uint);\n', '\n', '////////////////\n', '// Clone Token Method\n', '////////////////\n', '\n', '    /// @notice Creates a new clone token with the initial distribution being\n', '    ///  this token at `_snapshotBlock`\n', '    /// @param _cloneTokenName Name of the clone token\n', '    /// @param _cloneDecimalUnits Number of decimals of the smallest unit\n', '    /// @param _cloneTokenSymbol Symbol of the clone token\n', '    /// @param _snapshotBlock Block when the distribution of the parent token is\n', '    ///  copied to set the initial distribution of the new clone token;\n', '    ///  if the block is zero than the actual block, the current block is used\n', '    /// @param _transfersEnabled True if transfers are allowed in the clone\n', '    /// @return The address of the new MiniMeToken Contract\n', '    function createCloneToken(\n', '        string _cloneTokenName,\n', '        uint8 _cloneDecimalUnits,\n', '        string _cloneTokenSymbol,\n', '        uint _snapshotBlock,\n', '        bool _transfersEnabled\n', '    ) returns(address);\n', '\n', '////////////////\n', '// Generate and destroy tokens\n', '////////////////\n', '\n', '    /// @notice Generates `_amount` tokens that are assigned to `_owner`\n', '    /// @param _owner The address that will be assigned the new tokens\n', '    /// @param _amount The quantity of tokens generated\n', '    /// @return True if the tokens are generated correctly\n', '    function generateTokens(address _owner, uint _amount) returns (bool);\n', '\n', '\n', '    /// @notice Burns `_amount` tokens from `_owner`\n', '    /// @param _owner The address that will lose the tokens\n', '    /// @param _amount The quantity of tokens to burn\n', '    /// @return True if the tokens are burned correctly\n', '    function destroyTokens(address _owner, uint _amount) returns (bool);\n', '\n', '////////////////\n', '// Enable tokens transfers\n', '////////////////\n', '\n', '    /// @notice Enables token holders to transfer their tokens freely if true\n', '    /// @param _transfersEnabled True if transfers are allowed in the clone\n', '    function enableTransfers(bool _transfersEnabled);\n', '\n', '//////////\n', '// Safety Methods\n', '//////////\n', '\n', '    /// @notice This method can be used by the controller to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    function claimTokens(address _token);\n', '\n', '////////////////\n', '// Events\n', '////////////////\n', '\n', '    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n', '    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n', '}\n', '\n', 'contract Finalizable {\n', '  uint256 public finalizedBlock;\n', '  bool public goalMet;\n', '\n', '  function finalize();\n', '}\n', '\n', 'contract Contribution is Controlled, TokenController, Finalizable {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 public totalSupplyCap; // Total MSP supply to be generated\n', '  uint256 public exchangeRate; // ETH-MSP exchange rate\n', '  uint256 public totalSold; // How much tokens sold\n', '  uint256 public totalSaleSupplyCap; // Token sale cap\n', '\n', '  MiniMeTokenI public sit;\n', '  MiniMeTokenI public msp;\n', '\n', '  uint256 public startBlock;\n', '  uint256 public endBlock;\n', '\n', '  address public destEthDevs;\n', '  address public destTokensSit;\n', '  address public destTokensTeam;\n', '  address public destTokensReferals;\n', '\n', '  address public mspController;\n', '\n', '  uint256 public initializedBlock;\n', '  uint256 public finalizedTime;\n', '\n', '  uint256 public minimum_investment;\n', '  uint256 public minimum_goal;\n', '\n', '  bool public paused;\n', '\n', '  modifier initialized() {\n', '    assert(address(msp) != 0x0);\n', '    _;\n', '  }\n', '\n', '  modifier contributionOpen() {\n', '    assert(getBlockNumber() >= startBlock &&\n', '            getBlockNumber() <= endBlock &&\n', '            finalizedBlock == 0 &&\n', '            address(msp) != 0x0);\n', '    _;\n', '  }\n', '\n', '  modifier notPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  function Contribution() {\n', '    // Booleans are false by default consider removing this\n', '    paused = false;\n', '  }\n', '\n', '  /// @notice This method should be called by the controller before the contribution\n', '  ///  period starts This initializes most of the parameters\n', '  /// @param _msp Address of the MSP token contract\n', '  /// @param _mspController Token controller for the MSP that will be transferred after\n', '  ///  the contribution finalizes.\n', '  /// @param _totalSupplyCap Maximum amount of tokens to generate during the contribution\n', '  /// @param _exchangeRate ETH to MSP rate for the token sale\n', '  /// @param _startBlock Block when the contribution period starts\n', '  /// @param _endBlock The last block that the contribution period is active\n', '  /// @param _destEthDevs Destination address where the contribution ether is sent\n', '  /// @param _destTokensSit Address of the exchanger SIT-MSP where the MSP are sent\n', '  ///  to be distributed to the SIT holders.\n', '  /// @param _destTokensTeam Address where the tokens for the team are sent\n', '  /// @param _destTokensReferals Address where the tokens for the referal system are sent\n', '  /// @param _sit Address of the SIT token contract\n', '  function initialize(\n', '      address _msp,\n', '      address _mspController,\n', '\n', '      uint256 _totalSupplyCap,\n', '      uint256 _exchangeRate,\n', '      uint256 _minimum_goal,\n', '\n', '      uint256 _startBlock,\n', '      uint256 _endBlock,\n', '\n', '      address _destEthDevs,\n', '      address _destTokensSit,\n', '      address _destTokensTeam,\n', '      address _destTokensReferals,\n', '\n', '      address _sit\n', '  ) public onlyController {\n', '    // Initialize only once\n', '    assert(address(msp) == 0x0);\n', '\n', '    msp = MiniMeTokenI(_msp);\n', '    assert(msp.totalSupply() == 0);\n', '    assert(msp.controller() == address(this));\n', '    assert(msp.decimals() == 18);  // Same amount of decimals as ETH\n', '\n', '    require(_mspController != 0x0);\n', '    mspController = _mspController;\n', '\n', '    require(_exchangeRate > 0);\n', '    exchangeRate = _exchangeRate;\n', '\n', '    assert(_startBlock >= getBlockNumber());\n', '    require(_startBlock < _endBlock);\n', '    startBlock = _startBlock;\n', '    endBlock = _endBlock;\n', '\n', '    require(_destEthDevs != 0x0);\n', '    destEthDevs = _destEthDevs;\n', '\n', '    require(_destTokensSit != 0x0);\n', '    destTokensSit = _destTokensSit;\n', '\n', '    require(_destTokensTeam != 0x0);\n', '    destTokensTeam = _destTokensTeam;\n', '\n', '    require(_destTokensReferals != 0x0);\n', '    destTokensReferals = _destTokensReferals;\n', '\n', '    require(_sit != 0x0);\n', '    sit = MiniMeTokenI(_sit);\n', '\n', '    initializedBlock = getBlockNumber();\n', '    // SIT amount should be no more than 20% of MSP total supply cap\n', '    assert(sit.totalSupplyAt(initializedBlock) * 5 <= _totalSupplyCap);\n', '    totalSupplyCap = _totalSupplyCap;\n', '\n', '    // We are going to sale 70% of total supply cap\n', '    totalSaleSupplyCap = percent(70).mul(_totalSupplyCap).div(percent(100));\n', '\n', '    minimum_goal = _minimum_goal;\n', '  }\n', '\n', '  function setMinimumInvestment(\n', '      uint _minimum_investment\n', '  ) public onlyController {\n', '    minimum_investment = _minimum_investment;\n', '  }\n', '\n', '  function setExchangeRate(\n', '      uint _exchangeRate\n', '  ) public onlyController {\n', '    assert(getBlockNumber() < startBlock);\n', '    exchangeRate = _exchangeRate;\n', '  }\n', '\n', '  /// @notice If anybody sends Ether directly to this contract, consider he is\n', '  ///  getting MSPs.\n', '  function () public payable notPaused {\n', '    proxyPayment(msg.sender);\n', '  }\n', '\n', '\n', '  //////////\n', '  // TokenController functions\n', '  //////////\n', '\n', '  /// @notice This method will generally be called by the MSP token contract to\n', '  ///  acquire MSPs. Or directly from third parties that want to acquire MSPs in\n', '  ///  behalf of a token holder.\n', '  /// @param _th MSP holder where the MSPs will be minted.\n', '  function proxyPayment(address _th) public payable notPaused initialized contributionOpen returns (bool) {\n', '    require(_th != 0x0);\n', '    doBuy(_th);\n', '    return true;\n', '  }\n', '\n', '  function onTransfer(address, address, uint256) public returns (bool) {\n', '    return false;\n', '  }\n', '\n', '  function onApprove(address, address, uint256) public returns (bool) {\n', '    return false;\n', '  }\n', '\n', '  function doBuy(address _th) internal {\n', '    require(msg.value >= minimum_investment);\n', '\n', '    // Antispam mechanism\n', '    address caller;\n', '    if (msg.sender == address(msp)) {\n', '      caller = _th;\n', '    } else {\n', '      caller = msg.sender;\n', '    }\n', '\n', '    // Do not allow contracts to game the system\n', '    assert(!isContract(caller));\n', '\n', '    uint256 toFund = msg.value;\n', '    uint256 leftForSale = tokensForSale();\n', '    if (toFund > 0) {\n', '      if (leftForSale > 0) {\n', '        uint256 tokensGenerated = toFund.mul(exchangeRate);\n', '\n', '        // Check total supply cap reached, sell the all remaining tokens\n', '        if (tokensGenerated > leftForSale) {\n', '          tokensGenerated = leftForSale;\n', '          toFund = leftForSale.div(exchangeRate);\n', '        }\n', '\n', '        assert(msp.generateTokens(_th, tokensGenerated));\n', '        totalSold = totalSold.add(tokensGenerated);\n', '        if (totalSold >= minimum_goal) {\n', '          goalMet = true;\n', '        }\n', '        destEthDevs.transfer(toFund);\n', '        NewSale(_th, toFund, tokensGenerated);\n', '      } else {\n', '        toFund = 0;\n', '      }\n', '    }\n', '\n', '    uint256 toReturn = msg.value.sub(toFund);\n', '    if (toReturn > 0) {\n', '      // If the call comes from the Token controller,\n', '      // then we return it to the token Holder.\n', '      // Otherwise we return to the sender.\n', '      if (msg.sender == address(msp)) {\n', '        _th.transfer(toReturn);\n', '      } else {\n', '        msg.sender.transfer(toReturn);\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Internal function to determine if an address is a contract\n', '  /// @param _addr The address being queried\n', '  /// @return True if `_addr` is a contract\n', '  function isContract(address _addr) constant internal returns (bool) {\n', '    if (_addr == 0) return false;\n', '    uint256 size;\n', '    assembly {\n', '      size := extcodesize(_addr)\n', '    }\n', '    return (size > 0);\n', '  }\n', '\n', '  function refund() public {\n', '    require(finalizedBlock != 0);\n', '    require(!goalMet);\n', '\n', '    uint256 amountTokens = msp.balanceOf(msg.sender);\n', '    require(amountTokens > 0);\n', '    uint256 amountEther = amountTokens.div(exchangeRate);\n', '    address th = msg.sender;\n', '\n', '    Refundable(mspController).refund(th, amountTokens);\n', '    Refundable(destEthDevs).refund(th, amountEther);\n', '\n', '    Refund(th, amountTokens, amountEther);\n', '  }\n', '\n', '  event Refund(address _token_holder, uint256 _amount_tokens, uint256 _amount_ether);\n', '\n', '  /// @notice This method will can be called by the controller before the contribution period\n', '  ///  end or by anybody after the `endBlock`. This method finalizes the contribution period\n', '  ///  by creating the remaining tokens and transferring the controller to the configured\n', '  ///  controller.\n', '  function finalize() public initialized {\n', '    assert(getBlockNumber() >= startBlock);\n', '    assert(msg.sender == controller || getBlockNumber() > endBlock || tokensForSale() == 0);\n', '    require(finalizedBlock == 0);\n', '\n', '    finalizedBlock = getBlockNumber();\n', '    finalizedTime = now;\n', '\n', '    if (goalMet) {\n', '      // Generate 5% for the team\n', '      assert(msp.generateTokens(\n', '        destTokensTeam,\n', '        percent(5).mul(totalSupplyCap).div(percent(100))));\n', '\n', '      // Generate 5% for the referal bonuses\n', '      assert(msp.generateTokens(\n', '        destTokensReferals,\n', '        percent(5).mul(totalSupplyCap).div(percent(100))));\n', '\n', '      // Generate tokens for SIT exchanger\n', '      assert(msp.generateTokens(\n', '        destTokensSit,\n', '        sit.totalSupplyAt(initializedBlock)));\n', '    }\n', '\n', '    msp.changeController(mspController);\n', '    Finalized();\n', '  }\n', '\n', '  function percent(uint256 p) internal returns (uint256) {\n', '    return p.mul(10**16);\n', '  }\n', '\n', '\n', '  //////////\n', '  // Constant functions\n', '  //////////\n', '\n', '  /// @return Total tokens issued in weis.\n', '  function tokensIssued() public constant returns (uint256) {\n', '    return msp.totalSupply();\n', '  }\n', '\n', '  /// @return Total tokens availale for the sale in weis.\n', '  function tokensForSale() public constant returns(uint256) {\n', '    return totalSaleSupplyCap > totalSold ? totalSaleSupplyCap - totalSold : 0;\n', '  }\n', '\n', '\n', '  //////////\n', '  // Testing specific methods\n', '  //////////\n', '\n', '  /// @notice This function is overridden by the test Mocks.\n', '  function getBlockNumber() internal constant returns (uint256) {\n', '    return block.number;\n', '  }\n', '\n', '\n', '  //////////\n', '  // Safety Methods\n', '  //////////\n', '\n', '  /// @notice This method can be used by the controller to extract mistakenly\n', '  ///  sent tokens to this contract.\n', '  /// @param _token The address of the token contract that you want to recover\n', '  ///  set to 0 in case you want to extract ether.\n', '  function claimTokens(address _token) public onlyController {\n', '    if (msp.controller() == address(this)) {\n', '      msp.claimTokens(_token);\n', '    }\n', '    if (_token == 0x0) {\n', '      controller.transfer(this.balance);\n', '      return;\n', '    }\n', '\n', '    ERC20Token token = ERC20Token(_token);\n', '    uint256 balance = token.balanceOf(this);\n', '    token.transfer(controller, balance);\n', '    ClaimedTokens(_token, controller, balance);\n', '  }\n', '\n', '\n', '  /// @notice Pauses the contribution if there is any issue\n', '  function pauseContribution() onlyController {\n', '    paused = true;\n', '  }\n', '\n', '  /// @notice Resumes the contribution\n', '  function resumeContribution() onlyController {\n', '    paused = false;\n', '  }\n', '\n', '  event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\n', '  event NewSale(address indexed _th, uint256 _amount, uint256 _tokens);\n', '  event Finalized();\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/*\n', '  Copyright 2017, Anton Egorov (Mothership Foundation)\n', '  Copyright 2017, Klaus Hott (BlockchainLabs.nz)\n', '  Copyright 2017, Jorge Izquierdo (Aragon Foundation)\n', '  Copyright 2017, Jordi Baylina (Giveth)\n', '\n', '  This program is free software: you can redistribute it and/or modify\n', '  it under the terms of the GNU General Public License as published by\n', '  the Free Software Foundation, either version 3 of the License, or\n', '  (at your option) any later version.\n', '\n', '  This program is distributed in the hope that it will be useful,\n', '  but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '  GNU General Public License for more details.\n', '\n', '  You should have received a copy of the GNU General Public License\n', '  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '  Based on SampleCampaign-TokenController.sol from https://github.com/Giveth/minime\n', '  Original contract is https://github.com/status-im/status-network-token/blob/master/contracts/StatusContribution.sol\n', '*/\n', '\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', 'contract Controlled {\n', '  /// @notice The address of the controller is the only address that can call\n', '  ///  a function with this modifier\n', '  modifier onlyController { if (msg.sender != controller) throw; _; }\n', '\n', '  address public controller;\n', '\n', '  function Controlled() { controller = msg.sender;}\n', '\n', '  /// @notice Changes the controller of the contract\n', '  /// @param _newController The new controller of the contract\n', '  function changeController(address _newController) onlyController {\n', '    controller = _newController;\n', '  }\n', '}\n', '\n', 'contract Refundable {\n', '  function refund(address th, uint amount) returns (bool);\n', '}\n', '\n', '/// @dev The token controller contract must implement these functions\n', 'contract TokenController {\n', '  /// @notice Called when `_owner` sends ether to the MiniMe Token contract\n', '  /// @param _owner The address that sent the ether to create tokens\n', '  /// @return True if the ether is accepted, false if it throws\n', '  function proxyPayment(address _owner) payable returns(bool);\n', '\n', '  /// @notice Notifies the controller about a token transfer allowing the\n', '  ///  controller to react if desired\n', '  /// @param _from The origin of the transfer\n', '  /// @param _to The destination of the transfer\n', '  /// @param _amount The amount of the transfer\n', '  /// @return False if the controller does not authorize the transfer\n', '  function onTransfer(address _from, address _to, uint _amount) returns(bool);\n', '\n', '  /// @notice Notifies the controller about an approval allowing the\n', '  ///  controller to react if desired\n', '  /// @param _owner The address that calls `approve()`\n', '  /// @param _spender The spender in the `approve()` call\n', '  /// @param _amount The amount in the `approve()` call\n', '  /// @return False if the controller does not authorize the approval\n', '  function onApprove(address _owner, address _spender, uint _amount)\n', '    returns(bool);\n', '}\n', '\n', 'contract ERC20Token {\n', '  /* This is a slight change to the ERC20 base standard.\n', '     function totalSupply() constant returns (uint256 supply);\n', '     is replaced with:\n', '     uint256 public totalSupply;\n', '     This automatically creates a getter function for the totalSupply.\n', '     This is moved to the base contract since public getter functions are not\n', '     currently recognised as an implementation of the matching abstract\n', '     function by the compiler.\n', '  */\n', '  /// total amount of tokens\n', '  function totalSupply() constant returns (uint256 balance);\n', '\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @return The balance\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '  /// @notice send `_value` token to `_to` from `msg.sender`\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value The amount of token to be transferred\n', '  /// @return Whether the transfer was successful or not\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @param _value The amount of tokens to be approved for transfer\n', '  /// @return Whether the approval was successful or not\n', '  function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '  /// @param _owner The address of the account owning tokens\n', '  /// @param _spender The address of the account able to transfer the tokens\n', '  /// @return Amount of remaining tokens allowed to spent\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract Burnable is Controlled {\n', '  /// @notice The address of the controller is the only address that can call\n', '  ///  a function with this modifier, also the burner can call but also the\n', '  /// target of the function must be the burner\n', '  modifier onlyControllerOrBurner(address target) {\n', '    assert(msg.sender == controller || (msg.sender == burner && msg.sender == target));\n', '    _;\n', '  }\n', '\n', '  modifier onlyBurner {\n', '    assert(msg.sender == burner);\n', '    _;\n', '  }\n', '  address public burner;\n', '\n', '  function Burnable() { burner = msg.sender;}\n', '\n', '  /// @notice Changes the burner of the contract\n', '  /// @param _newBurner The new burner of the contract\n', '  function changeBurner(address _newBurner) onlyBurner {\n', '    burner = _newBurner;\n', '  }\n', '}\n', '\n', 'contract MiniMeTokenI is ERC20Token, Burnable {\n', '\n', "      string public name;                //The Token's name: e.g. DigixDAO Tokens\n", '      uint8 public decimals;             //Number of decimals of the smallest unit\n', '      string public symbol;              //An identifier: e.g. REP\n', "      string public version = 'MMT_0.1'; //An arbitrary versioning scheme\n", '\n', '///////////////////\n', '// ERC20 Methods\n', '///////////////////\n', '\n', '\n', '    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n', '    ///  its behalf, and then a function is triggered in the contract that is\n', '    ///  being approved, `_spender`. This allows users to use their tokens to\n', '    ///  interact with contracts in one function call instead of two\n', '    /// @param _spender The address of the contract able to transfer the tokens\n', '    /// @param _amount The amount of tokens to be approved for transfer\n', '    /// @return True if the function call was successful\n', '    function approveAndCall(\n', '        address _spender,\n', '        uint256 _amount,\n', '        bytes _extraData\n', '    ) returns (bool success);\n', '\n', '////////////////\n', '// Query balance and totalSupply in History\n', '////////////////\n', '\n', '    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @param _blockNumber The block number when the balance is queried\n', '    /// @return The balance at `_blockNumber`\n', '    function balanceOfAt(\n', '        address _owner,\n', '        uint _blockNumber\n', '    ) constant returns (uint);\n', '\n', '    /// @notice Total amount of tokens at a specific `_blockNumber`.\n', '    /// @param _blockNumber The block number when the totalSupply is queried\n', '    /// @return The total amount of tokens at `_blockNumber`\n', '    function totalSupplyAt(uint _blockNumber) constant returns(uint);\n', '\n', '////////////////\n', '// Clone Token Method\n', '////////////////\n', '\n', '    /// @notice Creates a new clone token with the initial distribution being\n', '    ///  this token at `_snapshotBlock`\n', '    /// @param _cloneTokenName Name of the clone token\n', '    /// @param _cloneDecimalUnits Number of decimals of the smallest unit\n', '    /// @param _cloneTokenSymbol Symbol of the clone token\n', '    /// @param _snapshotBlock Block when the distribution of the parent token is\n', '    ///  copied to set the initial distribution of the new clone token;\n', '    ///  if the block is zero than the actual block, the current block is used\n', '    /// @param _transfersEnabled True if transfers are allowed in the clone\n', '    /// @return The address of the new MiniMeToken Contract\n', '    function createCloneToken(\n', '        string _cloneTokenName,\n', '        uint8 _cloneDecimalUnits,\n', '        string _cloneTokenSymbol,\n', '        uint _snapshotBlock,\n', '        bool _transfersEnabled\n', '    ) returns(address);\n', '\n', '////////////////\n', '// Generate and destroy tokens\n', '////////////////\n', '\n', '    /// @notice Generates `_amount` tokens that are assigned to `_owner`\n', '    /// @param _owner The address that will be assigned the new tokens\n', '    /// @param _amount The quantity of tokens generated\n', '    /// @return True if the tokens are generated correctly\n', '    function generateTokens(address _owner, uint _amount) returns (bool);\n', '\n', '\n', '    /// @notice Burns `_amount` tokens from `_owner`\n', '    /// @param _owner The address that will lose the tokens\n', '    /// @param _amount The quantity of tokens to burn\n', '    /// @return True if the tokens are burned correctly\n', '    function destroyTokens(address _owner, uint _amount) returns (bool);\n', '\n', '////////////////\n', '// Enable tokens transfers\n', '////////////////\n', '\n', '    /// @notice Enables token holders to transfer their tokens freely if true\n', '    /// @param _transfersEnabled True if transfers are allowed in the clone\n', '    function enableTransfers(bool _transfersEnabled);\n', '\n', '//////////\n', '// Safety Methods\n', '//////////\n', '\n', '    /// @notice This method can be used by the controller to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    function claimTokens(address _token);\n', '\n', '////////////////\n', '// Events\n', '////////////////\n', '\n', '    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n', '    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n', '}\n', '\n', 'contract Finalizable {\n', '  uint256 public finalizedBlock;\n', '  bool public goalMet;\n', '\n', '  function finalize();\n', '}\n', '\n', 'contract Contribution is Controlled, TokenController, Finalizable {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 public totalSupplyCap; // Total MSP supply to be generated\n', '  uint256 public exchangeRate; // ETH-MSP exchange rate\n', '  uint256 public totalSold; // How much tokens sold\n', '  uint256 public totalSaleSupplyCap; // Token sale cap\n', '\n', '  MiniMeTokenI public sit;\n', '  MiniMeTokenI public msp;\n', '\n', '  uint256 public startBlock;\n', '  uint256 public endBlock;\n', '\n', '  address public destEthDevs;\n', '  address public destTokensSit;\n', '  address public destTokensTeam;\n', '  address public destTokensReferals;\n', '\n', '  address public mspController;\n', '\n', '  uint256 public initializedBlock;\n', '  uint256 public finalizedTime;\n', '\n', '  uint256 public minimum_investment;\n', '  uint256 public minimum_goal;\n', '\n', '  bool public paused;\n', '\n', '  modifier initialized() {\n', '    assert(address(msp) != 0x0);\n', '    _;\n', '  }\n', '\n', '  modifier contributionOpen() {\n', '    assert(getBlockNumber() >= startBlock &&\n', '            getBlockNumber() <= endBlock &&\n', '            finalizedBlock == 0 &&\n', '            address(msp) != 0x0);\n', '    _;\n', '  }\n', '\n', '  modifier notPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  function Contribution() {\n', '    // Booleans are false by default consider removing this\n', '    paused = false;\n', '  }\n', '\n', '  /// @notice This method should be called by the controller before the contribution\n', '  ///  period starts This initializes most of the parameters\n', '  /// @param _msp Address of the MSP token contract\n', '  /// @param _mspController Token controller for the MSP that will be transferred after\n', '  ///  the contribution finalizes.\n', '  /// @param _totalSupplyCap Maximum amount of tokens to generate during the contribution\n', '  /// @param _exchangeRate ETH to MSP rate for the token sale\n', '  /// @param _startBlock Block when the contribution period starts\n', '  /// @param _endBlock The last block that the contribution period is active\n', '  /// @param _destEthDevs Destination address where the contribution ether is sent\n', '  /// @param _destTokensSit Address of the exchanger SIT-MSP where the MSP are sent\n', '  ///  to be distributed to the SIT holders.\n', '  /// @param _destTokensTeam Address where the tokens for the team are sent\n', '  /// @param _destTokensReferals Address where the tokens for the referal system are sent\n', '  /// @param _sit Address of the SIT token contract\n', '  function initialize(\n', '      address _msp,\n', '      address _mspController,\n', '\n', '      uint256 _totalSupplyCap,\n', '      uint256 _exchangeRate,\n', '      uint256 _minimum_goal,\n', '\n', '      uint256 _startBlock,\n', '      uint256 _endBlock,\n', '\n', '      address _destEthDevs,\n', '      address _destTokensSit,\n', '      address _destTokensTeam,\n', '      address _destTokensReferals,\n', '\n', '      address _sit\n', '  ) public onlyController {\n', '    // Initialize only once\n', '    assert(address(msp) == 0x0);\n', '\n', '    msp = MiniMeTokenI(_msp);\n', '    assert(msp.totalSupply() == 0);\n', '    assert(msp.controller() == address(this));\n', '    assert(msp.decimals() == 18);  // Same amount of decimals as ETH\n', '\n', '    require(_mspController != 0x0);\n', '    mspController = _mspController;\n', '\n', '    require(_exchangeRate > 0);\n', '    exchangeRate = _exchangeRate;\n', '\n', '    assert(_startBlock >= getBlockNumber());\n', '    require(_startBlock < _endBlock);\n', '    startBlock = _startBlock;\n', '    endBlock = _endBlock;\n', '\n', '    require(_destEthDevs != 0x0);\n', '    destEthDevs = _destEthDevs;\n', '\n', '    require(_destTokensSit != 0x0);\n', '    destTokensSit = _destTokensSit;\n', '\n', '    require(_destTokensTeam != 0x0);\n', '    destTokensTeam = _destTokensTeam;\n', '\n', '    require(_destTokensReferals != 0x0);\n', '    destTokensReferals = _destTokensReferals;\n', '\n', '    require(_sit != 0x0);\n', '    sit = MiniMeTokenI(_sit);\n', '\n', '    initializedBlock = getBlockNumber();\n', '    // SIT amount should be no more than 20% of MSP total supply cap\n', '    assert(sit.totalSupplyAt(initializedBlock) * 5 <= _totalSupplyCap);\n', '    totalSupplyCap = _totalSupplyCap;\n', '\n', '    // We are going to sale 70% of total supply cap\n', '    totalSaleSupplyCap = percent(70).mul(_totalSupplyCap).div(percent(100));\n', '\n', '    minimum_goal = _minimum_goal;\n', '  }\n', '\n', '  function setMinimumInvestment(\n', '      uint _minimum_investment\n', '  ) public onlyController {\n', '    minimum_investment = _minimum_investment;\n', '  }\n', '\n', '  function setExchangeRate(\n', '      uint _exchangeRate\n', '  ) public onlyController {\n', '    assert(getBlockNumber() < startBlock);\n', '    exchangeRate = _exchangeRate;\n', '  }\n', '\n', '  /// @notice If anybody sends Ether directly to this contract, consider he is\n', '  ///  getting MSPs.\n', '  function () public payable notPaused {\n', '    proxyPayment(msg.sender);\n', '  }\n', '\n', '\n', '  //////////\n', '  // TokenController functions\n', '  //////////\n', '\n', '  /// @notice This method will generally be called by the MSP token contract to\n', '  ///  acquire MSPs. Or directly from third parties that want to acquire MSPs in\n', '  ///  behalf of a token holder.\n', '  /// @param _th MSP holder where the MSPs will be minted.\n', '  function proxyPayment(address _th) public payable notPaused initialized contributionOpen returns (bool) {\n', '    require(_th != 0x0);\n', '    doBuy(_th);\n', '    return true;\n', '  }\n', '\n', '  function onTransfer(address, address, uint256) public returns (bool) {\n', '    return false;\n', '  }\n', '\n', '  function onApprove(address, address, uint256) public returns (bool) {\n', '    return false;\n', '  }\n', '\n', '  function doBuy(address _th) internal {\n', '    require(msg.value >= minimum_investment);\n', '\n', '    // Antispam mechanism\n', '    address caller;\n', '    if (msg.sender == address(msp)) {\n', '      caller = _th;\n', '    } else {\n', '      caller = msg.sender;\n', '    }\n', '\n', '    // Do not allow contracts to game the system\n', '    assert(!isContract(caller));\n', '\n', '    uint256 toFund = msg.value;\n', '    uint256 leftForSale = tokensForSale();\n', '    if (toFund > 0) {\n', '      if (leftForSale > 0) {\n', '        uint256 tokensGenerated = toFund.mul(exchangeRate);\n', '\n', '        // Check total supply cap reached, sell the all remaining tokens\n', '        if (tokensGenerated > leftForSale) {\n', '          tokensGenerated = leftForSale;\n', '          toFund = leftForSale.div(exchangeRate);\n', '        }\n', '\n', '        assert(msp.generateTokens(_th, tokensGenerated));\n', '        totalSold = totalSold.add(tokensGenerated);\n', '        if (totalSold >= minimum_goal) {\n', '          goalMet = true;\n', '        }\n', '        destEthDevs.transfer(toFund);\n', '        NewSale(_th, toFund, tokensGenerated);\n', '      } else {\n', '        toFund = 0;\n', '      }\n', '    }\n', '\n', '    uint256 toReturn = msg.value.sub(toFund);\n', '    if (toReturn > 0) {\n', '      // If the call comes from the Token controller,\n', '      // then we return it to the token Holder.\n', '      // Otherwise we return to the sender.\n', '      if (msg.sender == address(msp)) {\n', '        _th.transfer(toReturn);\n', '      } else {\n', '        msg.sender.transfer(toReturn);\n', '      }\n', '    }\n', '  }\n', '\n', '  /// @dev Internal function to determine if an address is a contract\n', '  /// @param _addr The address being queried\n', '  /// @return True if `_addr` is a contract\n', '  function isContract(address _addr) constant internal returns (bool) {\n', '    if (_addr == 0) return false;\n', '    uint256 size;\n', '    assembly {\n', '      size := extcodesize(_addr)\n', '    }\n', '    return (size > 0);\n', '  }\n', '\n', '  function refund() public {\n', '    require(finalizedBlock != 0);\n', '    require(!goalMet);\n', '\n', '    uint256 amountTokens = msp.balanceOf(msg.sender);\n', '    require(amountTokens > 0);\n', '    uint256 amountEther = amountTokens.div(exchangeRate);\n', '    address th = msg.sender;\n', '\n', '    Refundable(mspController).refund(th, amountTokens);\n', '    Refundable(destEthDevs).refund(th, amountEther);\n', '\n', '    Refund(th, amountTokens, amountEther);\n', '  }\n', '\n', '  event Refund(address _token_holder, uint256 _amount_tokens, uint256 _amount_ether);\n', '\n', '  /// @notice This method will can be called by the controller before the contribution period\n', '  ///  end or by anybody after the `endBlock`. This method finalizes the contribution period\n', '  ///  by creating the remaining tokens and transferring the controller to the configured\n', '  ///  controller.\n', '  function finalize() public initialized {\n', '    assert(getBlockNumber() >= startBlock);\n', '    assert(msg.sender == controller || getBlockNumber() > endBlock || tokensForSale() == 0);\n', '    require(finalizedBlock == 0);\n', '\n', '    finalizedBlock = getBlockNumber();\n', '    finalizedTime = now;\n', '\n', '    if (goalMet) {\n', '      // Generate 5% for the team\n', '      assert(msp.generateTokens(\n', '        destTokensTeam,\n', '        percent(5).mul(totalSupplyCap).div(percent(100))));\n', '\n', '      // Generate 5% for the referal bonuses\n', '      assert(msp.generateTokens(\n', '        destTokensReferals,\n', '        percent(5).mul(totalSupplyCap).div(percent(100))));\n', '\n', '      // Generate tokens for SIT exchanger\n', '      assert(msp.generateTokens(\n', '        destTokensSit,\n', '        sit.totalSupplyAt(initializedBlock)));\n', '    }\n', '\n', '    msp.changeController(mspController);\n', '    Finalized();\n', '  }\n', '\n', '  function percent(uint256 p) internal returns (uint256) {\n', '    return p.mul(10**16);\n', '  }\n', '\n', '\n', '  //////////\n', '  // Constant functions\n', '  //////////\n', '\n', '  /// @return Total tokens issued in weis.\n', '  function tokensIssued() public constant returns (uint256) {\n', '    return msp.totalSupply();\n', '  }\n', '\n', '  /// @return Total tokens availale for the sale in weis.\n', '  function tokensForSale() public constant returns(uint256) {\n', '    return totalSaleSupplyCap > totalSold ? totalSaleSupplyCap - totalSold : 0;\n', '  }\n', '\n', '\n', '  //////////\n', '  // Testing specific methods\n', '  //////////\n', '\n', '  /// @notice This function is overridden by the test Mocks.\n', '  function getBlockNumber() internal constant returns (uint256) {\n', '    return block.number;\n', '  }\n', '\n', '\n', '  //////////\n', '  // Safety Methods\n', '  //////////\n', '\n', '  /// @notice This method can be used by the controller to extract mistakenly\n', '  ///  sent tokens to this contract.\n', '  /// @param _token The address of the token contract that you want to recover\n', '  ///  set to 0 in case you want to extract ether.\n', '  function claimTokens(address _token) public onlyController {\n', '    if (msp.controller() == address(this)) {\n', '      msp.claimTokens(_token);\n', '    }\n', '    if (_token == 0x0) {\n', '      controller.transfer(this.balance);\n', '      return;\n', '    }\n', '\n', '    ERC20Token token = ERC20Token(_token);\n', '    uint256 balance = token.balanceOf(this);\n', '    token.transfer(controller, balance);\n', '    ClaimedTokens(_token, controller, balance);\n', '  }\n', '\n', '\n', '  /// @notice Pauses the contribution if there is any issue\n', '  function pauseContribution() onlyController {\n', '    paused = true;\n', '  }\n', '\n', '  /// @notice Resumes the contribution\n', '  function resumeContribution() onlyController {\n', '    paused = false;\n', '  }\n', '\n', '  event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\n', '  event NewSale(address indexed _th, uint256 _amount, uint256 _tokens);\n', '  event Finalized();\n', '}']
