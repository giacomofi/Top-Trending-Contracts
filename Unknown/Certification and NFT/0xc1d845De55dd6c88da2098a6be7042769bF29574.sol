['pragma solidity ^ 0.4 .13;\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns(uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns(uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '\n', '    function assert(bool assertion) internal {\n', '        if (!assertion) {\n', '            revert();\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        if (newOwner != address(0)) owner = newOwner;\n', '    }\n', '\n', '    function kill() {\n', '        if (msg.sender == owner) selfdestruct(owner);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender != owner) revert();\n', '            _;\n', '    }\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '    bool public stopped;\n', '\n', '    modifier stopInEmergency {\n', '        if (stopped) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyInEmergency {\n', '        if (!stopped) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    // Called by the owner in emergency, triggers stopped state\n', '    function emergencyStop() external onlyOwner {\n', '        stopped = true;\n', '    }\n', '\n', '    // Called by the owner to end of emergency, returns to normal state\n', '    function release() external onlyOwner onlyInEmergency {\n', '        stopped = false;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '// Presale Smart Contract\n', '// This smart contract collects ETH during presale. Tokens are not distributed during\n', '// this time. Only informatoion stored how much tokens should be allocated in the future.\n', 'contract Presale is SafeMath, Pausable {\n', '\n', '    struct Backer {\n', '        uint weiReceived;   // amount of ETH contributed\n', '        uint SOCXSent;      // amount of tokens to be sent\n', '        bool processed;     // true if tokens transffered.\n', '    }\n', '    \n', '    address public multisigETH; // Multisig contract that will receive the ETH    \n', '    uint public ETHReceived;    // Number of ETH received\n', '    uint public SOCXSentToETH;  // Number of SOCX sent to ETH contributors\n', '    uint public startBlock;     // Presale start block\n', '    uint public endBlock;       // Presale end block\n', '\n', '    uint public minContributeETH;// Minimum amount to contribute\n', '    bool public presaleClosed;  // Is presale still on going\n', '    uint public maxCap;         // Maximum number of SOCX to sell\n', '\n', '    uint totalTokensSold;       // tokens sold during the campaign\n', '    uint tokenPriceWei;         // price of tokens in Wei\n', '\n', '\n', '    uint multiplier = 10000000000;              // to provide 10 decimal values\n', '    mapping(address => Backer) public backers;  // backer list accessible through address\n', '    address[] public backersIndex;              // order list of backer to be able to itarate through when distributing the tokens. \n', '\n', '\n', '    // @notice to be used when certain account is required to access the function\n', '    // @param a {address}  The address of the authorised individual\n', '    modifier onlyBy(address a) {\n', '        if (msg.sender != a) revert();\n', '        _;\n', '    }\n', '\n', '    // @notice to verify if action is not performed out of the campaing time range\n', '    modifier respectTimeFrame() {\n', '        if ((block.number < startBlock) || (block.number > endBlock)) revert();\n', '        _;\n', '    }\n', '\n', '\n', '\n', '    // Events\n', '    event ReceivedETH(address backer, uint amount, uint tokenAmount);\n', '\n', '\n', '\n', '    // Presale  {constructor}\n', '    // @notice fired when contract is crated. Initilizes all constnat variables.\n', '    function Presale() {     \n', '           \n', '        multisigETH = 0x7bf08cb1732e1246c65b51b83ac092f9b4ebb8c6; //TODO: Replace address with correct one\n', '        maxCap = 2000000 * multiplier;  // max amount of tokens to be sold\n', '        SOCXSentToETH = 0;              // tokens sold so far\n', '        minContributeETH = 1 ether;     // minimum contribution acceptable\n', '        startBlock = 0;                 // start block of the campaign, it will be set in start() function\n', '        endBlock = 0;                   // end block of the campaign, it will be set in start() function \n', '        tokenPriceWei = 720000000000000;// price of token expressed in Wei \n', '    }\n', '\n', '    // @notice to obtain number of contributors so later "front end" can loop through backersIndex and \n', '    // triggger transfer of tokens\n', '    // @return  {uint} true if transaction was successful\n', '    function numberOfBackers() constant returns(uint) {\n', '        return backersIndex.length;\n', '    }\n', '\n', '    function updateMultiSig(address _multisigETH) onlyBy(owner) {\n', '        multisigETH = _multisigETH;\n', '    }\n', '\n', '\n', '    // {fallback function}\n', '    // @notice It will call internal function which handels allocation of Ether and calculates SOCX tokens.\n', '    function () payable {\n', '        if (block.number > endBlock) revert();\n', '        handleETH(msg.sender);\n', '    }\n', '\n', '    // @notice It will be called by owner to start the sale\n', '    // TODO WARNING REMOVE _block parameter and _block variable in function\n', '    function start() onlyBy(owner) {\n', '        startBlock = block.number;        \n', '        endBlock = startBlock + 57600;\n', '        // 10 days in blocks = 57600 (4*60*24*10)\n', '        // enable this for live assuming each bloc takes 15 sec.\n', '    }\n', '\n', '    // @notice called to mark contributer when tokens are transfered to them after ICO\n', '    // @param _backer {address} address of beneficiary\n', '    function process(address _backer) onlyBy(owner) returns (bool){\n', '\n', '        Backer storage backer = backers[_backer]; \n', '        backer.processed = true;\n', '\n', '        return true;\n', '    }\n', '\n', '    // @notice It will be called by fallback function whenever ether is sent to it\n', '    // @param  _backer {address} address of beneficiary\n', '    // @return res {bool} true if transaction was successful\n', '    function handleETH(address _backer) internal stopInEmergency respectTimeFrame returns(bool res) {\n', '\n', '        if (msg.value < minContributeETH) revert();                     // stop when required minimum is not sent\n', '        uint SOCXToSend = (msg.value / tokenPriceWei) * multiplier; // calculate number of tokens\n', '\n', '        \n', "        if (safeAdd(SOCXSentToETH, SOCXToSend) > maxCap) revert();  // ensure that max cap hasn't been reached yet\n", '\n', '        Backer storage backer = backers[_backer];                   // access backer record\n', '        backer.SOCXSent = safeAdd(backer.SOCXSent, SOCXToSend);     // calculate number of tokens sent by backer\n', '        backer.weiReceived = safeAdd(backer.weiReceived, msg.value);// store amount of Ether received in Wei\n', '        ETHReceived = safeAdd(ETHReceived, msg.value);              // update the total Ether recived\n', '        SOCXSentToETH = safeAdd(SOCXSentToETH, SOCXToSend);         // keep total number of tokens sold\n', '        backersIndex.push(_backer);                                 // maintain iterable storage of contributors\n', '\n', '        ReceivedETH(_backer, msg.value, SOCXToSend);                // register event\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    // @notice This function will finalize the sale.\n', '    // It will only execute if predetermined sale time passed \n', '    // if successfull it will transfer collected Ether into predetermined multisig wallet or address\n', '    function finalize() onlyBy(owner) {\n', '\n', '        if (block.number < endBlock && SOCXSentToETH < maxCap) revert();\n', '\n', '        if (!multisigETH.send(this.balance)) revert();\n', '        presaleClosed = true;\n', '\n', '    }\n', '\n', '    \n', '    // @notice Failsafe drain\n', '    // in case finalize failes, we need guaranteed way to transfer Ether out of this contract. \n', '    function drain() onlyBy(owner) {\n', '        if (!owner.send(this.balance)) revert();\n', '    }\n', '\n', '}']