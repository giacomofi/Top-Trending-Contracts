['pragma solidity ^0.4.6;\n', '\n', '/**\n', '* @title RLPReader\n', '*\n', '* RLPReader is used to read and parse RLP encoded data in memory.\n', '*\n', '* @author Andreas Olofsson (androlo1980@gmail.com)\n', '*/\n', 'library RLP {\n', '\n', ' uint constant DATA_SHORT_START = 0x80;\n', ' uint constant DATA_LONG_START = 0xB8;\n', ' uint constant LIST_SHORT_START = 0xC0;\n', ' uint constant LIST_LONG_START = 0xF8;\n', '\n', ' uint constant DATA_LONG_OFFSET = 0xB7;\n', ' uint constant LIST_LONG_OFFSET = 0xF7;\n', '\n', '\n', ' struct RLPItem {\n', '     uint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes.\n', '     uint _unsafe_length;    // Number of bytes. This is the full length of the string.\n', ' }\n', '\n', ' struct Iterator {\n', "     RLPItem _unsafe_item;   // Item that's being iterated over.\n", '     uint _unsafe_nextPtr;   // Position of the next item in the list.\n', ' }\n', '\n', ' /* Iterator */\n', '\n', ' function next(Iterator memory self) internal constant returns (RLPItem memory subItem) {\n', '     if(hasNext(self)) {\n', '         var ptr = self._unsafe_nextPtr;\n', '         var itemLength = _itemLength(ptr);\n', '         subItem._unsafe_memPtr = ptr;\n', '         subItem._unsafe_length = itemLength;\n', '         self._unsafe_nextPtr = ptr + itemLength;\n', '     }\n', '     else\n', '         throw;\n', ' }\n', '\n', ' function next(Iterator memory self, bool strict) internal constant returns (RLPItem memory subItem) {\n', '     subItem = next(self);\n', '     if(strict && !_validate(subItem))\n', '         throw;\n', '     return;\n', ' }\n', '\n', ' function hasNext(Iterator memory self) internal constant returns (bool) {\n', '     var item = self._unsafe_item;\n', '     return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;\n', ' }\n', '\n', ' /* RLPItem */\n', '\n', ' /// @dev Creates an RLPItem from an array of RLP encoded bytes.\n', ' /// @param self The RLP encoded bytes.\n', ' /// @return An RLPItem\n', ' function toRLPItem(bytes memory self) internal constant returns (RLPItem memory) {\n', '     uint len = self.length;\n', '     if (len == 0) {\n', '         return RLPItem(0, 0);\n', '     }\n', '     uint memPtr;\n', '     assembly {\n', '         memPtr := add(self, 0x20)\n', '     }\n', '     return RLPItem(memPtr, len);\n', ' }\n', '\n', ' /// @dev Creates an RLPItem from an array of RLP encoded bytes.\n', ' /// @param self The RLP encoded bytes.\n', ' /// @param strict Will throw if the data is not RLP encoded.\n', ' /// @return An RLPItem\n', ' function toRLPItem(bytes memory self, bool strict) internal constant returns (RLPItem memory) {\n', '     var item = toRLPItem(self);\n', '     if(strict) {\n', '         uint len = self.length;\n', '         if(_payloadOffset(item) > len)\n', '             throw;\n', '         if(_itemLength(item._unsafe_memPtr) != len)\n', '             throw;\n', '         if(!_validate(item))\n', '             throw;\n', '     }\n', '     return item;\n', ' }\n', '\n', ' /// @dev Check if the RLP item is null.\n', ' /// @param self The RLP item.\n', " /// @return 'true' if the item is null.\n", ' function isNull(RLPItem memory self) internal constant returns (bool ret) {\n', '     return self._unsafe_length == 0;\n', ' }\n', '\n', ' /// @dev Check if the RLP item is a list.\n', ' /// @param self The RLP item.\n', " /// @return 'true' if the item is a list.\n", ' function isList(RLPItem memory self) internal constant returns (bool ret) {\n', '     if (self._unsafe_length == 0)\n', '         return false;\n', '     uint memPtr = self._unsafe_memPtr;\n', '     assembly {\n', '         ret := iszero(lt(byte(0, mload(memPtr)), 0xC0))\n', '     }\n', ' }\n', '\n', ' /// @dev Check if the RLP item is data.\n', ' /// @param self The RLP item.\n', " /// @return 'true' if the item is data.\n", ' function isData(RLPItem memory self) internal constant returns (bool ret) {\n', '     if (self._unsafe_length == 0)\n', '         return false;\n', '     uint memPtr = self._unsafe_memPtr;\n', '     assembly {\n', '         ret := lt(byte(0, mload(memPtr)), 0xC0)\n', '     }\n', ' }\n', '\n', ' /// @dev Check if the RLP item is empty (string or list).\n', ' /// @param self The RLP item.\n', " /// @return 'true' if the item is null.\n", ' function isEmpty(RLPItem memory self) internal constant returns (bool ret) {\n', '     if(isNull(self))\n', '         return false;\n', '     uint b0;\n', '     uint memPtr = self._unsafe_memPtr;\n', '     assembly {\n', '         b0 := byte(0, mload(memPtr))\n', '     }\n', '     return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\n', ' }\n', '\n', ' /// @dev Get the number of items in an RLP encoded list.\n', ' /// @param self The RLP item.\n', ' /// @return The number of items.\n', ' function items(RLPItem memory self) internal constant returns (uint) {\n', '     if (!isList(self))\n', '         return 0;\n', '     uint b0;\n', '     uint memPtr = self._unsafe_memPtr;\n', '     assembly {\n', '         b0 := byte(0, mload(memPtr))\n', '     }\n', '     uint pos = memPtr + _payloadOffset(self);\n', '     uint last = memPtr + self._unsafe_length - 1;\n', '     uint itms;\n', '     while(pos <= last) {\n', '         pos += _itemLength(pos);\n', '         itms++;\n', '     }\n', '     return itms;\n', ' }\n', '\n', ' /// @dev Create an iterator.\n', ' /// @param self The RLP item.\n', " /// @return An 'Iterator' over the item.\n", ' function iterator(RLPItem memory self) internal constant returns (Iterator memory it) {\n', '     if (!isList(self))\n', '         throw;\n', '     uint ptr = self._unsafe_memPtr + _payloadOffset(self);\n', '     it._unsafe_item = self;\n', '     it._unsafe_nextPtr = ptr;\n', ' }\n', '\n', ' /// @dev Return the RLP encoded bytes.\n', ' /// @param self The RLPItem.\n', ' /// @return The bytes.\n', ' function toBytes(RLPItem memory self) internal constant returns (bytes memory bts) {\n', '     var len = self._unsafe_length;\n', '     if (len == 0)\n', '         return;\n', '     bts = new bytes(len);\n', '     _copyToBytes(self._unsafe_memPtr, bts, len);\n', ' }\n', '\n', ' /// @dev Decode an RLPItem into bytes. This will not work if the\n', ' /// RLPItem is a list.\n', ' /// @param self The RLPItem.\n', ' /// @return The decoded string.\n', ' function toData(RLPItem memory self) internal constant returns (bytes memory bts) {\n', '     if(!isData(self))\n', '         throw;\n', '     var (rStartPos, len) = _decode(self);\n', '     bts = new bytes(len);\n', '     _copyToBytes(rStartPos, bts, len);\n', ' }\n', '\n', ' /// @dev Get the list of sub-items from an RLP encoded list.\n', ' /// Warning: This is inefficient, as it requires that the list is read twice.\n', ' /// @param self The RLP item.\n', ' /// @return Array of RLPItems.\n', ' function toList(RLPItem memory self) internal constant returns (RLPItem[] memory list) {\n', '     if(!isList(self))\n', '         throw;\n', '     var numItems = items(self);\n', '     list = new RLPItem[](numItems);\n', '     var it = iterator(self);\n', '     uint idx;\n', '     while(hasNext(it)) {\n', '         list[idx] = next(it);\n', '         idx++;\n', '     }\n', ' }\n', '\n', ' /// @dev Decode an RLPItem into an ascii string. This will not work if the\n', ' /// RLPItem is a list.\n', ' /// @param self The RLPItem.\n', ' /// @return The decoded string.\n', ' function toAscii(RLPItem memory self) internal constant returns (string memory str) {\n', '     if(!isData(self))\n', '         throw;\n', '     var (rStartPos, len) = _decode(self);\n', '     bytes memory bts = new bytes(len);\n', '     _copyToBytes(rStartPos, bts, len);\n', '     str = string(bts);\n', ' }\n', '\n', ' /// @dev Decode an RLPItem into a uint. This will not work if the\n', ' /// RLPItem is a list.\n', ' /// @param self The RLPItem.\n', ' /// @return The decoded string.\n', ' function toUint(RLPItem memory self) internal constant returns (uint data) {\n', '     if(!isData(self))\n', '         throw;\n', '     var (rStartPos, len) = _decode(self);\n', '     if (len > 32 || len == 0)\n', '         throw;\n', '     assembly {\n', '         data := div(mload(rStartPos), exp(256, sub(32, len)))\n', '     }\n', ' }\n', '\n', ' /// @dev Decode an RLPItem into a boolean. This will not work if the\n', ' /// RLPItem is a list.\n', ' /// @param self The RLPItem.\n', ' /// @return The decoded string.\n', ' function toBool(RLPItem memory self) internal constant returns (bool data) {\n', '     if(!isData(self))\n', '         throw;\n', '     var (rStartPos, len) = _decode(self);\n', '     if (len != 1)\n', '         throw;\n', '     uint temp;\n', '     assembly {\n', '         temp := byte(0, mload(rStartPos))\n', '     }\n', '     if (temp > 1)\n', '         throw;\n', '     return temp == 1 ? true : false;\n', ' }\n', '\n', ' /// @dev Decode an RLPItem into a byte. This will not work if the\n', ' /// RLPItem is a list.\n', ' /// @param self The RLPItem.\n', ' /// @return The decoded string.\n', ' function toByte(RLPItem memory self) internal constant returns (byte data) {\n', '     if(!isData(self))\n', '         throw;\n', '     var (rStartPos, len) = _decode(self);\n', '     if (len != 1)\n', '         throw;\n', '     uint temp;\n', '     assembly {\n', '         temp := byte(0, mload(rStartPos))\n', '     }\n', '     return byte(temp);\n', ' }\n', '\n', ' /// @dev Decode an RLPItem into an int. This will not work if the\n', ' /// RLPItem is a list.\n', ' /// @param self The RLPItem.\n', ' /// @return The decoded string.\n', ' function toInt(RLPItem memory self) internal constant returns (int data) {\n', '     return int(toUint(self));\n', ' }\n', '\n', ' /// @dev Decode an RLPItem into a bytes32. This will not work if the\n', ' /// RLPItem is a list.\n', ' /// @param self The RLPItem.\n', ' /// @return The decoded string.\n', ' function toBytes32(RLPItem memory self) internal constant returns (bytes32 data) {\n', '     return bytes32(toUint(self));\n', ' }\n', '\n', ' /// @dev Decode an RLPItem into an address. This will not work if the\n', ' /// RLPItem is a list.\n', ' /// @param self The RLPItem.\n', ' /// @return The decoded string.\n', ' function toAddress(RLPItem memory self) internal constant returns (address data) {\n', '     if(!isData(self))\n', '         throw;\n', '     var (rStartPos, len) = _decode(self);\n', '     if (len != 20)\n', '         throw;\n', '     assembly {\n', '         data := div(mload(rStartPos), exp(256, 12))\n', '     }\n', ' }\n', '\n', ' // Get the payload offset.\n', ' function _payloadOffset(RLPItem memory self) private constant returns (uint) {\n', '     if(self._unsafe_length == 0)\n', '         return 0;\n', '     uint b0;\n', '     uint memPtr = self._unsafe_memPtr;\n', '     assembly {\n', '         b0 := byte(0, mload(memPtr))\n', '     }\n', '     if(b0 < DATA_SHORT_START)\n', '         return 0;\n', '     if(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))\n', '         return 1;\n', '     if(b0 < LIST_SHORT_START)\n', '         return b0 - DATA_LONG_OFFSET + 1;\n', '     return b0 - LIST_LONG_OFFSET + 1;\n', ' }\n', '\n', ' // Get the full length of an RLP item.\n', ' function _itemLength(uint memPtr) private constant returns (uint len) {\n', '     uint b0;\n', '     assembly {\n', '         b0 := byte(0, mload(memPtr))\n', '     }\n', '     if (b0 < DATA_SHORT_START)\n', '         len = 1;\n', '     else if (b0 < DATA_LONG_START)\n', '         len = b0 - DATA_SHORT_START + 1;\n', '     else if (b0 < LIST_SHORT_START) {\n', '         assembly {\n', '             let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\n', '             let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\n', '             len := add(1, add(bLen, dLen)) // total length\n', '         }\n', '     }\n', '     else if (b0 < LIST_LONG_START)\n', '         len = b0 - LIST_SHORT_START + 1;\n', '     else {\n', '         assembly {\n', '             let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\n', '             let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\n', '             len := add(1, add(bLen, dLen)) // total length\n', '         }\n', '     }\n', ' }\n', '\n', ' // Get start position and length of the data.\n', ' function _decode(RLPItem memory self) private constant returns (uint memPtr, uint len) {\n', '     if(!isData(self))\n', '         throw;\n', '     uint b0;\n', '     uint start = self._unsafe_memPtr;\n', '     assembly {\n', '         b0 := byte(0, mload(start))\n', '     }\n', '     if (b0 < DATA_SHORT_START) {\n', '         memPtr = start;\n', '         len = 1;\n', '         return;\n', '     }\n', '     if (b0 < DATA_LONG_START) {\n', '         len = self._unsafe_length - 1;\n', '         memPtr = start + 1;\n', '     } else {\n', '         uint bLen;\n', '         assembly {\n', '             bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\n', '         }\n', '         len = self._unsafe_length - 1 - bLen;\n', '         memPtr = start + bLen + 1;\n', '     }\n', '     return;\n', ' }\n', '\n', ' // Assumes that enough memory has been allocated to store in target.\n', ' function _copyToBytes(uint btsPtr, bytes memory tgt, uint btsLen) private constant {\n', "     // Exploiting the fact that 'tgt' was the last thing to be allocated,\n", '     // we can write entire words, and just overwrite any excess.\n', '     assembly {\n', '         {\n', '                 let i := 0 // Start at arr + 0x20\n', '                 let words := div(add(btsLen, 31), 32)\n', '                 let rOffset := btsPtr\n', '                 let wOffset := add(tgt, 0x20)\n', '             tag_loop:\n', '                 jumpi(end, eq(i, words))\n', '                 {\n', '                     let offset := mul(i, 0x20)\n', '                     mstore(add(wOffset, offset), mload(add(rOffset, offset)))\n', '                     i := add(i, 1)\n', '                 }\n', '                 jump(tag_loop)\n', '             end:\n', '                 mstore(add(tgt, add(0x20, mload(tgt))), 0)\n', '         }\n', '     }\n', ' }\n', '\n', ' // Check that an RLP item is valid.\n', '     function _validate(RLPItem memory self) private constant returns (bool ret) {\n', '         // Check that RLP is well-formed.\n', '         uint b0;\n', '         uint b1;\n', '         uint memPtr = self._unsafe_memPtr;\n', '         assembly {\n', '             b0 := byte(0, mload(memPtr))\n', '             b1 := byte(1, mload(memPtr))\n', '         }\n', '         if(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START)\n', '             return false;\n', '         return true;\n', '     }\n', '}\n', '\n', '/*\n', '    Copyright 2016, Jordi Baylina\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', ' */\n', '\n', '/// @title MilestoneTracker Contract\n', '/// @author Jordi Baylina\n', '/// @dev This contract tracks the\n', '\n', '\n', '/// is rules the relation betwen a donor and a recipient\n', '///  in order to guaranty to the donor that the job will be done and to guaranty\n', '///  to the recipient that he will be paid\n', '\n', '\n', '/// @dev We use the RLP library to decode RLP so that the donor can approve one\n', '///  set of milestone changes at a time.\n', '///  https://github.com/androlo/standard-contracts/blob/master/contracts/src/codec/RLP.sol\n', '// import "RLP.sol";\n', '\n', '\n', '\n', '/// @dev This contract allows for `recipient` to set and modify milestones\n', 'contract MilestoneTracker {\n', '    using RLP for RLP.RLPItem;\n', '    using RLP for RLP.Iterator;\n', '    using RLP for bytes;\n', '\n', '    struct Milestone {\n', '        string description;     // Description of the milestone\n', '        string url;             // A link to more information (swarm gateway)\n', '        uint minCompletionDate;       // Earliest UNIX time the milestone can be paid\n', '        uint maxCompletionDate;       // Latest UNIX time the milestone can be paid\n', '        address reviewer;       // Who will check the milestone has completed\n', '        uint reviewTime;        // How many seconds the reviewer has to review\n', '        address paymentSource;  // Where the milestone payment is sent from\n', '        bytes payData;          // Data defining how much ether is sent where\n', '\n', '        MilestoneStatus status; // Current status of the milestone (Completed, Paid...)\n', '        uint doneTime;          // UNIX time when the milestone was marked DONE\n', '    }\n', '\n', '    // The list of all the milestones.\n', '    Milestone[] public milestones;\n', '\n', '    address public recipient;   // Calls functions in the name of the recipient\n', '    address public donor;       // Calls functions in the name of the donor\n', '    address public arbitrator;  // Calls functions in the name of the arbitrator\n', '\n', '    enum MilestoneStatus { AcceptedAndInProgress, Completed, Paid, Canceled }\n', '\n', '    // True if the campaign has been canceled\n', '    bool public campaignCanceled;\n', '\n', '    // True if an approval on a change to `milestones` is a pending\n', '    bool public changingMilestones;\n', '\n', '    // The pending change to `milestones` encoded in RLP\n', '    bytes public proposedMilestones;\n', '\n', '\n', '    /// @dev The following modifiers only allow specific roles to call functions\n', '    /// with these modifiers\n', '    modifier onlyRecipient { if (msg.sender !=  recipient) throw; _; }\n', '    modifier onlyArbitrator { if (msg.sender != arbitrator) throw; _; }\n', '    modifier onlyDonor { if (msg.sender != donor) throw; _; }\n', '\n', '    /// @dev The following modifiers prevent functions from being called if the\n', '    /// campaign has been canceled or if new milestones are being proposed\n', '    modifier campaignNotCanceled { if (campaignCanceled) throw; _; }\n', '    modifier notChanging { if (changingMilestones) throw; _; }\n', '\n', ' // @dev Events to make the payment movements easy to find on the blockchain\n', '    event NewMilestoneListProposed();\n', '    event NewMilestoneListUnproposed();\n', '    event NewMilestoneListAccepted();\n', '    event ProposalStatusChanged(uint idProposal, MilestoneStatus newProposal);\n', '    event CampaignCalncelled();\n', '\n', '\n', '///////////\n', '// Constructor\n', '///////////\n', '\n', '    /// @notice The Constructor creates the Milestone contract on the blockchain\n', '    /// @param _arbitrator Address assigned to be the arbitrator\n', '    /// @param _donor Address assigned to be the donor\n', '    /// @param _recipient Address assigned to be the recipient\n', '    function MilestoneTracker (\n', '        address _arbitrator,\n', '        address _donor,\n', '        address _recipient\n', '    ) {\n', '        arbitrator = _arbitrator;\n', '        donor = _donor;\n', '        recipient = _recipient;\n', '    }\n', '\n', '\n', '/////////\n', '// Helper functions\n', '/////////\n', '\n', '    /// @return The number of milestones ever created even if they were canceled\n', '    function numberOfMilestones() constant returns (uint) {\n', '        return milestones.length;\n', '    }\n', '\n', '\n', '////////\n', '// Change players\n', '////////\n', '\n', '    /// @notice `onlyArbitrator` Reassigns the arbitrator to a new address\n', '    /// @param _newArbitrator The new arbitrator\n', '    function changeArbitrator(address _newArbitrator) onlyArbitrator {\n', '        arbitrator = _newArbitrator;\n', '    }\n', '\n', '    /// @notice `onlyDonor` Reassigns the `donor` to a new address\n', '    /// @param _newDonor The new donor\n', '    function changeDonor(address _newDonor) onlyDonor {\n', '        donor = _newDonor;\n', '    }\n', '\n', '    /// @notice `onlyRecipient` Reassigns the `recipient` to a new address\n', '    /// @param _newRecipient The new recipient\n', '    function changeRecipient(address _newRecipient) onlyRecipient {\n', '        recipient = _newRecipient;\n', '    }\n', '\n', '\n', '////////////\n', '// Creation and modification of Milestones\n', '////////////\n', '\n', '    /// @notice `onlyRecipient` Proposes new milestones or changes old\n', '    ///  milestones, this will require a user interface to be built up to\n', '    ///  support this functionality as asks for RLP encoded bytecode to be\n', '    ///  generated, until this interface is built you can use this script:\n', '    ///  https://github.com/Giveth/milestonetracker/blob/master/js/milestonetracker_helper.js\n', '    ///  the functions milestones2bytes and bytes2milestones will enable the\n', '    ///  recipient to encode and decode a list of milestones, also see\n', '    ///  https://github.com/Giveth/milestonetracker/blob/master/README.md\n', '    /// @param _newMilestones The RLP encoded list of milestones; each milestone\n', '    ///  has these fields:\n', '    ///       string description,\n', '    ///       string url,\n', '    ///       address paymentSource,\n', '    ///       bytes payData,\n', '    ///       uint minCompletionDate,\n', '    ///       uint maxCompletionDate,\n', '    ///       address reviewer,\n', '    ///       uint reviewTime\n', '    function proposeMilestones(bytes _newMilestones\n', '    ) onlyRecipient campaignNotCanceled {\n', '        proposedMilestones = _newMilestones;\n', '        changingMilestones = true;\n', '        NewMilestoneListProposed();\n', '    }\n', '\n', '\n', '////////////\n', '// Normal actions that will change the state of the milestones\n', '////////////\n', '\n', '    /// @notice `onlyRecipient` Cancels the proposed milestones and reactivates\n', '    ///  the previous set of milestones\n', '    function unproposeMilestones() onlyRecipient campaignNotCanceled {\n', '        delete proposedMilestones;\n', '        changingMilestones = false;\n', '        NewMilestoneListUnproposed();\n', '    }\n', '\n', '    /// @notice `onlyDonor` Approves the proposed milestone list\n', "    /// @param _hashProposals The sha3() of the proposed milestone list's\n", '    ///  bytecode; this confirms that the `donor` knows the set of milestones\n', '    ///  they are approving\n', '    function acceptProposedMilestones(bytes32 _hashProposals\n', '    ) onlyDonor campaignNotCanceled {\n', '\n', '        uint i;\n', '\n', '        if (!changingMilestones) throw;\n', '        if (sha3(proposedMilestones) != _hashProposals) throw;\n', '\n', '        // Cancel all the unfinished milestones\n', '        for (i=0; i<milestones.length; i++) {\n', '            if (milestones[i].status != MilestoneStatus.Paid) {\n', '                milestones[i].status = MilestoneStatus.Canceled;\n', '            }\n', '        }\n', '        // Decode the RLP encoded milestones and add them to the milestones list\n', '        bytes memory mProposedMilestones = proposedMilestones;\n', '\n', '        var itmProposals = mProposedMilestones.toRLPItem(true);\n', '\n', '        if (!itmProposals.isList()) throw;\n', '\n', '        var itrProposals = itmProposals.iterator();\n', '\n', '        while(itrProposals.hasNext()) {\n', '\n', '\n', '            var itmProposal = itrProposals.next();\n', '\n', '            Milestone milestone = milestones[milestones.length ++];\n', '\n', '            if (!itmProposal.isList()) throw;\n', '\n', '            var itrProposal = itmProposal.iterator();\n', '\n', '            milestone.description = itrProposal.next().toAscii();\n', '            milestone.url = itrProposal.next().toAscii();\n', '            milestone.minCompletionDate = itrProposal.next().toUint();\n', '            milestone.maxCompletionDate = itrProposal.next().toUint();\n', '            milestone.reviewer = itrProposal.next().toAddress();\n', '            milestone.reviewTime = itrProposal.next().toUint();\n', '            milestone.paymentSource = itrProposal.next().toAddress();\n', '            milestone.payData = itrProposal.next().toData();\n', '\n', '            milestone.status = MilestoneStatus.AcceptedAndInProgress;\n', '\n', '        }\n', '\n', '        delete proposedMilestones;\n', '        changingMilestones = false;\n', '        NewMilestoneListAccepted();\n', '    }\n', '\n', '    /// @notice `onlyReviewer` Approves a specific milestone\n', '    /// @param _idMilestone ID of the milestone that is approved\n', '    function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {\n', '        if (_idMilestone >= milestones.length) throw;\n', '        Milestone milestone = milestones[_idMilestone];\n', '        if ((msg.sender != milestone.reviewer) ||\n', '            (milestone.status != MilestoneStatus.Completed)) throw;\n', '\n', '        doPayment(_idMilestone);\n', '    }\n', '\n', "    /// @notice `onlyReviewer` Rejects a specific milestone's completion and\n", '    ///  reverts the `milestone.status` back to the `AcceptedAndInProgress` state\n', '    /// @param _idMilestone ID of the milestone that is being rejected\n', '    function rejectMilestone(uint _idMilestone) campaignNotCanceled notChanging {\n', '        if (_idMilestone >= milestones.length) throw;\n', '        Milestone milestone = milestones[_idMilestone];\n', '        if ((msg.sender != milestone.reviewer) ||\n', '            (milestone.status != MilestoneStatus.Completed)) throw;\n', '\n', '        milestone.status = MilestoneStatus.AcceptedAndInProgress;\n', '        ProposalStatusChanged(_idMilestone, milestone.status);\n', '    }\n', '\n', '    /// @notice `onlyRecipient` Marks a milestone as DONE and ready for review\n', '    /// @param _idMilestone ID of the milestone that has been completed\n', '    function milestoneCompleted(uint _idMilestone) onlyRecipient campaignNotCanceled notChanging {\n', '        if (_idMilestone >= milestones.length) throw;\n', '        Milestone milestone = milestones[_idMilestone];\n', '        if (milestone.status != MilestoneStatus.AcceptedAndInProgress) throw;\n', '        if (now < milestone.minCompletionDate) throw;\n', '        if (now > milestone.maxCompletionDate) throw;\n', '        milestone.status = MilestoneStatus.Completed;\n', '        milestone.doneTime = now;\n', '        ProposalStatusChanged(_idMilestone, milestone.status);\n', '    }\n', '\n', '    /// @notice `onlyRecipient` Sends the milestone payment as specified in\n', '    ///  `payData`; the recipient can only call this after the `reviewTime` has\n', '    ///  elapsed\n', '    /// @param _idMilestone ID of the milestone to be paid out\n', '    function collectMilestonePayment(uint _idMilestone\n', '        ) onlyRecipient campaignNotCanceled notChanging {\n', '        if (_idMilestone >= milestones.length) throw;\n', '        Milestone milestone = milestones[_idMilestone];\n', '        if  ((milestone.status != MilestoneStatus.Completed) ||\n', '             (now < milestone.doneTime + milestone.reviewTime))\n', '            throw;\n', '\n', '        doPayment(_idMilestone);\n', '    }\n', '\n', '    /// @notice `onlyRecipient` Cancels a previously accepted milestone\n', '    /// @param _idMilestone ID of the milestone to be canceled\n', '    function cancelMilestone(uint _idMilestone) onlyRecipient campaignNotCanceled notChanging {\n', '        if (_idMilestone >= milestones.length) throw;\n', '        Milestone milestone = milestones[_idMilestone];\n', '        if  ((milestone.status != MilestoneStatus.AcceptedAndInProgress) &&\n', '             (milestone.status != MilestoneStatus.Completed))\n', '            throw;\n', '\n', '        milestone.status = MilestoneStatus.Canceled;\n', '        ProposalStatusChanged(_idMilestone, milestone.status);\n', '    }\n', '\n', '    /// @notice `onlyArbitrator` Forces a milestone to be paid out as long as it\n', '    /// has not been paid or canceled\n', '    /// @param _idMilestone ID of the milestone to be paid out\n', '    function arbitrateApproveMilestone(uint _idMilestone\n', '    ) onlyArbitrator campaignNotCanceled notChanging {\n', '        if (_idMilestone >= milestones.length) throw;\n', '        Milestone milestone = milestones[_idMilestone];\n', '        if  ((milestone.status != MilestoneStatus.AcceptedAndInProgress) &&\n', '             (milestone.status != MilestoneStatus.Completed))\n', '           throw;\n', '        doPayment(_idMilestone);\n', '    }\n', '\n', '    /// @notice `onlyArbitrator` Cancels the entire campaign voiding all\n', '    ///  milestones vo\n', '    function arbitrateCancelCampaign() onlyArbitrator campaignNotCanceled {\n', '        campaignCanceled = true;\n', '        CampaignCalncelled();\n', '    }\n', '\n', '    // @dev This internal function is executed when the milestone is paid out\n', '    function doPayment(uint _idMilestone) internal {\n', '        if (_idMilestone >= milestones.length) throw;\n', '        Milestone milestone = milestones[_idMilestone];\n', '        // Recheck again to not pay twice\n', '        if (milestone.status == MilestoneStatus.Paid) throw;\n', '        milestone.status = MilestoneStatus.Paid;\n', '        if (!milestone.paymentSource.call.value(0)(milestone.payData))\n', '            throw;\n', '        ProposalStatusChanged(_idMilestone, milestone.status);\n', '    }\n', '}']