['// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', ' \n', 'contract BuyerFund {\n', '  // Store the amount of ETH deposited by each account.\n', '  mapping (address => uint256) public balances;\n', ' \n', '  // Track whether the contract has bought the tokens yet.\n', '  bool public bought_tokens;\n', ' \n', '  // Whether contract is enabled.\n', '  bool public contract_enabled;\n', ' \n', '  // Record ETH value of tokens currently held by contract.\n', '  uint256 public contract_eth_value;\n', ' \n', '  // The minimum amount of ETH that must be deposited before the buy-in can be performed.\n', '  uint256 constant public min_required_amount = 100 ether;\n', ' \n', '  // The maximum amount of ETH that can be deposited into the contract.\n', '  uint256 public max_raised_amount = 300 ether;\n', ' \n', '  // The first block after which a refund is allowed. Set in the contract constructor.\n', '  uint256 public min_refund_block;\n', ' \n', '  // The crowdsale address.\n', '  address constant public sale = 0x09AE9886C971279E771030aD5Da37f227fb1e7f9;\n', ' \n', '  // Constructor.\n', '  function BuyerFund() {\n', '    // Minimum block for refund - roughly a week from now, in case of rejected payment.\n', '    min_refund_block = 4362646;\n', '  }\n', ' \n', '  // Allows any user to withdraw his tokens.\n', "  // Takes the token's ERC20 address as argument as it is unknown at the time of contract deployment.\n", '  function perform_withdraw(address tokenAddress) {\n', "    // Disallow withdraw if tokens haven't been bought yet.\n", '    if (!bought_tokens) throw;\n', ' \n', '    // Retrieve current token balance of contract.\n', '    ERC20 token = ERC20(tokenAddress);\n', '    uint256 contract_token_balance = token.balanceOf(address(this));\n', ' \n', '    // Disallow token withdrawals if there are no tokens to withdraw.\n', '    if (contract_token_balance == 0) throw;\n', ' \n', "    // Store the user's token balance in a temporary variable.\n", '    uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value;\n', ' \n', '    // Update the value of tokens currently held by the contract.\n', '    contract_eth_value -= balances[msg.sender];\n', ' \n', "    // Update the user's balance prior to sending to prevent recursive call.\n", '    balances[msg.sender] = 0;\n', ' \n', '    // Send the funds.  Throws on failure to prevent loss of funds.\n', '    if(!token.transfer(msg.sender, tokens_to_withdraw)) throw;\n', '  }\n', ' \n', '  // Allows any user to get his eth refunded before the purchase is made or after approx. 20 days in case the devs refund the eth.\n', '  function refund_me() {\n', '    if (bought_tokens) {\n', '      // Only allow refunds when the tokens have been bought if the minimum refund block has been reached.\n', '      if (block.number < min_refund_block) throw;\n', '    }\n', ' \n', "    // Store the user's balance prior to withdrawal in a temporary variable.\n", '    uint256 eth_to_withdraw = balances[msg.sender];\n', ' \n', "    // Update the user's balance prior to sending ETH to prevent recursive call.\n", '    balances[msg.sender] = 0;\n', ' \n', "    // Return the user's funds.  Throws on failure to prevent loss of funds.\n", '    msg.sender.transfer(eth_to_withdraw);\n', '  }\n', ' \n', '  // Buy the tokens. Sends ETH to the presale wallet and records the ETH amount held in the contract.\n', '  function buy_the_tokens() {\n', '    // Short circuit to save gas if the contract has already bought tokens.\n', ' \n', '    if (msg.sender == 0xC68bb418ee2B566E4a3786F0fA838aEa85aE1186) {\n', ' \n', '        if (bought_tokens) return;\n', ' \n', '        // Throw if the contract balance is less than the minimum required amount\n', '        if (this.balance < min_required_amount) throw;\n', ' \n', '        // Record that the contract has bought the tokens.\n', '        bought_tokens = true;\n', ' \n', "        // Record the amount of ETH sent as the contract's current value.\n", '        contract_eth_value = this.balance;\n', ' \n', '        // Transfer all the funds to the crowdsale address.\n', '        sale.transfer(contract_eth_value);\n', '    }\n', '  }\n', ' \n', '  // Raise total cap.\n', ' function upgrade_cap() {\n', '      if (msg.sender == 0xC68bb418ee2B566E4a3786F0fA838aEa85aE1186) {\n', '          max_raised_amount = 500 ether;\n', '      }\n', '  }\n', ' \n', '  // A helper function for the default function, allowing contracts to interact.\n', '  function default_helper() payable {\n', "    // Only allow deposits if the contract hasn't already purchased the tokens.\n", '    require(!bought_tokens);\n', ' \n', '    // Requires contract creator to enable contract.\n', '    require(contract_enabled);\n', ' \n', '    // Require balance to be less than cap.\n', '    require(this.balance < max_raised_amount);\n', ' \n', '    // Update records of deposited ETH to include the received amount.\n', '    balances[msg.sender] += msg.value;\n', '  }\n', ' \n', '  function enable_sale(){\n', '    if (msg.sender == 0xC68bb418ee2B566E4a3786F0fA838aEa85aE1186) {\n', '        contract_enabled = true;\n', '    }\n', '  }\n', ' \n', '  // Default function.  Called when a user sends ETH to the contract.\n', '  function () payable {\n', '    // Delegate to the helper function.\n', '    default_helper();\n', '  }\n', '}']