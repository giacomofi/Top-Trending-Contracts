['pragma solidity ^0.4.15;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface OraclizeI {\n', '    // address public cbAddress;\n', '    function cbAddress() constant returns (address); // Reads public variable cbAddress\n', '    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n', '    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n', '    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n', '    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n', '    function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n', '    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n', '    function getPrice(string _datasoaurce) returns (uint _dsprice);\n', '    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n', '    function useCoupon(string _coupon);\n', '    function setProofType(byte _proofType);\n', '    function setConfig(bytes32 _config);\n', '    function setCustomGasPrice(uint _gasPrice);\n', '    function randomDS_getSessionPubKeyHash() returns(bytes32);\n', '}\n', '\n', 'interface OraclizeAddrResolverI {\n', '    function getAddress() returns (address _addr);\n', '}\n', '\n', '// this is a reduced and optimize version of the usingOraclize contract in https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.4.sol\n', 'contract myUsingOraclize is Ownable {\n', '    OraclizeAddrResolverI OAR;\n', '    OraclizeI public oraclize;\n', '    uint public oraclize_gaslimit = 120000;\n', '\n', '    function myUsingOraclize() {\n', '        oraclize_setNetwork();\n', '        update_oraclize();\n', '    }\n', '\n', '    function update_oraclize() onlyOwner public {\n', '        oraclize = OraclizeI(OAR.getAddress());\n', '    }\n', '\n', '    function oraclize_query(string datasource, string arg1, string arg2) internal returns (bytes32 id) {\n', '        uint price = oraclize.getPrice(datasource, oraclize_gaslimit);\n', '        if (price > 1 ether + tx.gasprice*oraclize_gaslimit) return 0; // unexpectedly high price\n', '        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, oraclize_gaslimit);\n', '    }\n', '\n', '    function oraclize_getPrice(string datasource) internal returns (uint) {\n', '        return oraclize.getPrice(datasource, oraclize_gaslimit);\n', '    }\n', '\n', '\n', '    function setGasLimit(uint _newLimit) onlyOwner public {\n', '        oraclize_gaslimit = _newLimit;\n', '    }\n', '\n', '    function oraclize_setNetwork() internal {\n', '        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n', '            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n', '        }\n', '        else if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n', '            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n', '        }\n', '        else if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n', '            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n', '        }\n', '        else if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n', '            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n', '        }\n', '        else if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n', '            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n', '        }\n', '        else if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n', '            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n', '        }\n', '        else if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n', '            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n', '        }\n', '        else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function getCodeSize(address _addr) constant internal returns(uint _size) {\n', '        assembly {\n', '            _size := extcodesize(_addr)\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    // This will not throw error on wrong input, but instead consume large and unknown amount of gas\n', '    // This should never occure as it&#39;s use with the ShapeShift deposit return value is checked before calling function\n', '    function parseAddr(string _a) internal returns (address){\n', '        bytes memory tmp = bytes(_a);\n', '        uint160 iaddr = 0;\n', '        uint160 b1;\n', '        uint160 b2;\n', '        for (uint i=2; i<2+2*20; i+=2){\n', '            iaddr *= 256;\n', '            b1 = uint160(tmp[i]);\n', '            b2 = uint160(tmp[i+1]);\n', '            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n', '            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n', '            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n', '            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n', '            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n', '            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n', '            iaddr += (b1*16+b2);\n', '        }\n', '        return address(iaddr);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title InterCrypto\n', ' * @dev The InterCrypto offers a no-commission service using Oraclize and ShapeShift\n', ' * that allows for on-blockchain conversion from Ether to any other blockchain that ShapeShift supports.\n', ' * @author Jack Tanner - <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="fe94908acfc8be979dd09f9dd08b95">[email&#160;protected]</a>>\n', ' */\n', 'contract InterCrypto is Ownable, myUsingOraclize {\n', '    // _______________VARIABLES_______________\n', '    struct Conversion {\n', '        address returnAddress;\n', '        uint amount;\n', '    }\n', '\n', '    mapping (uint => Conversion) public conversions;\n', '    uint conversionCount = 0;\n', '    mapping (bytes32 => uint) oraclizeMyId2conversionID;\n', '    mapping (address => uint) public recoverable;\n', '\n', '    // _______________EVENTS_______________\n', '    event ConversionStarted(uint indexed conversionID);\n', '    event ConversionSentToShapeShift(uint indexed conversionID, address indexed returnAddress, address indexed depositAddress, uint amount);\n', '    event ConversionAborted(uint indexed conversionID, string reason);\n', '    event Recovered(address indexed recoveredTo, uint amount);\n', '\n', '    // _______________EXTERNAL FUNCTIONS_______________\n', '    /**\n', '     * Constructor.\n', '     */\n', '    function InterCrypto() {}\n', '\n', '    /**\n', '     * Destroys the contract and returns and Ether to the owner.\n', '     */\n', '    function kill() onlyOwner external {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    /**\n', '     * Fallback function to allow contract to accept Ether.\n', '     */\n', '    function () payable {}\n', '\n', '    /**\n', '     * Sets up a ShapeShift cryptocurrency conversion using Oraclize and the ShapeShift API. Must be sent more Ether than the Oraclize price.\n', '     * Returns a conversionID which can be used for tracking of the conversion.\n', '     * @param _coinSymbol The coinsymbol of the other blockchain to be used by ShapeShift. See engine() function for more details.\n', '     * @param _toAddress The address on the other blockchain that the converted cryptocurrency will be sent to.\n', '     */\n', '    function convert1(string _coinSymbol, string _toAddress) external payable returns(uint) {\n', '        return engine(_coinSymbol, _toAddress, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Sets up a ShapeShift cryptocurrency conversion using Oraclize and the ShapeShift API. Must be sent more Ether than the Oraclize price.\n', '     * Returns a conversionID which can be used for tracking of the conversion.\n', '     * @param _coinSymbol The coinsymbol of the other blockchain to be used by ShapeShift. See engine() function for more details.\n', '     * @param _toAddress The address on the other blockchain that the converted cryptocurrency will be sent to.\n', '     * @param _returnAddress The Ethereum address that any Ether should be sent back to in the event that the ShapeShift conversion is invalid or fails\n', '     */\n', '    function convert2(string _coinSymbol, string _toAddress, address _returnAddress) external payable returns(uint) {\n', '        return engine(_coinSymbol, _toAddress, _returnAddress);\n', '    }\n', '\n', '    /**\n', '     * Callback function for use exclusively by Oraclize.\n', '     * @param myid The Oraclize id of the query.\n', '     * @param result The result of the query.\n', '     */\n', '    function __callback(bytes32 myid, string result) {\n', '        if (msg.sender != oraclize.cbAddress()) revert();\n', '\n', '        uint conversionID = oraclizeMyId2conversionID[myid];\n', '\n', '        if( bytes(result).length == 0 ) {\n', '            ConversionAborted(conversionID, "Oraclize return value was invalid, this is probably due to incorrect convert() argments");\n', '            recoverable[conversions[conversionID].returnAddress] += conversions[conversionID].amount;\n', '            conversions[conversionID].amount = 0;\n', '        }\n', '        else {\n', '            address depositAddress = parseAddr(result);\n', '            require(depositAddress != msg.sender); // prevent DAO tpe re-entracy vulnerability that can potentially be done by Oraclize\n', '            uint sendAmount = conversions[conversionID].amount;\n', '            conversions[conversionID].amount = 0;\n', '            if (depositAddress.send(sendAmount)) {\n', '                ConversionSentToShapeShift(conversionID, conversions[conversionID].returnAddress, depositAddress, sendAmount);\n', '            }\n', '            else {\n', '                ConversionAborted(conversionID, "deposit to address returned by Oraclize failed");\n', '                recoverable[conversions[conversionID].returnAddress] += sendAmount;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Cancel a cryptocurrency conversion.\n', '     * This should only be required to be called if Oraclize fails make a return call to __callback().\n', '     * @param conversionID The conversion ID of the cryptocurrency conversion, generated during engine().\n', '     */\n', '     function cancelConversion(uint conversionID) external {\n', '        Conversion memory conversion = conversions[conversionID];\n', '\n', '        if (conversion.amount > 0) {\n', '            require(msg.sender == conversion.returnAddress);\n', '            recoverable[msg.sender] += conversion.amount;\n', '            conversions[conversionID].amount = 0;\n', '            ConversionAborted(conversionID, "conversion cancelled by creator");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Recover any recoverable funds due to the failure of InterCrypto. Failure can occure due to:\n', '     * 1. Bad user inputs to convert().\n', '     * 2. ShapeShift temporarily or permanently discontinues support of other blockchain.\n', '     * 3. ShapeShift service becomes unavailable.\n', '     * 4. Oraclize service become unavailable.\n', '     */\n', '     function recover() external {\n', '        uint amount = recoverable[msg.sender];\n', '        recoverable[msg.sender] = 0;\n', '        if (msg.sender.send(amount)) {\n', '            Recovered(msg.sender, amount);\n', '        }\n', '        else {\n', '            recoverable[msg.sender] = amount;\n', '        }\n', '    }\n', '    // _______________PUBLIC FUNCTIONS_______________\n', '    /**\n', '     * Returns the price in Wei paid to Oraclize.\n', '     */\n', '    function getInterCryptoPrice() constant public returns (uint) {\n', '        return oraclize_getPrice(&#39;URL&#39;);\n', '    }\n', '\n', '    // _______________INTERNAL FUNCTIONS_______________\n', '    /**\n', '     * Sets up a ShapeShift cryptocurrency conversion using Oraclize and the ShapeShift API. Must be sent more Ether than the Oraclize price.\n', '     * Returns a conversionID which can be used for tracking of the conversion.\n', '     * @param _coinSymbol The coinsymbol of the other blockchain to be used by ShapeShift. See engine() function for more details.\n', '     * @param _toAddress The address on the other blockchain that the converted cryptocurrency will be sent to.\n', '     * Example first two arguments:\n', '     * "ltc", "LbZcDdMeP96ko85H21TQii98YFF9RgZg3D"    Litecoin\n', '     * "btc", "1L8oRijgmkfcZDYA21b73b6DewLtyYs87s"    Bitcoin\n', '     * "dash", "Xoopows17idkTwNrMZuySXBwQDorsezQAx"   Dash\n', '     * "zec", "t1N7tf1xRxz5cBK51JADijLDWS592FPJtya"   ZCash\n', '     * "doge", "DMAFvwTH2upni7eTau8au6Rktgm2bUkMei"   Dogecoin\n', '     * Test symbol pairs using ShapeShift API (shapeshift.io/validateAddress/[address]/[coinSymbol]) or by creating a test\n', '     * conversion on https://shapeshift.io first whenever possible before using it with InterCrypto.\n', '     * @param _returnAddress The Ethereum address that any Ether should be sent back to in the event that the ShapeShift conversion is invalid or fails.\n', '     */\n', '    function engine(string _coinSymbol, string _toAddress, address _returnAddress) internal returns(uint conversionID) {\n', '        conversionID = conversionCount++;\n', '\n', '        if (\n', '            !isValidString(_coinSymbol, 6) || // Waves smbol is "waves"\n', '            !isValidString(_toAddress, 120)   // Monero integrated addresses are 106 characters\n', '            ) {\n', '            ConversionAborted(conversionID, "input parameters are too long or contain invalid symbols");\n', '            recoverable[msg.sender] += msg.value;\n', '            return;\n', '        }\n', '\n', '        uint oraclizePrice = getInterCryptoPrice();\n', '\n', '        if (msg.value > oraclizePrice) {\n', '            Conversion memory conversion = Conversion(_returnAddress, msg.value-oraclizePrice);\n', '            conversions[conversionID] = Conversion(_returnAddress, msg.value-oraclizePrice);\n', '\n', '            string memory postData = createShapeShiftConversionPost(_coinSymbol, _toAddress);\n', '            bytes32 myQueryId = oraclize_query("URL", "json(https://shapeshift.io/shift).deposit", postData);\n', '\n', '            if (myQueryId == 0) {\n', '                ConversionAborted(conversionID, "unexpectedly high Oraclize price when calling oraclize_query");\n', '                recoverable[msg.sender] += msg.value-oraclizePrice;\n', '                conversions[conversionID].amount = 0;\n', '                return;\n', '            }\n', '            oraclizeMyId2conversionID[myQueryId] = conversionID;\n', '            ConversionStarted(conversionID);\n', '        }\n', '        else {\n', '            ConversionAborted(conversionID, "Not enough Ether sent to cover Oraclize fee");\n', '            conversions[conversionID].amount = 0;\n', '            recoverable[msg.sender] += msg.value;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns true if a given string contains only numbers and letters, and is below a maximum length.\n', '     * @param _string String to be checked.\n', '     * @param maxSize The maximum allowable sting character length. The address on the other blockchain that the converted cryptocurrency will be sent to.\n', '     */\n', '    function isValidString(string _string, uint maxSize) constant internal returns (bool allowed) {\n', '        bytes memory stringBytes = bytes(_string);\n', '        uint lengthBytes = stringBytes.length;\n', '        if (lengthBytes < 1 ||\n', '            lengthBytes > maxSize) {\n', '            return false;\n', '        }\n', '\n', '        for (uint i = 0; i < lengthBytes; i++) {\n', '            byte b = stringBytes[i];\n', '            if ( !(\n', '                (b >= 48 && b <= 57) || // 0 - 9\n', '                (b >= 65 && b <= 90) || // A - Z\n', '                (b >= 97 && b <= 122)   // a - z\n', '            )) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns a concatenation of seven bytes.\n', '     * @param b1 The first bytes to be concatenated.\n', '     * ...\n', '     * @param b7 The last bytes to be concatenated.\n', '     */\n', '    function concatBytes(bytes b1, bytes b2, bytes b3, bytes b4, bytes b5, bytes b6, bytes b7) internal returns (bytes bFinal) {\n', '        bFinal = new bytes(b1.length + b2.length + b3.length + b4.length + b5.length + b6.length + b7.length);\n', '\n', '        uint i = 0;\n', '        uint j;\n', '        for (j = 0; j < b1.length; j++) bFinal[i++] = b1[j];\n', '        for (j = 0; j < b2.length; j++) bFinal[i++] = b2[j];\n', '        for (j = 0; j < b3.length; j++) bFinal[i++] = b3[j];\n', '        for (j = 0; j < b4.length; j++) bFinal[i++] = b4[j];\n', '        for (j = 0; j < b5.length; j++) bFinal[i++] = b5[j];\n', '        for (j = 0; j < b6.length; j++) bFinal[i++] = b6[j];\n', '        for (j = 0; j < b7.length; j++) bFinal[i++] = b7[j];\n', '    }\n', '\n', '    /**\n', '     * Returns the ShapeShift shift API string that is needed to be sent to Oraclize.\n', '     * @param _coinSymbol The coinsymbol of the other blockchain to be used by ShapeShift. See engine() function for more details.\n', '     * @param _toAddress The address on the other blockchain that the converted cryptocurrency will be sent to.\n', '     * Example output:\n', '     * &#39; {"withdrawal":"LbZcDdMeP96ko85H21TQii98YFF9RgZg3D","pair":"eth_ltc","returnAddress":"558999ff2e0daefcb4fcded4c89e07fdf9ccb56c"}&#39;\n', '     * Note that an extra space &#39; &#39; is needed at the start to tell Oraclize to make a POST query\n', '     */\n', '    function createShapeShiftConversionPost(string _coinSymbol, string _toAddress) internal returns (string sFinal) {\n', '        string memory s1 = &#39; {"withdrawal":"&#39;;\n', '        string memory s3 = &#39;","pair":"eth_&#39;;\n', '        string memory s5 = &#39;","returnAddress":"&#39;;\n', '        string memory s7 = &#39;"}&#39;;\n', '\n', '        bytes memory bFinal = concatBytes(bytes(s1), bytes(_toAddress), bytes(s3), bytes(_coinSymbol), bytes(s5), bytes(addressToBytes(msg.sender)), bytes(s7));\n', '\n', '        sFinal = string(bFinal);\n', '    }\n', '\n', '    /**\n', '     * Returns the ASCII numeric or lower case character representation of a number.\n', '     * Authored by from https://github.com/axic\n', '     * @param nibble Nuber to be converted\n', '     */\n', '    function nibbleToChar(uint nibble) internal returns (uint ret) {\n', '        if (nibble > 9)\n', '        return nibble + 87; // nibble + &#39;a&#39;- 10\n', '        else\n', '        return nibble + 48; // &#39;0&#39;\n', '    }\n', '\n', '    /**\n', '     * Returns the bytes representation of a provided Ethereum address\n', '     * Authored by from https://github.com/axic\n', '     * @param _address Ethereum address to be cast to bytes\n', '     */\n', '    function addressToBytes(address _address) internal returns (bytes) {\n', '        uint160 tmp = uint160(_address);\n', '\n', '        // 40 bytes of space, but actually uses 64 bytes\n', '        string memory holder = "                                        ";\n', '        bytes memory ret = bytes(holder);\n', '\n', '        // NOTE: this is written in an expensive way, as out-of-order array access\n', '        //       is not supported yet, e.g. we cannot go in reverse easily\n', '        //       (or maybe it is a bug: https://github.com/ethereum/solidity/issues/212)\n', '        uint j = 0;\n', '        for (uint i = 0; i < 20; i++) {\n', '            uint _tmp = tmp / (2 ** (8*(19-i))); // shr(tmp, 8*(19-i))\n', '            uint nb1 = (_tmp / 0x10) & 0x0f;     // shr(tmp, 8) & 0x0f\n', '            uint nb2 = _tmp & 0x0f;\n', '            ret[j++] = byte(nibbleToChar(nb1));\n', '            ret[j++] = byte(nibbleToChar(nb2));\n', '        }\n', '\n', '        return ret;\n', '    }\n', '\n', '    // _______________PRIVATE FUNCTIONS_______________\n', '\n', '}']
['pragma solidity ^0.4.15;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface OraclizeI {\n', '    // address public cbAddress;\n', '    function cbAddress() constant returns (address); // Reads public variable cbAddress\n', '    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n', '    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n', '    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n', '    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n', '    function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n', '    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n', '    function getPrice(string _datasoaurce) returns (uint _dsprice);\n', '    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n', '    function useCoupon(string _coupon);\n', '    function setProofType(byte _proofType);\n', '    function setConfig(bytes32 _config);\n', '    function setCustomGasPrice(uint _gasPrice);\n', '    function randomDS_getSessionPubKeyHash() returns(bytes32);\n', '}\n', '\n', 'interface OraclizeAddrResolverI {\n', '    function getAddress() returns (address _addr);\n', '}\n', '\n', '// this is a reduced and optimize version of the usingOraclize contract in https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.4.sol\n', 'contract myUsingOraclize is Ownable {\n', '    OraclizeAddrResolverI OAR;\n', '    OraclizeI public oraclize;\n', '    uint public oraclize_gaslimit = 120000;\n', '\n', '    function myUsingOraclize() {\n', '        oraclize_setNetwork();\n', '        update_oraclize();\n', '    }\n', '\n', '    function update_oraclize() onlyOwner public {\n', '        oraclize = OraclizeI(OAR.getAddress());\n', '    }\n', '\n', '    function oraclize_query(string datasource, string arg1, string arg2) internal returns (bytes32 id) {\n', '        uint price = oraclize.getPrice(datasource, oraclize_gaslimit);\n', '        if (price > 1 ether + tx.gasprice*oraclize_gaslimit) return 0; // unexpectedly high price\n', '        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, oraclize_gaslimit);\n', '    }\n', '\n', '    function oraclize_getPrice(string datasource) internal returns (uint) {\n', '        return oraclize.getPrice(datasource, oraclize_gaslimit);\n', '    }\n', '\n', '\n', '    function setGasLimit(uint _newLimit) onlyOwner public {\n', '        oraclize_gaslimit = _newLimit;\n', '    }\n', '\n', '    function oraclize_setNetwork() internal {\n', '        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\n', '            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n', '        }\n', '        else if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\n', '            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n', '        }\n', '        else if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\n', '            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n', '        }\n', '        else if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\n', '            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n', '        }\n', '        else if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\n', '            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n', '        }\n', '        else if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\n', '            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n', '        }\n', '        else if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\n', '            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n', '        }\n', '        else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function getCodeSize(address _addr) constant internal returns(uint _size) {\n', '        assembly {\n', '            _size := extcodesize(_addr)\n', '        }\n', '        return _size;\n', '    }\n', '\n', '    // This will not throw error on wrong input, but instead consume large and unknown amount of gas\n', "    // This should never occure as it's use with the ShapeShift deposit return value is checked before calling function\n", '    function parseAddr(string _a) internal returns (address){\n', '        bytes memory tmp = bytes(_a);\n', '        uint160 iaddr = 0;\n', '        uint160 b1;\n', '        uint160 b2;\n', '        for (uint i=2; i<2+2*20; i+=2){\n', '            iaddr *= 256;\n', '            b1 = uint160(tmp[i]);\n', '            b2 = uint160(tmp[i+1]);\n', '            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n', '            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n', '            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n', '            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n', '            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n', '            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n', '            iaddr += (b1*16+b2);\n', '        }\n', '        return address(iaddr);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title InterCrypto\n', ' * @dev The InterCrypto offers a no-commission service using Oraclize and ShapeShift\n', ' * that allows for on-blockchain conversion from Ether to any other blockchain that ShapeShift supports.\n', ' * @author Jack Tanner - <jnt16@ic.ac.uk>\n', ' */\n', 'contract InterCrypto is Ownable, myUsingOraclize {\n', '    // _______________VARIABLES_______________\n', '    struct Conversion {\n', '        address returnAddress;\n', '        uint amount;\n', '    }\n', '\n', '    mapping (uint => Conversion) public conversions;\n', '    uint conversionCount = 0;\n', '    mapping (bytes32 => uint) oraclizeMyId2conversionID;\n', '    mapping (address => uint) public recoverable;\n', '\n', '    // _______________EVENTS_______________\n', '    event ConversionStarted(uint indexed conversionID);\n', '    event ConversionSentToShapeShift(uint indexed conversionID, address indexed returnAddress, address indexed depositAddress, uint amount);\n', '    event ConversionAborted(uint indexed conversionID, string reason);\n', '    event Recovered(address indexed recoveredTo, uint amount);\n', '\n', '    // _______________EXTERNAL FUNCTIONS_______________\n', '    /**\n', '     * Constructor.\n', '     */\n', '    function InterCrypto() {}\n', '\n', '    /**\n', '     * Destroys the contract and returns and Ether to the owner.\n', '     */\n', '    function kill() onlyOwner external {\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    /**\n', '     * Fallback function to allow contract to accept Ether.\n', '     */\n', '    function () payable {}\n', '\n', '    /**\n', '     * Sets up a ShapeShift cryptocurrency conversion using Oraclize and the ShapeShift API. Must be sent more Ether than the Oraclize price.\n', '     * Returns a conversionID which can be used for tracking of the conversion.\n', '     * @param _coinSymbol The coinsymbol of the other blockchain to be used by ShapeShift. See engine() function for more details.\n', '     * @param _toAddress The address on the other blockchain that the converted cryptocurrency will be sent to.\n', '     */\n', '    function convert1(string _coinSymbol, string _toAddress) external payable returns(uint) {\n', '        return engine(_coinSymbol, _toAddress, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Sets up a ShapeShift cryptocurrency conversion using Oraclize and the ShapeShift API. Must be sent more Ether than the Oraclize price.\n', '     * Returns a conversionID which can be used for tracking of the conversion.\n', '     * @param _coinSymbol The coinsymbol of the other blockchain to be used by ShapeShift. See engine() function for more details.\n', '     * @param _toAddress The address on the other blockchain that the converted cryptocurrency will be sent to.\n', '     * @param _returnAddress The Ethereum address that any Ether should be sent back to in the event that the ShapeShift conversion is invalid or fails\n', '     */\n', '    function convert2(string _coinSymbol, string _toAddress, address _returnAddress) external payable returns(uint) {\n', '        return engine(_coinSymbol, _toAddress, _returnAddress);\n', '    }\n', '\n', '    /**\n', '     * Callback function for use exclusively by Oraclize.\n', '     * @param myid The Oraclize id of the query.\n', '     * @param result The result of the query.\n', '     */\n', '    function __callback(bytes32 myid, string result) {\n', '        if (msg.sender != oraclize.cbAddress()) revert();\n', '\n', '        uint conversionID = oraclizeMyId2conversionID[myid];\n', '\n', '        if( bytes(result).length == 0 ) {\n', '            ConversionAborted(conversionID, "Oraclize return value was invalid, this is probably due to incorrect convert() argments");\n', '            recoverable[conversions[conversionID].returnAddress] += conversions[conversionID].amount;\n', '            conversions[conversionID].amount = 0;\n', '        }\n', '        else {\n', '            address depositAddress = parseAddr(result);\n', '            require(depositAddress != msg.sender); // prevent DAO tpe re-entracy vulnerability that can potentially be done by Oraclize\n', '            uint sendAmount = conversions[conversionID].amount;\n', '            conversions[conversionID].amount = 0;\n', '            if (depositAddress.send(sendAmount)) {\n', '                ConversionSentToShapeShift(conversionID, conversions[conversionID].returnAddress, depositAddress, sendAmount);\n', '            }\n', '            else {\n', '                ConversionAborted(conversionID, "deposit to address returned by Oraclize failed");\n', '                recoverable[conversions[conversionID].returnAddress] += sendAmount;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Cancel a cryptocurrency conversion.\n', '     * This should only be required to be called if Oraclize fails make a return call to __callback().\n', '     * @param conversionID The conversion ID of the cryptocurrency conversion, generated during engine().\n', '     */\n', '     function cancelConversion(uint conversionID) external {\n', '        Conversion memory conversion = conversions[conversionID];\n', '\n', '        if (conversion.amount > 0) {\n', '            require(msg.sender == conversion.returnAddress);\n', '            recoverable[msg.sender] += conversion.amount;\n', '            conversions[conversionID].amount = 0;\n', '            ConversionAborted(conversionID, "conversion cancelled by creator");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Recover any recoverable funds due to the failure of InterCrypto. Failure can occure due to:\n', '     * 1. Bad user inputs to convert().\n', '     * 2. ShapeShift temporarily or permanently discontinues support of other blockchain.\n', '     * 3. ShapeShift service becomes unavailable.\n', '     * 4. Oraclize service become unavailable.\n', '     */\n', '     function recover() external {\n', '        uint amount = recoverable[msg.sender];\n', '        recoverable[msg.sender] = 0;\n', '        if (msg.sender.send(amount)) {\n', '            Recovered(msg.sender, amount);\n', '        }\n', '        else {\n', '            recoverable[msg.sender] = amount;\n', '        }\n', '    }\n', '    // _______________PUBLIC FUNCTIONS_______________\n', '    /**\n', '     * Returns the price in Wei paid to Oraclize.\n', '     */\n', '    function getInterCryptoPrice() constant public returns (uint) {\n', "        return oraclize_getPrice('URL');\n", '    }\n', '\n', '    // _______________INTERNAL FUNCTIONS_______________\n', '    /**\n', '     * Sets up a ShapeShift cryptocurrency conversion using Oraclize and the ShapeShift API. Must be sent more Ether than the Oraclize price.\n', '     * Returns a conversionID which can be used for tracking of the conversion.\n', '     * @param _coinSymbol The coinsymbol of the other blockchain to be used by ShapeShift. See engine() function for more details.\n', '     * @param _toAddress The address on the other blockchain that the converted cryptocurrency will be sent to.\n', '     * Example first two arguments:\n', '     * "ltc", "LbZcDdMeP96ko85H21TQii98YFF9RgZg3D"    Litecoin\n', '     * "btc", "1L8oRijgmkfcZDYA21b73b6DewLtyYs87s"    Bitcoin\n', '     * "dash", "Xoopows17idkTwNrMZuySXBwQDorsezQAx"   Dash\n', '     * "zec", "t1N7tf1xRxz5cBK51JADijLDWS592FPJtya"   ZCash\n', '     * "doge", "DMAFvwTH2upni7eTau8au6Rktgm2bUkMei"   Dogecoin\n', '     * Test symbol pairs using ShapeShift API (shapeshift.io/validateAddress/[address]/[coinSymbol]) or by creating a test\n', '     * conversion on https://shapeshift.io first whenever possible before using it with InterCrypto.\n', '     * @param _returnAddress The Ethereum address that any Ether should be sent back to in the event that the ShapeShift conversion is invalid or fails.\n', '     */\n', '    function engine(string _coinSymbol, string _toAddress, address _returnAddress) internal returns(uint conversionID) {\n', '        conversionID = conversionCount++;\n', '\n', '        if (\n', '            !isValidString(_coinSymbol, 6) || // Waves smbol is "waves"\n', '            !isValidString(_toAddress, 120)   // Monero integrated addresses are 106 characters\n', '            ) {\n', '            ConversionAborted(conversionID, "input parameters are too long or contain invalid symbols");\n', '            recoverable[msg.sender] += msg.value;\n', '            return;\n', '        }\n', '\n', '        uint oraclizePrice = getInterCryptoPrice();\n', '\n', '        if (msg.value > oraclizePrice) {\n', '            Conversion memory conversion = Conversion(_returnAddress, msg.value-oraclizePrice);\n', '            conversions[conversionID] = Conversion(_returnAddress, msg.value-oraclizePrice);\n', '\n', '            string memory postData = createShapeShiftConversionPost(_coinSymbol, _toAddress);\n', '            bytes32 myQueryId = oraclize_query("URL", "json(https://shapeshift.io/shift).deposit", postData);\n', '\n', '            if (myQueryId == 0) {\n', '                ConversionAborted(conversionID, "unexpectedly high Oraclize price when calling oraclize_query");\n', '                recoverable[msg.sender] += msg.value-oraclizePrice;\n', '                conversions[conversionID].amount = 0;\n', '                return;\n', '            }\n', '            oraclizeMyId2conversionID[myQueryId] = conversionID;\n', '            ConversionStarted(conversionID);\n', '        }\n', '        else {\n', '            ConversionAborted(conversionID, "Not enough Ether sent to cover Oraclize fee");\n', '            conversions[conversionID].amount = 0;\n', '            recoverable[msg.sender] += msg.value;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns true if a given string contains only numbers and letters, and is below a maximum length.\n', '     * @param _string String to be checked.\n', '     * @param maxSize The maximum allowable sting character length. The address on the other blockchain that the converted cryptocurrency will be sent to.\n', '     */\n', '    function isValidString(string _string, uint maxSize) constant internal returns (bool allowed) {\n', '        bytes memory stringBytes = bytes(_string);\n', '        uint lengthBytes = stringBytes.length;\n', '        if (lengthBytes < 1 ||\n', '            lengthBytes > maxSize) {\n', '            return false;\n', '        }\n', '\n', '        for (uint i = 0; i < lengthBytes; i++) {\n', '            byte b = stringBytes[i];\n', '            if ( !(\n', '                (b >= 48 && b <= 57) || // 0 - 9\n', '                (b >= 65 && b <= 90) || // A - Z\n', '                (b >= 97 && b <= 122)   // a - z\n', '            )) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns a concatenation of seven bytes.\n', '     * @param b1 The first bytes to be concatenated.\n', '     * ...\n', '     * @param b7 The last bytes to be concatenated.\n', '     */\n', '    function concatBytes(bytes b1, bytes b2, bytes b3, bytes b4, bytes b5, bytes b6, bytes b7) internal returns (bytes bFinal) {\n', '        bFinal = new bytes(b1.length + b2.length + b3.length + b4.length + b5.length + b6.length + b7.length);\n', '\n', '        uint i = 0;\n', '        uint j;\n', '        for (j = 0; j < b1.length; j++) bFinal[i++] = b1[j];\n', '        for (j = 0; j < b2.length; j++) bFinal[i++] = b2[j];\n', '        for (j = 0; j < b3.length; j++) bFinal[i++] = b3[j];\n', '        for (j = 0; j < b4.length; j++) bFinal[i++] = b4[j];\n', '        for (j = 0; j < b5.length; j++) bFinal[i++] = b5[j];\n', '        for (j = 0; j < b6.length; j++) bFinal[i++] = b6[j];\n', '        for (j = 0; j < b7.length; j++) bFinal[i++] = b7[j];\n', '    }\n', '\n', '    /**\n', '     * Returns the ShapeShift shift API string that is needed to be sent to Oraclize.\n', '     * @param _coinSymbol The coinsymbol of the other blockchain to be used by ShapeShift. See engine() function for more details.\n', '     * @param _toAddress The address on the other blockchain that the converted cryptocurrency will be sent to.\n', '     * Example output:\n', '     * \' {"withdrawal":"LbZcDdMeP96ko85H21TQii98YFF9RgZg3D","pair":"eth_ltc","returnAddress":"558999ff2e0daefcb4fcded4c89e07fdf9ccb56c"}\'\n', "     * Note that an extra space ' ' is needed at the start to tell Oraclize to make a POST query\n", '     */\n', '    function createShapeShiftConversionPost(string _coinSymbol, string _toAddress) internal returns (string sFinal) {\n', '        string memory s1 = \' {"withdrawal":"\';\n', '        string memory s3 = \'","pair":"eth_\';\n', '        string memory s5 = \'","returnAddress":"\';\n', '        string memory s7 = \'"}\';\n', '\n', '        bytes memory bFinal = concatBytes(bytes(s1), bytes(_toAddress), bytes(s3), bytes(_coinSymbol), bytes(s5), bytes(addressToBytes(msg.sender)), bytes(s7));\n', '\n', '        sFinal = string(bFinal);\n', '    }\n', '\n', '    /**\n', '     * Returns the ASCII numeric or lower case character representation of a number.\n', '     * Authored by from https://github.com/axic\n', '     * @param nibble Nuber to be converted\n', '     */\n', '    function nibbleToChar(uint nibble) internal returns (uint ret) {\n', '        if (nibble > 9)\n', "        return nibble + 87; // nibble + 'a'- 10\n", '        else\n', "        return nibble + 48; // '0'\n", '    }\n', '\n', '    /**\n', '     * Returns the bytes representation of a provided Ethereum address\n', '     * Authored by from https://github.com/axic\n', '     * @param _address Ethereum address to be cast to bytes\n', '     */\n', '    function addressToBytes(address _address) internal returns (bytes) {\n', '        uint160 tmp = uint160(_address);\n', '\n', '        // 40 bytes of space, but actually uses 64 bytes\n', '        string memory holder = "                                        ";\n', '        bytes memory ret = bytes(holder);\n', '\n', '        // NOTE: this is written in an expensive way, as out-of-order array access\n', '        //       is not supported yet, e.g. we cannot go in reverse easily\n', '        //       (or maybe it is a bug: https://github.com/ethereum/solidity/issues/212)\n', '        uint j = 0;\n', '        for (uint i = 0; i < 20; i++) {\n', '            uint _tmp = tmp / (2 ** (8*(19-i))); // shr(tmp, 8*(19-i))\n', '            uint nb1 = (_tmp / 0x10) & 0x0f;     // shr(tmp, 8) & 0x0f\n', '            uint nb2 = _tmp & 0x0f;\n', '            ret[j++] = byte(nibbleToChar(nb1));\n', '            ret[j++] = byte(nibbleToChar(nb2));\n', '        }\n', '\n', '        return ret;\n', '    }\n', '\n', '    // _______________PRIVATE FUNCTIONS_______________\n', '\n', '}']
