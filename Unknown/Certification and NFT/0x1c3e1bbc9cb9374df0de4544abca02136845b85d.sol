['//A BurnableOpenPayment is instantiated with a specified payer and a commitThreshold.\n', '//The recipient is not set when the contract is instantiated.\n', '\n', '//The constructor is payable, so the contract can be instantiated with initial funds.\n', '//In addition, anyone can add more funds to the Payment by calling addFunds.\n', '\n', '//All behavior of the contract is directed by the payer, but\n', '//the payer can never directly recover the payment,\n', '//unless he calls the recover() function before anyone else commit()s.\n', '\n', '//If the BOP is in the Open state,\n', '//anyone can become the recipient by contributing the commitThreshold with commit().\n', '//This changes the state from Open to Committed. The BOP will never return to the Open state.\n', '//The recipient will never be changed once it&#39;s been set via commit().\n', '\n', '//In the committed state,\n', '//the payer can at any time choose to burn or release to the recipient any amount of funds.\n', '\n', 'pragma solidity ^ 0.4.10;\n', 'contract BurnableOpenPaymentFactory {\n', '\tevent NewBOP(address indexed contractAddress, address newBOPAddress, address payer, uint commitThreshold, bool hasDefaultRelease, uint defaultTimeoutLength, string initialPayerString);\n', '\n', '\t//contract address array\n', '\taddress[]public contracts;\n', '\n', '\tfunction getContractCount()\n', '\tpublic\n', '\tconstant\n', '\treturns(uint) {\n', '\t\treturn contracts.length;\n', '\t}\n', '\n', '\tfunction newBurnableOpenPayment(address payer, uint commitThreshold, bool hasDefaultRelease, uint defaultTimeoutLength, string initialPayerString)\n', '\tpublic\n', '\tpayable\n', '\treturns(address) {\n', '\t\t//pass along any ether to the constructor\n', '\t\taddress newBOPAddr = (new BurnableOpenPayment).value(msg.value)(payer, commitThreshold, hasDefaultRelease, defaultTimeoutLength, initialPayerString);\n', '\t\tNewBOP(this, newBOPAddr, payer, commitThreshold, hasDefaultRelease, defaultTimeoutLength, initialPayerString);\n', '\n', '\t\t//save created BOPs in contract array\n', '\t\tcontracts.push(newBOPAddr);\n', '\n', '\t\treturn newBOPAddr;\n', '\t}\n', '}\n', '\n', 'contract BurnableOpenPayment {\n', '\t//BOP will start with a payer but no recipient (recipient==0x0)\n', '\taddress public payer;\n', '\taddress public recipient;\n', '\taddress constant burnAddress = 0x0;\n', '\t\n', '\t//Set to true if fundsRecovered is called\n', '\tbool recovered = false;\n', '\n', '\t//Note that these will track, but not influence the BOP logic.\n', '\tuint public amountDeposited;\n', '\tuint public amountBurned;\n', '\tuint public amountReleased;\n', '\n', '\t//payerString and recipientString enable rudimentary communication/publishing.\n', '\t//Although the two parties might quickly move to another medium with better privacy or convenience,\n', '\t//beginning with this is nice because it&#39;s already trustless/transparent/signed/pseudonymous/etc.\n', '\tstring public payerString;\n', '\tstring public recipientString;\n', '\n', '\t//Amount of ether a prospective recipient must pay to permanently become the recipient. See commit().\n', '\tuint public commitThreshold;\n', '\n', '\t//What if the payer falls off the face of the planet?\n', '\t//A BOP is instantiated with or without defaultRelease, which cannot be changed after instantiation.\n', '\tbool public hasDefaultRelease;\n', '\n', '\t//if hasDefaultRelease == True, how long should we wait allowing the default release to be called?\n', '\tuint public defaultTimeoutLength;\n', '\n', '\t//Calculated from defaultTimeoutLength in commit(),\n', '\t//and recaluclated whenever the payer (or possibly the recipient) calls delayhasDefaultRelease()\n', '\tuint public defaultTriggerTime;\n', '\n', '\t//Most action happens in the Committed state.\n', '\tenum State {\n', '\t\tOpen,\n', '\t\tCommitted,\n', '\t\tExpended\n', '\t}\n', '\tState public state;\n', '\t//Note that a BOP cannot go from Committed back to Open, but it can go from Expended back to Committed\n', '\t//(this would retain the committed recipient). Search for Expended and Unexpended events to see how this works.\n', '\n', '\tmodifier inState(State s) {\n', '\t\trequire(s == state);\n', '\t\t_;\n', '\t}\n', '\tmodifier onlyPayer() {\n', '\t\trequire(msg.sender == payer);\n', '\t\t_;\n', '\t}\n', '\tmodifier onlyRecipient() {\n', '\t\trequire(msg.sender == recipient);\n', '\t\t_;\n', '\t}\n', '\tmodifier onlyPayerOrRecipient() {\n', '\t\trequire((msg.sender == payer) || (msg.sender == recipient));\n', '\t\t_;\n', '\t}\n', '\n', '\tevent Created(address indexed contractAddress, address payer, uint commitThreshold, bool hasDefaultRelease, uint defaultTimeoutLength, string initialPayerString);\n', '\tevent FundsAdded(uint amount); //The payer has added funds to the BOP.\n', '\tevent PayerStringUpdated(string newPayerString);\n', '\tevent RecipientStringUpdated(string newRecipientString);\n', '\tevent FundsRecovered();\n', '\tevent Committed(address recipient);\n', '\tevent FundsBurned(uint amount);\n', '\tevent FundsReleased(uint amount);\n', '\tevent Expended();\n', '\tevent Unexpended();\n', '\tevent DefaultReleaseDelayed();\n', '\tevent DefaultReleaseCalled();\n', '\n', '\tfunction BurnableOpenPayment(address _payer, uint _commitThreshold, bool _hasDefaultRelease, uint _defaultTimeoutLength, string _payerString)\n', '\tpublic\n', '\tpayable {\n', '\t\tCreated(this, _payer, _commitThreshold, _hasDefaultRelease, _defaultTimeoutLength, _payerString);\n', '\n', '\t\tif (msg.value > 0) {\n', '\t\t\tFundsAdded(msg.value);\n', '\t\t\tamountDeposited += msg.value;\n', '\t\t}\n', '\n', '\t\tstate = State.Open;\n', '\t\tpayer = _payer;\n', '\n', '\t\tcommitThreshold = _commitThreshold;\n', '\n', '\t\thasDefaultRelease = _hasDefaultRelease;\n', '\t\tif (hasDefaultRelease)\n', '\t\t\tdefaultTimeoutLength = _defaultTimeoutLength;\n', '\n', '\t\tpayerString = _payerString;\n', '\t}\n', '\n', '\tfunction getFullState()\n', '\tpublic\n', '\tconstant\n', '\treturns(State, address, string, address, string, uint, uint, uint, uint, uint, bool, uint, uint) {\n', '\t\treturn (state, payer, payerString, recipient, recipientString, this.balance, commitThreshold, amountDeposited, amountBurned, amountReleased, hasDefaultRelease, defaultTimeoutLength, defaultTriggerTime);\n', '\t}\n', '\n', '\tfunction addFunds()\n', '\tpublic\n', '\tpayable {\n', '\t\trequire(msg.value > 0);\n', '\n', '\t\tFundsAdded(msg.value);\n', '\t\tamountDeposited += msg.value;\n', '\t\tif (state == State.Expended) {\n', '\t\t\tstate = State.Committed;\n', '\t\t\tUnexpended();\n', '\t\t}\n', '\t}\n', '\n', '\tfunction recoverFunds()\n', '\tpublic\n', '\tonlyPayer()\n', '\tinState(State.Open) {\n', '\t    recovered = true;\n', '\t\tFundsRecovered();\n', '\t\tselfdestruct(payer);\n', '\t}\n', '\n', '\tfunction commit()\n', '\tpublic\n', '\tinState(State.Open)\n', '\tpayable{\n', '\t\trequire(msg.value >= commitThreshold);\n', '\n', '\t\tif (msg.value > 0) {\n', '\t\t\tFundsAdded(msg.value);\n', '\t\t\tamountDeposited += msg.value;\n', '\t\t}\n', '\n', '\t\trecipient = msg.sender;\n', '\t\tstate = State.Committed;\n', '\t\tCommitted(recipient);\n', '\n', '\t\tif (hasDefaultRelease) {\n', '\t\t\tdefaultTriggerTime = now + defaultTimeoutLength;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction internalBurn(uint amount)\n', '\tprivate\n', '\tinState(State.Committed) {\n', '\t\tburnAddress.transfer(amount);\n', '\n', '\t\tamountBurned += amount;\n', '\t\tFundsBurned(amount);\n', '\n', '\t\tif (this.balance == 0) {\n', '\t\t\tstate = State.Expended;\n', '\t\t\tExpended();\n', '\t\t}\n', '\t}\n', '\n', '\tfunction burn(uint amount)\n', '\tpublic\n', '\tinState(State.Committed)\n', '\tonlyPayer() {\n', '\t\tinternalBurn(amount);\n', '\t}\n', '\n', '\tfunction internalRelease(uint amount)\n', '\tprivate\n', '\tinState(State.Committed) {\n', '\t\trecipient.transfer(amount);\n', '\n', '\t\tamountReleased += amount;\n', '\t\tFundsReleased(amount);\n', '\n', '\t\tif (this.balance == 0) {\n', '\t\t\tstate = State.Expended;\n', '\t\t\tExpended();\n', '\t\t}\n', '\t}\n', '\n', '\tfunction release(uint amount)\n', '\tpublic\n', '\tinState(State.Committed)\n', '\tonlyPayer() {\n', '\t\tinternalRelease(amount);\n', '\t}\n', '\n', '\tfunction setPayerString(string _string)\n', '\tpublic\n', '\tonlyPayer() {\n', '\t\tpayerString = _string;\n', '\t\tPayerStringUpdated(payerString);\n', '\t}\n', '\n', '\tfunction setRecipientString(string _string)\n', '\tpublic\n', '\tonlyRecipient() {\n', '\t\trecipientString = _string;\n', '\t\tRecipientStringUpdated(recipientString);\n', '\t}\n', '\n', '\tfunction delayDefaultRelease()\n', '\tpublic\n', '\tonlyPayerOrRecipient()\n', '\tinState(State.Committed) {\n', '\t\trequire(hasDefaultRelease);\n', '\n', '\t\tdefaultTriggerTime = now + defaultTimeoutLength;\n', '\t\tDefaultReleaseDelayed();\n', '\t}\n', '\n', '\tfunction callDefaultRelease()\n', '\tpublic\n', '\tonlyPayerOrRecipient()\n', '\tinState(State.Committed) {\n', '\t\trequire(hasDefaultRelease);\n', '\t\trequire(now >= defaultTriggerTime);\n', '\n', '\t\tif (hasDefaultRelease) {\n', '\t\t\tinternalRelease(this.balance);\n', '\t\t}\n', '\t\tDefaultReleaseCalled();\n', '\t}\n', '}']
['//A BurnableOpenPayment is instantiated with a specified payer and a commitThreshold.\n', '//The recipient is not set when the contract is instantiated.\n', '\n', '//The constructor is payable, so the contract can be instantiated with initial funds.\n', '//In addition, anyone can add more funds to the Payment by calling addFunds.\n', '\n', '//All behavior of the contract is directed by the payer, but\n', '//the payer can never directly recover the payment,\n', '//unless he calls the recover() function before anyone else commit()s.\n', '\n', '//If the BOP is in the Open state,\n', '//anyone can become the recipient by contributing the commitThreshold with commit().\n', '//This changes the state from Open to Committed. The BOP will never return to the Open state.\n', "//The recipient will never be changed once it's been set via commit().\n", '\n', '//In the committed state,\n', '//the payer can at any time choose to burn or release to the recipient any amount of funds.\n', '\n', 'pragma solidity ^ 0.4.10;\n', 'contract BurnableOpenPaymentFactory {\n', '\tevent NewBOP(address indexed contractAddress, address newBOPAddress, address payer, uint commitThreshold, bool hasDefaultRelease, uint defaultTimeoutLength, string initialPayerString);\n', '\n', '\t//contract address array\n', '\taddress[]public contracts;\n', '\n', '\tfunction getContractCount()\n', '\tpublic\n', '\tconstant\n', '\treturns(uint) {\n', '\t\treturn contracts.length;\n', '\t}\n', '\n', '\tfunction newBurnableOpenPayment(address payer, uint commitThreshold, bool hasDefaultRelease, uint defaultTimeoutLength, string initialPayerString)\n', '\tpublic\n', '\tpayable\n', '\treturns(address) {\n', '\t\t//pass along any ether to the constructor\n', '\t\taddress newBOPAddr = (new BurnableOpenPayment).value(msg.value)(payer, commitThreshold, hasDefaultRelease, defaultTimeoutLength, initialPayerString);\n', '\t\tNewBOP(this, newBOPAddr, payer, commitThreshold, hasDefaultRelease, defaultTimeoutLength, initialPayerString);\n', '\n', '\t\t//save created BOPs in contract array\n', '\t\tcontracts.push(newBOPAddr);\n', '\n', '\t\treturn newBOPAddr;\n', '\t}\n', '}\n', '\n', 'contract BurnableOpenPayment {\n', '\t//BOP will start with a payer but no recipient (recipient==0x0)\n', '\taddress public payer;\n', '\taddress public recipient;\n', '\taddress constant burnAddress = 0x0;\n', '\t\n', '\t//Set to true if fundsRecovered is called\n', '\tbool recovered = false;\n', '\n', '\t//Note that these will track, but not influence the BOP logic.\n', '\tuint public amountDeposited;\n', '\tuint public amountBurned;\n', '\tuint public amountReleased;\n', '\n', '\t//payerString and recipientString enable rudimentary communication/publishing.\n', '\t//Although the two parties might quickly move to another medium with better privacy or convenience,\n', "\t//beginning with this is nice because it's already trustless/transparent/signed/pseudonymous/etc.\n", '\tstring public payerString;\n', '\tstring public recipientString;\n', '\n', '\t//Amount of ether a prospective recipient must pay to permanently become the recipient. See commit().\n', '\tuint public commitThreshold;\n', '\n', '\t//What if the payer falls off the face of the planet?\n', '\t//A BOP is instantiated with or without defaultRelease, which cannot be changed after instantiation.\n', '\tbool public hasDefaultRelease;\n', '\n', '\t//if hasDefaultRelease == True, how long should we wait allowing the default release to be called?\n', '\tuint public defaultTimeoutLength;\n', '\n', '\t//Calculated from defaultTimeoutLength in commit(),\n', '\t//and recaluclated whenever the payer (or possibly the recipient) calls delayhasDefaultRelease()\n', '\tuint public defaultTriggerTime;\n', '\n', '\t//Most action happens in the Committed state.\n', '\tenum State {\n', '\t\tOpen,\n', '\t\tCommitted,\n', '\t\tExpended\n', '\t}\n', '\tState public state;\n', '\t//Note that a BOP cannot go from Committed back to Open, but it can go from Expended back to Committed\n', '\t//(this would retain the committed recipient). Search for Expended and Unexpended events to see how this works.\n', '\n', '\tmodifier inState(State s) {\n', '\t\trequire(s == state);\n', '\t\t_;\n', '\t}\n', '\tmodifier onlyPayer() {\n', '\t\trequire(msg.sender == payer);\n', '\t\t_;\n', '\t}\n', '\tmodifier onlyRecipient() {\n', '\t\trequire(msg.sender == recipient);\n', '\t\t_;\n', '\t}\n', '\tmodifier onlyPayerOrRecipient() {\n', '\t\trequire((msg.sender == payer) || (msg.sender == recipient));\n', '\t\t_;\n', '\t}\n', '\n', '\tevent Created(address indexed contractAddress, address payer, uint commitThreshold, bool hasDefaultRelease, uint defaultTimeoutLength, string initialPayerString);\n', '\tevent FundsAdded(uint amount); //The payer has added funds to the BOP.\n', '\tevent PayerStringUpdated(string newPayerString);\n', '\tevent RecipientStringUpdated(string newRecipientString);\n', '\tevent FundsRecovered();\n', '\tevent Committed(address recipient);\n', '\tevent FundsBurned(uint amount);\n', '\tevent FundsReleased(uint amount);\n', '\tevent Expended();\n', '\tevent Unexpended();\n', '\tevent DefaultReleaseDelayed();\n', '\tevent DefaultReleaseCalled();\n', '\n', '\tfunction BurnableOpenPayment(address _payer, uint _commitThreshold, bool _hasDefaultRelease, uint _defaultTimeoutLength, string _payerString)\n', '\tpublic\n', '\tpayable {\n', '\t\tCreated(this, _payer, _commitThreshold, _hasDefaultRelease, _defaultTimeoutLength, _payerString);\n', '\n', '\t\tif (msg.value > 0) {\n', '\t\t\tFundsAdded(msg.value);\n', '\t\t\tamountDeposited += msg.value;\n', '\t\t}\n', '\n', '\t\tstate = State.Open;\n', '\t\tpayer = _payer;\n', '\n', '\t\tcommitThreshold = _commitThreshold;\n', '\n', '\t\thasDefaultRelease = _hasDefaultRelease;\n', '\t\tif (hasDefaultRelease)\n', '\t\t\tdefaultTimeoutLength = _defaultTimeoutLength;\n', '\n', '\t\tpayerString = _payerString;\n', '\t}\n', '\n', '\tfunction getFullState()\n', '\tpublic\n', '\tconstant\n', '\treturns(State, address, string, address, string, uint, uint, uint, uint, uint, bool, uint, uint) {\n', '\t\treturn (state, payer, payerString, recipient, recipientString, this.balance, commitThreshold, amountDeposited, amountBurned, amountReleased, hasDefaultRelease, defaultTimeoutLength, defaultTriggerTime);\n', '\t}\n', '\n', '\tfunction addFunds()\n', '\tpublic\n', '\tpayable {\n', '\t\trequire(msg.value > 0);\n', '\n', '\t\tFundsAdded(msg.value);\n', '\t\tamountDeposited += msg.value;\n', '\t\tif (state == State.Expended) {\n', '\t\t\tstate = State.Committed;\n', '\t\t\tUnexpended();\n', '\t\t}\n', '\t}\n', '\n', '\tfunction recoverFunds()\n', '\tpublic\n', '\tonlyPayer()\n', '\tinState(State.Open) {\n', '\t    recovered = true;\n', '\t\tFundsRecovered();\n', '\t\tselfdestruct(payer);\n', '\t}\n', '\n', '\tfunction commit()\n', '\tpublic\n', '\tinState(State.Open)\n', '\tpayable{\n', '\t\trequire(msg.value >= commitThreshold);\n', '\n', '\t\tif (msg.value > 0) {\n', '\t\t\tFundsAdded(msg.value);\n', '\t\t\tamountDeposited += msg.value;\n', '\t\t}\n', '\n', '\t\trecipient = msg.sender;\n', '\t\tstate = State.Committed;\n', '\t\tCommitted(recipient);\n', '\n', '\t\tif (hasDefaultRelease) {\n', '\t\t\tdefaultTriggerTime = now + defaultTimeoutLength;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction internalBurn(uint amount)\n', '\tprivate\n', '\tinState(State.Committed) {\n', '\t\tburnAddress.transfer(amount);\n', '\n', '\t\tamountBurned += amount;\n', '\t\tFundsBurned(amount);\n', '\n', '\t\tif (this.balance == 0) {\n', '\t\t\tstate = State.Expended;\n', '\t\t\tExpended();\n', '\t\t}\n', '\t}\n', '\n', '\tfunction burn(uint amount)\n', '\tpublic\n', '\tinState(State.Committed)\n', '\tonlyPayer() {\n', '\t\tinternalBurn(amount);\n', '\t}\n', '\n', '\tfunction internalRelease(uint amount)\n', '\tprivate\n', '\tinState(State.Committed) {\n', '\t\trecipient.transfer(amount);\n', '\n', '\t\tamountReleased += amount;\n', '\t\tFundsReleased(amount);\n', '\n', '\t\tif (this.balance == 0) {\n', '\t\t\tstate = State.Expended;\n', '\t\t\tExpended();\n', '\t\t}\n', '\t}\n', '\n', '\tfunction release(uint amount)\n', '\tpublic\n', '\tinState(State.Committed)\n', '\tonlyPayer() {\n', '\t\tinternalRelease(amount);\n', '\t}\n', '\n', '\tfunction setPayerString(string _string)\n', '\tpublic\n', '\tonlyPayer() {\n', '\t\tpayerString = _string;\n', '\t\tPayerStringUpdated(payerString);\n', '\t}\n', '\n', '\tfunction setRecipientString(string _string)\n', '\tpublic\n', '\tonlyRecipient() {\n', '\t\trecipientString = _string;\n', '\t\tRecipientStringUpdated(recipientString);\n', '\t}\n', '\n', '\tfunction delayDefaultRelease()\n', '\tpublic\n', '\tonlyPayerOrRecipient()\n', '\tinState(State.Committed) {\n', '\t\trequire(hasDefaultRelease);\n', '\n', '\t\tdefaultTriggerTime = now + defaultTimeoutLength;\n', '\t\tDefaultReleaseDelayed();\n', '\t}\n', '\n', '\tfunction callDefaultRelease()\n', '\tpublic\n', '\tonlyPayerOrRecipient()\n', '\tinState(State.Committed) {\n', '\t\trequire(hasDefaultRelease);\n', '\t\trequire(now >= defaultTriggerTime);\n', '\n', '\t\tif (hasDefaultRelease) {\n', '\t\t\tinternalRelease(this.balance);\n', '\t\t}\n', '\t\tDefaultReleaseCalled();\n', '\t}\n', '}']
