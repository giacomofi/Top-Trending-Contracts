['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract SharkProxy is Ownable {\n', '\n', '  event Deposit(address indexed sender, uint256 value);\n', '  event Withdrawal(address indexed to, uint256 value, bytes data);\n', '\n', '  function SharkProxy() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function getOwner() constant returns (address) {\n', '    return owner;\n', '  }\n', '\n', '  function forward(address _destination, uint256 _value, bytes _data) onlyOwner {\n', '    require(_destination != address(0));\n', '    assert(_destination.call.value(_value)(_data)); // send eth and/or data\n', '    if (_value > 0) {\n', '      Withdrawal(_destination, _value, _data);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Default function; is called when Ether is deposited.\n', '   */\n', '  function() payable {\n', '    Deposit(msg.sender, msg.value);\n', '  }\n', '\n', '  /**\n', '   * @dev is called when ERC223 token is deposited.\n', '   */\n', '  function tokenFallback(address _from, uint _value, bytes _data) {\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract FishProxy is SharkProxy {\n', '\n', '  // this address can sign receipt to unlock account\n', '  address lockAddr;\n', '\n', '  function FishProxy(address _owner, address _lockAddr) {\n', '    owner = _owner;\n', '    lockAddr = _lockAddr;\n', '  }\n', '\n', '  function isLocked() constant returns (bool) {\n', '    return lockAddr != 0x0;\n', '  }\n', '\n', '  function unlock(bytes32 _r, bytes32 _s, bytes32 _pl) {\n', '    assert(lockAddr != 0x0);\n', '    // parse receipt data\n', '    uint8 v;\n', '    uint88 target;\n', '    address newOwner;\n', '    assembly {\n', '        v := calldataload(37)\n', '        target := calldataload(48)\n', '        newOwner := calldataload(68)\n', '    }\n', '    // check permission\n', '    assert(target == uint88(address(this)));\n', '    assert(newOwner == msg.sender);\n', '    assert(newOwner != owner);\n', '    assert(ecrecover(sha3(uint8(0), target, newOwner), v, _r, _s) == lockAddr);\n', '    // update state\n', '    owner = newOwner;\n', '    lockAddr = 0x0;\n', '  }\n', '\n', '  /**\n', '   * Default function; is called when Ether is deposited.\n', '   */\n', '  function() payable {\n', '    // if locked, only allow 0.1 ETH max\n', '    // Note this doesn&#39;t prevent other contracts to send funds by using selfdestruct(address);\n', '    // See: https://github.com/ConsenSys/smart-contract-best-practices#remember-that-ether-can-be-forcibly-sent-to-an-account\n', '    assert(lockAddr == address(0) || this.balance <= 1e17);\n', '    Deposit(msg.sender, msg.value);\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract FishFactory {\n', '\n', '  event AccountCreated(address proxy);\n', '\n', '  function create(address _owner, address _lockAddr) {\n', '    address proxy = new FishProxy(_owner, _lockAddr);\n', '    AccountCreated(proxy);\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract SharkProxy is Ownable {\n', '\n', '  event Deposit(address indexed sender, uint256 value);\n', '  event Withdrawal(address indexed to, uint256 value, bytes data);\n', '\n', '  function SharkProxy() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function getOwner() constant returns (address) {\n', '    return owner;\n', '  }\n', '\n', '  function forward(address _destination, uint256 _value, bytes _data) onlyOwner {\n', '    require(_destination != address(0));\n', '    assert(_destination.call.value(_value)(_data)); // send eth and/or data\n', '    if (_value > 0) {\n', '      Withdrawal(_destination, _value, _data);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Default function; is called when Ether is deposited.\n', '   */\n', '  function() payable {\n', '    Deposit(msg.sender, msg.value);\n', '  }\n', '\n', '  /**\n', '   * @dev is called when ERC223 token is deposited.\n', '   */\n', '  function tokenFallback(address _from, uint _value, bytes _data) {\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract FishProxy is SharkProxy {\n', '\n', '  // this address can sign receipt to unlock account\n', '  address lockAddr;\n', '\n', '  function FishProxy(address _owner, address _lockAddr) {\n', '    owner = _owner;\n', '    lockAddr = _lockAddr;\n', '  }\n', '\n', '  function isLocked() constant returns (bool) {\n', '    return lockAddr != 0x0;\n', '  }\n', '\n', '  function unlock(bytes32 _r, bytes32 _s, bytes32 _pl) {\n', '    assert(lockAddr != 0x0);\n', '    // parse receipt data\n', '    uint8 v;\n', '    uint88 target;\n', '    address newOwner;\n', '    assembly {\n', '        v := calldataload(37)\n', '        target := calldataload(48)\n', '        newOwner := calldataload(68)\n', '    }\n', '    // check permission\n', '    assert(target == uint88(address(this)));\n', '    assert(newOwner == msg.sender);\n', '    assert(newOwner != owner);\n', '    assert(ecrecover(sha3(uint8(0), target, newOwner), v, _r, _s) == lockAddr);\n', '    // update state\n', '    owner = newOwner;\n', '    lockAddr = 0x0;\n', '  }\n', '\n', '  /**\n', '   * Default function; is called when Ether is deposited.\n', '   */\n', '  function() payable {\n', '    // if locked, only allow 0.1 ETH max\n', "    // Note this doesn't prevent other contracts to send funds by using selfdestruct(address);\n", '    // See: https://github.com/ConsenSys/smart-contract-best-practices#remember-that-ether-can-be-forcibly-sent-to-an-account\n', '    assert(lockAddr == address(0) || this.balance <= 1e17);\n', '    Deposit(msg.sender, msg.value);\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract FishFactory {\n', '\n', '  event AccountCreated(address proxy);\n', '\n', '  function create(address _owner, address _lockAddr) {\n', '    address proxy = new FishProxy(_owner, _lockAddr);\n', '    AccountCreated(proxy);\n', '  }\n', '\n', '}']
