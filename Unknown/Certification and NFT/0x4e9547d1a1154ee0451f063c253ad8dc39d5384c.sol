['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances. \n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', '\n', '// Migration Agent interface\n', 'contract MigrationAgent {\n', '    function migrateFrom(address _from, uint _value);\n', '}\n', '\n', 'contract GVToken is StandardToken {\n', '    \n', '    // Constants\n', '    string public constant name = "Genesis Vision Token";\n', '    string public constant symbol = "GVT";\n', '    uint   public constant decimals = 18;\n', '    uint   constant TOKEN_LIMIT = 44 * 1e6 * 1e18; \n', '    \n', '    address public ico;\n', '\n', '    // GVT transfers are blocked until ICO is finished.\n', '    bool public isFrozen = true;\n', '\n', '    // Token migration variables\n', '    address public migrationMaster;\n', '    address public migrationAgent;\n', '    uint public totalMigrated;\n', '\n', '    event Migrate(address indexed _from, address indexed _to, uint _value);\n', '\n', '    // Constructor\n', '    function GVToken(address _ico, address _migrationMaster) {\n', '        require(_ico != 0);\n', '        require(_migrationMaster != 0);\n', '        ico = _ico;\n', '        migrationMaster = _migrationMaster;\n', '    }\n', '\n', '    // Create tokens\n', '    function mint(address holder, uint value) {\n', '        require(msg.sender == ico);\n', '        require(value > 0);\n', '        require(totalSupply + value <= TOKEN_LIMIT);\n', '\n', '        balances[holder] += value;\n', '        totalSupply += value;\n', '        Transfer(0x0, holder, value);\n', '    }\n', '\n', '    // Allow token transfer.\n', '    function unfreeze() {\n', '        require(msg.sender == ico);\n', '        isFrozen = false;\n', '    }\n', '\n', '    // ERC20 functions\n', '    // =========================\n', '\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(!isFrozen);\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        require(!isFrozen);\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        require(!isFrozen);\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '    // Token migration\n', '    function migrate(uint value) external {\n', '        require(migrationAgent != 0);\n', '        require(value > 0);\n', '        require(value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] -= value;\n', '        totalSupply -= value;\n', '        totalMigrated += value;\n', '        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\n', '        Migrate(msg.sender, migrationAgent, value);\n', '    }\n', '\n', '    // Set address of migration contract\n', '    function setMigrationAgent(address _agent) external {\n', '        require(migrationAgent == 0);\n', '        require(msg.sender == migrationMaster);\n', '        migrationAgent = _agent;\n', '    }\n', '\n', '    function setMigrationMaster(address _master) external {\n', '        require(msg.sender == migrationMaster);\n', '        require(_master != 0);\n', '        migrationMaster = _master;\n', '    }\n', '}\n', '\n', 'contract GVOptionToken is StandardToken {\n', '    \n', '    address public optionProgram;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint   public constant decimals = 18;\n', '\n', '    uint TOKEN_LIMIT;\n', '\n', '    // Modifiers\n', '    modifier optionProgramOnly { require(msg.sender == optionProgram); _; }\n', '\n', '    // Constructor\n', '    function GVOptionToken(\n', '        address _optionProgram,\n', '        string _name,\n', '        string _symbol,\n', '        uint _TOKEN_LIMIT\n', '    ) {\n', '        require(_optionProgram != 0);        \n', '        optionProgram = _optionProgram;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        TOKEN_LIMIT = _TOKEN_LIMIT;\n', '    }\n', '\n', '    // Create tokens\n', '    function buyOptions(address buyer, uint value) optionProgramOnly {\n', '        require(value > 0);\n', '        require(totalSupply + value <= TOKEN_LIMIT);\n', '\n', '        balances[buyer] += value;\n', '        totalSupply += value;\n', '        Transfer(0x0, buyer, value);\n', '    }\n', '    \n', '    function remainingTokensCount() returns(uint) {\n', '        return TOKEN_LIMIT - totalSupply;\n', '    }\n', '    \n', '    // Burn option tokens after execution during ICO\n', '    function executeOption(address addr, uint optionsCount) \n', '        optionProgramOnly\n', '        returns (uint) {\n', '        if (balances[addr] < optionsCount) {\n', '            optionsCount = balances[addr];\n', '        }\n', '        if (optionsCount == 0) {\n', '            return 0;\n', '        }\n', '\n', '        balances[addr] -= optionsCount;\n', '        totalSupply -= optionsCount;\n', '\n', '        return optionsCount;\n', '    }\n', '}\n', '\n', 'contract GVOptionProgram {\n', '\n', '    // Constants\n', '    uint constant option30perCent = 26 * 1e16; // GVOT30 tokens per usd cent during option purchase \n', '    uint constant option20perCent = 24 * 1e16; // GVOT20 tokens per usd cent during option purchase\n', '    uint constant option10perCent = 22 * 1e16; // GVOT10 tokens per usd cent during option purchase\n', '    uint constant token30perCent  = 13684210526315800;  // GVT tokens per usd cent during execution of GVOT30\n', '    uint constant token20perCent  = 12631578947368500;  // GVT tokens per usd cent during execution of GVOT20\n', '    uint constant token10perCent  = 11578947368421100;  // GVT tokens per usd cent during execution of GVOT10\n', '\n', '    string public constant option30name = "30% GVOT";\n', '    string public constant option20name = "20% GVOT";\n', '    string public constant option10name = "10% GVOT";\n', '\n', '    string public constant option30symbol = "GVOT30";\n', '    string public constant option20symbol = "GVOT20";\n', '    string public constant option10symbol = "GVOT10";\n', '\n', '    uint constant option30_TOKEN_LIMIT = 26 * 1e5 * 1e18;\n', '    uint constant option20_TOKEN_LIMIT = 36 * 1e5 * 1e18;\n', '    uint constant option10_TOKEN_LIMIT = 55 * 1e5 * 1e18;\n', '\n', '    // Events\n', '    event BuyOptions(address buyer, uint amount, string tx, uint8 optionType);\n', '    event ExecuteOptions(address buyer, uint amount, string tx, uint8 optionType);\n', '\n', '    // State variables\n', '    address public gvAgent; // payments bot account\n', '    address public team;    // team account\n', '    address public ico;     \n', '\n', '    GVOptionToken public gvOptionToken30;\n', '    GVOptionToken public gvOptionToken20;\n', '    GVOptionToken public gvOptionToken10;\n', '\n', '    // Modifiers\n', '    modifier icoOnly { require(msg.sender == ico); _; }\n', '    \n', '    // Constructor\n', '    function GVOptionProgram(address _ico, address _gvAgent, address _team) {\n', '        gvOptionToken30 = new GVOptionToken(this, option30name, option30symbol, option30_TOKEN_LIMIT);\n', '        gvOptionToken20 = new GVOptionToken(this, option20name, option20symbol, option20_TOKEN_LIMIT);\n', '        gvOptionToken10 = new GVOptionToken(this, option10name, option10symbol, option10_TOKEN_LIMIT);\n', '        gvAgent = _gvAgent;\n', '        team = _team;\n', '        ico = _ico;\n', '    }\n', '\n', '    // Get remaining tokens for all types of option tokens\n', '    function getBalance() public returns (uint, uint, uint) {\n', '        return (gvOptionToken30.remainingTokensCount(), gvOptionToken20.remainingTokensCount(), gvOptionToken10.remainingTokensCount());\n', '    }\n', '\n', '    // Execute options during the ICO token purchase. Priority: GVOT30 -> GVOT20 -> GVOT10\n', '    function executeOptions(address buyer, uint usdCents, string txHash) icoOnly\n', '        returns (uint executedTokens, uint remainingCents) {\n', '        require(usdCents > 0);\n', '\n', '        (executedTokens, remainingCents) = executeIfAvailable(buyer, usdCents, txHash, gvOptionToken30, 0, token30perCent);\n', '        if (remainingCents == 0) {\n', '            return (executedTokens, 0);\n', '        }\n', '\n', '        uint executed20;\n', '        (executed20, remainingCents) = executeIfAvailable(buyer, remainingCents, txHash, gvOptionToken20, 1, token20perCent);\n', '        if (remainingCents == 0) {\n', '            return (executedTokens + executed20, 0);\n', '        }\n', '\n', '        uint executed10;\n', '        (executed10, remainingCents) = executeIfAvailable(buyer, remainingCents, txHash, gvOptionToken10, 2, token10perCent);\n', '        \n', '        return (executedTokens + executed20 + executed10, remainingCents);\n', '    }\n', '\n', '    // Buy option tokens. Priority: GVOT30 -> GVOT20 -> GVOT10\n', '    function buyOptions(address buyer, uint usdCents, string txHash) icoOnly {\n', '        require(usdCents > 0);\n', '\n', '        var remainUsdCents = buyIfAvailable(buyer, usdCents, txHash, gvOptionToken30, 0, option30perCent);\n', '        if (remainUsdCents == 0) {\n', '            return;\n', '        }\n', '\n', '        remainUsdCents = buyIfAvailable(buyer, remainUsdCents, txHash, gvOptionToken20, 1, option20perCent);\n', '        if (remainUsdCents == 0) {\n', '            return;\n', '        }\n', '\n', '        remainUsdCents = buyIfAvailable(buyer, remainUsdCents, txHash, gvOptionToken10, 2, option10perCent);\n', '    }   \n', '\n', '    // Private functions\n', '    \n', '    function executeIfAvailable(address buyer, uint usdCents, string txHash,\n', '        GVOptionToken optionToken, uint8 optionType, uint optionPerCent)\n', '        private returns (uint executedTokens, uint remainingCents) {\n', '        \n', '        var optionsAmount = usdCents * optionPerCent;\n', '        executedTokens = optionToken.executeOption(buyer, optionsAmount);\n', '        remainingCents = usdCents - (executedTokens / optionPerCent);\n', '        if (executedTokens > 0) {\n', '            ExecuteOptions(buyer, executedTokens, txHash, optionType);\n', '        }\n', '        return (executedTokens, remainingCents);\n', '    }\n', '\n', '    function buyIfAvailable(address buyer, uint usdCents, string txHash,\n', '        GVOptionToken optionToken, uint8 optionType, uint optionsPerCent)\n', '        private returns (uint) {\n', '        \n', '        var availableTokens = optionToken.remainingTokensCount(); \n', '        if (availableTokens > 0) {\n', '            var tokens = usdCents * optionsPerCent;\n', '            if(availableTokens >= tokens) {\n', '                optionToken.buyOptions(buyer, tokens);\n', '                BuyOptions(buyer, tokens, txHash, optionType);\n', '                return 0;\n', '            }\n', '            else {\n', '                optionToken.buyOptions(buyer, availableTokens);\n', '                BuyOptions(buyer, availableTokens, txHash, optionType);\n', '                return usdCents - availableTokens / optionsPerCent;\n', '            }\n', '        }\n', '        return usdCents;\n', '    }\n', '}\n', '\n', 'contract Initable {\n', '    function init(address token);\n', '}\n', '\n', '// Crowdfunding code for Genesis Vision Project\n', 'contract ICO {\n', '\n', '    // Constants\n', '    uint public constant TOKENS_FOR_SALE = 33 * 1e6 * 1e18;\n', '\n', '    // Events\n', '    event StartOptionsSelling();\n', '    event StartICOForOptionsHolders();\n', '    event RunIco();\n', '    event PauseIco();\n', '    event ResumeIco();\n', '    event FinishIco();\n', '\n', '    event BuyTokens(address buyer, uint amount, string txHash);\n', '\n', '    address public gvAgent; // payments bot account\n', '    address public team;    // team account\n', '\n', '    GVToken public gvToken;\n', '    GVOptionProgram public optionProgram;\n', '    Initable public teamAllocator;\n', '    address public migrationMaster;\n', '\n', '    // Modifiers\n', '    modifier teamOnly { require(msg.sender == team); _; }\n', '    modifier gvAgentOnly { require(msg.sender == gvAgent); _; }\n', '\n', '    // Current total token supply\n', '    uint tokensSold = 0;\n', '\n', '    bool public isPaused = false;\n', '    enum IcoState { Created, RunningOptionsSelling, RunningForOptionsHolders, Running, Finished }\n', '    IcoState public icoState = IcoState.Created;\n', '\n', '    // Constructor\n', '    function ICO(address _team, address _gvAgent, address _migrationMaster, address _teamAllocator) {\n', '        gvAgent = _gvAgent;\n', '        team = _team;\n', '        teamAllocator = Initable(_teamAllocator);\n', '        migrationMaster = _migrationMaster;\n', '        gvToken = new GVToken(this, migrationMaster);\n', '    }\n', '\n', '    // Initialize Option Program contract\n', '    function initOptionProgram() external teamOnly {\n', '        if (optionProgram == address(0)) {\n', '            optionProgram = new GVOptionProgram(this, gvAgent, team);\n', '        }\n', '    }\n', '\n', '    // ICO and Option Program state management\n', '    function startOptionsSelling() external teamOnly {\n', '        require(icoState == IcoState.Created);\n', '        // Check if Option Program is initialized\n', '        require(optionProgram != address(0));    \n', '        icoState = IcoState.RunningOptionsSelling;\n', '        StartOptionsSelling();\n', '    }\n', '\n', '    // Finish options selling and start ICO for the option holders\n', '    function startIcoForOptionsHolders() external teamOnly {\n', '        require(icoState == IcoState.RunningOptionsSelling);       \n', '        icoState = IcoState.RunningForOptionsHolders;\n', '        StartICOForOptionsHolders();\n', '    }\n', '\n', '    function startIco() external teamOnly {\n', '        require(icoState == IcoState.RunningForOptionsHolders);\n', '        icoState = IcoState.Running;\n', '        RunIco();\n', '    }\n', '\n', '    function pauseIco() external teamOnly {\n', '        require(!isPaused);\n', '        require(icoState == IcoState.Running || icoState == IcoState.RunningForOptionsHolders || icoState == IcoState.RunningOptionsSelling);\n', '        isPaused = true;\n', '        PauseIco();\n', '    }\n', '\n', '    function resumeIco() external teamOnly {\n', '        require(isPaused);\n', '        require(icoState == IcoState.Running || icoState == IcoState.RunningForOptionsHolders || icoState == IcoState.RunningOptionsSelling);\n', '        isPaused = false;\n', '        ResumeIco();\n', '    }\n', '\n', '    function finishIco(address _fund, address _bounty) external teamOnly {\n', '        require(icoState == IcoState.Running);\n', '        icoState = IcoState.Finished;\n', '\n', '        uint mintedTokens = gvToken.totalSupply();\n', '        if (mintedTokens > 0) {\n', '            uint totalAmount = mintedTokens * 4 / 3;              // 75% of total tokens are for sale, get 100%\n', '            gvToken.mint(teamAllocator, 11 * totalAmount / 100);  // 11% for team to the time-locked wallet\n', '            gvToken.mint(_fund, totalAmount / 20);                // 5% for Genesis Vision fund\n', '            gvToken.mint(_bounty, 9 * totalAmount / 100);         // 9% for Advisers, Marketing, Bounty\n', '            gvToken.unfreeze();\n', '        }\n', '        \n', '        FinishIco();\n', '    }    \n', '\n', '    // Buy GVT without options\n', '    function buyTokens(address buyer, uint usdCents, string txHash)\n', '        external gvAgentOnly returns (uint) {\n', '        require(icoState == IcoState.Running);\n', '        require(!isPaused);\n', '        return buyTokensInternal(buyer, usdCents, txHash);\n', '    }\n', '\n', '    // Buy GVT for option holders. At first buy GVT with option execution, then buy GVT in regular way if ICO is running\n', '    function buyTokensByOptions(address buyer, uint usdCents, string txHash)\n', '        external gvAgentOnly returns (uint) {\n', '        require(!isPaused);\n', '        require(icoState == IcoState.Running || icoState == IcoState.RunningForOptionsHolders);\n', '        require(usdCents > 0);\n', '\n', '        uint executedTokens; \n', '        uint remainingCents;\n', '        // Execute options\n', '        (executedTokens, remainingCents) = optionProgram.executeOptions(buyer, usdCents, txHash);\n', '\n', '        if (executedTokens > 0) {\n', '            require(tokensSold + executedTokens <= TOKENS_FOR_SALE);\n', '            tokensSold += executedTokens;\n', '            \n', '            gvToken.mint(buyer, executedTokens);\n', '            BuyTokens(buyer, executedTokens, txHash);\n', '        }\n', '\n', '        //Buy GVT for remaining cents without options\n', '        if (icoState == IcoState.Running) {\n', '            return buyTokensInternal(buyer, remainingCents, txHash);\n', '        } else {\n', '            return remainingCents;\n', '        }\n', '    }\n', '\n', '    // Buy GVOT during the Option Program\n', '    function buyOptions(address buyer, uint usdCents, string txHash)\n', '        external gvAgentOnly {\n', '        require(!isPaused);\n', '        require(icoState == IcoState.RunningOptionsSelling);\n', '        optionProgram.buyOptions(buyer, usdCents, txHash);\n', '    }\n', '\n', '    // Internal buy GVT without options\n', '    function buyTokensInternal(address buyer, uint usdCents, string txHash)\n', '    private returns (uint) {\n', '        //ICO state is checked in external functions, which call this function        \n', '        require(usdCents > 0);\n', '        uint tokens = usdCents * 1e16;\n', '        require(tokensSold + tokens <= TOKENS_FOR_SALE);\n', '        tokensSold += tokens;\n', '            \n', '        gvToken.mint(buyer, tokens);\n', '        BuyTokens(buyer, tokens, txHash);\n', '\n', '        return 0;\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  uint256 public totalSupply;\n', '  function balanceOf(address who) constant returns (uint256);\n', '  function transfer(address to, uint256 value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances. \n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances;\n', '\n', '  /**\n', '  * @dev transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) returns (bool) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of. \n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) returns (bool);\n', '  function approve(address spender, uint256 value) returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * @dev https://github.com/ethereum/EIPs/issues/20\n', ' * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '  mapping (address => mapping (address => uint256)) allowed;\n', '\n', '\n', '  /**\n', '   * @dev Transfer tokens from one address to another\n', '   * @param _from address The address which you want to send tokens from\n', '   * @param _to address The address which you want to transfer to\n', '   * @param _value uint256 the amout of tokens to be transfered\n', '   */\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '   * @param _spender The address which will spend the funds.\n', '   * @param _value The amount of tokens to be spent.\n', '   */\n', '  function approve(address _spender, uint256 _value) returns (bool) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '   * @param _owner address The address which owns the funds.\n', '   * @param _spender address The address which will spend the funds.\n', '   * @return A uint256 specifing the amount of tokens still avaible for the spender.\n', '   */\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}\n', '\n', '\n', '// Migration Agent interface\n', 'contract MigrationAgent {\n', '    function migrateFrom(address _from, uint _value);\n', '}\n', '\n', 'contract GVToken is StandardToken {\n', '    \n', '    // Constants\n', '    string public constant name = "Genesis Vision Token";\n', '    string public constant symbol = "GVT";\n', '    uint   public constant decimals = 18;\n', '    uint   constant TOKEN_LIMIT = 44 * 1e6 * 1e18; \n', '    \n', '    address public ico;\n', '\n', '    // GVT transfers are blocked until ICO is finished.\n', '    bool public isFrozen = true;\n', '\n', '    // Token migration variables\n', '    address public migrationMaster;\n', '    address public migrationAgent;\n', '    uint public totalMigrated;\n', '\n', '    event Migrate(address indexed _from, address indexed _to, uint _value);\n', '\n', '    // Constructor\n', '    function GVToken(address _ico, address _migrationMaster) {\n', '        require(_ico != 0);\n', '        require(_migrationMaster != 0);\n', '        ico = _ico;\n', '        migrationMaster = _migrationMaster;\n', '    }\n', '\n', '    // Create tokens\n', '    function mint(address holder, uint value) {\n', '        require(msg.sender == ico);\n', '        require(value > 0);\n', '        require(totalSupply + value <= TOKEN_LIMIT);\n', '\n', '        balances[holder] += value;\n', '        totalSupply += value;\n', '        Transfer(0x0, holder, value);\n', '    }\n', '\n', '    // Allow token transfer.\n', '    function unfreeze() {\n', '        require(msg.sender == ico);\n', '        isFrozen = false;\n', '    }\n', '\n', '    // ERC20 functions\n', '    // =========================\n', '\n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        require(_to != address(0));\n', '        require(!isFrozen);\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        require(!isFrozen);\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        require(!isFrozen);\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '    // Token migration\n', '    function migrate(uint value) external {\n', '        require(migrationAgent != 0);\n', '        require(value > 0);\n', '        require(value <= balances[msg.sender]);\n', '\n', '        balances[msg.sender] -= value;\n', '        totalSupply -= value;\n', '        totalMigrated += value;\n', '        MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\n', '        Migrate(msg.sender, migrationAgent, value);\n', '    }\n', '\n', '    // Set address of migration contract\n', '    function setMigrationAgent(address _agent) external {\n', '        require(migrationAgent == 0);\n', '        require(msg.sender == migrationMaster);\n', '        migrationAgent = _agent;\n', '    }\n', '\n', '    function setMigrationMaster(address _master) external {\n', '        require(msg.sender == migrationMaster);\n', '        require(_master != 0);\n', '        migrationMaster = _master;\n', '    }\n', '}\n', '\n', 'contract GVOptionToken is StandardToken {\n', '    \n', '    address public optionProgram;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint   public constant decimals = 18;\n', '\n', '    uint TOKEN_LIMIT;\n', '\n', '    // Modifiers\n', '    modifier optionProgramOnly { require(msg.sender == optionProgram); _; }\n', '\n', '    // Constructor\n', '    function GVOptionToken(\n', '        address _optionProgram,\n', '        string _name,\n', '        string _symbol,\n', '        uint _TOKEN_LIMIT\n', '    ) {\n', '        require(_optionProgram != 0);        \n', '        optionProgram = _optionProgram;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        TOKEN_LIMIT = _TOKEN_LIMIT;\n', '    }\n', '\n', '    // Create tokens\n', '    function buyOptions(address buyer, uint value) optionProgramOnly {\n', '        require(value > 0);\n', '        require(totalSupply + value <= TOKEN_LIMIT);\n', '\n', '        balances[buyer] += value;\n', '        totalSupply += value;\n', '        Transfer(0x0, buyer, value);\n', '    }\n', '    \n', '    function remainingTokensCount() returns(uint) {\n', '        return TOKEN_LIMIT - totalSupply;\n', '    }\n', '    \n', '    // Burn option tokens after execution during ICO\n', '    function executeOption(address addr, uint optionsCount) \n', '        optionProgramOnly\n', '        returns (uint) {\n', '        if (balances[addr] < optionsCount) {\n', '            optionsCount = balances[addr];\n', '        }\n', '        if (optionsCount == 0) {\n', '            return 0;\n', '        }\n', '\n', '        balances[addr] -= optionsCount;\n', '        totalSupply -= optionsCount;\n', '\n', '        return optionsCount;\n', '    }\n', '}\n', '\n', 'contract GVOptionProgram {\n', '\n', '    // Constants\n', '    uint constant option30perCent = 26 * 1e16; // GVOT30 tokens per usd cent during option purchase \n', '    uint constant option20perCent = 24 * 1e16; // GVOT20 tokens per usd cent during option purchase\n', '    uint constant option10perCent = 22 * 1e16; // GVOT10 tokens per usd cent during option purchase\n', '    uint constant token30perCent  = 13684210526315800;  // GVT tokens per usd cent during execution of GVOT30\n', '    uint constant token20perCent  = 12631578947368500;  // GVT tokens per usd cent during execution of GVOT20\n', '    uint constant token10perCent  = 11578947368421100;  // GVT tokens per usd cent during execution of GVOT10\n', '\n', '    string public constant option30name = "30% GVOT";\n', '    string public constant option20name = "20% GVOT";\n', '    string public constant option10name = "10% GVOT";\n', '\n', '    string public constant option30symbol = "GVOT30";\n', '    string public constant option20symbol = "GVOT20";\n', '    string public constant option10symbol = "GVOT10";\n', '\n', '    uint constant option30_TOKEN_LIMIT = 26 * 1e5 * 1e18;\n', '    uint constant option20_TOKEN_LIMIT = 36 * 1e5 * 1e18;\n', '    uint constant option10_TOKEN_LIMIT = 55 * 1e5 * 1e18;\n', '\n', '    // Events\n', '    event BuyOptions(address buyer, uint amount, string tx, uint8 optionType);\n', '    event ExecuteOptions(address buyer, uint amount, string tx, uint8 optionType);\n', '\n', '    // State variables\n', '    address public gvAgent; // payments bot account\n', '    address public team;    // team account\n', '    address public ico;     \n', '\n', '    GVOptionToken public gvOptionToken30;\n', '    GVOptionToken public gvOptionToken20;\n', '    GVOptionToken public gvOptionToken10;\n', '\n', '    // Modifiers\n', '    modifier icoOnly { require(msg.sender == ico); _; }\n', '    \n', '    // Constructor\n', '    function GVOptionProgram(address _ico, address _gvAgent, address _team) {\n', '        gvOptionToken30 = new GVOptionToken(this, option30name, option30symbol, option30_TOKEN_LIMIT);\n', '        gvOptionToken20 = new GVOptionToken(this, option20name, option20symbol, option20_TOKEN_LIMIT);\n', '        gvOptionToken10 = new GVOptionToken(this, option10name, option10symbol, option10_TOKEN_LIMIT);\n', '        gvAgent = _gvAgent;\n', '        team = _team;\n', '        ico = _ico;\n', '    }\n', '\n', '    // Get remaining tokens for all types of option tokens\n', '    function getBalance() public returns (uint, uint, uint) {\n', '        return (gvOptionToken30.remainingTokensCount(), gvOptionToken20.remainingTokensCount(), gvOptionToken10.remainingTokensCount());\n', '    }\n', '\n', '    // Execute options during the ICO token purchase. Priority: GVOT30 -> GVOT20 -> GVOT10\n', '    function executeOptions(address buyer, uint usdCents, string txHash) icoOnly\n', '        returns (uint executedTokens, uint remainingCents) {\n', '        require(usdCents > 0);\n', '\n', '        (executedTokens, remainingCents) = executeIfAvailable(buyer, usdCents, txHash, gvOptionToken30, 0, token30perCent);\n', '        if (remainingCents == 0) {\n', '            return (executedTokens, 0);\n', '        }\n', '\n', '        uint executed20;\n', '        (executed20, remainingCents) = executeIfAvailable(buyer, remainingCents, txHash, gvOptionToken20, 1, token20perCent);\n', '        if (remainingCents == 0) {\n', '            return (executedTokens + executed20, 0);\n', '        }\n', '\n', '        uint executed10;\n', '        (executed10, remainingCents) = executeIfAvailable(buyer, remainingCents, txHash, gvOptionToken10, 2, token10perCent);\n', '        \n', '        return (executedTokens + executed20 + executed10, remainingCents);\n', '    }\n', '\n', '    // Buy option tokens. Priority: GVOT30 -> GVOT20 -> GVOT10\n', '    function buyOptions(address buyer, uint usdCents, string txHash) icoOnly {\n', '        require(usdCents > 0);\n', '\n', '        var remainUsdCents = buyIfAvailable(buyer, usdCents, txHash, gvOptionToken30, 0, option30perCent);\n', '        if (remainUsdCents == 0) {\n', '            return;\n', '        }\n', '\n', '        remainUsdCents = buyIfAvailable(buyer, remainUsdCents, txHash, gvOptionToken20, 1, option20perCent);\n', '        if (remainUsdCents == 0) {\n', '            return;\n', '        }\n', '\n', '        remainUsdCents = buyIfAvailable(buyer, remainUsdCents, txHash, gvOptionToken10, 2, option10perCent);\n', '    }   \n', '\n', '    // Private functions\n', '    \n', '    function executeIfAvailable(address buyer, uint usdCents, string txHash,\n', '        GVOptionToken optionToken, uint8 optionType, uint optionPerCent)\n', '        private returns (uint executedTokens, uint remainingCents) {\n', '        \n', '        var optionsAmount = usdCents * optionPerCent;\n', '        executedTokens = optionToken.executeOption(buyer, optionsAmount);\n', '        remainingCents = usdCents - (executedTokens / optionPerCent);\n', '        if (executedTokens > 0) {\n', '            ExecuteOptions(buyer, executedTokens, txHash, optionType);\n', '        }\n', '        return (executedTokens, remainingCents);\n', '    }\n', '\n', '    function buyIfAvailable(address buyer, uint usdCents, string txHash,\n', '        GVOptionToken optionToken, uint8 optionType, uint optionsPerCent)\n', '        private returns (uint) {\n', '        \n', '        var availableTokens = optionToken.remainingTokensCount(); \n', '        if (availableTokens > 0) {\n', '            var tokens = usdCents * optionsPerCent;\n', '            if(availableTokens >= tokens) {\n', '                optionToken.buyOptions(buyer, tokens);\n', '                BuyOptions(buyer, tokens, txHash, optionType);\n', '                return 0;\n', '            }\n', '            else {\n', '                optionToken.buyOptions(buyer, availableTokens);\n', '                BuyOptions(buyer, availableTokens, txHash, optionType);\n', '                return usdCents - availableTokens / optionsPerCent;\n', '            }\n', '        }\n', '        return usdCents;\n', '    }\n', '}\n', '\n', 'contract Initable {\n', '    function init(address token);\n', '}\n', '\n', '// Crowdfunding code for Genesis Vision Project\n', 'contract ICO {\n', '\n', '    // Constants\n', '    uint public constant TOKENS_FOR_SALE = 33 * 1e6 * 1e18;\n', '\n', '    // Events\n', '    event StartOptionsSelling();\n', '    event StartICOForOptionsHolders();\n', '    event RunIco();\n', '    event PauseIco();\n', '    event ResumeIco();\n', '    event FinishIco();\n', '\n', '    event BuyTokens(address buyer, uint amount, string txHash);\n', '\n', '    address public gvAgent; // payments bot account\n', '    address public team;    // team account\n', '\n', '    GVToken public gvToken;\n', '    GVOptionProgram public optionProgram;\n', '    Initable public teamAllocator;\n', '    address public migrationMaster;\n', '\n', '    // Modifiers\n', '    modifier teamOnly { require(msg.sender == team); _; }\n', '    modifier gvAgentOnly { require(msg.sender == gvAgent); _; }\n', '\n', '    // Current total token supply\n', '    uint tokensSold = 0;\n', '\n', '    bool public isPaused = false;\n', '    enum IcoState { Created, RunningOptionsSelling, RunningForOptionsHolders, Running, Finished }\n', '    IcoState public icoState = IcoState.Created;\n', '\n', '    // Constructor\n', '    function ICO(address _team, address _gvAgent, address _migrationMaster, address _teamAllocator) {\n', '        gvAgent = _gvAgent;\n', '        team = _team;\n', '        teamAllocator = Initable(_teamAllocator);\n', '        migrationMaster = _migrationMaster;\n', '        gvToken = new GVToken(this, migrationMaster);\n', '    }\n', '\n', '    // Initialize Option Program contract\n', '    function initOptionProgram() external teamOnly {\n', '        if (optionProgram == address(0)) {\n', '            optionProgram = new GVOptionProgram(this, gvAgent, team);\n', '        }\n', '    }\n', '\n', '    // ICO and Option Program state management\n', '    function startOptionsSelling() external teamOnly {\n', '        require(icoState == IcoState.Created);\n', '        // Check if Option Program is initialized\n', '        require(optionProgram != address(0));    \n', '        icoState = IcoState.RunningOptionsSelling;\n', '        StartOptionsSelling();\n', '    }\n', '\n', '    // Finish options selling and start ICO for the option holders\n', '    function startIcoForOptionsHolders() external teamOnly {\n', '        require(icoState == IcoState.RunningOptionsSelling);       \n', '        icoState = IcoState.RunningForOptionsHolders;\n', '        StartICOForOptionsHolders();\n', '    }\n', '\n', '    function startIco() external teamOnly {\n', '        require(icoState == IcoState.RunningForOptionsHolders);\n', '        icoState = IcoState.Running;\n', '        RunIco();\n', '    }\n', '\n', '    function pauseIco() external teamOnly {\n', '        require(!isPaused);\n', '        require(icoState == IcoState.Running || icoState == IcoState.RunningForOptionsHolders || icoState == IcoState.RunningOptionsSelling);\n', '        isPaused = true;\n', '        PauseIco();\n', '    }\n', '\n', '    function resumeIco() external teamOnly {\n', '        require(isPaused);\n', '        require(icoState == IcoState.Running || icoState == IcoState.RunningForOptionsHolders || icoState == IcoState.RunningOptionsSelling);\n', '        isPaused = false;\n', '        ResumeIco();\n', '    }\n', '\n', '    function finishIco(address _fund, address _bounty) external teamOnly {\n', '        require(icoState == IcoState.Running);\n', '        icoState = IcoState.Finished;\n', '\n', '        uint mintedTokens = gvToken.totalSupply();\n', '        if (mintedTokens > 0) {\n', '            uint totalAmount = mintedTokens * 4 / 3;              // 75% of total tokens are for sale, get 100%\n', '            gvToken.mint(teamAllocator, 11 * totalAmount / 100);  // 11% for team to the time-locked wallet\n', '            gvToken.mint(_fund, totalAmount / 20);                // 5% for Genesis Vision fund\n', '            gvToken.mint(_bounty, 9 * totalAmount / 100);         // 9% for Advisers, Marketing, Bounty\n', '            gvToken.unfreeze();\n', '        }\n', '        \n', '        FinishIco();\n', '    }    \n', '\n', '    // Buy GVT without options\n', '    function buyTokens(address buyer, uint usdCents, string txHash)\n', '        external gvAgentOnly returns (uint) {\n', '        require(icoState == IcoState.Running);\n', '        require(!isPaused);\n', '        return buyTokensInternal(buyer, usdCents, txHash);\n', '    }\n', '\n', '    // Buy GVT for option holders. At first buy GVT with option execution, then buy GVT in regular way if ICO is running\n', '    function buyTokensByOptions(address buyer, uint usdCents, string txHash)\n', '        external gvAgentOnly returns (uint) {\n', '        require(!isPaused);\n', '        require(icoState == IcoState.Running || icoState == IcoState.RunningForOptionsHolders);\n', '        require(usdCents > 0);\n', '\n', '        uint executedTokens; \n', '        uint remainingCents;\n', '        // Execute options\n', '        (executedTokens, remainingCents) = optionProgram.executeOptions(buyer, usdCents, txHash);\n', '\n', '        if (executedTokens > 0) {\n', '            require(tokensSold + executedTokens <= TOKENS_FOR_SALE);\n', '            tokensSold += executedTokens;\n', '            \n', '            gvToken.mint(buyer, executedTokens);\n', '            BuyTokens(buyer, executedTokens, txHash);\n', '        }\n', '\n', '        //Buy GVT for remaining cents without options\n', '        if (icoState == IcoState.Running) {\n', '            return buyTokensInternal(buyer, remainingCents, txHash);\n', '        } else {\n', '            return remainingCents;\n', '        }\n', '    }\n', '\n', '    // Buy GVOT during the Option Program\n', '    function buyOptions(address buyer, uint usdCents, string txHash)\n', '        external gvAgentOnly {\n', '        require(!isPaused);\n', '        require(icoState == IcoState.RunningOptionsSelling);\n', '        optionProgram.buyOptions(buyer, usdCents, txHash);\n', '    }\n', '\n', '    // Internal buy GVT without options\n', '    function buyTokensInternal(address buyer, uint usdCents, string txHash)\n', '    private returns (uint) {\n', '        //ICO state is checked in external functions, which call this function        \n', '        require(usdCents > 0);\n', '        uint tokens = usdCents * 1e16;\n', '        require(tokensSold + tokens <= TOKENS_FOR_SALE);\n', '        tokensSold += tokens;\n', '            \n', '        gvToken.mint(buyer, tokens);\n', '        BuyTokens(buyer, tokens, txHash);\n', '\n', '        return 0;\n', '    }\n', '}']
