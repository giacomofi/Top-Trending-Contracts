['/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/* The authentication manager details user accounts that have access to certain priviledges and keeps a permanent ledger of who has and has had these rights. */\n', 'contract AuthenticationManager {\n', '    /* Map addresses to admins */\n', '    mapping (address => bool) adminAddresses;\n', '\n', '    /* Map addresses to account readers */\n', '    mapping (address => bool) accountReaderAddresses;\n', '\n', '    /* Details of all admins that have ever existed */\n', '    address[] adminAudit;\n', '\n', '    /* Details of all account readers that have ever existed */\n', '    address[] accountReaderAudit;\n', '\n', '    /* Fired whenever an admin is added to the contract. */\n', '    event AdminAdded(address addedBy, address admin);\n', '\n', '    /* Fired whenever an admin is removed from the contract. */\n', '    event AdminRemoved(address removedBy, address admin);\n', '\n', '    /* Fired whenever an account-reader contract is added. */\n', '    event AccountReaderAdded(address addedBy, address account);\n', '\n', '    /* Fired whenever an account-reader contract is removed. */\n', '    event AccountReaderRemoved(address removedBy, address account);\n', '\n', '    /* When this contract is first setup we use the creator as the first admin */    \n', '    function AuthenticationManager() {\n', '        /* Set the first admin to be the person creating the contract */\n', '        adminAddresses[msg.sender] = true;\n', '        AdminAdded(0, msg.sender);\n', '        adminAudit.length++;\n', '        adminAudit[adminAudit.length - 1] = msg.sender;\n', '    }\n', '\n', '    /* Gets the contract version for validation */\n', '    function contractVersion() constant returns(uint256) {\n', '        // Admin contract identifies as 100YYYYMMDDHHMM\n', '        return 100201707171503;\n', '    }\n', '\n', '    /* Gets whether or not the specified address is currently an admin */\n', '    function isCurrentAdmin(address _address) constant returns (bool) {\n', '        return adminAddresses[_address];\n', '    }\n', '\n', '    /* Gets whether or not the specified address has ever been an admin */\n', '    function isCurrentOrPastAdmin(address _address) constant returns (bool) {\n', '        for (uint256 i = 0; i < adminAudit.length; i++)\n', '            if (adminAudit[i] == _address)\n', '                return true;\n', '        return false;\n', '    }\n', '\n', '    /* Gets whether or not the specified address is currently an account reader */\n', '    function isCurrentAccountReader(address _address) constant returns (bool) {\n', '        return accountReaderAddresses[_address];\n', '    }\n', '\n', '    /* Gets whether or not the specified address has ever been an admin */\n', '    function isCurrentOrPastAccountReader(address _address) constant returns (bool) {\n', '        for (uint256 i = 0; i < accountReaderAudit.length; i++)\n', '            if (accountReaderAudit[i] == _address)\n', '                return true;\n', '        return false;\n', '    }\n', '\n', '    /* Adds a user to our list of admins */\n', '    function addAdmin(address _address) {\n', '        /* Ensure we&#39;re an admin */\n', '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        // Fail if this account is already admin\n', '        if (adminAddresses[_address])\n', '            throw;\n', '        \n', '        // Add the user\n', '        adminAddresses[_address] = true;\n', '        AdminAdded(msg.sender, _address);\n', '        adminAudit.length++;\n', '        adminAudit[adminAudit.length - 1] = _address;\n', '    }\n', '\n', '    /* Removes a user from our list of admins but keeps them in the history audit */\n', '    function removeAdmin(address _address) {\n', '        /* Ensure we&#39;re an admin */\n', '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        /* Don&#39;t allow removal of self */\n', '        if (_address == msg.sender)\n', '            throw;\n', '\n', '        // Fail if this account is already non-admin\n', '        if (!adminAddresses[_address])\n', '            throw;\n', '\n', '        /* Remove this admin user */\n', '        adminAddresses[_address] = false;\n', '        AdminRemoved(msg.sender, _address);\n', '    }\n', '\n', '    /* Adds a user/contract to our list of account readers */\n', '    function addAccountReader(address _address) {\n', '        /* Ensure we&#39;re an admin */\n', '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        // Fail if this account is already in the list\n', '        if (accountReaderAddresses[_address])\n', '            throw;\n', '        \n', '        // Add the user\n', '        accountReaderAddresses[_address] = true;\n', '        AccountReaderAdded(msg.sender, _address);\n', '        accountReaderAudit.length++;\n', '        accountReaderAudit[adminAudit.length - 1] = _address;\n', '    }\n', '\n', '    /* Removes a user/contracts from our list of account readers but keeps them in the history audit */\n', '    function removeAccountReader(address _address) {\n', '        /* Ensure we&#39;re an admin */\n', '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        // Fail if this account is already not in the list\n', '        if (!accountReaderAddresses[_address])\n', '            throw;\n', '\n', '        /* Remove this admin user */\n', '        accountReaderAddresses[_address] = false;\n', '        AccountReaderRemoved(msg.sender, _address);\n', '    }\n', '}\n', 'contract VotingBase {\n', '    using SafeMath for uint256;\n', '\n', '    /* Map all our our balances for issued tokens */\n', '    mapping (address => uint256) public voteCount;\n', '\n', '    /* List of all token holders */\n', '    address[] public voterAddresses;\n', '\n', '    /* Defines the admin contract we interface with for credentails. */\n', '    AuthenticationManager internal authenticationManager;\n', '\n', '    /* Unix epoch voting starts at */\n', '    uint256 public voteStartTime;\n', '\n', '    /* Unix epoch voting ends at */\n', '    uint256 public voteEndTime;\n', '\n', '    /* This modifier allows a method to only be called by current admins */\n', '    modifier adminOnly {\n', '        if (!authenticationManager.isCurrentAdmin(msg.sender)) throw;\n', '        _;\n', '    }\n', '\n', '    function setVoterCount(uint256 _count) adminOnly {\n', '        // Forbid after voting has started\n', '        if (now >= voteStartTime)\n', '            throw;\n', '\n', '        /* Clear existing voter count */\n', '        for (uint256 i = 0; i < voterAddresses.length; i++) {\n', '            address voter = voterAddresses[i];\n', '            voteCount[voter] = 0;\n', '        }\n', '\n', '        /* Set the count accordingly */\n', '        voterAddresses.length = _count;\n', '    }\n', '\n', '    function setVoter(uint256 _position, address _voter, uint256 _voteCount) adminOnly {\n', '        // Forbid after voting has started\n', '        if (now >= voteStartTime)\n', '            throw;\n', '\n', '        if (_position >= voterAddresses.length)\n', '            throw;\n', '            \n', '        voterAddresses[_position] = _voter;\n', '        voteCount[_voter] = _voteCount;\n', '    }\n', '}\n', '\n', 'contract VoteSvp002 is VotingBase {\n', '    using SafeMath for uint256;\n', '\n', '    /* Votes for SVP002-01.  0 = not votes, 1 = Yes, 2 = No */\n', '     mapping (address => uint256) vote01;\n', '     uint256 public vote01YesCount;\n', '     uint256 public vote01NoCount;\n', '\n', '    /* Votes for SVP002-02.  0 = not votes, 1 = Yes, 2 = No */\n', '     mapping (address => uint256) vote02;\n', '     uint256 public vote02YesCount;\n', '     uint256 public vote02NoCount;\n', '\n', '    /* Votes for SVP003-02.  0 = not votes, 1 = Yes, 2 = No */\n', '     mapping (address => uint256) vote03;\n', '     uint256 public vote03YesCount;\n', '     uint256 public vote03NoCount;\n', '\n', '    /* Create our contract with references to other contracts as required. */\n', '    function VoteSvp002(address _authenticationManagerAddress, uint256 _voteStartTime, uint256 _voteEndTime) {\n', '        /* Setup access to our other contracts and validate their versions */\n', '        authenticationManager = AuthenticationManager(_authenticationManagerAddress);\n', '        if (authenticationManager.contractVersion() != 100201707171503)\n', '            throw;\n', '\n', '        /* Store start/end times */\n', '        if (_voteStartTime >= _voteEndTime)\n', '            throw;\n', '        voteStartTime = _voteStartTime;\n', '        voteEndTime = _voteEndTime;\n', '    }\n', '\n', '     function voteSvp01(bool vote) {\n', '        // Forbid outside of voting period\n', '        if (now < voteStartTime || now > voteEndTime)\n', '            throw;\n', '\n', '         /* Ensure they have voting rights first */\n', '         uint256 voteWeight = voteCount[msg.sender];\n', '         if (voteWeight == 0)\n', '            throw;\n', '        \n', '        /* Set their vote */\n', '        uint256 existingVote = vote01[msg.sender];\n', '        uint256 newVote = vote ? 1 : 2;\n', '        if (newVote == existingVote)\n', '            /* No change so just return */\n', '            return;\n', '        vote01[msg.sender] = newVote;\n', '\n', '        /* If they had voted previous first decrement previous vote count */\n', '        if (existingVote == 1)\n', '            vote01YesCount -= voteWeight;\n', '        else if (existingVote == 2)\n', '            vote01NoCount -= voteWeight;\n', '        if (vote)\n', '            vote01YesCount += voteWeight;\n', '        else\n', '            vote01NoCount += voteWeight;\n', '     }\n', '\n', '     function voteSvp02(bool vote) {\n', '        // Forbid outside of voting period\n', '        if (now < voteStartTime || now > voteEndTime)\n', '            throw;\n', '\n', '         /* Ensure they have voting rights first */\n', '         uint256 voteWeight = voteCount[msg.sender];\n', '         if (voteWeight == 0)\n', '            throw;\n', '        \n', '        /* Set their vote */\n', '        uint256 existingVote = vote02[msg.sender];\n', '        uint256 newVote = vote ? 1 : 2;\n', '        if (newVote == existingVote)\n', '            /* No change so just return */\n', '            return;\n', '        vote02[msg.sender] = newVote;\n', '\n', '        /* If they had voted previous first decrement previous vote count */\n', '        if (existingVote == 1)\n', '            vote02YesCount -= voteWeight;\n', '        else if (existingVote == 2)\n', '            vote02NoCount -= voteWeight;\n', '        if (vote)\n', '            vote02YesCount += voteWeight;\n', '        else\n', '            vote02NoCount += voteWeight;\n', '     }\n', '\n', '     function voteSvp03(bool vote) {\n', '        // Forbid outside of voting period\n', '        if (now < voteStartTime || now > voteEndTime)\n', '            throw;\n', '\n', '         /* Ensure they have voting rights first */\n', '         uint256 voteWeight = voteCount[msg.sender];\n', '         if (voteWeight == 0)\n', '            throw;\n', '        \n', '        /* Set their vote */\n', '        uint256 existingVote = vote03[msg.sender];\n', '        uint256 newVote = vote ? 1 : 2;\n', '        if (newVote == existingVote)\n', '            /* No change so just return */\n', '            return;\n', '        vote03[msg.sender] = newVote;\n', '\n', '        /* If they had voted previous first decrement previous vote count */\n', '        if (existingVote == 1)\n', '            vote03YesCount -= voteWeight;\n', '        else if (existingVote == 2)\n', '            vote03NoCount -= voteWeight;\n', '        if (vote)\n', '            vote03YesCount += voteWeight;\n', '        else\n', '            vote03NoCount += voteWeight;\n', '     }\n', '}']
['/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '/* The authentication manager details user accounts that have access to certain priviledges and keeps a permanent ledger of who has and has had these rights. */\n', 'contract AuthenticationManager {\n', '    /* Map addresses to admins */\n', '    mapping (address => bool) adminAddresses;\n', '\n', '    /* Map addresses to account readers */\n', '    mapping (address => bool) accountReaderAddresses;\n', '\n', '    /* Details of all admins that have ever existed */\n', '    address[] adminAudit;\n', '\n', '    /* Details of all account readers that have ever existed */\n', '    address[] accountReaderAudit;\n', '\n', '    /* Fired whenever an admin is added to the contract. */\n', '    event AdminAdded(address addedBy, address admin);\n', '\n', '    /* Fired whenever an admin is removed from the contract. */\n', '    event AdminRemoved(address removedBy, address admin);\n', '\n', '    /* Fired whenever an account-reader contract is added. */\n', '    event AccountReaderAdded(address addedBy, address account);\n', '\n', '    /* Fired whenever an account-reader contract is removed. */\n', '    event AccountReaderRemoved(address removedBy, address account);\n', '\n', '    /* When this contract is first setup we use the creator as the first admin */    \n', '    function AuthenticationManager() {\n', '        /* Set the first admin to be the person creating the contract */\n', '        adminAddresses[msg.sender] = true;\n', '        AdminAdded(0, msg.sender);\n', '        adminAudit.length++;\n', '        adminAudit[adminAudit.length - 1] = msg.sender;\n', '    }\n', '\n', '    /* Gets the contract version for validation */\n', '    function contractVersion() constant returns(uint256) {\n', '        // Admin contract identifies as 100YYYYMMDDHHMM\n', '        return 100201707171503;\n', '    }\n', '\n', '    /* Gets whether or not the specified address is currently an admin */\n', '    function isCurrentAdmin(address _address) constant returns (bool) {\n', '        return adminAddresses[_address];\n', '    }\n', '\n', '    /* Gets whether or not the specified address has ever been an admin */\n', '    function isCurrentOrPastAdmin(address _address) constant returns (bool) {\n', '        for (uint256 i = 0; i < adminAudit.length; i++)\n', '            if (adminAudit[i] == _address)\n', '                return true;\n', '        return false;\n', '    }\n', '\n', '    /* Gets whether or not the specified address is currently an account reader */\n', '    function isCurrentAccountReader(address _address) constant returns (bool) {\n', '        return accountReaderAddresses[_address];\n', '    }\n', '\n', '    /* Gets whether or not the specified address has ever been an admin */\n', '    function isCurrentOrPastAccountReader(address _address) constant returns (bool) {\n', '        for (uint256 i = 0; i < accountReaderAudit.length; i++)\n', '            if (accountReaderAudit[i] == _address)\n', '                return true;\n', '        return false;\n', '    }\n', '\n', '    /* Adds a user to our list of admins */\n', '    function addAdmin(address _address) {\n', "        /* Ensure we're an admin */\n", '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        // Fail if this account is already admin\n', '        if (adminAddresses[_address])\n', '            throw;\n', '        \n', '        // Add the user\n', '        adminAddresses[_address] = true;\n', '        AdminAdded(msg.sender, _address);\n', '        adminAudit.length++;\n', '        adminAudit[adminAudit.length - 1] = _address;\n', '    }\n', '\n', '    /* Removes a user from our list of admins but keeps them in the history audit */\n', '    function removeAdmin(address _address) {\n', "        /* Ensure we're an admin */\n", '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', "        /* Don't allow removal of self */\n", '        if (_address == msg.sender)\n', '            throw;\n', '\n', '        // Fail if this account is already non-admin\n', '        if (!adminAddresses[_address])\n', '            throw;\n', '\n', '        /* Remove this admin user */\n', '        adminAddresses[_address] = false;\n', '        AdminRemoved(msg.sender, _address);\n', '    }\n', '\n', '    /* Adds a user/contract to our list of account readers */\n', '    function addAccountReader(address _address) {\n', "        /* Ensure we're an admin */\n", '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        // Fail if this account is already in the list\n', '        if (accountReaderAddresses[_address])\n', '            throw;\n', '        \n', '        // Add the user\n', '        accountReaderAddresses[_address] = true;\n', '        AccountReaderAdded(msg.sender, _address);\n', '        accountReaderAudit.length++;\n', '        accountReaderAudit[adminAudit.length - 1] = _address;\n', '    }\n', '\n', '    /* Removes a user/contracts from our list of account readers but keeps them in the history audit */\n', '    function removeAccountReader(address _address) {\n', "        /* Ensure we're an admin */\n", '        if (!isCurrentAdmin(msg.sender))\n', '            throw;\n', '\n', '        // Fail if this account is already not in the list\n', '        if (!accountReaderAddresses[_address])\n', '            throw;\n', '\n', '        /* Remove this admin user */\n', '        accountReaderAddresses[_address] = false;\n', '        AccountReaderRemoved(msg.sender, _address);\n', '    }\n', '}\n', 'contract VotingBase {\n', '    using SafeMath for uint256;\n', '\n', '    /* Map all our our balances for issued tokens */\n', '    mapping (address => uint256) public voteCount;\n', '\n', '    /* List of all token holders */\n', '    address[] public voterAddresses;\n', '\n', '    /* Defines the admin contract we interface with for credentails. */\n', '    AuthenticationManager internal authenticationManager;\n', '\n', '    /* Unix epoch voting starts at */\n', '    uint256 public voteStartTime;\n', '\n', '    /* Unix epoch voting ends at */\n', '    uint256 public voteEndTime;\n', '\n', '    /* This modifier allows a method to only be called by current admins */\n', '    modifier adminOnly {\n', '        if (!authenticationManager.isCurrentAdmin(msg.sender)) throw;\n', '        _;\n', '    }\n', '\n', '    function setVoterCount(uint256 _count) adminOnly {\n', '        // Forbid after voting has started\n', '        if (now >= voteStartTime)\n', '            throw;\n', '\n', '        /* Clear existing voter count */\n', '        for (uint256 i = 0; i < voterAddresses.length; i++) {\n', '            address voter = voterAddresses[i];\n', '            voteCount[voter] = 0;\n', '        }\n', '\n', '        /* Set the count accordingly */\n', '        voterAddresses.length = _count;\n', '    }\n', '\n', '    function setVoter(uint256 _position, address _voter, uint256 _voteCount) adminOnly {\n', '        // Forbid after voting has started\n', '        if (now >= voteStartTime)\n', '            throw;\n', '\n', '        if (_position >= voterAddresses.length)\n', '            throw;\n', '            \n', '        voterAddresses[_position] = _voter;\n', '        voteCount[_voter] = _voteCount;\n', '    }\n', '}\n', '\n', 'contract VoteSvp002 is VotingBase {\n', '    using SafeMath for uint256;\n', '\n', '    /* Votes for SVP002-01.  0 = not votes, 1 = Yes, 2 = No */\n', '     mapping (address => uint256) vote01;\n', '     uint256 public vote01YesCount;\n', '     uint256 public vote01NoCount;\n', '\n', '    /* Votes for SVP002-02.  0 = not votes, 1 = Yes, 2 = No */\n', '     mapping (address => uint256) vote02;\n', '     uint256 public vote02YesCount;\n', '     uint256 public vote02NoCount;\n', '\n', '    /* Votes for SVP003-02.  0 = not votes, 1 = Yes, 2 = No */\n', '     mapping (address => uint256) vote03;\n', '     uint256 public vote03YesCount;\n', '     uint256 public vote03NoCount;\n', '\n', '    /* Create our contract with references to other contracts as required. */\n', '    function VoteSvp002(address _authenticationManagerAddress, uint256 _voteStartTime, uint256 _voteEndTime) {\n', '        /* Setup access to our other contracts and validate their versions */\n', '        authenticationManager = AuthenticationManager(_authenticationManagerAddress);\n', '        if (authenticationManager.contractVersion() != 100201707171503)\n', '            throw;\n', '\n', '        /* Store start/end times */\n', '        if (_voteStartTime >= _voteEndTime)\n', '            throw;\n', '        voteStartTime = _voteStartTime;\n', '        voteEndTime = _voteEndTime;\n', '    }\n', '\n', '     function voteSvp01(bool vote) {\n', '        // Forbid outside of voting period\n', '        if (now < voteStartTime || now > voteEndTime)\n', '            throw;\n', '\n', '         /* Ensure they have voting rights first */\n', '         uint256 voteWeight = voteCount[msg.sender];\n', '         if (voteWeight == 0)\n', '            throw;\n', '        \n', '        /* Set their vote */\n', '        uint256 existingVote = vote01[msg.sender];\n', '        uint256 newVote = vote ? 1 : 2;\n', '        if (newVote == existingVote)\n', '            /* No change so just return */\n', '            return;\n', '        vote01[msg.sender] = newVote;\n', '\n', '        /* If they had voted previous first decrement previous vote count */\n', '        if (existingVote == 1)\n', '            vote01YesCount -= voteWeight;\n', '        else if (existingVote == 2)\n', '            vote01NoCount -= voteWeight;\n', '        if (vote)\n', '            vote01YesCount += voteWeight;\n', '        else\n', '            vote01NoCount += voteWeight;\n', '     }\n', '\n', '     function voteSvp02(bool vote) {\n', '        // Forbid outside of voting period\n', '        if (now < voteStartTime || now > voteEndTime)\n', '            throw;\n', '\n', '         /* Ensure they have voting rights first */\n', '         uint256 voteWeight = voteCount[msg.sender];\n', '         if (voteWeight == 0)\n', '            throw;\n', '        \n', '        /* Set their vote */\n', '        uint256 existingVote = vote02[msg.sender];\n', '        uint256 newVote = vote ? 1 : 2;\n', '        if (newVote == existingVote)\n', '            /* No change so just return */\n', '            return;\n', '        vote02[msg.sender] = newVote;\n', '\n', '        /* If they had voted previous first decrement previous vote count */\n', '        if (existingVote == 1)\n', '            vote02YesCount -= voteWeight;\n', '        else if (existingVote == 2)\n', '            vote02NoCount -= voteWeight;\n', '        if (vote)\n', '            vote02YesCount += voteWeight;\n', '        else\n', '            vote02NoCount += voteWeight;\n', '     }\n', '\n', '     function voteSvp03(bool vote) {\n', '        // Forbid outside of voting period\n', '        if (now < voteStartTime || now > voteEndTime)\n', '            throw;\n', '\n', '         /* Ensure they have voting rights first */\n', '         uint256 voteWeight = voteCount[msg.sender];\n', '         if (voteWeight == 0)\n', '            throw;\n', '        \n', '        /* Set their vote */\n', '        uint256 existingVote = vote03[msg.sender];\n', '        uint256 newVote = vote ? 1 : 2;\n', '        if (newVote == existingVote)\n', '            /* No change so just return */\n', '            return;\n', '        vote03[msg.sender] = newVote;\n', '\n', '        /* If they had voted previous first decrement previous vote count */\n', '        if (existingVote == 1)\n', '            vote03YesCount -= voteWeight;\n', '        else if (existingVote == 2)\n', '            vote03NoCount -= voteWeight;\n', '        if (vote)\n', '            vote03YesCount += voteWeight;\n', '        else\n', '            vote03NoCount += voteWeight;\n', '     }\n', '}']
