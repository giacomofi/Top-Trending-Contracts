['pragma solidity 0.4.6;\n', '\n', 'contract DXF_Tokens{\n', '\n', '  //States\n', '  bool public dxfOpen=true;\n', '  bool public refundState;\n', '  bool public transferLocked=true;\n', '\n', '  uint256 public startingDateFunding;\n', '  uint256 public closingDateFunding;\n', '  //Maximum number of participants\n', '  uint256 public constant maxNumberMembers=5000;\n', '  //Token caps, this includes the 12500 tokens that will be attributed to former users (VIPs)\n', '  uint256 public totalTokens;\n', '  uint256 public constant tokensCreationMin = 25000 ether;\n', '  uint256 public constant tokensCreationCap = 75000 ether;\n', '  //Cap of 12500 ethers worth of tokens to be distributed \n', '  //to previous DO members in exchange for their rouleth accounts\n', '  uint256 public remainingTokensVIPs=12500 ether;\n', '  uint256 public constant tokensCreationVIPsCap = 12500 ether; \n', '\n', '\n', '  mapping (address => uint256) balances;\n', '  mapping (address => bool) vips;\n', '  mapping (address => uint256) indexMembers;\n', '  \n', '  struct Member\n', '  {\n', '    address member;\n', '    uint timestamp;\n', '    uint initial_value;\n', '  }\n', '  Member[] public members;\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Refund(address indexed _to, uint256 _value);\n', '  event failingRefund(address indexed _to, uint256 _value);\n', '  event VipMigration(address indexed _vip, uint256 _value);\n', '  event newMember(address indexed _from);\n', '\n', '  // Token parameters\n', '  string public constant name = "DXF - Decentralized eXperience Friends";\n', '  string public constant symbol = "DXF";\n', '  uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n', '\n', '  address public admin;\n', '  address public multisigDXF;\n', '\n', '  modifier onlyAdmin()\n', '  {\n', '    if (msg.sender!=admin) throw;\n', '    _;\n', '  }\n', '\n', '  function DXF_Tokens()\n', '  {\n', '    admin = msg.sender;\n', '    startingDateFunding=now;\n', '    multisigDXF=0x7a992f486fbc7C03a3f2f862Ad260f158C5c5486; //or switch to constructor param\n', '    //increment array by 1 for indexes\n', '    members.push(Member(0,0,0));\n', '  }\n', '\n', '\n', '  //empty fallback\n', '  function ()\n', '    {\n', '      throw;\n', '    }\n', '\n', '  //USER FUNCTIONS  \n', '  /// @notice Create tokens when funding is active.\n', '  /// @notice By using this function you accept the terms of DXF\n', '  /// @dev Required state: Funding Active\n', '  /// @dev State transition: -> Funding Success (only if cap reached)\n', '  function acceptTermsAndJoinDXF() payable external \n', '  {\n', '    // refuse if more than 12 months have passed\n', '    if (now>startingDateFunding+365 days) throw;\n', '    // Abort if DXF is not open.\n', '    if (!dxfOpen) throw;\n', '    // verify if the account is not a VIP account\n', '    if (vips[msg.sender]) throw;\n', '    // Do not allow creating less than 10 ether or more than the cap tokens.\n', '    if (msg.value < 10 ether) throw;\n', '    if (msg.value > (tokensCreationCap - totalTokens)) throw;\n', '    // Enforce cap of 10 000 ethers per address / individual\n', '    if (msg.value > (10000 ether - balances[msg.sender])) throw;\n', '    // Register member\n', '    if (balances[msg.sender]==0)\n', '      {\n', '        newMember(msg.sender); //event\n', '\tindexMembers[msg.sender]=members.length;\n', '\tmembers.push(Member(msg.sender,now,msg.value));\n', '      }\n', '    else\n', '      {\n', '\tmembers[indexMembers[msg.sender]].initial_value+=msg.value;\n', '      }\n', '    if (members.length>maxNumberMembers) throw;\n', '    //Send the funds to the MultiSig Wallet\n', '    if (multisigDXF==0) throw;\n', '    if (!multisigDXF.send(msg.value)) throw;\n', '    // Assign new tokens to the sender\n', '    uint numTokens = msg.value;\n', '    totalTokens += numTokens;\n', "    // Do not allow creating tokens if we don't leave enough for the VIPs\n", '    if ( (tokensCreationCap-totalTokens) < remainingTokensVIPs ) throw;\n', '    balances[msg.sender] += numTokens;\n', '    // Log token creation event\n', '    Transfer(0, msg.sender, numTokens);\n', '  }\n', '\n', '\n', '\n', '  //NOT INCLUDED IN LATEST VERSION\n', '  //since we move the funds to multisig\n', '  //refund will be with payback()\n', '  /* /// @notice Get back the ether sent during the funding in case the funding */\n', '  /* /// has not reached the minimum level. */\n', '  /* /// @dev Required state: refund true */\n', '  /* function refund() */\n', '  /* { */\n', '  /*   // Abort if not in refund state */\n', '  /*   if (!refundState) throw; */\n', '  /*   // Not refunded for VIP, we will do a manual refund for them */\n', '  /*   // via the payback function */\n', '  /*   if (vips[msg.sender]) throw; */\n', '  /*   uint value = balances[msg.sender]; */\n', '  /*   if (value == 0) throw; */\n', '  /*   balances[msg.sender] = 0; */\n', '  /*   totalTokens -= value; */\n', '  /*   delete members[indexMembers[msg.sender]]; */\n', '  /*   indexMembers[msg.sender]=0; */\n', '  /*   Refund(msg.sender, value); */\n', '  /*   if (!msg.sender.send(value)) throw; */\n', '  /* } */\n', '\n', '\n', "  //@notice Full Tranfer of DX tokens from sender to '_to'\n", '  //@dev only active if tranfer has been unlocked\n', '  //@param _to address of recipient\n', '  //@param _value amount to tranfer\n', '  //@return success of tranfer ?\n', '  function fullTransfer(address _to) returns (bool)\n', '  {\n', '    // Cancel if tranfer is not allowed\n', '    if (transferLocked) throw;\n', '    if (balances[_to]!=0) throw;\n', '    if (balances[msg.sender]!=0)\n', '      {\n', '\tuint senderBalance = balances[msg.sender];\n', '\tbalances[msg.sender] = 0;\n', '\tbalances[_to]=senderBalance;\n', '\tif (vips[msg.sender])\n', '\t  {\n', '\t    vips[_to]=true;\n', '\t    vips[msg.sender]=false;\n', '\t  }\n', '\tmembers[indexMembers[msg.sender]].member=_to;\n', '\tindexMembers[_to]=indexMembers[msg.sender];\n', '\tindexMembers[msg.sender]=0;\n', '\tTransfer(msg.sender, _to, senderBalance);\n', '\treturn true;\n', '      }\n', '    else\n', '      {\n', '\treturn false;\n', '      }\n', '  }\n', '\n', '\n', '  //ADMIN FUNCTIONS\n', '\n', '\n', '  //@notice called by Admin to manually register migration of previous DO\n', '  //@dev can not be called with a _vip address that is already investor\n', '  //@dev can be called even after the DO is sealed\n', "  //@param _value : balance of VIP at DXDO's creation date\n", '  function registerVIP(address _vip, address _vip_confirm, uint256 _previous_balance)\n', '    onlyAdmin\n', '  {\n', '    if (_vip==0) throw;\n', '    if (_vip!=_vip_confirm) throw;\n', "    //don't allow migration to a non empty address\n", '    if (balances[_vip]!=0) throw; \n', '    if (_previous_balance==0) throw;\n', '    uint numberTokens=_previous_balance+(_previous_balance/3);\n', '    totalTokens+=numberTokens;\n', '    //too many tokens created via VIP migration\n', '    if (numberTokens>remainingTokensVIPs) throw;     \n', '    remainingTokensVIPs-=numberTokens;\n', '    balances[_vip]+=numberTokens;\n', '    indexMembers[_vip]=members.length;\n', '    members.push(Member(_vip,now,_previous_balance));\n', '    vips[_vip]=true;\n', '    VipMigration(_vip,_previous_balance);\n', '  }\n', '\n', '\n', '  /// @notice Pay back the ether contributed to the DAO\n', '  function paybackContribution(uint i)\n', '    payable\n', '    onlyAdmin\n', '  {\n', '    address memberRefunded=members[i].member;\n', '    if (memberRefunded==0) throw;\n', '    uint amountTokens=msg.value;\n', '    if (vips[memberRefunded]) \n', '      {\n', '\tamountTokens+=amountTokens/3;\n', '\tremainingTokensVIPs+=amountTokens;\n', '      }\n', '    if (amountTokens>balances[memberRefunded]) throw;\n', '    balances[memberRefunded]-=amountTokens;\n', '    totalTokens-=amountTokens;\n', '    if (balances[memberRefunded]==0) \n', '      {\n', '\tdelete members[i];\n', '\tvips[memberRefunded]=false;\n', '\tindexMembers[memberRefunded]=0;\n', '      }\n', '    if (!memberRefunded.send(msg.value))\n', '      {\n', '        failingRefund(memberRefunded,msg.value);\n', '      }\n', '    Refund(memberRefunded,msg.value);\n', '  }\n', '\n', '\n', '  function changeAdmin(address _admin, address _admin_confirm)\n', '    onlyAdmin\n', '  {\n', '    if (_admin!=_admin_confirm) throw;\n', '    if (_admin==0) throw;\n', '    admin=_admin;\n', '  }\n', '\n', '  //@notice called to seal the DO\n', '  //@dev can not be opened again, marks the end of the fundraising \n', '  //and the recruitment in the DO\n', '  function closeFunding()\n', '    onlyAdmin\n', '  {\n', '    closingDateFunding=now;\n', '    dxfOpen=false;\n', '    //verify if the cap has been reached\n', '    //if not : refund mode\n', '    if (totalTokens<tokensCreationMin)\n', '      {\n', '\trefundState=true;\n', '      }\n', '    else\n', '      {\n', '        //send balance, but should not be necessary.      \n', '\tif(!admin.send(this.balance)) throw;\n', '      }\n', '  }\n', '\n', '  //NOT INCLUDED\n', '  /* function reopenDO() */\n', '  /*   onlyAdmin */\n', '  /* { */\n', '  /*   dxfOpen=true; */\n', '  /*   transferLocked=true; */\n', '  /* } */\n', '\n', '  function allowTransfers()\n', '    onlyAdmin\n', '  {\n', '    transferLocked=false;\n', '  }\n', '\n', '  function disableTransfers()\n', '    onlyAdmin\n', '  {\n', '    transferLocked=true;\n', '  }\n', '\n', '\n', '  //Constant Functions\n', '  function totalSupply() external constant returns (uint256) \n', '  {\n', '    return totalTokens;\n', '  }\n', '\n', '  function balanceOf(address _owner) external constant returns (uint256) \n', '  {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function accountInformation(address _owner) external constant returns (bool vip, uint balance_dxf, uint share_dxf_per_thousands) \n', '  {\n', '    vip=vips[_owner];\n', '    balance_dxf=balances[_owner]/(1 ether);\n', '    share_dxf_per_thousands=1000*balances[_owner]/totalTokens;\n', '  }\n', '\n', '\n', '}']