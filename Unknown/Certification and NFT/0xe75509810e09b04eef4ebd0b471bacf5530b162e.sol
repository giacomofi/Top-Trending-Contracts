['/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/*\n', ' * Haltable\n', ' *\n', ' * Abstract contract that allows children to implement an\n', ' * emergency stop mechanism. Differs from Pausable by causing a throw\n', ' * instead of return when in halt mode.\n', ' *\n', ' *\n', ' * Originally envisioned in FirstBlood ICO contract.\n', ' */\n', 'contract Haltable is Ownable {\n', '  bool public halted;\n', '\n', '  modifier stopInEmergency {\n', '    if (halted) throw;\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    if (!halted) throw;\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function halt() external onlyOwner {\n', '    halted = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function unhalt() external onlyOwner onlyInEmergency {\n', '    halted = false;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Forward Ethereum payments to another wallet and track them with an event.\n', ' *\n', ' * Allows to identify customers who made Ethereum payment for a central token issuance.\n', ' * Furthermore allow making a payment on behalf of another address.\n', ' *\n', ' * Allow pausing to signal the end of the crowdsale.\n', ' */\n', 'contract PaymentForwarder is Haltable, SafeMath {\n', '\n', '  /** Who will get all ETH in the end */\n', '  address public teamMultisig;\n', '\n', '  /** Total incoming money */\n', '  uint public totalTransferred;\n', '\n', '  /** How many distinct customers we have that have made a payment */\n', '  uint public customerCount;\n', '\n', '  /** Total incoming money per centrally tracked customer id */\n', '  mapping(uint128 => uint) public paymentsByCustomer;\n', '\n', '  /** Total incoming money per benefactor address */\n', '  mapping(address => uint) public paymentsByBenefactor;\n', '\n', '  /** A customer has made a payment. Benefactor is the address where the tokens will be ultimately issued.*/\n', '  event PaymentForwarded(address source, uint amount, uint128 customerId, address benefactor);\n', '\n', '  /**\n', '   * @param _teamMultisig Team multisig receives the deposited payments.\n', '   *\n', '   * @param _owner Owner is able to pause and resume crowdsale\n', '   */\n', '  function PaymentForwarder(address _owner, address _teamMultisig) {\n', '    teamMultisig = _teamMultisig;\n', '    owner = _owner;\n', '  }\n', '\n', '  /**\n', '   * Pay on a behalf of an address.\n', '   *\n', '   * We log the payment event, so that the server can keep tally of the invested amounts\n', '   * and token receivers.\n', '   *\n', '   * The actual payment is forwarded to the team multisig.\n', '   *\n', '   * @param customerId Identifier in the central database, UUID v4 - this is used to note customer by email\n', '   *\n', '   */\n', '  function pay(uint128 customerId, address benefactor) public stopInEmergency payable {\n', '\n', '    uint weiAmount = msg.value;\n', '\n', '    if(weiAmount == 0) {\n', '      throw; // No invalid payments\n', '    }\n', '\n', '    if(customerId == 0) {\n', '      throw; // We require to record customer id for the server side processing\n', '    }\n', '\n', '    if(benefactor == 0) {\n', '      throw; // Bad payment address\n', '    }\n', '\n', '    PaymentForwarded(msg.sender, weiAmount, customerId, benefactor);\n', '\n', '    totalTransferred = safeAdd(totalTransferred, weiAmount);\n', '\n', '    if(paymentsByCustomer[customerId] == 0) {\n', '      customerCount++;\n', '    }\n', '\n', '    paymentsByCustomer[customerId] = safeAdd(paymentsByCustomer[customerId], weiAmount);\n', '\n', '    // We track benefactor addresses for extra safety;\n', '    // In the case of central ETH issuance tracking has problems we can\n', '    // construct ETH contributions solely based on blockchain data\n', '    paymentsByBenefactor[benefactor] = safeAdd(paymentsByBenefactor[benefactor], weiAmount);\n', '\n', '    // May run out of gas\n', '    if(!teamMultisig.send(weiAmount)) throw;\n', '  }\n', '\n', '  /**\n', '   * Pay on a behalf of the sender.\n', '   *\n', '   * @param customerId Identifier in the central database, UUID v4\n', '   *\n', '   */\n', '  function payForMyself(uint128 customerId) public payable {\n', '    pay(customerId, msg.sender);\n', '  }\n', '\n', '}']