['pragma solidity ^0.4.16;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '\tfunction totalSupply() constant returns (uint totalSupply);\n', '\tfunction balanceOf(address _owner) constant returns (uint balance);\n', '\tfunction transfer(address _to, uint _value) returns (bool success);\n', '\tfunction transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '\tfunction approve(address _spender, uint _value) returns (bool success);\n', '\tfunction allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    // This generates a public event on the blockchain that will notify clients\n', '\tevent Transfer(address indexed _from, address indexed _to, uint _value);\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '//Token with owner (admin)\n', 'contract OwnedToken {\n', '\taddress public owner; //contract owner (admin) address\n', '\tfunction OwnedToken () public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\t//Check if owner initiate call\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Transfer ownership\n', '     *\n', '     * @param newOwner The address of the new contract owner\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '//Contract with name\n', 'contract NamedOwnedToken is OwnedToken {\n', '\tstring public name; //the name for display purposes\n', '\tstring public symbol; //the symbol for display purposes\n', '\tfunction NamedOwnedToken(string tokenName, string tokenSymbol) public\n', '\t{\n', '        name = tokenName;                                   // Set the name for display purposes\n', '        symbol = tokenSymbol;                               // Set the symbol for display purposes\n', '\t}\n', '\n', '    /**\n', '     * Change name and symbol\n', '     *\n', '     * @param newName The new contract name\n', '     * @param newSymbol The new contract symbol \n', '     */\n', '    function changeName(string newName, string newSymbol)public onlyOwner {\n', '\t\tname = newName;\n', '\t\tsymbol = newSymbol;\n', '    }\n', '}\n', '\n', 'contract TSBToken is ERC20, NamedOwnedToken {\n', '\tusing SafeMath for uint256;\n', '\n', '    // Public variables of the token\n', '\n', '    uint256 public _totalSupply = 0; //Total number of token issued (1 token = 10^decimals)\n', '\tuint8 public decimals = 18; //Decimals, each 1 token = 10^decimals\n', '\n', '    \n', '    mapping (address => uint256) public balances; // A map with all balances\n', '    mapping (address => mapping (address => uint256)) public allowed; //Implement allowence to support ERC20\n', '\n', '    mapping (address => uint256) public paidETH; //The sum have already been paid to token owner\n', '\tuint256 public accrueDividendsPerXTokenETH = 0;\n', '\tuint256 public tokenPriceETH = 0;\n', '\n', '    mapping (address => uint256) public paydCouponsETH;\n', '\tuint256 public accrueCouponsPerXTokenETH = 0;\n', '\tuint256 public totalCouponsUSD = 0;\n', '\tuint256 public MaxCouponsPaymentUSD = 150000;\n', '\n', '\tmapping (address => uint256) public rebuySum;\n', '\tmapping (address => uint256) public rebuyInformTime;\n', '\n', '\n', '\tuint256 public endSaleTime;\n', '\tuint256 public startRebuyTime;\n', '\tuint256 public reservedSum;\n', '\tbool public rebuyStarted = false;\n', '\n', '\tuint public tokenDecimals;\n', '\tuint public tokenDecimalsLeft;\n', '\n', '    /**\n', '     * Constructor function\n', '     *\n', '     * Initializes contract\n', '     */\n', '    function TSBToken(\n', '        string tokenName,\n', '        string tokenSymbol\n', '    ) NamedOwnedToken(tokenName, tokenSymbol) public {\n', '\t\ttokenDecimals = 10**uint256(decimals - 5);\n', '\t\ttokenDecimalsLeft = 10**5;\n', '\t\tstartRebuyTime = now + 1 years;\n', '\t\tendSaleTime = now;\n', '    }\n', '\n', '    /**\n', '     * Internal function, calc dividends to transfer when tokens are transfering to another wallet\n', '     */\n', '\tfunction transferDiv(uint startTokens, uint fromTokens, uint toTokens, uint sumPaydFrom, uint sumPaydTo, uint acrued) internal constant returns (uint, uint) {\n', '\t\tuint sumToPayDividendsFrom = fromTokens.mul(acrued);\n', '\t\tuint sumToPayDividendsTo = toTokens.mul(acrued);\n', '\t\tuint sumTransfer = sumPaydFrom.div(startTokens);\n', '\t\tsumTransfer = sumTransfer.mul(startTokens-fromTokens);\n', '\t\tif (sumPaydFrom > sumTransfer) {\n', '\t\t\tsumPaydFrom -= sumTransfer;\n', '\t\t\tif (sumPaydFrom > sumToPayDividendsFrom) {\n', '\t\t\t\tsumTransfer += sumPaydFrom - sumToPayDividendsFrom;\n', '\t\t\t\tsumPaydFrom = sumToPayDividendsFrom;\n', '\t\t\t}\n', '\t\t} else {\n', '\t\t\tsumTransfer = sumPaydFrom;\n', '\t\t\tsumPaydFrom = 0;\n', '\t\t}\n', '\t\tsumPaydTo = sumPaydTo.add(sumTransfer);\n', '\t\tif (sumPaydTo > sumToPayDividendsTo) {\n', '\t\t\tuint differ = sumPaydTo - sumToPayDividendsTo;\n', '\t\t\tsumPaydTo = sumToPayDividendsTo;\n', '\t\t\tsumPaydFrom = sumPaydFrom.add(differ);\n', '\t\t\tif (sumPaydFrom > sumToPayDividendsFrom) {\n', '\t\t\t\tsumPaydFrom = sumToPayDividendsFrom;\n', '\t\t\t} \n', '\t\t}\n', '\t\treturn (sumPaydFrom, sumPaydTo);\n', '\t}\n', '\n', '\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(_to != address(0));                               // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(balances[_from] >= _value);                // Check if the sender has enough\n', '        require(balances[_to] + _value > balances[_to]); // Check for overflows\n', '\t\tuint startTokens = balances[_from].div(tokenDecimals);\n', '        balances[_from] -= _value;                         // Subtract from the sender\n', '        balances[_to] += _value;                           // Add the same to the recipient\n', '\n', '\t\tif (balances[_from] == 0) {\n', '\t\t\tpaidETH[_to] = paidETH[_to].add(paidETH[_from]);\n', '\t\t} else {\n', '\t\t\tuint fromTokens = balances[_from].div(tokenDecimals);\n', '\t\t\tuint toTokens = balances[_to].div(tokenDecimals);\n', '\t\t\t(paidETH[_from], paidETH[_to]) = transferDiv(startTokens, fromTokens, toTokens, paidETH[_from], paidETH[_to], accrueDividendsPerXTokenETH+accrueCouponsPerXTokenETH);\n', '\t\t}\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '     * Transfer tokens\n', '     *\n', '     * Send `_value` tokens to `_to` from your account\n', '     *\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Balance of tokens\n', '     *\n', '     * @param _owner The address of token wallet\n', '     */\n', '\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '\n', '    /**\n', '     * Returns total issued tokens number\n', '     *\n', '\t*/\n', '\tfunction totalSupply() public constant returns (uint totalSupply) {\n', '\t\treturn _totalSupply;\n', '\t}\n', '\n', '\n', '    /**\n', '     * Transfer tokens from other address\n', '     *\n', '     * Send `_value` tokens to `_to` in behalf of `_from`\n', '     *\n', '     * @param _from The address of the sender\n', '     * @param _to The address of the recipient\n', '     * @param _value the amount to send\n', '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowed[_from][msg.sender]);     // Check allowance\n', '        allowed[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set allowance for other address\n', '     *\n', '     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '     *\n', '     * @param _spender The address authorized to spend\n', '     * @param _value the max amount they can spend\n', '     */\n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Check allowance for address\n', '     *\n', '     * @param _owner The address who authorize to spend\n', '     * @param _spender The address authorized to spend\n', '     */\n', '\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '\n', '\t// This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    /**\n', '     * Internal function destroy tokens\n', '     */\n', '    function burnTo(uint256 _value, address adr) internal returns (bool success) {\n', '        require(balances[adr] >= _value);   // Check if the sender has enough\n', '        require(_value > 0);   // Check if the sender has enough\n', '\t\tuint startTokens = balances[adr].div(tokenDecimals);\n', '        balances[adr] -= _value;            // Subtract from the sender\n', '\t\tuint endTokens = balances[adr].div(tokenDecimals);\n', '\n', '\t\tuint sumToPayFrom = endTokens.mul(accrueDividendsPerXTokenETH + accrueCouponsPerXTokenETH);\n', '\t\tuint divETH = paidETH[adr].div(startTokens);\n', '\t\tdivETH = divETH.mul(endTokens);\n', '\t\tif (divETH > sumToPayFrom) {\n', '\t\t\tpaidETH[adr] = sumToPayFrom;\n', '\t\t} else {\n', '\t\t\tpaidETH[adr] = divETH;\n', '\t\t}\n', '\n', '\t\t_totalSupply -= _value;                      // Updates totalSupply\n', '        Burn(adr, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Delete tokens tokens during the end of croudfunding \n', '     * (in case of errors made by crowdfnuding participants)\n', '     * Only owner could call\n', '     */\n', '    function deleteTokens(address adr, uint256 amount) public onlyOwner canMint {\n', '        burnTo(amount, adr);\n', '    }\n', '\n', '\tbool public mintingFinished = false;\n', '\tevent Mint(address indexed to, uint256 amount);\n', '\tevent MintFinished();\n', '\n', '\t//Check if it is possible to mint new tokens (mint allowed only during croudfunding)\n', '\tmodifier canMint() {\n', '\t\trequire(!mintingFinished);\n', '\t\t_;\n', '\t}\n', '\t\n', '\tfunction () public payable {\n', '\t}\n', '\n', '\t//Withdraw unused ETH from contract to owner\n', '\tfunction WithdrawLeftToOwner(uint sum) public onlyOwner {\n', '\t    owner.transfer(sum);\n', '\t}\n', '\t\n', '    /**\n', '     * Mint additional tokens at the end of croudfunding\n', '     */\n', '\tfunction mintToken(address target, uint256 mintedAmount) public onlyOwner canMint  {\n', '\t\tbalances[target] += mintedAmount;\n', '\t\tuint tokensInX = mintedAmount.div(tokenDecimals);\n', '\t\tpaidETH[target] += tokensInX.mul(accrueDividendsPerXTokenETH + accrueCouponsPerXTokenETH);\n', '\t\t_totalSupply += mintedAmount;\n', '\t\tMint(owner, mintedAmount);\n', '\t\tTransfer(0x0, target, mintedAmount);\n', '\t}\n', '\n', '    /**\n', '     * Finish minting\n', '     */\n', '\tfunction finishMinting() public onlyOwner returns (bool) {\n', '\t\tmintingFinished = true;\n', '\t\tendSaleTime = now;\n', '\t\tstartRebuyTime = endSaleTime + (180 * 1 days);\n', '\t\tMintFinished();\n', '\t\treturn true;\n', '\t}\n', '\n', '    /**\n', '     * Withdraw accrued dividends and coupons\n', '     */\n', '\tfunction WithdrawDividendsAndCoupons() public {\n', '\t\twithdrawTo(msg.sender,0);\n', '\t}\n', '\n', '    /**\n', '     * Owner could initiate a withdrawal of accrued dividends and coupons to some address (in purpose to help users)\n', '     */\n', '\tfunction WithdrawDividendsAndCouponsTo(address _sendadr) public onlyOwner {\n', '\t\twithdrawTo(_sendadr, tx.gasprice * block.gaslimit);\n', '\t}\n', '\n', '    /**\n', '     * Internal function to withdraw accrued dividends and coupons\n', '     */\n', '\tfunction withdrawTo(address _sendadr, uint comiss) internal {\n', '\t\tuint tokensPerX = balances[_sendadr].div(tokenDecimals);\n', '\t\tuint sumPayd = paidETH[_sendadr];\n', '\t\tuint sumToPayRes = tokensPerX.mul(accrueCouponsPerXTokenETH+accrueDividendsPerXTokenETH);\n', '\t\tuint sumToPay = sumToPayRes.sub(comiss);\n', '\t\trequire(sumToPay>sumPayd);\n', '\t\tsumToPay = sumToPay.sub(sumPayd);\n', '\t\t_sendadr.transfer(sumToPay);\n', '\t\tpaidETH[_sendadr] = sumToPayRes;\n', '\t}\n', '\n', '    /**\n', '     * Owner accrue new sum of dividends and coupons (once per month)\n', '     */\n', '\tfunction accrueDividendandCoupons(uint sumDivFinney, uint sumFinneyCoup) public onlyOwner {\n', '\t\tsumDivFinney = sumDivFinney * 1 finney;\n', '\t\tsumFinneyCoup = sumFinneyCoup * 1 finney;\n', '\t\tuint tokens = _totalSupply.div(tokenDecimals);\n', '\t\taccrueDividendsPerXTokenETH = accrueDividendsPerXTokenETH.add(sumDivFinney.div(tokens));\n', '\t\taccrueCouponsPerXTokenETH = accrueCouponsPerXTokenETH.add(sumFinneyCoup.div(tokens));\n', '\t}\n', '\n', '    /**\n', '     * Set a price of token to rebuy\n', '     */\n', '\tfunction setTokenPrice(uint priceFinney) public onlyOwner {\n', '\t\ttokenPriceETH = priceFinney * 1 finney;\n', '\t}\n', '\n', '\tevent RebuyInformEvent(address indexed adr, uint256 amount);\n', '\n', '    /**\n', '     * Inform owner that someone whant to sell tokens\n', '     * The rebuy proccess allowed in 2 weeks after inform\n', '     * Only after half a year after croudfunding\n', '     */\n', '\tfunction InformRebuy(uint sum) public {\n', '\t\t_informRebuyTo(sum, msg.sender);\n', '\t}\n', '\n', '\tfunction InformRebuyTo(uint sum, address adr) public onlyOwner{\n', '\t\t_informRebuyTo(sum, adr);\n', '\t}\n', '\n', '\tfunction _informRebuyTo(uint sum, address adr) internal{\n', '\t\trequire (rebuyStarted || (now >= startRebuyTime));\n', '\t\trequire (sum <= balances[adr]);\n', '\t\trebuyInformTime[adr] = now;\n', '\t\trebuySum[adr] = sum;\n', '\t\tRebuyInformEvent(adr, sum);\n', '\t}\n', '\n', '    /**\n', '     * Owner could allow rebuy proccess early\n', '     */\n', '\tfunction StartRebuy() public onlyOwner{\n', '\t\trebuyStarted = true;\n', '\t}\n', '\n', '    /**\n', '    * Sell tokens after 2 weeks from information\n', '    */\n', '\tfunction doRebuy() public {\n', '\t\t_doRebuyTo(msg.sender, 0);\n', '\t}\n', '    /**\n', '    * Contract owner would perform tokens rebuy after 2 weeks from information\n', '    */\n', '\tfunction doRebuyTo(address adr) public onlyOwner {\n', '\t\t_doRebuyTo(adr, tx.gasprice * block.gaslimit);\n', '\t}\n', '\tfunction _doRebuyTo(address adr, uint comiss) internal {\n', '\t\trequire (rebuyStarted || (now >= startRebuyTime));\n', '\t\trequire (now >= rebuyInformTime[adr].add(14 days));\n', '\t\tuint sum = rebuySum[adr];\n', '\t\trequire (sum <= balances[adr]);\n', '\t\twithdrawTo(adr, 0);\n', '\t\tif (burnTo(sum, adr)) {\n', '\t\t\tsum = sum.div(tokenDecimals);\n', '\t\t\tsum = sum.mul(tokenPriceETH);\n', '\t\t\tsum = sum.div(tokenDecimalsLeft);\n', '\t\t\tsum = sum.sub(comiss);\n', '\t\t\tadr.transfer(sum);\n', '\t\t\trebuySum[adr] = 0;\n', '\t\t}\n', '\t}\n', '\n', '}\n', '\n', 'contract TSBCrowdFundingContract is NamedOwnedToken{\n', '\tusing SafeMath for uint256;\n', '\n', '\n', '\tenum CrowdSaleState {NotFinished, Success, Failure}\n', '\tCrowdSaleState public crowdSaleState = CrowdSaleState.NotFinished;\n', '\n', '\n', '    uint public fundingGoalUSD = 200000; //Min cap\n', '    uint public fundingMaxCapUSD = 500000; //Max cap\n', '    uint public priceUSD = 1; //Price in USD per 1 token\n', '\tuint public USDDecimals = 1 ether;\n', '\n', '\tuint public startTime; //crowdfunding start time\n', '    uint public endTime; //crowdfunding end time\n', '    uint public bonusEndTime; //crowdfunding end of bonus time\n', '    uint public selfDestroyTime = 2 weeks;\n', '    TSBToken public tokenReward; //TSB Token to send\n', '\t\n', '\tuint public ETHPrice = 30000; //Current price of one ETH in USD cents\n', '\tuint public BTCPrice = 400000; //Current price of one BTC in USD cents\n', '\tuint public PriceDecimals = 100;\n', '\n', '\tuint public ETHCollected = 0; //Collected sum of ETH\n', '\tuint public BTCCollected = 0; //Collected sum of BTC\n', '\tuint public amountRaisedUSD = 0; //Collected sum in USD\n', '\tuint public TokenAmountToPay = 0; //Number of tokens to distribute (excluding bonus tokens)\n', '\n', '\tmapping(address => uint256) public balanceMapPos;\n', '\tstruct mapStruct {\n', '\t\taddress mapAddress;\n', '\t\tuint mapBalanceETH;\n', '\t\tuint mapBalanceBTC;\n', '\t\tuint bonusTokens;\n', '\t}\n', '\tmapStruct[] public balanceList; //Array of struct with information about invested sums\n', '\n', '    uint public bonusCapUSD = 100000; //Bonus cap\n', '\tmapping(bytes32 => uint256) public bonusesMapPos;\n', '\tstruct bonusStruct {\n', '\t\tuint balancePos;\n', '\t\tbool notempty;\n', '\t\tuint maxBonusETH;\n', '\t\tuint maxBonusBTC;\n', '\t\tuint bonusETH;\n', '\t\tuint bonusBTC;\n', '\t\tuint8 bonusPercent;\n', '\t}\n', '\tbonusStruct[] public bonusesList; //Array of struct with information about bonuses\n', '\t\n', '    bool public fundingGoalReached = false; \n', '    bool public crowdsaleClosed = false;\n', '\n', '    event GoalReached(address beneficiary, uint amountRaised);\n', '    event FundTransfer(address backer, uint amount, bool isContribution);\n', '\n', '\tfunction TSBCrowdFundingContract( \n', '\t\tuint _startTime,\n', '        uint durationInHours,\n', '        string tokenName,\n', '        string tokenSymbol\n', '\t) NamedOwnedToken(tokenName, tokenSymbol) public {\n', '\t//\trequire(_startTime >= now);\n', '\t    SetStartTime(_startTime, durationInHours);\n', '\t\tbonusCapUSD = bonusCapUSD * USDDecimals;\n', '\t}\n', '\n', '    function SetStartTime(uint startT, uint durationInHours) public onlyOwner {\n', '        startTime = startT;\n', '        bonusEndTime = startT+ 24 hours;\n', '        endTime = startT + (durationInHours * 1 hours);\n', '    }\n', '\n', '\tfunction assignTokenContract(address tok) public onlyOwner   {\n', '\t\ttokenReward = TSBToken(tok);\n', '\t\ttokenReward.transferOwnership(address(this));\n', '\t}\n', '\n', '\tfunction () public payable {\n', '\t\tbool withinPeriod = now >= startTime && now <= endTime;\n', '\t\tbool nonZeroPurchase = msg.value != 0;\n', '\t\trequire( withinPeriod && nonZeroPurchase && (crowdSaleState == CrowdSaleState.NotFinished));\n', '\t\tuint bonuspos = 0;\n', '\t\tif (now <= bonusEndTime) {\n', '//\t\t    lastdata = msg.data;\n', '\t\t\tbytes32 code = sha3(msg.data);\n', '\t\t\tbonuspos = bonusesMapPos[code];\n', '\t\t}\n', '\t\tReceiveAmount(msg.sender, msg.value, 0, now, bonuspos);\n', '\n', '\t}\n', '\n', '\tfunction CheckBTCtransaction() internal constant returns (bool) {\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction AddBTCTransactionFromArray (address[] ETHadress, uint[] BTCnum, uint[] TransTime, bytes4[] bonusdata) public onlyOwner {\n', '        require(ETHadress.length == BTCnum.length); \n', '        require(TransTime.length == bonusdata.length);\n', '        require(ETHadress.length == bonusdata.length);\n', '        for (uint i = 0; i < ETHadress.length; i++) {\n', '            AddBTCTransaction(ETHadress[i], BTCnum[i], TransTime[i], bonusdata[i]);\n', '        }\n', '\t}\n', '    /**\n', '     * Add transfered BTC, only owner could call\n', '     *\n', '     * @param ETHadress The address of ethereum wallet of sender \n', '     * @param BTCnum the received amount in BTC * 10^18\n', '     * @param TransTime the original (BTC) transaction time\n', '     */\n', '\tfunction AddBTCTransaction (address ETHadress, uint BTCnum, uint TransTime, bytes4 bonusdata) public onlyOwner {\n', '\t\trequire(CheckBTCtransaction());\n', '\t\trequire((TransTime >= startTime) && (TransTime <= endTime));\n', '\t\trequire(BTCnum != 0);\n', '\t\tuint bonuspos = 0;\n', '\t\tif (TransTime <= bonusEndTime) {\n', '//\t\t    lastdata = bonusdata;\n', '\t\t\tbytes32 code = sha3(bonusdata);\n', '\t\t\tbonuspos = bonusesMapPos[code];\n', '\t\t}\n', '\t\tReceiveAmount(ETHadress, 0, BTCnum, TransTime, bonuspos);\n', '\t}\n', '\n', '\tmodifier afterDeadline() { if (now >= endTime) _; }\n', '\n', '    /**\n', '     * Set price for ETH and BTC, only owner could call\n', '     *\n', '     * @param _ETHPrice ETH price in USD cents\n', '     * @param _BTCPrice BTC price in USD cents\n', '     */\n', '\tfunction SetCryptoPrice(uint _ETHPrice, uint _BTCPrice) public onlyOwner {\n', '\t\tETHPrice = _ETHPrice;\n', '\t\tBTCPrice = _BTCPrice;\n', '\t}\n', '\n', '    /**\n', '     * Convert sum in ETH plus BTC to USD\n', '     *\n', '     * @param ETH ETH sum in wei\n', '     * @param BTC BTC sum in 10^18\n', '     */\n', '\tfunction convertToUSD(uint ETH, uint BTC) public constant returns (uint) {\n', '\t\tuint _ETH = ETH.mul(ETHPrice);\n', '\t\tuint _BTC = BTC.mul(BTCPrice);\n', '\t\treturn (_ETH+_BTC).div(PriceDecimals);\n', '\t}\n', '\n', '    /**\n', '     * Calc collected sum in USD\n', '     */\n', '\tfunction collectedSum() public constant returns (uint) {\n', '\t\treturn convertToUSD(ETHCollected,BTCCollected);\n', '\t}\n', '\n', '    /**\n', '     * Check if min cap was reached (only after finish of crowdfunding)\n', '     */\n', '    function checkGoalReached() public afterDeadline {\n', '\t\tamountRaisedUSD = collectedSum();\n', '        if (amountRaisedUSD >= (fundingGoalUSD * USDDecimals) ){\n', '\t\t\tcrowdSaleState = CrowdSaleState.Success;\n', '\t\t\tTokenAmountToPay = amountRaisedUSD;\n', '            GoalReached(owner, amountRaisedUSD);\n', '        } else {\n', '\t\t\tcrowdSaleState = CrowdSaleState.Failure;\n', '\t\t}\n', '    }\n', '\n', '    /**\n', '     * Check if max cap was reached\n', '     */\n', '    function checkMaxCapReached() public {\n', '\t\tamountRaisedUSD = collectedSum();\n', '        if (amountRaisedUSD >= (fundingMaxCapUSD * USDDecimals) ){\n', '\t        crowdSaleState = CrowdSaleState.Success;\n', '\t\t\tTokenAmountToPay = amountRaisedUSD;\n', '            GoalReached(owner, amountRaisedUSD);\n', '        }\n', '    }\n', '\n', '\tfunction ReceiveAmount(address investor, uint sumETH, uint sumBTC, uint TransTime, uint bonuspos) internal {\n', '\t\trequire(investor != 0x0);\n', '\n', '\t\tuint pos = balanceMapPos[investor];\n', '\t\tif (pos>0) {\n', '\t\t\tpos--;\n', '\t\t\tassert(pos < balanceList.length);\n', '\t\t\tassert(balanceList[pos].mapAddress == investor);\n', '\t\t\tbalanceList[pos].mapBalanceETH = balanceList[pos].mapBalanceETH.add(sumETH);\n', '\t\t\tbalanceList[pos].mapBalanceBTC = balanceList[pos].mapBalanceBTC.add(sumBTC);\n', '\t\t} else {\n', '\t\t\tmapStruct memory newStruct;\n', '\t\t\tnewStruct.mapAddress = investor;\n', '\t\t\tnewStruct.mapBalanceETH = sumETH;\n', '\t\t\tnewStruct.mapBalanceBTC = sumBTC;\n', '\t\t\tnewStruct.bonusTokens = 0;\n', '\t\t\tpos = balanceList.push(newStruct);\t\t\n', '\t\t\tbalanceMapPos[investor] = pos;\n', '\t\t\tpos--;\n', '\t\t}\n', '\t\t\n', '\t\t// update state\n', '\t\tETHCollected = ETHCollected.add(sumETH);\n', '\t\tBTCCollected = BTCCollected.add(sumBTC);\n', '\t\t\n', '\t\tcheckBonus(pos, sumETH, sumBTC, TransTime, bonuspos);\n', '\t\tcheckMaxCapReached();\n', '\t}\n', '\n', '\tuint public DistributionNextPos = 0;\n', '\n', '    /**\n', '     * Distribute tokens to next N participants, only owner could call\n', '     */\n', '\tfunction DistributeNextNTokens(uint n) public payable onlyOwner {\n', '\t\trequire(BonusesDistributed);\n', '\t\trequire(DistributionNextPos<balanceList.length);\n', '\t\tuint nextpos;\n', '\t\tif (n == 0) {\n', '\t\t    nextpos = balanceList.length;\n', '\t\t} else {\n', '    \t\tnextpos = DistributionNextPos.add(n);\n', '    \t\tif (nextpos > balanceList.length) {\n', '    \t\t\tnextpos = balanceList.length;\n', '    \t\t}\n', '\t\t}\n', '\t\tuint TokenAmountToPay_local = TokenAmountToPay;\n', '\t\tfor (uint i = DistributionNextPos; i < nextpos; i++) {\n', '\t\t\tuint USDbalance = convertToUSD(balanceList[i].mapBalanceETH, balanceList[i].mapBalanceBTC);\n', '\t\t\tuint tokensCount = USDbalance.mul(priceUSD);\n', '\t\t\ttokenReward.mintToken(balanceList[i].mapAddress, tokensCount + balanceList[i].bonusTokens);\n', '\t\t\tTokenAmountToPay_local = TokenAmountToPay_local.sub(tokensCount);\n', '\t\t\tbalanceList[i].mapBalanceETH = 0;\n', '\t\t\tbalanceList[i].mapBalanceBTC = 0;\n', '\t\t}\n', '\t\tTokenAmountToPay = TokenAmountToPay_local;\n', '\t\tDistributionNextPos = nextpos;\n', '\t}\n', '\n', '\tfunction finishDistribution()  onlyOwner {\n', '\t\trequire ((TokenAmountToPay == 0)||(DistributionNextPos >= balanceList.length));\n', '//\t\ttokenReward.finishMinting();\n', '\t\ttokenReward.transferOwnership(owner);\n', '\t\tselfdestruct(owner);\n', '\t}\n', '\n', '    /**\n', '     * Withdraw the funds\n', '     *\n', '     * Checks to see if goal was not reached, each contributor can withdraw\n', '     * the amount they contributed.\n', '     */\n', '    function safeWithdrawal() public afterDeadline {\n', '        require(crowdSaleState == CrowdSaleState.Failure);\n', '\t\tuint pos = balanceMapPos[msg.sender];\n', '\t\trequire((pos>0)&&(pos<=balanceList.length));\n', '\t\tpos--;\n', '        uint amount = balanceList[pos].mapBalanceETH;\n', '        balanceList[pos].mapBalanceETH = 0;\n', '        if (amount > 0) {\n', '            msg.sender.transfer(amount);\n', '            FundTransfer(msg.sender, amount, false);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * If something goes wrong owner could destroy the contract after 2 weeks from the crowdfunding end\n', '     * In this case the token distribution or sum refund will be performed in mannual\n', '     */\n', '\tfunction killContract() public onlyOwner {\n', '\t\trequire(now >= endTime + selfDestroyTime);\n', '\t\ttokenReward.transferOwnership(owner);\n', '        selfdestruct(owner);\n', '    }\n', '\n', '    /**\n', '     * Add a new bonus code, only owner could call\n', '     */\n', '\tfunction AddBonusToListFromArray(bytes32[] bonusCode, uint[] ETHsumInFinney, uint[] BTCsumInFinney) public onlyOwner {\n', '\t    require(bonusCode.length == ETHsumInFinney.length);\n', '\t    require(bonusCode.length == BTCsumInFinney.length);\n', '\t    for (uint i = 0; i < bonusCode.length; i++) {\n', '\t        AddBonusToList(bonusCode[i], ETHsumInFinney[i], BTCsumInFinney[i] );\n', '\t    }\n', '\t}\n', '    /**\n', '     * Add a new bonus code, only owner could call\n', '     */\n', '\tfunction AddBonusToList(bytes32 bonusCode, uint ETHsumInFinney, uint BTCsumInFinney) public onlyOwner {\n', '\t\tuint pos = bonusesMapPos[bonusCode];\n', '\n', '\t\tif (pos > 0) {\n', '\t\t\tpos -= 1;\n', '\t\t\tbonusesList[pos].maxBonusETH = ETHsumInFinney * 1 finney;\n', '\t\t\tbonusesList[pos].maxBonusBTC = BTCsumInFinney * 1 finney;\n', '\t\t} else {\n', '\t\t\tbonusStruct memory newStruct;\n', '\t\t\tnewStruct.balancePos = 0;\n', '\t\t\tnewStruct.notempty = false;\n', '\t\t\tnewStruct.maxBonusETH = ETHsumInFinney * 1 finney;\n', '\t\t\tnewStruct.maxBonusBTC = BTCsumInFinney * 1 finney;\n', '\t\t\tnewStruct.bonusETH = 0;\n', '\t\t\tnewStruct.bonusBTC = 0;\n', '\t\t\tnewStruct.bonusPercent = 20;\n', '\t\t\tpos = bonusesList.push(newStruct);\t\t\n', '\t\t\tbonusesMapPos[bonusCode] = pos;\n', '\t\t}\n', '\t}\n', '\tbool public BonusesDistributed = false;\n', '\tuint public BonusCalcPos = 0;\n', '//    bytes public lastdata;\n', '\tfunction checkBonus(uint newBalancePos, uint sumETH, uint sumBTC, uint TransTime, uint pos) internal {\n', '\t\t\tif (pos > 0) {\n', '\t\t\t\tpos--;\n', '\t\t\t\tif (!bonusesList[pos].notempty) {\n', '\t\t\t\t\tbonusesList[pos].balancePos = newBalancePos;\n', '\t\t\t\t\tbonusesList[pos].notempty = true;\n', '\t\t\t\t} else {\n', '\t\t\t\t    if (bonusesList[pos].balancePos != newBalancePos) return;\n', '\t\t\t\t}\n', '\t\t\t\tbonusesList[pos].bonusETH = bonusesList[pos].bonusETH.add(sumETH);\n', '\t\t\t\t// if (bonusesList[pos].bonusETH > bonusesList[pos].maxBonusETH)\n', '\t\t\t\t// \tbonusesList[pos].bonusETH = bonusesList[pos].maxBonusETH;\n', '\t\t\t\tbonusesList[pos].bonusBTC = bonusesList[pos].bonusBTC.add(sumBTC);\n', '\t\t\t\t// if (bonusesList[pos].bonusBTC > bonusesList[pos].maxBonusBTC)\n', '\t\t\t\t// \tbonusesList[pos].bonusBTC = bonusesList[pos].maxBonusBTC;\n', '\t\t\t}\n', '\t}\n', '\n', '    /**\n', '     * Calc the number of bonus tokens for N next bonus participants, only owner could call\n', '     */\n', '\tfunction calcNextNBonuses(uint N) public onlyOwner {\n', '\t\trequire(crowdSaleState == CrowdSaleState.Success);\n', '\t\trequire(!BonusesDistributed);\n', '\t\tuint nextPos = BonusCalcPos + N;\n', '\t\tif (nextPos > bonusesList.length) \n', '\t\t\tnextPos = bonusesList.length;\n', '        uint bonusCapUSD_local = bonusCapUSD;    \n', '\t\tfor (uint i = BonusCalcPos; i < nextPos; i++) {\n', '\t\t\tif  ((bonusesList[i].notempty) && (bonusesList[i].balancePos < balanceList.length)) {\n', '\t\t\t\tuint maxbonus = convertToUSD(bonusesList[i].maxBonusETH, bonusesList[i].maxBonusBTC);\n', '\t\t\t\tuint bonus = convertToUSD(bonusesList[i].bonusETH, bonusesList[i].bonusBTC);\n', '\t\t\t\tif (maxbonus < bonus)\n', '\t\t\t\t    bonus = maxbonus;\n', '\t\t\t\tbonus = bonus.mul(priceUSD);\n', '\t\t\t\tif (bonusCapUSD_local >= bonus) {\n', '\t\t\t\t\tbonusCapUSD_local = bonusCapUSD_local - bonus;\n', '\t\t\t\t} else {\n', '\t\t\t\t\tbonus = bonusCapUSD_local;\n', '\t\t\t\t\tbonusCapUSD_local = 0;\n', '\t\t\t\t}\n', '\t\t\t\tbonus = bonus.mul(bonusesList[i].bonusPercent) / 100;\n', '\t\t\t\tbalanceList[bonusesList[i].balancePos].bonusTokens = bonus;\n', '\t\t\t\tif (bonusCapUSD_local == 0) {\n', '\t\t\t\t\tBonusesDistributed = true;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '        bonusCapUSD = bonusCapUSD_local;    \n', '\t\tBonusCalcPos = nextPos;\n', '\t\tif (nextPos >= bonusesList.length) {\n', '\t\t\tBonusesDistributed = true;\n', '\t\t}\n', '\t}\n', '\n', '}']