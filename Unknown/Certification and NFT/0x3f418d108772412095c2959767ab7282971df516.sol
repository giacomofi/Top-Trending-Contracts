['pragma solidity ^0.4.11;\n', '/*\n', '    Meme Network Token contract source code.\n', '    Copyright (C) 2017 whodknee\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', 'contract MemeNetworkToken {\n', '    // Token information.\n', '    string public constant name = "Meme Network Token";\n', '    string public constant symbol = "MNT";\n', '    uint8 public constant decimals = 18;\n', '\n', '    uint256 public constant tokenCreationRate = 10;\n', '    uint256 public constant tokenCreationCap = 100000 ether * tokenCreationRate;\n', '    uint256 totalTokens;\n', '\n', '    address public devAddress;\n', '\n', '    // Ending block.\n', '    uint256 public endingBlock;\n', '\n', '    // Funding state.\n', '    bool public funding = true;\n', '    \n', '    // Array of balances.\n', '    mapping (address => uint256) balances;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function MemeNetworkToken(\n', '        address _devAddress,\n', '        uint256 _endingBlock\n', '        ) {\n', '        devAddress = _devAddress;\n', '        endingBlock = _endingBlock;\n', '    }\n', '\n', '    function balanceOf(address _owner) external constant returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    function totalSupply() external constant returns (uint256) {\n', '        return totalTokens;\n', '    }\n', '\n', '    // Transfer Coins\n', '    function transfer(address _to, uint256 _value) {\n', '        \n', '        //check for proper balance and overflows\n', '        if (balances[msg.sender] < _value)\n', '            throw;\n', '        if (balances[_to] + _value < balances[_to])\n', '            throw;\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    // Crowdfunding. Only if(funding).\n', '    function create() payable external {\n', '        // Abort if funding is over.\n', '        // Abort if past ending block.\n', '        // Abort if msg.value == 0\n', '        // Abort if tokens created would cause \n', '        // totalTokens to be greater than tokenCreationCap\n', '        if(!funding) throw;\n', '        if (block.number > endingBlock)\n', '            throw;\n', '        // Do not allow creating 0 or more than the cap.\n', '        if (msg.value == 0) throw;\n', '        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n', '            throw;\n', '        \n', '        var numTokens = msg.value * tokenCreationRate;\n', '        totalTokens += numTokens;\n', '\n', '        balances[msg.sender] += numTokens;\n', '\n', '        Transfer(0, msg.sender, numTokens);      \n', '    }\n', '    function finalize() {\n', '        if (!funding) throw;\n', '        if (block.number <= endingBlock &&\n', '            totalTokens < tokenCreationCap)\n', '            throw;\n', '        \n', '        funding = false;\n', '\n', '        uint256 devTokens = tokenCreationCap - totalTokens + (tokenCreationCap / 5);\n', '        balances[devAddress] += devTokens;\n', '        Transfer(0, devAddress, devTokens);\n', '\n', '        if (!devAddress.send(this.balance)) throw;\n', '    }\n', '}']