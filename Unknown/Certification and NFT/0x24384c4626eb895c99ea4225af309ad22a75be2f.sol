['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title Owned contract with safe ownership pass.\n', ' *\n', ' * Note: all the non constant functions return false instead of throwing in case if state change\n', ' * didn&#39;t happen yet.\n', ' */\n', 'contract Owned {\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public contractOwner;\n', '\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public pendingContractOwner;\n', '\n', '    function Owned() {\n', '        contractOwner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner check modifier\n', '    */\n', '    modifier onlyContractOwner() {\n', '        if (contractOwner == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Destroy contract and scrub a data\n', '     * @notice Only owner can call it\n', '     */\n', '    function destroy() onlyContractOwner {\n', '        suicide(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Prepares ownership pass.\n', '     *\n', '     * Can only be called by current owner.\n', '     *\n', '     * @param _to address of the next owner. 0x0 is not allowed.\n', '     *\n', '     * @return success.\n', '     */\n', '    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\n', '        if (_to  == 0x0) {\n', '            return false;\n', '        }\n', '\n', '        pendingContractOwner = _to;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Finalize ownership pass.\n', '     *\n', '     * Can only be called by pending owner.\n', '     *\n', '     * @return success.\n', '     */\n', '    function claimContractOwnership() returns(bool) {\n', '        if (pendingContractOwner != msg.sender) {\n', '            return false;\n', '        }\n', '\n', '        contractOwner = pendingContractOwner;\n', '        delete pendingContractOwner;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '    string public symbol;\n', '\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', '/**\n', ' * @title Generic owned destroyable contract\n', ' */\n', 'contract Object is Owned {\n', '    /**\n', '    *  Common result code. Means everything is fine.\n', '    */\n', '    uint constant OK = 1;\n', '    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\n', '\n', '    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\n', '        for(uint i=0;i<tokens.length;i++) {\n', '            address token = tokens[i];\n', '            uint balance = ERC20Interface(token).balanceOf(this);\n', '            if(balance != 0)\n', '                ERC20Interface(token).transfer(_to,balance);\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    function checkOnlyContractOwner() internal constant returns(uint) {\n', '        if (contractOwner == msg.sender) {\n', '            return OK;\n', '        }\n', '\n', '        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Events History universal multi contract.\n', ' *\n', ' * Contract serves as an Events storage for any type of contracts.\n', ' * Events appear on this contract address but their definitions provided by calling contracts.\n', ' *\n', ' * Note: all the non constant functions return false instead of throwing in case if state change\n', ' * didn&#39;t happen yet.\n', ' */\n', 'contract MultiEventsHistory is Object {\n', '    // Authorized calling contracts.\n', '    mapping(address => bool) public isAuthorized;\n', '\n', '    /**\n', '     * Authorize new caller contract.\n', '     *\n', '     * @param _caller address of the new caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function authorize(address _caller) onlyContractOwner() returns(bool) {\n', '        if (isAuthorized[_caller]) {\n', '            return false;\n', '        }\n', '        isAuthorized[_caller] = true;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Reject access.\n', '     *\n', '     * @param _caller address of the caller.\n', '     */\n', '    function reject(address _caller) onlyContractOwner() {\n', '        delete isAuthorized[_caller];\n', '    }\n', '\n', '    /**\n', '     * Event emitting fallback.\n', '     *\n', '     * Can be and only called by authorized caller.\n', '     * Delegate calls back with provided msg.data to emit an event.\n', '     *\n', '     * Throws if call failed.\n', '     */\n', '    function () {\n', '        if (!isAuthorized[msg.sender]) {\n', '            return;\n', '        }\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Recursive Call: safe, all changes already made.\n', '        if (!msg.sender.delegatecall(msg.data)) {\n', '            throw;\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title Owned contract with safe ownership pass.\n', ' *\n', ' * Note: all the non constant functions return false instead of throwing in case if state change\n', " * didn't happen yet.\n", ' */\n', 'contract Owned {\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public contractOwner;\n', '\n', '    /**\n', '     * Contract owner address\n', '     */\n', '    address public pendingContractOwner;\n', '\n', '    function Owned() {\n', '        contractOwner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Owner check modifier\n', '    */\n', '    modifier onlyContractOwner() {\n', '        if (contractOwner == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Destroy contract and scrub a data\n', '     * @notice Only owner can call it\n', '     */\n', '    function destroy() onlyContractOwner {\n', '        suicide(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Prepares ownership pass.\n', '     *\n', '     * Can only be called by current owner.\n', '     *\n', '     * @param _to address of the next owner. 0x0 is not allowed.\n', '     *\n', '     * @return success.\n', '     */\n', '    function changeContractOwnership(address _to) onlyContractOwner() returns(bool) {\n', '        if (_to  == 0x0) {\n', '            return false;\n', '        }\n', '\n', '        pendingContractOwner = _to;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Finalize ownership pass.\n', '     *\n', '     * Can only be called by pending owner.\n', '     *\n', '     * @return success.\n', '     */\n', '    function claimContractOwnership() returns(bool) {\n', '        if (pendingContractOwner != msg.sender) {\n', '            return false;\n', '        }\n', '\n', '        contractOwner = pendingContractOwner;\n', '        delete pendingContractOwner;\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract ERC20Interface {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '    string public symbol;\n', '\n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '}\n', '\n', '/**\n', ' * @title Generic owned destroyable contract\n', ' */\n', 'contract Object is Owned {\n', '    /**\n', '    *  Common result code. Means everything is fine.\n', '    */\n', '    uint constant OK = 1;\n', '    uint constant OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER = 8;\n', '\n', '    function withdrawnTokens(address[] tokens, address _to) onlyContractOwner returns(uint) {\n', '        for(uint i=0;i<tokens.length;i++) {\n', '            address token = tokens[i];\n', '            uint balance = ERC20Interface(token).balanceOf(this);\n', '            if(balance != 0)\n', '                ERC20Interface(token).transfer(_to,balance);\n', '        }\n', '        return OK;\n', '    }\n', '\n', '    function checkOnlyContractOwner() internal constant returns(uint) {\n', '        if (contractOwner == msg.sender) {\n', '            return OK;\n', '        }\n', '\n', '        return OWNED_ACCESS_DENIED_ONLY_CONTRACT_OWNER;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Events History universal multi contract.\n', ' *\n', ' * Contract serves as an Events storage for any type of contracts.\n', ' * Events appear on this contract address but their definitions provided by calling contracts.\n', ' *\n', ' * Note: all the non constant functions return false instead of throwing in case if state change\n', " * didn't happen yet.\n", ' */\n', 'contract MultiEventsHistory is Object {\n', '    // Authorized calling contracts.\n', '    mapping(address => bool) public isAuthorized;\n', '\n', '    /**\n', '     * Authorize new caller contract.\n', '     *\n', '     * @param _caller address of the new caller.\n', '     *\n', '     * @return success.\n', '     */\n', '    function authorize(address _caller) onlyContractOwner() returns(bool) {\n', '        if (isAuthorized[_caller]) {\n', '            return false;\n', '        }\n', '        isAuthorized[_caller] = true;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Reject access.\n', '     *\n', '     * @param _caller address of the caller.\n', '     */\n', '    function reject(address _caller) onlyContractOwner() {\n', '        delete isAuthorized[_caller];\n', '    }\n', '\n', '    /**\n', '     * Event emitting fallback.\n', '     *\n', '     * Can be and only called by authorized caller.\n', '     * Delegate calls back with provided msg.data to emit an event.\n', '     *\n', '     * Throws if call failed.\n', '     */\n', '    function () {\n', '        if (!isAuthorized[msg.sender]) {\n', '            return;\n', '        }\n', '        // Internal Out Of Gas/Throw: revert this transaction too;\n', '        // Recursive Call: safe, all changes already made.\n', '        if (!msg.sender.delegatecall(msg.data)) {\n', '            throw;\n', '        }\n', '    }\n', '}']
