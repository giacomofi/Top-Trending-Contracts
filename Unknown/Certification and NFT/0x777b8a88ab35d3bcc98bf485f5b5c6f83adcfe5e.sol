['pragma solidity ^ 0.4.17;\n', '\n', 'library SafeMath {\n', '    function mul(uint a, uint b) pure internal returns(uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '\n', '    function sub(uint a, uint b) pure internal returns(uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint a, uint b) pure internal returns(uint) {\n', '        uint c = a + b;\n', '        assert(c >= a && c >= b);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '\n', '    function balanceOf(address who) public view returns(uint);\n', '\n', '    function allowance(address owner, address spender) public view returns(uint);\n', '\n', '    function transfer(address to, uint value) public returns(bool ok);\n', '\n', '    function transferFrom(address from, address to, uint value) public returns(bool ok);\n', '\n', '    function approve(address spender, uint value) public returns(bool ok);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        if (newOwner != address(0)) \n', '            owner = newOwner;\n', '    }\n', '\n', '    function kill() public {\n', '        if (msg.sender == owner) \n', '            selfdestruct(owner);\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender == owner)\n', '            _;\n', '    }\n', '}\n', '\n', 'contract Pausable is Ownable {\n', '    bool public stopped;\n', '\n', '    modifier stopInEmergency {\n', '        if (stopped) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyInEmergency {\n', '        if (!stopped) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    // Called by the owner in emergency, triggers stopped state\n', '    function emergencyStop() external onlyOwner() {\n', '        stopped = true;\n', '    }\n', '\n', '    // Called by the owner to end of emergency, returns to normal state\n', '    function release() external onlyOwner() onlyInEmergency {\n', '        stopped = false;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '// Crowdsale Smart Contract\n', '// This smart contract collects ETH and in return sends tokens to contributors\n', 'contract Crowdsale is Pausable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    struct Backer {\n', '        uint weiReceived; // amount of ETH contributed\n', '        uint tokensSent; // amount of tokens  sent  \n', '        bool refunded; // true if user has been refunded       \n', '    }\n', '\n', '    Token public token; // Token contract reference   \n', '    address public multisig; // Multisig contract that will receive the ETH    \n', '    address public team; // Address at which the team tokens will be sent     \n', '    address public lottery; //address for 50% of remaining tokens \n', '    uint public ethReceivedPresale; // Number of ETH received in presal\n', '    uint public ethReceivedMain; // Number of ETH received in main sale\n', '    uint public totalTokensSent; // Number of sent to ETH contributors\n', '    uint public startBlock; // Crowdsale start block\n', '    uint public endBlock; // Crowdsale end block\n', '    uint public maxCap; // Maximum number of to sell\n', '    uint public minCap; // Minimum number of ETH to raise\n', '    uint public minInvestETH; // Minimum amount to invest   \n', '    bool public crowdsaleClosed; // Is crowdsale still on going\n', '    Step public currentStep;  // to allow for controled steps of the campaign \n', '    uint public refundCount;  // number of refunds\n', '    uint public totalRefunded; // total amount of refunds    \n', '    uint public tokenPriceWei;\n', '\n', '    mapping(address => Backer) public backers; //backer list\n', '    address[] public backersIndex; // to be able to itarate through backers for verification.  \n', '\n', '\n', '     // @ntice ovwrite to ensure that if any money are left, they go \n', '     // to multisig wallet\n', '     function kill() public {\n', '        if (msg.sender == owner) \n', '            selfdestruct(multisig);\n', '    }\n', '\n', '    // @notice to verify if action is not performed out of the campaing range\n', '    modifier respectTimeFrame() {\n', '        if ((block.number < startBlock) || (block.number > endBlock)) \n', '            revert();\n', '        _;\n', '    }\n', '\n', '\n', '    modifier minCapNotReached() {\n', '        if (ethReceivedPresale.add(ethReceivedMain) >= minCap) \n', '            revert();\n', '        _;\n', '    }\n', '\n', '\n', '    // @notice to set and determine steps of crowdsale\n', '    enum Step {\n', '        Unknown,\n', '        FundingPreSale,     // presale mode\n', '        FundingPublicSale,  // public mode\n', '        Refunding  // in case campaign failed during this step contributors will be able to receive refunds\n', '    }\n', '\n', '\n', '    // Events\n', '    event ReceivedETH(address backer, uint amount, uint tokenAmount);\n', '    event RefundETH(address backer, uint amount);\n', '\n', '\n', '    // Crowdsale  {constructor}\n', '    // @notice fired when contract is crated. Initilizes all constnat variables.\n', '    function Crowdsale() public {\n', '        \n', '        multisig = 0xC30b7a7d82c71467AF9eC85e039e4ED586EF9812; \n', '        team = 0xC30b7a7d82c71467AF9eC85e039e4ED586EF9812;       \n', '        lottery = 0x027127930D9ae133C08AE480A6E6C2caf1e87861;                                                         \n', '        maxCap = 14700000e18;        \n', '        tokenPriceWei = 6666666666e5;\n', '        totalTokensSent = 0; \n', '        minCap = (250 ether * 1e18) / tokenPriceWei;\n', '        setStep(Step.FundingPreSale);\n', '    }\n', '\n', '       // @notice to populate website with status of the sale \n', '    function returnWebsiteData() external constant returns(uint, uint, uint, uint, uint, uint, uint, uint, Step, bool, bool) {\n', '        \n', '    \n', '        return (startBlock, endBlock, backersIndex.length, ethReceivedPresale.add(ethReceivedMain), maxCap, minCap, totalTokensSent,  tokenPriceWei, currentStep, stopped, crowdsaleClosed);\n', '    }\n', '\n', '    // @notice in case refunds are needed, money can be returned to the contract\n', '    function fundContract() external payable onlyOwner() returns (bool) {\n', '        return true;\n', '    }\n', '\n', '\n', '    // @notice Specify address of token contract\n', '    // @param _tokenAddress {address} address of token contrac\n', '    // @return res {bool}\n', '    function updateTokenAddress(Token _tokenAddress) external onlyOwner() returns(bool res) {\n', '        token = _tokenAddress;\n', '        return true;\n', '    }\n', '\n', '\n', '    // @notice set the step of the campaign \n', '    // @param _step {Step}\n', '    function setStep(Step _step) public onlyOwner() {\n', '        currentStep = _step;\n', '        \n', '        if (currentStep == Step.FundingPreSale)  // for presale             \n', '            minInvestETH = 1 ether/4;                             \n', '        else if (currentStep == Step.FundingPublicSale) // for public sale           \n', '            minInvestETH = 0;                               \n', '    }\n', '\n', '\n', '    // @notice return number of contributors\n', '    // @return  {uint} number of contributors   \n', '    function numberOfBackers() public constant returns(uint) {\n', '        return backersIndex.length;\n', '    }\n', '\n', '\n', '\n', '    // {fallback function}\n', '    // @notice It will call internal function which handels allocation of Ether and calculates tokens.\n', '    function () external payable {           \n', '        contribute(msg.sender);\n', '    }\n', '\n', '\n', '    // @notice It will be called by owner to start the sale    \n', '    function start(uint _block) external onlyOwner() {   \n', '\n', '        require(_block < 216000);  // 2.5*60*24*60 days = 216000     \n', '        startBlock = block.number;\n', '        endBlock = startBlock.add(_block); \n', '    }\n', '\n', '    // @notice Due to changing average of block time\n', '    // this function will allow on adjusting duration of campaign closer to the end \n', '    function adjustDuration(uint _block) external onlyOwner() {\n', '\n', '        require(_block < 288000);  // 2.5*60*24*80 days = 288000     \n', '        require(_block > block.number.sub(startBlock)); // ensure that endBlock is not set in the past\n', '        endBlock = startBlock.add(_block); \n', '    }\n', '\n', '    // @notice It will be called by fallback function whenever ether is sent to it\n', '    // @param  _backer {address} address of beneficiary\n', '    // @return res {bool} true if transaction was successful\n', '    function contribute(address _backer) internal stopInEmergency respectTimeFrame returns(bool res) {\n', '\n', '        uint tokensToSend = validPurchase();\n', '            \n', '        Backer storage backer = backers[_backer];\n', '\n', '        if (!token.transfer(_backer, tokensToSend)) \n', '            revert(); // Transfer tokens\n', '        backer.tokensSent = backer.tokensSent.add(tokensToSend); // save contributors tokens to be sent\n', '        backer.weiReceived = backer.weiReceived.add(msg.value);  // save how much was the contribution\n', '\n', '        if (Step.FundingPublicSale == currentStep)  // Update the total Ether recived\n', '           ethReceivedMain = ethReceivedMain.add(msg.value);\n', '        else\n', '            ethReceivedPresale = ethReceivedPresale.add(msg.value); \n', '                                                     \n', '        totalTokensSent = totalTokensSent.add(tokensToSend);     // update the total amount of tokens sent\n', '        backersIndex.push(_backer);\n', '\n', '        multisig.transfer(this.balance);   // transfer funds to multisignature wallet             \n', '\n', '        ReceivedETH(_backer, msg.value, tokensToSend); // Register event\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    // @notice determine if purchase is valid and return proper number of tokens\n', '    // @return tokensToSend {uint} proper number of tokens based on the timline\n', '\n', '    function validPurchase() constant internal returns (uint) {\n', '       \n', '        require (msg.value >= minInvestETH);   // ensure that min contributions amount is met\n', '\n', '        // calculate amount of tokens to send  (add 18 0s first)   \n', '        uint tokensToSend = msg.value.mul(1e18) / tokenPriceWei;  // basic nmumber of tokens to send\n', '          \n', '        if (Step.FundingPublicSale == currentStep)   // calculate stepped price of token in public sale\n', '            tokensToSend = calculateNoOfTokensToSend(tokensToSend); \n', '        else                                         // calculate number of tokens for presale with 50% bonus\n', '            tokensToSend = tokensToSend.add(tokensToSend.mul(50) / 100);\n', '          \n', "        require(totalTokensSent.add(tokensToSend) < maxCap); // Ensure that max cap hasn't been reached  \n", '\n', '        return tokensToSend;\n', '    }\n', '    \n', '    // @notice It is called by handleETH to determine amount of tokens for given contribution\n', '    // @param _amount {uint} current range computed\n', '    // @return tokensToPurchase {uint} value of tokens to purchase\n', '    function calculateNoOfTokensToSend(uint _amount) internal constant returns(uint) {\n', '   \n', '        if (ethReceivedMain <= 1500 ether)        // First 1500 ETH: 25%\n', '            return _amount.add(_amount.mul(25) / 100);\n', '        else if (ethReceivedMain <= 2500 ether)   // 1501 to 2500 ETH: 15%              \n', '            return _amount.add(_amount.mul(15) / 100);\n', '        else if (ethReceivedMain < 3000 ether)   // 2501 to 3000 ETH: 10%\n', '            return _amount.add(_amount.mul(10) / 100);\n', '        else if (ethReceivedMain <= 4000 ether)  // 3001 to 4000 ETH: 5%\n', '            return _amount.add(_amount.mul(5) / 100);\n', '        else if (ethReceivedMain <= 5000 ether)  // 4001 to 5000 ETH : 2%\n', '            return _amount.add(_amount.mul(2) / 100);\n', '        else                                 // 5000+ No bonus after that\n', '            return _amount;\n', '    }\n', '\n', '    // @notice show for display purpose amount of tokens which can be bought \n', '    // at given moment. \n', '    // @param _ether {uint} amount of ehter\n', '    function estimateTokenNumber(uint _amountWei ) external view returns (uint) { \n', '        return calculateNoOfTokensToSend(_amountWei);\n', '    }\n', '\n', '    // @notice This function will finalize the sale.\n', '    // It will only execute if predetermined sale time passed or all tokens are sold.\n', '    function finalize() external onlyOwner() {\n', '\n', '        uint totalEtherReceived = ethReceivedPresale.add(ethReceivedMain);\n', '\n', '        require(!crowdsaleClosed);        \n', '        // purchasing precise number of tokens might be impractical, thus subtract 100 tokens so finalizition is possible\n', '        // near the end \n', '        require (block.number >= endBlock || totalTokensSent >= maxCap.sub(100)); \n', '        require(totalEtherReceived >= minCap && block.number >= endBlock);             \n', '\n', '        if (totalTokensSent >= minCap) {           \n', '            if (!token.transfer(team, 6300000e18)) // transfer tokens for the team/dev/advisors\n', '                revert();\n', '            if (!token.transfer(lottery, token.balanceOf(this) / 2)) \n', '                revert();\n', '            if (!token.burn(this, token.balanceOf(this)))\n', '                revert();\n', '             token.unlock();\n', '        }\n', '        crowdsaleClosed = true;       \n', '    }\n', '\n', '  \n', '\n', '    // @notice Failsafe drain\n', '    function drain() external onlyOwner() {\n', '        multisig.transfer(this.balance);               \n', '    }\n', '\n', '\n', '\n', '    // @notice Failsafe token transfer\n', '    function tokenDrian() external onlyOwner() {\n', '       if (block.number > endBlock) {\n', '        if (!token.transfer(team, token.balanceOf(this))) \n', '                revert();\n', '        }\n', '    }\n', '    \n', '\n', '\n', '    function refund()  external stopInEmergency returns (bool) {\n', '\n', '        require(totalTokensSent < minCap); \n', '        require(this.balance > 0);  // contract will hold 0 ether at the end of campaign.                                  \n', '                                    // contract needs to be funded through fundContract() \n', '\n', '        Backer storage backer = backers[msg.sender];\n', '\n', '        if (backer.weiReceived == 0)\n', '            revert();\n', '\n', '        require(!backer.refunded);\n', '        require(backer.tokensSent != 0);\n', '\n', '        if (!token.burn(msg.sender, backer.tokensSent))\n', '            revert();\n', '        backer.refunded = true;\n', '      \n', '        refundCount ++;\n', '        totalRefunded = totalRefunded.add(backer.weiReceived);\n', '        msg.sender.transfer(backer.weiReceived);\n', '        RefundETH(msg.sender, backer.weiReceived);\n', '        return true;\n', '    }\n', '}\n', '\n', '// The token\n', 'contract Token is ERC20,  Ownable {\n', '\n', '    using SafeMath for uint;\n', '    // Public variables of the token\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals; // How many decimals to show.\n', '    string public version = "v0.1";       \n', '    uint public totalSupply;\n', '    bool public locked;\n', '    address public crowdSaleAddress;\n', '    \n', '\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    // tokens are locked during the ICO. Allow transfer of tokens after ICO. \n', '    modifier onlyUnlocked() {\n', '        if (msg.sender != crowdSaleAddress && locked) \n', '            revert();\n', '        _;\n', '    }\n', '\n', '\n', '    // allow burning of tokens only by authorized users \n', '    modifier onlyAuthorized() {\n', '        if (msg.sender != owner && msg.sender != crowdSaleAddress ) \n', '            revert();\n', '        _;\n', '    }\n', '\n', '\n', '    // The Token \n', '    function Token(address _crowdSaleAddress) public {\n', '        \n', '        locked = true;  // Lock the transfCrowdsaleer function during the crowdsale\n', '        totalSupply = 21000000e18; \n', '        name = "Lottery Token"; // Set the name for display purposes\n', '        symbol = "ETHD"; // Set the symbol for display purposes\n', '        decimals = 18; // Amount of decimals for display purposes\n', '        crowdSaleAddress = _crowdSaleAddress;                                  \n', '        balances[crowdSaleAddress] = totalSupply;\n', '    }\n', '\n', '    function unlock() public onlyAuthorized {\n', '        locked = false;\n', '    }\n', '\n', '    function lock() public onlyAuthorized {\n', '        locked = true;\n', '    }\n', '    \n', '\n', '    function burn( address _member, uint256 _value) public onlyAuthorized returns(bool) {\n', '        balances[_member] = balances[_member].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        Transfer(_member, 0x0, _value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public onlyUnlocked returns(bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns(bool success) {\n', '        require (balances[_from] >= _value); // Check if the sender has enough                            \n', '        require (_value <= allowed[_from][msg.sender]); // Check if allowed is greater or equal        \n', '        balances[_from] = balances[_from].sub(_value); // Subtract from the sender\n', '        balances[_to] = balances[_to].add(_value); // Add the same to the recipient\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns(uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    *\n', '    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint _value) public returns(bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    function allowance(address _owner, address _spender) public constant returns(uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '    * approve should be called when allowed[_spender] == 0. To increment\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    */\n', '    function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '        allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}']