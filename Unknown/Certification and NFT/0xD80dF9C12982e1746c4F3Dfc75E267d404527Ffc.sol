['pragma solidity ^0.4.13;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint a, uint b) internal constant returns (uint) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint a, uint b) internal constant returns (uint) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '/**\n', ' * Interface for defining crowdsale ceiling.\n', ' */\n', 'contract CeilingStrategy {\n', '\n', '  /** Interface declaration. */\n', '  function isCeilingStrategy() public constant returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * When somebody tries to buy tokens for X wei, calculate how many weis they are allowed to use.\n', '   *\n', '   *\n', '   * @param _value - What is the value of the transaction sent in as wei.\n', '   * @param _weiRaised - How much money has been raised so far.\n', '   * @param _weiInvestedBySender - the investment made by the address that is sending the transaction.\n', '   * @param _weiFundingCap - the caller&#39;s declared total cap. May be reinterpreted by the implementation of the CeilingStrategy.\n', '   * @return Amount of wei the crowdsale can receive.\n', '   */\n', '  function weiAllowedToReceive(uint _value, uint _weiRaised, uint _weiInvestedBySender, uint _weiFundingCap) public constant returns (uint amount);\n', '\n', '  function isCrowdsaleFull(uint _weiRaised, uint _weiFundingCap) public constant returns (bool);\n', '\n', '  /**\n', '   * Calculate a new cap if the provided one is not above the amount already raised.\n', '   *\n', '   *\n', '   * @param _newCap - The potential new cap.\n', '   * @param _weiRaised - How much money has been raised so far.\n', '   * @return The adjusted cap.\n', '   */\n', '  function relaxFundingCap(uint _newCap, uint _weiRaised) public constant returns (uint);\n', '\n', '}\n', '\n', '/**\n', ' * Fixed cap investment per address and crowdsale\n', ' */\n', 'contract FixedCeiling is CeilingStrategy {\n', '    using SafeMath for uint;\n', '\n', '    /* When relaxing a cap is necessary, we use this multiple to determine the relaxed cap */\n', '    uint public chunkedWeiMultiple;\n', '    /* The limit an individual address can invest */\n', '    uint public weiLimitPerAddress;\n', '\n', '    function FixedCeiling(uint multiple, uint limit) {\n', '        chunkedWeiMultiple = multiple;\n', '        weiLimitPerAddress = limit;\n', '    }\n', '\n', '    function weiAllowedToReceive(uint tentativeAmount, uint weiRaised, uint weiInvestedBySender, uint weiFundingCap) public constant returns (uint) {\n', '        // First, we limit per address investment\n', '        uint totalOfSender = tentativeAmount.add(weiInvestedBySender);\n', '        if (totalOfSender > weiLimitPerAddress) tentativeAmount = weiLimitPerAddress.sub(weiInvestedBySender);\n', '        // Then, we check the funding cap\n', '        if (weiFundingCap == 0) return tentativeAmount;\n', '        uint total = tentativeAmount.add(weiRaised);\n', '        if (total < weiFundingCap) return tentativeAmount;\n', '        else return weiFundingCap.sub(weiRaised);\n', '    }\n', '\n', '    function isCrowdsaleFull(uint weiRaised, uint weiFundingCap) public constant returns (bool) {\n', '        return weiFundingCap > 0 && weiRaised >= weiFundingCap;\n', '    }\n', '\n', '    /* If the new target cap has not been reached yet, it&#39;s fine as it is */\n', '    function relaxFundingCap(uint newCap, uint weiRaised) public constant returns (uint) {\n', '        if (newCap > weiRaised) return newCap;\n', '        else return weiRaised.div(chunkedWeiMultiple).add(1).mul(chunkedWeiMultiple);\n', '    }\n', '\n', '}']