['pragma solidity ^0.4.16;\n', '\n', '// SafeMath Taken From FirstBlood\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', '// Ownership\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '    modifier onlyOwner { assert(msg.sender == owner); _; }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', '// ERC20 Interface\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint _totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '// ERC20Token\n', 'contract ERC20Token is ERC20, SafeMath {\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalTokens; \n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '            balances[_to] = safeAdd(balances[_to], _value);\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        var _allowance = allowed[_from][msg.sender];\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] = safeAdd(balances[_to], _value);\n', '            balances[_from] = safeSub(balances[_from], _value);\n', '            allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256) {\n', '        return totalTokens;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract Wolk is ERC20Token, Owned {\n', '\n', '    // TOKEN INFO\n', '    string  public constant name = "Wolk Protocol Token";\n', '    string  public constant symbol = "WOLK";\n', '    uint256 public constant decimals = 18;\n', '\n', '    // RESERVE\n', '    uint256 public reserveBalance = 0; \n', '    uint8  public constant percentageETHReserve = 15;\n', '\n', '    // CONTRACT OWNER\n', '    address public multisigWallet;\n', '\n', '\n', '    // WOLK SETTLERS\n', '    mapping (address => bool) settlers;\n', '    modifier onlySettler { assert(settlers[msg.sender] == true); _; }\n', '\n', '    // TOKEN GENERATION CONTROL\n', '    address public wolkSale;\n', '    bool    public allSaleCompleted = false;\n', '    bool    public openSaleCompleted = false;\n', '    modifier isTransferable { require(allSaleCompleted); _; }\n', '    modifier onlyWolk { assert(msg.sender == wolkSale); _; }\n', '\n', '    // TOKEN GENERATION EVENTLOG\n', '    event WolkCreated(address indexed _to, uint256 _tokenCreated);\n', '    event WolkDestroyed(address indexed _from, uint256 _tokenDestroyed);\n', '    event LogRefund(address indexed _to, uint256 _value);\n', '}\n', '\n', 'contract WolkTGE is Wolk {\n', '\n', '    // TOKEN GENERATION EVENT\n', '    mapping (address => uint256) contribution;\n', '    mapping (address => uint256) presaleLimit;\n', '    mapping (address => bool) presaleContributor;\n', '    uint256 public constant tokenGenerationMin = 50 * 10**6 * 10**decimals;\n', '    uint256 public constant tokenGenerationMax = 150 * 10**6 * 10**decimals;\n', '    uint256 public presale_start_block; \n', '    uint256 public start_block;\n', '    uint256 public end_block;\n', '\n', '    // @param _presaleStartBlock\n', '    // @param _startBlock\n', '    // @param _endBlock\n', '    // @param _wolkWallet\n', '    // @param _wolkSale\n', '    // @return success\n', '    // @dev Wolk Genesis Event [only accessible by Contract Owner]\n', '    function wolkGenesis(uint256 _presaleStartBlock, uint256 _startBlock, uint256 _endBlock, address _wolkWallet, address _wolkSale) onlyOwner returns (bool success){\n', '        require((totalTokens < 1) && (block.number <= _startBlock) && (_endBlock > _startBlock) && (_startBlock > _presaleStartBlock));\n', '        presale_start_block = _presaleStartBlock;\n', '        start_block = _startBlock;\n', '        end_block = _endBlock;\n', '        multisigWallet = _wolkWallet;\n', '        wolkSale = _wolkSale;\n', '        settlers[msg.sender] = true;\n', '        return true;\n', '    }\n', '\n', '    // @param _presaleParticipants\n', '    // @return success\n', '    // @dev Adds addresses that are allowed to take part in presale [only accessible by current Contract Owner]\n', '    function addParticipant(address[] _presaleParticipants, uint256[] _contributionLimits) onlyOwner returns (bool success) {\n', '        require(_presaleParticipants.length == _contributionLimits.length);         \n', '        for (uint cnt = 0; cnt < _presaleParticipants.length; cnt++){           \n', '            presaleContributor[_presaleParticipants[cnt]] = true;\n', '            presaleLimit[_presaleParticipants[cnt]] =  safeMul(_contributionLimits[cnt], 10**decimals);       \n', '        }\n', '        return true;\n', '    } \n', '\n', '    // @param _presaleParticipants\n', '    // @return success\n', '    // @dev Revoke designated presale contributors [only accessible by current Contract Owner]\n', '    function removeParticipant(address[] _presaleParticipants) onlyOwner returns (bool success){         \n', '        for (uint cnt = 0; cnt < _presaleParticipants.length; cnt++){           \n', '            presaleContributor[_presaleParticipants[cnt]] = false;\n', '            presaleLimit[_presaleParticipants[cnt]] = 0;      \n', '        }\n', '        return true;\n', '    }\n', '\n', '    // @param _participant\n', '    // @return remainingAllocation\n', '    // @dev return PresaleLimit allocated to given address\n', '    function participantBalance(address _participant) constant returns (uint256 remainingAllocation) {\n', '        return presaleLimit[_participant];\n', '    }\n', '    \n', '\n', '    // @param _participant\n', '    // @dev use tokenGenerationEvent to handle Pre-sale and Open-sale\n', '    function tokenGenerationEvent(address _participant) payable external {\n', '        require( presaleContributor[_participant] && !openSaleCompleted && !allSaleCompleted && (block.number <= end_block) && msg.value > 0);\n', '\n', '        /* Early Participation Discount (rounded to the nearest integer)\n', '        ---------------------------------\n', '        | Token Issued | Rate | Discount|\n', '        ---------------------------------\n', '        |   0  -  50MM | 1177 |  15.0%  |\n', '        | 50MM -  60MM | 1143 |  12.5%  |\n', '        | 60MM -  70MM | 1111 |  10.0%  |\n', '        | 70MM -  80MM | 1081 |   7.5%  |\n', '        | 80MM -  90MM | 1053 |   5.0%  |         \n', '        | 90MM - 100MM | 1026 |   2.5%  |\n', '        |    100MM+    | 1000 |   0.0%  |\n', '        ---------------------------------\n', '        */\n', '\n', '        uint256 rate = 1000;  // Default Rate\n', '\n', '        if ( totalTokens < (50 * 10**6 * 10**decimals) ) {  \n', '            rate = 1177;\n', '        } else if ( totalTokens < (60 * 10**6 * 10**decimals) ) {  \n', '            rate = 1143;\n', '        } else if ( totalTokens < (70 * 10**6 * 10**decimals) ) {  \n', '            rate = 1111;\n', '        } else if ( totalTokens < (80 * 10**6 * 10**decimals) ) {  \n', '            rate = 1081;\n', '        } else if ( totalTokens < (90 * 10**6 * 10**decimals) ) {  \n', '            rate = 1053;\n', '        } else if ( totalTokens < (100 * 10**6 * 10**decimals) ) {  \n', '            rate = 1026;\n', '        }else{\n', '            rate = 1000;\n', '        }\n', '\n', '        if ((block.number < start_block) && (block.number >= presale_start_block))  { \n', '            require(presaleLimit[_participant] >= msg.value);\n', '            presaleLimit[_participant] = safeSub(presaleLimit[_participant], msg.value);\n', '        } else {\n', '            require(block.number >= start_block) ;\n', '        }\n', '\n', '        uint256 tokens = safeMul(msg.value, rate);\n', '        uint256 checkedSupply = safeAdd(totalTokens, tokens);\n', '        require(checkedSupply <= tokenGenerationMax);\n', '\n', '        totalTokens = checkedSupply;\n', '        Transfer(address(this), _participant, tokens);\n', '        balances[_participant] = safeAdd(balances[_participant], tokens);\n', '        contribution[_participant] = safeAdd(contribution[_participant], msg.value);\n', '        WolkCreated(_participant, tokens); // logs token creation\n', '    }\n', '\n', '\n', '    // @dev If Token Generation Minimum is Not Met, TGE Participants can call this func and request for refund\n', '    function refund() external {\n', '        require((contribution[msg.sender] > 0) && (!allSaleCompleted) && (totalTokens < tokenGenerationMin) && (block.number > end_block));\n', '        uint256 tokenBalance = balances[msg.sender];\n', '        uint256 refundBalance = contribution[msg.sender];\n', '        balances[msg.sender] = 0;\n', '        contribution[msg.sender] = 0;\n', '        totalTokens = safeSub(totalTokens, tokenBalance);\n', '        WolkDestroyed(msg.sender, tokenBalance);\n', '        LogRefund(msg.sender, refundBalance);\n', '        msg.sender.transfer(refundBalance); \n', '    }\n', '\n', '    // @dev Finalizing the Open-Sale for Token Generation Event. 15% of Eth will be kept in contract to provide liquidity\n', '    function finalizeOpenSale() onlyOwner {\n', '        require((!openSaleCompleted) && (totalTokens >= tokenGenerationMin));\n', '        openSaleCompleted = true;\n', '        end_block = block.number;\n', '        reserveBalance = safeDiv(safeMul(totalTokens, percentageETHReserve), 100000);\n', '        var withdrawalBalance = safeSub(this.balance, reserveBalance);\n', '        msg.sender.transfer(withdrawalBalance);\n', '    }\n', '\n', '    // @dev Finalizing the Private-Sale. Entire Eth will be kept in contract to provide liquidity. This func will conclude the entire sale.\n', '    function finalize() onlyWolk payable external {\n', '        require((openSaleCompleted) && (!allSaleCompleted));                                                                                                    \n', '        uint256 privateSaleTokens =  safeDiv(safeMul(msg.value, 100000), percentageETHReserve);\n', '        uint256 checkedSupply = safeAdd(totalTokens, privateSaleTokens);                                                                                                \n', '        totalTokens = checkedSupply;                                                                                                                         \n', '        reserveBalance = safeAdd(reserveBalance, msg.value);                                                                                                 \n', '        Transfer(address(this), wolkSale, privateSaleTokens);                                                                                                              \n', '        balances[wolkSale] = safeAdd(balances[wolkSale], privateSaleTokens);                                                                                                  \n', '        WolkCreated(wolkSale, privateSaleTokens); // logs token creation for Presale events                                                                                                 \n', '        allSaleCompleted = true;                                                                                                                                \n', '    }\n', '}\n', '\n', 'contract IBurnFormula {\n', '    function calculateWolkToBurn(uint256 _value) public constant returns (uint256);\n', '}\n', '\n', 'contract IFeeFormula {\n', '    function calculateProviderFee(uint256 _value) public constant returns (uint256);\n', '}\n', '\n', 'contract WolkProtocol is Wolk {\n', '\n', '    // WOLK NETWORK PROTOCOL\n', '    address public burnFormula;\n', '    bool    public settlementIsRunning = true;\n', '    uint256 public burnBasisPoints = 500;  // Burn rate (in BP) when Service Provider withdraws from data buyers&#39; accounts\n', '    mapping (address => mapping (address => bool)) authorized; // holds which accounts have approved which Service Providers\n', '    mapping (address => uint256) feeBasisPoints;   // Fee (in BP) earned by Service Provider when depositing to data seller\n', '    mapping (address => address) feeFormulas;      // Provider&#39;s customizable Fee mormula\n', '    modifier isSettleable { require(settlementIsRunning); _; }\n', '\n', '\n', '    // WOLK PROTOCOL Events:\n', '    event AuthorizeServiceProvider(address indexed _owner, address _serviceProvider);\n', '    event DeauthorizeServiceProvider(address indexed _owner, address _serviceProvider);\n', '    event SetServiceProviderFee(address indexed _serviceProvider, uint256 _feeBasisPoints);\n', '    event BurnTokens(address indexed _from, address indexed _serviceProvider, uint256 _value);\n', '\n', '    // @param  _burnBasisPoints\n', '    // @return success\n', '    // @dev Set BurnRate on Wolk Protocol -- only Wolk can set this, affects Service Provider settleBuyer\n', '    function setBurnRate(uint256 _burnBasisPoints) onlyOwner returns (bool success) {\n', '        require((_burnBasisPoints > 0) && (_burnBasisPoints <= 1000));\n', '        burnBasisPoints = _burnBasisPoints;\n', '        return true;\n', '    }\n', '    \n', '    // @param  _newBurnFormula\n', '    // @return success\n', '    // @dev Set the formula to use for burning -- only Wolk  can set this\n', '    function setBurnFormula(address _newBurnFormula) onlyOwner returns (bool success){\n', '        uint256 testBurning = estWolkToBurn(_newBurnFormula, 10 ** 18);\n', '        require(testBurning > (5 * 10 ** 13));\n', '        burnFormula = _newBurnFormula;\n', '        return true;\n', '    }\n', '    \n', '    // @param  _newFeeFormula\n', '    // @return success\n', '    // @dev Set the formula to use for settlement -- settler can customize its fee  \n', '    function setFeeFormula(address _newFeeFormula) onlySettler returns (bool success){\n', '        uint256 testSettling = estProviderFee(_newFeeFormula, 10 ** 18);\n', '        require(testSettling > (5 * 10 ** 13));\n', '        feeFormulas[msg.sender] = _newFeeFormula;\n', '        return true;\n', '    }\n', '    \n', '    // @param  _isRunning\n', '    // @return success\n', '    // @dev upating settlement status -- only Wolk can set this\n', '    function updateSettlementStatus(bool _isRunning) onlyOwner returns (bool success){\n', '        settlementIsRunning = _isRunning;\n', '        return true;\n', '    }\n', '    \n', '    // @param  _serviceProvider\n', '    // @param  _feeBasisPoints\n', '    // @return success\n', '    // @dev Set Service Provider fee -- only Contract Owner can do this, affects Service Provider settleSeller\n', '    function setServiceFee(address _serviceProvider, uint256 _feeBasisPoints) onlyOwner returns (bool success) {\n', '        if (_feeBasisPoints <= 0 || _feeBasisPoints > 4000){\n', '            // revoke Settler privilege\n', '            settlers[_serviceProvider] = false;\n', '            feeBasisPoints[_serviceProvider] = 0;\n', '            return false;\n', '        }else{\n', '            feeBasisPoints[_serviceProvider] = _feeBasisPoints;\n', '            settlers[_serviceProvider] = true;\n', '            SetServiceProviderFee(_serviceProvider, _feeBasisPoints);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    // @param  _serviceProvider\n', '    // @return _feeBasisPoints\n', '    // @dev Check service Fee (in BP) for a given provider\n', '    function checkServiceFee(address _serviceProvider) constant returns (uint256 _feeBasisPoints) {\n', '        return feeBasisPoints[_serviceProvider];\n', '    }\n', '\n', '    // @param _serviceProvider\n', '    // @return _formulaAddress\n', '    // @dev Returns the contract address of the Service Provider&#39;s fee formula\n', '    function checkFeeSchedule(address _serviceProvider) constant returns (address _formulaAddress) {\n', '        return feeFormulas[_serviceProvider];\n', '    }\n', '    \n', '    // @param _value\n', '    // @return wolkBurnt\n', '    // @dev Returns estimate of Wolk to burn \n', '    function estWolkToBurn(address _burnFormula, uint256 _value) constant internal returns (uint256){\n', '        if(_burnFormula != 0x0){\n', '            uint256 wolkBurnt = IBurnFormula(_burnFormula).calculateWolkToBurn(_value);\n', '            return wolkBurnt;    \n', '        }else{\n', '            return 0; \n', '        }\n', '    }\n', '    \n', '    // @param _value\n', '    // @param _serviceProvider\n', '    // @return estFee\n', '    // @dev Returns estimate of Service Provider&#39;s fee \n', '    function estProviderFee(address _serviceProvider, uint256 _value) constant internal returns (uint256){\n', '        address ProviderFeeFormula = feeFormulas[_serviceProvider];\n', '        if (ProviderFeeFormula != 0x0){\n', '            uint256 estFee = IFeeFormula(ProviderFeeFormula).calculateProviderFee(_value);\n', '            return estFee;      \n', '        }else{\n', '            return 0;  \n', '        }\n', '    }\n', '    \n', '    // @param  _buyer\n', '    // @param  _value\n', '    // @return success\n', '    // @dev Service Provider Settlement with Buyer: a small percent is burnt (set in setBurnRate, stored in burnBasisPoints) when funds are transferred from buyer to Service Provider [only accessible by settlers]\n', '    function settleBuyer(address _buyer, uint256 _value) onlySettler isSettleable returns (bool success) {\n', '        require((burnBasisPoints > 0) && (burnBasisPoints <= 1000) && authorized[_buyer][msg.sender]); // Buyer must authorize Service Provider \n', '        require(balances[_buyer] >= _value && _value > 0);\n', '        var WolkToBurn = estWolkToBurn(burnFormula, _value);\n', '        var burnCap = safeDiv(safeMul(_value, burnBasisPoints), 10000); //can not burn more than this\n', '\n', '        // If burn formula not found, use default burn rate. If Est to burn exceeds BurnCap, cut back to the cap\n', '        if (WolkToBurn < 1) WolkToBurn = burnCap;\n', '        if (WolkToBurn > burnCap) WolkToBurn = burnCap;\n', '            \n', '        var transferredToServiceProvider = safeSub(_value, WolkToBurn);\n', '        balances[_buyer] = safeSub(balances[_buyer], _value);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], transferredToServiceProvider);\n', '        totalTokens = safeSub(totalTokens, WolkToBurn);\n', '        Transfer(_buyer, msg.sender, transferredToServiceProvider);\n', '        Transfer(_buyer, 0x00000000000000000000, WolkToBurn);\n', '        BurnTokens(_buyer, msg.sender, WolkToBurn);\n', '        return true;\n', '    } \n', '\n', '    // @param  _seller\n', '    // @param  _value\n', '    // @return success\n', '    // @dev Service Provider Settlement with Seller: a small percent is kept by Service Provider (set in setServiceFee, stored in feeBasisPoints) when funds are transferred from Service Provider to seller [only accessible by settlers]\n', '    function settleSeller(address _seller, uint256 _value) onlySettler isSettleable returns (bool success) {\n', '        // Service Providers have a % max fee (e.g. 20%)\n', '        var serviceProviderBP = feeBasisPoints[msg.sender];\n', '        require((serviceProviderBP > 0) && (serviceProviderBP <= 4000) && (_value > 0));\n', '        var seviceFee = estProviderFee(msg.sender, _value);\n', '        var Maximumfee = safeDiv(safeMul(_value, serviceProviderBP), 10000);\n', '        \n', '        // If provider&#39;s fee formula not set, use default burn rate. If Est fee exceeds Maximumfee, cut back to the fee\n', '        if (seviceFee < 1) seviceFee = Maximumfee;  \n', '        if (seviceFee > Maximumfee) seviceFee = Maximumfee;\n', '        var transferredToSeller = safeSub(_value, seviceFee);\n', '        require(balances[msg.sender] >= transferredToSeller );\n', '        balances[_seller] = safeAdd(balances[_seller], transferredToSeller);\n', '        Transfer(msg.sender, _seller, transferredToSeller);\n', '        return true;\n', '    }\n', '\n', '    // @param _providerToAdd\n', '    // @return success\n', '    // @dev Buyer authorizes the Service Provider (to call settleBuyer). For security reason, _providerToAdd needs to be whitelisted by Wolk Inc first\n', '    function authorizeProvider(address _providerToAdd) returns (bool success) {\n', '        require(settlers[_providerToAdd]);\n', '        authorized[msg.sender][_providerToAdd] = true;\n', '        AuthorizeServiceProvider(msg.sender, _providerToAdd);\n', '        return true;\n', '    }\n', '\n', '    // @param _providerToRemove\n', '    // @return success\n', '    // @dev Buyer deauthorizes the Service Provider (from calling settleBuyer)\n', '    function deauthorizeProvider(address _providerToRemove) returns (bool success) {\n', '        authorized[msg.sender][_providerToRemove] = false;\n', '        DeauthorizeServiceProvider(msg.sender, _providerToRemove);\n', '        return true;\n', '    }\n', '\n', '    // @param _owner\n', '    // @param _serviceProvider\n', '    // @return authorizationStatus\n', '    // @dev Check authorization between account and Service Provider\n', '    function checkAuthorization(address _owner, address _serviceProvider) constant returns (bool authorizationStatus) {\n', '        return authorized[_owner][_serviceProvider];\n', '    }\n', '\n', '    // @param _owner\n', '    // @param _providerToAdd\n', '    // @return authorizationStatus\n', '    // @dev Grant authorization between account and Service Provider on buyers&#39; behalf [only accessible by Contract Owner]\n', '    // @note Explicit permission from balance owner MUST be obtained beforehand\n', '    function grantService(address _owner, address _providerToAdd) onlyOwner returns (bool authorizationStatus) {\n', '        var isPreauthorized = authorized[_owner][msg.sender];\n', '        if (isPreauthorized && settlers[_providerToAdd]) {\n', '            authorized[_owner][_providerToAdd] = true;\n', '            AuthorizeServiceProvider(msg.sender, _providerToAdd);\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // @param _owner\n', '    // @param _providerToRemove\n', '    // @return authorization_status\n', '    // @dev Revoke authorization between account and Service Provider on buyers&#39; behalf [only accessible by Contract Owner]\n', '    // @note Explicit permission from balance owner are NOT required for disabling ill-intent Service Provider\n', '    function removeService(address _owner, address _providerToRemove) onlyOwner returns (bool authorizationStatus) {\n', '        authorized[_owner][_providerToRemove] = false;\n', '        DeauthorizeServiceProvider(_owner, _providerToRemove);\n', '        return true;\n', '    }\n', '}\n', '\n', '// Taken from https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/BancorFormula.sol\n', 'contract IBancorFormula {\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint8 _reserveRatio, uint256 _depositAmount) public constant returns (uint256);\n', '    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint8 _reserveRatio, uint256 _sellAmount) public constant returns (uint256);\n', '}\n', '\n', 'contract WolkExchange is WolkProtocol, WolkTGE {\n', '\n', '    uint256 public maxPerExchangeBP = 50;\n', '    address public exchangeFormula;\n', '    bool    public exchangeIsRunning = false;\n', '    modifier isExchangable { require(exchangeIsRunning && allSaleCompleted); _; }\n', '    \n', '    // @param  _newExchangeformula\n', '    // @return success\n', '    // @dev Set the bancor formula to use -- only Wolk Inc can set this\n', '    function setExchangeFormula(address _newExchangeformula) onlyOwner returns (bool success){\n', '        require(sellWolkEstimate(10**decimals, _newExchangeformula) > 0);\n', '        require(purchaseWolkEstimate(10**decimals, _newExchangeformula) > 0);\n', '        exchangeIsRunning = false;\n', '        exchangeFormula = _newExchangeformula;\n', '        return true;\n', '    }\n', '    \n', '    // @param  _isRunning\n', '    // @return success\n', '    // @dev upating exchange status -- only Wolk Inc can set this\n', '    function updateExchangeStatus(bool _isRunning) onlyOwner returns (bool success){\n', '        if (_isRunning){\n', '            require(sellWolkEstimate(10**decimals, exchangeFormula) > 0);\n', '            require(purchaseWolkEstimate(10**decimals, exchangeFormula) > 0);   \n', '        }\n', '        exchangeIsRunning = _isRunning;\n', '        return true;\n', '    }\n', '    \n', '    // @param  _maxPerExchange\n', '    // @return success\n', '    // @dev Set max sell token amount per transaction -- only Wolk Inc can set this\n', '    function setMaxPerExchange(uint256 _maxPerExchange) onlyOwner returns (bool success) {\n', '        require((_maxPerExchange >= 10) && (_maxPerExchange <= 100));\n', '        maxPerExchangeBP = _maxPerExchange;\n', '        return true;\n', '    }\n', '\n', '    // @return Estimated Liquidation Cap\n', '    // @dev Liquidation Cap per transaction is used to ensure proper price discovery for Wolk Exchange \n', '    function estLiquidationCap() public constant returns (uint256) {\n', '        if (openSaleCompleted){\n', '            var liquidationMax  = safeDiv(safeMul(totalTokens, maxPerExchangeBP), 10000);\n', '            if (liquidationMax < 100 * 10**decimals){ \n', '                liquidationMax = 100 * 10**decimals;\n', '            }\n', '            return liquidationMax;   \n', '        }else{\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function sellWolkEstimate(uint256 _wolkAmountest, address _formula) internal returns(uint256) {\n', '        uint256 ethReceivable =  IBancorFormula(_formula).calculateSaleReturn(totalTokens, reserveBalance, percentageETHReserve, _wolkAmountest);\n', '        return ethReceivable;\n', '    }\n', '    \n', '    function purchaseWolkEstimate(uint256 _ethAmountest, address _formula) internal returns(uint256) {\n', '        uint256 wolkReceivable = IBancorFormula(_formula).calculatePurchaseReturn(totalTokens, reserveBalance, percentageETHReserve, _ethAmountest);\n', '        return wolkReceivable;\n', '    }\n', '    \n', '    // @param _wolkAmount\n', '    // @return ethReceivable\n', '    // @dev send Wolk into contract in exchange for eth, at an exchange rate based on the Bancor Protocol derivation and decrease totalSupply accordingly\n', '    function sellWolk(uint256 _wolkAmount) isExchangable() returns(uint256) {\n', '        uint256 sellCap = estLiquidationCap();\n', '        require((balances[msg.sender] >= _wolkAmount));\n', '        require(sellCap >= _wolkAmount);\n', '        uint256 ethReceivable = sellWolkEstimate(_wolkAmount,exchangeFormula);\n', '        require(this.balance > ethReceivable);\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _wolkAmount);\n', '        totalTokens = safeSub(totalTokens, _wolkAmount);\n', '        reserveBalance = safeSub(this.balance, ethReceivable);\n', '        WolkDestroyed(msg.sender, _wolkAmount);\n', '        Transfer(msg.sender, 0x00000000000000000000, _wolkAmount);\n', '        msg.sender.transfer(ethReceivable);\n', '        return ethReceivable;     \n', '    }\n', '\n', '    // @return wolkReceivable    \n', '    // @dev send eth into contract in exchange for Wolk tokens, at an exchange rate based on the Bancor Protocol derivation and increase totalSupply accordingly\n', '    function purchaseWolk(address _buyer) isExchangable() payable returns(uint256){\n', '        require(msg.value > 0);\n', '        uint256 wolkReceivable = purchaseWolkEstimate(msg.value, exchangeFormula);\n', '        require(wolkReceivable > 0);\n', '        totalTokens = safeAdd(totalTokens, wolkReceivable);\n', '        balances[_buyer] = safeAdd(balances[_buyer], wolkReceivable);\n', '        reserveBalance = safeAdd(reserveBalance, msg.value);\n', '        WolkCreated(_buyer, wolkReceivable);\n', '        Transfer(address(this),_buyer,wolkReceivable);\n', '        return wolkReceivable;\n', '    }\n', '\n', '    // @dev  fallback function for purchase\n', '    // @note Automatically fallback to tokenGenerationEvent before sale is completed. After the token generation event, fallback to purchaseWolk. Liquidity exchange will be enabled through updateExchangeStatus  \n', '    function () payable {\n', '        require(msg.value > 0);\n', '        if(!openSaleCompleted){\n', '            this.tokenGenerationEvent.value(msg.value)(msg.sender);\n', '        }else if (block.number >= end_block){\n', '            this.purchaseWolk.value(msg.value)(msg.sender);\n', '        }else{\n', '            revert();\n', '        }\n', '    }\n', '}']
['pragma solidity ^0.4.16;\n', '\n', '// SafeMath Taken From FirstBlood\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '}\n', '\n', '// Ownership\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '    modifier onlyOwner { assert(msg.sender == owner); _; }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '}\n', '\n', '// ERC20 Interface\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint _totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '// ERC20Token\n', 'contract ERC20Token is ERC20, SafeMath {\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    uint256 public totalTokens; \n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        if (balances[msg.sender] >= _value && _value > 0) {\n', '            balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '            balances[_to] = safeAdd(balances[_to], _value);\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        var _allowance = allowed[_from][msg.sender];\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '            balances[_to] = safeAdd(balances[_to], _value);\n', '            balances[_from] = safeSub(balances[_from], _value);\n', '            allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256) {\n', '        return totalTokens;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract Wolk is ERC20Token, Owned {\n', '\n', '    // TOKEN INFO\n', '    string  public constant name = "Wolk Protocol Token";\n', '    string  public constant symbol = "WOLK";\n', '    uint256 public constant decimals = 18;\n', '\n', '    // RESERVE\n', '    uint256 public reserveBalance = 0; \n', '    uint8  public constant percentageETHReserve = 15;\n', '\n', '    // CONTRACT OWNER\n', '    address public multisigWallet;\n', '\n', '\n', '    // WOLK SETTLERS\n', '    mapping (address => bool) settlers;\n', '    modifier onlySettler { assert(settlers[msg.sender] == true); _; }\n', '\n', '    // TOKEN GENERATION CONTROL\n', '    address public wolkSale;\n', '    bool    public allSaleCompleted = false;\n', '    bool    public openSaleCompleted = false;\n', '    modifier isTransferable { require(allSaleCompleted); _; }\n', '    modifier onlyWolk { assert(msg.sender == wolkSale); _; }\n', '\n', '    // TOKEN GENERATION EVENTLOG\n', '    event WolkCreated(address indexed _to, uint256 _tokenCreated);\n', '    event WolkDestroyed(address indexed _from, uint256 _tokenDestroyed);\n', '    event LogRefund(address indexed _to, uint256 _value);\n', '}\n', '\n', 'contract WolkTGE is Wolk {\n', '\n', '    // TOKEN GENERATION EVENT\n', '    mapping (address => uint256) contribution;\n', '    mapping (address => uint256) presaleLimit;\n', '    mapping (address => bool) presaleContributor;\n', '    uint256 public constant tokenGenerationMin = 50 * 10**6 * 10**decimals;\n', '    uint256 public constant tokenGenerationMax = 150 * 10**6 * 10**decimals;\n', '    uint256 public presale_start_block; \n', '    uint256 public start_block;\n', '    uint256 public end_block;\n', '\n', '    // @param _presaleStartBlock\n', '    // @param _startBlock\n', '    // @param _endBlock\n', '    // @param _wolkWallet\n', '    // @param _wolkSale\n', '    // @return success\n', '    // @dev Wolk Genesis Event [only accessible by Contract Owner]\n', '    function wolkGenesis(uint256 _presaleStartBlock, uint256 _startBlock, uint256 _endBlock, address _wolkWallet, address _wolkSale) onlyOwner returns (bool success){\n', '        require((totalTokens < 1) && (block.number <= _startBlock) && (_endBlock > _startBlock) && (_startBlock > _presaleStartBlock));\n', '        presale_start_block = _presaleStartBlock;\n', '        start_block = _startBlock;\n', '        end_block = _endBlock;\n', '        multisigWallet = _wolkWallet;\n', '        wolkSale = _wolkSale;\n', '        settlers[msg.sender] = true;\n', '        return true;\n', '    }\n', '\n', '    // @param _presaleParticipants\n', '    // @return success\n', '    // @dev Adds addresses that are allowed to take part in presale [only accessible by current Contract Owner]\n', '    function addParticipant(address[] _presaleParticipants, uint256[] _contributionLimits) onlyOwner returns (bool success) {\n', '        require(_presaleParticipants.length == _contributionLimits.length);         \n', '        for (uint cnt = 0; cnt < _presaleParticipants.length; cnt++){           \n', '            presaleContributor[_presaleParticipants[cnt]] = true;\n', '            presaleLimit[_presaleParticipants[cnt]] =  safeMul(_contributionLimits[cnt], 10**decimals);       \n', '        }\n', '        return true;\n', '    } \n', '\n', '    // @param _presaleParticipants\n', '    // @return success\n', '    // @dev Revoke designated presale contributors [only accessible by current Contract Owner]\n', '    function removeParticipant(address[] _presaleParticipants) onlyOwner returns (bool success){         \n', '        for (uint cnt = 0; cnt < _presaleParticipants.length; cnt++){           \n', '            presaleContributor[_presaleParticipants[cnt]] = false;\n', '            presaleLimit[_presaleParticipants[cnt]] = 0;      \n', '        }\n', '        return true;\n', '    }\n', '\n', '    // @param _participant\n', '    // @return remainingAllocation\n', '    // @dev return PresaleLimit allocated to given address\n', '    function participantBalance(address _participant) constant returns (uint256 remainingAllocation) {\n', '        return presaleLimit[_participant];\n', '    }\n', '    \n', '\n', '    // @param _participant\n', '    // @dev use tokenGenerationEvent to handle Pre-sale and Open-sale\n', '    function tokenGenerationEvent(address _participant) payable external {\n', '        require( presaleContributor[_participant] && !openSaleCompleted && !allSaleCompleted && (block.number <= end_block) && msg.value > 0);\n', '\n', '        /* Early Participation Discount (rounded to the nearest integer)\n', '        ---------------------------------\n', '        | Token Issued | Rate | Discount|\n', '        ---------------------------------\n', '        |   0  -  50MM | 1177 |  15.0%  |\n', '        | 50MM -  60MM | 1143 |  12.5%  |\n', '        | 60MM -  70MM | 1111 |  10.0%  |\n', '        | 70MM -  80MM | 1081 |   7.5%  |\n', '        | 80MM -  90MM | 1053 |   5.0%  |         \n', '        | 90MM - 100MM | 1026 |   2.5%  |\n', '        |    100MM+    | 1000 |   0.0%  |\n', '        ---------------------------------\n', '        */\n', '\n', '        uint256 rate = 1000;  // Default Rate\n', '\n', '        if ( totalTokens < (50 * 10**6 * 10**decimals) ) {  \n', '            rate = 1177;\n', '        } else if ( totalTokens < (60 * 10**6 * 10**decimals) ) {  \n', '            rate = 1143;\n', '        } else if ( totalTokens < (70 * 10**6 * 10**decimals) ) {  \n', '            rate = 1111;\n', '        } else if ( totalTokens < (80 * 10**6 * 10**decimals) ) {  \n', '            rate = 1081;\n', '        } else if ( totalTokens < (90 * 10**6 * 10**decimals) ) {  \n', '            rate = 1053;\n', '        } else if ( totalTokens < (100 * 10**6 * 10**decimals) ) {  \n', '            rate = 1026;\n', '        }else{\n', '            rate = 1000;\n', '        }\n', '\n', '        if ((block.number < start_block) && (block.number >= presale_start_block))  { \n', '            require(presaleLimit[_participant] >= msg.value);\n', '            presaleLimit[_participant] = safeSub(presaleLimit[_participant], msg.value);\n', '        } else {\n', '            require(block.number >= start_block) ;\n', '        }\n', '\n', '        uint256 tokens = safeMul(msg.value, rate);\n', '        uint256 checkedSupply = safeAdd(totalTokens, tokens);\n', '        require(checkedSupply <= tokenGenerationMax);\n', '\n', '        totalTokens = checkedSupply;\n', '        Transfer(address(this), _participant, tokens);\n', '        balances[_participant] = safeAdd(balances[_participant], tokens);\n', '        contribution[_participant] = safeAdd(contribution[_participant], msg.value);\n', '        WolkCreated(_participant, tokens); // logs token creation\n', '    }\n', '\n', '\n', '    // @dev If Token Generation Minimum is Not Met, TGE Participants can call this func and request for refund\n', '    function refund() external {\n', '        require((contribution[msg.sender] > 0) && (!allSaleCompleted) && (totalTokens < tokenGenerationMin) && (block.number > end_block));\n', '        uint256 tokenBalance = balances[msg.sender];\n', '        uint256 refundBalance = contribution[msg.sender];\n', '        balances[msg.sender] = 0;\n', '        contribution[msg.sender] = 0;\n', '        totalTokens = safeSub(totalTokens, tokenBalance);\n', '        WolkDestroyed(msg.sender, tokenBalance);\n', '        LogRefund(msg.sender, refundBalance);\n', '        msg.sender.transfer(refundBalance); \n', '    }\n', '\n', '    // @dev Finalizing the Open-Sale for Token Generation Event. 15% of Eth will be kept in contract to provide liquidity\n', '    function finalizeOpenSale() onlyOwner {\n', '        require((!openSaleCompleted) && (totalTokens >= tokenGenerationMin));\n', '        openSaleCompleted = true;\n', '        end_block = block.number;\n', '        reserveBalance = safeDiv(safeMul(totalTokens, percentageETHReserve), 100000);\n', '        var withdrawalBalance = safeSub(this.balance, reserveBalance);\n', '        msg.sender.transfer(withdrawalBalance);\n', '    }\n', '\n', '    // @dev Finalizing the Private-Sale. Entire Eth will be kept in contract to provide liquidity. This func will conclude the entire sale.\n', '    function finalize() onlyWolk payable external {\n', '        require((openSaleCompleted) && (!allSaleCompleted));                                                                                                    \n', '        uint256 privateSaleTokens =  safeDiv(safeMul(msg.value, 100000), percentageETHReserve);\n', '        uint256 checkedSupply = safeAdd(totalTokens, privateSaleTokens);                                                                                                \n', '        totalTokens = checkedSupply;                                                                                                                         \n', '        reserveBalance = safeAdd(reserveBalance, msg.value);                                                                                                 \n', '        Transfer(address(this), wolkSale, privateSaleTokens);                                                                                                              \n', '        balances[wolkSale] = safeAdd(balances[wolkSale], privateSaleTokens);                                                                                                  \n', '        WolkCreated(wolkSale, privateSaleTokens); // logs token creation for Presale events                                                                                                 \n', '        allSaleCompleted = true;                                                                                                                                \n', '    }\n', '}\n', '\n', 'contract IBurnFormula {\n', '    function calculateWolkToBurn(uint256 _value) public constant returns (uint256);\n', '}\n', '\n', 'contract IFeeFormula {\n', '    function calculateProviderFee(uint256 _value) public constant returns (uint256);\n', '}\n', '\n', 'contract WolkProtocol is Wolk {\n', '\n', '    // WOLK NETWORK PROTOCOL\n', '    address public burnFormula;\n', '    bool    public settlementIsRunning = true;\n', "    uint256 public burnBasisPoints = 500;  // Burn rate (in BP) when Service Provider withdraws from data buyers' accounts\n", '    mapping (address => mapping (address => bool)) authorized; // holds which accounts have approved which Service Providers\n', '    mapping (address => uint256) feeBasisPoints;   // Fee (in BP) earned by Service Provider when depositing to data seller\n', "    mapping (address => address) feeFormulas;      // Provider's customizable Fee mormula\n", '    modifier isSettleable { require(settlementIsRunning); _; }\n', '\n', '\n', '    // WOLK PROTOCOL Events:\n', '    event AuthorizeServiceProvider(address indexed _owner, address _serviceProvider);\n', '    event DeauthorizeServiceProvider(address indexed _owner, address _serviceProvider);\n', '    event SetServiceProviderFee(address indexed _serviceProvider, uint256 _feeBasisPoints);\n', '    event BurnTokens(address indexed _from, address indexed _serviceProvider, uint256 _value);\n', '\n', '    // @param  _burnBasisPoints\n', '    // @return success\n', '    // @dev Set BurnRate on Wolk Protocol -- only Wolk can set this, affects Service Provider settleBuyer\n', '    function setBurnRate(uint256 _burnBasisPoints) onlyOwner returns (bool success) {\n', '        require((_burnBasisPoints > 0) && (_burnBasisPoints <= 1000));\n', '        burnBasisPoints = _burnBasisPoints;\n', '        return true;\n', '    }\n', '    \n', '    // @param  _newBurnFormula\n', '    // @return success\n', '    // @dev Set the formula to use for burning -- only Wolk  can set this\n', '    function setBurnFormula(address _newBurnFormula) onlyOwner returns (bool success){\n', '        uint256 testBurning = estWolkToBurn(_newBurnFormula, 10 ** 18);\n', '        require(testBurning > (5 * 10 ** 13));\n', '        burnFormula = _newBurnFormula;\n', '        return true;\n', '    }\n', '    \n', '    // @param  _newFeeFormula\n', '    // @return success\n', '    // @dev Set the formula to use for settlement -- settler can customize its fee  \n', '    function setFeeFormula(address _newFeeFormula) onlySettler returns (bool success){\n', '        uint256 testSettling = estProviderFee(_newFeeFormula, 10 ** 18);\n', '        require(testSettling > (5 * 10 ** 13));\n', '        feeFormulas[msg.sender] = _newFeeFormula;\n', '        return true;\n', '    }\n', '    \n', '    // @param  _isRunning\n', '    // @return success\n', '    // @dev upating settlement status -- only Wolk can set this\n', '    function updateSettlementStatus(bool _isRunning) onlyOwner returns (bool success){\n', '        settlementIsRunning = _isRunning;\n', '        return true;\n', '    }\n', '    \n', '    // @param  _serviceProvider\n', '    // @param  _feeBasisPoints\n', '    // @return success\n', '    // @dev Set Service Provider fee -- only Contract Owner can do this, affects Service Provider settleSeller\n', '    function setServiceFee(address _serviceProvider, uint256 _feeBasisPoints) onlyOwner returns (bool success) {\n', '        if (_feeBasisPoints <= 0 || _feeBasisPoints > 4000){\n', '            // revoke Settler privilege\n', '            settlers[_serviceProvider] = false;\n', '            feeBasisPoints[_serviceProvider] = 0;\n', '            return false;\n', '        }else{\n', '            feeBasisPoints[_serviceProvider] = _feeBasisPoints;\n', '            settlers[_serviceProvider] = true;\n', '            SetServiceProviderFee(_serviceProvider, _feeBasisPoints);\n', '            return true;\n', '        }\n', '    }\n', '\n', '    // @param  _serviceProvider\n', '    // @return _feeBasisPoints\n', '    // @dev Check service Fee (in BP) for a given provider\n', '    function checkServiceFee(address _serviceProvider) constant returns (uint256 _feeBasisPoints) {\n', '        return feeBasisPoints[_serviceProvider];\n', '    }\n', '\n', '    // @param _serviceProvider\n', '    // @return _formulaAddress\n', "    // @dev Returns the contract address of the Service Provider's fee formula\n", '    function checkFeeSchedule(address _serviceProvider) constant returns (address _formulaAddress) {\n', '        return feeFormulas[_serviceProvider];\n', '    }\n', '    \n', '    // @param _value\n', '    // @return wolkBurnt\n', '    // @dev Returns estimate of Wolk to burn \n', '    function estWolkToBurn(address _burnFormula, uint256 _value) constant internal returns (uint256){\n', '        if(_burnFormula != 0x0){\n', '            uint256 wolkBurnt = IBurnFormula(_burnFormula).calculateWolkToBurn(_value);\n', '            return wolkBurnt;    \n', '        }else{\n', '            return 0; \n', '        }\n', '    }\n', '    \n', '    // @param _value\n', '    // @param _serviceProvider\n', '    // @return estFee\n', "    // @dev Returns estimate of Service Provider's fee \n", '    function estProviderFee(address _serviceProvider, uint256 _value) constant internal returns (uint256){\n', '        address ProviderFeeFormula = feeFormulas[_serviceProvider];\n', '        if (ProviderFeeFormula != 0x0){\n', '            uint256 estFee = IFeeFormula(ProviderFeeFormula).calculateProviderFee(_value);\n', '            return estFee;      \n', '        }else{\n', '            return 0;  \n', '        }\n', '    }\n', '    \n', '    // @param  _buyer\n', '    // @param  _value\n', '    // @return success\n', '    // @dev Service Provider Settlement with Buyer: a small percent is burnt (set in setBurnRate, stored in burnBasisPoints) when funds are transferred from buyer to Service Provider [only accessible by settlers]\n', '    function settleBuyer(address _buyer, uint256 _value) onlySettler isSettleable returns (bool success) {\n', '        require((burnBasisPoints > 0) && (burnBasisPoints <= 1000) && authorized[_buyer][msg.sender]); // Buyer must authorize Service Provider \n', '        require(balances[_buyer] >= _value && _value > 0);\n', '        var WolkToBurn = estWolkToBurn(burnFormula, _value);\n', '        var burnCap = safeDiv(safeMul(_value, burnBasisPoints), 10000); //can not burn more than this\n', '\n', '        // If burn formula not found, use default burn rate. If Est to burn exceeds BurnCap, cut back to the cap\n', '        if (WolkToBurn < 1) WolkToBurn = burnCap;\n', '        if (WolkToBurn > burnCap) WolkToBurn = burnCap;\n', '            \n', '        var transferredToServiceProvider = safeSub(_value, WolkToBurn);\n', '        balances[_buyer] = safeSub(balances[_buyer], _value);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], transferredToServiceProvider);\n', '        totalTokens = safeSub(totalTokens, WolkToBurn);\n', '        Transfer(_buyer, msg.sender, transferredToServiceProvider);\n', '        Transfer(_buyer, 0x00000000000000000000, WolkToBurn);\n', '        BurnTokens(_buyer, msg.sender, WolkToBurn);\n', '        return true;\n', '    } \n', '\n', '    // @param  _seller\n', '    // @param  _value\n', '    // @return success\n', '    // @dev Service Provider Settlement with Seller: a small percent is kept by Service Provider (set in setServiceFee, stored in feeBasisPoints) when funds are transferred from Service Provider to seller [only accessible by settlers]\n', '    function settleSeller(address _seller, uint256 _value) onlySettler isSettleable returns (bool success) {\n', '        // Service Providers have a % max fee (e.g. 20%)\n', '        var serviceProviderBP = feeBasisPoints[msg.sender];\n', '        require((serviceProviderBP > 0) && (serviceProviderBP <= 4000) && (_value > 0));\n', '        var seviceFee = estProviderFee(msg.sender, _value);\n', '        var Maximumfee = safeDiv(safeMul(_value, serviceProviderBP), 10000);\n', '        \n', "        // If provider's fee formula not set, use default burn rate. If Est fee exceeds Maximumfee, cut back to the fee\n", '        if (seviceFee < 1) seviceFee = Maximumfee;  \n', '        if (seviceFee > Maximumfee) seviceFee = Maximumfee;\n', '        var transferredToSeller = safeSub(_value, seviceFee);\n', '        require(balances[msg.sender] >= transferredToSeller );\n', '        balances[_seller] = safeAdd(balances[_seller], transferredToSeller);\n', '        Transfer(msg.sender, _seller, transferredToSeller);\n', '        return true;\n', '    }\n', '\n', '    // @param _providerToAdd\n', '    // @return success\n', '    // @dev Buyer authorizes the Service Provider (to call settleBuyer). For security reason, _providerToAdd needs to be whitelisted by Wolk Inc first\n', '    function authorizeProvider(address _providerToAdd) returns (bool success) {\n', '        require(settlers[_providerToAdd]);\n', '        authorized[msg.sender][_providerToAdd] = true;\n', '        AuthorizeServiceProvider(msg.sender, _providerToAdd);\n', '        return true;\n', '    }\n', '\n', '    // @param _providerToRemove\n', '    // @return success\n', '    // @dev Buyer deauthorizes the Service Provider (from calling settleBuyer)\n', '    function deauthorizeProvider(address _providerToRemove) returns (bool success) {\n', '        authorized[msg.sender][_providerToRemove] = false;\n', '        DeauthorizeServiceProvider(msg.sender, _providerToRemove);\n', '        return true;\n', '    }\n', '\n', '    // @param _owner\n', '    // @param _serviceProvider\n', '    // @return authorizationStatus\n', '    // @dev Check authorization between account and Service Provider\n', '    function checkAuthorization(address _owner, address _serviceProvider) constant returns (bool authorizationStatus) {\n', '        return authorized[_owner][_serviceProvider];\n', '    }\n', '\n', '    // @param _owner\n', '    // @param _providerToAdd\n', '    // @return authorizationStatus\n', "    // @dev Grant authorization between account and Service Provider on buyers' behalf [only accessible by Contract Owner]\n", '    // @note Explicit permission from balance owner MUST be obtained beforehand\n', '    function grantService(address _owner, address _providerToAdd) onlyOwner returns (bool authorizationStatus) {\n', '        var isPreauthorized = authorized[_owner][msg.sender];\n', '        if (isPreauthorized && settlers[_providerToAdd]) {\n', '            authorized[_owner][_providerToAdd] = true;\n', '            AuthorizeServiceProvider(msg.sender, _providerToAdd);\n', '            return true;\n', '        }else{\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // @param _owner\n', '    // @param _providerToRemove\n', '    // @return authorization_status\n', "    // @dev Revoke authorization between account and Service Provider on buyers' behalf [only accessible by Contract Owner]\n", '    // @note Explicit permission from balance owner are NOT required for disabling ill-intent Service Provider\n', '    function removeService(address _owner, address _providerToRemove) onlyOwner returns (bool authorizationStatus) {\n', '        authorized[_owner][_providerToRemove] = false;\n', '        DeauthorizeServiceProvider(_owner, _providerToRemove);\n', '        return true;\n', '    }\n', '}\n', '\n', '// Taken from https://github.com/bancorprotocol/contracts/blob/master/solidity/contracts/BancorFormula.sol\n', 'contract IBancorFormula {\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _reserveBalance, uint8 _reserveRatio, uint256 _depositAmount) public constant returns (uint256);\n', '    function calculateSaleReturn(uint256 _supply, uint256 _reserveBalance, uint8 _reserveRatio, uint256 _sellAmount) public constant returns (uint256);\n', '}\n', '\n', 'contract WolkExchange is WolkProtocol, WolkTGE {\n', '\n', '    uint256 public maxPerExchangeBP = 50;\n', '    address public exchangeFormula;\n', '    bool    public exchangeIsRunning = false;\n', '    modifier isExchangable { require(exchangeIsRunning && allSaleCompleted); _; }\n', '    \n', '    // @param  _newExchangeformula\n', '    // @return success\n', '    // @dev Set the bancor formula to use -- only Wolk Inc can set this\n', '    function setExchangeFormula(address _newExchangeformula) onlyOwner returns (bool success){\n', '        require(sellWolkEstimate(10**decimals, _newExchangeformula) > 0);\n', '        require(purchaseWolkEstimate(10**decimals, _newExchangeformula) > 0);\n', '        exchangeIsRunning = false;\n', '        exchangeFormula = _newExchangeformula;\n', '        return true;\n', '    }\n', '    \n', '    // @param  _isRunning\n', '    // @return success\n', '    // @dev upating exchange status -- only Wolk Inc can set this\n', '    function updateExchangeStatus(bool _isRunning) onlyOwner returns (bool success){\n', '        if (_isRunning){\n', '            require(sellWolkEstimate(10**decimals, exchangeFormula) > 0);\n', '            require(purchaseWolkEstimate(10**decimals, exchangeFormula) > 0);   \n', '        }\n', '        exchangeIsRunning = _isRunning;\n', '        return true;\n', '    }\n', '    \n', '    // @param  _maxPerExchange\n', '    // @return success\n', '    // @dev Set max sell token amount per transaction -- only Wolk Inc can set this\n', '    function setMaxPerExchange(uint256 _maxPerExchange) onlyOwner returns (bool success) {\n', '        require((_maxPerExchange >= 10) && (_maxPerExchange <= 100));\n', '        maxPerExchangeBP = _maxPerExchange;\n', '        return true;\n', '    }\n', '\n', '    // @return Estimated Liquidation Cap\n', '    // @dev Liquidation Cap per transaction is used to ensure proper price discovery for Wolk Exchange \n', '    function estLiquidationCap() public constant returns (uint256) {\n', '        if (openSaleCompleted){\n', '            var liquidationMax  = safeDiv(safeMul(totalTokens, maxPerExchangeBP), 10000);\n', '            if (liquidationMax < 100 * 10**decimals){ \n', '                liquidationMax = 100 * 10**decimals;\n', '            }\n', '            return liquidationMax;   \n', '        }else{\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function sellWolkEstimate(uint256 _wolkAmountest, address _formula) internal returns(uint256) {\n', '        uint256 ethReceivable =  IBancorFormula(_formula).calculateSaleReturn(totalTokens, reserveBalance, percentageETHReserve, _wolkAmountest);\n', '        return ethReceivable;\n', '    }\n', '    \n', '    function purchaseWolkEstimate(uint256 _ethAmountest, address _formula) internal returns(uint256) {\n', '        uint256 wolkReceivable = IBancorFormula(_formula).calculatePurchaseReturn(totalTokens, reserveBalance, percentageETHReserve, _ethAmountest);\n', '        return wolkReceivable;\n', '    }\n', '    \n', '    // @param _wolkAmount\n', '    // @return ethReceivable\n', '    // @dev send Wolk into contract in exchange for eth, at an exchange rate based on the Bancor Protocol derivation and decrease totalSupply accordingly\n', '    function sellWolk(uint256 _wolkAmount) isExchangable() returns(uint256) {\n', '        uint256 sellCap = estLiquidationCap();\n', '        require((balances[msg.sender] >= _wolkAmount));\n', '        require(sellCap >= _wolkAmount);\n', '        uint256 ethReceivable = sellWolkEstimate(_wolkAmount,exchangeFormula);\n', '        require(this.balance > ethReceivable);\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _wolkAmount);\n', '        totalTokens = safeSub(totalTokens, _wolkAmount);\n', '        reserveBalance = safeSub(this.balance, ethReceivable);\n', '        WolkDestroyed(msg.sender, _wolkAmount);\n', '        Transfer(msg.sender, 0x00000000000000000000, _wolkAmount);\n', '        msg.sender.transfer(ethReceivable);\n', '        return ethReceivable;     \n', '    }\n', '\n', '    // @return wolkReceivable    \n', '    // @dev send eth into contract in exchange for Wolk tokens, at an exchange rate based on the Bancor Protocol derivation and increase totalSupply accordingly\n', '    function purchaseWolk(address _buyer) isExchangable() payable returns(uint256){\n', '        require(msg.value > 0);\n', '        uint256 wolkReceivable = purchaseWolkEstimate(msg.value, exchangeFormula);\n', '        require(wolkReceivable > 0);\n', '        totalTokens = safeAdd(totalTokens, wolkReceivable);\n', '        balances[_buyer] = safeAdd(balances[_buyer], wolkReceivable);\n', '        reserveBalance = safeAdd(reserveBalance, msg.value);\n', '        WolkCreated(_buyer, wolkReceivable);\n', '        Transfer(address(this),_buyer,wolkReceivable);\n', '        return wolkReceivable;\n', '    }\n', '\n', '    // @dev  fallback function for purchase\n', '    // @note Automatically fallback to tokenGenerationEvent before sale is completed. After the token generation event, fallback to purchaseWolk. Liquidity exchange will be enabled through updateExchangeStatus  \n', '    function () payable {\n', '        require(msg.value > 0);\n', '        if(!openSaleCompleted){\n', '            this.tokenGenerationEvent.value(msg.value)(msg.sender);\n', '        }else if (block.number >= end_block){\n', '            this.purchaseWolk.value(msg.value)(msg.sender);\n', '        }else{\n', '            revert();\n', '        }\n', '    }\n', '}']
