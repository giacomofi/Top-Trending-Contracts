['pragma solidity ^0.4.15;\n', '\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic authorization control functions, this simplifies\n', '/// and the implementation of "user permissions".\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwnerCandidate;\n', '\n', '    event OwnershipRequested(address indexed _by, address indexed _to);\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    /// account.\n', '    function Ownable() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Reverts if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerCandidate() {\n', '        if (msg.sender != newOwnerCandidate) {\n', '            revert();\n', '        }\n', '\n', '        _;\n', '    }\n', '\n', '    /// @dev Proposes to transfer control of the contract to a newOwnerCandidate.\n', '    /// @param _newOwnerCandidate address The address to transfer ownership to.\n', '    function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\n', '        require(_newOwnerCandidate != address(0));\n', '\n', '        newOwnerCandidate = _newOwnerCandidate;\n', '\n', '        OwnershipRequested(msg.sender, newOwnerCandidate);\n', '    }\n', '\n', '    /// @dev Accept ownership transfer. This method needs to be called by the previously proposed owner.\n', '    function acceptOwnership() external onlyOwnerCandidate {\n', '        address previousOwner = owner;\n', '\n', '        owner = newOwnerCandidate;\n', '        newOwnerCandidate = address(0);\n', '\n', '        OwnershipTransferred(previousOwner, owner);\n', '    }\n', '}\n', '\n', '/// @title Math operations with safety checks\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', '        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', '/// @title ERC Token Standard #20 Interface (https://github.com/ethereum/EIPs/issues/20)\n', 'contract ERC20 {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/// @title Basic ERC20 token contract implementation.\n', '/// @dev Based on OpenZeppelin&#39;s StandardToken.\n', 'contract BasicToken is ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public totalSupply;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    mapping (address => uint256) balances;\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    /// @param _spender address The address which will spend the funds.\n', '    /// @param _value uint256 The amount of tokens to be spent.\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\n', '            revert();\n', '        }\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    /// @param _owner address The address which owns the funds.\n', '    /// @param _spender address The address which will spend the funds.\n', '    /// @return uint256 specifying the amount of tokens still available for the spender.\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    /// @dev Gets the balance of the specified address.\n', '    /// @param _owner address The address to query the the balance of.\n', '    /// @return uint256 representing the amount owned by the passed address.\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /// @dev transfer token to a specified address.\n', '    /// @param _to address The address to transfer to.\n', '    /// @param _value uint256 The amount to be transferred.\n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Transfer tokens from one address to another.\n', '    /// @param _from address The address which you want to send tokens from.\n', '    /// @param _to address The address which you want to transfer to.\n', '    /// @param _value uint256 the amount of tokens to be transferred.\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '        uint256 _allowance = allowed[_from][msg.sender];\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '}\n', '\n', '\n', '/// @title Token holder contract.\n', 'contract TokenHolder is Ownable {\n', '    /// @dev Allow the owner to transfer out any accidentally sent ERC20 tokens.\n', '    /// @param _tokenAddress address The address of the ERC20 contract.\n', '    /// @param _amount uint256 The amount of tokens to be transferred.\n', '    function transferAnyERC20Token(address _tokenAddress, uint256 _amount) onlyOwner returns (bool success) {\n', '        return ERC20(_tokenAddress).transfer(owner, _amount);\n', '    }\n', '}\n', '\n', '\n', '/// @title Kin token contract.\n', 'contract KinToken is Ownable, BasicToken, TokenHolder {\n', '    using SafeMath for uint256;\n', '\n', '    string public constant name = "Kin";\n', '    string public constant symbol = "KIN";\n', '\n', '    // Using same decimal value as ETH (makes ETH-KIN conversion much easier).\n', '    uint8 public constant decimals = 18;\n', '\n', '    // States whether creating more tokens is allowed or not.\n', '    // Used during token sale.\n', '    bool public isMinting = true;\n', '\n', '    event MintingEnded();\n', '\n', '    modifier onlyDuringMinting() {\n', '        require(isMinting);\n', '\n', '        _;\n', '    }\n', '\n', '    modifier onlyAfterMinting() {\n', '        require(!isMinting);\n', '\n', '        _;\n', '    }\n', '\n', '    /// @dev Mint Kin tokens.\n', '    /// @param _to address Address to send minted Kin to.\n', '    /// @param _amount uint256 Amount of Kin tokens to mint.\n', '    function mint(address _to, uint256 _amount) external onlyOwner onlyDuringMinting {\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '\n', '        Transfer(0x0, _to, _amount);\n', '    }\n', '\n', '    /// @dev End minting mode.\n', '    function endMinting() external onlyOwner {\n', '        if (isMinting == false) {\n', '            return;\n', '        }\n', '\n', '        isMinting = false;\n', '\n', '        MintingEnded();\n', '    }\n', '\n', '    /// @dev Same ERC20 behavior, but reverts if still minting.\n', '    /// @param _spender address The address which will spend the funds.\n', '    /// @param _value uint256 The amount of tokens to be spent.\n', '    function approve(address _spender, uint256 _value) public onlyAfterMinting returns (bool) {\n', '        return super.approve(_spender, _value);\n', '    }\n', '\n', '    /// @dev Same ERC20 behavior, but reverts if still minting.\n', '    /// @param _to address The address to transfer to.\n', '    /// @param _value uint256 The amount to be transferred.\n', '    function transfer(address _to, uint256 _value) public onlyAfterMinting returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /// @dev Same ERC20 behavior, but reverts if still minting.\n', '    /// @param _from address The address which you want to send tokens from.\n', '    /// @param _to address The address which you want to transfer to.\n', '    /// @param _value uint256 the amount of tokens to be transferred.\n', '    function transferFrom(address _from, address _to, uint256 _value) public onlyAfterMinting returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}\n', '\n', '\n', '/// @title Vesting trustee contract for Kin token.\n', 'contract VestingTrustee is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    // Kin token contract.\n', '    KinToken public kin;\n', '\n', '    // Vesting grant for a speicifc holder.\n', '    struct Grant {\n', '        uint256 value;\n', '        uint256 start;\n', '        uint256 cliff;\n', '        uint256 end;\n', '        uint256 installmentLength; // In seconds.\n', '        uint256 transferred;\n', '        bool revokable;\n', '    }\n', '\n', '    // Holder to grant information mapping.\n', '    mapping (address => Grant) public grants;\n', '\n', '    // Total tokens available for vesting.\n', '    uint256 public totalVesting;\n', '\n', '    event NewGrant(address indexed _from, address indexed _to, uint256 _value);\n', '    event TokensUnlocked(address indexed _to, uint256 _value);\n', '    event GrantRevoked(address indexed _holder, uint256 _refund);\n', '\n', '    /// @dev Constructor that initializes the address of the Kin token contract.\n', '    /// @param _kin KinToken The address of the previously deployed Kin token contract.\n', '    function VestingTrustee(KinToken _kin) {\n', '        require(_kin != address(0));\n', '\n', '        kin = _kin;\n', '    }\n', '\n', '    /// @dev Grant tokens to a specified address. Please note, that the trustee must have enough ungranted tokens to\n', '    /// accomodate the new grant. Otherwise, the call with fail.\n', '    /// @param _to address The holder address.\n', '    /// @param _value uint256 The amount of tokens to be granted.\n', '    /// @param _start uint256 The beginning of the vesting period.\n', '    /// @param _cliff uint256 Duration of the cliff period (when the first installment is made).\n', '    /// @param _end uint256 The end of the vesting period.\n', '    /// @param _installmentLength uint256 The length of each vesting installment (in seconds).\n', '    /// @param _revokable bool Whether the grant is revokable or not.\n', '    function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end,\n', '        uint256 _installmentLength, bool _revokable)\n', '        external onlyOwner {\n', '\n', '        require(_to != address(0));\n', '        require(_to != address(this)); // Protect this contract from receiving a grant.\n', '        require(_value > 0);\n', '\n', '        // Require that every holder can be granted tokens only once.\n', '        require(grants[_to].value == 0);\n', '\n', '        // Require for time ranges to be consistent and valid.\n', '        require(_start <= _cliff && _cliff <= _end);\n', '\n', '        // Require installment length to be valid and no longer than (end - start).\n', '        require(_installmentLength > 0 && _installmentLength <= _end.sub(_start));\n', '\n', '        // Grant must not exceed the total amount of tokens currently available for vesting.\n', '        require(totalVesting.add(_value) <= kin.balanceOf(address(this)));\n', '\n', '        // Assign a new grant.\n', '        grants[_to] = Grant({\n', '            value: _value,\n', '            start: _start,\n', '            cliff: _cliff,\n', '            end: _end,\n', '            installmentLength: _installmentLength,\n', '            transferred: 0,\n', '            revokable: _revokable\n', '        });\n', '\n', '        // Since tokens have been granted, reduce the total amount available for vesting.\n', '        totalVesting = totalVesting.add(_value);\n', '\n', '        NewGrant(msg.sender, _to, _value);\n', '    }\n', '\n', '    /// @dev Revoke the grant of tokens of a specifed address.\n', '    /// @param _holder The address which will have its tokens revoked.\n', '    function revoke(address _holder) public onlyOwner {\n', '        Grant memory grant = grants[_holder];\n', '\n', '        // Grant must be revokable.\n', '        require(grant.revokable);\n', '\n', '        // Calculate amount of remaining tokens that can still be returned.\n', '        uint256 refund = grant.value.sub(grant.transferred);\n', '\n', '        // Remove the grant.\n', '        delete grants[_holder];\n', '\n', '        // Update total vesting amount and transfer previously calculated tokens to owner.\n', '        totalVesting = totalVesting.sub(refund);\n', '        kin.transfer(msg.sender, refund);\n', '\n', '        GrantRevoked(_holder, refund);\n', '    }\n', '\n', '    /// @dev Calculate the total amount of vested tokens of a holder at a given time.\n', '    /// @param _holder address The address of the holder.\n', '    /// @param _time uint256 The specific time to calculate against.\n', '    /// @return a uint256 Representing a holder&#39;s total amount of vested tokens.\n', '    function vestedTokens(address _holder, uint256 _time) external constant returns (uint256) {\n', '        Grant memory grant = grants[_holder];\n', '        if (grant.value == 0) {\n', '            return 0;\n', '        }\n', '\n', '        return calculateVestedTokens(grant, _time);\n', '    }\n', '\n', '    /// @dev Calculate amount of vested tokens at a specifc time.\n', '    /// @param _grant Grant The vesting grant.\n', '    /// @param _time uint256 The time to be checked\n', '    /// @return An uint256 Representing the amount of vested tokens of a specific grant.\n', '    function calculateVestedTokens(Grant _grant, uint256 _time) private constant returns (uint256) {\n', '        // If we&#39;re before the cliff, then nothing is vested.\n', '        if (_time < _grant.cliff) {\n', '            return 0;\n', '        }\n', '\n', '        // If we&#39;re after the end of the vesting period - everything is vested;\n', '        if (_time >= _grant.end) {\n', '            return _grant.value;\n', '        }\n', '\n', '        // Calculate amount of installments past until now.\n', '        //\n', '        // NOTE result gets floored because of integer division.\n', '        uint256 installmentsPast = _time.sub(_grant.start).div(_grant.installmentLength);\n', '\n', '        // Calculate amount of days in entire vesting period.\n', '        uint256 vestingDays = _grant.end.sub(_grant.start);\n', '\n', '        // Calculate and return the number of tokens according to vesting days that have passed.\n', '        return _grant.value.mul(installmentsPast.mul(_grant.installmentLength)).div(vestingDays);\n', '    }\n', '\n', '    /// @dev Unlock vested tokens and transfer them to the grantee.\n', '    function unlockVestedTokens() external {\n', '        Grant storage grant = grants[msg.sender];\n', '\n', '        // Make sure the grant has tokens available.\n', '        require(grant.value != 0);\n', '\n', '        // Get the total amount of vested tokens, acccording to grant.\n', '        uint256 vested = calculateVestedTokens(grant, now);\n', '        if (vested == 0) {\n', '            return;\n', '        }\n', '\n', '        // Make sure the holder doesn&#39;t transfer more than what he already has.\n', '        uint256 transferable = vested.sub(grant.transferred);\n', '        if (transferable == 0) {\n', '            return;\n', '        }\n', '\n', '        // Update transferred and total vesting amount, then transfer remaining vested funds to holder.\n', '        grant.transferred = grant.transferred.add(transferable);\n', '        totalVesting = totalVesting.sub(transferable);\n', '        kin.transfer(msg.sender, transferable);\n', '\n', '        TokensUnlocked(msg.sender, transferable);\n', '    }\n', '}\n', '\n', '\n', '/// @title Kin token sale contract.\n', 'contract KinTokenSale is Ownable, TokenHolder {\n', '    using SafeMath for uint256;\n', '\n', '    // External parties:\n', '\n', '    // KIN token contract.\n', '    KinToken public kin;\n', '\n', '    // Vesting contract for pre-sale participants.\n', '    VestingTrustee public trustee;\n', '\n', '    // Received funds are forwarded to this address.\n', '    address public fundingRecipient;\n', '\n', '    // Kin token unit.\n', '    // Using same decimal value as ETH (makes ETH-KIN conversion much easier).\n', '    // This is the same as in Kin token contract.\n', '    uint256 public constant TOKEN_UNIT = 10 ** 18;\n', '\n', '    // Maximum number of tokens in circulation: 10 trillion.\n', '    uint256 public constant MAX_TOKENS = 10 ** 13 * TOKEN_UNIT;\n', '\n', '    // Maximum tokens offered in the sale.\n', '    uint256 public constant MAX_TOKENS_SOLD = 512195121951 * TOKEN_UNIT;\n', '\n', '    // Wei to 1 USD ratio.\n', '    uint256 public constant WEI_PER_USD = uint256(1 ether) / 289;\n', '\n', '    // KIN to 1 USD ratio,\n', '    // such that MAX_TOKENS_SOLD / KIN_PER_USD is the $75M cap.\n', '    uint256 public constant KIN_PER_USD = 6829 * TOKEN_UNIT;\n', '\n', '    // KIN to 1 wei ratio.\n', '    uint256 public constant KIN_PER_WEI = KIN_PER_USD / WEI_PER_USD;\n', '\n', '    // Sale start and end timestamps.\n', '    uint256 public constant SALE_DURATION = 14 days;\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '\n', '    // Amount of tokens sold until now in the sale.\n', '    uint256 public tokensSold = 0;\n', '\n', '    // Participation caps, according to KYC tiers.\n', '    uint256 public constant TIER_1_CAP = 100000 * WEI_PER_USD;\n', '    uint256 public constant TIER_2_CAP = uint256(-1); // Maximum uint256 value\n', '\n', '    // Accumulated amount each participant has contributed so far.\n', '    mapping (address => uint256) public participationHistory;\n', '\n', '    // Maximum amount that each participant is allowed to contribute (in WEI).\n', '    mapping (address => uint256) public participationCaps;\n', '\n', '    // Maximum amount ANYBODY is currently allowed to contribute.\n', '    uint256 public hardParticipationCap = 4393 * WEI_PER_USD;\n', '\n', '    // Vesting information for special addresses:\n', '    struct TokenGrant {\n', '        uint256 value;\n', '        uint256 startOffset;\n', '        uint256 cliffOffset;\n', '        uint256 endOffset;\n', '        uint256 installmentLength;\n', '        uint8 percentVested;\n', '    }\n', '\n', '    address[] public tokenGrantees;\n', '    mapping (address => TokenGrant) public tokenGrants;\n', '    uint256 public lastGrantedIndex = 0;\n', '    uint256 public constant MAX_TOKEN_GRANTEES = 100;\n', '    uint256 public constant GRANT_BATCH_SIZE = 10;\n', '\n', '    // Post-TDE multisig addresses.\n', '    address public constant KIN_FOUNDATION_ADDRESS = 0x56aE76573EC54754bC5B6A8cBF04bBd7Dc86b0A0;\n', '    address public constant KIK_ADDRESS = 0x3bf4BbE253153678E9E8E540395C22BFf7fCa87d;\n', '\n', '    event TokensIssued(address indexed _to, uint256 _tokens);\n', '\n', '    /// @dev Reverts if called when not during sale.\n', '    modifier onlyDuringSale() {\n', '        require(!saleEnded() && now >= startTime);\n', '\n', '        _;\n', '    }\n', '\n', '    /// @dev Reverts if called before sale ends.\n', '    modifier onlyAfterSale() {\n', '        require(saleEnded());\n', '\n', '        _;\n', '    }\n', '\n', '    /// @dev Constructor that initializes the sale conditions.\n', '    /// @param _fundingRecipient address The address of the funding recipient.\n', '    /// @param _startTime uint256 The start time of the token sale.\n', '    function KinTokenSale(address _fundingRecipient, uint256 _startTime) {\n', '        require(_fundingRecipient != address(0));\n', '        require(_startTime > now);\n', '\n', '        // Deploy new KinToken contract.\n', '        kin = new KinToken();\n', '\n', '        // Deploy new VestingTrustee contract.\n', '        trustee = new VestingTrustee(kin);\n', '\n', '        fundingRecipient = _fundingRecipient;\n', '        startTime = _startTime;\n', '        endTime = startTime + SALE_DURATION;\n', '\n', '        // Initialize special vesting grants.\n', '        initTokenGrants();\n', '    }\n', '\n', '    /// @dev Initialize token grants.\n', '    function initTokenGrants() private onlyOwner {\n', '        // Issue the remaining 60% to Kin Foundation&#39;s multisig wallet. In a few days, after the token sale is\n', '        // finalized, these tokens will be loaded into the KinVestingTrustee smart contract, according to the white\n', '        // paper. Please note, that this is implied by setting a 0% vesting percent.\n', '        tokenGrantees.push(KIN_FOUNDATION_ADDRESS);\n', '        tokenGrants[KIN_FOUNDATION_ADDRESS] = TokenGrant(MAX_TOKENS.mul(60).div(100), 0, 0, 3 years, 1 days, 0);\n', '\n', '        // Kik, 30%\n', '        tokenGrantees.push(KIK_ADDRESS);\n', '        tokenGrants[KIK_ADDRESS] = TokenGrant(MAX_TOKENS.mul(30).div(100), 0, 0, 120 weeks, 12 weeks, 100);\n', '    }\n', '\n', '    /// @dev Adds a Kin token vesting grant.\n', '    /// @param _grantee address The address of the token grantee. Can be granted only once.\n', '    /// @param _value uint256 The value of the grant.\n', '    function addTokenGrant(address _grantee, uint256 _value) external onlyOwner {\n', '        require(_grantee != address(0));\n', '        require(_value > 0);\n', '        require(tokenGrantees.length + 1 <= MAX_TOKEN_GRANTEES);\n', '\n', '        // Verify the grant doesn&#39;t already exist.\n', '        require(tokenGrants[_grantee].value == 0);\n', '        for (uint i = 0; i < tokenGrantees.length; i++) {\n', '            require(tokenGrantees[i] != _grantee);\n', '        }\n', '\n', '        // Add grant and add to grantee list.\n', '        tokenGrantees.push(_grantee);\n', '        tokenGrants[_grantee] = TokenGrant(_value, 0, 1 years, 1 years, 1 days, 50);\n', '    }\n', '\n', '    /// @dev Deletes a Kin token grant.\n', '    /// @param _grantee address The address of the token grantee.\n', '    function deleteTokenGrant(address _grantee) external onlyOwner {\n', '        require(_grantee != address(0));\n', '\n', '        // Delete the grant from the keys array.\n', '        for (uint i = 0; i < tokenGrantees.length; i++) {\n', '            if (tokenGrantees[i] == _grantee) {\n', '                delete tokenGrantees[i];\n', '\n', '                break;\n', '            }\n', '        }\n', '\n', '        // Delete the grant from the mapping.\n', '        delete tokenGrants[_grantee];\n', '    }\n', '\n', '    /// @dev Add a list of participants to a capped participation tier.\n', '    /// @param _participants address[] The list of participant addresses.\n', '    /// @param _cap uint256 The cap amount (in ETH).\n', '    function setParticipationCap(address[] _participants, uint256 _cap) private onlyOwner {\n', '        for (uint i = 0; i < _participants.length; i++) {\n', '            participationCaps[_participants[i]] = _cap;\n', '        }\n', '    }\n', '\n', '    /// @dev Add a list of participants to cap tier #1.\n', '    /// @param _participants address[] The list of participant addresses.\n', '    function setTier1Participants(address[] _participants) external onlyOwner {\n', '        setParticipationCap(_participants, TIER_1_CAP);\n', '    }\n', '\n', '    /// @dev Add a list of participants to tier #2.\n', '    /// @param _participants address[] The list of participant addresses.\n', '    function setTier2Participants(address[] _participants) external onlyOwner {\n', '        setParticipationCap(_participants, TIER_2_CAP);\n', '    }\n', '\n', '    /// @dev Set hard participation cap for all participants.\n', '    /// @param _cap uint256 The hard cap amount.\n', '    function setHardParticipationCap(uint256 _cap) external onlyOwner {\n', '        require(_cap > 0);\n', '\n', '        hardParticipationCap = _cap;\n', '    }\n', '\n', '    /// @dev Fallback function that will delegate the request to create().\n', '    function () external payable onlyDuringSale {\n', '        create(msg.sender);\n', '    }\n', '\n', '    /// @dev Create and sell tokens to the caller.\n', '    /// @param _recipient address The address of the recipient receiving the tokens.\n', '    function create(address _recipient) public payable onlyDuringSale {\n', '        require(_recipient != address(0));\n', '\n', '        // Enforce participation cap (in Wei received).\n', '        uint256 weiAlreadyParticipated = participationHistory[msg.sender];\n', '        uint256 participationCap = SafeMath.min256(participationCaps[msg.sender], hardParticipationCap);\n', '        uint256 cappedWeiReceived = SafeMath.min256(msg.value, participationCap.sub(weiAlreadyParticipated));\n', '        require(cappedWeiReceived > 0);\n', '\n', '        // Accept funds and transfer to funding recipient.\n', '        uint256 weiLeftInSale = MAX_TOKENS_SOLD.sub(tokensSold).div(KIN_PER_WEI);\n', '        uint256 weiToParticipate = SafeMath.min256(cappedWeiReceived, weiLeftInSale);\n', '        participationHistory[msg.sender] = weiAlreadyParticipated.add(weiToParticipate);\n', '        fundingRecipient.transfer(weiToParticipate);\n', '\n', '        // Issue tokens and transfer to recipient.\n', '        uint256 tokensLeftInSale = MAX_TOKENS_SOLD.sub(tokensSold);\n', '        uint256 tokensToIssue = weiToParticipate.mul(KIN_PER_WEI);\n', '        if (tokensLeftInSale.sub(tokensToIssue) < KIN_PER_WEI) {\n', '            // If purchase would cause less than KIN_PER_WEI tokens left then nobody could ever buy them.\n', '            // So, gift them to the last buyer.\n', '            tokensToIssue = tokensLeftInSale;\n', '        }\n', '        tokensSold = tokensSold.add(tokensToIssue);\n', '        issueTokens(_recipient, tokensToIssue);\n', '\n', '        // Partial refund if full participation not possible\n', '        // e.g. due to cap being reached.\n', '        uint256 refund = msg.value.sub(weiToParticipate);\n', '        if (refund > 0) {\n', '            msg.sender.transfer(refund);\n', '        }\n', '    }\n', '\n', '    /// @dev Finalizes the token sale event, by stopping token minting.\n', '    function finalize() external onlyAfterSale onlyOwner {\n', '        if (!kin.isMinting()) {\n', '            revert();\n', '        }\n', '\n', '        require(lastGrantedIndex == tokenGrantees.length);\n', '\n', '        // Finish minting.\n', '        kin.endMinting();\n', '    }\n', '\n', '    /// @dev Grants pre-configured token grants in batches. When the method is called, it&#39;ll resume from the last grant,\n', '    /// from its previous run, and will finish either after granting GRANT_BATCH_SIZE grants or finishing the whole list\n', '    /// of grants.\n', '    function grantTokens() external onlyAfterSale onlyOwner {\n', '        uint endIndex = SafeMath.min256(tokenGrantees.length, lastGrantedIndex + GRANT_BATCH_SIZE);\n', '        for (uint i = lastGrantedIndex; i < endIndex; i++) {\n', '            address grantee = tokenGrantees[i];\n', '\n', '            // Calculate how many tokens have been granted, vested, and issued such that: granted = vested + issued.\n', '            TokenGrant memory tokenGrant = tokenGrants[grantee];\n', '            uint256 tokensGranted = tokenGrant.value.mul(tokensSold).div(MAX_TOKENS_SOLD);\n', '            uint256 tokensVesting = tokensGranted.mul(tokenGrant.percentVested).div(100);\n', '            uint256 tokensIssued = tokensGranted.sub(tokensVesting);\n', '\n', '            // Transfer issued tokens that have yet to be transferred to grantee.\n', '            if (tokensIssued > 0) {\n', '                issueTokens(grantee, tokensIssued);\n', '            }\n', '\n', '            // Transfer vested tokens that have yet to be transferred to vesting trustee, and initialize grant.\n', '            if (tokensVesting > 0) {\n', '                issueTokens(trustee, tokensVesting);\n', '                trustee.grant(grantee, tokensVesting, now.add(tokenGrant.startOffset), now.add(tokenGrant.cliffOffset),\n', '                    now.add(tokenGrant.endOffset), tokenGrant.installmentLength, true);\n', '            }\n', '\n', '            lastGrantedIndex++;\n', '        }\n', '    }\n', '\n', '    /// @dev Issues tokens for the recipient.\n', '    /// @param _recipient address The address of the recipient.\n', '    /// @param _tokens uint256 The amount of tokens to issue.\n', '    function issueTokens(address _recipient, uint256 _tokens) private {\n', '        // Request Kin token contract to mint the requested tokens for the buyer.\n', '        kin.mint(_recipient, _tokens);\n', '\n', '        TokensIssued(_recipient, _tokens);\n', '    }\n', '\n', '    /// @dev Returns whether the sale has ended.\n', '    /// @return bool Whether the sale has ended or not.\n', '    function saleEnded() private constant returns (bool) {\n', '        return tokensSold >= MAX_TOKENS_SOLD || now >= endTime;\n', '    }\n', '\n', '    /// @dev Requests to transfer control of the Kin token contract to a new owner.\n', '    /// @param _newOwnerCandidate address The address to transfer ownership to.\n', '    ///\n', '    /// NOTE:\n', '    ///   1. The new owner will need to call Kin token contract&#39;s acceptOwnership directly in order to accept the ownership.\n', '    ///   2. Calling this method during the token sale will prevent the token sale to continue, since only the owner of\n', '    ///      the Kin token contract can issue new tokens.\n', '    function requestKinTokenOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\n', '        kin.requestOwnershipTransfer(_newOwnerCandidate);\n', '    }\n', '\n', '    /// @dev Accepts new ownership on behalf of the Kin token contract.\n', '    // This can be used by the sale contract itself to claim back ownership of the Kin token contract.\n', '    function acceptKinTokenOwnership() external onlyOwner {\n', '        kin.acceptOwnership();\n', '    }\n', '\n', '    /// @dev Requests to transfer control of the VestingTrustee contract to a new owner.\n', '    /// @param _newOwnerCandidate address The address to transfer ownership to.\n', '    ///\n', '    /// NOTE:\n', '    ///   1. The new owner will need to call VestingTrustee&#39;s acceptOwnership directly in order to accept the ownership.\n', '    ///   2. Calling this method during the token sale will prevent the token sale from finalizaing, since only the owner\n', '    ///      of the VestingTrustee contract can issue new token grants.\n', '    function requestVestingTrusteeOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\n', '        trustee.requestOwnershipTransfer(_newOwnerCandidate);\n', '    }\n', '\n', '    /// @dev Accepts new ownership on behalf of the VestingTrustee contract.\n', '    /// This can be used by the token sale contract itself to claim back ownership of the VestingTrustee contract.\n', '    function acceptVestingTrusteeOwnership() external onlyOwner {\n', '        trustee.acceptOwnership();\n', '    }\n', '}']