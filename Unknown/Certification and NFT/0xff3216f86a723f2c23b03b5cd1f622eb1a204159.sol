['pragma solidity ^0.4.2;\n', '\n', 'contract ValentineRegistry {\n', '\n', '    event LogValentineRequestCreated(string requesterName, string valentineName, string customMessage, address valentineAddress, address requesterAddress);\n', '    event LogRequestAccepted(address requesterAddress);\n', '\n', '    struct Request {\n', '        string requesterName;\n', '        string valentineName;\n', '        string customMessage;\n', '        bool doesExist;\n', '        bool wasAccepted;\n', '        address valentineAddress;\n', '    }\n', '    address public owner;\n', '    // Requests maps requester addresses to the requests details\n', '    mapping (address => Request) private requests;\n', '    uint public numRequesters;\n', '    address[] public requesters;\n', '    address constant ADDRESS_NULL = 0;\n', '    uint constant MAX_CUSTOM_MESSAGE_LENGTH = 140;\n', '    uint constant MAX_NAME_LENGTH = 25;\n', '    uint constant COST = 0.1 ether;\n', '\n', '    modifier restricted() {\n', '        if (msg.sender != owner)\n', '            throw;\n', '        _;\n', '    }\n', '    modifier costs(uint _amount) {\n', '        if (msg.value < _amount)\n', '            throw;\n', '        _;\n', '    }\n', '    modifier prohibitRequestUpdates() {\n', '        if (requests[msg.sender].doesExist)\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    function ValentineRegistry() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // Creates a valentine request that can only be accepted by the specified valentineAddress\n', '    function createTargetedValentineRequest(string requesterName, string valentineName,\n', '        string customMessage, address valentineAddress)\n', '        costs(COST)\n', '        prohibitRequestUpdates\n', '        payable\n', '        public {\n', '        createNewValentineRequest(requesterName, valentineName, customMessage, valentineAddress);\n', '    }\n', '\n', '    // Creates a valentine request that can be fullfilled by any address\n', '    function createOpenValentineRequest(string requesterName, string valentineName, string customMessage)\n', '        costs(COST)\n', '        prohibitRequestUpdates\n', '        payable\n', '        public {\n', '        createNewValentineRequest(requesterName, valentineName, customMessage, ADDRESS_NULL);\n', '    }\n', '\n', '    function createNewValentineRequest(string requesterName, string valentineName, string customMessage,\n', '        address valentineAddress)\n', '        internal {\n', '        if (bytes(requesterName).length > MAX_NAME_LENGTH || bytes(valentineName).length > MAX_NAME_LENGTH\n', '            || bytes(customMessage).length > MAX_CUSTOM_MESSAGE_LENGTH) {\n', '            throw; // invalid request\n', '        }\n', '        bool doesExist = true;\n', '        bool wasAccepted = false;\n', '        Request memory r = Request(requesterName, valentineName, customMessage, doesExist,\n', '        wasAccepted, valentineAddress);\n', '        requesters.push(msg.sender);\n', '        numRequesters++;\n', '        requests[msg.sender] = r;\n', '        LogValentineRequestCreated(requesterName, valentineName, customMessage, valentineAddress, msg.sender);\n', '    }\n', '\n', '    function acceptValentineRequest(address requesterAddress) public {\n', '        Request request = requests[requesterAddress];\n', '        if (!request.doesExist) {\n', "            throw; // the request doesn't exist\n", '        }\n', '        request.wasAccepted = true;\n', '        LogRequestAccepted(requesterAddress);\n', '    }\n', '\n', '    function getRequestByRequesterAddress(address requesterAddress) public returns (string, string, string, bool, address, address) {\n', '        Request r = requests[requesterAddress];\n', '        if (!r.doesExist) {\n', '            return ("", "", "", false, ADDRESS_NULL, ADDRESS_NULL);\n', '        }\n', '        return (r.requesterName, r.valentineName, r.customMessage, r.wasAccepted, r.valentineAddress, requesterAddress);\n', '    }\n', '\n', '    function getRequestByIndex(uint index) public returns (string, string, string, bool, address, address) {\n', '        if (index >= requesters.length) {\n', '            throw;\n', '        }\n', '        address requesterAddress = requesters[index];\n', '        Request r = requests[requesterAddress];\n', '        return (r.requesterName, r.valentineName, r.customMessage, r.wasAccepted, r.valentineAddress, requesterAddress);\n', '    }\n', '\n', '    function updateOwner(address newOwner)\n', '        restricted\n', '        public {\n', '        owner = newOwner;\n', '    }\n', '\n', '    function cashout(address recipient)\n', '        restricted\n', '        public {\n', '        address contractAddress = this;\n', '        if (!recipient.send(contractAddress.balance)) {\n', '            throw;\n', '        }\n', '    }\n', '}']