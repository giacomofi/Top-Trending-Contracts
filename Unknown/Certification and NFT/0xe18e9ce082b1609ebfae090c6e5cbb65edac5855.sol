['pragma solidity ^0.4.13;\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', 'contract ERC20 {\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', 'contract Controlled {\n', '    modifier onlyController() {\n', '        require(msg.sender == controller);\n', '        _;\n', '    }\n', '\n', '    address public controller;\n', '\n', '    function Controlled() {\n', '        controller = msg.sender;\n', '    }\n', '\n', '    address public newController;\n', '\n', '    function changeOwner(address _newController) onlyController {\n', '        newController = _newController;\n', '    }\n', '\n', '    function acceptOwnership() {\n', '        if (msg.sender == newController) {\n', '            controller = newController;\n', '        }\n', '    }\n', '}\n', 'contract DAOControlled is Controlled{\n', '    address public dao;\n', '    modifier onlyDAO{\n', '        require(msg.sender == dao);\n', '        _;\n', '    }\n', '    function setDAO(address _dao) onlyController{\n', '        dao = _dao;\n', '    }\n', '}\n', '\n', 'contract MintableToken is ERC20, SafeMath, DAOControlled{\n', '\tmapping(address => uint) public balances;\n', '\taddress[] public mintingFactories;\n', '\tuint public numFactories;\n', '\tfunction resetFactories() onlyController{\n', '\t    numFactories = 0;\n', '\t}\n', '\tfunction addMintingFactory(address _factory) onlyController{\n', '\t    mintingFactories.push(_factory);\n', '\t    numFactories += 1;\n', '\t}\n', '\t\n', '\tfunction removeMintingFactory(address _factory) onlyController{\n', '\t    for (uint i = 0; i < numFactories; i++){\n', '\t        if (_factory == mintingFactories[i])\n', '\t        {\n', '\t            mintingFactories[i] = 0;\n', '\t        }\n', '\t    }\n', '\t}\n', '\t\n', '\tmodifier onlyFactory{\n', '\t    bool isFactory = false;\n', '\t    for (uint i = 0; i < numFactories; i++){\n', '\t        if (msg.sender == mintingFactories[i] && msg.sender != address(0))\n', '\t        {\n', '\t            isFactory = true;\n', '\t        }\n', '\t    }\n', '\t    if (!isFactory) throw;\n', '\t    _;\n', '\t}\n', '}\n', 'contract CollectibleFeeToken is MintableToken{\n', '\tuint8 public decimals;\n', '\tmapping(uint => uint) public roundFees;\n', '\tmapping(uint => uint) public recordedCoinSupplyForRound;\n', '\tmapping(uint => mapping (address => uint)) public claimedFees;\n', '\tmapping(address => uint) public lastClaimedRound;\n', '\tuint public latestRound = 0;\n', '\tuint public initialRound = 1;\n', '\tuint public reserves;\n', '    event Claimed(address indexed _owner, uint256 _amount);\n', '    event Deposited(uint256 _amount, uint indexed round);\n', '\t\n', '\tmodifier onlyPayloadSize(uint size) {\n', '\t\tif(msg.data.length != size + 4) {\n', '\t\tthrow;\n', '\t\t}\n', '\t\t_;\n', '\t}\n', '\t\n', '\tfunction reduceReserves(uint value) onlyPayloadSize(1 * 32) onlyDAO{\n', '\t    reserves = safeSub(reserves, value);\n', '\t}\n', '\t\n', '\tfunction addReserves(uint value) onlyPayloadSize(1 * 32) onlyDAO{\n', '\t    reserves = safeAdd(reserves, value);\n', '\t}\n', '\t\n', '\tfunction depositFees(uint value) onlyDAO {\n', '\t\tlatestRound += 1;\n', '\t\tDeposited(value, latestRound);\n', '\t\trecordedCoinSupplyForRound[latestRound] = totalSupply;\n', '\t\troundFees[latestRound] = value;\n', '\t}\n', '\tfunction claimFees(address _owner) onlyPayloadSize(1 * 32) onlyDAO returns (uint totalFees) {\n', '\t\ttotalFees = 0;\n', '\t\tfor (uint i = lastClaimedRound[_owner] + 1; i <= latestRound; i++){\n', '\t\t\tuint feeForRound = balances[_owner] * feePerUnitOfCoin(i);\n', '\t\t\tif (feeForRound > claimedFees[i][_owner]){\n', '\t\t\t\tfeeForRound = safeSub(feeForRound,claimedFees[i][_owner]);\n', '\t\t\t}\n', '\t\t\telse {\n', '\t\t\t\tfeeForRound = 0;\n', '\t\t\t}\n', '\t\t\tclaimedFees[i][_owner] = safeAdd(claimedFees[i][_owner], feeForRound);\n', '\t\t\ttotalFees = safeAdd(totalFees, feeForRound);\n', '\t\t}\n', '\t\tlastClaimedRound[_owner] = latestRound;\n', '\t\tClaimed(_owner, feeForRound);\n', '\t\treturn totalFees;\n', '\t}\n', '\n', '\tfunction claimFeesForRound(address _owner, uint round) onlyPayloadSize(2 * 32) onlyDAO returns (uint feeForRound) {\n', '\t\tfeeForRound = balances[_owner] * feePerUnitOfCoin(round);\n', '\t\tif (feeForRound > claimedFees[round][_owner]){\n', '\t\t\tfeeForRound = safeSub(feeForRound,claimedFees[round][_owner]);\n', '\t\t}\n', '\t\telse {\n', '\t\t\tfeeForRound = 0;\n', '\t\t}\n', '\t\tclaimedFees[round][_owner] = safeAdd(claimedFees[round][_owner], feeForRound);\n', '\t\tClaimed(_owner, feeForRound);\n', '\t\treturn feeForRound;\n', '\t}\n', '\n', '\tfunction _resetTransferredCoinFees(address _owner, address _receipient, uint numCoins) internal returns (bool){\n', '\t\tfor (uint i = lastClaimedRound[_owner] + 1; i <= latestRound; i++){\n', '\t\t\tuint feeForRound = balances[_owner] * feePerUnitOfCoin(i);\n', '\t\t\tif (feeForRound > claimedFees[i][_owner]) {\n', '\t\t\t\t//Add unclaimed fees to reserves\n', '\t\t\t\tuint unclaimedFees = min256(numCoins * feePerUnitOfCoin(i), safeSub(feeForRound, claimedFees[i][_owner]));\n', '\t\t\t\treserves = safeAdd(reserves, unclaimedFees);\n', '\t\t\t\tclaimedFees[i][_owner] = safeAdd(claimedFees[i][_owner], unclaimedFees);\n', '\t\t\t}\n', '\t\t}\n', '\t\tfor (uint x = lastClaimedRound[_receipient] + 1; x <= latestRound; x++){\n', '\t\t\t//Empty fees for new receipient\n', '\t\t\tclaimedFees[x][_receipient] = safeAdd(claimedFees[x][_receipient], numCoins * feePerUnitOfCoin(x));\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\tfunction feePerUnitOfCoin(uint round) public constant returns (uint fee){\n', '\t\treturn safeDiv(roundFees[round], recordedCoinSupplyForRound[round]);\n', '\t}\n', '\t\n', '\tfunction reservesPerUnitToken() public constant returns(uint) {\n', '\t    return reserves / totalSupply;\n', '\t}\n', '\t\n', '   function mintTokens(address _owner, uint amount) onlyFactory{\n', '       //Upon factory transfer, fees will be redistributed into reserves\n', '       lastClaimedRound[msg.sender] = latestRound;\n', '       totalSupply = safeAdd(totalSupply, amount);\n', '       balances[_owner] += amount;\n', '   }\n', '}\n', '\n', 'contract BurnableToken is CollectibleFeeToken{\n', '\n', '    event Burned(address indexed _owner, uint256 _value);\n', '    function burn(address _owner, uint amount) onlyDAO returns (uint burnValue){\n', '        require(balances[_owner] >= amount);\n', '        //Validation is done to ensure no fees remaining in token\n', '        require(latestRound == lastClaimedRound[_owner]);\n', '        burnValue = reservesPerUnitToken() * amount;\n', '        reserves = safeSub(reserves, burnValue);\n', '        balances[_owner] = safeSub(balances[_owner], amount);\n', '        totalSupply = safeSub(totalSupply, amount);\n', '        Transfer(_owner, this, amount);\n', '        Burned(_owner, amount);\n', '        return burnValue;\n', '    }\n', '    \n', '}\n', '/*\n', ' * Haltable\n', ' *\n', ' * Abstract contract that allows children to implement an\n', ' * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\n', ' *\n', ' *\n', ' * Originally envisioned in FirstBlood ICO contract.\n', ' */\n', 'contract Haltable is Controlled {\n', '  bool public halted;\n', '\n', '  modifier stopInEmergency {\n', '    if (halted) throw;\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    if (!halted) throw;\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function halt() external onlyController {\n', '    halted = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function unhalt() external onlyController onlyInEmergency {\n', '    halted = false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', ' *\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract SphereToken is BurnableToken, Haltable {\n', '    \n', '    string public name;                //The Token&#39;s name: e.g. DigixDAO Tokens\n', '    string public symbol;              //An identifier: e.g. REP\n', '    string public version = &#39;SPR_0.1&#39;; //An arbitrary versioning scheme\n', '    bool public isTransferEnabled;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '    function SphereToken(){\n', '        name = &#39;EtherSphere&#39;;\n', '        symbol = &#39;SPR&#39;;\n', '        decimals = 4;\n', '        isTransferEnabled = false;\n', '    }\n', '  /**\n', '   *\n', '   * Fix for the ERC20 short address attack\n', '   *\n', '   * http://vessenes.com/the-erc20-short-address-attack-explained/\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '     if(msg.data.length != size + 4) {\n', '       throw;\n', '     }\n', '     _;\n', '  }\n', '\n', '    function setTransferEnable(bool enabled) onlyDAO{\n', '        isTransferEnabled = enabled;\n', '    }\n', '    function doTransfer(address _from, address _to, uint _value) private returns (bool success){\n', '        if (_value > balances[_from] || !isTransferEnabled) return false;\n', '        if (!_resetTransferredCoinFees(_from, _to, _value)) return false;\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) stopInEmergency returns (bool success) {\n', '    return doTransfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  function exchangeTransfer(address _to, uint _value) stopInEmergency onlyFactory returns (bool success) {\n', '        if (_value > balances[msg.sender]) {return false;}\n', '        if (!_resetTransferredCoinFees(msg.sender, _to, _value)){ return false;}\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '  }\n', '  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) stopInEmergency returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '    if (_value > balances[_from] || !isTransferEnabled || _value > _allowance) return false;\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    return doTransfer(_from, _to, _value);\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) stopInEmergency returns (bool success) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\n', '        return false;\n', '    }\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * Atomic increment of approved spending\n', '   *\n', '   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   *\n', '   */\n', '  function addApproval(address _spender, uint _addedValue)\n', '  onlyPayloadSize(2 * 32) stopInEmergency\n', '  returns (bool success) {\n', '      uint oldValue = allowed[msg.sender][_spender];\n', '      allowed[msg.sender][_spender] = safeAdd(oldValue, _addedValue);\n', '      return true;\n', '  }\n', '\n', '  /**\n', '   * Atomic decrement of approved spending.\n', '   *\n', '   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   */\n', '  function subApproval(address _spender, uint _subtractedValue)\n', '  onlyPayloadSize(2 * 32) stopInEmergency\n', '  returns (bool success) {\n', '\n', '      uint oldVal = allowed[msg.sender][_spender];\n', '\n', '      if (_subtractedValue > oldVal) {\n', '          allowed[msg.sender][_spender] = 0;\n', '      } else {\n', '          allowed[msg.sender][_spender] = safeSub(oldVal, _subtractedValue);\n', '      }\n', '      return true;\n', '  }\n', '\n', '}']
['pragma solidity ^0.4.13;\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', 'contract ERC20 {\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      throw;\n', '    }\n', '  }\n', '}\n', '\n', 'contract Controlled {\n', '    modifier onlyController() {\n', '        require(msg.sender == controller);\n', '        _;\n', '    }\n', '\n', '    address public controller;\n', '\n', '    function Controlled() {\n', '        controller = msg.sender;\n', '    }\n', '\n', '    address public newController;\n', '\n', '    function changeOwner(address _newController) onlyController {\n', '        newController = _newController;\n', '    }\n', '\n', '    function acceptOwnership() {\n', '        if (msg.sender == newController) {\n', '            controller = newController;\n', '        }\n', '    }\n', '}\n', 'contract DAOControlled is Controlled{\n', '    address public dao;\n', '    modifier onlyDAO{\n', '        require(msg.sender == dao);\n', '        _;\n', '    }\n', '    function setDAO(address _dao) onlyController{\n', '        dao = _dao;\n', '    }\n', '}\n', '\n', 'contract MintableToken is ERC20, SafeMath, DAOControlled{\n', '\tmapping(address => uint) public balances;\n', '\taddress[] public mintingFactories;\n', '\tuint public numFactories;\n', '\tfunction resetFactories() onlyController{\n', '\t    numFactories = 0;\n', '\t}\n', '\tfunction addMintingFactory(address _factory) onlyController{\n', '\t    mintingFactories.push(_factory);\n', '\t    numFactories += 1;\n', '\t}\n', '\t\n', '\tfunction removeMintingFactory(address _factory) onlyController{\n', '\t    for (uint i = 0; i < numFactories; i++){\n', '\t        if (_factory == mintingFactories[i])\n', '\t        {\n', '\t            mintingFactories[i] = 0;\n', '\t        }\n', '\t    }\n', '\t}\n', '\t\n', '\tmodifier onlyFactory{\n', '\t    bool isFactory = false;\n', '\t    for (uint i = 0; i < numFactories; i++){\n', '\t        if (msg.sender == mintingFactories[i] && msg.sender != address(0))\n', '\t        {\n', '\t            isFactory = true;\n', '\t        }\n', '\t    }\n', '\t    if (!isFactory) throw;\n', '\t    _;\n', '\t}\n', '}\n', 'contract CollectibleFeeToken is MintableToken{\n', '\tuint8 public decimals;\n', '\tmapping(uint => uint) public roundFees;\n', '\tmapping(uint => uint) public recordedCoinSupplyForRound;\n', '\tmapping(uint => mapping (address => uint)) public claimedFees;\n', '\tmapping(address => uint) public lastClaimedRound;\n', '\tuint public latestRound = 0;\n', '\tuint public initialRound = 1;\n', '\tuint public reserves;\n', '    event Claimed(address indexed _owner, uint256 _amount);\n', '    event Deposited(uint256 _amount, uint indexed round);\n', '\t\n', '\tmodifier onlyPayloadSize(uint size) {\n', '\t\tif(msg.data.length != size + 4) {\n', '\t\tthrow;\n', '\t\t}\n', '\t\t_;\n', '\t}\n', '\t\n', '\tfunction reduceReserves(uint value) onlyPayloadSize(1 * 32) onlyDAO{\n', '\t    reserves = safeSub(reserves, value);\n', '\t}\n', '\t\n', '\tfunction addReserves(uint value) onlyPayloadSize(1 * 32) onlyDAO{\n', '\t    reserves = safeAdd(reserves, value);\n', '\t}\n', '\t\n', '\tfunction depositFees(uint value) onlyDAO {\n', '\t\tlatestRound += 1;\n', '\t\tDeposited(value, latestRound);\n', '\t\trecordedCoinSupplyForRound[latestRound] = totalSupply;\n', '\t\troundFees[latestRound] = value;\n', '\t}\n', '\tfunction claimFees(address _owner) onlyPayloadSize(1 * 32) onlyDAO returns (uint totalFees) {\n', '\t\ttotalFees = 0;\n', '\t\tfor (uint i = lastClaimedRound[_owner] + 1; i <= latestRound; i++){\n', '\t\t\tuint feeForRound = balances[_owner] * feePerUnitOfCoin(i);\n', '\t\t\tif (feeForRound > claimedFees[i][_owner]){\n', '\t\t\t\tfeeForRound = safeSub(feeForRound,claimedFees[i][_owner]);\n', '\t\t\t}\n', '\t\t\telse {\n', '\t\t\t\tfeeForRound = 0;\n', '\t\t\t}\n', '\t\t\tclaimedFees[i][_owner] = safeAdd(claimedFees[i][_owner], feeForRound);\n', '\t\t\ttotalFees = safeAdd(totalFees, feeForRound);\n', '\t\t}\n', '\t\tlastClaimedRound[_owner] = latestRound;\n', '\t\tClaimed(_owner, feeForRound);\n', '\t\treturn totalFees;\n', '\t}\n', '\n', '\tfunction claimFeesForRound(address _owner, uint round) onlyPayloadSize(2 * 32) onlyDAO returns (uint feeForRound) {\n', '\t\tfeeForRound = balances[_owner] * feePerUnitOfCoin(round);\n', '\t\tif (feeForRound > claimedFees[round][_owner]){\n', '\t\t\tfeeForRound = safeSub(feeForRound,claimedFees[round][_owner]);\n', '\t\t}\n', '\t\telse {\n', '\t\t\tfeeForRound = 0;\n', '\t\t}\n', '\t\tclaimedFees[round][_owner] = safeAdd(claimedFees[round][_owner], feeForRound);\n', '\t\tClaimed(_owner, feeForRound);\n', '\t\treturn feeForRound;\n', '\t}\n', '\n', '\tfunction _resetTransferredCoinFees(address _owner, address _receipient, uint numCoins) internal returns (bool){\n', '\t\tfor (uint i = lastClaimedRound[_owner] + 1; i <= latestRound; i++){\n', '\t\t\tuint feeForRound = balances[_owner] * feePerUnitOfCoin(i);\n', '\t\t\tif (feeForRound > claimedFees[i][_owner]) {\n', '\t\t\t\t//Add unclaimed fees to reserves\n', '\t\t\t\tuint unclaimedFees = min256(numCoins * feePerUnitOfCoin(i), safeSub(feeForRound, claimedFees[i][_owner]));\n', '\t\t\t\treserves = safeAdd(reserves, unclaimedFees);\n', '\t\t\t\tclaimedFees[i][_owner] = safeAdd(claimedFees[i][_owner], unclaimedFees);\n', '\t\t\t}\n', '\t\t}\n', '\t\tfor (uint x = lastClaimedRound[_receipient] + 1; x <= latestRound; x++){\n', '\t\t\t//Empty fees for new receipient\n', '\t\t\tclaimedFees[x][_receipient] = safeAdd(claimedFees[x][_receipient], numCoins * feePerUnitOfCoin(x));\n', '\t\t}\n', '\t\treturn true;\n', '\t}\n', '\tfunction feePerUnitOfCoin(uint round) public constant returns (uint fee){\n', '\t\treturn safeDiv(roundFees[round], recordedCoinSupplyForRound[round]);\n', '\t}\n', '\t\n', '\tfunction reservesPerUnitToken() public constant returns(uint) {\n', '\t    return reserves / totalSupply;\n', '\t}\n', '\t\n', '   function mintTokens(address _owner, uint amount) onlyFactory{\n', '       //Upon factory transfer, fees will be redistributed into reserves\n', '       lastClaimedRound[msg.sender] = latestRound;\n', '       totalSupply = safeAdd(totalSupply, amount);\n', '       balances[_owner] += amount;\n', '   }\n', '}\n', '\n', 'contract BurnableToken is CollectibleFeeToken{\n', '\n', '    event Burned(address indexed _owner, uint256 _value);\n', '    function burn(address _owner, uint amount) onlyDAO returns (uint burnValue){\n', '        require(balances[_owner] >= amount);\n', '        //Validation is done to ensure no fees remaining in token\n', '        require(latestRound == lastClaimedRound[_owner]);\n', '        burnValue = reservesPerUnitToken() * amount;\n', '        reserves = safeSub(reserves, burnValue);\n', '        balances[_owner] = safeSub(balances[_owner], amount);\n', '        totalSupply = safeSub(totalSupply, amount);\n', '        Transfer(_owner, this, amount);\n', '        Burned(_owner, amount);\n', '        return burnValue;\n', '    }\n', '    \n', '}\n', '/*\n', ' * Haltable\n', ' *\n', ' * Abstract contract that allows children to implement an\n', ' * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\n', ' *\n', ' *\n', ' * Originally envisioned in FirstBlood ICO contract.\n', ' */\n', 'contract Haltable is Controlled {\n', '  bool public halted;\n', '\n', '  modifier stopInEmergency {\n', '    if (halted) throw;\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    if (!halted) throw;\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function halt() external onlyController {\n', '    halted = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function unhalt() external onlyController onlyInEmergency {\n', '    halted = false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', ' *\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract SphereToken is BurnableToken, Haltable {\n', '    \n', "    string public name;                //The Token's name: e.g. DigixDAO Tokens\n", '    string public symbol;              //An identifier: e.g. REP\n', "    string public version = 'SPR_0.1'; //An arbitrary versioning scheme\n", '    bool public isTransferEnabled;\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '    function SphereToken(){\n', "        name = 'EtherSphere';\n", "        symbol = 'SPR';\n", '        decimals = 4;\n', '        isTransferEnabled = false;\n', '    }\n', '  /**\n', '   *\n', '   * Fix for the ERC20 short address attack\n', '   *\n', '   * http://vessenes.com/the-erc20-short-address-attack-explained/\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '     if(msg.data.length != size + 4) {\n', '       throw;\n', '     }\n', '     _;\n', '  }\n', '\n', '    function setTransferEnable(bool enabled) onlyDAO{\n', '        isTransferEnabled = enabled;\n', '    }\n', '    function doTransfer(address _from, address _to, uint _value) private returns (bool success){\n', '        if (_value > balances[_from] || !isTransferEnabled) return false;\n', '        if (!_resetTransferredCoinFees(_from, _to, _value)) return false;\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) stopInEmergency returns (bool success) {\n', '    return doTransfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  function exchangeTransfer(address _to, uint _value) stopInEmergency onlyFactory returns (bool success) {\n', '        if (_value > balances[msg.sender]) {return false;}\n', '        if (!_resetTransferredCoinFees(msg.sender, _to, _value)){ return false;}\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '  }\n', '  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) stopInEmergency returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '    if (_value > balances[_from] || !isTransferEnabled || _value > _allowance) return false;\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    return doTransfer(_from, _to, _value);\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) stopInEmergency returns (bool success) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\n', '        return false;\n', '    }\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '  /**\n', '   * Atomic increment of approved spending\n', '   *\n', '   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   *\n', '   */\n', '  function addApproval(address _spender, uint _addedValue)\n', '  onlyPayloadSize(2 * 32) stopInEmergency\n', '  returns (bool success) {\n', '      uint oldValue = allowed[msg.sender][_spender];\n', '      allowed[msg.sender][_spender] = safeAdd(oldValue, _addedValue);\n', '      return true;\n', '  }\n', '\n', '  /**\n', '   * Atomic decrement of approved spending.\n', '   *\n', '   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   */\n', '  function subApproval(address _spender, uint _subtractedValue)\n', '  onlyPayloadSize(2 * 32) stopInEmergency\n', '  returns (bool success) {\n', '\n', '      uint oldVal = allowed[msg.sender][_spender];\n', '\n', '      if (_subtractedValue > oldVal) {\n', '          allowed[msg.sender][_spender] = 0;\n', '      } else {\n', '          allowed[msg.sender][_spender] = safeSub(oldVal, _subtractedValue);\n', '      }\n', '      return true;\n', '  }\n', '\n', '}']
