['pragma solidity ^0.4.10;\n', '\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '/*\n', ' * Safe Math Smart Contract.  Copyright &#169; 2016 by ABDK Consulting.\n', ' */\n', '\n', '/**\n', ' * Provides methods to safely add, subtract and multiply uint256 numbers.\n', ' */\n', 'contract SafeMath {\n', '  uint256 constant private MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '  /**\n', '   * Add two uint256 values, throw in case of overflow.\n', '   *\n', '   * @param x first value to add\n', '   * @param y second value to add\n', '   * @return x + y\n', '   */\n', '  function safeAdd (uint256 x, uint256 y)\n', '  constant internal\n', '  returns (uint256 z) {\n', '    if (x > MAX_UINT256 - y) throw;\n', '    return x + y;\n', '  }\n', '\n', '  /**\n', '   * Subtract one uint256 value from another, throw in case of underflow.\n', '   *\n', '   * @param x value to subtract from\n', '   * @param y value to subtract\n', '   * @return x - y\n', '   */\n', '  function safeSub (uint256 x, uint256 y)\n', '  constant internal\n', '  returns (uint256 z) {\n', '    if (x < y) throw;\n', '    return x - y;\n', '  }\n', '\n', '  /**\n', '   * Multiply two uint256 values, throw in case of overflow.\n', '   *\n', '   * @param x first value to multiply\n', '   * @param y second value to multiply\n', '   * @return x * y\n', '   */\n', '  function safeMul (uint256 x, uint256 y)\n', '  constant internal\n', '  returns (uint256 z) {\n', '    if (y == 0) return 0; // Prevent division by zero at the next line\n', '    if (x > MAX_UINT256 / y) throw;\n', '    return x * y;\n', '  }\n', '}\n', '\n', 'contract Vote is ERC20, SafeMath{\n', '\n', '\tmapping (address => uint) balances;\n', '\tmapping (address => mapping (address => uint)) allowed;\n', '\n', '\tuint public totalSupply;\n', '\tuint public initialSupply;\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\n', '\tfunction Vote(){\n', '\t\tinitialSupply = 100000;\n', '\t\ttotalSupply = initialSupply;\n', '\t\tbalances[msg.sender] = initialSupply;\n', '\t\tname = "EthTaipei Logo Vote";\n', '\t\tsymbol = "EthTaipei Logo";\n', '\t\tdecimals = 0;\n', '\t}\n', '\n', '\tfunction transfer(address _to, uint _value) returns (bool) {\n', '\t    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '\t    balances[_to] = safeAdd(balances[_to], _value);\n', '\t    Transfer(msg.sender, _to, _value);\n', '\t    return true;\n', '  \t}\n', '\n', '  \tfunction transferFrom(address _from, address _to, uint _value) returns (bool) {\n', '\t    var _allowance = allowed[_from][msg.sender];\t    \n', '\t    balances[_to] = safeAdd(balances[_to], _value);\n', '\t    balances[_from] = safeSub(balances[_from], _value);\n', '\t    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '\t    Transfer(_from, _to, _value);\n', '\t    return true;\n', '  \t}\n', '\n', '  \tfunction approve(address _spender, uint _value) returns (bool) {\n', '    \tallowed[msg.sender][_spender] = _value;\n', '    \tApproval(msg.sender, _spender, _value);\n', '    \treturn true;\n', '  \t}\n', '\n', '  \tfunction balanceOf(address _address) constant returns (uint balance) {\n', '  \t\treturn balances[_address];\n', '  \t}\n', '\n', '  \tfunction allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    \treturn allowed[_owner][_spender];\n', '  \t}\n', '\n', '}\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender == owner)\n', '      _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract wLogoVote {\n', '\tfunction claimReward(address _receiver);\n', '}\n', '\n', 'contract Logo is Ownable{\n', '\n', '\twLogoVote public logoVote;\n', '\n', '\taddress public author;\n', '\tstring public metadataUrl;\n', '\n', '\tevent ReceiveTips(address _from, uint _value);\n', '\n', '\tfunction Logo(address _owner, address _author, string _metadatUrl){\n', '\t\towner = _owner;\n', '\t\tauthor = _author;\n', '\t\tmetadataUrl = _metadatUrl;\n', '\t\tlogoVote = wLogoVote(msg.sender);\n', '\t}\n', '\n', '\tfunction tips() payable {\n', '\t\tReceiveTips(msg.sender, msg.value);\n', '\t\tif(!author.send(msg.value)) throw;\n', '\t}\n', '\n', '\tfunction claimReward() onlyOwner {\n', '\t\tlogoVote.claimReward(author);\n', '\t}\n', '\n', '\tfunction setMetadata(string _metadataUrl) onlyOwner {\n', '\t\tmetadataUrl = _metadataUrl;\n', '\t}\n', '\n', '\tfunction () payable {\n', '\t\ttips();\n', '\t}\n', '}\n', '/*\n', ' * Pausable\n', ' * Abstract contract that allows children to implement an\n', ' * emergency stop mechanism.\n', ' */\n', '\n', 'contract Pausable is Ownable {\n', '  bool public stopped;\n', '\n', '  modifier stopInEmergency {\n', '    if (stopped) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '  \n', '  modifier onlyInEmergency {\n', '    if (!stopped) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function emergencyStop() external onlyOwner {\n', '    stopped = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function release() external onlyOwner onlyInEmergency {\n', '    stopped = false;\n', '  }\n', '\n', '}\n', 'contract Token{\n', '\tfunction transfer(address to, uint value) returns (bool ok);\n', '}\n', '\n', 'contract Faucet {\n', '\n', '\taddress public tokenAddress;\n', '\tToken token;\n', '\n', '\tfunction Faucet(address _tokenAddress) {\n', '\t\ttokenAddress = _tokenAddress;\n', '\t\ttoken = Token(tokenAddress);\n', '\t}\n', '  \n', '\tfunction getToken() {\n', '\t\tif(!token.transfer(msg.sender, 1)) throw;\n', '\t}\n', '\n', '\tfunction () {\n', '\t\tgetToken();\n', '\t}\n', '\n', '}\n', '\n', 'contract LogoVote is Pausable, SafeMath{\n', '\n', '\tVote public vote;\n', '\tFaucet public faucet;\n', '\tLogo[] public logos;\n', '\n', '\tmapping (address => uint) backers;\n', '\tmapping (address => bool) rewards;\n', '\tuint rewardClaimed;\n', '\n', '\tuint public votePerETH;\n', '\tuint public totalReward;\n', '\tuint public startBlock;\n', '\tuint public endBlock;\n', '\taddress public winner;\n', '\n', '\tevent ReceiveDonate(address addr, uint value);\n', '\n', '\tmodifier respectTimeFrame() {\n', '\t\tif (!isRespectTimeFrame()) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier afterEnd() {\n', '\t\tif (!isAfterEnd()) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction LogoVote() {\n', '\t\tvote = new Vote();\n', '\t\tfaucet = new Faucet(vote);\n', '\t\tvotePerETH = 1000; // donate 0.001 ether to get 1 vote \n', '\t\ttotalReward = 0;\n', '\t\tstartBlock = getBlockNumber();\n', '\t\tendBlock = startBlock + ( 30 * 24 * 60 * 60 / 15 ); //end in 30 days\n', '\t\trewardClaimed = 0;\n', '\t}\n', '\n', '\t// functions only for owner \n', '\tfunction sendToFaucet(uint _amount) onlyOwner {\n', '\t\tif(!vote.transfer(faucet, _amount)) throw;\n', '\t}\n', '\n', '\tfunction registLogo(address _owner, address _author, string _metadatUrl) \n', '\t\t\t\t\t\tonlyOwner respectTimeFrame returns (address) {\n', '\t\tLogo logoAddress = new Logo(_owner, _author, _metadatUrl);\n', '\t\tlogos.push(logoAddress);\n', '\t\treturn logoAddress;\n', '\t}\n', '\n', '\tfunction claimWinner () onlyOwner afterEnd {\n', '\t\tif (isLogo(winner)) throw;\n', '\t\twinner = logos[0];\n', '\t\tfor (uint8 i = 1; i < logos.length; i++) {\n', '\t\t\tif (vote.balanceOf(logos[i]) > vote.balanceOf(winner))\n', '\t\t\t\twinner = logos[i];\n', '\t\t} \n', '\t}\n', '\n', '\tfunction cleanBalance () onlyOwner afterEnd {\n', '\t\tif (rewardClaimed >= logos.length || getBlockNumber() < endBlock + 43200) throw;\n', '\t\tif(!vote.transfer(owner, vote.balanceOf(this))) throw;\n', '\t\tif (!owner.send(this.balance)) throw;\n', '\t}\n', '\n', '\t// normal user can donate to get votes\n', '\tfunction donate(address beneficiary) internal stopInEmergency respectTimeFrame {\n', '\t\tuint voteToSend = safeMul(msg.value, votePerETH)/(1 ether);\n', '\t\tif (!vote.transfer(beneficiary, voteToSend)) throw; \n', '\t\tbackers[beneficiary] = safeAdd(backers[beneficiary], msg.value);\n', '\t\ttotalReward = safeAdd(totalReward, msg.value);\n', '\n', '\t\tReceiveDonate(beneficiary, msg.value);\n', '\t}\n', '\n', '\t// normal user can get back their funds if in emergency \n', '\tfunction getFunds() onlyInEmergency {\n', '\t\tif (backers[msg.sender] == 0) throw;\n', '\t\tuint amount = backers[msg.sender];\n', '\t\tbackers[msg.sender] = 0;\n', '\n', '\t\tif(!msg.sender.send(amount)) throw;\n', '\t}\n', '\n', '\t// logo&#39;s owner can claim their rewards after end \n', '\tfunction claimReward (address _receiver) stopInEmergency afterEnd {\n', '\t\tif (!isLogo(msg.sender)) throw;\n', '\t\tif (rewards[msg.sender]) throw;\n', '\t\tif (rewardClaimed == logos.length) throw;\n', '\t\tuint amount = totalReward / safeMul(2, logos.length); // all logos share the 50% of rewards\n', '\t\tif (msg.sender == winner) {\n', '\t\t\tamount = safeAdd(amount, totalReward/2);\n', '\t\t}\n', '\t\trewards[msg.sender] = true;\n', '\t\trewardClaimed = safeAdd(rewardClaimed, 1);\n', '\t\tif (!_receiver.send(amount)) throw;\n', '\t}\n', '\n', '\n', '\t// helper functions \n', '\tfunction isLogo (address _logoAddress) constant returns (bool) {\n', '\t\tfor (uint8 i = 0; i < logos.length; i++) {\n', '\t\t\tif (logos[i] == _logoAddress) return true;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction getLogos() constant returns (Logo[]) {\n', '\t\treturn logos;\n', '\t}\n', '\n', '\tfunction getBlockNumber() constant returns (uint) {\n', '      return block.number;\n', '    }\n', '\n', '\tfunction isAfterEnd() constant returns (bool) {\n', '      return getBlockNumber() > endBlock;\n', '    }\n', '\n', '\tfunction isRespectTimeFrame() constant returns (bool) {\n', '\t\treturn getBlockNumber() < endBlock;\n', '\t}\n', '\n', '\tfunction () payable {\n', '\t\tif (isAfterEnd()) throw;\n', '\t\tdonate(msg.sender);\n', '\t}\n', '}']
['pragma solidity ^0.4.10;\n', '\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '\n', '  function transfer(address to, uint value) returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) returns (bool ok);\n', '  function approve(address spender, uint value) returns (bool ok);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '/*\n', ' * Safe Math Smart Contract.  Copyright Â© 2016 by ABDK Consulting.\n', ' */\n', '\n', '/**\n', ' * Provides methods to safely add, subtract and multiply uint256 numbers.\n', ' */\n', 'contract SafeMath {\n', '  uint256 constant private MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '  /**\n', '   * Add two uint256 values, throw in case of overflow.\n', '   *\n', '   * @param x first value to add\n', '   * @param y second value to add\n', '   * @return x + y\n', '   */\n', '  function safeAdd (uint256 x, uint256 y)\n', '  constant internal\n', '  returns (uint256 z) {\n', '    if (x > MAX_UINT256 - y) throw;\n', '    return x + y;\n', '  }\n', '\n', '  /**\n', '   * Subtract one uint256 value from another, throw in case of underflow.\n', '   *\n', '   * @param x value to subtract from\n', '   * @param y value to subtract\n', '   * @return x - y\n', '   */\n', '  function safeSub (uint256 x, uint256 y)\n', '  constant internal\n', '  returns (uint256 z) {\n', '    if (x < y) throw;\n', '    return x - y;\n', '  }\n', '\n', '  /**\n', '   * Multiply two uint256 values, throw in case of overflow.\n', '   *\n', '   * @param x first value to multiply\n', '   * @param y second value to multiply\n', '   * @return x * y\n', '   */\n', '  function safeMul (uint256 x, uint256 y)\n', '  constant internal\n', '  returns (uint256 z) {\n', '    if (y == 0) return 0; // Prevent division by zero at the next line\n', '    if (x > MAX_UINT256 / y) throw;\n', '    return x * y;\n', '  }\n', '}\n', '\n', 'contract Vote is ERC20, SafeMath{\n', '\n', '\tmapping (address => uint) balances;\n', '\tmapping (address => mapping (address => uint)) allowed;\n', '\n', '\tuint public totalSupply;\n', '\tuint public initialSupply;\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\n', '\tfunction Vote(){\n', '\t\tinitialSupply = 100000;\n', '\t\ttotalSupply = initialSupply;\n', '\t\tbalances[msg.sender] = initialSupply;\n', '\t\tname = "EthTaipei Logo Vote";\n', '\t\tsymbol = "EthTaipei Logo";\n', '\t\tdecimals = 0;\n', '\t}\n', '\n', '\tfunction transfer(address _to, uint _value) returns (bool) {\n', '\t    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '\t    balances[_to] = safeAdd(balances[_to], _value);\n', '\t    Transfer(msg.sender, _to, _value);\n', '\t    return true;\n', '  \t}\n', '\n', '  \tfunction transferFrom(address _from, address _to, uint _value) returns (bool) {\n', '\t    var _allowance = allowed[_from][msg.sender];\t    \n', '\t    balances[_to] = safeAdd(balances[_to], _value);\n', '\t    balances[_from] = safeSub(balances[_from], _value);\n', '\t    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '\t    Transfer(_from, _to, _value);\n', '\t    return true;\n', '  \t}\n', '\n', '  \tfunction approve(address _spender, uint _value) returns (bool) {\n', '    \tallowed[msg.sender][_spender] = _value;\n', '    \tApproval(msg.sender, _spender, _value);\n', '    \treturn true;\n', '  \t}\n', '\n', '  \tfunction balanceOf(address _address) constant returns (uint balance) {\n', '  \t\treturn balances[_address];\n', '  \t}\n', '\n', '  \tfunction allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    \treturn allowed[_owner][_spender];\n', '  \t}\n', '\n', '}\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender == owner)\n', '      _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract wLogoVote {\n', '\tfunction claimReward(address _receiver);\n', '}\n', '\n', 'contract Logo is Ownable{\n', '\n', '\twLogoVote public logoVote;\n', '\n', '\taddress public author;\n', '\tstring public metadataUrl;\n', '\n', '\tevent ReceiveTips(address _from, uint _value);\n', '\n', '\tfunction Logo(address _owner, address _author, string _metadatUrl){\n', '\t\towner = _owner;\n', '\t\tauthor = _author;\n', '\t\tmetadataUrl = _metadatUrl;\n', '\t\tlogoVote = wLogoVote(msg.sender);\n', '\t}\n', '\n', '\tfunction tips() payable {\n', '\t\tReceiveTips(msg.sender, msg.value);\n', '\t\tif(!author.send(msg.value)) throw;\n', '\t}\n', '\n', '\tfunction claimReward() onlyOwner {\n', '\t\tlogoVote.claimReward(author);\n', '\t}\n', '\n', '\tfunction setMetadata(string _metadataUrl) onlyOwner {\n', '\t\tmetadataUrl = _metadataUrl;\n', '\t}\n', '\n', '\tfunction () payable {\n', '\t\ttips();\n', '\t}\n', '}\n', '/*\n', ' * Pausable\n', ' * Abstract contract that allows children to implement an\n', ' * emergency stop mechanism.\n', ' */\n', '\n', 'contract Pausable is Ownable {\n', '  bool public stopped;\n', '\n', '  modifier stopInEmergency {\n', '    if (stopped) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '  \n', '  modifier onlyInEmergency {\n', '    if (!stopped) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function emergencyStop() external onlyOwner {\n', '    stopped = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function release() external onlyOwner onlyInEmergency {\n', '    stopped = false;\n', '  }\n', '\n', '}\n', 'contract Token{\n', '\tfunction transfer(address to, uint value) returns (bool ok);\n', '}\n', '\n', 'contract Faucet {\n', '\n', '\taddress public tokenAddress;\n', '\tToken token;\n', '\n', '\tfunction Faucet(address _tokenAddress) {\n', '\t\ttokenAddress = _tokenAddress;\n', '\t\ttoken = Token(tokenAddress);\n', '\t}\n', '  \n', '\tfunction getToken() {\n', '\t\tif(!token.transfer(msg.sender, 1)) throw;\n', '\t}\n', '\n', '\tfunction () {\n', '\t\tgetToken();\n', '\t}\n', '\n', '}\n', '\n', 'contract LogoVote is Pausable, SafeMath{\n', '\n', '\tVote public vote;\n', '\tFaucet public faucet;\n', '\tLogo[] public logos;\n', '\n', '\tmapping (address => uint) backers;\n', '\tmapping (address => bool) rewards;\n', '\tuint rewardClaimed;\n', '\n', '\tuint public votePerETH;\n', '\tuint public totalReward;\n', '\tuint public startBlock;\n', '\tuint public endBlock;\n', '\taddress public winner;\n', '\n', '\tevent ReceiveDonate(address addr, uint value);\n', '\n', '\tmodifier respectTimeFrame() {\n', '\t\tif (!isRespectTimeFrame()) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier afterEnd() {\n', '\t\tif (!isAfterEnd()) throw;\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction LogoVote() {\n', '\t\tvote = new Vote();\n', '\t\tfaucet = new Faucet(vote);\n', '\t\tvotePerETH = 1000; // donate 0.001 ether to get 1 vote \n', '\t\ttotalReward = 0;\n', '\t\tstartBlock = getBlockNumber();\n', '\t\tendBlock = startBlock + ( 30 * 24 * 60 * 60 / 15 ); //end in 30 days\n', '\t\trewardClaimed = 0;\n', '\t}\n', '\n', '\t// functions only for owner \n', '\tfunction sendToFaucet(uint _amount) onlyOwner {\n', '\t\tif(!vote.transfer(faucet, _amount)) throw;\n', '\t}\n', '\n', '\tfunction registLogo(address _owner, address _author, string _metadatUrl) \n', '\t\t\t\t\t\tonlyOwner respectTimeFrame returns (address) {\n', '\t\tLogo logoAddress = new Logo(_owner, _author, _metadatUrl);\n', '\t\tlogos.push(logoAddress);\n', '\t\treturn logoAddress;\n', '\t}\n', '\n', '\tfunction claimWinner () onlyOwner afterEnd {\n', '\t\tif (isLogo(winner)) throw;\n', '\t\twinner = logos[0];\n', '\t\tfor (uint8 i = 1; i < logos.length; i++) {\n', '\t\t\tif (vote.balanceOf(logos[i]) > vote.balanceOf(winner))\n', '\t\t\t\twinner = logos[i];\n', '\t\t} \n', '\t}\n', '\n', '\tfunction cleanBalance () onlyOwner afterEnd {\n', '\t\tif (rewardClaimed >= logos.length || getBlockNumber() < endBlock + 43200) throw;\n', '\t\tif(!vote.transfer(owner, vote.balanceOf(this))) throw;\n', '\t\tif (!owner.send(this.balance)) throw;\n', '\t}\n', '\n', '\t// normal user can donate to get votes\n', '\tfunction donate(address beneficiary) internal stopInEmergency respectTimeFrame {\n', '\t\tuint voteToSend = safeMul(msg.value, votePerETH)/(1 ether);\n', '\t\tif (!vote.transfer(beneficiary, voteToSend)) throw; \n', '\t\tbackers[beneficiary] = safeAdd(backers[beneficiary], msg.value);\n', '\t\ttotalReward = safeAdd(totalReward, msg.value);\n', '\n', '\t\tReceiveDonate(beneficiary, msg.value);\n', '\t}\n', '\n', '\t// normal user can get back their funds if in emergency \n', '\tfunction getFunds() onlyInEmergency {\n', '\t\tif (backers[msg.sender] == 0) throw;\n', '\t\tuint amount = backers[msg.sender];\n', '\t\tbackers[msg.sender] = 0;\n', '\n', '\t\tif(!msg.sender.send(amount)) throw;\n', '\t}\n', '\n', "\t// logo's owner can claim their rewards after end \n", '\tfunction claimReward (address _receiver) stopInEmergency afterEnd {\n', '\t\tif (!isLogo(msg.sender)) throw;\n', '\t\tif (rewards[msg.sender]) throw;\n', '\t\tif (rewardClaimed == logos.length) throw;\n', '\t\tuint amount = totalReward / safeMul(2, logos.length); // all logos share the 50% of rewards\n', '\t\tif (msg.sender == winner) {\n', '\t\t\tamount = safeAdd(amount, totalReward/2);\n', '\t\t}\n', '\t\trewards[msg.sender] = true;\n', '\t\trewardClaimed = safeAdd(rewardClaimed, 1);\n', '\t\tif (!_receiver.send(amount)) throw;\n', '\t}\n', '\n', '\n', '\t// helper functions \n', '\tfunction isLogo (address _logoAddress) constant returns (bool) {\n', '\t\tfor (uint8 i = 0; i < logos.length; i++) {\n', '\t\t\tif (logos[i] == _logoAddress) return true;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction getLogos() constant returns (Logo[]) {\n', '\t\treturn logos;\n', '\t}\n', '\n', '\tfunction getBlockNumber() constant returns (uint) {\n', '      return block.number;\n', '    }\n', '\n', '\tfunction isAfterEnd() constant returns (bool) {\n', '      return getBlockNumber() > endBlock;\n', '    }\n', '\n', '\tfunction isRespectTimeFrame() constant returns (bool) {\n', '\t\treturn getBlockNumber() < endBlock;\n', '\t}\n', '\n', '\tfunction () payable {\n', '\t\tif (isAfterEnd()) throw;\n', '\t\tdonate(msg.sender);\n', '\t}\n', '}']
