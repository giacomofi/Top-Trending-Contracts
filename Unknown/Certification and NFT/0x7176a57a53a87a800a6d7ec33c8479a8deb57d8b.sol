['pragma solidity ^0.4.11;\n', '\n', '// ERC20 token interface is implemented only partially.\n', '\n', 'contract ARIToken {\n', '\n', '    /// @dev Constructor\n', '    /// @param _tokenManager Token manager address.\n', '    function ARIToken(address _tokenManager, address _escrow) {\n', '        tokenManager = _tokenManager;\n', '        escrow = _escrow;\n', '    }\n', '\n', '\n', '    /*/\n', '     *  Constants\n', '    /*/\n', '\n', '    string public constant name = "ARI Token";\n', '    string public constant symbol = "ARI";\n', '    uint   public constant decimals = 18;\n', '\n', '    /*/\n', '     *  Token state\n', '    /*/\n', '\n', '    enum Phase {\n', '        Created,\n', '        Running,\n', '        Paused,\n', '        Migrating,\n', '        Migrated\n', '    }\n', '\n', '    Phase public currentPhase = Phase.Created;\n', '    uint public totalSupply = 0; // amount of tokens already sold\n', '\n', '    uint public price = 2000;\n', '    uint public tokenSupplyLimit = 2000 * 10000 * (1 ether / 1 wei);\n', '\n', '    bool public transferable = false;\n', '\n', '    // Token manager has exclusive priveleges to call administrative\n', '    // functions on this contract.\n', '    address public tokenManager;\n', '\n', '    // Gathered funds can be withdrawn only to escrow&#39;s address.\n', '    address public escrow;\n', '\n', '    // Crowdsale manager has exclusive priveleges to burn presale tokens.\n', '    address public crowdsaleManager;\n', '\n', '    mapping (address => uint256) private balance;\n', '\n', '\n', '    modifier onlyTokenManager()     { if(msg.sender != tokenManager) throw; _; }\n', '    modifier onlyCrowdsaleManager() { if(msg.sender != crowdsaleManager) throw; _; }\n', '\n', '\n', '    /*/\n', '     *  Events\n', '    /*/\n', '\n', '    event LogBuy(address indexed owner, uint value);\n', '    event LogBurn(address indexed owner, uint value);\n', '    event LogPhaseSwitch(Phase newPhase);\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\n', '    /*/\n', '     *  Public functions\n', '    /*/\n', '\n', '    function() payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    /// @dev Lets buy you some tokens.\n', '    function buyTokens(address _buyer) public payable {\n', '        // Available only if presale is running.\n', '        if(currentPhase != Phase.Running) throw;\n', '\n', '        if(msg.value <= 0) throw;\n', '        uint newTokens = msg.value * price;\n', '        if (totalSupply + newTokens > tokenSupplyLimit) throw;\n', '        balance[_buyer] += newTokens;\n', '        totalSupply += newTokens;\n', '        LogBuy(_buyer, newTokens);\n', '    }\n', '\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    function burnTokens(address _owner) public\n', '        onlyCrowdsaleManager\n', '    {\n', '        // Available only during migration phase\n', '        if(currentPhase != Phase.Migrating) throw;\n', '\n', '        uint tokens = balance[_owner];\n', '        if(tokens == 0) throw;\n', '        balance[_owner] = 0;\n', '        totalSupply -= tokens;\n', '        LogBurn(_owner, tokens);\n', '\n', '        // Automatically switch phase when migration is done.\n', '        if(totalSupply == 0) {\n', '            currentPhase = Phase.Migrated;\n', '            LogPhaseSwitch(Phase.Migrated);\n', '        }\n', '    }\n', '\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    function balanceOf(address _owner) constant returns (uint256) {\n', '        return balance[_owner];\n', '    }\n', '\n', '\n', '    /*/\n', '     *  Administrative functions\n', '    /*/\n', '\n', '    function setPresalePhase(Phase _nextPhase) public\n', '        onlyTokenManager\n', '    {\n', '        bool canSwitchPhase\n', '            =  (currentPhase == Phase.Created && _nextPhase == Phase.Running)\n', '            || (currentPhase == Phase.Running && _nextPhase == Phase.Paused)\n', '                // switch to migration phase only if crowdsale manager is set\n', '            || ((currentPhase == Phase.Running || currentPhase == Phase.Paused)\n', '                && _nextPhase == Phase.Migrating\n', '                && crowdsaleManager != 0x0)\n', '            || (currentPhase == Phase.Paused && _nextPhase == Phase.Running)\n', '                // switch to migrated only if everyting is migrated\n', '            || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated\n', '                && totalSupply == 0);\n', '\n', '        if(!canSwitchPhase) throw;\n', '        currentPhase = _nextPhase;\n', '        LogPhaseSwitch(_nextPhase);\n', '    }\n', '\n', '\n', '    function withdrawEther() public\n', '        onlyTokenManager\n', '    {\n', '        // Available at any phase.\n', '        if(this.balance > 0) {\n', '            if(!escrow.send(this.balance)) throw;\n', '        }\n', '    }\n', '\n', '\n', '    function setCrowdsaleManager(address _mgr) public\n', '        onlyTokenManager\n', '    {\n', '        // You can&#39;t change crowdsale contract when migration is in progress.\n', '        if(currentPhase == Phase.Migrating) throw;\n', '        crowdsaleManager = _mgr;\n', '    }\n', '    \n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) {\n', '        if (!transferable) throw;\n', '        if (balance[msg.sender] < _value) throw;           // Check if the sender has enough\n', '        if (balance[_to] + _value < balance[_to]) throw; // Check for overflows\n', '        balance[msg.sender] -= _value;                     // Subtract from the sender\n', '        balance[_to] += _value;                            // Add the same to the recipient\n', '        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n', '    }\n', '    \n', '    function setTransferable(bool _value) public\n', '        onlyTokenManager\n', '    {\n', '        transferable = _value;\n', '    }\n', '    \n', '    function setPrice(uint256 _price) public\n', '        onlyTokenManager\n', '    {\n', '        if(currentPhase != Phase.Paused) throw;\n', '        if(_price <= 0) throw;\n', '\n', '        price = _price;\n', '    }\n', '\n', '    function setTokenSupplyLimit(uint256 _value) public\n', '        onlyTokenManager\n', '    {\n', '        if(currentPhase != Phase.Paused) throw;\n', '        if(_value <= 0) throw;\n', '\n', '        uint _tokenSupplyLimit;\n', '        _tokenSupplyLimit = _value * (1 ether / 1 wei);\n', '\n', '        if(totalSupply > _tokenSupplyLimit) throw;\n', '\n', '        tokenSupplyLimit = _tokenSupplyLimit;\n', '    }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '// ERC20 token interface is implemented only partially.\n', '\n', 'contract ARIToken {\n', '\n', '    /// @dev Constructor\n', '    /// @param _tokenManager Token manager address.\n', '    function ARIToken(address _tokenManager, address _escrow) {\n', '        tokenManager = _tokenManager;\n', '        escrow = _escrow;\n', '    }\n', '\n', '\n', '    /*/\n', '     *  Constants\n', '    /*/\n', '\n', '    string public constant name = "ARI Token";\n', '    string public constant symbol = "ARI";\n', '    uint   public constant decimals = 18;\n', '\n', '    /*/\n', '     *  Token state\n', '    /*/\n', '\n', '    enum Phase {\n', '        Created,\n', '        Running,\n', '        Paused,\n', '        Migrating,\n', '        Migrated\n', '    }\n', '\n', '    Phase public currentPhase = Phase.Created;\n', '    uint public totalSupply = 0; // amount of tokens already sold\n', '\n', '    uint public price = 2000;\n', '    uint public tokenSupplyLimit = 2000 * 10000 * (1 ether / 1 wei);\n', '\n', '    bool public transferable = false;\n', '\n', '    // Token manager has exclusive priveleges to call administrative\n', '    // functions on this contract.\n', '    address public tokenManager;\n', '\n', "    // Gathered funds can be withdrawn only to escrow's address.\n", '    address public escrow;\n', '\n', '    // Crowdsale manager has exclusive priveleges to burn presale tokens.\n', '    address public crowdsaleManager;\n', '\n', '    mapping (address => uint256) private balance;\n', '\n', '\n', '    modifier onlyTokenManager()     { if(msg.sender != tokenManager) throw; _; }\n', '    modifier onlyCrowdsaleManager() { if(msg.sender != crowdsaleManager) throw; _; }\n', '\n', '\n', '    /*/\n', '     *  Events\n', '    /*/\n', '\n', '    event LogBuy(address indexed owner, uint value);\n', '    event LogBurn(address indexed owner, uint value);\n', '    event LogPhaseSwitch(Phase newPhase);\n', '    /* This generates a public event on the blockchain that will notify clients */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\n', '    /*/\n', '     *  Public functions\n', '    /*/\n', '\n', '    function() payable {\n', '        buyTokens(msg.sender);\n', '    }\n', '\n', '    /// @dev Lets buy you some tokens.\n', '    function buyTokens(address _buyer) public payable {\n', '        // Available only if presale is running.\n', '        if(currentPhase != Phase.Running) throw;\n', '\n', '        if(msg.value <= 0) throw;\n', '        uint newTokens = msg.value * price;\n', '        if (totalSupply + newTokens > tokenSupplyLimit) throw;\n', '        balance[_buyer] += newTokens;\n', '        totalSupply += newTokens;\n', '        LogBuy(_buyer, newTokens);\n', '    }\n', '\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    function burnTokens(address _owner) public\n', '        onlyCrowdsaleManager\n', '    {\n', '        // Available only during migration phase\n', '        if(currentPhase != Phase.Migrating) throw;\n', '\n', '        uint tokens = balance[_owner];\n', '        if(tokens == 0) throw;\n', '        balance[_owner] = 0;\n', '        totalSupply -= tokens;\n', '        LogBurn(_owner, tokens);\n', '\n', '        // Automatically switch phase when migration is done.\n', '        if(totalSupply == 0) {\n', '            currentPhase = Phase.Migrated;\n', '            LogPhaseSwitch(Phase.Migrated);\n', '        }\n', '    }\n', '\n', '\n', '    /// @dev Returns number of tokens owned by given address.\n', '    /// @param _owner Address of token owner.\n', '    function balanceOf(address _owner) constant returns (uint256) {\n', '        return balance[_owner];\n', '    }\n', '\n', '\n', '    /*/\n', '     *  Administrative functions\n', '    /*/\n', '\n', '    function setPresalePhase(Phase _nextPhase) public\n', '        onlyTokenManager\n', '    {\n', '        bool canSwitchPhase\n', '            =  (currentPhase == Phase.Created && _nextPhase == Phase.Running)\n', '            || (currentPhase == Phase.Running && _nextPhase == Phase.Paused)\n', '                // switch to migration phase only if crowdsale manager is set\n', '            || ((currentPhase == Phase.Running || currentPhase == Phase.Paused)\n', '                && _nextPhase == Phase.Migrating\n', '                && crowdsaleManager != 0x0)\n', '            || (currentPhase == Phase.Paused && _nextPhase == Phase.Running)\n', '                // switch to migrated only if everyting is migrated\n', '            || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated\n', '                && totalSupply == 0);\n', '\n', '        if(!canSwitchPhase) throw;\n', '        currentPhase = _nextPhase;\n', '        LogPhaseSwitch(_nextPhase);\n', '    }\n', '\n', '\n', '    function withdrawEther() public\n', '        onlyTokenManager\n', '    {\n', '        // Available at any phase.\n', '        if(this.balance > 0) {\n', '            if(!escrow.send(this.balance)) throw;\n', '        }\n', '    }\n', '\n', '\n', '    function setCrowdsaleManager(address _mgr) public\n', '        onlyTokenManager\n', '    {\n', "        // You can't change crowdsale contract when migration is in progress.\n", '        if(currentPhase == Phase.Migrating) throw;\n', '        crowdsaleManager = _mgr;\n', '    }\n', '    \n', '    /* Send coins */\n', '    function transfer(address _to, uint256 _value) {\n', '        if (!transferable) throw;\n', '        if (balance[msg.sender] < _value) throw;           // Check if the sender has enough\n', '        if (balance[_to] + _value < balance[_to]) throw; // Check for overflows\n', '        balance[msg.sender] -= _value;                     // Subtract from the sender\n', '        balance[_to] += _value;                            // Add the same to the recipient\n', '        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n', '    }\n', '    \n', '    function setTransferable(bool _value) public\n', '        onlyTokenManager\n', '    {\n', '        transferable = _value;\n', '    }\n', '    \n', '    function setPrice(uint256 _price) public\n', '        onlyTokenManager\n', '    {\n', '        if(currentPhase != Phase.Paused) throw;\n', '        if(_price <= 0) throw;\n', '\n', '        price = _price;\n', '    }\n', '\n', '    function setTokenSupplyLimit(uint256 _value) public\n', '        onlyTokenManager\n', '    {\n', '        if(currentPhase != Phase.Paused) throw;\n', '        if(_value <= 0) throw;\n', '\n', '        uint _tokenSupplyLimit;\n', '        _tokenSupplyLimit = _value * (1 ether / 1 wei);\n', '\n', '        if(totalSupply > _tokenSupplyLimit) throw;\n', '\n', '        tokenSupplyLimit = _tokenSupplyLimit;\n', '    }\n', '}']
