['pragma solidity ^0.4.11;\n', '\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '/* taking ideas from FirstBlood token */\n', 'contract SafeMath {\n', '\n', '    /* function assert(bool assertion) internal { */\n', '    /*   if (!assertion) { */\n', '    /*     throw; */\n', '    /*   } */\n', '    /* }      // assert no longer needed once solidity is on 0.4.10 */\n', '\n', '    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x + y;\n', '      assert((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n', '      assert(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '\n', '}\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is Token {\n', '\n', '  modifier onlyPayloadSize(uint size) {\n', '     if(msg.data.length < size + 4) {\n', '       throw;\n', '     }\n', '     _;\n', '  }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract splitterContract is Ownable{\n', '\n', '    event ev(string msg, address whom, uint256 val);\n', '\n', '    struct xRec {\n', '        bool inList;\n', '        address next;\n', '        address prev;\n', '        uint256 val;\n', '    }\n', '\n', '    struct l8r {\n', '        address whom;\n', '        uint256 val;\n', '    }\n', '    address public myAddress = this;\n', '    address public first;\n', '    address public last;\n', '    address public ddf;\n', '    bool    public thinkMode;\n', '    uint256 public pos;\n', '\n', '    mapping (address => xRec) public theList;\n', '\n', '    l8r[]  afterParty;\n', '\n', '    modifier onlyMeOrDDF() {\n', '        if (msg.sender == ddf || msg.sender == myAddress || msg.sender == owner) {\n', '            _;\n', '            return;\n', '        }\n', '    }\n', '\n', '    function setDDF(address ddf_) onlyOwner {\n', '        ddf = ddf_;\n', '    }\n', '\n', '    function splitterContract(address seed, uint256 seedVal) {\n', '        first = seed;\n', '        last = seed;\n', '        theList[seed] = xRec(true,0x0,0x0,seedVal);\n', '    }\n', '\n', '    function startThinking() onlyOwner {\n', '        thinkMode = true;\n', '        pos = 0;\n', '    }\n', '\n', '    function stopThinking(uint256 num) onlyOwner {\n', '        thinkMode = false;\n', '        for (uint256 i = 0; i < num; i++) {\n', '            if (pos >= afterParty.length) {\n', '                delete afterParty;\n', '                return;\n', '            }\n', '            update(afterParty[pos].whom,afterParty[pos].val);\n', '            pos++;\n', '        }\n', '        thinkMode = true;\n', '    } \n', '\n', '    function thinkLength() constant returns (uint256) {\n', '        return afterParty.length;\n', '    }\n', '\n', '    function addRec4L8R(address whom, uint256 val) internal {\n', '        afterParty.push(l8r(whom,val));\n', '    }\n', '\n', '    function add(address whom, uint256 value) internal {\n', '        theList[whom] = xRec(true,0x0,last,value);\n', '        theList[last].next = whom;\n', '        last = whom;\n', '        ev("add",whom,value);\n', '    }\n', '\n', '    function remove(address whom) internal {\n', '        if (first == whom) {\n', '            first = theList[whom].next;\n', '            theList[whom] = xRec(false,0x0,0x0,0);\n', '            return;\n', '        }\n', '        address next = theList[whom].next;\n', '        address prev = theList[whom].prev;\n', '        if (prev != 0x0) {\n', '            theList[prev].next = next;\n', '        }\n', '        if (next != 0x0) {\n', '            theList[next].prev = prev;\n', '        }\n', '        theList[whom] = xRec(false,0x0,0x0,0);\n', '        ev("remove",whom,0);\n', '    }\n', '\n', '    function update(address whom, uint256 value) onlyMeOrDDF {\n', '        if (thinkMode) {\n', '            addRec4L8R(whom,value);\n', '            return;\n', '        }\n', '        if (value != 0) {\n', '            if (!theList[whom].inList) {\n', '                add(whom,value);\n', '            } else {\n', '                theList[whom].val = value;\n', '                ev("update",whom,value);\n', '            }\n', '            return;\n', '        }\n', '        if (theList[whom].inList) {\n', '                remove(whom);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', 'contract DDFToken is StandardToken, SafeMath {\n', '\n', '    // metadata\n', '    string public constant name = "Digital Developers Fund Token";\n', '    string public constant symbol = "DDF";\n', '    uint256 public constant decimals = 18;\n', '    string public version = "1.0";\n', '\n', '    // contracts\n', '    address public ethFundDeposit;      // deposit address for ETH for Domain Development Fund\n', '    address public ddftFundDeposit;     // deposit address for Domain Development Fund reserve\n', '    address public splitter;          // DA 8/6/2017 - splitter contract\n', '\n', '    // crowdsale parameters\n', '    bool public isFinalized;              // switched to true in operational state\n', '    uint256 public fundingStartTime;\n', '    uint256 public fundingEndTime;\n', '    uint256 public constant ddftFund = 1 * (10**6) * 10**decimals;   // 1m DDFT reserved for DDF use\n', '    uint256 public constant tokenExchangeRate = 1000;               // 1000 DDFT tokens per 1 ETH\n', '    uint256 public constant tokenCreationCap =  250 * (10**6) * 10**decimals;\n', '    uint256 public constant tokenCreationMin =  1 * (10**6) * 10**decimals;\n', '\n', '\n', '    // events\n', '    event LogRefund(address indexed _to, uint256 _value);\n', '    event CreateDDFT(address indexed _to, uint256 _value);\n', '\n', '    // constructor\n', '    function DDFToken(\n', '        address _ethFundDeposit,\n', '        address _ddftFundDeposit,\n', '        address _splitter, // DA 8/6/2017\n', '        uint256 _fundingStartTime,\n', '        uint256 duration)\n', '    {\n', '      isFinalized = false;                   //controls pre through crowdsale state\n', '      ethFundDeposit = _ethFundDeposit;\n', '      ddftFundDeposit = _ddftFundDeposit;\n', '      splitter =  _splitter ;                  // DA 8/6/2017\n', '      fundingStartTime = _fundingStartTime;\n', '      fundingEndTime = fundingStartTime + duration * 1 days;\n', '      totalSupply = ddftFund;\n', '      balances[ddftFundDeposit] = ddftFund;    // Deposit DDF share\n', '      CreateDDFT(ddftFundDeposit, ddftFund);  // logs DDF fund\n', '    }\n', '\n', '    function () payable {           // DA 8/6/2017 prefer to use fallback function\n', '      createTokens(msg.value);\n', '    }\n', '\n', '    /// @dev Accepts ether and creates new DDFT tokens.\n', '    function createTokens(uint256 _value)  internal {\n', '      if (isFinalized) throw;\n', '      if (now < fundingStartTime) throw;\n', '      if (now > fundingEndTime) throw;\n', '      if (msg.value == 0) throw;\n', '\n', '      uint256 tokens = safeMult(_value, tokenExchangeRate); // check that we&#39;re not over totals\n', '      uint256 checkedSupply = safeAdd(totalSupply, tokens);\n', '\n', '      // DA 8/6/2017 to fairly allocate the last few tokens\n', '      if (tokenCreationCap < checkedSupply) {\n', '        if (tokenCreationCap <= totalSupply) throw;  // CAP reached no more please\n', '        uint256 tokensToAllocate = safeSubtract(tokenCreationCap,totalSupply);\n', '        uint256 tokensToRefund   = safeSubtract(tokens,tokensToAllocate);\n', '        totalSupply = tokenCreationCap;\n', '        balances[msg.sender] += tokensToAllocate;  // safeAdd not needed; bad semantics to use here\n', '        uint256 etherToRefund = tokensToRefund / tokenExchangeRate;\n', '        msg.sender.transfer(etherToRefund);\n', '        CreateDDFT(msg.sender, tokensToAllocate);  // logs token creation\n', '        LogRefund(msg.sender,etherToRefund);\n', '        splitterContract(splitter).update(msg.sender,balances[msg.sender]);\n', '        return;\n', '      }\n', '      // DA 8/6/2017 end of fair allocation code\n', '      totalSupply = checkedSupply;\n', '      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\n', '      CreateDDFT(msg.sender, tokens);  // logs token creation\n', '      splitterContract(splitter).update(msg.sender,balances[msg.sender]);\n', '    }\n', '\n', '    /// @dev Ends the funding period and sends the ETH home\n', '    function finalize() external {\n', '      if (isFinalized) throw;\n', '      if (msg.sender != ethFundDeposit) throw; // locks finalize to the ultimate ETH owner\n', '      if(totalSupply < tokenCreationMin + ddftFund) throw;      // have to sell minimum to move to operational\n', '      if(now <= fundingEndTime && totalSupply != tokenCreationCap) throw;\n', '      // move to operational\n', '      isFinalized = true;\n', '      // DA 8/6/2017 change send/throw to transfer\n', '      ethFundDeposit.transfer(this.balance);  // send the eth to DDF\n', '    }\n', '\n', '    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\n', '    function refund() external {\n', '      if(isFinalized) throw;                       // prevents refund if operational\n', '      if (now <= fundingEndTime) throw; // prevents refund until sale period is over\n', '      if(totalSupply >= tokenCreationMin + ddftFund) throw;  // no refunds if we sold enough\n', '      if(msg.sender == ddftFundDeposit) throw;    // DDF not entitled to a refund\n', '      uint256 ddftVal = balances[msg.sender];\n', '      if (ddftVal == 0) throw;\n', '      balances[msg.sender] = 0;\n', '      totalSupply = safeSubtract(totalSupply, ddftVal); // extra safe\n', '      uint256 ethVal = ddftVal / tokenExchangeRate;     // should be safe; previous throws covers edges\n', '      LogRefund(msg.sender, ethVal);               // log it \n', '      // DA 8/6/2017 change send/throw to transfer\n', '      msg.sender.transfer(ethVal);                 // if you&#39;re using a contract; make sure it works with .send gas limits\n', '    }\n', '\n', '    // DA 8/6/2017\n', '    /// @dev Updates splitter contract with ownership changes\n', '    function transfer(address _to, uint _value) returns (bool success)  {\n', '      success = super.transfer(_to,_value);\n', '      splitterContract sc = splitterContract(splitter);\n', '      sc.update(msg.sender,balances[msg.sender]);\n', '      sc.update(_to,balances[_to]);\n', '      return;\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '\n', '/*\n', ' * Ownable\n', ' *\n', ' * Base contract with an owner.\n', ' * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '\n', '}\n', '\n', '/* taking ideas from FirstBlood token */\n', 'contract SafeMath {\n', '\n', '    /* function assert(bool assertion) internal { */\n', '    /*   if (!assertion) { */\n', '    /*     throw; */\n', '    /*   } */\n', '    /* }      // assert no longer needed once solidity is on 0.4.10 */\n', '\n', '    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x + y;\n', '      assert((z >= x) && (z >= y));\n', '      return z;\n', '    }\n', '\n', '    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n', '      assert(x >= y);\n', '      uint256 z = x - y;\n', '      return z;\n', '    }\n', '\n', '    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n', '      uint256 z = x * y;\n', '      assert((x == 0)||(z/x == y));\n', '      return z;\n', '    }\n', '\n', '}\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is Token {\n', '\n', '  modifier onlyPayloadSize(uint size) {\n', '     if(msg.data.length < size + 4) {\n', '       throw;\n', '     }\n', '     _;\n', '  }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '      } else {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', 'contract splitterContract is Ownable{\n', '\n', '    event ev(string msg, address whom, uint256 val);\n', '\n', '    struct xRec {\n', '        bool inList;\n', '        address next;\n', '        address prev;\n', '        uint256 val;\n', '    }\n', '\n', '    struct l8r {\n', '        address whom;\n', '        uint256 val;\n', '    }\n', '    address public myAddress = this;\n', '    address public first;\n', '    address public last;\n', '    address public ddf;\n', '    bool    public thinkMode;\n', '    uint256 public pos;\n', '\n', '    mapping (address => xRec) public theList;\n', '\n', '    l8r[]  afterParty;\n', '\n', '    modifier onlyMeOrDDF() {\n', '        if (msg.sender == ddf || msg.sender == myAddress || msg.sender == owner) {\n', '            _;\n', '            return;\n', '        }\n', '    }\n', '\n', '    function setDDF(address ddf_) onlyOwner {\n', '        ddf = ddf_;\n', '    }\n', '\n', '    function splitterContract(address seed, uint256 seedVal) {\n', '        first = seed;\n', '        last = seed;\n', '        theList[seed] = xRec(true,0x0,0x0,seedVal);\n', '    }\n', '\n', '    function startThinking() onlyOwner {\n', '        thinkMode = true;\n', '        pos = 0;\n', '    }\n', '\n', '    function stopThinking(uint256 num) onlyOwner {\n', '        thinkMode = false;\n', '        for (uint256 i = 0; i < num; i++) {\n', '            if (pos >= afterParty.length) {\n', '                delete afterParty;\n', '                return;\n', '            }\n', '            update(afterParty[pos].whom,afterParty[pos].val);\n', '            pos++;\n', '        }\n', '        thinkMode = true;\n', '    } \n', '\n', '    function thinkLength() constant returns (uint256) {\n', '        return afterParty.length;\n', '    }\n', '\n', '    function addRec4L8R(address whom, uint256 val) internal {\n', '        afterParty.push(l8r(whom,val));\n', '    }\n', '\n', '    function add(address whom, uint256 value) internal {\n', '        theList[whom] = xRec(true,0x0,last,value);\n', '        theList[last].next = whom;\n', '        last = whom;\n', '        ev("add",whom,value);\n', '    }\n', '\n', '    function remove(address whom) internal {\n', '        if (first == whom) {\n', '            first = theList[whom].next;\n', '            theList[whom] = xRec(false,0x0,0x0,0);\n', '            return;\n', '        }\n', '        address next = theList[whom].next;\n', '        address prev = theList[whom].prev;\n', '        if (prev != 0x0) {\n', '            theList[prev].next = next;\n', '        }\n', '        if (next != 0x0) {\n', '            theList[next].prev = prev;\n', '        }\n', '        theList[whom] = xRec(false,0x0,0x0,0);\n', '        ev("remove",whom,0);\n', '    }\n', '\n', '    function update(address whom, uint256 value) onlyMeOrDDF {\n', '        if (thinkMode) {\n', '            addRec4L8R(whom,value);\n', '            return;\n', '        }\n', '        if (value != 0) {\n', '            if (!theList[whom].inList) {\n', '                add(whom,value);\n', '            } else {\n', '                theList[whom].val = value;\n', '                ev("update",whom,value);\n', '            }\n', '            return;\n', '        }\n', '        if (theList[whom].inList) {\n', '                remove(whom);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', 'contract DDFToken is StandardToken, SafeMath {\n', '\n', '    // metadata\n', '    string public constant name = "Digital Developers Fund Token";\n', '    string public constant symbol = "DDF";\n', '    uint256 public constant decimals = 18;\n', '    string public version = "1.0";\n', '\n', '    // contracts\n', '    address public ethFundDeposit;      // deposit address for ETH for Domain Development Fund\n', '    address public ddftFundDeposit;     // deposit address for Domain Development Fund reserve\n', '    address public splitter;          // DA 8/6/2017 - splitter contract\n', '\n', '    // crowdsale parameters\n', '    bool public isFinalized;              // switched to true in operational state\n', '    uint256 public fundingStartTime;\n', '    uint256 public fundingEndTime;\n', '    uint256 public constant ddftFund = 1 * (10**6) * 10**decimals;   // 1m DDFT reserved for DDF use\n', '    uint256 public constant tokenExchangeRate = 1000;               // 1000 DDFT tokens per 1 ETH\n', '    uint256 public constant tokenCreationCap =  250 * (10**6) * 10**decimals;\n', '    uint256 public constant tokenCreationMin =  1 * (10**6) * 10**decimals;\n', '\n', '\n', '    // events\n', '    event LogRefund(address indexed _to, uint256 _value);\n', '    event CreateDDFT(address indexed _to, uint256 _value);\n', '\n', '    // constructor\n', '    function DDFToken(\n', '        address _ethFundDeposit,\n', '        address _ddftFundDeposit,\n', '        address _splitter, // DA 8/6/2017\n', '        uint256 _fundingStartTime,\n', '        uint256 duration)\n', '    {\n', '      isFinalized = false;                   //controls pre through crowdsale state\n', '      ethFundDeposit = _ethFundDeposit;\n', '      ddftFundDeposit = _ddftFundDeposit;\n', '      splitter =  _splitter ;                  // DA 8/6/2017\n', '      fundingStartTime = _fundingStartTime;\n', '      fundingEndTime = fundingStartTime + duration * 1 days;\n', '      totalSupply = ddftFund;\n', '      balances[ddftFundDeposit] = ddftFund;    // Deposit DDF share\n', '      CreateDDFT(ddftFundDeposit, ddftFund);  // logs DDF fund\n', '    }\n', '\n', '    function () payable {           // DA 8/6/2017 prefer to use fallback function\n', '      createTokens(msg.value);\n', '    }\n', '\n', '    /// @dev Accepts ether and creates new DDFT tokens.\n', '    function createTokens(uint256 _value)  internal {\n', '      if (isFinalized) throw;\n', '      if (now < fundingStartTime) throw;\n', '      if (now > fundingEndTime) throw;\n', '      if (msg.value == 0) throw;\n', '\n', "      uint256 tokens = safeMult(_value, tokenExchangeRate); // check that we're not over totals\n", '      uint256 checkedSupply = safeAdd(totalSupply, tokens);\n', '\n', '      // DA 8/6/2017 to fairly allocate the last few tokens\n', '      if (tokenCreationCap < checkedSupply) {\n', '        if (tokenCreationCap <= totalSupply) throw;  // CAP reached no more please\n', '        uint256 tokensToAllocate = safeSubtract(tokenCreationCap,totalSupply);\n', '        uint256 tokensToRefund   = safeSubtract(tokens,tokensToAllocate);\n', '        totalSupply = tokenCreationCap;\n', '        balances[msg.sender] += tokensToAllocate;  // safeAdd not needed; bad semantics to use here\n', '        uint256 etherToRefund = tokensToRefund / tokenExchangeRate;\n', '        msg.sender.transfer(etherToRefund);\n', '        CreateDDFT(msg.sender, tokensToAllocate);  // logs token creation\n', '        LogRefund(msg.sender,etherToRefund);\n', '        splitterContract(splitter).update(msg.sender,balances[msg.sender]);\n', '        return;\n', '      }\n', '      // DA 8/6/2017 end of fair allocation code\n', '      totalSupply = checkedSupply;\n', '      balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here\n', '      CreateDDFT(msg.sender, tokens);  // logs token creation\n', '      splitterContract(splitter).update(msg.sender,balances[msg.sender]);\n', '    }\n', '\n', '    /// @dev Ends the funding period and sends the ETH home\n', '    function finalize() external {\n', '      if (isFinalized) throw;\n', '      if (msg.sender != ethFundDeposit) throw; // locks finalize to the ultimate ETH owner\n', '      if(totalSupply < tokenCreationMin + ddftFund) throw;      // have to sell minimum to move to operational\n', '      if(now <= fundingEndTime && totalSupply != tokenCreationCap) throw;\n', '      // move to operational\n', '      isFinalized = true;\n', '      // DA 8/6/2017 change send/throw to transfer\n', '      ethFundDeposit.transfer(this.balance);  // send the eth to DDF\n', '    }\n', '\n', '    /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\n', '    function refund() external {\n', '      if(isFinalized) throw;                       // prevents refund if operational\n', '      if (now <= fundingEndTime) throw; // prevents refund until sale period is over\n', '      if(totalSupply >= tokenCreationMin + ddftFund) throw;  // no refunds if we sold enough\n', '      if(msg.sender == ddftFundDeposit) throw;    // DDF not entitled to a refund\n', '      uint256 ddftVal = balances[msg.sender];\n', '      if (ddftVal == 0) throw;\n', '      balances[msg.sender] = 0;\n', '      totalSupply = safeSubtract(totalSupply, ddftVal); // extra safe\n', '      uint256 ethVal = ddftVal / tokenExchangeRate;     // should be safe; previous throws covers edges\n', '      LogRefund(msg.sender, ethVal);               // log it \n', '      // DA 8/6/2017 change send/throw to transfer\n', "      msg.sender.transfer(ethVal);                 // if you're using a contract; make sure it works with .send gas limits\n", '    }\n', '\n', '    // DA 8/6/2017\n', '    /// @dev Updates splitter contract with ownership changes\n', '    function transfer(address _to, uint _value) returns (bool success)  {\n', '      success = super.transfer(_to,_value);\n', '      splitterContract sc = splitterContract(splitter);\n', '      sc.update(msg.sender,balances[msg.sender]);\n', '      sc.update(_to,balances[_to]);\n', '      return;\n', '    }\n', '\n', '}']
