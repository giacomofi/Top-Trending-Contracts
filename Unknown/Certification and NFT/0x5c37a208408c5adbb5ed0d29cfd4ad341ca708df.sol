['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', '// Interfacting Deployed Nertia Token \n', 'contract KairosToken{\n', '  function getExchangeRate() returns (uint256 exchangeRate);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '  function getOwner() returns (address owner);\n', '  function getDecimals() returns (uint256 decimals);\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', '\n', '/**\n', ' * ICO contract for the Nertia Token\n', ' */\n', 'contract Crowdsale {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  address public ethOwner;\n', '  address public kairosOwner;\n', '\n', '  KairosToken public token;\n', '\n', '  mapping(address => uint256) etherBlance;\n', '\n', '  uint256 public decimals;\n', '  uint256 public icoMinCap;\n', '    \n', '  bool public isFinalized;\n', '  uint256 public icoStartBlock;\n', '  uint256 public icoEndBlock;\n', '  uint256 public icoStartTime;\n', '  uint256 public totalSupply;\n', '  uint256 public exchangeRate;\n', '\n', '  event Refund(address indexed _to, uint256 _value);\n', '  event RefundError(address indexed _to, uint256 _value);\n', '    \n', '  function Crowdsale() {\n', '    token          = KairosToken(0xa6C9e4D4B34D432d4aea793Fa8C380b9940a5279);\n', '    decimals       = token.getDecimals();\n', '    exchangeRate   = 20;\n', '    isFinalized    = false;\n', '    icoStartTime   = now;\n', '    icoStartBlock  = block.number.add(15247);\n', '    icoEndBlock    = icoStartBlock.add(152470);\n', '    ethOwner       = 0x0fe777FA444Fae128169754877d51b665eE557Ee;\n', '    kairosOwner    = 0xa6C9e4D4B34D432d4aea793Fa8C380b9940a5279;\n', '    icoMinCap      = 15 * (10**6) * 10**decimals;\n', '  }\n', '\n', '\n', '  /// @dev Ends the funding period and sends the ETH home\n', '  function finalize() external {\n', '    if(isFinalized) throw;\n', '    if(msg.sender != ethOwner) throw; // locks finalize to the ultimate ETH owner\n', '    //if(totalSupply < icoMinCap) throw;      // have to sell minimum to move to operational\n', '    if(block.number <= icoEndBlock) throw;\n', '    \n', '    // move to operational\n', '    isFinalized = true;\n', '    if(!ethOwner.send(this.balance)) throw;  // send the eth to Nertia Owner\n', '  }\n', '\n', '\n', '  function refund(){\n', '    if(isFinalized) throw;\n', '    if(block.number <= icoEndBlock) throw;\n', '    if(msg.sender == token.getOwner() ) throw;\n', '\n', '    uint256 userBalance = token.balanceOf(msg.sender);\n', '    if(userBalance == 0) throw;\n', '\n', '    uint256 userEthers = etherBlance[msg.sender];\n', '    if(userEthers == 0) throw;    \n', '    \n', '    etherBlance[msg.sender] = 0;\n', '    \n', '    if(!token.transferFrom(msg.sender,kairosOwner, userBalance)) throw;\n', '\n', '    if(msg.sender.send(userEthers)){\n', '      Refund(msg.sender, userEthers);\n', '    }else{\n', '      etherBlance[msg.sender] = userEthers;\n', '      RefundError(msg.sender, userEthers);\n', '      throw;\n', '    }\n', '  }\n', '\n', '\n', '  function () payable {\n', '    if(isFinalized && msg.value <= 0) throw;\n', '\n', '    if(block.number < icoStartBlock) throw;\n', '    if(block.number > icoEndBlock) throw;\n', '\n', '    // storing user ethers;\n', '    etherBlance[msg.sender] += msg.value;\n', '\n', '    // calculating bonus\n', '    uint256 val = msg.value;\n', '    uint256 bonus  =  calcBonus(val);\n', '    uint256 level2bonus = calcLevel2Bonus(val);\n', '    uint256 tokens = msg.value.add(level2bonus).add(bonus).mul(exchangeRate);    \n', '    uint256 checkedSupply = totalSupply.add(tokens);\n', '    totalSupply = checkedSupply;\n', '    bool transfer = token.transferFrom( token.getOwner(),msg.sender, tokens);\n', '    if(!transfer){\n', '        totalSupply = totalSupply.sub(tokens);\n', '        throw;\n', '    }\n', '  }\n', '  \n', '  // Calculating bounus tokens\n', '  function calcBonus(uint256 _val) private constant returns (uint256){\n', '    return _val.div(100).mul(getPercentage());            \n', '  }  \n', '\n', '  // Calculating bonus percentage \n', '  function getPercentage() private constant returns (uint){\n', '    uint duration = now.sub(icoStartTime);\n', '    if(duration > 21 days){\n', '      return 0;\n', '    } else if(duration <= 21 days && duration > 14 days){\n', '      return 1;\n', '    } else if(duration <= 14 days && duration > 7 days){\n', '      return 3;\n', '    } else {\n', '      return 5;\n', '    }\n', '  }\n', '\n', '  function calcLevel2Bonus(uint256 _val) private constant returns(uint256) {\n', '    return _val.div(100).mul(level2Bonus(_val));\n', '  }\n', '\n', '  // calculating 2nd level bonus\n', '  function level2Bonus(uint256 tokens) private constant returns(uint256) {\n', '      if(tokens > 1000000){\n', '        return 5;   \n', '      }else if(tokens <= 999999 && tokens >= 100000){\n', '        return 3;\n', '      }else if(tokens <= 99999 && tokens >= 50000 ){\n', '        return 2;\n', '      }else if( tokens <= 49999 && tokens >= 10000){\n', '        return 1;\n', '      }\n', '      return 0;\n', '  }\n', '\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', '// Interfacting Deployed Nertia Token \n', 'contract KairosToken{\n', '  function getExchangeRate() returns (uint256 exchangeRate);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '  function getOwner() returns (address owner);\n', '  function getDecimals() returns (uint256 decimals);\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', '\n', '/**\n', ' * ICO contract for the Nertia Token\n', ' */\n', 'contract Crowdsale {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  address public ethOwner;\n', '  address public kairosOwner;\n', '\n', '  KairosToken public token;\n', '\n', '  mapping(address => uint256) etherBlance;\n', '\n', '  uint256 public decimals;\n', '  uint256 public icoMinCap;\n', '    \n', '  bool public isFinalized;\n', '  uint256 public icoStartBlock;\n', '  uint256 public icoEndBlock;\n', '  uint256 public icoStartTime;\n', '  uint256 public totalSupply;\n', '  uint256 public exchangeRate;\n', '\n', '  event Refund(address indexed _to, uint256 _value);\n', '  event RefundError(address indexed _to, uint256 _value);\n', '    \n', '  function Crowdsale() {\n', '    token          = KairosToken(0xa6C9e4D4B34D432d4aea793Fa8C380b9940a5279);\n', '    decimals       = token.getDecimals();\n', '    exchangeRate   = 20;\n', '    isFinalized    = false;\n', '    icoStartTime   = now;\n', '    icoStartBlock  = block.number.add(15247);\n', '    icoEndBlock    = icoStartBlock.add(152470);\n', '    ethOwner       = 0x0fe777FA444Fae128169754877d51b665eE557Ee;\n', '    kairosOwner    = 0xa6C9e4D4B34D432d4aea793Fa8C380b9940a5279;\n', '    icoMinCap      = 15 * (10**6) * 10**decimals;\n', '  }\n', '\n', '\n', '  /// @dev Ends the funding period and sends the ETH home\n', '  function finalize() external {\n', '    if(isFinalized) throw;\n', '    if(msg.sender != ethOwner) throw; // locks finalize to the ultimate ETH owner\n', '    //if(totalSupply < icoMinCap) throw;      // have to sell minimum to move to operational\n', '    if(block.number <= icoEndBlock) throw;\n', '    \n', '    // move to operational\n', '    isFinalized = true;\n', '    if(!ethOwner.send(this.balance)) throw;  // send the eth to Nertia Owner\n', '  }\n', '\n', '\n', '  function refund(){\n', '    if(isFinalized) throw;\n', '    if(block.number <= icoEndBlock) throw;\n', '    if(msg.sender == token.getOwner() ) throw;\n', '\n', '    uint256 userBalance = token.balanceOf(msg.sender);\n', '    if(userBalance == 0) throw;\n', '\n', '    uint256 userEthers = etherBlance[msg.sender];\n', '    if(userEthers == 0) throw;    \n', '    \n', '    etherBlance[msg.sender] = 0;\n', '    \n', '    if(!token.transferFrom(msg.sender,kairosOwner, userBalance)) throw;\n', '\n', '    if(msg.sender.send(userEthers)){\n', '      Refund(msg.sender, userEthers);\n', '    }else{\n', '      etherBlance[msg.sender] = userEthers;\n', '      RefundError(msg.sender, userEthers);\n', '      throw;\n', '    }\n', '  }\n', '\n', '\n', '  function () payable {\n', '    if(isFinalized && msg.value <= 0) throw;\n', '\n', '    if(block.number < icoStartBlock) throw;\n', '    if(block.number > icoEndBlock) throw;\n', '\n', '    // storing user ethers;\n', '    etherBlance[msg.sender] += msg.value;\n', '\n', '    // calculating bonus\n', '    uint256 val = msg.value;\n', '    uint256 bonus  =  calcBonus(val);\n', '    uint256 level2bonus = calcLevel2Bonus(val);\n', '    uint256 tokens = msg.value.add(level2bonus).add(bonus).mul(exchangeRate);    \n', '    uint256 checkedSupply = totalSupply.add(tokens);\n', '    totalSupply = checkedSupply;\n', '    bool transfer = token.transferFrom( token.getOwner(),msg.sender, tokens);\n', '    if(!transfer){\n', '        totalSupply = totalSupply.sub(tokens);\n', '        throw;\n', '    }\n', '  }\n', '  \n', '  // Calculating bounus tokens\n', '  function calcBonus(uint256 _val) private constant returns (uint256){\n', '    return _val.div(100).mul(getPercentage());            \n', '  }  \n', '\n', '  // Calculating bonus percentage \n', '  function getPercentage() private constant returns (uint){\n', '    uint duration = now.sub(icoStartTime);\n', '    if(duration > 21 days){\n', '      return 0;\n', '    } else if(duration <= 21 days && duration > 14 days){\n', '      return 1;\n', '    } else if(duration <= 14 days && duration > 7 days){\n', '      return 3;\n', '    } else {\n', '      return 5;\n', '    }\n', '  }\n', '\n', '  function calcLevel2Bonus(uint256 _val) private constant returns(uint256) {\n', '    return _val.div(100).mul(level2Bonus(_val));\n', '  }\n', '\n', '  // calculating 2nd level bonus\n', '  function level2Bonus(uint256 tokens) private constant returns(uint256) {\n', '      if(tokens > 1000000){\n', '        return 5;   \n', '      }else if(tokens <= 999999 && tokens >= 100000){\n', '        return 3;\n', '      }else if(tokens <= 99999 && tokens >= 50000 ){\n', '        return 2;\n', '      }else if( tokens <= 49999 && tokens >= 10000){\n', '        return 1;\n', '      }\n', '      return 0;\n', '  }\n', '\n', '\n', '}']
