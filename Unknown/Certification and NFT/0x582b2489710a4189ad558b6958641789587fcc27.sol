['pragma solidity ^0.4.11;\n', '// We have to specify what version of compiler this code will compile with\n', '\n', 'contract PonziUnlimited {\n', '\n', '  modifier onlyBy(address _account)\n', '    {\n', '        require(msg.sender == _account);\n', '        // Do not forget the "_;"! It will\n', '        // be replaced by the actual function\n', '        // body when the modifier is used.\n', '        _;\n', '    }\n', '\n', '  event GainsCalculated(\n', '    address receiver,\n', '    uint payedAmount,\n', '    uint gains,\n', '    uint contractBalance,\n', '    uint currentPayoutIndex\n', '  );\n', '\n', '  event FeesCalculated(\n', '    uint gains,\n', '    uint fees\n', '  );\n', '\n', '  event Payout(\n', '    address receiver,\n', '    uint value\n', '  );\n', '\n', '  event FeesPayout(\n', '    uint value\n', '  );\n', '\n', '  event FundsDeposited(\n', '    address depositor,\n', '    uint amount\n', '  );\n', '\n', '  event ComputedGainsRate(\n', '    address depositor,\n', '    uint gainsRate\n', '  );\n', '\n', '  struct Deposit {\n', '    address depositor;\n', '    uint amount;\n', '  }\n', '\n', '  struct PayoutItem {\n', '    address receiver;\n', '    uint amount;\n', '  }\n', '\n', '  address public master;\n', '  uint public feesRate;\n', '  uint public numDeposits;\n', '  uint public totalDeposited;\n', '  uint public totalGains;\n', '  uint public lastDeposit;\n', '  uint public profitsRatePercent;\n', '  uint public referedRateBonus;\n', '  uint public refereesRateBonus;\n', '  bool public active;\n', '  uint private currentPayoutIndex;\n', '\n', '  mapping (uint => Deposit) public depositsStack;\n', '\n', '  mapping (address => uint) public refereesCount;\n', '  mapping (address => uint) public pendingReferals;\n', '  mapping (address => uint) public addressGains;\n', '  mapping (address => uint[]) public addressPositions;\n', '  mapping (address => address) public refereeInvitations;\n', '  mapping (address => bool) public refereds;\n', '\n', '  PayoutItem[] public lastPayouts;\n', '\n', '  function PonziUnlimited() {\n', '    master = msg.sender;\n', '    feesRate = 10;\n', '    numDeposits = 0;\n', '    currentPayoutIndex = 0;\n', '    profitsRatePercent = 15;\n', '    referedRateBonus = 5;\n', '    refereesRateBonus = 5;\n', '    totalDeposited = 0;\n', '    totalGains = 0;\n', '    active = false;\n', '  }\n', '\n', '  function getPayout(uint index) constant returns (address receiver, uint amount) {\n', '    PayoutItem memory payout;\n', '    payout = lastPayouts[index];\n', '    return (payout.receiver, payout.amount);\n', '  }\n', '\n', '  function getLastPayouts() constant returns (address[10] lastReceivers, uint[10] lastAmounts) {\n', '    uint j = 0;\n', '    PayoutItem memory currentPayout;\n', '    uint length = lastPayouts.length;\n', '    uint startIndex = 0;\n', '\n', '    if (length > 10) {\n', '      startIndex = length - 10;\n', '    }\n', '\n', '    for(uint i = startIndex; i < length; i++) {\n', '      currentPayout = lastPayouts[i];\n', '      lastReceivers[j] = currentPayout.receiver;\n', '      lastAmounts[j] = currentPayout.amount;\n', '      j++;\n', '    }\n', '\n', '    return (lastReceivers, lastAmounts);\n', '  }\n', '\n', '  function getMaster() constant returns (address masterAddress) {\n', '    return master;\n', '  }\n', '\n', '  function getnumDeposits() constant returns (uint) {\n', '    return numDeposits;\n', '  }\n', '\n', '  function getContractMetrics() constant returns (uint, uint, uint, uint, bool) {\n', '    return (\n', '      this.balance,\n', '      totalDeposited,\n', '      totalGains,\n', '      numDeposits,\n', '      active\n', '    );\n', '  }\n', '\n', '  function setActive(bool activate) onlyBy(master) returns (bool) {\n', '    active = activate;\n', '\n', '    if (active) {\n', '      dispatchGains();\n', '    }\n', '    return active;\n', '  }\n', '\n', '  function inviteReferee(address referer, address referee) returns (bool success) {\n', '    success = true;\n', '\n', '    refereeInvitations[referee] = referer;\n', '    pendingReferals[referer] += 1;\n', '    return success;\n', '  }\n', '\n', '  function createReferee(address referer, address referee) private {\n', '    refereds[referee] = true;\n', '    refereesCount[referer] += 1;\n', '    pendingReferals[referer] -= 1;\n', '  }\n', '\n', '  function checkIfReferee(address referee) private {\n', '    address referer = refereeInvitations[referee];\n', '    if(referer != address(0)) {\n', '      createReferee(referer, referee);\n', '      delete refereeInvitations[referee];\n', '    }\n', '  }\n', '\n', '  function getAddressGains(address addr) constant returns(uint) {\n', '    return addressGains[addr];\n', '  }\n', '\n', '  function getCurrentPayoutIndex() constant returns(uint) {\n', '    return currentPayoutIndex;\n', '  }\n', '\n', '  function getEarliestPosition(address addr) constant returns(uint[]) {\n', '    return  addressPositions[addr];\n', '  }\n', '\n', '  function deposit() payable {\n', '    if(msg.value <= 0) throw;\n', '    lastDeposit = block.timestamp;\n', '    depositsStack[numDeposits] = Deposit(msg.sender, msg.value);\n', '    totalDeposited += msg.value;\n', '\n', '    checkIfReferee(msg.sender);\n', '    FundsDeposited(msg.sender, msg.value);\n', '    ++numDeposits;\n', '\n', '    addressPositions[msg.sender].push(numDeposits);\n', '\n', '    if(active) {\n', '      dispatchGains();\n', '    }\n', '  }\n', '\n', '  function resetBonuses(address depositor) private {\n', '    resetReferee(depositor);\n', '    resetReferedCount(depositor);\n', '  }\n', '\n', '  function setGainsRate(uint gainsRate) onlyBy(master) {\n', '    profitsRatePercent = gainsRate;\n', '  }\n', '\n', '  function resetReferee(address depositor) private {\n', '    refereds[depositor] = false;\n', '  }\n', '\n', '  function resetReferedCount(address depositor) private {\n', '    refereesCount[depositor] = 0;\n', '  }\n', '\n', '  function getAccountReferalsStats(address addr) constant returns(uint, uint) {\n', '\n', '    return (\n', '      getPendingReferals(addr),\n', '      getReferedCount(addr)\n', '    );\n', '  }\n', '\n', '  function computeGainsRate(address depositor) constant returns(uint gainsPercentage) {\n', '    gainsPercentage = profitsRatePercent;\n', '    if(isReferee(depositor)) {\n', '      gainsPercentage += referedRateBonus;\n', '    }\n', '\n', '    gainsPercentage += getReferedCount(depositor) * refereesRateBonus;\n', '\n', '    ComputedGainsRate(depositor, gainsPercentage);\n', '    return gainsPercentage;\n', '  }\n', '\n', ' function computeGains(Deposit deposit) private constant returns (uint gains, uint fees) {\n', '    gains = 0;\n', '\n', '    if(deposit.amount > 0) {\n', '      gains = (deposit.amount * computeGainsRate(deposit.depositor)) / 100;\n', '      fees = (gains * feesRate) / 100;\n', '\n', '      GainsCalculated(deposit.depositor, deposit.amount, gains, this.balance, currentPayoutIndex);\n', '      FeesCalculated(gains, fees);\n', '    }\n', '\n', '    return (\n', '      gains - fees,\n', '      fees\n', '    );\n', '  }\n', '\n', '  function isReferee(address referee) private constant returns (bool) {\n', '    return refereds[referee];\n', '  }\n', '\n', '  function getReferedCount(address referer) private constant returns (uint referedsCount) {\n', '    referedsCount = refereesCount[referer];\n', '    return referedsCount;\n', '  }\n', '\n', '  function getPendingReferals(address addr) private constant returns (uint) {\n', '    return  pendingReferals[addr];\n', '  }\n', '\n', '  function addNewPayout(PayoutItem payout) private {\n', '    lastPayouts.length++;\n', '    lastPayouts[lastPayouts.length-1] = payout;\n', '  }\n', '\n', '  function payout(Deposit deposit) private{\n', '\n', '    var (gains, fees) = computeGains(deposit);\n', '    bool success = false;\n', '    bool feesSuccess = false;\n', '    uint payableAmount = deposit.amount + gains;\n', '    address currentDepositor = deposit.depositor;\n', '\n', '    if(gains > 0 && this.balance > payableAmount) {\n', '      success = currentDepositor.send( payableAmount );\n', '      if (success) {\n', '        Payout(currentDepositor, payableAmount);\n', '        addNewPayout(PayoutItem(currentDepositor, payableAmount));\n', '        feesSuccess = master.send(fees);\n', '        if(feesSuccess) {\n', '          FeesPayout(fees);\n', '        }\n', '        resetBonuses(currentDepositor);\n', '        addressGains[currentDepositor] += gains;\n', '        totalGains += gains;\n', '        currentPayoutIndex ++;\n', '      }\n', '    }\n', '  }\n', '\n', '  function dispatchGains() {\n', '\n', '    for (uint i = currentPayoutIndex; i<numDeposits; i++){\n', '      payout(depositsStack[i]);\n', '    }\n', '  }\n', '\n', '  function() payable {\n', '    deposit();\n', '  }\n', '}']
['pragma solidity ^0.4.11;\n', '// We have to specify what version of compiler this code will compile with\n', '\n', 'contract PonziUnlimited {\n', '\n', '  modifier onlyBy(address _account)\n', '    {\n', '        require(msg.sender == _account);\n', '        // Do not forget the "_;"! It will\n', '        // be replaced by the actual function\n', '        // body when the modifier is used.\n', '        _;\n', '    }\n', '\n', '  event GainsCalculated(\n', '    address receiver,\n', '    uint payedAmount,\n', '    uint gains,\n', '    uint contractBalance,\n', '    uint currentPayoutIndex\n', '  );\n', '\n', '  event FeesCalculated(\n', '    uint gains,\n', '    uint fees\n', '  );\n', '\n', '  event Payout(\n', '    address receiver,\n', '    uint value\n', '  );\n', '\n', '  event FeesPayout(\n', '    uint value\n', '  );\n', '\n', '  event FundsDeposited(\n', '    address depositor,\n', '    uint amount\n', '  );\n', '\n', '  event ComputedGainsRate(\n', '    address depositor,\n', '    uint gainsRate\n', '  );\n', '\n', '  struct Deposit {\n', '    address depositor;\n', '    uint amount;\n', '  }\n', '\n', '  struct PayoutItem {\n', '    address receiver;\n', '    uint amount;\n', '  }\n', '\n', '  address public master;\n', '  uint public feesRate;\n', '  uint public numDeposits;\n', '  uint public totalDeposited;\n', '  uint public totalGains;\n', '  uint public lastDeposit;\n', '  uint public profitsRatePercent;\n', '  uint public referedRateBonus;\n', '  uint public refereesRateBonus;\n', '  bool public active;\n', '  uint private currentPayoutIndex;\n', '\n', '  mapping (uint => Deposit) public depositsStack;\n', '\n', '  mapping (address => uint) public refereesCount;\n', '  mapping (address => uint) public pendingReferals;\n', '  mapping (address => uint) public addressGains;\n', '  mapping (address => uint[]) public addressPositions;\n', '  mapping (address => address) public refereeInvitations;\n', '  mapping (address => bool) public refereds;\n', '\n', '  PayoutItem[] public lastPayouts;\n', '\n', '  function PonziUnlimited() {\n', '    master = msg.sender;\n', '    feesRate = 10;\n', '    numDeposits = 0;\n', '    currentPayoutIndex = 0;\n', '    profitsRatePercent = 15;\n', '    referedRateBonus = 5;\n', '    refereesRateBonus = 5;\n', '    totalDeposited = 0;\n', '    totalGains = 0;\n', '    active = false;\n', '  }\n', '\n', '  function getPayout(uint index) constant returns (address receiver, uint amount) {\n', '    PayoutItem memory payout;\n', '    payout = lastPayouts[index];\n', '    return (payout.receiver, payout.amount);\n', '  }\n', '\n', '  function getLastPayouts() constant returns (address[10] lastReceivers, uint[10] lastAmounts) {\n', '    uint j = 0;\n', '    PayoutItem memory currentPayout;\n', '    uint length = lastPayouts.length;\n', '    uint startIndex = 0;\n', '\n', '    if (length > 10) {\n', '      startIndex = length - 10;\n', '    }\n', '\n', '    for(uint i = startIndex; i < length; i++) {\n', '      currentPayout = lastPayouts[i];\n', '      lastReceivers[j] = currentPayout.receiver;\n', '      lastAmounts[j] = currentPayout.amount;\n', '      j++;\n', '    }\n', '\n', '    return (lastReceivers, lastAmounts);\n', '  }\n', '\n', '  function getMaster() constant returns (address masterAddress) {\n', '    return master;\n', '  }\n', '\n', '  function getnumDeposits() constant returns (uint) {\n', '    return numDeposits;\n', '  }\n', '\n', '  function getContractMetrics() constant returns (uint, uint, uint, uint, bool) {\n', '    return (\n', '      this.balance,\n', '      totalDeposited,\n', '      totalGains,\n', '      numDeposits,\n', '      active\n', '    );\n', '  }\n', '\n', '  function setActive(bool activate) onlyBy(master) returns (bool) {\n', '    active = activate;\n', '\n', '    if (active) {\n', '      dispatchGains();\n', '    }\n', '    return active;\n', '  }\n', '\n', '  function inviteReferee(address referer, address referee) returns (bool success) {\n', '    success = true;\n', '\n', '    refereeInvitations[referee] = referer;\n', '    pendingReferals[referer] += 1;\n', '    return success;\n', '  }\n', '\n', '  function createReferee(address referer, address referee) private {\n', '    refereds[referee] = true;\n', '    refereesCount[referer] += 1;\n', '    pendingReferals[referer] -= 1;\n', '  }\n', '\n', '  function checkIfReferee(address referee) private {\n', '    address referer = refereeInvitations[referee];\n', '    if(referer != address(0)) {\n', '      createReferee(referer, referee);\n', '      delete refereeInvitations[referee];\n', '    }\n', '  }\n', '\n', '  function getAddressGains(address addr) constant returns(uint) {\n', '    return addressGains[addr];\n', '  }\n', '\n', '  function getCurrentPayoutIndex() constant returns(uint) {\n', '    return currentPayoutIndex;\n', '  }\n', '\n', '  function getEarliestPosition(address addr) constant returns(uint[]) {\n', '    return  addressPositions[addr];\n', '  }\n', '\n', '  function deposit() payable {\n', '    if(msg.value <= 0) throw;\n', '    lastDeposit = block.timestamp;\n', '    depositsStack[numDeposits] = Deposit(msg.sender, msg.value);\n', '    totalDeposited += msg.value;\n', '\n', '    checkIfReferee(msg.sender);\n', '    FundsDeposited(msg.sender, msg.value);\n', '    ++numDeposits;\n', '\n', '    addressPositions[msg.sender].push(numDeposits);\n', '\n', '    if(active) {\n', '      dispatchGains();\n', '    }\n', '  }\n', '\n', '  function resetBonuses(address depositor) private {\n', '    resetReferee(depositor);\n', '    resetReferedCount(depositor);\n', '  }\n', '\n', '  function setGainsRate(uint gainsRate) onlyBy(master) {\n', '    profitsRatePercent = gainsRate;\n', '  }\n', '\n', '  function resetReferee(address depositor) private {\n', '    refereds[depositor] = false;\n', '  }\n', '\n', '  function resetReferedCount(address depositor) private {\n', '    refereesCount[depositor] = 0;\n', '  }\n', '\n', '  function getAccountReferalsStats(address addr) constant returns(uint, uint) {\n', '\n', '    return (\n', '      getPendingReferals(addr),\n', '      getReferedCount(addr)\n', '    );\n', '  }\n', '\n', '  function computeGainsRate(address depositor) constant returns(uint gainsPercentage) {\n', '    gainsPercentage = profitsRatePercent;\n', '    if(isReferee(depositor)) {\n', '      gainsPercentage += referedRateBonus;\n', '    }\n', '\n', '    gainsPercentage += getReferedCount(depositor) * refereesRateBonus;\n', '\n', '    ComputedGainsRate(depositor, gainsPercentage);\n', '    return gainsPercentage;\n', '  }\n', '\n', ' function computeGains(Deposit deposit) private constant returns (uint gains, uint fees) {\n', '    gains = 0;\n', '\n', '    if(deposit.amount > 0) {\n', '      gains = (deposit.amount * computeGainsRate(deposit.depositor)) / 100;\n', '      fees = (gains * feesRate) / 100;\n', '\n', '      GainsCalculated(deposit.depositor, deposit.amount, gains, this.balance, currentPayoutIndex);\n', '      FeesCalculated(gains, fees);\n', '    }\n', '\n', '    return (\n', '      gains - fees,\n', '      fees\n', '    );\n', '  }\n', '\n', '  function isReferee(address referee) private constant returns (bool) {\n', '    return refereds[referee];\n', '  }\n', '\n', '  function getReferedCount(address referer) private constant returns (uint referedsCount) {\n', '    referedsCount = refereesCount[referer];\n', '    return referedsCount;\n', '  }\n', '\n', '  function getPendingReferals(address addr) private constant returns (uint) {\n', '    return  pendingReferals[addr];\n', '  }\n', '\n', '  function addNewPayout(PayoutItem payout) private {\n', '    lastPayouts.length++;\n', '    lastPayouts[lastPayouts.length-1] = payout;\n', '  }\n', '\n', '  function payout(Deposit deposit) private{\n', '\n', '    var (gains, fees) = computeGains(deposit);\n', '    bool success = false;\n', '    bool feesSuccess = false;\n', '    uint payableAmount = deposit.amount + gains;\n', '    address currentDepositor = deposit.depositor;\n', '\n', '    if(gains > 0 && this.balance > payableAmount) {\n', '      success = currentDepositor.send( payableAmount );\n', '      if (success) {\n', '        Payout(currentDepositor, payableAmount);\n', '        addNewPayout(PayoutItem(currentDepositor, payableAmount));\n', '        feesSuccess = master.send(fees);\n', '        if(feesSuccess) {\n', '          FeesPayout(fees);\n', '        }\n', '        resetBonuses(currentDepositor);\n', '        addressGains[currentDepositor] += gains;\n', '        totalGains += gains;\n', '        currentPayoutIndex ++;\n', '      }\n', '    }\n', '  }\n', '\n', '  function dispatchGains() {\n', '\n', '    for (uint i = currentPayoutIndex; i<numDeposits; i++){\n', '      payout(depositsStack[i]);\n', '    }\n', '  }\n', '\n', '  function() payable {\n', '    deposit();\n', '  }\n', '}']
