['pragma solidity ^0.4.14;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '}\n', '\n', 'contract PariMutuel is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  enum Outcome { Mayweather, McGregor }\n', '  enum State { PreEvent, DuringEvent, PostEvent, Refunding }\n', '\n', '  event BetPlaced(address indexed bettor, uint256 amount, Outcome outcome);\n', '  event StateChanged(State _state);\n', '  event WinningOutcomeDeclared(Outcome outcome);\n', '  event Withdrawal(address indexed bettor, uint256 amount);\n', '\n', '  uint256 public constant percentRake = 2;\n', '  uint256 public constant minBetAmount = 0.01 ether;\n', '  uint8 public constant numberOfOutcomes = 2; // need this until Solidity allows Outcome.length\n', '\n', '  Outcome public winningOutcome;\n', '  State public state;\n', '\n', '  mapping(uint8 => mapping(address => uint256)) balancesForOutcome;\n', '  mapping(uint8 => uint256) public totalForOutcome;\n', '\n', '  bool public hasWithdrawnRake;\n', '  mapping(address => bool) refunded;\n', '\n', '  function PariMutuel() {\n', '    state = State.PreEvent;\n', '  }\n', '\n', '  modifier requireState(State _state) {\n', '    require(state == _state);\n', '    _;\n', '  }\n', '\n', '  function bet(Outcome outcome) external payable requireState(State.PreEvent) {\n', '    require(msg.value >= minBetAmount);\n', '    balancesForOutcome[uint8(outcome)][msg.sender] = balancesForOutcome[uint8(outcome)][msg.sender].add(msg.value);\n', '    totalForOutcome[uint8(outcome)] = totalForOutcome[uint8(outcome)].add(msg.value);\n', '    BetPlaced(msg.sender, msg.value, outcome);\n', '  }\n', '\n', '  function totalWagered() public constant returns (uint256) {\n', '    uint256 total = 0;\n', '    for (uint8 i = 0; i < numberOfOutcomes; i++) {\n', '      total = total.add(totalForOutcome[i]);\n', '    }\n', '    return total;\n', '  }\n', '\n', '  function totalRake() public constant returns (uint256) {\n', '    return totalWagered().mul(percentRake) / 100;\n', '  }\n', '\n', '  function totalPrizePool() public constant returns (uint256) {\n', '    return totalWagered().sub(totalRake());\n', '  }\n', '\n', '  function totalWageredForAddress(address _address) public constant returns (uint256) {\n', '    uint256 total = 0;\n', '    for (uint8 i = 0; i < numberOfOutcomes; i++) {\n', '      total = total.add(balancesForOutcome[i][_address]);\n', '    }\n', '    return total;\n', '  }\n', '\n', '  // THERE MIGHT BE ROUNDING ERRORS\n', '  // BUT THIS IS JUST FOR DISPLAY ANYWAYS\n', '  // e.g. totalPrizePool = 2.97, risk = 2.5\n', '  // we return 1.18 when really it should be 1.19\n', '  function decimalOddsForOutcome(Outcome outcome) external constant returns (uint256 integer, uint256 fractional) {\n', '    uint256 toWin = totalPrizePool();\n', '    uint256 risk = totalForOutcome[uint8(outcome)];\n', '    uint256 remainder = toWin % risk;\n', '    return (toWin / risk, (remainder * 100) / risk);\n', '  }\n', '\n', '  function payoutForWagerAndOutcome(uint256 wager, Outcome outcome) public constant returns (uint256) {\n', '    return totalPrizePool().mul(wager) / totalForOutcome[uint8(outcome)];\n', '  }\n', '\n', '  function startEvent() external onlyOwner requireState(State.PreEvent) {\n', '    state = State.DuringEvent;\n', '    StateChanged(state);\n', '  }\n', '\n', '  function declareWinningOutcome(Outcome outcome) external onlyOwner requireState(State.DuringEvent) {\n', '    state = State.PostEvent;\n', '    StateChanged(state);\n', '    winningOutcome = outcome;\n', '    WinningOutcomeDeclared(outcome);\n', '  }\n', '\n', '  // if there&#39;s a draw or a bug in the contract\n', '  function refundEverybody() external onlyOwner {\n', '    state = State.Refunding;\n', '    StateChanged(state);\n', '  }\n', '\n', '  function getRefunded() external requireState(State.Refunding) {\n', '    require(!refunded[msg.sender]);\n', '    refunded[msg.sender] = true;\n', '    msg.sender.transfer(totalWageredForAddress(msg.sender));\n', '  }\n', '\n', '  function withdrawRake() external onlyOwner requireState(State.PostEvent) {\n', '    require(!hasWithdrawnRake);\n', '    hasWithdrawnRake = true;\n', '    owner.transfer(totalRake());\n', '  }\n', '\n', '  function withdrawWinnings() external requireState(State.PostEvent) {\n', '    uint256 wager = balancesForOutcome[uint8(winningOutcome)][msg.sender];\n', '    require(wager > 0);\n', '    uint256 winnings = payoutForWagerAndOutcome(wager, winningOutcome);\n', '    balancesForOutcome[uint8(winningOutcome)][msg.sender] = 0;\n', '    msg.sender.transfer(winnings);\n', '    Withdrawal(msg.sender, winnings);\n', '  }\n', '}']
['pragma solidity ^0.4.14;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '}\n', '\n', 'contract PariMutuel is Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  enum Outcome { Mayweather, McGregor }\n', '  enum State { PreEvent, DuringEvent, PostEvent, Refunding }\n', '\n', '  event BetPlaced(address indexed bettor, uint256 amount, Outcome outcome);\n', '  event StateChanged(State _state);\n', '  event WinningOutcomeDeclared(Outcome outcome);\n', '  event Withdrawal(address indexed bettor, uint256 amount);\n', '\n', '  uint256 public constant percentRake = 2;\n', '  uint256 public constant minBetAmount = 0.01 ether;\n', '  uint8 public constant numberOfOutcomes = 2; // need this until Solidity allows Outcome.length\n', '\n', '  Outcome public winningOutcome;\n', '  State public state;\n', '\n', '  mapping(uint8 => mapping(address => uint256)) balancesForOutcome;\n', '  mapping(uint8 => uint256) public totalForOutcome;\n', '\n', '  bool public hasWithdrawnRake;\n', '  mapping(address => bool) refunded;\n', '\n', '  function PariMutuel() {\n', '    state = State.PreEvent;\n', '  }\n', '\n', '  modifier requireState(State _state) {\n', '    require(state == _state);\n', '    _;\n', '  }\n', '\n', '  function bet(Outcome outcome) external payable requireState(State.PreEvent) {\n', '    require(msg.value >= minBetAmount);\n', '    balancesForOutcome[uint8(outcome)][msg.sender] = balancesForOutcome[uint8(outcome)][msg.sender].add(msg.value);\n', '    totalForOutcome[uint8(outcome)] = totalForOutcome[uint8(outcome)].add(msg.value);\n', '    BetPlaced(msg.sender, msg.value, outcome);\n', '  }\n', '\n', '  function totalWagered() public constant returns (uint256) {\n', '    uint256 total = 0;\n', '    for (uint8 i = 0; i < numberOfOutcomes; i++) {\n', '      total = total.add(totalForOutcome[i]);\n', '    }\n', '    return total;\n', '  }\n', '\n', '  function totalRake() public constant returns (uint256) {\n', '    return totalWagered().mul(percentRake) / 100;\n', '  }\n', '\n', '  function totalPrizePool() public constant returns (uint256) {\n', '    return totalWagered().sub(totalRake());\n', '  }\n', '\n', '  function totalWageredForAddress(address _address) public constant returns (uint256) {\n', '    uint256 total = 0;\n', '    for (uint8 i = 0; i < numberOfOutcomes; i++) {\n', '      total = total.add(balancesForOutcome[i][_address]);\n', '    }\n', '    return total;\n', '  }\n', '\n', '  // THERE MIGHT BE ROUNDING ERRORS\n', '  // BUT THIS IS JUST FOR DISPLAY ANYWAYS\n', '  // e.g. totalPrizePool = 2.97, risk = 2.5\n', '  // we return 1.18 when really it should be 1.19\n', '  function decimalOddsForOutcome(Outcome outcome) external constant returns (uint256 integer, uint256 fractional) {\n', '    uint256 toWin = totalPrizePool();\n', '    uint256 risk = totalForOutcome[uint8(outcome)];\n', '    uint256 remainder = toWin % risk;\n', '    return (toWin / risk, (remainder * 100) / risk);\n', '  }\n', '\n', '  function payoutForWagerAndOutcome(uint256 wager, Outcome outcome) public constant returns (uint256) {\n', '    return totalPrizePool().mul(wager) / totalForOutcome[uint8(outcome)];\n', '  }\n', '\n', '  function startEvent() external onlyOwner requireState(State.PreEvent) {\n', '    state = State.DuringEvent;\n', '    StateChanged(state);\n', '  }\n', '\n', '  function declareWinningOutcome(Outcome outcome) external onlyOwner requireState(State.DuringEvent) {\n', '    state = State.PostEvent;\n', '    StateChanged(state);\n', '    winningOutcome = outcome;\n', '    WinningOutcomeDeclared(outcome);\n', '  }\n', '\n', "  // if there's a draw or a bug in the contract\n", '  function refundEverybody() external onlyOwner {\n', '    state = State.Refunding;\n', '    StateChanged(state);\n', '  }\n', '\n', '  function getRefunded() external requireState(State.Refunding) {\n', '    require(!refunded[msg.sender]);\n', '    refunded[msg.sender] = true;\n', '    msg.sender.transfer(totalWageredForAddress(msg.sender));\n', '  }\n', '\n', '  function withdrawRake() external onlyOwner requireState(State.PostEvent) {\n', '    require(!hasWithdrawnRake);\n', '    hasWithdrawnRake = true;\n', '    owner.transfer(totalRake());\n', '  }\n', '\n', '  function withdrawWinnings() external requireState(State.PostEvent) {\n', '    uint256 wager = balancesForOutcome[uint8(winningOutcome)][msg.sender];\n', '    require(wager > 0);\n', '    uint256 winnings = payoutForWagerAndOutcome(wager, winningOutcome);\n', '    balancesForOutcome[uint8(winningOutcome)][msg.sender] = 0;\n', '    msg.sender.transfer(winnings);\n', '    Withdrawal(msg.sender, winnings);\n', '  }\n', '}']
