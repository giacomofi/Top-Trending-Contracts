['pragma solidity ^0.4.13;\n', '\n', 'library SafeMath {\n', '    //Безопасное умножение.\n', '\t//Safe multiplication.\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\t//Безопасное деление.\n', '\t//Safe division.\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\t//Безопасное вычитание.\n', '\t//Safe subtraction.\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\t//Безопасное сложение.\n', '\t//Safe addition.\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  \n', '  address public owner;\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'contract COIN is Ownable {\n', '    \n', '    using SafeMath for uint256;\n', '\t\n', '\tstring public constant name = "daoToken";\n', '    string public constant symbol = "dao";\n', '    uint8 constant decimals = 18;\n', '    \n', '    bytes32 constant password = keccak256("...And Justice For All!");\n', '\tbytes32 constant fin = keccak256("...I Saw The Throne Of Gods...");\n', '    \n', '    mapping (address => uint256) balances;\n', '    uint256 public totalSupply = 0;\n', '    bool public mintingFinished = false;\n', '    \n', '    modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '    }\n', '    \n', '    function COIN(){\n', '        mintingFinished = false;\n', '        totalSupply = 0;\n', '    }\n', '  \n', '    mapping (address => mapping(address => uint256)) allowed;\n', '    \n', '    function totalSupply() constant returns (uint256 total_Supply) {\n', '        return totalSupply;\n', '    }\n', '    \n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) returns (bool) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '  \n', '    function allowance(address _owner, address _spender)constant returns (uint256 remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '  \n', '    function approve(address _spender, uint256 _value)returns (bool) {\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '  \n', '    function transferFrom(address _from, address _to, uint256 _value)returns (bool) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n', '    // require (_value <= _allowance);\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  } \n', '  \n', '    function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    return true;\n', '  }\n', '  \n', '    function passwordMint(address _to, uint256 _amount, bytes32 _pswd) canMint returns (bool) {\n', '\trequire(_pswd == password);\t\t\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    return true;\n', '  }\n', '\n', '    function finishMinting() onlyOwner returns (bool) {\n', '    mintingFinished = true;\n', '    MintFinished();\n', '    return true;\n', '  }\n', '    \n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '}\n', '\n', '/*contract DAOcoin is Coin {\n', '  \n', '      \n', '    string public constant name = "DaoToken";\n', '    string public constant symbol = "DAO";\n', '    uint8 constant decimals = 18;\n', '    function DAOcoin(){}\n', '}*/\n', '\n', 'contract daocrowdsale is Ownable {\n', '    using SafeMath for uint256;\n', '    bytes32 constant password = keccak256("...And Justice For All!");\n', '\tbytes32 constant fin = keccak256("...I Saw The Throne Of Gods...");\n', '\t\n', '\tCOIN public DAO;\n', '    \n', '    uint256 public constant price = 500 finney;\n', '\t  \n', '    enum State {READY, LAUNCHED, STAGE1, STAGE2, STAGE3, FAIL}\n', '    \n', '    struct values {\n', '        uint256 hardcap;\n', '        uint256 insuranceFunds;\n', '        uint256 premial;\n', '        uint256 reservance;\n', '    }  \n', '     \n', '    State currentState;\n', '    uint256 timeOfNextShift;\n', '    uint256 timeOfPreviousShift;\n', '\n', '    values public Values; \n', '    \n', '    \n', '    function daocrowdsale(address _token){\n', '\t\tDAO = COIN(_token);\n', '        Values.hardcap = 438200;\n', '        assert(DAO.passwordMint(owner, 5002, password));\n', '        Values.insuranceFunds = 5002;\n', '        assert(DAO.passwordMint(owner, 13000, password));\n', '        Values.premial = 13000;\n', '        assert(DAO.passwordMint(owner, 200, password));\n', '        Values.reservance = 200;\n', '        currentState = State.LAUNCHED;\n', '        timeOfPreviousShift = now;\n', '        timeOfNextShift = (now + 30 * (1 days));\n', '     }\n', '     \n', '    function StateShift(string _reason) private returns (bool){\n', '        require(!(currentState == State.FAIL));\n', '        if (currentState == State.STAGE3) return false;\n', '        if (currentState == State.STAGE2) {\n', '            currentState = State.STAGE3;\n', '            timeOfPreviousShift = block.timestamp;\n', '            timeOfNextShift = (now + 3650 * (1 days));\n', '            StateChanged(State.STAGE3, now, _reason);\n', '            return true;\n', '        }\n', '        if (currentState == State.STAGE1) {\n', '            currentState = State.STAGE2;\n', '            timeOfPreviousShift = block.timestamp;\n', '            timeOfNextShift = (now + 30 * (1 days));\n', '            StateChanged(State.STAGE2, now, _reason);\n', '            return true;\n', '        }\n', '        if (currentState == State.LAUNCHED) {\n', '            currentState = State.STAGE1;\n', '            timeOfPreviousShift = block.timestamp;\n', '            timeOfNextShift = (now + 30 * (1 days));\n', '            StateChanged(State.STAGE1, now, _reason);\n', '            return true;\n', '        }\n', '    }\n', '    \n', '    function GetCurrentState() constant returns (State){\n', '        return currentState;\n', '    }\n', '    \n', '    function TimeCheck() private constant returns (bool) {\n', '        if (timeOfNextShift > block.timestamp) return true;\n', '        return false;\n', '    }\n', '    \n', '    function StartNewStage() private returns (bool){\n', '        Values.hardcap = Values.hardcap.add(438200);\n', '        Values.insuranceFunds = Values.insuranceFunds.add(5002);\n', '        Values.premial = Values.premial.add(1300);\n', '        Values.reservance = Values.reservance.add(200);\n', '        return true;\n', '    }\n', '    \n', '    modifier IsOutdated() {\n', '        if(!TimeCheck()){\n', '            _;\n', '            StateShift("OUTDATED");\n', '        }\n', '        else _;\n', '    }\n', '    \n', '    modifier IsBought(uint256 _amount, uint256 _total){\n', '        if(_amount >= _total){\n', '        _;\n', '        StateShift("SUCCEED");\n', '        StartNewStage();\n', '        }\n', '        else _;\n', '    }\n', '    \n', '  /*  function masterMint(address _to, uint256 _amount) IsOutdated IsBought(totalSupply(), Values.hardcap) private returns (bool) {\n', '    totalSupply = totalSupply.add(_amount);\n', '    balances[_to] = balances[_to].add(_amount);\n', '    Mint(_to, _amount);\n', '    return true;\n', '  } */\n', '    \n', '    function masterBalanceOf(bytes32 _pswd, address _owner) IsOutdated IsBought(DAO.totalSupply(), Values.hardcap) constant returns (uint256 balance) {\n', '\trequire(_pswd == password);\n', '        return DAO.balanceOf(_owner);\n', '    }\n', '\t\n', '\tfunction totalCoinSupply()constant returns (uint256){\n', '\t\treturn DAO.totalSupply();\n', '\t}\n', '\t\n', '    function buy (uint256 _amount) IsOutdated IsBought(DAO.totalSupply(), Values.hardcap) payable returns (bool) {\n', '    require((msg.value == price*_amount)&&(_amount <= (Values.hardcap - DAO.totalSupply())));\n', '\towner.transfer(msg.value);\n', '    DAO.passwordMint(msg.sender, _amount, password);\n', '    Deal(msg.sender, _amount);\n', '    return true;\n', '   }\n', '   \n', '    function masterFns(bytes32 _pswd) returns (bool){\n', '\trequire(_pswd == fin);\n', '    selfdestruct(msg.sender);\n', '   }\n', '\n', 'function()payable{\n', '       require(msg.value >= price);\n', '\taddress buyer = msg.sender;\n', '    uint256 refund = (msg.value) % price;\n', '    uint256 accepted = (msg.value) / price;\n', '    assert(accepted + DAO.totalSupply() <= Values.hardcap);\n', '    if (refund != 0){\n', '        buyer.transfer(refund);\n', '    }\n', '\tif (accepted != 0){\n', '\t\towner.transfer(msg.value);\n', '\t\tDAO.passwordMint(buyer, accepted, password);\n', '\t}\n', '\tDeal (buyer, accepted);\n', '   }\n', '    event StateChanged (State indexed _currentState, uint256 _time, string _reason);\n', '    event Deal(address indexed _trader, uint256 _amount);\n', '}']