['pragma solidity ^0.4.13; \n', '\n', '\n', '////////////////// >>>>> Wallet Contract <<<<< ///////////////////\n', '\n', '\n', '/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\n', '/// @author Stefan George - <<span class="__cf_email__" data-cfemail="b5c6c1d0d3d4db9bd2d0dac7d2d0f5d6dadbc6d0dbc6ccc69bdbd0c1">[email&#160;protected]</span>>\n', 'contract MultiSigWallet {\n', '\n', '    uint constant public MAX_OWNER_COUNT = 50;\n', '\n', '    event Confirmation(address indexed sender, uint indexed transactionId);\n', '    event Revocation(address indexed sender, uint indexed transactionId);\n', '    event Submission(uint indexed transactionId);\n', '    event Execution(uint indexed transactionId);\n', '    event ExecutionFailure(uint indexed transactionId);\n', '    event Deposit(address indexed sender, uint value);\n', '    event OwnerAddition(address indexed owner);\n', '    event OwnerRemoval(address indexed owner);\n', '    event RequirementChange(uint required);\n', '\n', '    mapping (uint => Transaction) public transactions;\n', '    mapping (uint => mapping (address => bool)) public confirmations;\n', '    mapping (address => bool) public isOwner;\n', '    address[] public owners;\n', '    uint public required;\n', '    uint public transactionCount;\n', '\n', '    struct Transaction {\n', '        address destination;\n', '        uint value;\n', '        bytes data;\n', '        bool executed;\n', '    }\n', '\n', '    modifier onlyWallet() {\n', '        if (msg.sender != address(this))\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    modifier ownerDoesNotExist(address owner) {\n', '        if (isOwner[owner])\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    modifier ownerExists(address owner) {\n', '        if (!isOwner[owner])\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    modifier transactionExists(uint transactionId) {\n', '        if (transactions[transactionId].destination == 0)\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    modifier confirmed(uint transactionId, address owner) {\n', '        if (!confirmations[transactionId][owner])\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    modifier notConfirmed(uint transactionId, address owner) {\n', '        if (confirmations[transactionId][owner])\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    modifier notExecuted(uint transactionId) {\n', '        if (transactions[transactionId].executed)\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    modifier notNull(address _address) {\n', '        if (_address == 0)\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    modifier validRequirement(uint ownerCount, uint _required) {\n', '        if (   ownerCount > MAX_OWNER_COUNT\n', '            || _required > ownerCount\n', '            || _required == 0\n', '            || ownerCount == 0)\n', '            throw;\n', '        _;\n', '    }\n', '\n', '    /// @dev Fallback function allows to deposit ether.\n', '    function()\n', '        payable\n', '    {\n', '        if (msg.value > 0)\n', '            Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    /*\n', '     * Public functions\n', '     */\n', '    /// @dev Contract constructor sets initial owners and required number of confirmations.\n', '    /// @param _owners List of initial owners.\n', '    /// @param _required Number of required confirmations.\n', '    function MultiSigWallet(address[] _owners, uint _required)\n', '        public\n', '        validRequirement(_owners.length, _required)\n', '    {\n', '        for (uint i=0; i<_owners.length; i++) {\n', '            if (isOwner[_owners[i]] || _owners[i] == 0)\n', '                throw;\n', '            isOwner[_owners[i]] = true;\n', '        }\n', '        owners = _owners;\n', '        required = _required;\n', '    }\n', '\n', '    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n', '    /// @param owner Address of new owner.\n', '    function addOwner(address owner)\n', '        public\n', '        onlyWallet\n', '        ownerDoesNotExist(owner)\n', '        notNull(owner)\n', '        validRequirement(owners.length + 1, required)\n', '    {\n', '        isOwner[owner] = true;\n', '        owners.push(owner);\n', '        OwnerAddition(owner);\n', '    }\n', '\n', '    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n', '    /// @param owner Address of owner.\n', '    function removeOwner(address owner)\n', '        public\n', '        onlyWallet\n', '        ownerExists(owner)\n', '    {\n', '        isOwner[owner] = false;\n', '        for (uint i=0; i<owners.length - 1; i++)\n', '            if (owners[i] == owner) {\n', '                owners[i] = owners[owners.length - 1];\n', '                break;\n', '            }\n', '        owners.length -= 1;\n', '        if (required > owners.length)\n', '            changeRequirement(owners.length);\n', '        OwnerRemoval(owner);\n', '    }\n', '\n', '    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n', '    /// @param owner Address of owner to be replaced.\n', '    /// @param owner Address of new owner.\n', '    function replaceOwner(address owner, address newOwner)\n', '        public\n', '        onlyWallet\n', '        ownerExists(owner)\n', '        ownerDoesNotExist(newOwner)\n', '    {\n', '        for (uint i=0; i<owners.length; i++)\n', '            if (owners[i] == owner) {\n', '                owners[i] = newOwner;\n', '                break;\n', '            }\n', '        isOwner[owner] = false;\n', '        isOwner[newOwner] = true;\n', '        OwnerRemoval(owner);\n', '        OwnerAddition(newOwner);\n', '    }\n', '\n', '    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n', '    /// @param _required Number of required confirmations.\n', '    function changeRequirement(uint _required)\n', '        public\n', '        onlyWallet\n', '        validRequirement(owners.length, _required)\n', '    {\n', '        required = _required;\n', '        RequirementChange(_required);\n', '    }\n', '\n', '    /// @dev Allows an owner to submit and confirm a transaction.\n', '    /// @param destination Transaction target address.\n', '    /// @param value Transaction ether value.\n', '    /// @param data Transaction data payload.\n', '    /// @return Returns transaction ID.\n', '    function submitTransaction(address destination, uint value, bytes data)\n', '        public\n', '        returns (uint transactionId)\n', '    {\n', '        transactionId = addTransaction(destination, value, data);\n', '        confirmTransaction(transactionId);\n', '    }\n', '\n', '    /// @dev Allows an owner to confirm a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    function confirmTransaction(uint transactionId)\n', '        public\n', '        ownerExists(msg.sender)\n', '        transactionExists(transactionId)\n', '        notConfirmed(transactionId, msg.sender)\n', '    {\n', '        confirmations[transactionId][msg.sender] = true;\n', '        Confirmation(msg.sender, transactionId);\n', '        executeTransaction(transactionId);\n', '    }\n', '\n', '    /// @dev Allows an owner to revoke a confirmation for a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    function revokeConfirmation(uint transactionId)\n', '        public\n', '        ownerExists(msg.sender)\n', '        confirmed(transactionId, msg.sender)\n', '        notExecuted(transactionId)\n', '    {\n', '        confirmations[transactionId][msg.sender] = false;\n', '        Revocation(msg.sender, transactionId);\n', '    }\n', '\n', '    /// @dev Allows anyone to execute a confirmed transaction.\n', '    /// @param transactionId Transaction ID.\n', '    function executeTransaction(uint transactionId)\n', '        public\n', '        notExecuted(transactionId)\n', '    {\n', '        if (isConfirmed(transactionId)) {\n', '            Transaction tx = transactions[transactionId];\n', '            tx.executed = true;\n', '            if (tx.destination.call.value(tx.value)(tx.data))\n', '                Execution(transactionId);\n', '            else {\n', '                ExecutionFailure(transactionId);\n', '                tx.executed = false;\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev Returns the confirmation status of a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    /// @return Confirmation status.\n', '    function isConfirmed(uint transactionId)\n', '        public\n', '        constant\n', '        returns (bool)\n', '    {\n', '        uint count = 0;\n', '        for (uint i=0; i<owners.length; i++) {\n', '            if (confirmations[transactionId][owners[i]])\n', '                count += 1;\n', '            if (count == required)\n', '                return true;\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Internal functions\n', '     */\n', '    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n', '    /// @param destination Transaction target address.\n', '    /// @param value Transaction ether value.\n', '    /// @param data Transaction data payload.\n', '    /// @return Returns transaction ID.\n', '    function addTransaction(address destination, uint value, bytes data)\n', '        internal\n', '        notNull(destination)\n', '        returns (uint transactionId)\n', '    {\n', '        transactionId = transactionCount;\n', '        transactions[transactionId] = Transaction({\n', '            destination: destination,\n', '            value: value,\n', '            data: data,\n', '            executed: false\n', '        });\n', '        transactionCount += 1;\n', '        Submission(transactionId);\n', '    }\n', '\n', '    /*\n', '     * Web3 call functions\n', '     */\n', '    /// @dev Returns number of confirmations of a transaction.\n', '    /// @param transactionId Transaction ID.\n', '    /// @return Number of confirmations.\n', '    function getConfirmationCount(uint transactionId)\n', '        public\n', '        constant\n', '        returns (uint count)\n', '    {\n', '        for (uint i=0; i<owners.length; i++)\n', '            if (confirmations[transactionId][owners[i]])\n', '                count += 1;\n', '    }\n', '\n', '    /// @dev Returns total number of transactions after filers are applied.\n', '    /// @param pending Include pending transactions.\n', '    /// @param executed Include executed transactions.\n', '    /// @return Total number of transactions after filters are applied.\n', '    function getTransactionCount(bool pending, bool executed)\n', '        public\n', '        constant\n', '        returns (uint count)\n', '    {\n', '        for (uint i=0; i<transactionCount; i++)\n', '            if (   pending && !transactions[i].executed\n', '                || executed && transactions[i].executed)\n', '                count += 1;\n', '    }\n', '\n', '    /// @dev Returns list of owners.\n', '    /// @return List of owner addresses.\n', '    function getOwners()\n', '        public\n', '        constant\n', '        returns (address[])\n', '    {\n', '        return owners;\n', '    }\n', '\n', '    /// @dev Returns array with owner addresses, which confirmed transaction.\n', '    /// @param transactionId Transaction ID.\n', '    /// @return Returns array of owner addresses.\n', '    function getConfirmations(uint transactionId)\n', '        public\n', '        constant\n', '        returns (address[] _confirmations)\n', '    {\n', '        address[] memory confirmationsTemp = new address[](owners.length);\n', '        uint count = 0;\n', '        uint i;\n', '        for (i=0; i<owners.length; i++)\n', '            if (confirmations[transactionId][owners[i]]) {\n', '                confirmationsTemp[count] = owners[i];\n', '                count += 1;\n', '            }\n', '        _confirmations = new address[](count);\n', '        for (i=0; i<count; i++)\n', '            _confirmations[i] = confirmationsTemp[i];\n', '    }\n', '\n', '    /// @dev Returns list of transaction IDs in defined range.\n', '    /// @param from Index start position of transaction array.\n', '    /// @param to Index end position of transaction array.\n', '    /// @param pending Include pending transactions.\n', '    /// @param executed Include executed transactions.\n', '    /// @return Returns array of transaction IDs.\n', '    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n', '        public\n', '        constant\n', '        returns (uint[] _transactionIds)\n', '    {\n', '        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n', '        uint count = 0;\n', '        uint i;\n', '        for (i=0; i<transactionCount; i++)\n', '            if (   pending && !transactions[i].executed\n', '                || executed && transactions[i].executed)\n', '            {\n', '                transactionIdsTemp[count] = i;\n', '                count += 1;\n', '            }\n', '        _transactionIds = new uint[](to - from);\n', '        for (i=from; i<to; i++)\n', '            _transactionIds[i - from] = transactionIdsTemp[i];\n', '    }\n', '}\n', '\n', '\n', '////////////////// >>>>> Library Contracts <<<<< ///////////////////\n', '\n', '\n', 'contract SafeMathLib {\n', '  function safeMul(uint a, uint b) constant returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) constant returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) constant returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control \n', ' * functions, this simplifies the implementation of "user permissions". \n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  address public newOwner;\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '  /** \n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner. \n', '   */\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to. \n', '   */\n', '  function transferOwnership(address _newOwner) onlyOwner {\n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  function acceptOwnership() {\n', '    require(msg.sender == newOwner);\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '////////////////// >>>>> Token Contracts <<<<< ///////////////////\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  function balanceOf(address _owner) constant returns (uint balance);\n', '  function transfer(address _to, uint _value) returns (bool success);\n', '  event Transfer(address indexed _from, address indexed _to, uint _value);\n', '}\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '  function approve(address _spender, uint _value) returns (bool success);\n', '  event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', ' *\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is ERC20, SafeMathLib {\n', '  /* Token supply got increased and a new owner received these tokens */\n', '  event Minted(address receiver, uint amount);\n', '\n', '  /* Actual balances of token holders */\n', '  mapping(address => uint) balances;\n', '\n', '  /* approve() allowances */\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transfer(address _to, uint _value) returns (bool success) {\n', '    if (balances[msg.sender] >= _value \n', '        && _value > 0 \n', '        && balances[_to] + _value > balances[_to]\n', '        ) {\n', '      balances[msg.sender] = safeSub(balances[msg.sender],_value);\n', '      balances[_to] = safeAdd(balances[_to],_value);\n', '      Transfer(msg.sender, _to, _value);\n', '      return true;\n', '    }\n', '    else{\n', '      return false;\n', '    }\n', '    \n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n', '    uint _allowance = allowed[_from][msg.sender];\n', '\n', '    if (balances[_from] >= _value   // From a/c has balance\n', '        && _allowance >= _value    // Transfer approved\n', '        && _value > 0              // Non-zero transfer\n', '        && balances[_to] + _value > balances[_to]  // Overflow check\n', '        ){\n', '    balances[_to] = safeAdd(balances[_to],_value);\n', '    balances[_from] = safeSub(balances[_from],_value);\n', '    allowed[_from][msg.sender] = safeSub(_allowance,_value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '        }\n', '    else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '  function approve(address _spender, uint _value) returns (bool success) {\n', '\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '\n', '    \n', '\n', '/**\n', ' * A token that can increase its supply by another contract.\n', ' *\n', ' * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\n', ' * Only mint agents, contracts whitelisted by owner, can mint new tokens.\n', ' *\n', ' */\n', 'contract MintableToken is StandardToken, Ownable {\n', '\n', '  bool public mintingFinished = false;\n', '\n', '  /** List of agents that are allowed to create new tokens */\n', '  mapping (address => bool) public mintAgents;\n', '\n', '  event MintingAgentChanged(address addr, bool state  );\n', '\n', '  /**\n', '   * Create new tokens and allocate them to an address..\n', '   *\n', '   * Only callably by a crowdsale contract (mint agent).\n', '   */\n', '  function mint(address receiver, uint amount) onlyMintAgent canMint public {\n', '    totalSupply = safeAdd(totalSupply, amount);\n', '    balances[receiver] = safeAdd(balances[receiver], amount);\n', '    // This will make the mint transaction apper in EtherScan.io\n', '    // We can remove this after there is a standardized minting event\n', '    Transfer(0, receiver, amount);\n', '  }\n', '\n', '  /**\n', '   * Owner can allow a crowdsale contract to mint new tokens.\n', '   */\n', '  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n', '    mintAgents[addr] = state;\n', '    MintingAgentChanged(addr, state);\n', '  }\n', '\n', '  modifier onlyMintAgent() {\n', '    // Only crowdsale contracts are allowed to mint new tokens\n', '    require(mintAgents[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  /** Make sure we are not done yet. */\n', '  modifier canMint() {\n', '    require(!mintingFinished);\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Define interface for releasing the token transfer after a successful crowdsale.\n', ' */\n', 'contract ReleasableToken is ERC20, Ownable {\n', '\n', '  /* The finalizer contract that allows unlift the transfer limits on this token */\n', '  address public releaseAgent;\n', '\n', '  /** A crowdsale contract can release us to the wild if ICO success. \n', '   * If false we are are in transfer lock up period.\n', '   */\n', '  bool public released = false;\n', '\n', '  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. \n', '   * These are crowdsale contracts and possible the team multisig itself. \n', '   */\n', '  mapping (address => bool) public transferAgents;\n', '\n', '  /**\n', '   * Limit token transfer until the crowdsale is over.\n', '   */\n', '  modifier canTransfer(address _sender) {\n', '\n', '    if (!released) {\n', '        require(transferAgents[_sender]);\n', '    }\n', '\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * Set the contract that can call release and make the token transferable.\n', '   *\n', '   * Design choice. Allow reset the release agent to fix fat finger mistakes.\n', '   */\n', '  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n', '\n', '    // We don&#39;t do interface check here as we might want to a normal wallet address to act as a release agent\n', '    releaseAgent = addr;\n', '  }\n', '\n', '  /**\n', '   * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\n', '   */\n', '  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n', '    transferAgents[addr] = state;\n', '  }\n', '\n', '  /**\n', '   * One way function to release the tokens to the wild.\n', '   *\n', '   * Can be called only from the release agent that is the final ICO contract. \n', '   * It is only called if the crowdsale has been success (first milestone reached).\n', '   */\n', '  function releaseTokenTransfer() public onlyReleaseAgent {\n', '    released = true;\n', '  }\n', '\n', '  /** The function can be called only before or after the tokens have been releasesd */\n', '  modifier inReleaseState(bool releaseState) {\n', '    require(releaseState == released);\n', '    _;\n', '  }\n', '\n', '  /** The function can be called only by a whitelisted release agent. */\n', '  modifier onlyReleaseAgent() {\n', '    require(msg.sender == releaseAgent);\n', '    _;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n', '    // Call StandardToken.transfer()\n', '   return super.transfer(_to, _value);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n', '    // Call StandardToken.transferForm()\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '}\n', '\n', '\n', ' \n', '\n', '/**\n', ' * Upgrade agent interface inspired by Lunyr.\n', ' *\n', ' * Upgrade agent transfers tokens to a new contract.\n', ' * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\n', ' */\n', 'contract UpgradeAgent {\n', '  uint public originalSupply;\n', '  /** Interface marker */\n', '  function isUpgradeAgent() public constant returns (bool) {\n', '    return true;\n', '  }\n', '  function upgradeFrom(address _from, uint256 _value) public;\n', '}\n', '\n', '/**\n', ' * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\n', ' *\n', ' * First envisioned by Golem and Lunyr projects.\n', ' */\n', 'contract UpgradeableToken is StandardToken {\n', '\n', '  /** Contract / person who can set the upgrade path. \n', '   * This can be the same as team multisig wallet, as what it is with its default value. \n', '   */\n', '  address public upgradeMaster;\n', '\n', '  /** The next contract where the tokens will be migrated. */\n', '  UpgradeAgent public upgradeAgent;\n', '\n', '  /** How many tokens we have upgraded by now. */\n', '  uint256 public totalUpgraded;\n', '\n', '  /**\n', '   * Upgrade states.\n', '   *\n', '   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\n', '   * - WaitingForAgent: Token allows upgrade, but we don&#39;t have a new agent yet\n', '   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\n', '   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\n', '   *\n', '   */\n', '  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n', '\n', '  /**\n', '   * Somebody has upgraded some of their tokens.\n', '   */\n', '  event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '  /**\n', '   * New upgrade agent available.\n', '   */\n', '  event UpgradeAgentSet(address agent);\n', '\n', '  /**\n', '   * Do not allow construction without upgrade master set.\n', '   */\n', '  function UpgradeableToken(address _upgradeMaster) {\n', '    upgradeMaster = _upgradeMaster;\n', '  }\n', '\n', '  /**\n', '   * Allow the token holder to upgrade some of their tokens to a new contract.\n', '   */\n', '  function upgrade(uint256 value) public {\n', '    UpgradeState state = getUpgradeState();\n', '    require((state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading));\n', '    // Validate input value.\n', '    require(value!=0);\n', '\n', '    balances[msg.sender] = safeSub(balances[msg.sender],value);\n', '\n', '    // Take tokens out from circulation\n', '    totalSupply = safeSub(totalSupply,value);\n', '    totalUpgraded = safeAdd(totalUpgraded,value);\n', '\n', '    // Upgrade agent reissues the tokens\n', '    upgradeAgent.upgradeFrom(msg.sender, value);\n', '    Upgrade(msg.sender, upgradeAgent, value);\n', '  }\n', '\n', '  /**\n', '   * Set an upgrade agent that handles\n', '   */\n', '  function setUpgradeAgent(address agent) external {\n', '    require(canUpgrade());\n', '    require(agent != 0x0);\n', '    // Only a master can designate the next agent\n', '    require(msg.sender == upgradeMaster);\n', '    // Upgrade has already begun for an agent\n', '    require(getUpgradeState() != UpgradeState.Upgrading);\n', '\n', '    upgradeAgent = UpgradeAgent(agent);\n', '\n', '    // Bad interface\n', '    require(upgradeAgent.isUpgradeAgent());\n', '    // Make sure that token supplies match in source and target\n', '    require(upgradeAgent.originalSupply() == totalSupply);\n', '\n', '    UpgradeAgentSet(upgradeAgent);\n', '  }\n', '\n', '  /**\n', '   * Get the state of the token upgrade.\n', '   */\n', '  function getUpgradeState() public constant returns(UpgradeState) {\n', '    if (!canUpgrade()) return UpgradeState.NotAllowed;\n', '    else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n', '    else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n', '    else return UpgradeState.Upgrading;\n', '  }\n', '\n', '  /**\n', '   * Change the upgrade master.\n', '   *\n', '   * This allows us to set a new owner for the upgrade mechanism.\n', '   */\n', '  function setUpgradeMaster(address master) public {\n', '    require(master != 0x0);\n', '    require(msg.sender == upgradeMaster);\n', '    upgradeMaster = master;\n', '  }\n', '\n', '  /**\n', '   * Child contract can enable to provide the condition when the upgrade can begun.\n', '   */\n', '  function canUpgrade() public constant returns(bool) {\n', '     return true;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * A crowdsale token.\n', ' *\n', ' * An ERC-20 token designed specifically for crowdsales with investor protection and \n', ' * further development path.\n', ' *\n', ' * - The token transfer() is disabled until the crowdsale is over\n', ' * - The token contract gives an opt-in upgrade path to a new contract\n', ' * - The same token can be part of several crowdsales through approve() mechanism\n', ' * - The token can be capped (supply set in the constructor) \n', ' *   or uncapped (crowdsale contract can mint new tokens)\n', ' */\n', 'contract DayToken is  ReleasableToken, MintableToken, UpgradeableToken {\n', '\n', '    enum sellingStatus {NOTONSALE, EXPIRED, ONSALE}\n', '\n', '    /** Basic structure for a contributor with a minting Address\n', '     * adr address of the contributor\n', '     * initialContributionDay initial contribution of the contributor in wei\n', '     * lastUpdatedOn day count from Minting Epoch when the account balance was last updated\n', '     * mintingPower Initial Minting power of the address\n', '     * expiryBlockNumber Variable to mark end of Minting address sale. Set by user\n', '     * minPriceInDay minimum price of Minting address in Day tokens. Set by user\n', '     * status Selling status Variable for transfer Minting address.\n', '     * sellingPriceInDay Variable for transfer Minting address. Price at which the address is actually sold\n', '     */ \n', '    struct Contributor {\n', '        address adr;\n', '        uint256 initialContributionDay;\n', '        uint256 lastUpdatedOn; //Day from Minting Epoch\n', '        uint256 mintingPower;\n', '        uint expiryBlockNumber;\n', '        uint256 minPriceInDay;\n', '        sellingStatus status;\n', '    }\n', '\n', '    /* Stores maximum days for which minting will happen since minting epoch */\n', '    uint256 public maxMintingDays = 1095;\n', '\n', '    /* Mapping to store id of each minting address */\n', '    mapping (address => uint) public idOf;\n', '    /* Mapping from id of each minting address to their respective structures */\n', '    mapping (uint256 => Contributor) public contributors;\n', '    /* mapping to store unix timestamp of when the minting address is issued to each team member */\n', '    mapping (address => uint256) public teamIssuedTimestamp;\n', '    mapping (address => bool) public soldAddresses;\n', '    mapping (address => uint256) public sellingPriceInDayOf;\n', '\n', '    /* Stores the id of the first  contributor */\n', '    uint256 public firstContributorId;\n', '    /* Stores total Pre + Post ICO TimeMints */\n', '    uint256 public totalNormalContributorIds;\n', '    /* Stores total Normal TimeMints allocated */\n', '    uint256 public totalNormalContributorIdsAllocated = 0;\n', '    \n', '    /* Stores the id of the first team TimeMint */\n', '    uint256 public firstTeamContributorId;\n', '    /* Stores the total team TimeMints */\n', '    uint256 public totalTeamContributorIds;\n', '    /* Stores total team TimeMints allocated */\n', '    uint256 public totalTeamContributorIdsAllocated = 0;\n', '\n', '    /* Stores the id of the first Post ICO contributor (for auctionable TimeMints) */\n', '    uint256 public firstPostIcoContributorId;\n', '    /* Stores total Post ICO TimeMints (for auction) */\n', '    uint256 public totalPostIcoContributorIds;\n', '    /* Stores total Auction TimeMints allocated */\n', '    uint256 public totalPostIcoContributorIdsAllocated = 0;\n', '\n', '    /* Maximum number of address */\n', '    uint256 public maxAddresses;\n', '\n', '    /* Min Minting power with 19 decimals: 0.5% : 5000000000000000000 */\n', '    uint256 public minMintingPower;\n', '    /* Max Minting power with 19 decimals: 1% : 10000000000000000000 */\n', '    uint256 public maxMintingPower;\n', '    /* Halving cycle in days (88) */\n', '    uint256 public halvingCycle; \n', '    /* Unix timestamp when minting is to be started */\n', '    uint256 public initialBlockTimestamp;\n', '    /* Flag to prevent setting initialBlockTimestamp more than once */\n', '    bool public isInitialBlockTimestampSet;\n', '    /* number of decimals in minting power */\n', '    uint256 public mintingDec; \n', '\n', '    /* Minimum Balance in Day tokens required to sell a minting address */\n', '    uint256 public minBalanceToSell;\n', '    /* Team address lock down period from issued time, in seconds */\n', '    uint256 public teamLockPeriodInSec;  //Initialize and set function\n', '    /* Duration in secs that we consider as a day. (For test deployment purposes, \n', '       if we want to decrease length of a day. default: 84600)*/\n', '    uint256 public DayInSecs;\n', '\n', '    event UpdatedTokenInformation(string newName, string newSymbol); \n', '    event MintingAdrTransferred(uint id, address from, address to);\n', '    event ContributorAdded(address adr, uint id);\n', '    event TimeMintOnSale(uint id, address seller, uint minPriceInDay, uint expiryBlockNumber);\n', '    event TimeMintSold(uint id, address buyer, uint offerInDay);\n', '    event PostInvested(address investor, uint weiAmount, uint tokenAmount, uint customerId, uint contributorId);\n', '    \n', '    event TeamAddressAdded(address teamAddress, uint id);\n', '    // Tell us invest was success\n', '    event Invested(address receiver, uint weiAmount, uint tokenAmount, uint customerId, uint contributorId);\n', '\n', '    modifier onlyContributor(uint id){\n', '        require(isValidContributorId(id));\n', '        _;\n', '    }\n', '\n', '    string public name; \n', '\n', '    string public symbol; \n', '\n', '    uint8 public decimals; \n', '\n', '    /**\n', '        * Construct the token.\n', '        *\n', '        * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n', '        *\n', '        * @param _name Token name\n', '        * @param _symbol Token symbol - should be all caps\n', '        * @param _initialSupply How many tokens we start with\n', '        * @param _decimals Number of decimal places\n', '        * _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply?\n', '        */\n', '    function DayToken(string _name, string _symbol, uint _initialSupply, uint8 _decimals, \n', '        bool _mintable, uint _maxAddresses, uint _firstTeamContributorId, uint _totalTeamContributorIds, \n', '        uint _totalPostIcoContributorIds, uint256 _minMintingPower, uint256 _maxMintingPower, uint _halvingCycle, \n', '        uint256 _minBalanceToSell, uint256 _dayInSecs, uint256 _teamLockPeriodInSec) \n', '        UpgradeableToken(msg.sender) {\n', '        \n', '        // Create any address, can be transferred\n', '        // to team multisig via changeOwner(),\n', '        // also remember to call setUpgradeMaster()\n', '        owner = msg.sender; \n', '        name = _name; \n', '        symbol = _symbol;  \n', '        totalSupply = _initialSupply; \n', '        decimals = _decimals; \n', '        // Create initially all balance on the team multisig\n', '        balances[owner] = totalSupply; \n', '        maxAddresses = _maxAddresses;\n', '        require(maxAddresses > 1); // else division by zero will occur in setInitialMintingPowerOf\n', '        \n', '        firstContributorId = 1;\n', '        totalNormalContributorIds = maxAddresses - _totalTeamContributorIds - _totalPostIcoContributorIds;\n', '\n', '        // check timeMint total is sane\n', '        require(totalNormalContributorIds >= 1);\n', '\n', '        firstTeamContributorId = _firstTeamContributorId;\n', '        totalTeamContributorIds = _totalTeamContributorIds;\n', '        totalPostIcoContributorIds = _totalPostIcoContributorIds;\n', '        \n', '        // calculate first contributor id to be auctioned post ICO\n', '        firstPostIcoContributorId = maxAddresses - totalPostIcoContributorIds + 1;\n', '        minMintingPower = _minMintingPower;\n', '        maxMintingPower = _maxMintingPower;\n', '        halvingCycle = _halvingCycle;\n', '        // setting future date far far away, year 2020, \n', '        // call setInitialBlockTimestamp to set proper timestamp\n', '        initialBlockTimestamp = 1577836800;\n', '        isInitialBlockTimestampSet = false;\n', '        // use setMintingDec to change this\n', '        mintingDec = 19;\n', '        minBalanceToSell = _minBalanceToSell;\n', '        DayInSecs = _dayInSecs;\n', '        teamLockPeriodInSec = _teamLockPeriodInSec;\n', '        \n', '        if (totalSupply > 0) {\n', '            Minted(owner, totalSupply); \n', '        }\n', '\n', '        if (!_mintable) {\n', '            mintingFinished = true; \n', '            require(totalSupply != 0); \n', '        }\n', '    }\n', '\n', '    /**\n', '    * Used to set timestamp at which minting power of TimeMints is activated\n', '    * Can be called only by owner\n', '    * @param _initialBlockTimestamp timestamp to be set.\n', '    */\n', '    function setInitialBlockTimestamp(uint _initialBlockTimestamp) internal onlyOwner {\n', '        require(!isInitialBlockTimestampSet);\n', '        isInitialBlockTimestampSet = true;\n', '        initialBlockTimestamp = _initialBlockTimestamp;\n', '    }\n', '\n', '    /**\n', '    * check if mintining power is activated and Day token and Timemint transfer is enabled\n', '    */\n', '    function isDayTokenActivated() constant returns (bool isActivated) {\n', '        return (block.timestamp >= initialBlockTimestamp);\n', '    }\n', '\n', '\n', '    /**\n', '    * to check if an id is a valid contributor\n', '    * @param _id contributor id to check.\n', '    */\n', '    function isValidContributorId(uint _id) constant returns (bool isValidContributor) {\n', '        return (_id > 0 && _id <= maxAddresses && contributors[_id].adr != 0 \n', '            && idOf[contributors[_id].adr] == _id); // cross checking\n', '    }\n', '\n', '    /**\n', '    * to check if an address is a valid contributor\n', '    * @param _address  contributor address to check.\n', '    */\n', '    function isValidContributorAddress(address _address) constant returns (bool isValidContributor) {\n', '        return isValidContributorId(idOf[_address]);\n', '    }\n', '\n', '\n', '    /**\n', '    * In case of Team address check if lock-in period is over (returns true for all non team addresses)\n', '    * @param _address team address to check lock in period for.\n', '    */\n', '    function isTeamLockInPeriodOverIfTeamAddress(address _address) constant returns (bool isLockInPeriodOver) {\n', '        isLockInPeriodOver = true;\n', '        if (teamIssuedTimestamp[_address] != 0) {\n', '                if (block.timestamp - teamIssuedTimestamp[_address] < teamLockPeriodInSec)\n', '                    isLockInPeriodOver = false;\n', '        }\n', '\n', '        return isLockInPeriodOver;\n', '    }\n', '\n', '    /**\n', '    * Used to set mintingDec\n', '    * Can be called only by owner\n', '    * @param _mintingDec bounty to be set.\n', '    */\n', '    function setMintingDec(uint256 _mintingDec) onlyOwner {\n', '        require(!isInitialBlockTimestampSet);\n', '        mintingDec = _mintingDec;\n', '    }\n', '\n', '    /**\n', '        * When token is released to be transferable, enforce no new tokens can be created.\n', '        */\n', '    function releaseTokenTransfer() public onlyOwner {\n', '        require(isInitialBlockTimestampSet);\n', '        mintingFinished = true; \n', '        super.releaseTokenTransfer(); \n', '    }\n', '\n', '    /**\n', '        * Allow upgrade agent functionality kick in only if the crowdsale was success.\n', '        */\n', '    function canUpgrade() public constant returns(bool) {\n', '        return released && super.canUpgrade(); \n', '    }\n', '\n', '    /**\n', '        * Owner can update token information here\n', '        */\n', '    function setTokenInformation(string _name, string _symbol) onlyOwner {\n', '        name = _name; \n', '        symbol = _symbol; \n', '        UpdatedTokenInformation(name, symbol); \n', '    }\n', '\n', '    /**\n', '        * Returns the current phase.  \n', '        * Note: Phase starts with 1\n', '        * @param _day Number of days since Minting Epoch\n', '        */\n', '    function getPhaseCount(uint _day) public constant returns (uint phase) {\n', '        phase = (_day/halvingCycle) + 1; \n', '        return (phase); \n', '    }\n', '    /**\n', '        * Returns current day number since minting epoch \n', '        * or zero if initialBlockTimestamp is in future or its DayZero.\n', '        */\n', '    function getDayCount() public constant returns (uint daySinceMintingEpoch) {\n', '        daySinceMintingEpoch = 0;\n', '        if (isDayTokenActivated())\n', '            daySinceMintingEpoch = (block.timestamp - initialBlockTimestamp)/DayInSecs; \n', '\n', '        return daySinceMintingEpoch; \n', '    }\n', '    /**\n', '        * Calculates and Sets the minting power of a particular id.\n', '        * Called before Minting Epoch by constructor\n', '        * @param _id id of the address whose minting power is to be set.\n', '        */\n', '    function setInitialMintingPowerOf(uint256 _id) internal onlyContributor(_id) {\n', '        contributors[_id].mintingPower = \n', '            (maxMintingPower - ((_id-1) * (maxMintingPower - minMintingPower)/(maxAddresses-1))); \n', '    }\n', '\n', '    /**\n', '        * Returns minting power of a particular id.\n', '        * @param _id Contribution id whose minting power is to be returned\n', '        */\n', '    function getMintingPowerById(uint _id) public constant returns (uint256 mintingPower) {\n', '        return contributors[_id].mintingPower/(2**(getPhaseCount(getDayCount())-1)); \n', '    }\n', '\n', '    /**\n', '        * Returns minting power of a particular address.\n', '        * @param _adr Address whose minting power is to be returned\n', '        */\n', '    function getMintingPowerByAddress(address _adr) public constant returns (uint256 mintingPower) {\n', '        return getMintingPowerById(idOf[_adr]);\n', '    }\n', '\n', '\n', '    /**\n', '        * Calculates and returns the balance based on the minting power, day and phase.\n', '        * Can only be called internally\n', '        * Can calculate balance based on last updated.\n', '        * @param _id id whose balnce is to be calculated\n', '        * @param _dayCount day count upto which balance is to be updated\n', '        */\n', '    function availableBalanceOf(uint256 _id, uint _dayCount) internal returns (uint256) {\n', '        uint256 balance = balances[contributors[_id].adr]; \n', '        uint maxUpdateDays = _dayCount < maxMintingDays ? _dayCount : maxMintingDays;\n', '        uint i = contributors[_id].lastUpdatedOn + 1;\n', '        while(i <= maxUpdateDays) {\n', '             uint phase = getPhaseCount(i);\n', '             uint phaseEndDay = phase * halvingCycle - 1; // as first day is 0\n', '             uint constantFactor = contributors[_id].mintingPower / 2**(phase-1);\n', '\n', '            for (uint j = i; j <= phaseEndDay && j <= maxUpdateDays; j++) {\n', '                balance = safeAdd( balance, constantFactor * balance / 10**(mintingDec + 2) );\n', '            }\n', '\n', '            i = j;\n', '            \n', '        } \n', '        return balance; \n', '    }\n', '\n', '    /**\n', '        * Updates the balance of the specified id in its structure and also in the balances[] mapping.\n', '        * returns true if successful.\n', '        * Only for internal calls. Not public.\n', '        * @param _id id whose balance is to be updated.\n', '        */\n', '    function updateBalanceOf(uint256 _id) internal returns (bool success) {\n', '        // check if its contributor\n', '        if (isValidContributorId(_id)) {\n', '            uint dayCount = getDayCount();\n', '            // proceed only if not already updated today\n', '            if (contributors[_id].lastUpdatedOn != dayCount && contributors[_id].lastUpdatedOn < maxMintingDays) {\n', '                address adr = contributors[_id].adr;\n', '                uint oldBalance = balances[adr];\n', '                totalSupply = safeSub(totalSupply, oldBalance);\n', '                uint newBalance = availableBalanceOf(_id, dayCount);\n', '                balances[adr] = newBalance;\n', '                totalSupply = safeAdd(totalSupply, newBalance);\n', '                contributors[_id].lastUpdatedOn = dayCount;\n', '                Transfer(0, adr, newBalance - oldBalance);\n', '                return true; \n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '\n', '    /**\n', '        * Standard ERC20 function overridden.\n', '        * Returns the balance of the specified address.\n', '        * Calculates the balance on fly only if it is a minting address else \n', '        * simply returns balance from balances[] mapping.\n', '        * For public calls.\n', '        * @param _adr address whose balance is to be returned.\n', '        */\n', '    function balanceOf(address _adr) constant returns (uint balance) {\n', '        uint id = idOf[_adr];\n', '        if (id != 0)\n', '            return balanceById(id);\n', '        else \n', '            return balances[_adr]; \n', '    }\n', '\n', '\n', '    /**\n', '        * Standard ERC20 function overridden.\n', '        * Returns the balance of the specified id.\n', '        * Calculates the balance on fly only if it is a minting address else \n', '        * simply returns balance from balances[] mapping.\n', '        * For public calls.\n', '        * @param _id address whose balance is to be returned.\n', '        */\n', '    function balanceById(uint _id) public constant returns (uint256 balance) {\n', '        address adr = contributors[_id].adr; \n', '        if (isDayTokenActivated()) {\n', '            if (isValidContributorId(_id)) {\n', '                return ( availableBalanceOf(_id, getDayCount()) );\n', '            }\n', '        }\n', '        return balances[adr]; \n', '    }\n', '\n', '    /**\n', '        * Returns totalSupply of DAY tokens.\n', '        */\n', '    function getTotalSupply() public constant returns (uint) {\n', '        return totalSupply;\n', '    }\n', '\n', '    /** Function to update balance of a Timemint\n', '        * returns true if balance updated, false otherwise\n', '        * @param _id TimeMint to update\n', '        */\n', '    function updateTimeMintBalance(uint _id) public returns (bool) {\n', '        require(isDayTokenActivated());\n', '        return updateBalanceOf(_id);\n', '    }\n', '\n', '    /** Function to update balance of sender&#39;s Timemint\n', '        * returns true if balance updated, false otherwise\n', '        */\n', '    function updateMyTimeMintBalance() public returns (bool) {\n', '        require(isDayTokenActivated());\n', '        return updateBalanceOf(idOf[msg.sender]);\n', '    }\n', '\n', '    /**\n', '        * Standard ERC20 function overidden.\n', '        * Used to transfer day tokens from caller&#39;s address to another\n', '        * @param _to address to which Day tokens are to be transferred\n', '        * @param _value Number of Day tokens to be transferred\n', '        */\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(isDayTokenActivated());\n', '        // if Team address, check if lock-in period is over\n', '        require(isTeamLockInPeriodOverIfTeamAddress(msg.sender));\n', '\n', '        updateBalanceOf(idOf[msg.sender]);\n', '\n', '        // Check sender account has enough balance and transfer amount is non zero\n', '        require ( balanceOf(msg.sender) >= _value && _value != 0 ); \n', '        \n', '        updateBalanceOf(idOf[_to]);\n', '\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value); \n', '        balances[_to] = safeAdd(balances[_to], _value); \n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '    \n', '\n', '    /**\n', '        * Standard ERC20 Standard Token function overridden. Added Team address vesting period lock. \n', '        */\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(isDayTokenActivated());\n', '\n', '        // if Team address, check if lock-in period is over\n', '        require(isTeamLockInPeriodOverIfTeamAddress(_from));\n', '\n', '        uint _allowance = allowed[_from][msg.sender];\n', '\n', '        updateBalanceOf(idOf[_from]);\n', '\n', '        // Check from account has enough balance, transfer amount is non zero \n', '        // and _value is allowed to be transferred\n', '        require ( balanceOf(_from) >= _value && _value != 0  &&  _value <= _allowance); \n', '\n', '        updateBalanceOf(idOf[_to]);\n', '\n', '        allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '        balances[_from] = safeSub(balances[_from], _value);\n', '        balances[_to] = safeAdd(balances[_to], _value);\n', '    \n', '        Transfer(_from, _to, _value);\n', '        \n', '        return true;\n', '    }\n', '\n', '\n', '    /** \n', '        * Add any contributor structure (For every kind of contributors: Team/Pre-ICO/ICO/Test)\n', '        * @param _adr Address of the contributor to be added  \n', '        * @param _initialContributionDay Initial Contribution of the contributor to be added\n', '        */\n', '  function addContributor(uint contributorId, address _adr, uint _initialContributionDay) internal onlyOwner {\n', '        require(contributorId <= maxAddresses);\n', '        //address should not be an existing contributor\n', '        require(!isValidContributorAddress(_adr));\n', '        //TimeMint should not be already allocated\n', '        require(!isValidContributorId(contributorId));\n', '        contributors[contributorId].adr = _adr;\n', '        idOf[_adr] = contributorId;\n', '        setInitialMintingPowerOf(contributorId);\n', '        contributors[contributorId].initialContributionDay = _initialContributionDay;\n', '        contributors[contributorId].lastUpdatedOn = getDayCount();\n', '        ContributorAdded(_adr, contributorId);\n', '        contributors[contributorId].status = sellingStatus.NOTONSALE;\n', '    }\n', '\n', '\n', '    /** Function to be called by minting addresses in order to sell their address\n', '        * @param _minPriceInDay Minimum price in DAY tokens set by the seller\n', '        * @param _expiryBlockNumber Expiry Block Number set by the seller\n', '        */\n', '    function sellMintingAddress(uint256 _minPriceInDay, uint _expiryBlockNumber) public returns (bool) {\n', '        require(isDayTokenActivated());\n', '        require(_expiryBlockNumber > block.number);\n', '\n', '        // if Team address, check if lock-in period is over\n', '        require(isTeamLockInPeriodOverIfTeamAddress(msg.sender));\n', '\n', '        uint id = idOf[msg.sender];\n', '        require(contributors[id].status == sellingStatus.NOTONSALE);\n', '\n', '        // update balance of sender address before checking for minimum required balance\n', '        updateBalanceOf(id);\n', '        require(balances[msg.sender] >= minBalanceToSell);\n', '        contributors[id].minPriceInDay = _minPriceInDay;\n', '        contributors[id].expiryBlockNumber = _expiryBlockNumber;\n', '        contributors[id].status = sellingStatus.ONSALE;\n', '        balances[msg.sender] = safeSub(balances[msg.sender], minBalanceToSell);\n', '        balances[this] = safeAdd(balances[this], minBalanceToSell);\n', '        Transfer(msg.sender, this, minBalanceToSell);\n', '        TimeMintOnSale(id, msg.sender, contributors[id].minPriceInDay, contributors[id].expiryBlockNumber);\n', '        return true;\n', '    }\n', '\n', '\n', '    /** Function to be called by minting address in order to cancel the sale of their TimeMint\n', '        */\n', '    function cancelSaleOfMintingAddress() onlyContributor(idOf[msg.sender]) public {\n', '        uint id = idOf[msg.sender];\n', '        // TimeMint should be on sale\n', '        require(contributors[id].status == sellingStatus.ONSALE);\n', '        contributors[id].status = sellingStatus.EXPIRED;\n', '    }\n', '\n', '\n', '    /** Function to be called by any user to get a list of all On Sale TimeMints\n', '        */\n', '    function getOnSaleIds() constant public returns(uint[]) {\n', '        uint[] memory idsOnSale = new uint[](maxAddresses);\n', '        uint j = 0;\n', '        for(uint i=1; i <= maxAddresses; i++) {\n', '\n', '            if ( isValidContributorId(i) &&\n', '                block.number <= contributors[i].expiryBlockNumber && \n', '                contributors[i].status == sellingStatus.ONSALE ) {\n', '                    idsOnSale[j] = i;\n', '                    j++;     \n', '            }\n', '            \n', '        }\n', '        return idsOnSale;\n', '    }\n', '\n', '\n', '    /** Function to be called by any user to get status of a Time Mint.\n', '        * returns status 0 - Not on sale, 1 - Expired, 2 - On sale,\n', '        * @param _id ID number of the Time Mint \n', '        */\n', '    function getSellingStatus(uint _id) constant public returns(sellingStatus status) {\n', '        require(isValidContributorId(_id));\n', '        status = contributors[_id].status;\n', '        if ( block.number > contributors[_id].expiryBlockNumber && \n', '                status == sellingStatus.ONSALE )\n', '            status = sellingStatus.EXPIRED;\n', '\n', '        return status;\n', '    }\n', '\n', '    /** Function to be called by any user to buy a onsale address by offering an amount\n', '        * @param _offerId ID number of the address to be bought by the buyer\n', '        * @param _offerInDay Offer given by the buyer in number of DAY tokens\n', '        */\n', '    function buyMintingAddress(uint _offerId, uint256 _offerInDay) public returns(bool) {\n', '        if (contributors[_offerId].status == sellingStatus.ONSALE \n', '            && block.number > contributors[_offerId].expiryBlockNumber)\n', '        {\n', '            contributors[_offerId].status = sellingStatus.EXPIRED;\n', '        }\n', '        address soldAddress = contributors[_offerId].adr;\n', '        require(contributors[_offerId].status == sellingStatus.ONSALE);\n', '        require(_offerInDay >= contributors[_offerId].minPriceInDay);\n', '\n', '        // prevent seller from cancelling sale in between\n', '        contributors[_offerId].status = sellingStatus.NOTONSALE;\n', '\n', '        // first get the offered DayToken in the token contract & \n', '        // then transfer the total sum (minBalanceToSend+_offerInDay) to the seller\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _offerInDay);\n', '        balances[this] = safeAdd(balances[this], _offerInDay);\n', '        Transfer(msg.sender, this, _offerInDay);\n', '        if(transferMintingAddress(contributors[_offerId].adr, msg.sender)) {\n', '            //mark the offer as sold & let seller pull the proceed to their own account.\n', '            sellingPriceInDayOf[soldAddress] = _offerInDay;\n', '            soldAddresses[soldAddress] = true; \n', '            TimeMintSold(_offerId, msg.sender, _offerInDay);  \n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '        * Transfer minting address from one user to another\n', '        * Gives the transfer-to address, the id of the original address\n', '        * returns true if successful and false if not.\n', '        * @param _to address of the user to which minting address is to be tranferred\n', '        */\n', '    function transferMintingAddress(address _from, address _to) internal onlyContributor(idOf[_from]) returns (bool) {\n', '        require(isDayTokenActivated());\n', '\n', '        // _to should be non minting address\n', '        require(!isValidContributorAddress(_to));\n', '        \n', '        uint id = idOf[_from];\n', '        // update balance of from address before transferring minting power\n', '        updateBalanceOf(id);\n', '\n', '        contributors[id].adr = _to;\n', '        idOf[_to] = id;\n', '        idOf[_from] = 0;\n', '        contributors[id].initialContributionDay = 0;\n', '        // needed as id is assigned to new address\n', '        contributors[id].lastUpdatedOn = getDayCount();\n', '        contributors[id].expiryBlockNumber = 0;\n', '        contributors[id].minPriceInDay = 0;\n', '        MintingAdrTransferred(id, _from, _to);\n', '        return true;\n', '    }\n', '\n', '\n', '    /** Function to allow seller to get back their deposited amount of day tokens(minBalanceToSell) and \n', '        * offer made by buyer after successful sale.\n', '        * Throws if sale is not successful\n', '        */\n', '    function fetchSuccessfulSaleProceed() public  returns(bool) {\n', '        require(soldAddresses[msg.sender] == true);\n', '        // to prevent re-entrancy attack\n', '        soldAddresses[msg.sender] = false;\n', '        uint saleProceed = safeAdd(minBalanceToSell, sellingPriceInDayOf[msg.sender]);\n', '        balances[this] = safeSub(balances[this], saleProceed);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], saleProceed);\n', '        Transfer(this, msg.sender, saleProceed);\n', '        return true;\n', '                \n', '    }\n', '\n', '    /** Function that lets a seller get their deposited day tokens (minBalanceToSell) back, if no buyer turns up.\n', '        * Allowed only after expiryBlockNumber\n', '        * Throws if any other state other than EXPIRED\n', '        */\n', '    function refundFailedAuctionAmount() onlyContributor(idOf[msg.sender]) public returns(bool){\n', '        uint id = idOf[msg.sender];\n', '        if(block.number > contributors[id].expiryBlockNumber && contributors[id].status == sellingStatus.ONSALE)\n', '        {\n', '            contributors[id].status = sellingStatus.EXPIRED;\n', '        }\n', '        require(contributors[id].status == sellingStatus.EXPIRED);\n', '        // reset selling status\n', '        contributors[id].status = sellingStatus.NOTONSALE;\n', '        balances[this] = safeSub(balances[this], minBalanceToSell);\n', '        // update balance of seller address before refunding\n', '        updateBalanceOf(id);\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], minBalanceToSell);\n', '        contributors[id].minPriceInDay = 0;\n', '        contributors[id].expiryBlockNumber = 0;\n', '        Transfer(this, msg.sender, minBalanceToSell);\n', '        return true;\n', '    }\n', '\n', '\n', '    /** Function to add a team address as a contributor and store it&#39;s time issued to calculate vesting period\n', '        * Called by owner\n', '        */\n', '    function addTeamTimeMints(address _adr, uint _id, uint _tokens, bool _isTest) public onlyOwner {\n', '        //check if Id is in range of team Ids\n', '        require(_id >= firstTeamContributorId && _id < firstTeamContributorId + totalTeamContributorIds);\n', '        require(totalTeamContributorIdsAllocated < totalTeamContributorIds);\n', '        addContributor(_id, _adr, 0);\n', '        totalTeamContributorIdsAllocated++;\n', '        // enforce lockin period if not test address\n', '        if(!_isTest) teamIssuedTimestamp[_adr] = block.timestamp;\n', '        mint(_adr, _tokens);\n', '        TeamAddressAdded(_adr, _id);\n', '    }\n', '\n', '\n', '    /** Function to add reserved aution TimeMints post-ICO. Only by owner\n', '        * @param _receiver Address of the minting to be added\n', '        * @param _customerId Server side id of the customer\n', '        * @param _id contributorId\n', '        */\n', '    function postAllocateAuctionTimeMints(address _receiver, uint _customerId, uint _id) public onlyOwner {\n', '\n', '        //check if Id is in range of Auction Ids\n', '        require(_id >= firstPostIcoContributorId && _id < firstPostIcoContributorId + totalPostIcoContributorIds);\n', '        require(totalPostIcoContributorIdsAllocated < totalPostIcoContributorIds);\n', '        \n', '        require(released == true);\n', '        addContributor(_id, _receiver, 0);\n', '        totalPostIcoContributorIdsAllocated++;\n', '        PostInvested(_receiver, 0, 0, _customerId, _id);\n', '    }\n', '\n', '\n', '    /** Function to add all contributors except team, test and Auctions TimeMints. Only by owner\n', '        * @param _receiver Address of the minting to be added\n', '        * @param _customerId Server side id of the customer\n', '        * @param _id contributor id\n', '        * @param _tokens day tokens to allocate\n', '        * @param _weiAmount ether invested in wei\n', '        */\n', '    function allocateNormalTimeMints(address _receiver, uint _customerId, uint _id, uint _tokens, uint _weiAmount) public onlyOwner {\n', '        // check if Id is in range of Normal Ids\n', '        require(_id >= firstContributorId && _id <= totalNormalContributorIds);\n', '        require(totalNormalContributorIdsAllocated < totalNormalContributorIds);\n', '        addContributor(_id, _receiver, _tokens);\n', '        totalNormalContributorIdsAllocated++;\n', '        mint(_receiver, _tokens);\n', '        Invested(_receiver, _weiAmount, _tokens, _customerId, _id);\n', '        \n', '    }\n', '\n', '\n', '    /** Function to release token\n', '        * Called by owner\n', '        */\n', '    function releaseToken(uint _initialBlockTimestamp) public onlyOwner {\n', '        require(!released); // check not already released\n', '        \n', '        setInitialBlockTimestamp(_initialBlockTimestamp);\n', '\n', '        // Make token transferable\n', '        releaseTokenTransfer();\n', '    }\n', '    \n', '}']