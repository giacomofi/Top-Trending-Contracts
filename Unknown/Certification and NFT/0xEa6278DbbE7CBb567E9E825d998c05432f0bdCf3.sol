['pragma solidity ^0.4.14;\n', '\n', ' /// @title SafeMath contract - math operations with safety checks\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '/// @title ERC20 interface see https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', ' uint public totalSupply;\n', ' function balanceOf(address who) constant returns (uint);\n', ' function allowance(address owner, address spender) constant returns (uint);\n', ' function mint(address receiver, uint amount);\n', ' function transfer(address to, uint value) returns (bool ok);\n', ' function transferFrom(address from, address to, uint value) returns (bool ok);\n', ' function approve(address spender, uint value) returns (bool ok);\n', ' event Transfer(address indexed from, address indexed to, uint value);\n', ' event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/// @title Ownable contract - base contract with an owner\n', 'contract Ownable {\n', ' address public owner;\n', '\n', ' function Ownable() {\n', '   owner = msg.sender;\n', ' }\n', '\n', ' modifier onlyOwner() {\n', '   require(msg.sender == owner);\n', '   _;\n', ' }\n', '\n', ' function transferOwnership(address newOwner) onlyOwner {\n', '   if (newOwner != address(0)) {\n', '     owner = newOwner;\n', '   }\n', ' }\n', '}\n', '\n', '/// @title Haltable contract - abstract contract that allows children to implement an emergency stop mechanism.\n', '/// Originally envisioned in FirstBlood ICO contract.\n', 'contract Haltable is Ownable {\n', '  bool public halted;\n', '\n', '  modifier stopInEmergency {\n', '    require(!halted);\n', '    _;\n', '  }\n', '\n', '  modifier onlyInEmergency {\n', '    require(halted);\n', '    _;\n', '  }\n', '\n', '  /// called by the owner on emergency, triggers stopped state\n', '  function halt() external onlyOwner {\n', '    halted = true;\n', '  }\n', '\n', '  /// called by the owner on end of emergency, returns to normal state\n', '  function unhalt() external onlyOwner onlyInEmergency {\n', '    halted = false;\n', '  }\n', '}\n', ' /// @title Killable contract - base contract that can be killed by owner. All funds in contract will be sent to the owner.\n', 'contract Killable is Ownable {\n', '  function kill() onlyOwner {\n', '    selfdestruct(owner);\n', '  }\n', '}\n', ' /// @title SilentNotaryToken contract - standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', 'contract SilentNotaryToken is SafeMath, ERC20, Killable {\n', '  string constant public name = "Silent Notary Token";\n', '  string constant public symbol = "SNTR";\n', '  uint constant public decimals = 4;\n', '  /// Buyout price\n', '  uint constant public buyOutPrice = 200 finney;\n', '  /// Holder list\n', '  address[] public holders;\n', '  /// Balance data\n', '  struct Balance {\n', '    /// Tokens amount\n', '    uint value;\n', '    /// Object exist\n', '    bool exist;\n', '  }\n', '  /// Holder balances\n', '  mapping(address => Balance) public balances;\n', '  /// Contract that is allowed to create new tokens and allows unlift the transfer limits on this token\n', '  address public crowdsaleAgent;\n', '  /// A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.\n', '  bool public released = false;\n', '  /// approve() allowances\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  /// @dev Limit token transfer until the crowdsale is over.\n', '  modifier canTransfer() {\n', '    if(!released)\n', '      require(msg.sender == crowdsaleAgent);\n', '    _;\n', '  }\n', '\n', '  /// @dev The function can be called only before or after the tokens have been releasesd\n', '  /// @param _released token transfer and mint state\n', '  modifier inReleaseState(bool _released) {\n', '    require(_released == released);\n', '    _;\n', '  }\n', '\n', '  /// @dev If holder does not exist add to array\n', '  /// @param holder Token holder\n', '  modifier addIfNotExist(address holder) {\n', '    if(!balances[holder].exist)\n', '      holders.push(holder);\n', '    _;\n', '  }\n', '\n', '  /// @dev The function can be called only by release agent.\n', '  modifier onlyCrowdsaleAgent() {\n', '    require(msg.sender == crowdsaleAgent);\n', '    _;\n', '  }\n', '\n', '  /// @dev Fix for the ERC20 short address attack http://vessenes.com/the-erc20-short-address-attack-explained/\n', '  /// @param size payload size\n', '  modifier onlyPayloadSize(uint size) {\n', '    require(msg.data.length >= size + 4);\n', '    _;\n', '  }\n', '\n', '  /// @dev Make sure we are not done yet.\n', '  modifier canMint() {\n', '    require(!released);\n', '    _;\n', '  }\n', '\n', '  /// Tokens burn event\n', '  event Burned(address indexed burner, address indexed holder, uint burnedAmount);\n', '  /// Tokens buyout event\n', '  event Pay(address indexed to, uint value);\n', '  /// Wei deposit event\n', '  event Deposit(address indexed from, uint value);\n', '\n', '  /// @dev Constructor\n', '  function SilentNotaryToken() {\n', '  }\n', '\n', '  /// Fallback method\n', '  function() payable {\n', '    require(msg.value > 0);\n', '    Deposit(msg.sender, msg.value);\n', '  }\n', '  /// @dev Create new tokens and allocate them to an address. Only callably by a crowdsale contract\n', '  /// @param receiver Address of receiver\n', '  /// @param amount  Number of tokens to issue.\n', '  function mint(address receiver, uint amount) onlyCrowdsaleAgent canMint addIfNotExist(receiver) public {\n', '      totalSupply = safeAdd(totalSupply, amount);\n', '      balances[receiver].value = safeAdd(balances[receiver].value, amount);\n', '      balances[receiver].exist = true;\n', '      Transfer(0, receiver, amount);\n', '  }\n', '\n', '  /// @dev Set the contract that can call release and make the token transferable.\n', '  /// @param _crowdsaleAgent crowdsale contract address\n', '  function setCrowdsaleAgent(address _crowdsaleAgent) onlyOwner inReleaseState(false) public {\n', '    crowdsaleAgent = _crowdsaleAgent;\n', '  }\n', '  /// @dev One way function to release the tokens to the wild. Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\n', '  function releaseTokenTransfer() public onlyCrowdsaleAgent {\n', '    released = true;\n', '  }\n', '  /// @dev Tranfer tokens to address\n', '  /// @param _to dest address\n', '  /// @param _value tokens amount\n', '  /// @return transfer result\n', '  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) canTransfer addIfNotExist(_to) returns (bool success) {\n', '    balances[msg.sender].value = safeSub(balances[msg.sender].value, _value);\n', '    balances[_to].value = safeAdd(balances[_to].value, _value);\n', '    balances[_to].exist = true;\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Tranfer tokens from one address to other\n', '  /// @param _from source address\n', '  /// @param _to dest address\n', '  /// @param _value tokens amount\n', '  /// @return transfer result\n', '  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(2 * 32) canTransfer addIfNotExist(_to) returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    balances[_to].value = safeAdd(balances[_to].value, _value);\n', '    balances[_from].value = safeSub(balances[_from].value, _value);\n', '    balances[_to].exist = true;\n', '\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '  /// @dev Tokens balance\n', '  /// @param _owner holder address\n', '  /// @return balance amount\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner].value;\n', '  }\n', '\n', '  /// @dev Approve transfer\n', '  /// @param _spender holder address\n', '  /// @param _value tokens amount\n', '  /// @return result\n', '  function approve(address _spender, uint _value) returns (bool success) {\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require ((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Token allowance\n', '  /// @param _owner holder address\n', '  /// @param _spender spender address\n', '  /// @return remain amount\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '  /// @dev buyout method\n', '  /// @param _holder holder address\n', '  /// @param _amount wei for buyout tokens\n', '  function buyout(address _holder, uint _amount) onlyOwner addIfNotExist(msg.sender) external  {\n', '    require(_holder != msg.sender);\n', '    require(this.balance >= _amount);\n', '    require(buyOutPrice <= _amount);\n', '\n', '    uint multiplier = 10 ** decimals;\n', '    uint buyoutTokens = safeDiv(safeMul(_amount, multiplier), buyOutPrice);\n', '\n', '    balances[msg.sender].value = safeAdd(balances[msg.sender].value, buyoutTokens);\n', '    balances[_holder].value = safeSub(balances[_holder].value, buyoutTokens);\n', '    balances[msg.sender].exist = true;\n', '\n', '    Transfer(_holder, msg.sender, buyoutTokens);\n', '\n', '    _holder.transfer(_amount);\n', '    Pay(_holder, _amount);\n', '  }\n', '}\n', '\n', '/// @title SilentNotary  сrowdsale contract\n', 'contract SilentNotaryCrowdsale is Haltable, Killable, SafeMath {\n', '\n', ' /// Period of the ICO stage\n', ' uint constant public DURATION = 14 days;\n', '\n', ' /// The duration of ICO\n', ' uint public icoDuration = DURATION;\n', '\n', ' //// The token we are selling\n', ' SilentNotaryToken public token;\n', '\n', ' /// Escrow wallet\n', ' address public multisigWallet;\n', '\n', ' /// Team wallet\n', ' address public teamWallet;\n', '\n', ' /// The UNIX timestamp start date of the crowdsale\n', ' uint public startsAt;\n', '\n', ' /// the number of tokens already sold through this contract\n', ' uint public tokensSold = 0;\n', '\n', ' ///  How many wei of funding we have raised\n', ' uint public weiRaised = 0;\n', '\n', ' ///  How many distinct addresses have invested\n', ' uint public investorCount = 0;\n', '\n', ' ///  How much wei we have returned back to the contract after a failed crowdfund.\n', ' uint public loadedRefund = 0;\n', '\n', ' ///  How much wei we have given back to investors.\n', ' uint public weiRefunded = 0;\n', '\n', ' ///  Has this crowdsale been finalized\n', ' bool public finalized;\n', '\n', ' ///  How much ETH each address has invested to this crowdsale\n', ' mapping (address => uint256) public investedAmountOf;\n', '\n', ' ///  How much tokens this crowdsale has credited for each investor address\n', ' mapping (address => uint256) public tokenAmountOf;\n', '\n', ' /// if the funding goal is not reached, investors may withdraw their funds\n', ' uint public constant FUNDING_GOAL = 1000 ether;\n', '\n', ' /// topup team wallet after that will topup both - team and multisig wallet by 32% and 68%\n', ' uint constant MULTISIG_WALLET_GOAL = FUNDING_GOAL;\n', '\n', ' /// Minimum order quantity 0.1 ether\n', ' uint public constant MIN_INVESTEMENT = 100 finney;\n', '\n', ' /// ICO start token price\n', ' uint public constant MIN_PRICE = 10e9;\n', '\n', ' /// Maximum token price, if reached ICO will stop\n', ' uint public constant MAX_PRICE = 20e10;\n', '\n', ' /// How much ICO tokens to sold\n', ' uint public constant INVESTOR_TOKENS  = 10e11;\n', '\n', ' /// Tokens count involved in price calculation\n', ' uint public constant TOTAL_TOKENS_FOR_PRICE = INVESTOR_TOKENS;\n', '\n', ' /// last token price\n', ' uint public tokenPrice = MIN_PRICE;\n', '\n', '  /// State machine\n', '  /// Preparing: All contract initialization calls and variables have not been set yet\n', '  /// Funding: Active crowdsale\n', '  /// Success: Minimum funding goal reached\n', '  /// Failure: Minimum funding goal not reached before ending time\n', '  /// Finalized: The finalized has been called and succesfully executed\n', '  /// Refunding: Refunds are loaded on the contract for reclaim\n', ' enum State{Unknown, Preparing, Funding, Success, Failure, Finalized, Refunding}\n', '\n', ' /// A new investment was made\n', ' event Invested(address investor, uint weiAmount, uint tokenAmount);\n', '\n', ' /// Refund was processed for a contributor\n', ' event Refund(address investor, uint weiAmount);\n', '\n', ' /// Crowdsale end time has been changed\n', ' event EndsAtChanged(uint endsAt);\n', '\n', ' /// New price was calculated\n', ' event PriceChanged(uint oldValue, uint newValue);\n', '\n', ' /// Modified allowing execution only if the crowdsale is currently runnin\n', ' modifier inState(State state) {\n', '   require(getState() == state);\n', '   _;\n', ' }\n', '\n', ' /// @dev Constructor\n', ' /// @param _token SNTR token address\n', ' /// @param _multisigWallet  multisig wallet address\n', ' /// @param _start  ICO start time\n', ' function SilentNotaryCrowdsale(address _token, address _multisigWallet, address _teamWallet, uint _start) {\n', '   require(_token != 0);\n', '   require(_multisigWallet != 0);\n', '   require(_teamWallet != 0);\n', '   require(_start != 0);\n', '\n', '   token = SilentNotaryToken(_token);\n', '   multisigWallet = _multisigWallet;\n', '   teamWallet = _teamWallet;\n', '   startsAt = _start;\n', ' }\n', '\n', ' /// @dev Don&#39;t expect to just send in money and get tokens.\n', ' function() payable {\n', '   buy();\n', ' }\n', '\n', '  /// @dev Make an investment.\n', '  /// @param receiver The Ethereum address who receives the tokens\n', ' function investInternal(address receiver) stopInEmergency private {\n', '   require(getState() == State.Funding);\n', '   require(msg.value >= MIN_INVESTEMENT);\n', '\n', '   uint weiAmount = msg.value;\n', '\n', '   var multiplier = 10 ** token.decimals();\n', '   uint tokenAmount = safeDiv(safeMul(weiAmount, multiplier), tokenPrice);\n', '   assert(tokenAmount > 0);\n', '\n', '   if(investedAmountOf[receiver] == 0) {\n', '      // A new investor\n', '      investorCount++;\n', '   }\n', '   // Update investor\n', '   investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver], weiAmount);\n', '   tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver], tokenAmount);\n', '   // Update totals\n', '   weiRaised = safeAdd(weiRaised, weiAmount);\n', '   tokensSold = safeAdd(tokensSold, tokenAmount);\n', '\n', '   var newPrice = calculatePrice(tokensSold);\n', '   PriceChanged(tokenPrice, newPrice);\n', '   tokenPrice = newPrice;\n', '\n', '   assignTokens(receiver, tokenAmount);\n', '   if(weiRaised <= MULTISIG_WALLET_GOAL)\n', '     multisigWallet.transfer(weiAmount);\n', '   else {\n', '     int remain = int(weiAmount - weiRaised - MULTISIG_WALLET_GOAL);\n', '\n', '     if(remain > 0) {\n', '       multisigWallet.transfer(uint(remain));\n', '       weiAmount = safeSub(weiAmount, uint(remain));\n', '     }\n', '\n', '     var distributedAmount = safeDiv(safeMul(weiAmount, 32), 100);\n', '     teamWallet.transfer(distributedAmount);\n', '     multisigWallet.transfer(safeSub(weiAmount, distributedAmount));\n', '\n', '   }\n', '   // Tell us invest was success\n', '   Invested(receiver, weiAmount, tokenAmount);\n', ' }\n', '\n', '  /// @dev Allow anonymous contributions to this crowdsale.\n', '  /// @param receiver The Ethereum address who receives the tokens\n', ' function invest(address receiver) public payable {\n', '   investInternal(receiver);\n', ' }\n', '\n', '  /// @dev Pay for funding, get invested tokens back in the sender address.\n', ' function buy() public payable {\n', '   invest(msg.sender);\n', ' }\n', '\n', ' /// @dev Finalize a succcesful crowdsale. The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\n', ' function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n', '   // If not already finalized\n', '   require(!finalized);\n', '\n', '   finalized = true;\n', '   finalizeCrowdsale();\n', ' }\n', '\n', ' /// @dev Finalize a succcesful crowdsale.\n', ' function finalizeCrowdsale() internal {\n', '   var multiplier = 10 ** token.decimals();\n', '   uint investorTokens = safeMul(INVESTOR_TOKENS, multiplier);\n', '   if(investorTokens > tokensSold)\n', '     assignTokens(teamWallet, safeSub(investorTokens, tokensSold));\n', '   token.releaseTokenTransfer();\n', ' }\n', '\n', '  /// @dev  Allow load refunds back on the contract for the refunding. The team can transfer the funds back on the smart contract in the case the minimum goal was not reached.\n', ' function loadRefund() public payable inState(State.Failure) {\n', '   if(msg.value == 0)\n', '     revert();\n', '   loadedRefund = safeAdd(loadedRefund, msg.value);\n', ' }\n', '\n', ' /// @dev  Investors can claim refund.\n', ' function refund() public inState(State.Refunding) {\n', '   uint256 weiValue = investedAmountOf[msg.sender];\n', '   if (weiValue == 0)\n', '     revert();\n', '   investedAmountOf[msg.sender] = 0;\n', '   weiRefunded = safeAdd(weiRefunded, weiValue);\n', '   Refund(msg.sender, weiValue);\n', '   if (!msg.sender.send(weiValue))\n', '     revert();\n', ' }\n', '\n', '  /// @dev Crowdfund state machine management.\n', '  /// @return State current state\n', ' function getState() public constant returns (State) {\n', '   if (finalized)\n', '     return State.Finalized;\n', '   if (address(token) == 0 || address(multisigWallet) == 0)\n', '     return State.Preparing;\n', '   if (now >= startsAt && now < startsAt + icoDuration && !isCrowdsaleFull())\n', '     return State.Funding;\n', '   if (isMinimumGoalReached())\n', '       return State.Success;\n', '   if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised)\n', '     return State.Refunding;\n', '   return State.Failure;\n', ' }\n', '\n', ' /// @dev Prolongate ICO if owner decide it\n', ' function prolongate() public onlyOwner {\n', '   require(icoDuration < DURATION * 2);\n', '   icoDuration += DURATION;\n', ' }\n', '\n', ' /// @dev Calculating price, it is not linear function\n', ' /// @param totalRaisedTokens total raised tokens\n', ' /// @return price in wei\n', ' function calculatePrice(uint totalRaisedTokens) internal returns (uint price) {\n', '   int multiplier = int(10**token.decimals());\n', '   int coefficient = int(safeDiv(totalRaisedTokens, TOTAL_TOKENS_FOR_PRICE)) - multiplier;\n', '   int priceDifference = coefficient * int(MAX_PRICE - MIN_PRICE) / multiplier;\n', '   assert(int(MAX_PRICE) >= -priceDifference);\n', '   return uint(priceDifference + int(MAX_PRICE));\n', ' }\n', '\n', '  /// @dev Minimum goal was reached\n', '  /// @return true if the crowdsale has raised enough money to be a succes\n', '  function isMinimumGoalReached() public constant returns (bool reached) {\n', '    return weiRaised >= FUNDING_GOAL;\n', '  }\n', '\n', '  /// @dev Check crowdsale limit\n', '  /// @return limit reached result\n', '  function isCrowdsaleFull() public constant returns (bool) {\n', '    return tokenPrice >= MAX_PRICE\n', '      || tokensSold >= safeMul(TOTAL_TOKENS_FOR_PRICE,  10 ** token.decimals())\n', '      || now > startsAt + icoDuration;\n', '  }\n', '\n', '   /// @dev Dynamically create tokens and assign them to the investor.\n', '   /// @param receiver address\n', '   /// @param tokenAmount tokens amount\n', '  function assignTokens(address receiver, uint tokenAmount) private {\n', '    token.mint(receiver, tokenAmount);\n', '  }\n', '}']