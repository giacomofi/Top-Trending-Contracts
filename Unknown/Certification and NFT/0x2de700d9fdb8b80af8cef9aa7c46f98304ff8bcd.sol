['contract MultiAsset {\n', '    function isCreated(bytes32 _symbol) constant returns(bool);\n', '    function owner(bytes32 _symbol) constant returns(address);\n', '    function totalSupply(bytes32 _symbol) constant returns(uint);\n', '    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\n', '    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\n', '    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n', '    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\n', '    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\n', '    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\n', '    function transferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n', '    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n', '    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n', '    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n', '    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\n', '}\n', '\n', 'contract Safe {\n', '    // Should always be placed as first modifier!\n', '    modifier noValue {\n', '        if (msg.value > 0) {\n', '            // Internal Out Of Gas/Throw: revert this transaction too;\n', '            // Call Stack Depth Limit reached: revert this transaction too;\n', '            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\n', '            _safeSend(msg.sender, msg.value);\n', '        }\n', '        _\n', '    }\n', '\n', '    modifier onlyHuman {\n', '        if (_isHuman()) {\n', '            _\n', '        }\n', '    }\n', '\n', '    modifier noCallback {\n', '        if (!isCall) {\n', '            _\n', '        }\n', '    }\n', '\n', '    modifier immutable(address _address) {\n', '        if (_address == 0) {\n', '            _\n', '        }\n', '    }\n', '\n', '    address stackDepthLib;\n', '    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n', '        stackDepthLib = _stackDepthLib;\n', '        return true;\n', '    }\n', '\n', '    modifier requireStackDepth(uint16 _depth) {\n', '        if (stackDepthLib == 0x0) {\n', '            throw;\n', '        }\n', '        if (_depth > 1023) {\n', '            throw;\n', '        }\n', '        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n', '            throw;\n', '        }\n', '        _\n', '    }\n', '\n', '    // Must not be used inside the functions that have noValue() modifier!\n', '    function _safeFalse() internal noValue() returns(bool) {\n', '        return false;\n', '    }\n', '\n', '    function _safeSend(address _to, uint _value) internal {\n', '        if (!_unsafeSend(_to, _value)) {\n', '            throw;\n', '        }\n', '    }\n', '\n', '    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n', '        return _to.call.value(_value)();\n', '    }\n', '\n', '    function _isContract() constant internal returns(bool) {\n', '        return msg.sender != tx.origin;\n', '    }\n', '\n', '    function _isHuman() constant internal returns(bool) {\n', '        return !_isContract();\n', '    }\n', '\n', '    bool private isCall = false;\n', '    function _setupNoCallback() internal {\n', '        isCall = true;\n', '    }\n', '\n', '    function _finishNoCallback() internal {\n', '        isCall = false;\n', '    }\n', '}\n', '\n', 'contract KUNA_SHARES is Safe {\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approve(address indexed from, address indexed spender, uint value);\n', '\n', '    MultiAsset public multiAsset;\n', '    bytes32 public symbol;\n', '\n', '    function init(address _multiAsset, bytes32 _symbol) noValue() immutable(address(multiAsset)) returns(bool) {\n', '        MultiAsset ma = MultiAsset(_multiAsset);\n', '        if (!ma.isCreated(_symbol)) {\n', '            return false;\n', '        }\n', '        multiAsset = ma;\n', '        symbol = _symbol;\n', '        return true;\n', '    }\n', '\n', '    modifier onlyMultiAsset() {\n', '        if (msg.sender == address(multiAsset)) {\n', '            _\n', '        }\n', '    }\n', '\n', '    function totalSupply() constant returns(uint) {\n', '        return multiAsset.totalSupply(symbol);\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns(uint) {\n', '        return multiAsset.balanceOf(_owner, symbol);\n', '    }\n', '\n', '    function allowance(address _from, address _spender) constant returns(uint) {\n', '        return multiAsset.allowance(_from, _spender, symbol);\n', '    }\n', '\n', '    function transfer(address _to, uint _value) returns(bool) {\n', '        return __transferWithReference(_to, _value, "");\n', '    }\n', '\n', '    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n', '        return __transferWithReference(_to, _value, _reference);\n', '    }\n', '\n', '    function __transferWithReference(address _to, uint _value, string _reference) private noValue() returns(bool) {\n', '        return _isHuman() ?\n', '            multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference) :\n', '            multiAsset.transferFromWithReference(msg.sender, _to, _value, symbol, _reference);\n', '    }\n', '\n', '    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n', '        return __transferToICAPWithReference(_icap, _value, "");\n', '    }\n', '\n', '    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n', '        return __transferToICAPWithReference(_icap, _value, _reference);\n', '    }\n', '\n', '    function __transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) private noValue() returns(bool) {\n', '        return _isHuman() ?\n', '            multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference) :\n', '            multiAsset.transferFromToICAPWithReference(msg.sender, _icap, _value, _reference);\n', '    }\n', '    \n', '    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n', '        return __transferFromWithReference(_from, _to, _value, "");\n', '    }\n', '\n', '    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n', '        return __transferFromWithReference(_from, _to, _value, _reference);\n', '    }\n', '\n', '    function __transferFromWithReference(address _from, address _to, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\n', '        return multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference);\n', '    }\n', '\n', '    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n', '        return __transferFromToICAPWithReference(_from, _icap, _value, "");\n', '    }\n', '\n', '    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n', '        return __transferFromToICAPWithReference(_from, _icap, _value, _reference);\n', '    }\n', '\n', '    function __transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\n', '        return multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference);\n', '    }\n', '\n', '    function approve(address _spender, uint _value) noValue() onlyHuman() returns(bool) {\n', '        return multiAsset.proxyApprove(_spender, _value, symbol);\n', '    }\n', '\n', '    function setCosignerAddress(address _cosigner) noValue() onlyHuman() returns(bool) {\n', '        return multiAsset.proxySetCosignerAddress(_cosigner, symbol);\n', '    }\n', '\n', '    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\n', '        Approve(_from, _spender, _value);\n', '    }\n', '\n', '    function sendToOwner() noValue() returns(bool) {\n', '        address owner = multiAsset.owner(symbol);\n', '        uint balance = this.balance;\n', '        bool success = true;\n', '        if (balance > 0) {\n', '            success = _unsafeSend(owner, balance);\n', '        }\n', '        return multiAsset.transfer(owner, balanceOf(owner), symbol) && success;\n', '    }\n', '}']