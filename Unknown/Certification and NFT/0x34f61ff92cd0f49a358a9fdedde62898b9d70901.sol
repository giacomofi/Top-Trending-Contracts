['pragma solidity ^0.4.15;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface AbstractENS {\n', '    function owner(bytes32 node) constant returns(address);\n', '    function resolver(bytes32 node) constant returns(address);\n', '    function ttl(bytes32 node) constant returns(uint64);\n', '    function setOwner(bytes32 node, address owner);\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner);\n', '    function setResolver(bytes32 node, address resolver);\n', '    function setTTL(bytes32 node, uint64 ttl);\n', '\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '}\n', '\n', 'interface InterCrypto_Interface {\n', '    // EVENTS\n', '    event ConversionStarted(uint indexed conversionID);\n', '    event ConversionSentToShapeShift(uint indexed conversionID, address indexed returnAddress, address indexed depositAddress, uint amount);\n', '    event ConversionAborted(uint indexed conversionID, string reason);\n', '    event Recovered(address indexed recoveredTo, uint amount);\n', '\n', '    // FUNCTIONS\n', '    function getInterCryptoPrice() constant public returns (uint);\n', '    function convert1(string _coinSymbol, string _toAddress) external payable returns (uint conversionID);\n', '    function convert2(string _coinSymbol, string _toAddress, address _returnAddress) external payable returns(uint conversionID);\n', '    function recover() external;\n', '    function recoverable(address myAddress) constant public returns (uint);\n', '    function cancelConversion(uint conversionID) external;\n', '}\n', '\n', 'interface AbstractPublicResolver {\n', '    function PublicResolver(address ensAddr);\n', '    function supportsInterface(bytes4 interfaceID) constant returns (bool);\n', '    function addr(bytes32 node) constant returns (address ret);\n', '    function setAddr(bytes32 node, address addr);\n', '    function hash(bytes32 node) constant returns (bytes32 ret);\n', '    function setHash(bytes32 node, bytes32 hash);\n', '}\n', '\n', 'contract usingInterCrypto is Ownable {\n', '    AbstractENS public abstractENS;\n', '    AbstractPublicResolver public abstractResolver;\n', '    InterCrypto_Interface public interCrypto;\n', '    \n', '    bytes32 public ResolverNode; // ENS Node name\n', '    bytes32 public InterCryptoNode; // ENS Node name\n', '    \n', '    function usingInterCrypto() public {\n', '        setNetwork();\n', '        updateResolver();\n', '        updateInterCrypto();\n', '        \n', '    }\n', '    \n', '    function setNetwork() internal returns(bool) {\n', '        if (getCodeSize(0x314159265dD8dbb310642f98f50C066173C1259b)>0){ //mainnet\n', '            abstractENS = AbstractENS(0x314159265dD8dbb310642f98f50C066173C1259b);\n', '            ResolverNode = 0xfdd5d5de6dd63db72bbc2d487944ba13bf775b50a80805fe6fcaba9b0fba88f5; // resolver.eth\n', '            InterCryptoNode = 0x921a56636fce44f7cbd33eed763c940f580add9ffb4da7007f8ff6e99804a7c8; // intercrypto.jacksplace.eth\n', '        }\n', '        else if (getCodeSize(0xe7410170f87102df0055eb195163a03b7f2bff4a)>0){ //rinkeby\n', '            abstractENS = AbstractENS(0xe7410170f87102df0055eb195163a03b7f2bff4a);\n', '            ResolverNode = 0xf2cf3eab504436e1b5a541dd9fbc5ac8547b773748bbf2bb81b350ee580702ca; // jackdomain.test\n', '            InterCryptoNode = 0xbe93c9e419d658afd89a8650dd90e37e763e75da1e663b9d57494aedf27f3eaa; // intercrypto.jackdomain.test\n', '        }\n', '        else if (getCodeSize(0x112234455c3a32fd11230c42e7bccd4a84e02010)>0){ //ropsten\n', '            abstractENS = AbstractENS(0x112234455c3a32fd11230c42e7bccd4a84e02010);\n', '            ResolverNode = 0xf2cf3eab504436e1b5a541dd9fbc5ac8547b773748bbf2bb81b350ee580702ca; // jackdomain.test\n', '            InterCryptoNode = 0xbe93c9e419d658afd89a8650dd90e37e763e75da1e663b9d57494aedf27f3eaa; // intercrypto.jackdomain.test\n', '        }\n', '        else {\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    function updateResolver() onlyOwner public {\n', '        abstractResolver = AbstractPublicResolver(abstractENS.resolver(ResolverNode));\n', '    }\n', '        \n', '    function updateInterCrypto() onlyOwner public {\n', '        interCrypto = InterCrypto_Interface(abstractResolver.addr(InterCryptoNode));\n', '    }\n', '    \n', '    function updateInterCryptonode(bytes32 newNodeName) onlyOwner public {\n', '        InterCryptoNode = newNodeName;\n', '    }\n', '        \n', '    function getCodeSize(address _addr) constant internal returns(uint _size) {\n', '        assembly {\n', '            _size := extcodesize(_addr)\n', '        }\n', '        return _size;\n', '    }\n', '    \n', '    function intercrypto_convert(uint amount, string _coinSymbol, string _toAddress) internal returns (uint conversionID) {\n', '        return interCrypto.convert1.value(amount)(_coinSymbol, _toAddress);\n', '    }\n', '    \n', '    function intercrypto_convert(uint amount, string _coinSymbol, string _toAddress, address _returnAddress) internal returns(uint conversionID) {\n', '        return interCrypto.convert2.value(amount)(_coinSymbol, _toAddress, _returnAddress);\n', '    }\n', '    \n', '    // If you want to allow public use of functions getInterCryptoPrice(), recover(), recoverable() or cancelConversion() then please copy the following as necessary\n', '    // into your smart contract. They are not included by default for security reasons.\n', '    \n', '    // function intercrypto_getInterCryptoPrice() constant public returns (uint) {\n', '    //     return interCrypto.getInterCryptoPrice();\n', '    // }\n', '    // function intercrypto_recover() onlyOwner public {\n', '    //     interCrypto.recover();\n', '    // }\n', '    // function intercrypto_recoverable() constant public returns (uint) {\n', '    //     return interCrypto.recoverable(this);\n', '    // }\n', '    // function intercrypto_cancelConversion(uint conversionID) onlyOwner external {\n', '    //     interCrypto.cancelConversion(conversionID);\n', '    // }\n', '}\n', '\n', 'contract InterCrypto_Wallet is usingInterCrypto {\n', '\n', '    event Deposit(address indexed deposit, uint amount);\n', '    event WithdrawalNormal(address indexed withdrawal, uint amount);\n', '    event WithdrawalInterCrypto(uint indexed conversionID);\n', '\n', '    mapping (address => uint) public funds;\n', '    \n', '    function InterCrypto_Wallet() {}\n', '\n', '    function () payable {}\n', '    \n', '    function deposit() payable {\n', '      if (msg.value > 0) {\n', '          funds[msg.sender] += msg.value;\n', '          Deposit(msg.sender, msg.value);\n', '      }\n', '    }\n', '    \n', '    function intercrypto_getInterCryptoPrice() constant public returns (uint) {\n', '        return interCrypto.getInterCryptoPrice();\n', '    }\n', '    \n', '    function withdrawalNormal() payable external {\n', '        uint amount = funds[msg.sender] + msg.value;\n', '        funds[msg.sender] = 0;\n', '        if(msg.sender.send(amount)) {\n', '            WithdrawalNormal(msg.sender, amount);\n', '        }\n', '        else {\n', '            funds[msg.sender] = amount;\n', '        }\n', '    }\n', '    \n', '    function withdrawalInterCrypto(string _coinSymbol, string _toAddress) external payable {\n', '        uint amount = funds[msg.sender] + msg.value;\n', '        funds[msg.sender] = 0;\n', '        uint conversionID = intercrypto_convert(amount, _coinSymbol, _toAddress);\n', '        WithdrawalInterCrypto(conversionID);\n', '    }\n', '    \n', '    \n', '    function intercrypto_recover() onlyOwner public {\n', '        interCrypto.recover();\n', '    }\n', '    \n', '    function intercrypto_recoverable() constant public returns (uint) {\n', '        return interCrypto.recoverable(this);\n', '    }\n', '    \n', '    function intercrypto_cancelConversion(uint conversionID) onlyOwner external {\n', '        interCrypto.cancelConversion(conversionID);\n', '    }\n', '    \n', '    function kill() onlyOwner external {\n', '        selfdestruct(owner);\n', '    }\n', '}']
['pragma solidity ^0.4.15;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    require(newOwner != address(0));      \n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface AbstractENS {\n', '    function owner(bytes32 node) constant returns(address);\n', '    function resolver(bytes32 node) constant returns(address);\n', '    function ttl(bytes32 node) constant returns(uint64);\n', '    function setOwner(bytes32 node, address owner);\n', '    function setSubnodeOwner(bytes32 node, bytes32 label, address owner);\n', '    function setResolver(bytes32 node, address resolver);\n', '    function setTTL(bytes32 node, uint64 ttl);\n', '\n', '    // Logged when the owner of a node assigns a new owner to a subnode.\n', '    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n', '\n', '    // Logged when the owner of a node transfers ownership to a new account.\n', '    event Transfer(bytes32 indexed node, address owner);\n', '\n', '    // Logged when the resolver for a node changes.\n', '    event NewResolver(bytes32 indexed node, address resolver);\n', '\n', '    // Logged when the TTL of a node changes\n', '    event NewTTL(bytes32 indexed node, uint64 ttl);\n', '}\n', '\n', 'interface InterCrypto_Interface {\n', '    // EVENTS\n', '    event ConversionStarted(uint indexed conversionID);\n', '    event ConversionSentToShapeShift(uint indexed conversionID, address indexed returnAddress, address indexed depositAddress, uint amount);\n', '    event ConversionAborted(uint indexed conversionID, string reason);\n', '    event Recovered(address indexed recoveredTo, uint amount);\n', '\n', '    // FUNCTIONS\n', '    function getInterCryptoPrice() constant public returns (uint);\n', '    function convert1(string _coinSymbol, string _toAddress) external payable returns (uint conversionID);\n', '    function convert2(string _coinSymbol, string _toAddress, address _returnAddress) external payable returns(uint conversionID);\n', '    function recover() external;\n', '    function recoverable(address myAddress) constant public returns (uint);\n', '    function cancelConversion(uint conversionID) external;\n', '}\n', '\n', 'interface AbstractPublicResolver {\n', '    function PublicResolver(address ensAddr);\n', '    function supportsInterface(bytes4 interfaceID) constant returns (bool);\n', '    function addr(bytes32 node) constant returns (address ret);\n', '    function setAddr(bytes32 node, address addr);\n', '    function hash(bytes32 node) constant returns (bytes32 ret);\n', '    function setHash(bytes32 node, bytes32 hash);\n', '}\n', '\n', 'contract usingInterCrypto is Ownable {\n', '    AbstractENS public abstractENS;\n', '    AbstractPublicResolver public abstractResolver;\n', '    InterCrypto_Interface public interCrypto;\n', '    \n', '    bytes32 public ResolverNode; // ENS Node name\n', '    bytes32 public InterCryptoNode; // ENS Node name\n', '    \n', '    function usingInterCrypto() public {\n', '        setNetwork();\n', '        updateResolver();\n', '        updateInterCrypto();\n', '        \n', '    }\n', '    \n', '    function setNetwork() internal returns(bool) {\n', '        if (getCodeSize(0x314159265dD8dbb310642f98f50C066173C1259b)>0){ //mainnet\n', '            abstractENS = AbstractENS(0x314159265dD8dbb310642f98f50C066173C1259b);\n', '            ResolverNode = 0xfdd5d5de6dd63db72bbc2d487944ba13bf775b50a80805fe6fcaba9b0fba88f5; // resolver.eth\n', '            InterCryptoNode = 0x921a56636fce44f7cbd33eed763c940f580add9ffb4da7007f8ff6e99804a7c8; // intercrypto.jacksplace.eth\n', '        }\n', '        else if (getCodeSize(0xe7410170f87102df0055eb195163a03b7f2bff4a)>0){ //rinkeby\n', '            abstractENS = AbstractENS(0xe7410170f87102df0055eb195163a03b7f2bff4a);\n', '            ResolverNode = 0xf2cf3eab504436e1b5a541dd9fbc5ac8547b773748bbf2bb81b350ee580702ca; // jackdomain.test\n', '            InterCryptoNode = 0xbe93c9e419d658afd89a8650dd90e37e763e75da1e663b9d57494aedf27f3eaa; // intercrypto.jackdomain.test\n', '        }\n', '        else if (getCodeSize(0x112234455c3a32fd11230c42e7bccd4a84e02010)>0){ //ropsten\n', '            abstractENS = AbstractENS(0x112234455c3a32fd11230c42e7bccd4a84e02010);\n', '            ResolverNode = 0xf2cf3eab504436e1b5a541dd9fbc5ac8547b773748bbf2bb81b350ee580702ca; // jackdomain.test\n', '            InterCryptoNode = 0xbe93c9e419d658afd89a8650dd90e37e763e75da1e663b9d57494aedf27f3eaa; // intercrypto.jackdomain.test\n', '        }\n', '        else {\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    function updateResolver() onlyOwner public {\n', '        abstractResolver = AbstractPublicResolver(abstractENS.resolver(ResolverNode));\n', '    }\n', '        \n', '    function updateInterCrypto() onlyOwner public {\n', '        interCrypto = InterCrypto_Interface(abstractResolver.addr(InterCryptoNode));\n', '    }\n', '    \n', '    function updateInterCryptonode(bytes32 newNodeName) onlyOwner public {\n', '        InterCryptoNode = newNodeName;\n', '    }\n', '        \n', '    function getCodeSize(address _addr) constant internal returns(uint _size) {\n', '        assembly {\n', '            _size := extcodesize(_addr)\n', '        }\n', '        return _size;\n', '    }\n', '    \n', '    function intercrypto_convert(uint amount, string _coinSymbol, string _toAddress) internal returns (uint conversionID) {\n', '        return interCrypto.convert1.value(amount)(_coinSymbol, _toAddress);\n', '    }\n', '    \n', '    function intercrypto_convert(uint amount, string _coinSymbol, string _toAddress, address _returnAddress) internal returns(uint conversionID) {\n', '        return interCrypto.convert2.value(amount)(_coinSymbol, _toAddress, _returnAddress);\n', '    }\n', '    \n', '    // If you want to allow public use of functions getInterCryptoPrice(), recover(), recoverable() or cancelConversion() then please copy the following as necessary\n', '    // into your smart contract. They are not included by default for security reasons.\n', '    \n', '    // function intercrypto_getInterCryptoPrice() constant public returns (uint) {\n', '    //     return interCrypto.getInterCryptoPrice();\n', '    // }\n', '    // function intercrypto_recover() onlyOwner public {\n', '    //     interCrypto.recover();\n', '    // }\n', '    // function intercrypto_recoverable() constant public returns (uint) {\n', '    //     return interCrypto.recoverable(this);\n', '    // }\n', '    // function intercrypto_cancelConversion(uint conversionID) onlyOwner external {\n', '    //     interCrypto.cancelConversion(conversionID);\n', '    // }\n', '}\n', '\n', 'contract InterCrypto_Wallet is usingInterCrypto {\n', '\n', '    event Deposit(address indexed deposit, uint amount);\n', '    event WithdrawalNormal(address indexed withdrawal, uint amount);\n', '    event WithdrawalInterCrypto(uint indexed conversionID);\n', '\n', '    mapping (address => uint) public funds;\n', '    \n', '    function InterCrypto_Wallet() {}\n', '\n', '    function () payable {}\n', '    \n', '    function deposit() payable {\n', '      if (msg.value > 0) {\n', '          funds[msg.sender] += msg.value;\n', '          Deposit(msg.sender, msg.value);\n', '      }\n', '    }\n', '    \n', '    function intercrypto_getInterCryptoPrice() constant public returns (uint) {\n', '        return interCrypto.getInterCryptoPrice();\n', '    }\n', '    \n', '    function withdrawalNormal() payable external {\n', '        uint amount = funds[msg.sender] + msg.value;\n', '        funds[msg.sender] = 0;\n', '        if(msg.sender.send(amount)) {\n', '            WithdrawalNormal(msg.sender, amount);\n', '        }\n', '        else {\n', '            funds[msg.sender] = amount;\n', '        }\n', '    }\n', '    \n', '    function withdrawalInterCrypto(string _coinSymbol, string _toAddress) external payable {\n', '        uint amount = funds[msg.sender] + msg.value;\n', '        funds[msg.sender] = 0;\n', '        uint conversionID = intercrypto_convert(amount, _coinSymbol, _toAddress);\n', '        WithdrawalInterCrypto(conversionID);\n', '    }\n', '    \n', '    \n', '    function intercrypto_recover() onlyOwner public {\n', '        interCrypto.recover();\n', '    }\n', '    \n', '    function intercrypto_recoverable() constant public returns (uint) {\n', '        return interCrypto.recoverable(this);\n', '    }\n', '    \n', '    function intercrypto_cancelConversion(uint conversionID) onlyOwner external {\n', '        interCrypto.cancelConversion(conversionID);\n', '    }\n', '    \n', '    function kill() onlyOwner external {\n', '        selfdestruct(owner);\n', '    }\n', '}']
