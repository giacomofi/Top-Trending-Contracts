['pragma solidity ^0.4.11;\n', '\n', '/*\n', '\n', 'Status Reseller\n', '========================\n', '\n', 'Resells Status tokens from the crowdsale before transfers are enabled.\n', 'Author: /u/Cintix\n', '\n', '*/\n', '\n', '// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', 'contract Reseller {\n', '  // Store the amount of SNT claimed by each account.\n', '  mapping (address => uint256) public snt_claimed;\n', '  // Total claimed SNT of all accounts.\n', '  uint256 public total_snt_claimed;\n', '  \n', '  // Status Network Token (SNT) Contract address.\n', '  ERC20 public token = ERC20(0x744d70FDBE2Ba4CF95131626614a1763DF805B9E);\n', '  // The developer address.\n', '  address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e;\n', '  \n', '  // Withdraws SNT claimed by the user.\n', '  function withdraw() {\n', '    // Store the user&#39;s amount of claimed SNT as the amount of SNT to withdraw.\n', '    uint256 snt_to_withdraw = snt_claimed[msg.sender];\n', '    // Update the user&#39;s amount of claimed SNT first to prevent recursive call.\n', '    snt_claimed[msg.sender] = 0;\n', '    // Update the total amount of claimed SNT.\n', '    total_snt_claimed -= snt_to_withdraw;\n', '    // Send the user their SNT.  Throws on failure to prevent loss of funds.\n', '    if(!token.transfer(msg.sender, snt_to_withdraw)) throw;\n', '  }\n', '  \n', '  // Claims SNT at a price determined by the block number.\n', '  function claim() payable {\n', '    // Verify ICO is over.\n', '    if(block.number < 3910000) throw;\n', '    // Calculate current sale price (SNT per ETH) based on block number.\n', '    uint256 snt_per_eth = (block.number - 3910000) * 2;\n', '    // Calculate amount of SNT user can purchase.\n', '    uint256 snt_to_claim = snt_per_eth * msg.value;\n', '    // Retrieve current SNT balance of contract.\n', '    uint256 contract_snt_balance = token.balanceOf(address(this));\n', '    // Verify the contract has enough remaining unclaimed SNT.\n', '    if((contract_snt_balance - total_snt_claimed) < snt_to_claim) throw;\n', '    // Update the amount of SNT claimed by the user.\n', '    snt_claimed[msg.sender] += snt_to_claim;\n', '    // Update the total amount of SNT claimed by all users.\n', '    total_snt_claimed += snt_to_claim;\n', '    // Send the funds to the developer instead of leaving them in the contract.\n', '    developer.transfer(msg.value);\n', '  }\n', '  \n', '  // Default function.  Called when a user sends ETH to the contract.\n', '  function () payable {\n', '    // If the user sent a 0 ETH transaction, withdraw their SNT.\n', '    if(msg.value == 0) {\n', '      withdraw();\n', '    }\n', '    // If the user sent ETH, claim SNT with it.\n', '    else {\n', '      claim();\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/*\n', '\n', 'Status Reseller\n', '========================\n', '\n', 'Resells Status tokens from the crowdsale before transfers are enabled.\n', 'Author: /u/Cintix\n', '\n', '*/\n', '\n', '// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  function transfer(address _to, uint256 _value) returns (bool success);\n', '  function balanceOf(address _owner) constant returns (uint256 balance);\n', '}\n', '\n', 'contract Reseller {\n', '  // Store the amount of SNT claimed by each account.\n', '  mapping (address => uint256) public snt_claimed;\n', '  // Total claimed SNT of all accounts.\n', '  uint256 public total_snt_claimed;\n', '  \n', '  // Status Network Token (SNT) Contract address.\n', '  ERC20 public token = ERC20(0x744d70FDBE2Ba4CF95131626614a1763DF805B9E);\n', '  // The developer address.\n', '  address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e;\n', '  \n', '  // Withdraws SNT claimed by the user.\n', '  function withdraw() {\n', "    // Store the user's amount of claimed SNT as the amount of SNT to withdraw.\n", '    uint256 snt_to_withdraw = snt_claimed[msg.sender];\n', "    // Update the user's amount of claimed SNT first to prevent recursive call.\n", '    snt_claimed[msg.sender] = 0;\n', '    // Update the total amount of claimed SNT.\n', '    total_snt_claimed -= snt_to_withdraw;\n', '    // Send the user their SNT.  Throws on failure to prevent loss of funds.\n', '    if(!token.transfer(msg.sender, snt_to_withdraw)) throw;\n', '  }\n', '  \n', '  // Claims SNT at a price determined by the block number.\n', '  function claim() payable {\n', '    // Verify ICO is over.\n', '    if(block.number < 3910000) throw;\n', '    // Calculate current sale price (SNT per ETH) based on block number.\n', '    uint256 snt_per_eth = (block.number - 3910000) * 2;\n', '    // Calculate amount of SNT user can purchase.\n', '    uint256 snt_to_claim = snt_per_eth * msg.value;\n', '    // Retrieve current SNT balance of contract.\n', '    uint256 contract_snt_balance = token.balanceOf(address(this));\n', '    // Verify the contract has enough remaining unclaimed SNT.\n', '    if((contract_snt_balance - total_snt_claimed) < snt_to_claim) throw;\n', '    // Update the amount of SNT claimed by the user.\n', '    snt_claimed[msg.sender] += snt_to_claim;\n', '    // Update the total amount of SNT claimed by all users.\n', '    total_snt_claimed += snt_to_claim;\n', '    // Send the funds to the developer instead of leaving them in the contract.\n', '    developer.transfer(msg.value);\n', '  }\n', '  \n', '  // Default function.  Called when a user sends ETH to the contract.\n', '  function () payable {\n', '    // If the user sent a 0 ETH transaction, withdraw their SNT.\n', '    if(msg.value == 0) {\n', '      withdraw();\n', '    }\n', '    // If the user sent ETH, claim SNT with it.\n', '    else {\n', '      claim();\n', '    }\n', '  }\n', '}']
