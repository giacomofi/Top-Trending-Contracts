['contract DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) constant returns (bool);\n', '}\n', '\n', 'contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    function DSAuth() {\n', '        owner = msg.sender;\n', '        LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        LogSetAuthority(authority);\n', '    }\n', '\n', '    modifier auth {\n', '        assert(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, this, sig);\n', '        }\n', '    }\n', '\n', '    function assert(bool x) internal {\n', '        if (!x) throw;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint supply);\n', '    function balanceOf( address who ) constant returns (uint value);\n', '    function allowance( address owner, address spender ) constant returns (uint _allowance);\n', '\n', '    function transfer( address to, uint value) returns (bool ok);\n', '    function transferFrom( address from, address to, uint value) returns (bool ok);\n', '    function approve( address spender, uint value ) returns (bool ok);\n', '\n', '    event Transfer( address indexed from, address indexed to, uint value);\n', '    event Approval( address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract DSMath {\n', '    \n', '\n', '    function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x * y;\n', '        assert(x == 0 || z / x == y);\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '\n', '\n', '    function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x + y) >= x);\n', '    }\n', '\n', '    function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        assert((z = x - y) <= x);\n', '    }\n', '\n', '    function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = x * y;\n', '        assert(x == 0 || z / x == y);\n', '    }\n', '\n', '    function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = x / y;\n', '    }\n', '\n', '    function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '\n', '\n', '    function imin(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int256 x, int256 y) constant internal returns (int256 z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    /*\n', '    WAD math\n', '     */\n', '\n', '    uint128 constant WAD = 10 ** 18;\n', '\n', '    function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + WAD / 2) / WAD);\n', '    }\n', '\n', '    function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * WAD + y / 2) / y);\n', '    }\n', '\n', '    function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    /*\n', '    RAY math\n', '     */\n', '\n', '    uint128 constant RAY = 10 ** 27;\n', '\n', '    function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hadd(x, y);\n', '    }\n', '\n', '    function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hsub(x, y);\n', '    }\n', '\n', '    function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * y + RAY / 2) / RAY);\n', '    }\n', '\n', '    function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n', '        z = cast((uint256(x) * RAY + y / 2) / y);\n', '    }\n', '\n', '    function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n', '        \n', '        \n', '        \n', '        \n', '        \n', '        \n', '        \n', '        \n', '        \n', '        \n', '        \n', '        \n', '        \n', '        \n', '\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '\n', '    function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmin(x, y);\n', '    }\n', '    function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n', '        return hmax(x, y);\n', '    }\n', '\n', '    function cast(uint256 x) constant internal returns (uint128 z) {\n', '        assert((z = uint128(x)) == x);\n', '    }\n', '\n', '}\n', '\n', 'contract IkuraStorage is DSMath, DSAuth {\n', '  \n', '  address[] ownerAddresses;\n', '\n', '  \n', '  mapping(address => uint) coinBalances;\n', '\n', '  \n', '  mapping(address => uint) tokenBalances;\n', '\n', '  \n', '  mapping(address => mapping (address => uint)) coinAllowances;\n', '\n', '  \n', '  uint _totalSupply = 0;\n', '\n', '  \n', '  \n', '  \n', '  uint _transferFeeRate = 500;\n', '\n', '  \n', '  \n', '  \n', '  uint8 _transferMinimumFee = 5;\n', '\n', '  address tokenAddress;\n', '  address multiSigAddress;\n', '  address authorityAddress;\n', '\n', '  \n', '  \n', '  \n', '  function IkuraStorage() DSAuth() {\n', '    /*address controllerAddress = 0x34c5605A4Ef1C98575DB6542179E55eE1f77A188;\n', '    owner = controllerAddress;\n', '    LogSetOwner(controllerAddress);*/\n', '  }\n', '\n', '  function changeToken(address tokenAddress_) auth {\n', '    tokenAddress = tokenAddress_;\n', '  }\n', '\n', '  function changeAssociation(address multiSigAddress_) auth {\n', '    multiSigAddress = multiSigAddress_;\n', '  }\n', '\n', '  function changeAuthority(address authorityAddress_) auth {\n', '    authorityAddress = authorityAddress_;\n', '  }\n', '\n', '  function totalSupply() auth returns (uint) {\n', '    return _totalSupply;\n', '  }\n', '  function addTotalSupply(uint amount) auth {\n', '    _totalSupply = add(_totalSupply, amount);\n', '  }\n', '  function subTotalSupply(uint amount) auth {\n', '    _totalSupply = sub(_totalSupply, amount);\n', '  }\n', '  function transferFeeRate() auth returns (uint) {\n', '    return _transferFeeRate;\n', '  }\n', '\n', '  function setTransferFeeRate(uint newTransferFeeRate) auth returns (bool) {\n', '    _transferFeeRate = newTransferFeeRate;\n', '\n', '    return true;\n', '  }\n', '\n', '  \n', '  \n', '  \n', '\n', '  function transferMinimumFee() auth returns (uint8) {\n', '    return _transferMinimumFee;\n', '  }\n', '\n', '  function setTransferMinimumFee(uint8 newTransferMinimumFee) auth {\n', '    _transferMinimumFee = newTransferMinimumFee;\n', '  }\n', '\n', '  function addOwnerAddress(address addr) internal returns (bool) {\n', '    ownerAddresses.push(addr);\n', '\n', '    return true;\n', '  }\n', '\n', '  function removeOwnerAddress(address addr) internal returns (bool) {\n', '    uint i = 0;\n', '\n', '    while (ownerAddresses[i] != addr) { i++; }\n', '\n', '    while (i < ownerAddresses.length - 1) {\n', '      ownerAddresses[i] = ownerAddresses[i + 1];\n', '      i++;\n', '    }\n', '\n', '    ownerAddresses.length--;\n', '\n', '    return true;\n', '  }\n', '\n', '  function primaryOwner() auth returns (address) {\n', '    return ownerAddresses[0];\n', '  }\n', '\n', '  function isOwnerAddress(address addr) auth returns (bool) {\n', '    for (uint i = 0; i < ownerAddresses.length; i++) {\n', '      if (ownerAddresses[i] == addr) return true;\n', '    }\n', '\n', '    return false;\n', '  }\n', '\n', '  function numOwnerAddress() auth constant returns (uint) {\n', '    return ownerAddresses.length;\n', '  }\n', '\n', '  \n', '  \n', '  \n', '\n', '  function coinBalance(address addr) auth returns (uint) {\n', '    return coinBalances[addr];\n', '  }\n', '\n', '  function addCoinBalance(address addr, uint amount) auth returns (bool) {\n', '    coinBalances[addr] = add(coinBalances[addr], amount);\n', '\n', '    return true;\n', '  }\n', '\n', '  function subCoinBalance(address addr, uint amount) auth returns (bool) {\n', '    coinBalances[addr] = sub(coinBalances[addr], amount);\n', '\n', '    return true;\n', '  }\n', '\n', '  \n', '  \n', '  \n', '\n', '  function tokenBalance(address addr) auth returns (uint) {\n', '    return tokenBalances[addr];\n', '  }\n', '\n', '  function addTokenBalance(address addr, uint amount) auth returns (bool) {\n', '    tokenBalances[addr] = add(tokenBalances[addr], amount);\n', '\n', '    if (tokenBalances[addr] > 0 && !isOwnerAddress(addr)) {\n', '      addOwnerAddress(addr);\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  function subTokenBalance(address addr, uint amount) auth returns (bool) {\n', '    tokenBalances[addr] = sub(tokenBalances[addr], amount);\n', '\n', '    if (tokenBalances[addr] <= 0) {\n', '      removeOwnerAddress(addr);\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  \n', '  \n', '  \n', '\n', '  function coinAllowance(address owner_, address spender) auth returns (uint) {\n', '    return coinAllowances[owner_][spender];\n', '  }\n', '\n', '  function addCoinAllowance(address owner_, address spender, uint amount) auth returns (bool) {\n', '    coinAllowances[owner_][spender] = add(coinAllowances[owner_][spender], amount);\n', '\n', '    return true;\n', '  }\n', '\n', '  function subCoinAllowance(address owner_, address spender, uint amount) auth returns (bool) {\n', '    coinAllowances[owner_][spender] = sub(coinAllowances[owner_][spender], amount);\n', '\n', '    return true;\n', '  }\n', '\n', '  function setCoinAllowance(address owner_, address spender, uint amount) auth returns (bool) {\n', '    coinAllowances[owner_][spender] = amount;\n', '\n', '    return true;\n', '  }\n', '\n', '  function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n', '    sig; \n', '\n', '    return  src == address(this) ||\n', '            src == owner ||\n', '            src == tokenAddress ||\n', '            src == authorityAddress ||\n', '            src == multiSigAddress;\n', '  }\n', '}\n', '\n', 'contract IkuraTokenEvent {\n', '  /** オーナーがdJPYを鋳造した際に発火するイベント */\n', '  event IkuraMint(address indexed owner, uint);\n', '\n', '  /** オーナーがdJPYを消却した際に発火するイベント */\n', '  event IkuraBurn(address indexed owner, uint);\n', '\n', '  /** トークンの移動時に発火するイベント */\n', '  event IkuraTransferToken(address indexed from, address indexed to, uint value);\n', '\n', '  /** 手数料が発生したときに発火するイベント */\n', '  event IkuraTransferFee(address indexed from, address indexed to, address indexed owner, uint value);\n', '\n', '  event IkuraTransfer(address indexed from, address indexed to, uint value);\n', '\n', '  /** 送金許可イベント */\n', '  event IkuraApproval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract IkuraAssociation is DSMath, DSAuth {\n', '  \n', '  \n', '  \n', '\n', '  \n', '  uint public confirmTotalTokenThreshold = 50;\n', '\n', '  \n', '  \n', '  \n', '\n', '  \n', '  IkuraStorage _storage;\n', '  IkuraToken _token;\n', '\n', '  \n', '  Proposal[] mintProposals;\n', '  Proposal[] burnProposals;\n', '  Proposal[] transferMinimumFeeProposals;\n', '  Proposal[] transferFeeRateProposals;\n', '\n', '  mapping (bytes32 => Proposal[]) proposals;\n', '\n', '  struct Proposal {\n', '    address proposer;                     \n', '    bytes32 digest;                       \n', '    bool executed;                        \n', '    uint createdAt;                       \n', '    uint expireAt;                        \n', '    address[] confirmers;                 \n', '    uint amount;                          \n', '    uint8 transferMinimumFee;             \n', '    uint transferFeeRate;                 \n', '  }\n', '\n', '  \n', '  \n', '  \n', '\n', '  event MintProposalAdded(uint proposalId, address proposer, uint amount);\n', '  event MintConfirmed(uint proposalId, address confirmer, uint amount);\n', '  event MintExecuted(uint proposalId, address proposer, uint amount);\n', '\n', '  event BurnProposalAdded(uint proposalId, address proposer, uint amount);\n', '  event BurnConfirmed(uint proposalId, address confirmer, uint amount);\n', '  event BurnExecuted(uint proposalId, address proposer, uint amount);\n', '\n', '  event TransferMinimumFeeProposalAdded(uint proposalId, address proposer, uint8 transferMinimumFee);\n', '  event TransferMinimumFeeConfirmed(uint proposalId, address confirmer, uint8 transferMinimumFee);\n', '  event TransferMinimumFeeExecuted(uint proposalId, address proposer, uint8 transferMinimumFee);\n', '\n', '  event TransferFeeRateProposalAdded(uint proposalId, address proposer, uint transferFeeRate);\n', '  event TransferFeeRateConfirmed(uint proposalId, address confirmer, uint transferFeeRate);\n', '  event TransferFeeRateExecuted(uint proposalId, address proposer, uint transferFeeRate);\n', '\n', '  function IkuraAssociation() {\n', "    proposals[sha3('mint')] = mintProposals;\n", "    proposals[sha3('burn')] = burnProposals;\n", "    proposals[sha3('transferMinimumFee')] = transferMinimumFeeProposals;\n", "    proposals[sha3('transferFeeRate')] = transferFeeRateProposals;\n", '\n', '  }\n', '\n', '  function changeStorage(IkuraStorage newStorage) auth returns (bool) {\n', '    _storage = newStorage;\n', '\n', '    return true;\n', '  }\n', '\n', '  function changeToken(IkuraToken token_) auth returns (bool) {\n', '    _token = token_;\n', '\n', '    return true;\n', '  }\n', '\n', '  function newProposal(bytes32 type_, address proposer, uint amount, uint8 transferMinimumFee, uint transferFeeRate, bytes transationBytecode) returns (uint) {\n', '    uint proposalId = proposals[type_].length++;\n', '    Proposal proposal = proposals[type_][proposalId];\n', '    proposal.proposer = proposer;\n', '    proposal.amount = amount;\n', '    proposal.transferMinimumFee = transferMinimumFee;\n', '    proposal.transferFeeRate = transferFeeRate;\n', '    proposal.digest = sha3(proposer, amount, transationBytecode);\n', '    proposal.executed = false;\n', '    proposal.createdAt = now;\n', '    proposal.expireAt = proposal.createdAt + 86400;\n', '\n', '    \n', '    \n', "    if (type_ == sha3('mint')) MintProposalAdded(proposalId, proposer, amount);\n", "    if (type_ == sha3('burn')) BurnProposalAdded(proposalId, proposer, amount);\n", "    if (type_ == sha3('transferMinimumFee')) TransferMinimumFeeProposalAdded(proposalId, proposer, transferMinimumFee);\n", "    if (type_ == sha3('transferFeeRate')) TransferFeeRateProposalAdded(proposalId, proposer, transferFeeRate);\n", '\n', '    \n', '    confirmProposal(type_, proposer, proposalId);\n', '\n', '    return proposalId;\n', '  }\n', '\n', '  function confirmProposal(bytes32 type_, address confirmer, uint proposalId) {\n', '    Proposal proposal = proposals[type_][proposalId];\n', '\n', '    \n', '    if (hasConfirmed(type_, confirmer, proposalId)) throw;\n', '\n', '    \n', '    proposal.confirmers.push(confirmer);\n', '\n', '    \n', '    \n', "    if (type_ == sha3('mint')) MintConfirmed(proposalId, confirmer, proposal.amount);\n", "    if (type_ == sha3('burn')) BurnConfirmed(proposalId, confirmer, proposal.amount);\n", "    if (type_ == sha3('transferMinimumFee')) TransferMinimumFeeConfirmed(proposalId, confirmer, proposal.transferMinimumFee);\n", "    if (type_ == sha3('transferFeeRate')) TransferFeeRateConfirmed(proposalId, confirmer, proposal.transferFeeRate);\n", '\n', "    if (isProposalExecutable(type_, proposalId, proposal.proposer, '')) {\n", '      proposal.executed = true;\n', '\n', '      \n', '      \n', "      if (type_ == sha3('mint')) executeMintProposal(proposalId);\n", "      if (type_ == sha3('burn')) executeBurnProposal(proposalId);\n", "      if (type_ == sha3('transferMinimumFee')) executeUpdateTransferMinimumFeeProposal(proposalId);\n", "      if (type_ == sha3('transferFeeRate')) executeUpdateTransferFeeRateProposal(proposalId);\n", '    }\n', '  }\n', '\n', '  function hasConfirmed(bytes32 type_, address addr, uint proposalId) returns (bool) {\n', '    Proposal proposal = proposals[type_][proposalId];\n', '    uint length = proposal.confirmers.length;\n', '\n', '    for (uint i = 0; i < length; i++) {\n', '      if (proposal.confirmers[i] == addr) return true;\n', '    }\n', '\n', '    return false;\n', '  }\n', '\n', '  function confirmedTotalToken(bytes32 type_, uint proposalId) returns (uint) {\n', '    Proposal proposal = proposals[type_][proposalId];\n', '    uint length = proposal.confirmers.length;\n', '    uint total = 0;\n', '\n', '    for (uint i = 0; i < length; i++) {\n', '      total = add(total, _storage.tokenBalance(proposal.confirmers[i]));\n', '    }\n', '\n', '    return total;\n', '  }\n', '\n', '  function proposalExpireAt(bytes32 type_, uint proposalId) returns (uint) {\n', '    Proposal proposal = proposals[type_][proposalId];\n', '    return proposal.expireAt;\n', '  }\n', '\n', '  function isProposalExecutable(bytes32 type_, uint proposalId, address proposer, bytes transactionBytecode) returns (bool) {\n', '    Proposal proposal = proposals[type_][proposalId];\n', '\n', '    \n', '    if (_storage.numOwnerAddress() < 2) {\n', '      return true;\n', '    }\n', '\n', '    return  proposal.digest == sha3(proposer, proposal.amount, transactionBytecode) &&\n', '            isProposalNotExpired(type_, proposalId) &&\n', '            div(mul(100, confirmedTotalToken(type_, proposalId)), _storage.totalSupply()) > confirmTotalTokenThreshold;\n', '  }\n', '\n', '  function numberOfProposals(bytes32 type_) constant returns (uint) {\n', '    return proposals[type_].length;\n', '  }\n', '\n', '  function numberOfActiveProposals(bytes32 type_) constant returns (uint) {\n', '    uint numActiveProposal = 0;\n', '\n', '    for(uint i = 0; i < proposals[type_].length; i++) {\n', '      Proposal proposal = proposals[type_][i];\n', '\n', '      if (isProposalNotExpired(type_, i)) {\n', '        numActiveProposal++;\n', '      }\n', '    }\n', '\n', '    return numActiveProposal;\n', '  }\n', '\n', '  function isProposalNotExpired(bytes32 type_, uint proposalId) internal returns (bool) {\n', '    Proposal proposal = proposals[type_][proposalId];\n', '\n', '    return  !proposal.executed &&\n', '            now < proposal.expireAt;\n', '  }\n', '\n', '  function executeMintProposal(uint proposalId) internal {\n', "    Proposal proposal = proposals[sha3('mint')][proposalId];\n", '\n', '    \n', '    if (proposal.amount <= 0) throw;\n', '\n', '    MintExecuted(proposalId, proposal.proposer, proposal.amount);\n', '\n', '    \n', '    _storage.addTotalSupply(proposal.amount);\n', '    _storage.addCoinBalance(proposal.proposer, proposal.amount);\n', '    _storage.addTokenBalance(proposal.proposer, proposal.amount);\n', '  }\n', '\n', '  function executeBurnProposal(uint proposalId) internal {\n', "    Proposal proposal = proposals[sha3('burn')][proposalId];\n", '\n', '    \n', '    if (proposal.amount <= 0) throw;\n', '    if (_storage.coinBalance(proposal.proposer) < proposal.amount) throw;\n', '    if (_storage.tokenBalance(proposal.proposer) < proposal.amount) throw;\n', '\n', '    BurnExecuted(proposalId, proposal.proposer, proposal.amount);\n', '\n', '    \n', '    _storage.subTotalSupply(proposal.amount);\n', '    _storage.subCoinBalance(proposal.proposer, proposal.amount);\n', '    _storage.subTokenBalance(proposal.proposer, proposal.amount);\n', '  }\n', '\n', '  function executeUpdateTransferMinimumFeeProposal(uint proposalId) internal {\n', "    Proposal proposal = proposals[sha3('transferMinimumFee')][proposalId];\n", '\n', '    if (proposal.transferMinimumFee < 0) throw;\n', '\n', '    TransferMinimumFeeExecuted(proposalId, proposal.proposer, proposal.transferMinimumFee);\n', '\n', '    _storage.setTransferMinimumFee(proposal.transferMinimumFee);\n', '  }\n', '\n', '  function executeUpdateTransferFeeRateProposal(uint proposalId) internal {\n', "    Proposal proposal = proposals[sha3('transferFeeRate')][proposalId];\n", '\n', '    if (proposal.transferFeeRate < 0) throw;\n', '\n', '    TransferFeeRateExecuted(proposalId, proposal.proposer, proposal.transferFeeRate);\n', '\n', '    _storage.setTransferFeeRate(proposal.transferFeeRate);\n', '  }\n', '\n', '  function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n', '    sig; \n', '\n', '    return  src == address(this) ||\n', '            src == owner ||\n', '            src == address(_token);\n', '  }\n', '}\n', 'library ProposalLibrary {\n', '  \n', '  \n', '  \n', '\n', '  \n', '  struct Entity {\n', '    IkuraStorage _storage;\n', '    IkuraAssociation _association;\n', '  }\n', '\n', '  function changeStorage(Entity storage self, address storage_) internal {\n', '    self._storage = IkuraStorage(storage_);\n', '  }\n', '\n', '  function changeAssociation(Entity storage self, address association_) internal {\n', '    self._association = IkuraAssociation(association_);\n', '  }\n', '\n', '  function updateTransferMinimumFee(Entity storage self, address sender, uint8 fee) returns (bool) {\n', '    if (fee < 0) throw;\n', '\n', "    self._association.newProposal(sha3('transferMinimumFee'), sender, 0, fee, 0, '');\n", '\n', '    return true;\n', '  }\n', '\n', '  function updateTransferFeeRate(Entity storage self, address sender, uint rate) returns (bool) {\n', '    if (rate < 0) throw;\n', '\n', "    self._association.newProposal(sha3('transferFeeRate'), sender, 0, 0, rate, '');\n", '\n', '    return true;\n', '  }\n', '\n', '  function mint(Entity storage self, address sender, uint amount) returns (bool) {\n', '    if (amount <= 0) throw;\n', '\n', "    self._association.newProposal(sha3('mint'), sender, amount, 0, 0, '');\n", '\n', '    return true;\n', '  }\n', '\n', '  function burn(Entity storage self, address sender, uint amount) returns (bool) {\n', '    if (amount <= 0) throw;\n', '    if (self._storage.coinBalance(sender) < amount) throw;\n', '    if (self._storage.tokenBalance(sender) < amount) throw;\n', '\n', "    self._association.newProposal(sha3('burn'), sender, amount, 0, 0, '');\n", '\n', '    return true;\n', '  }\n', '\n', '  function confirmProposal(Entity storage self, address sender, bytes32 type_, uint proposalId) {\n', '    self._association.confirmProposal(type_, sender, proposalId);\n', '  }\n', '\n', '  function numberOfProposals(Entity storage self, bytes32 type_) constant returns (uint) {\n', '    return self._association.numberOfProposals(type_);\n', '  }\n', '}\n', '\n', 'contract IkuraToken is IkuraTokenEvent, DSMath, DSAuth {\n', '  \n', '  \n', '  \n', '\n', '  /*using ProposalLibrary for ProposalLibrary.Entity;\n', '  ProposalLibrary.Entity proposalEntity;*/\n', '\n', '  \n', '  \n', '  \n', '\n', '  \n', '  IkuraStorage _storage;\n', '  IkuraAssociation _association;\n', '\n', '  function IkuraToken() DSAuth() {\n', '    \n', '    \n', '    \n', '    /*address controllerAddress = 0x34c5605A4Ef1C98575DB6542179E55eE1f77A188;\n', '    owner = controllerAddress;\n', '    LogSetOwner(controllerAddress);*/\n', '  }\n', '\n', '  function totalSupply(address sender) auth constant returns (uint) {\n', '    sender; \n', '\n', '    return _storage.totalSupply();\n', '  }\n', '\n', '  function balanceOf(address sender, address addr) auth constant returns (uint) {\n', '    sender; \n', '\n', '    return _storage.coinBalance(addr);\n', '  }\n', '\n', '  function transfer(address sender, address to, uint amount) auth returns (bool success) {\n', '    uint fee = transferFee(sender, sender, to, amount);\n', '\n', '    if (_storage.coinBalance(sender) < add(amount, fee)) throw;\n', '    if (amount <= 0) throw;\n', '\n', '    \n', '    address owner = selectOwnerAddressForTransactionFee(sender);\n', '\n', '    \n', '    _storage.subCoinBalance(sender, add(amount, fee));\n', '\n', '    \n', '    _storage.addCoinBalance(to, amount);\n', '\n', '    \n', '    _storage.addCoinBalance(owner, fee);\n', '\n', '    \n', '    IkuraTransfer(sender, to, amount);\n', '    IkuraTransferFee(sender, to, owner, fee);\n', '\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address sender, address from, address to, uint amount) auth returns (bool success) {\n', '    uint fee = transferFee(sender, from, to, amount);\n', '\n', '    if (_storage.coinBalance(from) < amount) throw;\n', '    if (_storage.coinAllowance(from, sender) < amount) throw;\n', '    if (amount <= 0) throw;\n', '    if (add(_storage.coinBalance(to), amount) <= _storage.coinBalance(to)) throw;\n', '    if (_storage.coinBalance(sender) < fee) throw;\n', '\n', '    \n', '    address owner = selectOwnerAddressForTransactionFee(sender);\n', '\n', '    \n', '    _storage.subCoinBalance(sender, fee);\n', '\n', '    \n', '    _storage.subCoinBalance(from, amount);\n', '\n', '    \n', '    _storage.subCoinAllowance(from, sender, amount);\n', '\n', '    \n', '    _storage.addCoinBalance(to, amount);\n', '\n', '    \n', '    _storage.addCoinBalance(owner, fee);\n', '\n', '    \n', '    IkuraTransfer(from, to, amount);\n', '\n', '    return true;\n', '  }\n', '\n', '  function approve(address sender, address spender, uint amount) auth returns (bool success) {\n', '    _storage.setCoinAllowance(sender, spender, amount);\n', '\n', '    \n', '    IkuraApproval(sender, spender, amount);\n', '\n', '    return true;\n', '  }\n', '\n', '\n', '  function allowance(address sender, address owner, address spender) auth constant returns (uint remaining) {\n', '    sender; \n', '\n', '    return _storage.coinAllowance(owner, spender);\n', '  }\n', '\n', '  \n', '  \n', '  \n', '\n', '\n', '  function tokenBalanceOf(address sender, address owner) auth constant returns (uint balance) {\n', '    sender; \n', '\n', '    return _storage.tokenBalance(owner);\n', '  }\n', '\n', '\n', '  function transferToken(address sender, address to, uint amount) auth returns (bool success) {\n', '    if (_storage.tokenBalance(sender) < amount ) throw;\n', '    if (amount <= 0) throw;\n', '    if (add(_storage.tokenBalance(to), amount) <= _storage.tokenBalance(to)) throw;\n', '\n', '    _storage.subTokenBalance(sender, amount);\n', '    _storage.addTokenBalance(to, amount);\n', '\n', '    IkuraTransferToken(sender, to, amount);\n', '\n', '    return true;\n', '  }\n', '\n', '\n', '  function transferFeeRate(address sender) auth constant returns (uint) {\n', '    sender; \n', '\n', '    return _storage.transferFeeRate();\n', '  }\n', '\n', '\n', '  function transferMinimumFee(address sender) auth constant returns (uint8) {\n', '    sender; \n', '\n', '    return _storage.transferMinimumFee();\n', '  }\n', '\n', '\n', '  function transferFee(address sender, address from, address to, uint amount) auth returns (uint) {\n', '    from; to; \n', '\n', '    uint rate = transferFeeRate(sender);\n', '    uint denominator = 1000000; \n', '    uint numerator = mul(amount, rate);\n', '\n', '    uint fee = div(numerator, denominator);\n', '    uint remainder = sub(numerator, mul(denominator, fee));\n', '\n', '    \n', '    if (remainder > 0) {\n', '      fee++;\n', '    }\n', '\n', '    if (fee < transferMinimumFee(sender)) {\n', '      fee = transferMinimumFee(sender);\n', '    }\n', '\n', '    return fee;\n', '  }\n', '\n', '\n', '  function updateTransferMinimumFee(address sender, uint8 fee) auth returns (bool) {\n', '    if (fee < 0) throw;\n', '\n', "    _association.newProposal(sha3('transferMinimumFee'), sender, 0, fee, 0, '');\n", '    return true;\n', '\n', '    /*return proposalEntity.updateTransferMinimumFee(sender, fee);*/\n', '  }\n', '\n', '\n', '  function updateTransferFeeRate(address sender, uint rate) auth returns (bool) {\n', '    if (rate < 0) throw;\n', '\n', "    _association.newProposal(sha3('transferFeeRate'), sender, 0, 0, rate, '');\n", '    return true;\n', '\n', '    /*return proposalEntity.updateTransferFeeRate(sender, rate);*/\n', '  }\n', '\n', '\n', '  function selectOwnerAddressForTransactionFee(address sender) auth returns (address) {\n', '    sender; \n', '\n', '    return _storage.primaryOwner();\n', '  }\n', '\n', '  function mint(address sender, uint amount) auth returns (bool) {\n', '    if (amount <= 0) throw;\n', '\n', "    _association.newProposal(sha3('mint'), sender, amount, 0, 0, '');\n", '\n', '    /*return proposalEntity.mint(sender, amount);*/\n', '  }\n', '\n', '\n', '  function burn(address sender, uint amount) auth returns (bool) {\n', '    if (amount <= 0) throw;\n', '    if (_storage.coinBalance(sender) < amount) throw;\n', '    if (_storage.tokenBalance(sender) < amount) throw;\n', '\n', "    _association.newProposal(sha3('burn'), sender, amount, 0, 0, '');\n", '    /*return proposalEntity.burn(sender, amount);*/\n', '  }\n', '\n', '  function confirmProposal(address sender, bytes32 type_, uint proposalId) auth {\n', '    _association.confirmProposal(type_, sender, proposalId);\n', '    /*proposalEntity.confirmProposal(sender, type_, proposalId);*/\n', '  }\n', '\n', '\n', '  function numberOfProposals(bytes32 type_) constant returns (uint) {\n', '    return _association.numberOfProposals(type_);\n', '    /*return proposalEntity.numberOfProposals(type_);*/\n', '  }\n', '\n', '\n', '  function changeAssociation(address association_) auth returns (bool) {\n', '    _association = IkuraAssociation(association_);\n', '    /*proposalEntity.changeAssociation(_association);*/\n', '\n', '    return true;\n', '  }\n', '\n', '\n', '  function changeStorage(address storage_) auth returns (bool) {\n', '    _storage = IkuraStorage(storage_);\n', '    /*proposalEntity.changeStorage(_storage);*/\n', '\n', '    return true;\n', '  }\n', '\n', '\n', '  function logicVersion(address sender) auth constant returns (uint) {\n', '    sender; \n', '\n', '    return 1;\n', '  }\n', '}\n', '\n', '\n', 'contract IkuraAuthority is DSAuthority, DSAuth {\n', '  \n', '  IkuraStorage tokenStorage;\n', '\n', '  \n', '  \n', '  mapping(bytes4 => bool) actionsWithToken;\n', '\n', '  \n', '  mapping(bytes4 => bool) actionsForbidden;\n', '\n', '  \n', '  \n', '  \n', '  function IkuraAuthority() DSAuth() {\n', '    /*address controllerAddress = 0x34c5605A4Ef1C98575DB6542179E55eE1f77A188;\n', '    owner = controllerAddress;\n', '    LogSetOwner(controllerAddress);*/\n', '  }\n', '\n', '\n', '  function changeStorage(address storage_) auth {\n', '    tokenStorage = IkuraStorage(storage_);\n', '\n', '    \n', "    actionsWithToken[stringToSig('mint(uint256)')] = true;\n", "    actionsWithToken[stringToSig('burn(uint256)')] = true;\n", "    actionsWithToken[stringToSig('updateTransferMinimumFee(uint8)')] = true;\n", "    actionsWithToken[stringToSig('updateTransferFeeRate(uint256)')] = true;\n", "    actionsWithToken[stringToSig('confirmProposal(string, uint256)')] = true;\n", "    actionsWithToken[stringToSig('numberOfProposals(string)')] = true;\n", '\n', '    \n', "    actionsForbidden[stringToSig('forbiddenAction()')] = true;\n", '  }\n', '\n', '  function canCall(address src, address dst, bytes4 sig) constant returns (bool) {\n', '    \n', '    if (actionsWithToken[sig]) return canCallWithAssociation(src, dst);\n', '\n', '    \n', '    if (actionsForbidden[sig]) return canCallWithNoOne();\n', '\n', '    \n', '    return canCallDefault(src);\n', '  }\n', '\n', '  function canCallDefault(address src) internal constant returns (bool) {\n', '    return tokenStorage.isOwnerAddress(src);\n', '  }\n', '\n', '\n', '  function canCallWithAssociation(address src, address dst) internal returns (bool) {\n', '    \n', '    dst;\n', '\n', '    return tokenStorage.isOwnerAddress(src) &&\n', '           (tokenStorage.numOwnerAddress() == 1 || tokenStorage.tokenBalance(src) > 0);\n', '  }\n', '\n', '\n', '  function canCallWithNoOne() internal constant returns (bool) {\n', '    return false;\n', '  }\n', '\n', '\n', '  function stringToSig(string str) internal constant returns (bytes4) {\n', '    return bytes4(sha3(str));\n', '  }\n', '}\n', '\n', '\n', 'contract IkuraController is ERC20, DSAuth {\n', '  \n', '  \n', '  \n', '\n', '  \n', '  string public name = "XJP 0.6.0";\n', '\n', '  \n', '  string public constant symbol = "XJP";\n', '\n', '  \n', '  uint8 public constant decimals = 0;\n', '\n', '  \n', '  \n', '  \n', '\n', '  \n', '  \n', '  IkuraToken private token;\n', '\n', '  \n', '  IkuraStorage private tokenStorage;\n', '\n', '  \n', '  IkuraAuthority private authority;\n', '\n', '  \n', '  IkuraAssociation private association;\n', '\n', '  \n', '  \n', '  \n', '\n', '  function totalSupply() constant returns (uint) {\n', '    return token.totalSupply(msg.sender);\n', '  }\n', '\n', '  function balanceOf(address addr) constant returns (uint) {\n', '    return token.balanceOf(msg.sender, addr);\n', '  }\n', '\n', '  function transfer(address to, uint amount) returns (bool) {\n', '    if (token.transfer(msg.sender, to, amount)) {\n', '      Transfer(msg.sender, to, amount);\n', '\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function transferFrom(address from, address to, uint amount) returns (bool) {\n', '    if (token.transferFrom(msg.sender, from, to, amount)) {\n', '      Transfer(from, to, amount);\n', '\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function approve(address spender, uint amount) returns (bool) {\n', '    if (token.approve(msg.sender, spender, amount)) {\n', '      Approval(msg.sender, spender, amount);\n', '\n', '      return true;\n', '    } else {\n', '      return false;\n', '    }\n', '  }\n', '\n', '  function allowance(address addr, address spender) constant returns (uint) {\n', '    return token.allowance(msg.sender, addr, spender);\n', '  }\n', '\n', '  \n', '  \n', '  \n', '\n', '  function tokenBalanceOf(address addr) constant returns (uint) {\n', '    return token.tokenBalanceOf(msg.sender, addr);\n', '  }\n', '\n', '  function transferToken(address to, uint amount) returns (bool) {\n', '    return token.transferToken(msg.sender, to, amount);\n', '  }\n', '\n', '  function transferFeeRate() constant returns (uint) {\n', '    return token.transferFeeRate(msg.sender);\n', '  }\n', '\n', '  function transferMinimumFee() constant returns (uint8) {\n', '    return token.transferMinimumFee(msg.sender);\n', '  }\n', '\n', '  function transferFee(address from, address to, uint amount) returns (uint) {\n', '    return token.transferFee(msg.sender, from, to, amount);\n', '  }\n', '\n', '  \n', '\n', '  function updateTransferMinimumFee(uint8 minimumFee) auth returns (bool) {\n', '    return token.updateTransferMinimumFee(msg.sender, minimumFee);\n', '  }\n', '\n', '  function updateTransferFeeRate(uint feeRate) auth returns (bool) {\n', '    return token.updateTransferFeeRate(msg.sender, feeRate);\n', '  }\n', '\n', '  function mint(uint amount) auth returns (bool) {\n', '    return token.mint(msg.sender, amount);\n', '  }\n', '\n', '  function burn(uint amount) auth returns (bool) {\n', '    return token.burn(msg.sender, amount);\n', '  }\n', '\n', '  function isOwner(address addr) auth returns (bool) {\n', '    return tokenStorage.isOwnerAddress(addr);\n', '  }\n', '\n', '\n', '  function confirmProposal(string type_, uint proposalId) auth {\n', '    token.confirmProposal(msg.sender, sha3(type_), proposalId);\n', '  }\n', '\n', '  function numOwnerAddress() auth constant returns (uint) {\n', '    return tokenStorage.numOwnerAddress();\n', '  }\n', '\n', '\n', '  function numberOfProposals(string type_) auth constant returns (uint) {\n', '    return token.numberOfProposals(sha3(type_));\n', '  }\n', '\n', '  \n', '  \n', '  \n', '\n', '\n', '  function setup(address storageAddress, address tokenAddress, address authorityAddress, address associationAddress) auth {\n', '    changeStorage(storageAddress);\n', '    changeToken(tokenAddress);\n', '    changeAuthority(authorityAddress);\n', '    changeAssociation(associationAddress);\n', '  }\n', '\n', '\n', '  function changeToken(address tokenAddress) auth {\n', '    \n', '    token = IkuraToken(tokenAddress);\n', '\n', '    \n', '    tokenStorage.changeToken(token);\n', '    token.changeStorage(tokenStorage);\n', '\n', '    \n', '    if (association != address(0)) {\n', '      association.changeToken(token);\n', '      token.changeAssociation(association);\n', '    }\n', '  }\n', '\n', '  function changeStorage(address storageAddress) auth {\n', '    \n', '    tokenStorage = IkuraStorage(storageAddress);\n', '  }\n', '\n', '\n', '  function changeAuthority(address authorityAddress) auth {\n', '    \n', '    authority = IkuraAuthority(authorityAddress);\n', '    setAuthority(authority);\n', '\n', '    \n', '    authority.changeStorage(tokenStorage);\n', '    tokenStorage.changeAuthority(authority);\n', '  }\n', '\n', '  function changeAssociation(address associationAddress) auth {\n', '    \n', '    association = IkuraAssociation(associationAddress);\n', '\n', '    \n', '    association.changeStorage(tokenStorage);\n', '    tokenStorage.changeAssociation(association);\n', '\n', '    \n', '    if (token != address(0)) {\n', '      association.changeToken(token);\n', '      token.changeAssociation(association);\n', '    }\n', '  }\n', '\n', '\n', '  function forbiddenAction() auth returns (bool) {\n', '    return true;\n', '  }\n', '\n', ' \n', '  function logicVersion() constant returns (uint) {\n', '    return token.logicVersion(msg.sender);\n', '  }\n', '\n', '\n', '  function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n', '    return  src == address(this) ||\n', '            src == owner ||\n', '            authority.canCall(src, this, sig);\n', '  }\n', '}']