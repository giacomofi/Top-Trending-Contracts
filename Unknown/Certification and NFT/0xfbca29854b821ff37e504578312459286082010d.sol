['pragma solidity ^0.4.11;\n', '\n', '/*  Copyright 2017 GoInto, LLC\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '        http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', '/**\n', ' * Storage contract for Etherep to store ratings and score data.  It&#39;s been \n', ' * separated from the main contract because this is much less likely to change\n', ' * than the other parts.  It would allow for upgrading the main contract without\n', ' * losing data.\n', ' */\n', 'contract RatingStore {\n', '\n', '    struct Score {\n', '        bool exists;\n', '        int cumulativeScore;\n', '        uint totalRatings;\n', '    }\n', '\n', '    bool internal debug;\n', '    mapping (address => Score) internal scores;\n', '    // The manager with full access\n', '    address internal manager;\n', '    // The contract that has write accees\n', '    address internal controller;\n', '\n', '    /// Events\n', '    event Debug(string message);\n', '\n', '    /**\n', '     * Only the manager or controller can use this method\n', '     */\n', '    modifier restricted() { \n', '        require(msg.sender == manager || tx.origin == manager || msg.sender == controller);\n', '        _; \n', '    }\n', '\n', '    /**\n', '     * Only a certain address can use this modified method\n', '     * @param by The address that can use the method\n', '     */\n', '    modifier onlyBy(address by) { \n', '        require(msg.sender == by);\n', '        _; \n', '    }\n', '\n', '    /**\n', '     * Constructor\n', '     * @param _manager The address that has full access to the contract\n', '     * @param _controller The contract that can make write calls to this contract\n', '     */\n', '    function RatingStore(address _manager, address _controller) {\n', '        manager = _manager;\n', '        controller = _controller;\n', '        debug = false;\n', '    }\n', '\n', '    /**\n', '     * Set a Score\n', '     * @param target The address&#39; score we&#39;re setting\n', '     * @param cumulative The cumulative score for the address\n', '     * @param total Total individual ratings for the address\n', '     * @return success If the set was completed successfully\n', '     */\n', '    function set(address target, int cumulative, uint total) external restricted {\n', '        if (!scores[target].exists) {\n', '            scores[target] = Score(true, 0, 0);\n', '        }\n', '        scores[target].cumulativeScore = cumulative;\n', '        scores[target].totalRatings = total;\n', '    }\n', '\n', '    /**\n', '     * Add a rating\n', '     * @param target The address&#39; score we&#39;re adding to\n', '     * @param wScore The weighted rating to add to the score\n', '     * @return success\n', '     */\n', '    function add(address target, int wScore) external restricted {\n', '        if (!scores[target].exists) {\n', '            scores[target] = Score(true, 0, 0);\n', '        }\n', '        scores[target].cumulativeScore += wScore;\n', '        scores[target].totalRatings += 1;\n', '    }\n', '\n', '    /**\n', '     * Get the score for an address\n', '     * @param target The address&#39; score to return\n', '     * @return cumulative score\n', '     * @return total ratings\n', '     */\n', '    function get(address target) external constant returns (int, uint) {\n', '        if (scores[target].exists == true) {\n', '            return (scores[target].cumulativeScore, scores[target].totalRatings);\n', '        } else {\n', '            return (0,0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Reset an entire score storage\n', '     * @param target The address we&#39;re wiping clean\n', '     */\n', '    function reset(address target) external onlyBy(manager) {\n', '        scores[target] = Score(true, 0,0);\n', '    }\n', '\n', '    /**\n', '     * Return the manager\n', '     * @return address The manager address\n', '     */\n', '    function getManager() external constant returns (address) {\n', '        return manager;\n', '    }\n', '\n', '    /**\n', '     * Change the manager\n', '     * @param newManager The address we&#39;re setting as manager\n', '     */\n', '    function setManager(address newManager) external onlyBy(manager) {\n', '        manager = newManager;\n', '    }\n', '\n', '    /**\n', '     * Return the controller\n', '     * @return address The manager address\n', '     */\n', '    function getController() external constant returns (address) {\n', '        return controller;\n', '    }\n', '\n', '    /**\n', '     * Change the controller\n', '     * @param newController The address we&#39;re setting as controller\n', '     */\n', '    function setController(address newController) external onlyBy(manager) {\n', '        controller = newController;\n', '    }\n', '\n', '    /**\n', '     * Return the debug setting\n', '     * @return bool debug\n', '     */\n', '    function getDebug() external constant returns (bool) {\n', '        return debug;\n', '    }\n', '\n', '    /**\n', '     * Set debug\n', '     * @param _debug The bool value debug should be set to\n', '     */\n', '    function setDebug(bool _debug) external onlyBy(manager) {\n', '        debug = _debug;\n', '    }\n', '\n', '}\n', '\n', '/** Ethereum Reputation\n', '\n', '    Contract that takes ratings and calculates a reputation score\n', ' */\n', 'contract Etherep {\n', '\n', '    bool internal debug;\n', '    address internal manager;\n', '    uint internal fee;\n', '    address internal storageAddress;\n', '    uint internal waitTime;\n', '    mapping (address => uint) internal lastRating;\n', '\n', '    /// Events\n', '    event Error(\n', '        address sender,\n', '        string message\n', '    );\n', '    event Debug(string message);\n', '    event DebugInt(int message);\n', '    event DebugUint(uint message);\n', '    event Rating(\n', '        address by, \n', '        address who, \n', '        int rating\n', '    );\n', '    event FeeChanged(uint f);\n', '    event DelayChanged(uint d);\n', '\n', '    /**\n', '     * Only a certain address can use this modified method\n', '     * @param by The address that can use the method\n', '     */\n', '    modifier onlyBy(address by) { \n', '        require(msg.sender == by);\n', '        _; \n', '    }\n', '\n', '    /**\n', '     * Delay ratings to be at least waitTime apart\n', '     */\n', '    modifier delay() {\n', '        if (debug == false && lastRating[msg.sender] > now - waitTime) {\n', '            Error(msg.sender, "Rating too often");\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Require the minimum fee to be met\n', '     */\n', '    modifier requireFee() {\n', '        require(msg.value >= fee);\n', '        _;\n', '    }\n', '\n', '    /** \n', '     * Constructor\n', '     * @param _manager The key that can make changes to this contract\n', '     * @param _fee The variable fee that will be charged per rating\n', '     * @param _storageAddress The address to the storage contract\n', '     * @param _wait The minimum time in seconds a user has to wait between ratings\n', '     */\n', '    function Etherep(address _manager, uint _fee, address _storageAddress, uint _wait) {\n', '        manager = _manager;\n', '        fee = _fee;\n', '        storageAddress = _storageAddress;\n', '        waitTime = _wait;\n', '        debug = false;\n', '    }\n', '\n', '    /**\n', '     * Set debug\n', '     * @param d The debug value that should be set\n', '     */\n', '    function setDebug(bool d) external onlyBy(manager) {\n', '        debug = d;\n', '    }\n', '\n', '    /**\n', '     * Get debug\n', '     * @return debug\n', '     */\n', '    function getDebug() external constant returns (bool) {\n', '        return debug;\n', '    }\n', '\n', '    /**\n', '     * Change the fee\n', '     * @param newFee New rating fee in Wei\n', '     */\n', '    function setFee(uint newFee) external onlyBy(manager) {\n', '        fee = newFee;\n', '        FeeChanged(fee);\n', '    }\n', '\n', '    /**\n', '     * Get the fee\n', '     * @return fee The current fee in Wei\n', '     */\n', '    function getFee() external constant returns (uint) {\n', '        return fee;\n', '    }\n', '\n', '    /**\n', '     * Change the rating delay\n', '     * @param _delay Delay in seconds\n', '     */\n', '    function setDelay(uint _delay) external onlyBy(manager) {\n', '        waitTime = _delay;\n', '        DelayChanged(waitTime);\n', '    }\n', '\n', '    /**\n', '     * Get the delay time\n', '     * @return delay The current rating delay time in seconds\n', '     */\n', '    function getDelay() external constant returns (uint) {\n', '        return waitTime;\n', '    }\n', '\n', '    /**\n', '     * Change the manager\n', '     * @param who The address of the new manager\n', '     */\n', '    function setManager(address who) external onlyBy(manager) {\n', '        manager = who;\n', '    }\n', '\n', '    /**\n', '     * Get the manager\n', '     * @return manager The address of this contract&#39;s manager\n', '     */\n', '    function getManager() external constant returns (address) {\n', '        return manager;\n', '    }\n', '\n', '    /**\n', '     * Drain fees\n', '     */\n', '    function drain() external onlyBy(manager) {\n', '        require(this.balance > 0);\n', '        manager.transfer(this.balance);\n', '    }\n', '\n', '    /** \n', '     * Adds a rating to an address&#39; cumulative score\n', '     * @param who The address that is being rated\n', '     * @param rating The rating(-5 to 5)\n', '     * @return success If the rating was processed successfully\n', '     */\n', '    function rate(address who, int rating) external payable delay requireFee {\n', '\n', '        require(rating <= 5 && rating >= -5);\n', '        require(who != msg.sender);\n', '\n', '        RatingStore store = RatingStore(storageAddress);\n', '        \n', '        // Starting weight\n', '        int weight = 0;\n', '\n', '        // Rating multiplier\n', '        int multiplier = 100;\n', '\n', '        // We need the absolute value\n', '        int absRating = rating;\n', '        if (absRating < 0) {\n', '            absRating = -rating;\n', '        }\n', '\n', '        // Get details on sender if available\n', '        int senderScore;\n', '        uint senderRatings;\n', '        int senderCumulative = 0;\n', '        (senderScore, senderRatings) = store.get(msg.sender);\n', '\n', '        // Calculate cumulative score if available\n', '        if (senderScore != 0) {\n', '            senderCumulative = (senderScore / (int(senderRatings) * 100)) * 100;\n', '        }\n', '\n', '        // Calculate the weight if the sender is rated above 0\n', '        if (senderCumulative > 0) {\n', '            weight = (((senderCumulative / 5) * absRating) / 10) + multiplier;\n', '        }\n', '        // Otherwise, unweighted\n', '        else {\n', '            weight = multiplier;\n', '        }\n', '        \n', '        // Calculate weighted rating\n', '        int workRating = rating * weight;\n', '\n', '        // Set last rating timestamp\n', '        lastRating[msg.sender] = now;\n', '\n', '        Rating(msg.sender, who, workRating);\n', '\n', '        // Add the new rating to their score\n', '        store.add(who, workRating);\n', '\n', '    }\n', '\n', '    /**\n', '     * Returns the cumulative score for an address\n', '     * @param who The address to lookup\n', '     * @return score The cumulative score\n', '     */\n', '    function getScore(address who) external constant returns (int score) {\n', '\n', '        RatingStore store = RatingStore(storageAddress);\n', '        \n', '        int cumulative;\n', '        uint ratings;\n', '        (cumulative, ratings) = store.get(who);\n', '        \n', '        // The score should have room for 2 decimal places, but ratings is a \n', '        // single count\n', '        score = cumulative / int(ratings);\n', '\n', '    }\n', '\n', '    /**\n', '     * Returns the cumulative score and count of ratings for an address\n', '     * @param who The address to lookup\n', '     * @return score The cumulative score\n', '     * @return count How many ratings have been made\n', '     */\n', '    function getScoreAndCount(address who) external constant returns (int score, uint ratings) {\n', '\n', '        RatingStore store = RatingStore(storageAddress);\n', '        \n', '        int cumulative;\n', '        (cumulative, ratings) = store.get(who);\n', '        \n', '        // The score should have room for 2 decimal places, but ratings is a \n', '        // single count\n', '        score = cumulative / int(ratings);\n', '\n', '    }\n', '\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '/*  Copyright 2017 GoInto, LLC\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '        http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', '/**\n', " * Storage contract for Etherep to store ratings and score data.  It's been \n", ' * separated from the main contract because this is much less likely to change\n', ' * than the other parts.  It would allow for upgrading the main contract without\n', ' * losing data.\n', ' */\n', 'contract RatingStore {\n', '\n', '    struct Score {\n', '        bool exists;\n', '        int cumulativeScore;\n', '        uint totalRatings;\n', '    }\n', '\n', '    bool internal debug;\n', '    mapping (address => Score) internal scores;\n', '    // The manager with full access\n', '    address internal manager;\n', '    // The contract that has write accees\n', '    address internal controller;\n', '\n', '    /// Events\n', '    event Debug(string message);\n', '\n', '    /**\n', '     * Only the manager or controller can use this method\n', '     */\n', '    modifier restricted() { \n', '        require(msg.sender == manager || tx.origin == manager || msg.sender == controller);\n', '        _; \n', '    }\n', '\n', '    /**\n', '     * Only a certain address can use this modified method\n', '     * @param by The address that can use the method\n', '     */\n', '    modifier onlyBy(address by) { \n', '        require(msg.sender == by);\n', '        _; \n', '    }\n', '\n', '    /**\n', '     * Constructor\n', '     * @param _manager The address that has full access to the contract\n', '     * @param _controller The contract that can make write calls to this contract\n', '     */\n', '    function RatingStore(address _manager, address _controller) {\n', '        manager = _manager;\n', '        controller = _controller;\n', '        debug = false;\n', '    }\n', '\n', '    /**\n', '     * Set a Score\n', "     * @param target The address' score we're setting\n", '     * @param cumulative The cumulative score for the address\n', '     * @param total Total individual ratings for the address\n', '     * @return success If the set was completed successfully\n', '     */\n', '    function set(address target, int cumulative, uint total) external restricted {\n', '        if (!scores[target].exists) {\n', '            scores[target] = Score(true, 0, 0);\n', '        }\n', '        scores[target].cumulativeScore = cumulative;\n', '        scores[target].totalRatings = total;\n', '    }\n', '\n', '    /**\n', '     * Add a rating\n', "     * @param target The address' score we're adding to\n", '     * @param wScore The weighted rating to add to the score\n', '     * @return success\n', '     */\n', '    function add(address target, int wScore) external restricted {\n', '        if (!scores[target].exists) {\n', '            scores[target] = Score(true, 0, 0);\n', '        }\n', '        scores[target].cumulativeScore += wScore;\n', '        scores[target].totalRatings += 1;\n', '    }\n', '\n', '    /**\n', '     * Get the score for an address\n', "     * @param target The address' score to return\n", '     * @return cumulative score\n', '     * @return total ratings\n', '     */\n', '    function get(address target) external constant returns (int, uint) {\n', '        if (scores[target].exists == true) {\n', '            return (scores[target].cumulativeScore, scores[target].totalRatings);\n', '        } else {\n', '            return (0,0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Reset an entire score storage\n', "     * @param target The address we're wiping clean\n", '     */\n', '    function reset(address target) external onlyBy(manager) {\n', '        scores[target] = Score(true, 0,0);\n', '    }\n', '\n', '    /**\n', '     * Return the manager\n', '     * @return address The manager address\n', '     */\n', '    function getManager() external constant returns (address) {\n', '        return manager;\n', '    }\n', '\n', '    /**\n', '     * Change the manager\n', "     * @param newManager The address we're setting as manager\n", '     */\n', '    function setManager(address newManager) external onlyBy(manager) {\n', '        manager = newManager;\n', '    }\n', '\n', '    /**\n', '     * Return the controller\n', '     * @return address The manager address\n', '     */\n', '    function getController() external constant returns (address) {\n', '        return controller;\n', '    }\n', '\n', '    /**\n', '     * Change the controller\n', "     * @param newController The address we're setting as controller\n", '     */\n', '    function setController(address newController) external onlyBy(manager) {\n', '        controller = newController;\n', '    }\n', '\n', '    /**\n', '     * Return the debug setting\n', '     * @return bool debug\n', '     */\n', '    function getDebug() external constant returns (bool) {\n', '        return debug;\n', '    }\n', '\n', '    /**\n', '     * Set debug\n', '     * @param _debug The bool value debug should be set to\n', '     */\n', '    function setDebug(bool _debug) external onlyBy(manager) {\n', '        debug = _debug;\n', '    }\n', '\n', '}\n', '\n', '/** Ethereum Reputation\n', '\n', '    Contract that takes ratings and calculates a reputation score\n', ' */\n', 'contract Etherep {\n', '\n', '    bool internal debug;\n', '    address internal manager;\n', '    uint internal fee;\n', '    address internal storageAddress;\n', '    uint internal waitTime;\n', '    mapping (address => uint) internal lastRating;\n', '\n', '    /// Events\n', '    event Error(\n', '        address sender,\n', '        string message\n', '    );\n', '    event Debug(string message);\n', '    event DebugInt(int message);\n', '    event DebugUint(uint message);\n', '    event Rating(\n', '        address by, \n', '        address who, \n', '        int rating\n', '    );\n', '    event FeeChanged(uint f);\n', '    event DelayChanged(uint d);\n', '\n', '    /**\n', '     * Only a certain address can use this modified method\n', '     * @param by The address that can use the method\n', '     */\n', '    modifier onlyBy(address by) { \n', '        require(msg.sender == by);\n', '        _; \n', '    }\n', '\n', '    /**\n', '     * Delay ratings to be at least waitTime apart\n', '     */\n', '    modifier delay() {\n', '        if (debug == false && lastRating[msg.sender] > now - waitTime) {\n', '            Error(msg.sender, "Rating too often");\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Require the minimum fee to be met\n', '     */\n', '    modifier requireFee() {\n', '        require(msg.value >= fee);\n', '        _;\n', '    }\n', '\n', '    /** \n', '     * Constructor\n', '     * @param _manager The key that can make changes to this contract\n', '     * @param _fee The variable fee that will be charged per rating\n', '     * @param _storageAddress The address to the storage contract\n', '     * @param _wait The minimum time in seconds a user has to wait between ratings\n', '     */\n', '    function Etherep(address _manager, uint _fee, address _storageAddress, uint _wait) {\n', '        manager = _manager;\n', '        fee = _fee;\n', '        storageAddress = _storageAddress;\n', '        waitTime = _wait;\n', '        debug = false;\n', '    }\n', '\n', '    /**\n', '     * Set debug\n', '     * @param d The debug value that should be set\n', '     */\n', '    function setDebug(bool d) external onlyBy(manager) {\n', '        debug = d;\n', '    }\n', '\n', '    /**\n', '     * Get debug\n', '     * @return debug\n', '     */\n', '    function getDebug() external constant returns (bool) {\n', '        return debug;\n', '    }\n', '\n', '    /**\n', '     * Change the fee\n', '     * @param newFee New rating fee in Wei\n', '     */\n', '    function setFee(uint newFee) external onlyBy(manager) {\n', '        fee = newFee;\n', '        FeeChanged(fee);\n', '    }\n', '\n', '    /**\n', '     * Get the fee\n', '     * @return fee The current fee in Wei\n', '     */\n', '    function getFee() external constant returns (uint) {\n', '        return fee;\n', '    }\n', '\n', '    /**\n', '     * Change the rating delay\n', '     * @param _delay Delay in seconds\n', '     */\n', '    function setDelay(uint _delay) external onlyBy(manager) {\n', '        waitTime = _delay;\n', '        DelayChanged(waitTime);\n', '    }\n', '\n', '    /**\n', '     * Get the delay time\n', '     * @return delay The current rating delay time in seconds\n', '     */\n', '    function getDelay() external constant returns (uint) {\n', '        return waitTime;\n', '    }\n', '\n', '    /**\n', '     * Change the manager\n', '     * @param who The address of the new manager\n', '     */\n', '    function setManager(address who) external onlyBy(manager) {\n', '        manager = who;\n', '    }\n', '\n', '    /**\n', '     * Get the manager\n', "     * @return manager The address of this contract's manager\n", '     */\n', '    function getManager() external constant returns (address) {\n', '        return manager;\n', '    }\n', '\n', '    /**\n', '     * Drain fees\n', '     */\n', '    function drain() external onlyBy(manager) {\n', '        require(this.balance > 0);\n', '        manager.transfer(this.balance);\n', '    }\n', '\n', '    /** \n', "     * Adds a rating to an address' cumulative score\n", '     * @param who The address that is being rated\n', '     * @param rating The rating(-5 to 5)\n', '     * @return success If the rating was processed successfully\n', '     */\n', '    function rate(address who, int rating) external payable delay requireFee {\n', '\n', '        require(rating <= 5 && rating >= -5);\n', '        require(who != msg.sender);\n', '\n', '        RatingStore store = RatingStore(storageAddress);\n', '        \n', '        // Starting weight\n', '        int weight = 0;\n', '\n', '        // Rating multiplier\n', '        int multiplier = 100;\n', '\n', '        // We need the absolute value\n', '        int absRating = rating;\n', '        if (absRating < 0) {\n', '            absRating = -rating;\n', '        }\n', '\n', '        // Get details on sender if available\n', '        int senderScore;\n', '        uint senderRatings;\n', '        int senderCumulative = 0;\n', '        (senderScore, senderRatings) = store.get(msg.sender);\n', '\n', '        // Calculate cumulative score if available\n', '        if (senderScore != 0) {\n', '            senderCumulative = (senderScore / (int(senderRatings) * 100)) * 100;\n', '        }\n', '\n', '        // Calculate the weight if the sender is rated above 0\n', '        if (senderCumulative > 0) {\n', '            weight = (((senderCumulative / 5) * absRating) / 10) + multiplier;\n', '        }\n', '        // Otherwise, unweighted\n', '        else {\n', '            weight = multiplier;\n', '        }\n', '        \n', '        // Calculate weighted rating\n', '        int workRating = rating * weight;\n', '\n', '        // Set last rating timestamp\n', '        lastRating[msg.sender] = now;\n', '\n', '        Rating(msg.sender, who, workRating);\n', '\n', '        // Add the new rating to their score\n', '        store.add(who, workRating);\n', '\n', '    }\n', '\n', '    /**\n', '     * Returns the cumulative score for an address\n', '     * @param who The address to lookup\n', '     * @return score The cumulative score\n', '     */\n', '    function getScore(address who) external constant returns (int score) {\n', '\n', '        RatingStore store = RatingStore(storageAddress);\n', '        \n', '        int cumulative;\n', '        uint ratings;\n', '        (cumulative, ratings) = store.get(who);\n', '        \n', '        // The score should have room for 2 decimal places, but ratings is a \n', '        // single count\n', '        score = cumulative / int(ratings);\n', '\n', '    }\n', '\n', '    /**\n', '     * Returns the cumulative score and count of ratings for an address\n', '     * @param who The address to lookup\n', '     * @return score The cumulative score\n', '     * @return count How many ratings have been made\n', '     */\n', '    function getScoreAndCount(address who) external constant returns (int score, uint ratings) {\n', '\n', '        RatingStore store = RatingStore(storageAddress);\n', '        \n', '        int cumulative;\n', '        (cumulative, ratings) = store.get(who);\n', '        \n', '        // The score should have room for 2 decimal places, but ratings is a \n', '        // single count\n', '        score = cumulative / int(ratings);\n', '\n', '    }\n', '\n', '}']
