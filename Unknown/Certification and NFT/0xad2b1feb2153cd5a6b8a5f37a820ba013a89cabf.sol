['pragma solidity 0.4.4;\n', '\n', 'contract Reward{\n', '    \n', '    function reward(uint32[] rewardsDistribution, address[] winners) payable{\n', '        \n', '        if(rewardsDistribution.length == 0 || rewardsDistribution.length > 64){ // do not risk gas shortage on reward\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t//ensure rewardsDistribution give always something and do not give more to a lower scoring player\n', '\t\tuint32 prev = 0;\n', '\t\tfor(uint8 i = 0; i < rewardsDistribution.length; i++){\n', '\t\t\tif(rewardsDistribution[i] == 0 ||  (prev != 0 && rewardsDistribution[i] > prev)){\n', '\t\t\t\tthrow;\n', '\t\t\t}\n', '\t\t\tprev = rewardsDistribution[i];\n', '\t\t}\n', '\t\t\n', '        uint8 numWinners = uint8(rewardsDistribution.length);\n', '\n', '\t\tif(numWinners > uint8(winners.length)){\n', '\t\t\tnumWinners = uint8(winners.length);\n', '\t\t}\n', '\t\t\n', '        uint forJack = msg.value;\n', '\t\tuint64 total = 0;\n', '\t\tfor(uint8 j=0; j<numWinners; j++){ // distribute all the winning even if there is not enought winners\n', '\t\t\ttotal += rewardsDistribution[j];\n', '\t\t}\n', '\t\tfor(uint8 k=0; k<numWinners; k++){\n', '\t\t\tuint value = (msg.value * rewardsDistribution[k]) / total;\n', '\t\t\tif(winners[k].send(value)){ // skip winner if fail to send but still use next distribution index\n', '\t\t\t\tforJack = forJack - value;\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\tif(forJack > 0){\n', '\t\t    if(!msg.sender.send(forJack)){\n', '\t\t        throw;\n', '\t\t    } \n', '\t\t}\n', '\t\t\n', '    }\n', '    \n', '}']