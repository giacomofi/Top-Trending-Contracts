['library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract IERC20Token {\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '  function approve(address _spender, uint256 _value) returns (bool success) {}\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', 'contract ItokenRecipient {\n', '  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\n', '}\n', 'contract IToken {\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '  function mintTokens(address _to, uint256 _amount) {}\n', '}\n', 'contract IMintableToken {\n', '  function mintTokens(address _to, uint256 _amount){}\n', '}\n', 'contract ReentrnacyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', 'contract Lockable is Owned{\n', '\n', '  uint256 public lockedUntilBlock;\n', '\n', '  event ContractLocked(uint256 _untilBlock, string _reason);\n', '\n', '  modifier lockAffected {\n', '      require(block.number > lockedUntilBlock);\n', '      _;\n', '  }\n', '\n', '  function lockFromSelf(uint256 _untilBlock, string _reason) internal {\n', '    lockedUntilBlock = _untilBlock;\n', '    ContractLocked(_untilBlock, _reason);\n', '  }\n', '\n', '\n', '  function lockUntil(uint256 _untilBlock, string _reason) onlyOwner {\n', '    lockedUntilBlock = _untilBlock;\n', '    ContractLocked(_untilBlock, _reason);\n', '  }\n', '}\n', '\n', 'contract Crowdsale is ReentrnacyHandlingContract, Owned{\n', '\n', '  struct ContributorData{\n', '    uint priorityPassAllowance;\n', '    bool isActive;\n', '    uint contributionAmount;\n', '    uint tokensIssued;\n', '  }\n', '\n', '  mapping(address => ContributorData) public contributorList;\n', '  uint nextContributorIndex;\n', '  mapping(uint => address) contributorIndexes;\n', '\n', '  state public crowdsaleState = state.pendingStart;\n', '  enum state { pendingStart, priorityPass, openedPriorityPass, crowdsale, crowdsaleEnded }\n', '\n', '  uint public presaleStartBlock;\n', '  uint public presaleUnlimitedStartBlock;\n', '  uint public crowdsaleStartBlock;\n', '  uint public crowdsaleEndedBlock;\n', '\n', '  event PresaleStarted(uint blockNumber);\n', '  event PresaleUnlimitedStarted(uint blockNumber);\n', '  event CrowdsaleStarted(uint blockNumber);\n', '  event CrowdsaleEnded(uint blockNumber);\n', '  event ErrorSendingETH(address to, uint amount);\n', '  event MinCapReached(uint blockNumber);\n', '  event MaxCapReached(uint blockNumber);\n', '\n', '  IToken token = IToken(0x0);\n', '  uint ethToTokenConversion;\n', '\n', '  uint public minCap;\n', '  uint public maxP1Cap;\n', '  uint public maxCap;\n', '  uint public ethRaised;\n', '\n', '  address public multisigAddress;\n', '\n', '  uint nextContributorToClaim;\n', '  mapping(address => bool) hasClaimedEthWhenFail;\n', '\n', '  uint maxTokenSupply;\n', '  bool ownerHasClaimedTokens;\n', '  uint cofounditReward;\n', '  address cofounditAddress;\n', '  address cofounditColdStorage;\n', '  bool cofounditHasClaimedTokens;\n', '\n', '  //\n', '  // Unnamed function that runs when eth is sent to the contract\n', '  //\n', '  function() noReentrancy payable{\n', '    require(msg.value != 0);                        // Throw if value is 0\n', '    require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\n', '\n', '    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\n', '\n', '    if (crowdsaleState == state.priorityPass){\n', '      if (contributorList[msg.sender].isActive){    // Check if contributor is in priorityPass\n', '        processTransaction(msg.sender, msg.value);  // Process transaction and issue tokens\n', '      }else{\n', '        refundTransaction(stateChanged);            // Set state and return funds or throw\n', '      }\n', '    }\n', '    else if(crowdsaleState == state.openedPriorityPass){\n', '      if (contributorList[msg.sender].isActive){    // Check if contributor is in priorityPass\n', '        processTransaction(msg.sender, msg.value);  // Process transaction and issue tokens\n', '      }else{\n', '        refundTransaction(stateChanged);            // Set state and return funds or throw\n', '      }\n', '    }\n', '    else if(crowdsaleState == state.crowdsale){\n', '      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\n', '    }\n', '    else{\n', '      refundTransaction(stateChanged);              // Set state and return funds or throw\n', '    }\n', '  }\n', '\n', '  //\n', '  // Check crowdsale state and calibrate it\n', '  //\n', '  function checkCrowdsaleState() internal returns (bool){\n', '    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded){                         // Check if max cap is reached\n', '      crowdsaleState = state.crowdsaleEnded;\n', '      MaxCapReached(block.number);                                                              // Close the crowdsale\n', '      CrowdsaleEnded(block.number);                                                             // Raise event\n', '      return true;\n', '    }\n', '\n', '    if (block.number > presaleStartBlock && block.number <= presaleUnlimitedStartBlock){  // Check if we are in presale phase\n', '      if (crowdsaleState != state.priorityPass){                                          // Check if state needs to be changed\n', '        crowdsaleState = state.priorityPass;                                              // Set new state\n', '        PresaleStarted(block.number);                                                     // Raise event\n', '        return true;\n', '      }\n', '    }else if(block.number > presaleUnlimitedStartBlock && block.number <= crowdsaleStartBlock){ // Check if we are in presale unlimited phase\n', '      if (crowdsaleState != state.openedPriorityPass){                                          // Check if state needs to be changed\n', '        crowdsaleState = state.openedPriorityPass;                                              // Set new state\n', '        PresaleUnlimitedStarted(block.number);                                                  // Raise event\n', '        return true;\n', '      }\n', '    }else if(block.number > crowdsaleStartBlock && block.number <= crowdsaleEndedBlock){        // Check if we are in crowdsale state\n', '      if (crowdsaleState != state.crowdsale){                                                   // Check if state needs to be changed\n', '        crowdsaleState = state.crowdsale;                                                       // Set new state\n', '        CrowdsaleStarted(block.number);                                                         // Raise event\n', '        return true;\n', '      }\n', '    }else{\n', '      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock){        // Check if crowdsale is over\n', '        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\n', '        CrowdsaleEnded(block.number);                                                           // Raise event\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '  //\n', '  // Decide if throw or only return ether\n', '  //\n', '  function refundTransaction(bool _stateChanged) internal{\n', '    if (_stateChanged){\n', '      msg.sender.transfer(msg.value);\n', '    }else{\n', '      revert();\n', '    }\n', '  }\n', '\n', '  //\n', '  // Calculate how much user can contribute\n', '  //\n', '  function calculateMaxContribution(address _contributor) constant returns (uint maxContribution){\n', '    uint maxContrib;\n', '    if (crowdsaleState == state.priorityPass){    // Check if we are in priority pass\n', '      maxContrib = contributorList[_contributor].priorityPassAllowance - contributorList[_contributor].contributionAmount;\n', '      if (maxContrib > (maxP1Cap - ethRaised)){   // Check if max contribution is more that max cap\n', '        maxContrib = maxP1Cap - ethRaised;        // Alter max cap\n', '      }\n', '    }\n', '    else{\n', '      maxContrib = maxCap - ethRaised;            // Alter max cap\n', '    }\n', '    return maxContrib;\n', '  }\n', '\n', '  //\n', '  // Issue tokens and return if there is overflow\n', '  //\n', '  function processTransaction(address _contributor, uint _amount) internal{\n', '    uint maxContribution = calculateMaxContribution(_contributor);              // Calculate max users contribution\n', '    uint contributionAmount = _amount;\n', '    uint returnAmount = 0;\n', '    if (maxContribution < _amount){                                             // Check if max contribution is lower than _amount sent\n', '      contributionAmount = maxContribution;                                     // Set that user contibutes his maximum alowed contribution\n', '      returnAmount = _amount - maxContribution;                                 // Calculate howmuch he must get back\n', '    }\n', '\n', '    if (ethRaised + contributionAmount > minCap && minCap > ethRaised) MinCapReached(block.number);\n', '\n', '    if (contributorList[_contributor].isActive == false){                       // Check if contributor has already contributed\n', '      contributorList[_contributor].isActive = true;                            // Set his activity to true\n', '      contributorList[_contributor].contributionAmount = contributionAmount;    // Set his contribution\n', '      contributorIndexes[nextContributorIndex] = _contributor;                  // Set contributors index\n', '      nextContributorIndex++;\n', '    }\n', '    else{\n', '      contributorList[_contributor].contributionAmount += contributionAmount;   // Add contribution amount to existing contributor\n', '    }\n', '    ethRaised += contributionAmount;                                            // Add to eth raised\n', '\n', '    uint tokenAmount = contributionAmount * ethToTokenConversion;               // Calculate how much tokens must contributor get\n', '    if (tokenAmount > 0){\n', '      token.mintTokens(_contributor, tokenAmount);                                // Issue new tokens\n', '      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\n', '    }\n', '    if (returnAmount != 0) _contributor.transfer(returnAmount);                 // Return overflow of ether\n', '  }\n', '\n', '  //\n', '  // Push contributor data to the contract before the crowdsale so that they are eligible for priorit pass\n', '  //\n', '  function editContributors(address[] _contributorAddresses, uint[] _contributorPPAllowances) onlyOwner{\n', '    require(_contributorAddresses.length == _contributorPPAllowances.length); // Check if input data is correct\n', '\n', '    for(uint cnt = 0; cnt < _contributorAddresses.length; cnt++){\n', '      if (contributorList[_contributorAddresses[cnt]].isActive){\n', '        contributorList[_contributorAddresses[cnt]].priorityPassAllowance = _contributorPPAllowances[cnt];\n', '      }\n', '      else{\n', '        contributorList[_contributorAddresses[cnt]].isActive = true;\n', '        contributorList[_contributorAddresses[cnt]].priorityPassAllowance = _contributorPPAllowances[cnt];\n', '        contributorIndexes[nextContributorIndex] = _contributorAddresses[cnt];\n', '        nextContributorIndex++;\n', '      }\n', '    }\n', '  }\n', '\n', '  //\n', '  // Method is needed for recovering tokens accedentaly sent to token address\n', '  //\n', '  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner{\n', '    IERC20Token(_tokenAddress).transfer(_to, _amount);\n', '  }\n', '\n', '  //\n', '  // withdrawEth when minimum cap is reached\n', '  //\n', '  function withdrawEth() onlyOwner{\n', '    require(this.balance != 0);\n', '    require(ethRaised >= minCap);\n', '\n', '    pendingEthWithdrawal = this.balance;\n', '  }\n', '  uint pendingEthWithdrawal;\n', '  function pullBalance(){\n', '    require(msg.sender == multisigAddress);\n', '    require(pendingEthWithdrawal > 0);\n', '\n', '    multisigAddress.transfer(pendingEthWithdrawal);\n', '    pendingEthWithdrawal = 0;\n', '  }\n', '\n', '  //\n', '  // Users can claim their contribution if min cap is not raised\n', '  //\n', '  function claimEthIfFailed(){\n', '    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);    // Check if crowdsale has failed\n', '    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedBlock\n', '    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\n', '\n', '    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\n', '    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\n', '    if (!msg.sender.send(ethContributed)){                                // Refund eth\n', '      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\n', '    }\n', '  }\n', '\n', '  //\n', '  // Owner can batch return contributors contributions(eth)\n', '  //\n', '  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner{\n', '    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);                // Check if crowdsale has failed\n', '    address currentParticipantAddress;\n', '    uint contribution;\n', '    for (uint cnt = 0; cnt < _numberOfReturns; cnt++){\n', '      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\n', '      if (currentParticipantAddress == 0x0) return;                                   // Check if all the participants were compensated\n', '      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\n', '        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\n', '        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\n', '        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\n', '          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\n', '        }\n', '      }\n', '      nextContributorToClaim += 1;                                                    // Repeat\n', '    }\n', '  }\n', '\n', '  //\n', '  // If there were any issue/attach with refund owner can withraw eth at the end for manual recovery\n', '  //\n', '  function withdrawRemainingBalanceForManualRecovery() onlyOwner{\n', '    require(this.balance != 0);                                  // Check if there are any eth to claim\n', '    require(block.number > crowdsaleEndedBlock);                 // Check if crowdsale is over\n', '    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\n', '    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\n', '  }\n', '\n', '  //\n', '  // Owner can set multisig address for crowdsale\n', '  //\n', '  function setMultisigAddress(address _newAddress) onlyOwner{\n', '    multisigAddress = _newAddress;\n', '  }\n', '\n', '  //\n', '  // Owner can set token address where mints will happen\n', '  //\n', '  function setToken(address _newAddress) onlyOwner{\n', '    token = IToken(_newAddress);\n', '  }\n', '\n', '  //\n', '  // Owner can claim teams tokens when crowdsale has successfully ended\n', '  //\n', '  function claimCoreTeamsTokens(address _to) onlyOwner{\n', '    require(crowdsaleState == state.crowdsaleEnded);              // Check if crowdsale has ended\n', '    require(!ownerHasClaimedTokens);                              // Check if owner has allready claimed tokens\n', '\n', '    uint devReward = maxTokenSupply - token.totalSupply();\n', '    if (!cofounditHasClaimedTokens) devReward -= cofounditReward; // If cofoundit has claimed tokens its ok if not set aside cofounditReward\n', '    token.mintTokens(_to, devReward);                             // Issue Teams tokens\n', '    ownerHasClaimedTokens = true;                                 // Block further mints from this method\n', '  }\n', '\n', '  //\n', '  // Cofoundit can claim their tokens\n', '  //\n', '  function claimCofounditTokens(){\n', '    require(msg.sender == cofounditAddress);            // Check if sender is cofoundit\n', '    require(crowdsaleState == state.crowdsaleEnded);    // Check if crowdsale has ended\n', '    require(!cofounditHasClaimedTokens);                // Check if cofoundit has allready claimed tokens\n', '\n', '    token.mintTokens(cofounditColdStorage, cofounditReward);             // Issue cofoundit tokens\n', '    cofounditHasClaimedTokens = true;                   // Block further mints from this method\n', '  }\n', '\n', '  function getTokenAddress() constant returns(address){\n', '    return address(token);\n', '  }\n', '\n', '  //\n', '  //  Before crowdsale starts owner can calibrate blocks of crowdsale stages\n', '  //\n', '  function setCrowdsaleBlocks(uint _presaleStartBlock, uint _presaleUnlimitedStartBlock, uint _crowdsaleStartBlock, uint _crowdsaleEndedBlock) onlyOwner{\n', '    require(crowdsaleState == state.pendingStart);                // Check if crowdsale has started\n', '    require(_presaleStartBlock != 0);                             // Check if any value is 0\n', '    require(_presaleStartBlock < _presaleUnlimitedStartBlock);    // Check if presaleUnlimitedStartBlock is set properly\n', '    require(_presaleUnlimitedStartBlock != 0);                    // Check if any value is 0\n', '    require(_presaleUnlimitedStartBlock < _crowdsaleStartBlock);  // Check if crowdsaleStartBlock is set properly\n', '    require(_crowdsaleStartBlock != 0);                           // Check if any value is 0\n', '    require(_crowdsaleStartBlock < _crowdsaleEndedBlock);         // Check if crowdsaleEndedBlock is set properly\n', '    require(_crowdsaleEndedBlock != 0);                           // Check if any value is 0\n', '    presaleStartBlock = _presaleStartBlock;\n', '    presaleUnlimitedStartBlock = _presaleUnlimitedStartBlock;\n', '    crowdsaleStartBlock = _crowdsaleStartBlock;\n', '    crowdsaleEndedBlock = _crowdsaleEndedBlock;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract DPPCrowdsale is Crowdsale {\n', '  function DPPCrowdsale(){\n', '    presaleStartBlock = 4291518;\n', '    presaleUnlimitedStartBlock = 4295146;\n', '    crowdsaleStartBlock = 4298775;\n', '    crowdsaleEndedBlock = 4313290;\n', '\n', '    minCap = 8236 * 10**18;\n', '    maxP1Cap = 12000 * 10**18;\n', '    maxCap = 20000 * 10**18;\n', '\n', '    ethToTokenConversion = 1250;\n', '\n', '    maxTokenSupply = 100000000 * 10**18;\n', '    cofounditReward = 8000000 * 10**18;\n', '    cofounditAddress = 0x988c3eA5554f3D2fB5ECB4dC5c35126eEf3B8a5D;\n', '    cofounditColdStorage = 0x8C0DB695de876a42cE2e133ca00fdF59A9166708;\n', '  }\n', '}']
['library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', 'contract IERC20Token {\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '  function balanceOf(address _owner) constant returns (uint256 balance) {}\n', '  function transfer(address _to, uint256 _value) returns (bool success) {}\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n', '  function approve(address _spender, uint256 _value) returns (bool success) {}\n', '  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', 'contract ItokenRecipient {\n', '  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData);\n', '}\n', 'contract IToken {\n', '  function totalSupply() constant returns (uint256 totalSupply);\n', '  function mintTokens(address _to, uint256 _amount) {}\n', '}\n', 'contract IMintableToken {\n', '  function mintTokens(address _to, uint256 _amount){}\n', '}\n', 'contract ReentrnacyHandlingContract{\n', '\n', '    bool locked;\n', '\n', '    modifier noReentrancy() {\n', '        require(!locked);\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != owner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = 0x0;\n', '    }\n', '\n', '    event OwnerUpdate(address _prevOwner, address _newOwner);\n', '}\n', 'contract Lockable is Owned{\n', '\n', '  uint256 public lockedUntilBlock;\n', '\n', '  event ContractLocked(uint256 _untilBlock, string _reason);\n', '\n', '  modifier lockAffected {\n', '      require(block.number > lockedUntilBlock);\n', '      _;\n', '  }\n', '\n', '  function lockFromSelf(uint256 _untilBlock, string _reason) internal {\n', '    lockedUntilBlock = _untilBlock;\n', '    ContractLocked(_untilBlock, _reason);\n', '  }\n', '\n', '\n', '  function lockUntil(uint256 _untilBlock, string _reason) onlyOwner {\n', '    lockedUntilBlock = _untilBlock;\n', '    ContractLocked(_untilBlock, _reason);\n', '  }\n', '}\n', '\n', 'contract Crowdsale is ReentrnacyHandlingContract, Owned{\n', '\n', '  struct ContributorData{\n', '    uint priorityPassAllowance;\n', '    bool isActive;\n', '    uint contributionAmount;\n', '    uint tokensIssued;\n', '  }\n', '\n', '  mapping(address => ContributorData) public contributorList;\n', '  uint nextContributorIndex;\n', '  mapping(uint => address) contributorIndexes;\n', '\n', '  state public crowdsaleState = state.pendingStart;\n', '  enum state { pendingStart, priorityPass, openedPriorityPass, crowdsale, crowdsaleEnded }\n', '\n', '  uint public presaleStartBlock;\n', '  uint public presaleUnlimitedStartBlock;\n', '  uint public crowdsaleStartBlock;\n', '  uint public crowdsaleEndedBlock;\n', '\n', '  event PresaleStarted(uint blockNumber);\n', '  event PresaleUnlimitedStarted(uint blockNumber);\n', '  event CrowdsaleStarted(uint blockNumber);\n', '  event CrowdsaleEnded(uint blockNumber);\n', '  event ErrorSendingETH(address to, uint amount);\n', '  event MinCapReached(uint blockNumber);\n', '  event MaxCapReached(uint blockNumber);\n', '\n', '  IToken token = IToken(0x0);\n', '  uint ethToTokenConversion;\n', '\n', '  uint public minCap;\n', '  uint public maxP1Cap;\n', '  uint public maxCap;\n', '  uint public ethRaised;\n', '\n', '  address public multisigAddress;\n', '\n', '  uint nextContributorToClaim;\n', '  mapping(address => bool) hasClaimedEthWhenFail;\n', '\n', '  uint maxTokenSupply;\n', '  bool ownerHasClaimedTokens;\n', '  uint cofounditReward;\n', '  address cofounditAddress;\n', '  address cofounditColdStorage;\n', '  bool cofounditHasClaimedTokens;\n', '\n', '  //\n', '  // Unnamed function that runs when eth is sent to the contract\n', '  //\n', '  function() noReentrancy payable{\n', '    require(msg.value != 0);                        // Throw if value is 0\n', '    require(crowdsaleState != state.crowdsaleEnded);// Check if crowdsale has ended\n', '\n', '    bool stateChanged = checkCrowdsaleState();      // Check blocks and calibrate crowdsale state\n', '\n', '    if (crowdsaleState == state.priorityPass){\n', '      if (contributorList[msg.sender].isActive){    // Check if contributor is in priorityPass\n', '        processTransaction(msg.sender, msg.value);  // Process transaction and issue tokens\n', '      }else{\n', '        refundTransaction(stateChanged);            // Set state and return funds or throw\n', '      }\n', '    }\n', '    else if(crowdsaleState == state.openedPriorityPass){\n', '      if (contributorList[msg.sender].isActive){    // Check if contributor is in priorityPass\n', '        processTransaction(msg.sender, msg.value);  // Process transaction and issue tokens\n', '      }else{\n', '        refundTransaction(stateChanged);            // Set state and return funds or throw\n', '      }\n', '    }\n', '    else if(crowdsaleState == state.crowdsale){\n', '      processTransaction(msg.sender, msg.value);    // Process transaction and issue tokens\n', '    }\n', '    else{\n', '      refundTransaction(stateChanged);              // Set state and return funds or throw\n', '    }\n', '  }\n', '\n', '  //\n', '  // Check crowdsale state and calibrate it\n', '  //\n', '  function checkCrowdsaleState() internal returns (bool){\n', '    if (ethRaised == maxCap && crowdsaleState != state.crowdsaleEnded){                         // Check if max cap is reached\n', '      crowdsaleState = state.crowdsaleEnded;\n', '      MaxCapReached(block.number);                                                              // Close the crowdsale\n', '      CrowdsaleEnded(block.number);                                                             // Raise event\n', '      return true;\n', '    }\n', '\n', '    if (block.number > presaleStartBlock && block.number <= presaleUnlimitedStartBlock){  // Check if we are in presale phase\n', '      if (crowdsaleState != state.priorityPass){                                          // Check if state needs to be changed\n', '        crowdsaleState = state.priorityPass;                                              // Set new state\n', '        PresaleStarted(block.number);                                                     // Raise event\n', '        return true;\n', '      }\n', '    }else if(block.number > presaleUnlimitedStartBlock && block.number <= crowdsaleStartBlock){ // Check if we are in presale unlimited phase\n', '      if (crowdsaleState != state.openedPriorityPass){                                          // Check if state needs to be changed\n', '        crowdsaleState = state.openedPriorityPass;                                              // Set new state\n', '        PresaleUnlimitedStarted(block.number);                                                  // Raise event\n', '        return true;\n', '      }\n', '    }else if(block.number > crowdsaleStartBlock && block.number <= crowdsaleEndedBlock){        // Check if we are in crowdsale state\n', '      if (crowdsaleState != state.crowdsale){                                                   // Check if state needs to be changed\n', '        crowdsaleState = state.crowdsale;                                                       // Set new state\n', '        CrowdsaleStarted(block.number);                                                         // Raise event\n', '        return true;\n', '      }\n', '    }else{\n', '      if (crowdsaleState != state.crowdsaleEnded && block.number > crowdsaleEndedBlock){        // Check if crowdsale is over\n', '        crowdsaleState = state.crowdsaleEnded;                                                  // Set new state\n', '        CrowdsaleEnded(block.number);                                                           // Raise event\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '  //\n', '  // Decide if throw or only return ether\n', '  //\n', '  function refundTransaction(bool _stateChanged) internal{\n', '    if (_stateChanged){\n', '      msg.sender.transfer(msg.value);\n', '    }else{\n', '      revert();\n', '    }\n', '  }\n', '\n', '  //\n', '  // Calculate how much user can contribute\n', '  //\n', '  function calculateMaxContribution(address _contributor) constant returns (uint maxContribution){\n', '    uint maxContrib;\n', '    if (crowdsaleState == state.priorityPass){    // Check if we are in priority pass\n', '      maxContrib = contributorList[_contributor].priorityPassAllowance - contributorList[_contributor].contributionAmount;\n', '      if (maxContrib > (maxP1Cap - ethRaised)){   // Check if max contribution is more that max cap\n', '        maxContrib = maxP1Cap - ethRaised;        // Alter max cap\n', '      }\n', '    }\n', '    else{\n', '      maxContrib = maxCap - ethRaised;            // Alter max cap\n', '    }\n', '    return maxContrib;\n', '  }\n', '\n', '  //\n', '  // Issue tokens and return if there is overflow\n', '  //\n', '  function processTransaction(address _contributor, uint _amount) internal{\n', '    uint maxContribution = calculateMaxContribution(_contributor);              // Calculate max users contribution\n', '    uint contributionAmount = _amount;\n', '    uint returnAmount = 0;\n', '    if (maxContribution < _amount){                                             // Check if max contribution is lower than _amount sent\n', '      contributionAmount = maxContribution;                                     // Set that user contibutes his maximum alowed contribution\n', '      returnAmount = _amount - maxContribution;                                 // Calculate howmuch he must get back\n', '    }\n', '\n', '    if (ethRaised + contributionAmount > minCap && minCap > ethRaised) MinCapReached(block.number);\n', '\n', '    if (contributorList[_contributor].isActive == false){                       // Check if contributor has already contributed\n', '      contributorList[_contributor].isActive = true;                            // Set his activity to true\n', '      contributorList[_contributor].contributionAmount = contributionAmount;    // Set his contribution\n', '      contributorIndexes[nextContributorIndex] = _contributor;                  // Set contributors index\n', '      nextContributorIndex++;\n', '    }\n', '    else{\n', '      contributorList[_contributor].contributionAmount += contributionAmount;   // Add contribution amount to existing contributor\n', '    }\n', '    ethRaised += contributionAmount;                                            // Add to eth raised\n', '\n', '    uint tokenAmount = contributionAmount * ethToTokenConversion;               // Calculate how much tokens must contributor get\n', '    if (tokenAmount > 0){\n', '      token.mintTokens(_contributor, tokenAmount);                                // Issue new tokens\n', '      contributorList[_contributor].tokensIssued += tokenAmount;                  // log token issuance\n', '    }\n', '    if (returnAmount != 0) _contributor.transfer(returnAmount);                 // Return overflow of ether\n', '  }\n', '\n', '  //\n', '  // Push contributor data to the contract before the crowdsale so that they are eligible for priorit pass\n', '  //\n', '  function editContributors(address[] _contributorAddresses, uint[] _contributorPPAllowances) onlyOwner{\n', '    require(_contributorAddresses.length == _contributorPPAllowances.length); // Check if input data is correct\n', '\n', '    for(uint cnt = 0; cnt < _contributorAddresses.length; cnt++){\n', '      if (contributorList[_contributorAddresses[cnt]].isActive){\n', '        contributorList[_contributorAddresses[cnt]].priorityPassAllowance = _contributorPPAllowances[cnt];\n', '      }\n', '      else{\n', '        contributorList[_contributorAddresses[cnt]].isActive = true;\n', '        contributorList[_contributorAddresses[cnt]].priorityPassAllowance = _contributorPPAllowances[cnt];\n', '        contributorIndexes[nextContributorIndex] = _contributorAddresses[cnt];\n', '        nextContributorIndex++;\n', '      }\n', '    }\n', '  }\n', '\n', '  //\n', '  // Method is needed for recovering tokens accedentaly sent to token address\n', '  //\n', '  function salvageTokensFromContract(address _tokenAddress, address _to, uint _amount) onlyOwner{\n', '    IERC20Token(_tokenAddress).transfer(_to, _amount);\n', '  }\n', '\n', '  //\n', '  // withdrawEth when minimum cap is reached\n', '  //\n', '  function withdrawEth() onlyOwner{\n', '    require(this.balance != 0);\n', '    require(ethRaised >= minCap);\n', '\n', '    pendingEthWithdrawal = this.balance;\n', '  }\n', '  uint pendingEthWithdrawal;\n', '  function pullBalance(){\n', '    require(msg.sender == multisigAddress);\n', '    require(pendingEthWithdrawal > 0);\n', '\n', '    multisigAddress.transfer(pendingEthWithdrawal);\n', '    pendingEthWithdrawal = 0;\n', '  }\n', '\n', '  //\n', '  // Users can claim their contribution if min cap is not raised\n', '  //\n', '  function claimEthIfFailed(){\n', '    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);    // Check if crowdsale has failed\n', '    require(contributorList[msg.sender].contributionAmount > 0);          // Check if contributor has contributed to crowdsaleEndedBlock\n', '    require(!hasClaimedEthWhenFail[msg.sender]);                          // Check if contributor has already claimed his eth\n', '\n', '    uint ethContributed = contributorList[msg.sender].contributionAmount; // Get contributors contribution\n', '    hasClaimedEthWhenFail[msg.sender] = true;                             // Set that he has claimed\n', '    if (!msg.sender.send(ethContributed)){                                // Refund eth\n', '      ErrorSendingETH(msg.sender, ethContributed);                        // If there is an issue raise event for manual recovery\n', '    }\n', '  }\n', '\n', '  //\n', '  // Owner can batch return contributors contributions(eth)\n', '  //\n', '  function batchReturnEthIfFailed(uint _numberOfReturns) onlyOwner{\n', '    require(block.number > crowdsaleEndedBlock && ethRaised < minCap);                // Check if crowdsale has failed\n', '    address currentParticipantAddress;\n', '    uint contribution;\n', '    for (uint cnt = 0; cnt < _numberOfReturns; cnt++){\n', '      currentParticipantAddress = contributorIndexes[nextContributorToClaim];         // Get next unclaimed participant\n', '      if (currentParticipantAddress == 0x0) return;                                   // Check if all the participants were compensated\n', '      if (!hasClaimedEthWhenFail[currentParticipantAddress]) {                        // Check if participant has already claimed\n', '        contribution = contributorList[currentParticipantAddress].contributionAmount; // Get contribution of participant\n', '        hasClaimedEthWhenFail[currentParticipantAddress] = true;                      // Set that he has claimed\n', '        if (!currentParticipantAddress.send(contribution)){                           // Refund eth\n', '          ErrorSendingETH(currentParticipantAddress, contribution);                   // If there is an issue raise event for manual recovery\n', '        }\n', '      }\n', '      nextContributorToClaim += 1;                                                    // Repeat\n', '    }\n', '  }\n', '\n', '  //\n', '  // If there were any issue/attach with refund owner can withraw eth at the end for manual recovery\n', '  //\n', '  function withdrawRemainingBalanceForManualRecovery() onlyOwner{\n', '    require(this.balance != 0);                                  // Check if there are any eth to claim\n', '    require(block.number > crowdsaleEndedBlock);                 // Check if crowdsale is over\n', '    require(contributorIndexes[nextContributorToClaim] == 0x0);  // Check if all the users were refunded\n', '    multisigAddress.transfer(this.balance);                      // Withdraw to multisig\n', '  }\n', '\n', '  //\n', '  // Owner can set multisig address for crowdsale\n', '  //\n', '  function setMultisigAddress(address _newAddress) onlyOwner{\n', '    multisigAddress = _newAddress;\n', '  }\n', '\n', '  //\n', '  // Owner can set token address where mints will happen\n', '  //\n', '  function setToken(address _newAddress) onlyOwner{\n', '    token = IToken(_newAddress);\n', '  }\n', '\n', '  //\n', '  // Owner can claim teams tokens when crowdsale has successfully ended\n', '  //\n', '  function claimCoreTeamsTokens(address _to) onlyOwner{\n', '    require(crowdsaleState == state.crowdsaleEnded);              // Check if crowdsale has ended\n', '    require(!ownerHasClaimedTokens);                              // Check if owner has allready claimed tokens\n', '\n', '    uint devReward = maxTokenSupply - token.totalSupply();\n', '    if (!cofounditHasClaimedTokens) devReward -= cofounditReward; // If cofoundit has claimed tokens its ok if not set aside cofounditReward\n', '    token.mintTokens(_to, devReward);                             // Issue Teams tokens\n', '    ownerHasClaimedTokens = true;                                 // Block further mints from this method\n', '  }\n', '\n', '  //\n', '  // Cofoundit can claim their tokens\n', '  //\n', '  function claimCofounditTokens(){\n', '    require(msg.sender == cofounditAddress);            // Check if sender is cofoundit\n', '    require(crowdsaleState == state.crowdsaleEnded);    // Check if crowdsale has ended\n', '    require(!cofounditHasClaimedTokens);                // Check if cofoundit has allready claimed tokens\n', '\n', '    token.mintTokens(cofounditColdStorage, cofounditReward);             // Issue cofoundit tokens\n', '    cofounditHasClaimedTokens = true;                   // Block further mints from this method\n', '  }\n', '\n', '  function getTokenAddress() constant returns(address){\n', '    return address(token);\n', '  }\n', '\n', '  //\n', '  //  Before crowdsale starts owner can calibrate blocks of crowdsale stages\n', '  //\n', '  function setCrowdsaleBlocks(uint _presaleStartBlock, uint _presaleUnlimitedStartBlock, uint _crowdsaleStartBlock, uint _crowdsaleEndedBlock) onlyOwner{\n', '    require(crowdsaleState == state.pendingStart);                // Check if crowdsale has started\n', '    require(_presaleStartBlock != 0);                             // Check if any value is 0\n', '    require(_presaleStartBlock < _presaleUnlimitedStartBlock);    // Check if presaleUnlimitedStartBlock is set properly\n', '    require(_presaleUnlimitedStartBlock != 0);                    // Check if any value is 0\n', '    require(_presaleUnlimitedStartBlock < _crowdsaleStartBlock);  // Check if crowdsaleStartBlock is set properly\n', '    require(_crowdsaleStartBlock != 0);                           // Check if any value is 0\n', '    require(_crowdsaleStartBlock < _crowdsaleEndedBlock);         // Check if crowdsaleEndedBlock is set properly\n', '    require(_crowdsaleEndedBlock != 0);                           // Check if any value is 0\n', '    presaleStartBlock = _presaleStartBlock;\n', '    presaleUnlimitedStartBlock = _presaleUnlimitedStartBlock;\n', '    crowdsaleStartBlock = _crowdsaleStartBlock;\n', '    crowdsaleEndedBlock = _crowdsaleEndedBlock;\n', '  }\n', '}\n', '\n', '\n', '\n', 'contract DPPCrowdsale is Crowdsale {\n', '  function DPPCrowdsale(){\n', '    presaleStartBlock = 4291518;\n', '    presaleUnlimitedStartBlock = 4295146;\n', '    crowdsaleStartBlock = 4298775;\n', '    crowdsaleEndedBlock = 4313290;\n', '\n', '    minCap = 8236 * 10**18;\n', '    maxP1Cap = 12000 * 10**18;\n', '    maxCap = 20000 * 10**18;\n', '\n', '    ethToTokenConversion = 1250;\n', '\n', '    maxTokenSupply = 100000000 * 10**18;\n', '    cofounditReward = 8000000 * 10**18;\n', '    cofounditAddress = 0x988c3eA5554f3D2fB5ECB4dC5c35126eEf3B8a5D;\n', '    cofounditColdStorage = 0x8C0DB695de876a42cE2e133ca00fdF59A9166708;\n', '  }\n', '}']
