['pragma solidity ^0.4.11;\n', '\n', 'contract Controller {\n', '\n', '\n', '  // list of admins, council at first spot\n', '  address[] public admins;\n', '\n', '  function Governable() {\n', '    admins.length = 1;\n', '    admins[0] = msg.sender;\n', '  }\n', '\n', '  modifier onlyAdmins() {\n', '    bool isAdmin = false;\n', '    for (uint256 i = 0; i < admins.length; i++) {\n', '      if (msg.sender == admins[i]) {\n', '        isAdmin = true;\n', '      }\n', '    }\n', '    require(isAdmin == true);\n', '    _;\n', '  }\n', '\n', '  function addAdmin(address _admin) public onlyAdmins {\n', '    for (uint256 i = 0; i < admins.length; i++) {\n', '      require(_admin != admins[i]);\n', '    }\n', '    require(admins.length < 10);\n', '    admins[admins.length++] = _admin;\n', '  }\n', '\n', '  function removeAdmin(address _admin) public onlyAdmins {\n', '    uint256 pos = admins.length;\n', '    for (uint256 i = 0; i < admins.length; i++) {\n', '      if (_admin == admins[i]) {\n', '        pos = i;\n', '      }\n', '    }\n', '    require(pos < admins.length);\n', '    // if not last element, switch with last\n', '    if (pos < admins.length - 1) {\n', '      admins[pos] = admins[admins.length - 1];\n', '    }\n', '    // then cut off the tail\n', '    admins.length--;\n', '  }\n', '\n', '  // State Variables\n', '  bool public paused;\n', '  function nutzAddr() constant returns (address);\n', '  function powerAddr() constant returns (address);\n', '  \n', '  function moveCeiling(uint256 _newPurchasePrice);\n', '  function moveFloor(uint256 _newPurchasePrice);\n', '\n', '  // Nutz functions\n', '  function babzBalanceOf(address _owner) constant returns (uint256);\n', '  function activeSupply() constant returns (uint256);\n', '  function burnPool() constant returns (uint256);\n', '  function powerPool() constant returns (uint256);\n', '  function totalSupply() constant returns (uint256);\n', '  function allowance(address _owner, address _spender) constant returns (uint256);\n', '\n', '  function approve(address _owner, address _spender, uint256 _amountBabz) public;\n', '  function transfer(address _from, address _to, uint256 _amountBabz, bytes _data) public;\n', '  function transferFrom(address _sender, address _from, address _to, uint256 _amountBabz, bytes _data) public;\n', '\n', '  // Market functions\n', '  function floor() constant returns (uint256);\n', '  function ceiling() constant returns (uint256);\n', '\n', '  function purchase(address _sender, uint256 _value, uint256 _price) public returns (uint256);\n', '  function sell(address _from, uint256 _price, uint256 _amountBabz);\n', '\n', '  // Power functions\n', '  function powerBalanceOf(address _owner) constant returns (uint256);\n', '  function outstandingPower() constant returns (uint256);\n', '  function authorizedPower() constant returns (uint256);\n', '  function powerTotalSupply() constant returns (uint256);\n', '\n', '  function powerUp(address _sender, address _from, uint256 _amountBabz) public;\n', '  function downTick(address _owner, uint256 _now) public;\n', '  function createDownRequest(address _owner, uint256 _amountPower) public;\n', '  function downs(address _owner) constant public returns(uint256, uint256, uint256);\n', '  function downtime() constant returns (uint256);\n', '\n', '  // this is called when NTZ are deposited into the burn pool\n', '  function dilutePower(uint256 _amountBabz, uint256 _amountPower);\n', '    function setMaxPower(uint256 _maxPower);\n', '    \n', '\n', '  // withdraw excessive reserve - i.e. milestones\n', '  function allocateEther(uint256 _amountWei, address _beneficiary);\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', '    // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '\n', '/*\n', ' * ERC20Basic\n', ' * Simpler version of ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() constant returns (uint256);\n', '  function balanceOf(address _owner) constant returns (uint256);\n', '  function transfer(address _to, uint256 _value) returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', '\n', 'contract ERC223Basic is ERC20Basic {\n', '    function transfer(address to, uint value, bytes data) returns (bool);\n', '}\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC223Basic {\n', '  // active supply of tokens\n', '  function activeSupply() constant returns (uint256);\n', '  function allowance(address _owner, address _spender) constant returns (uint256);\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool);\n', '  function approve(address _spender, uint256 _value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', 'contract PowerEvent {\n', '  using SafeMath for uint;\n', '\n', '  // states\n', '  //   - waiting, initial state\n', '  //   - collecting, after waiting, before collection stopped\n', '  //   - failed, after collecting, if softcap missed\n', '  //   - closed, after collecting, if softcap reached\n', '  //   - complete, after closed or failed, when job done\n', '  enum EventState { Waiting, Collecting, Closed, Failed, Complete }\n', '  EventState public state;\n', '  uint256 public RATE_FACTOR = 1000000;\n', '\n', '  // Terms\n', '  uint256 public startTime;\n', '  uint256 public minDuration;\n', '  uint256 public maxDuration;\n', '  uint256 public softCap;\n', '  uint256 public hardCap;\n', '  uint256 public discountRate; // if rate 30%, this will be 300,000\n', '  uint256 public amountPower;\n', '  address[] public milestoneRecipients;\n', '  uint256[] public milestoneShares;\n', '\n', '  // Params\n', '  address public controllerAddr;\n', '  address public powerAddr;\n', '  address public nutzAddr;\n', '  uint256 public initialReserve;\n', '  uint256 public initialSupply;\n', '\n', '  function PowerEvent(address _controllerAddr, uint256 _startTime, uint256 _minDuration, uint256 _maxDuration, uint256 _softCap, uint256 _hardCap, uint256 _discount, uint256 _amountPower, address[] _milestoneRecipients, uint256[] _milestoneShares)\n', '  areValidMileStones(_milestoneRecipients, _milestoneShares) {\n', '    require(_minDuration <= _maxDuration);\n', '    require(_softCap <= _hardCap);\n', '    controllerAddr = _controllerAddr;\n', '    startTime = _startTime;\n', '    minDuration = _minDuration;\n', '    maxDuration = _maxDuration;\n', '    softCap = _softCap;\n', '    hardCap = _hardCap;\n', '    discountRate = _discount;\n', '    amountPower = _amountPower;\n', '    state = EventState.Waiting;\n', '    milestoneRecipients = _milestoneRecipients;\n', '    milestoneShares = _milestoneShares;\n', '  }\n', '\n', '  modifier isState(EventState _state) {\n', '    require(state == _state);\n', '    _;\n', '  }\n', '\n', '  modifier areValidMileStones(address[] _milestoneRecipients, uint256[] _milestoneShares) {\n', '    require(checkMilestones(_milestoneRecipients, _milestoneShares));\n', '    _;\n', '  }\n', '\n', '  function checkMilestones(address[] _milestoneRecipients, uint256[] _milestoneShares) internal returns (bool) {\n', '    require(_milestoneRecipients.length == _milestoneShares.length && _milestoneShares.length <= 4);\n', '    uint256 totalPercentage;\n', '    for(uint8 i = 0; i < _milestoneShares.length; i++) {\n', '      require(_milestoneShares[i] >= 0 && _milestoneShares[i] <= 1000000);\n', '      totalPercentage = totalPercentage.add(_milestoneShares[i]);\n', '    }\n', '    require(totalPercentage >= 0 && totalPercentage <= 1000000);\n', '    return true;\n', '  }\n', '\n', '  function tick() public {\n', '    if (state == EventState.Waiting) {\n', '      startCollection();\n', '    } else if (state == EventState.Collecting) {\n', '      stopCollection();\n', '    } else if (state == EventState.Failed) {\n', '      completeFailed();\n', '    } else if (state == EventState.Closed) {\n', '      completeClosed();\n', '    } else {\n', '      throw;\n', '    }\n', '  }\n', '\n', '  function startCollection() isState(EventState.Waiting) {\n', '    // check time\n', '    require(now > startTime);\n', '    // assert(now < startTime.add(minDuration));\n', '    // read initial values\n', '    var contr = Controller(controllerAddr);\n', '    powerAddr = contr.powerAddr();\n', '    nutzAddr = contr.nutzAddr();\n', '    initialSupply = contr.activeSupply().add(contr.powerPool()).add(contr.burnPool());\n', '    initialReserve = nutzAddr.balance;\n', '    uint256 ceiling = contr.ceiling();\n', '    // move ceiling\n', '    uint256 newCeiling = ceiling.mul(discountRate).div(RATE_FACTOR);\n', '    contr.moveCeiling(newCeiling);\n', '    // set state\n', '    state = EventState.Collecting;\n', '  }\n', '\n', '  function stopCollection() isState(EventState.Collecting) {\n', '    uint256 collected = nutzAddr.balance.sub(initialReserve);\n', '    if (now > startTime.add(maxDuration)) {\n', '      if (collected >= softCap) {\n', '        // softCap reached, close\n', '        state = EventState.Closed;\n', '        return;\n', '      } else {\n', '        // softCap missed, fail\n', '        state = EventState.Failed;\n', '        return;\n', '      }\n', '    } else if (now > startTime.add(minDuration)) {\n', '      if (collected >= hardCap) {\n', '        // hardCap reached, close\n', '        state = EventState.Closed;\n', '        return;\n', '      } else {\n', '        // keep going\n', '        revert();\n', '      }\n', '    }\n', '    // keep going\n', '    revert();\n', '  }\n', '\n', '  function completeFailed() isState(EventState.Failed) {\n', '    var contr = Controller(controllerAddr);\n', '    // move floor (set ceiling or max floor)\n', '    uint256 ceiling = contr.ceiling();\n', '    contr.moveFloor(ceiling);\n', '    // remove access\n', '    contr.removeAdmin(address(this));\n', '    // set state\n', '    state = EventState.Complete;\n', '  }\n', '\n', '  function completeClosed() isState(EventState.Closed) {\n', '    var contr = Controller(controllerAddr);\n', '    // move ceiling\n', '    uint256 ceiling = contr.ceiling();\n', '    uint256 newCeiling = ceiling.mul(RATE_FACTOR).div(discountRate);\n', '    contr.moveCeiling(newCeiling);\n', '    // dilute power\n', '    uint256 totalSupply = contr.activeSupply().add(contr.powerPool()).add(contr.burnPool());\n', '    uint256 newSupply = totalSupply.sub(initialSupply);\n', '    contr.dilutePower(newSupply, amountPower);\n', '    // set max power\n', '    var PowerContract = ERC20(powerAddr);\n', '    uint256 authorizedPower = PowerContract.totalSupply();\n', '    contr.setMaxPower(authorizedPower);\n', '    // pay out milestone\n', '    uint256 collected = nutzAddr.balance.sub(initialReserve);\n', '    for (uint256 i = 0; i < milestoneRecipients.length; i++) {\n', '      uint256 payoutAmount = collected.mul(milestoneShares[i]).div(RATE_FACTOR);\n', '      contr.allocateEther(payoutAmount, milestoneRecipients[i]);\n', '    }\n', '    // remove access\n', '    contr.removeAdmin(address(this));\n', '    // set state\n', '    state = EventState.Complete;\n', '  }\n', '\n', '}']