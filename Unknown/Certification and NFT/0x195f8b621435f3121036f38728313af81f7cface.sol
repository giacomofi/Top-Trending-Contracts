['pragma solidity 0.4.11;\n', '\n', 'contract CrowdWithUs {\n', '    \n', '    address public creator;\n', '    address public fundRecipient; // creator may be different than recipient\n', '    uint public minimumToRaise; // required to reach at least this much, else everyone gets refund\n', '    string campaignUrl; \n', '    byte constant version = 1;\n', '\n', '    // Data structures\n', '    enum State {\n', '        Fundraising,\n', '        ExpiredRefund,\n', '        Successful,\n', '        Closed\n', '    }\n', '\n', '    struct Contribution {\n', '        uint amount;\n', '        address contributor;\n', '    }\n', '\n', '    // State variables\n', '    State public state = State.Fundraising; // initialize on create\n', '    uint public totalRaised;\n', '    uint public currentBalance;\n', '    uint public raiseBy;\n', '    uint public completeAt;\n', '    Contribution[] contributions;\n', '\n', '    event LogFundingReceived(address addr, uint amount, uint currentTotal);\n', '    event LogWinnerPaid(address winnerAddress);\n', '    event LogFunderInitialized(\n', '        address creator,\n', '        address fundRecipient,\n', '        string url,\n', '        uint _minimumToRaise, \n', '        uint256 raiseby\n', '    );\n', '\n', '    modifier inState(State _state) {\n', '        if (state != _state) throw;\n', '        _;\n', '    }\n', '\n', '    modifier isCreator() {\n', '        if (msg.sender != creator) throw;\n', '        _;\n', '    }\n', '\n', '    // Wait 1 hour after final contract state before allowing contract destruction\n', '    modifier atEndOfLifecycle() {\n', '        if(!((state == State.ExpiredRefund || state == State.Successful) && completeAt + 1 hours < now)) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    function CrowdWithUs(\n', '        uint timeInHoursForFundraising,\n', '        string _campaignUrl,\n', '        address _fundRecipient,\n', '        uint _minimumToRaise)\n', '    {\n', '        creator = msg.sender;\n', '        fundRecipient = _fundRecipient;\n', '        campaignUrl = _campaignUrl;\n', '        minimumToRaise = _minimumToRaise * 1 ether; //convert to wei\n', '        raiseBy = now + (timeInHoursForFundraising * 1 hours);\n', '        currentBalance = 0;\n', '        LogFunderInitialized(\n', '            creator,\n', '            fundRecipient,\n', '            campaignUrl,\n', '            minimumToRaise,\n', '            raiseBy);\n', '    }\n', '\n', '    function contribute()\n', '    public\n', '    inState(State.Fundraising) payable returns (uint256)\n', '    {\n', '        contributions.push(\n', '            Contribution({\n', '                amount: msg.value,\n', '                contributor: msg.sender\n', '                }) // use array, so can iterate\n', '            );\n', '        totalRaised += msg.value;\n', '        currentBalance = totalRaised;\n', '        LogFundingReceived(msg.sender, msg.value, totalRaised);\n', '\n', '        checkIfFundingCompleteOrExpired();\n', '        return contributions.length - 1; // return id\n', '    }\n', '\n', '    function checkIfFundingCompleteOrExpired() {\n', '        if (totalRaised > minimumToRaise) {\n', '            state = State.Successful;\n', '            payOut();\n', '\n', '            // could incentivize sender who initiated state change here\n', '            } else if ( now > raiseBy )  {\n', '                state = State.ExpiredRefund; // backers can now collect refunds by calling getRefund(id)\n', '            }\n', '            completeAt = now;\n', '        }\n', '\n', '        function payOut()\n', '        public\n', '        inState(State.Successful)\n', '        {\n', '            if(!fundRecipient.send(this.balance)) {\n', '                throw;\n', '            }\n', '            state = State.Closed;\n', '            currentBalance = 0;\n', '            LogWinnerPaid(fundRecipient);\n', '        }\n', '\n', '        function getRefund(uint256 id)\n', '        public\n', '        inState(State.ExpiredRefund) \n', '        returns (bool)\n', '        {\n', '            if (contributions.length <= id || id < 0 || contributions[id].amount == 0 ) {\n', '                throw;\n', '            }\n', '\n', '            uint amountToRefund = contributions[id].amount;\n', '            contributions[id].amount = 0;\n', '\n', '            if(!contributions[id].contributor.send(amountToRefund)) {\n', '                contributions[id].amount = amountToRefund;\n', '                return false;\n', '            }\n', '            else{\n', '                totalRaised -= amountToRefund;\n', '                currentBalance = totalRaised;\n', '            }\n', '\n', '            return true;\n', '        }\n', '\n', '        function removeContract()\n', '        public\n', '        isCreator()\n', '        atEndOfLifecycle()\n', '        {\n', '            selfdestruct(msg.sender);\n', '            // creator gets all money that hasn&#39;t be claimed\n', '\n', '\n', '        }\n', '\n', '        function () { throw; }\n', '    }']
['pragma solidity 0.4.11;\n', '\n', 'contract CrowdWithUs {\n', '    \n', '    address public creator;\n', '    address public fundRecipient; // creator may be different than recipient\n', '    uint public minimumToRaise; // required to reach at least this much, else everyone gets refund\n', '    string campaignUrl; \n', '    byte constant version = 1;\n', '\n', '    // Data structures\n', '    enum State {\n', '        Fundraising,\n', '        ExpiredRefund,\n', '        Successful,\n', '        Closed\n', '    }\n', '\n', '    struct Contribution {\n', '        uint amount;\n', '        address contributor;\n', '    }\n', '\n', '    // State variables\n', '    State public state = State.Fundraising; // initialize on create\n', '    uint public totalRaised;\n', '    uint public currentBalance;\n', '    uint public raiseBy;\n', '    uint public completeAt;\n', '    Contribution[] contributions;\n', '\n', '    event LogFundingReceived(address addr, uint amount, uint currentTotal);\n', '    event LogWinnerPaid(address winnerAddress);\n', '    event LogFunderInitialized(\n', '        address creator,\n', '        address fundRecipient,\n', '        string url,\n', '        uint _minimumToRaise, \n', '        uint256 raiseby\n', '    );\n', '\n', '    modifier inState(State _state) {\n', '        if (state != _state) throw;\n', '        _;\n', '    }\n', '\n', '    modifier isCreator() {\n', '        if (msg.sender != creator) throw;\n', '        _;\n', '    }\n', '\n', '    // Wait 1 hour after final contract state before allowing contract destruction\n', '    modifier atEndOfLifecycle() {\n', '        if(!((state == State.ExpiredRefund || state == State.Successful) && completeAt + 1 hours < now)) {\n', '            throw;\n', '        }\n', '        _;\n', '    }\n', '\n', '    function CrowdWithUs(\n', '        uint timeInHoursForFundraising,\n', '        string _campaignUrl,\n', '        address _fundRecipient,\n', '        uint _minimumToRaise)\n', '    {\n', '        creator = msg.sender;\n', '        fundRecipient = _fundRecipient;\n', '        campaignUrl = _campaignUrl;\n', '        minimumToRaise = _minimumToRaise * 1 ether; //convert to wei\n', '        raiseBy = now + (timeInHoursForFundraising * 1 hours);\n', '        currentBalance = 0;\n', '        LogFunderInitialized(\n', '            creator,\n', '            fundRecipient,\n', '            campaignUrl,\n', '            minimumToRaise,\n', '            raiseBy);\n', '    }\n', '\n', '    function contribute()\n', '    public\n', '    inState(State.Fundraising) payable returns (uint256)\n', '    {\n', '        contributions.push(\n', '            Contribution({\n', '                amount: msg.value,\n', '                contributor: msg.sender\n', '                }) // use array, so can iterate\n', '            );\n', '        totalRaised += msg.value;\n', '        currentBalance = totalRaised;\n', '        LogFundingReceived(msg.sender, msg.value, totalRaised);\n', '\n', '        checkIfFundingCompleteOrExpired();\n', '        return contributions.length - 1; // return id\n', '    }\n', '\n', '    function checkIfFundingCompleteOrExpired() {\n', '        if (totalRaised > minimumToRaise) {\n', '            state = State.Successful;\n', '            payOut();\n', '\n', '            // could incentivize sender who initiated state change here\n', '            } else if ( now > raiseBy )  {\n', '                state = State.ExpiredRefund; // backers can now collect refunds by calling getRefund(id)\n', '            }\n', '            completeAt = now;\n', '        }\n', '\n', '        function payOut()\n', '        public\n', '        inState(State.Successful)\n', '        {\n', '            if(!fundRecipient.send(this.balance)) {\n', '                throw;\n', '            }\n', '            state = State.Closed;\n', '            currentBalance = 0;\n', '            LogWinnerPaid(fundRecipient);\n', '        }\n', '\n', '        function getRefund(uint256 id)\n', '        public\n', '        inState(State.ExpiredRefund) \n', '        returns (bool)\n', '        {\n', '            if (contributions.length <= id || id < 0 || contributions[id].amount == 0 ) {\n', '                throw;\n', '            }\n', '\n', '            uint amountToRefund = contributions[id].amount;\n', '            contributions[id].amount = 0;\n', '\n', '            if(!contributions[id].contributor.send(amountToRefund)) {\n', '                contributions[id].amount = amountToRefund;\n', '                return false;\n', '            }\n', '            else{\n', '                totalRaised -= amountToRefund;\n', '                currentBalance = totalRaised;\n', '            }\n', '\n', '            return true;\n', '        }\n', '\n', '        function removeContract()\n', '        public\n', '        isCreator()\n', '        atEndOfLifecycle()\n', '        {\n', '            selfdestruct(msg.sender);\n', "            // creator gets all money that hasn't be claimed\n", '\n', '\n', '        }\n', '\n', '        function () { throw; }\n', '    }']
