['pragma solidity ^0.4.11;\n', '\n', 'contract ERC20 {\n', '  function transfer(address _to, uint _value);\n', '  function balanceOf(address _owner) constant returns (uint balance);\n', '}\n', '\n', 'contract IOU {\n', '  // Store the amount of IOUs purchased by a buyer\n', '  mapping (address => uint256) public iou_purchased;\n', '\n', '  // Store the amount of ETH sent in by a buyer\n', '  mapping (address => uint256) public eth_sent;\n', '\n', '  // Total IOUs available to sell\n', '  uint256 public total_iou_available = 20000000000000000000;\n', '\n', '  // Total IOUs purchased by all buyers\n', '  uint256 public total_iou_purchased;\n', '\n', '  //  BAT token contract address (IOU offering)\n', '  ERC20 public token = ERC20(0x0D8775F648430679A709E98d2b0Cb6250d2887EF);\n', '\n', '  // The seller&#39;s address (to receive ETH upon distribution, and for auth withdrawTokens())\n', '  address seller = 0x00203F5b27CB688a402fBDBdd2EaF8542ffF72B6;\n', '\n', '  // Safety to withdraw all tokens back to seller in the event any get stranded\n', '  function withdrawTokens() {\n', '    if(msg.sender != seller) throw;\n', '    token.transfer(seller, token.balanceOf(address(this)));\n', '  }\n', '\n', '  function withdrawEth() {\n', '    if(msg.sender != seller) throw;\n', '    msg.sender.transfer(this.balance);\n', '  }\n', '\n', '  function killya() {\n', '    if(msg.sender != seller) throw;\n', '    selfdestruct(seller);\n', '  }\n', '\n', '  function withdraw() payable {\n', '    /*\n', '      Main mechanism to ensure a buyer&#39;s purchase/ETH/IOU is safe.\n', '\n', '      Refund the buyer&#39;s ETH if we&#39;re beyond the date of our distribution\n', '      promise AND if the contract doesn&#39;t have an adequate amount of tokens\n', '      to distribute to the buyer. If we&#39;re beyond the given date, yet there\n', '      is an adequate amount of tokens in the contract&#39;s balance, then the\n', '      buyer can withdraw accordingly. This allows buyers to withdraw well\n', '      into the future if they need to. It also allows us to extend the sale.\n', '      Time-sensitive ETH protection is only applicable if the contract\n', '      doesn&#39;t have adequate tokens for the buyer.\n', '\n', '      The "adequacy" check prevents the seller and/or third party attacker\n', '      from locking down buyers&#39; ETH. i.e. The attacker sends 1 token into our\n', '      contract to falsely signal that the contract has been filled and is ready\n', '      for token distribution. If we simply check for a >0 token balance, we risk\n', '      distribution errors AND stranding/locking the buyer&#39;s ETH.\n', '\n', '      TODO: confirm there are no logical errors that will allow a buyer/attacker to\n', '            withdraw ETH early/unauthorized/doubly/etc\n', '    */\n', '    if(block.number > 3943365 && iou_purchased[msg.sender] > token.balanceOf(address(this))) {\n', '      // We didn&#39;t fulfill our promise to have adequate tokens withdrawable at xx time.\n', '      // Refund the buyer&#39;s ETH automatically instead.\n', '      uint256 eth_to_refund = eth_sent[msg.sender];\n', '\n', '      // If the user doesn&#39;t have any ETH or tokens to withdraw, get out ASAP\n', '      if(eth_to_refund == 0 || iou_purchased[msg.sender] == 0) throw;\n', '\n', '      // Adjust total accurately in the event we allow purchases in the future\n', '      total_iou_purchased -= iou_purchased[msg.sender];\n', '\n', '      // Clear record of buyer&#39;s ETH and IOU balance before refunding\n', '      eth_sent[msg.sender] = 0;\n', '      iou_purchased[msg.sender] = 0;\n', '\n', '      msg.sender.transfer(eth_to_refund);\n', '      return; // ?\n', '    }\n', '\n', '    /*\n', '      At this point, we are still before our distribution date promise.\n', '      Check if there is an adequate amount of tokens in the contract yet\n', '      and allow buyer&#39;s token withdrawal and seller&#39;s ETH distribution if so.\n', '\n', '      TODO: confirm there are no logical errors that will allow a buyer/attacker to\n', '            withdraw IOU tokens early/unauthorized/doubly/etc\n', '    */\n', '    if(token.balanceOf(address(this)) == 0 || iou_purchased[msg.sender] > token.balanceOf(address(this))) throw;\n', '\n', '    uint256 iou_to_withdraw = iou_purchased[msg.sender];\n', '    uint256 eth_to_release = eth_sent[msg.sender];\n', '\n', '    // If the user doesn&#39;t have any IOUs or ETH to withdraw/release, get out ASAP\n', '    if(iou_to_withdraw == 0 || eth_to_release == 0) throw;\n', '\n', '    // Clear record of buyer&#39;s IOU and ETH balance before transferring out\n', '    iou_purchased[msg.sender] = 0;\n', '    eth_sent[msg.sender] = 0;\n', '\n', '    // Distribute tokens to the buyer\n', '    token.transfer(msg.sender, iou_to_withdraw);\n', '\n', '    // Release buyer&#39;s ETH to the seller\n', '    seller.transfer(eth_to_release);\n', '  }\n', '\n', '  function purchase() payable {\n', '    // Check for pre-determined sale start time\n', '    //if(block.number < 3960990) throw;\n', '    // Check if sale window is still open or not (date of promised distribution - grace?)\n', '    //if(block.number > 3990990) throw;\n', '\n', '    // Determine amount of tokens user wants to/can buy\n', '    uint256 iou_to_purchase = 8600 * msg.value; // price is 8600 per ETH\n', '\n', '    // Check if we have enough IOUs left to sell\n', '    if((total_iou_purchased + iou_to_purchase) > total_iou_available) throw;\n', '\n', '    // Update the amount of IOUs purchased by user. Also keep track of the total ETH they sent in\n', '    iou_purchased[msg.sender] += iou_to_purchase;\n', '    eth_sent[msg.sender] += msg.value;\n', '\n', '    // Update the total amount of IOUs purchased by all buyers\n', '    total_iou_purchased += iou_to_purchase;\n', '  }\n', '\n', '  // Fallback function/entry point\n', '  function () payable {\n', '    if(msg.value == 0) { // If the user sent a 0 ETH transaction, withdraw()\n', '      withdraw();\n', '    }\n', '    else { // If the user sent ETH, purchase IOU\n', '      purchase();\n', '    }\n', '  }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', 'contract ERC20 {\n', '  function transfer(address _to, uint _value);\n', '  function balanceOf(address _owner) constant returns (uint balance);\n', '}\n', '\n', 'contract IOU {\n', '  // Store the amount of IOUs purchased by a buyer\n', '  mapping (address => uint256) public iou_purchased;\n', '\n', '  // Store the amount of ETH sent in by a buyer\n', '  mapping (address => uint256) public eth_sent;\n', '\n', '  // Total IOUs available to sell\n', '  uint256 public total_iou_available = 20000000000000000000;\n', '\n', '  // Total IOUs purchased by all buyers\n', '  uint256 public total_iou_purchased;\n', '\n', '  //  BAT token contract address (IOU offering)\n', '  ERC20 public token = ERC20(0x0D8775F648430679A709E98d2b0Cb6250d2887EF);\n', '\n', "  // The seller's address (to receive ETH upon distribution, and for auth withdrawTokens())\n", '  address seller = 0x00203F5b27CB688a402fBDBdd2EaF8542ffF72B6;\n', '\n', '  // Safety to withdraw all tokens back to seller in the event any get stranded\n', '  function withdrawTokens() {\n', '    if(msg.sender != seller) throw;\n', '    token.transfer(seller, token.balanceOf(address(this)));\n', '  }\n', '\n', '  function withdrawEth() {\n', '    if(msg.sender != seller) throw;\n', '    msg.sender.transfer(this.balance);\n', '  }\n', '\n', '  function killya() {\n', '    if(msg.sender != seller) throw;\n', '    selfdestruct(seller);\n', '  }\n', '\n', '  function withdraw() payable {\n', '    /*\n', "      Main mechanism to ensure a buyer's purchase/ETH/IOU is safe.\n", '\n', "      Refund the buyer's ETH if we're beyond the date of our distribution\n", "      promise AND if the contract doesn't have an adequate amount of tokens\n", "      to distribute to the buyer. If we're beyond the given date, yet there\n", "      is an adequate amount of tokens in the contract's balance, then the\n", '      buyer can withdraw accordingly. This allows buyers to withdraw well\n', '      into the future if they need to. It also allows us to extend the sale.\n', '      Time-sensitive ETH protection is only applicable if the contract\n', "      doesn't have adequate tokens for the buyer.\n", '\n', '      The "adequacy" check prevents the seller and/or third party attacker\n', "      from locking down buyers' ETH. i.e. The attacker sends 1 token into our\n", '      contract to falsely signal that the contract has been filled and is ready\n', '      for token distribution. If we simply check for a >0 token balance, we risk\n', "      distribution errors AND stranding/locking the buyer's ETH.\n", '\n', '      TODO: confirm there are no logical errors that will allow a buyer/attacker to\n', '            withdraw ETH early/unauthorized/doubly/etc\n', '    */\n', '    if(block.number > 3943365 && iou_purchased[msg.sender] > token.balanceOf(address(this))) {\n', "      // We didn't fulfill our promise to have adequate tokens withdrawable at xx time.\n", "      // Refund the buyer's ETH automatically instead.\n", '      uint256 eth_to_refund = eth_sent[msg.sender];\n', '\n', "      // If the user doesn't have any ETH or tokens to withdraw, get out ASAP\n", '      if(eth_to_refund == 0 || iou_purchased[msg.sender] == 0) throw;\n', '\n', '      // Adjust total accurately in the event we allow purchases in the future\n', '      total_iou_purchased -= iou_purchased[msg.sender];\n', '\n', "      // Clear record of buyer's ETH and IOU balance before refunding\n", '      eth_sent[msg.sender] = 0;\n', '      iou_purchased[msg.sender] = 0;\n', '\n', '      msg.sender.transfer(eth_to_refund);\n', '      return; // ?\n', '    }\n', '\n', '    /*\n', '      At this point, we are still before our distribution date promise.\n', '      Check if there is an adequate amount of tokens in the contract yet\n', "      and allow buyer's token withdrawal and seller's ETH distribution if so.\n", '\n', '      TODO: confirm there are no logical errors that will allow a buyer/attacker to\n', '            withdraw IOU tokens early/unauthorized/doubly/etc\n', '    */\n', '    if(token.balanceOf(address(this)) == 0 || iou_purchased[msg.sender] > token.balanceOf(address(this))) throw;\n', '\n', '    uint256 iou_to_withdraw = iou_purchased[msg.sender];\n', '    uint256 eth_to_release = eth_sent[msg.sender];\n', '\n', "    // If the user doesn't have any IOUs or ETH to withdraw/release, get out ASAP\n", '    if(iou_to_withdraw == 0 || eth_to_release == 0) throw;\n', '\n', "    // Clear record of buyer's IOU and ETH balance before transferring out\n", '    iou_purchased[msg.sender] = 0;\n', '    eth_sent[msg.sender] = 0;\n', '\n', '    // Distribute tokens to the buyer\n', '    token.transfer(msg.sender, iou_to_withdraw);\n', '\n', "    // Release buyer's ETH to the seller\n", '    seller.transfer(eth_to_release);\n', '  }\n', '\n', '  function purchase() payable {\n', '    // Check for pre-determined sale start time\n', '    //if(block.number < 3960990) throw;\n', '    // Check if sale window is still open or not (date of promised distribution - grace?)\n', '    //if(block.number > 3990990) throw;\n', '\n', '    // Determine amount of tokens user wants to/can buy\n', '    uint256 iou_to_purchase = 8600 * msg.value; // price is 8600 per ETH\n', '\n', '    // Check if we have enough IOUs left to sell\n', '    if((total_iou_purchased + iou_to_purchase) > total_iou_available) throw;\n', '\n', '    // Update the amount of IOUs purchased by user. Also keep track of the total ETH they sent in\n', '    iou_purchased[msg.sender] += iou_to_purchase;\n', '    eth_sent[msg.sender] += msg.value;\n', '\n', '    // Update the total amount of IOUs purchased by all buyers\n', '    total_iou_purchased += iou_to_purchase;\n', '  }\n', '\n', '  // Fallback function/entry point\n', '  function () payable {\n', '    if(msg.value == 0) { // If the user sent a 0 ETH transaction, withdraw()\n', '      withdraw();\n', '    }\n', '    else { // If the user sent ETH, purchase IOU\n', '      purchase();\n', '    }\n', '  }\n', '}']
