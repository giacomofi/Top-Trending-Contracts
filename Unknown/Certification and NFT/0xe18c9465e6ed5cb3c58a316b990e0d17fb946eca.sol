['// VERSION K\n', '\n', 'pragma solidity ^0.4.8;\n', '\n', '\n', '//\n', '// FOR REFERENCE - INCLUDE  iE4RowEscrow  (interface) CONTRACT at the top .....\n', '//\n', '\n', 'contract iE4RowEscrow {\n', '\tfunction getNumGamesStarted() constant returns (int ngames);\n', '}\n', '\n', '// Abstract contract for the full ERC 20 Token standard\n', '// https://github.com/ethereum/EIPs/issues/20\n', '\n', '// ---------------------------------\n', '// ABSTRACT standard token class\n', '// ---------------------------------\n', 'contract Token { \n', '    function totalSupply() constant returns (uint256 supply);\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '// --------------------------\n', '//  E4RowRewards - abstract e4 dividend contract\n', '// --------------------------\n', 'contract E4RowRewards\n', '{\n', '\tfunction checkDividends(address _addr) constant returns(uint _amount);\n', '\tfunction withdrawDividends() public returns (uint namount);\n', '}\n', '\n', '// --------------------------\n', '//  Finney Chip - token contract\n', '// --------------------------\n', 'contract E4Token is Token, E4RowRewards {\n', '    \tevent StatEvent(string msg);\n', '    \tevent StatEventI(string msg, uint val);\n', '\n', '\tenum SettingStateValue  {debug, release, lockedRelease}\n', '\tenum IcoStatusValue {anouncement, saleOpen, saleClosed, failed, succeeded}\n', '\n', '\n', '\n', '\n', '\tstruct tokenAccount {\n', '\t\tbool alloced; // flag to ascert prior allocation\n', '\t\tuint tokens; // num tokens\n', '\t\tuint balance; // rewards balance\n', '\t}\n', '// -----------------------------\n', '//  data storage\n', '// ----------------------------------------\n', '\taddress developers; // developers token holding address\n', '\taddress public owner; // deployer executor\n', '\taddress founderOrg; // founder orginaization contract\n', '\taddress auxPartner; // aux partner (pr/auditing) - 1 percent upon close\n', '\taddress e4_partner; // e4row  contract addresses\n', '\n', '\n', '\tmapping (address => tokenAccount) holderAccounts ; // who holds how many tokens (high two bytes contain curPayId)\n', '\tmapping (uint => address) holderIndexes ; // for iteration thru holder\n', '\tuint numAccounts;\n', '\n', '\tuint partnerCredits; // amount partner (e4row)  has paid\n', '\tmapping (address => mapping (address => uint256)) allowed; // approvals\n', '\n', '\n', '\tuint maxMintableTokens; // ...\n', '\tuint minIcoTokenGoal;// token goal by sale end\n', '\tuint minUsageGoal; //  num games goal by usage deadline\n', '\tuint public  tokenPrice; // price per token\n', '\tuint public payoutThreshold; // threshold till payout\n', '\n', '\tuint totalTokenFundsReceived; \t// running total of token funds received\n', '\tuint public totalTokensMinted; \t// total number of tokens minted\n', '\tuint public holdoverBalance; \t\t// hold this amount until threshhold before reward payout\n', '\tint public payoutBalance; \t\t// hold this amount until threshhold before reward payout\n', '\tint prOrigPayoutBal;\t\t\t// original payout balance before run\n', '\tuint prOrigTokensMint; \t\t\t// tokens minted at start of pay run\n', '\tuint public curPayoutId;\t\t// current payout id\n', '\tuint public lastPayoutIndex;\t\t// payout idx between run segments\n', '\tuint public maxPaysPer;\t\t\t// num pays per segment\n', '\tuint public minPayInterval;\t\t// min interval between start pay run\n', '\n', '\n', '\tuint fundingStart; \t\t// funding start time immediately after anouncement\n', '\tuint fundingDeadline; \t\t// funding end time\n', '\tuint usageDeadline; \t\t// deadline where minimum usage needs to be met before considered success\n', '\tuint public lastPayoutTime; \t// timestamp of last payout time\n', '\tuint vestTime; \t\t// 1 year past sale vest developer tokens\n', '\tuint numDevTokens; \t// 10 per cent of tokens after close to developers\n', '\tbool developersGranted; \t\t// flag\n', '\tuint remunerationStage; \t// 0 for not yet, 1 for 10 percent, 2 for remaining  upon succeeded.\n', '\tuint public remunerationBalance; \t// remuneration balance to release token funds\n', '\tuint auxPartnerBalance; \t// aux partner balance - 1 percent\n', '\tuint rmGas; // remuneration gas\n', '\tuint rwGas; // reward gas\n', '\tuint rfGas; // refund gas\n', '\n', '\tIcoStatusValue icoStatus;  // current status of ico\n', '\tSettingStateValue public settingsState;\n', '\n', '\n', '\t// --------------------\n', '\t// contract constructor\n', '\t// --------------------\n', '\tfunction E4Token() \n', '\t{\n', '\t\towner = msg.sender;\n', '\t\tdevelopers = msg.sender;\n', '\t}\n', '\n', '\t// -----------------------------------\n', '\t// use this to reset everything, will never be called after lockRelease\n', '\t// -----------------------------------\n', '\tfunction applySettings(SettingStateValue qState, uint _saleStart, uint _saleEnd, uint _usageEnd, uint _minUsage, uint _tokGoal, uint  _maxMintable, uint _threshold, uint _price, uint _mpp, uint _mpi )\n', '\t{\n', '\t\tif (msg.sender != owner) \n', '\t\t\treturn;\n', '\n', '\t\t// these settings are permanently tweakable for performance adjustments\n', '\t\tpayoutThreshold = _threshold;\n', '\t\tmaxPaysPer = _mpp;\n', '\t\tminPayInterval = _mpi;\n', '\n', '\t\t// this first test checks if already locked\n', '\t\tif (settingsState == SettingStateValue.lockedRelease)\n', '\t\t\treturn;\n', '\n', ' \t \tsettingsState = qState;\n', '\n', '\t\t// this second test allows locking without changing other permanent settings\n', "\t\t// WARNING, MAKE SURE YOUR'RE HAPPY WITH ALL SETTINGS \n", '\t\t// BEFORE LOCKING\n', '\n', '\t\tif (qState == SettingStateValue.lockedRelease) {\n', '\t\t\tStatEvent("Locking!");\n', '\t\t\treturn;\n', '\t\t}\n', '\n', '\t\ticoStatus = IcoStatusValue.anouncement;\n', '\n', '\t\trmGas = 100000; // remuneration gas\n', '\t\trwGas = 10000; // reward gas\n', '\t\trfGas = 10000; // refund gas\n', '\n', '\n', '\t\t// zero out all token holders.  \n', '\t\t// leave alloced on, leave num accounts\n', '\t\t// cant delete them anyways\n', '\t\n', '\t\tif (totalTokensMinted > 0) {\n', '\t\t\tfor (uint i = 0; i < numAccounts; i++ ) {\n', '\t\t\t\taddress a = holderIndexes[i];\n', '\t\t\t\tif (a != address(0)) {\n', '\t\t\t\t\tholderAccounts[a].tokens = 0;\n', '\t\t\t\t\tholderAccounts[a].balance = 0;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t// do not reset numAccounts!\n', '\n', '\t\ttotalTokensMinted = 0; // this will erase\n', '\t\ttotalTokenFundsReceived = 0; // this will erase.\n', '\t\tpartnerCredits = 0; // reset all partner credits\n', '\n', '\t\tfundingStart =  _saleStart;\n', '\t\tfundingDeadline = _saleEnd;\n', '\t\tusageDeadline = _usageEnd;\n', '\t\tminUsageGoal = _minUsage;\n', '\t\tminIcoTokenGoal = _tokGoal;\n', '\t\tmaxMintableTokens = _maxMintable;\n', '\t\ttokenPrice = _price;\n', '\n', '\t\tvestTime = fundingStart + (365 days);\n', '\t\tnumDevTokens = 0;\n', '\t\t\n', '\t\tholdoverBalance = 0;\n', '\t\tpayoutBalance = 0;\n', '\t\tcurPayoutId = 1;\n', '\t\tlastPayoutIndex = 0;\n', '\t\tremunerationStage = 0;\n', '\t\tremunerationBalance = 0;\n', '\t\tauxPartnerBalance = 0;\n', '\t\tdevelopersGranted = false;\n', '\t\tlastPayoutTime = 0;\n', '\n', '\t\tif (this.balance > 0) {\n', '\t\t\tif (!owner.call.gas(rfGas).value(this.balance)())\n', '\t\t\t\tStatEvent("ERROR!");\n', '\t\t}\n', '\t\tStatEvent("ok");\n', '\n', '\t}\n', '\n', '\n', '\t// ---------------------------------------------------\n', '\t// tokens held reserve the top two bytes for the payid last paid.\n', '\t// this is so holders at the top of the list dont transfer tokens \n', '\t// to themselves on the bottom of the list thus scamming the \n', '\t// system. this function deconstructs the tokenheld value.\n', '\t// ---------------------------------------------------\n', '\tfunction getPayIdAndHeld(uint _tokHeld) internal returns (uint _payId, uint _held)\n', '\t{\n', '\t\t_payId = (_tokHeld / (2 ** 48)) & 0xffff;\n', '\t\t_held = _tokHeld & 0xffffffffffff;\n', '\t}\n', '\tfunction getHeld(uint _tokHeld) internal  returns (uint _held)\n', '\t{\n', '\t\t_held = _tokHeld & 0xffffffffffff;\n', '\t}\n', '\t// ---------------------------------------------------\n', '\t// allocate a new account by setting alloc to true\n', '\t// set the top to bytes of tokens to cur pay id to leave out of current round\n', '\t// add holder index, bump the num accounts\n', '\t// ---------------------------------------------------\n', '\tfunction addAccount(address _addr) internal  {\n', '\t\tholderAccounts[_addr].alloced = true;\n', '\t\tholderAccounts[_addr].tokens = (curPayoutId * (2 ** 48));\n', '\t\tholderIndexes[numAccounts++] = _addr;\n', '\t}\n', '\t\n', '\n', '// --------------------------------------\n', '// BEGIN ERC-20 from StandardToken\n', '// --------------------------------------\n', '\tfunction totalSupply() constant returns (uint256 supply)\n', '\t{\n', '\t\tif (icoStatus == IcoStatusValue.saleOpen\n', '\t\t\t|| icoStatus == IcoStatusValue.anouncement)\n', '\t\t\tsupply = maxMintableTokens;\n', '\t\telse\n', '\t\t\tsupply = totalTokensMinted;\n', '\t}\n', '\n', '\tfunction transfer(address _to, uint256 _value) returns (bool success) {\n', '\n', '\t\tif ((msg.sender == developers) \n', '\t\t\t&&  (now < vestTime)) {\n', '\t\t\t//statEvent("Tokens not yet vested.");\n', '\t\t\treturn false;\n', '\t\t}\n', '\n', '\n', "\t        //Default assumes totalSupply can't be over max (2^256 - 1).\n", "\t        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n", '\t        //Replace the if with this one instead.\n', '\t        //if (holderAccounts[msg.sender] >= _value && balances[_to] + _value > holderAccounts[_to]) {\n', '\n', '\t\tvar (pidFrom, heldFrom) = getPayIdAndHeld(holderAccounts[msg.sender].tokens);\n', '\t        if (heldFrom >= _value && _value > 0) {\n', '\n', '\t            holderAccounts[msg.sender].tokens -= _value;\n', '\n', '\t\t    if (!holderAccounts[_to].alloced) {\n', '\t\t\taddAccount(_to);\n', '\t\t    }\n', '\n', '\t\t    uint newHeld = _value + getHeld(holderAccounts[_to].tokens);\n', '\t\t    holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48));\n', '\t            Transfer(msg.sender, _to, _value);\n', '\t            return true;\n', '\t        } else { \n', '\t\t\treturn false; \n', '\t\t}\n', '    \t}\n', '\n', '    \tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '\n', '\t\tif ((_from == developers) \n', '\t\t\t&&  (now < vestTime)) {\n', '\t\t\t//statEvent("Tokens not yet vested.");\n', '\t\t\treturn false;\n', '\t\t}\n', '\n', '\n', '        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n', '        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '\n', '\t\tvar (pidFrom, heldFrom) = getPayIdAndHeld(holderAccounts[_from].tokens);\n', '        \tif (heldFrom >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '\t            holderAccounts[_from].tokens -= _value;\n', '\n', '\t\t    if (!holderAccounts[_to].alloced)\n', '\t\t\taddAccount(_to);\n', '\n', '\t\t    uint newHeld = _value + getHeld(holderAccounts[_to].tokens);\n', '\n', '\t\t    holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48));\n', '\t            allowed[_from][msg.sender] -= _value;\n', '\t            Transfer(_from, _to, _value);\n', '\t            return true;\n', '\t        } else { \n', '\t\t    return false; \n', '\t\t}\n', '\t}\n', '\n', '\n', '    \tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n', '\t\t// vars default to 0\n', '\t\tif (holderAccounts[_owner].alloced) {\n', '\t        \tbalance = getHeld(holderAccounts[_owner].tokens);\n', '\t\t} \n', '    \t}\n', '\n', '    \tfunction approve(address _spender, uint256 _value) returns (bool success) {\n', '        \tallowed[msg.sender][_spender] = _value;\n', '        \tApproval(msg.sender, _spender, _value);\n', '        \treturn true;\n', '    \t}\n', '\n', '    \tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      \t\treturn allowed[_owner][_spender];\n', '    \t}\n', '// ----------------------------------\n', '// END ERC20\n', '// ----------------------------------\n', '\n', '  \n', '\n', '\n', '\n', '\t// -------------------------------------------\n', '\t// default payable function.\n', '\t// if sender is e4row  partner, this is a rake fee payment\n', '\t// otherwise this is a token purchase.\n', '\t// tokens only purchaseable between tokenfundingstart and end\n', '\t// -------------------------------------------\n', '\tfunction () payable {\n', '\t\tif (msg.sender == e4_partner) {\n', '\t\t     feePayment(); // from e4row game escrow contract\n', '\t\t} else {\n', '\t\t     purchaseToken();\n', '\t\t}\n', '\t}\n', '\n', '\t// -----------------------------\n', '\t// purchase token function - tokens only sold during sale period up until the max tokens\n', '\t// purchase price is tokenPrice.  all units in wei.\n', '\t// purchaser will not be included in current pay run\n', '\t// -----------------------------\n', '\tfunction purchaseToken() payable {\n', '\n', '\t\tuint nvalue = msg.value; // being careful to preserve msg.value\n', '\t\taddress npurchaser = msg.sender;\n', '\t\tif (nvalue < tokenPrice) \n', '\t\t\tthrow;\n', '\n', '\t\tuint qty = nvalue/tokenPrice;\n', '\t\tupdateIcoStatus();\n', '\t\tif (icoStatus != IcoStatusValue.saleOpen) // purchase is closed\n', '\t\t\tthrow;\n', '\t\tif (totalTokensMinted + qty > maxMintableTokens)\n', '\t\t\tthrow;\n', '\t\tif (!holderAccounts[npurchaser].alloced)\n', '\t\t\taddAccount(npurchaser);\n', '\t\t\n', '\t\t// purchaser waits for next payrun. otherwise can disrupt cur pay run\n', '\t\tuint newHeld = qty + getHeld(holderAccounts[npurchaser].tokens);\n', '\t\tholderAccounts[npurchaser].tokens = newHeld | (curPayoutId * (2 ** 48));\n', '\n', '\t\ttotalTokensMinted += qty;\n', '\t\ttotalTokenFundsReceived += nvalue;\n', '\n', '\t\tif (totalTokensMinted == maxMintableTokens) {\n', '\t\t\ticoStatus = IcoStatusValue.saleClosed;\n', '\t\t\t//test unnecessary -  if (getNumTokensPurchased() >= minIcoTokenGoal)\n', '\t\t\tdoDeveloperGrant();\n', '\t\t\tStatEventI("Purchased,Granted", qty);\n', '\t\t} else\n', '\t\t\tStatEventI("Purchased", qty);\n', '\n', '\t}\n', '\n', '\n', '\t// ---------------------------\n', '\t// accept payment from e4row contract\n', '\t// DO NOT CALL THIS FUNCTION LEST YOU LOSE YOUR MONEY\n', '\t// ---------------------------\n', '\tfunction feePayment() payable  \n', '\t{\n', '\t\tif (msg.sender != e4_partner) {\n', '\t\t\tStatEvent("forbidden");\n', '\t\t\treturn; // thank you\n', '\t\t}\n', '\t\tuint nfvalue = msg.value; // preserve value in case changed in dev grant\n', '\n', '\t\tupdateIcoStatus();\n', '\n', '\t\tholdoverBalance += nfvalue;\n', '\t\tpartnerCredits += nfvalue;\n', '\t\tStatEventI("Payment", nfvalue);\n', '\n', '\t\tif (holdoverBalance > payoutThreshold\n', '\t\t\t|| payoutBalance > 0)\n', '\t\t\tdoPayout(maxPaysPer);\n', '\t\t\n', '\t\n', '\t}\n', '\n', '\t// ---------------------------\n', '\t// set the e4row partner, this is only done once\n', '\t// ---------------------------\n', '\tfunction setE4RowPartner(address _addr) public\t\n', '\t{\n', '\t// ONLY owner can set and ONLY ONCE! (unless "unlocked" debug)\n', '\t// once its locked. ONLY ONCE!\n', '\t\tif (msg.sender == owner) {\n', '\t\t\tif ((e4_partner == address(0)) || (settingsState == SettingStateValue.debug)) {\n', '\t\t\t\te4_partner = _addr;\n', '\t\t\t\tpartnerCredits = 0;\n', '\t\t\t\t//StatEventI("E4-Set", 0);\n', '\t\t\t} else {\n', '\t\t\t\tStatEvent("Already Set");\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\t// ----------------------------\n', '\t// return the total tokens purchased\n', '\t// ----------------------------\n', '\tfunction getNumTokensPurchased() constant returns(uint _purchased)\n', '\t{\n', '\t\t_purchased = totalTokensMinted-numDevTokens;\n', '\t}\n', '\n', '\t// ----------------------------\n', '\t// return the num games as reported from the e4row  contract\n', '\t// ----------------------------\n', '\tfunction getNumGames() constant returns(uint _games)\n', '\t{\n', '\t\t//_games = 0;\n', '\t\tif (e4_partner != address(0)) {\n', '\t\t\tiE4RowEscrow pe4 = iE4RowEscrow(e4_partner);\n', '\t\t\t_games = uint(pe4.getNumGamesStarted());\n', '\t\t} \n', '\t\t//else\n', '\t\t//StatEvent("Empty E4");\n', '\t}\n', '\n', '\t// ------------------------------------------------\n', '\t// get the founders, auxPartner, developer\n', '\t// --------------------------------------------------\n', '\tfunction getSpecialAddresses() constant returns (address _fndr, address _aux, address _dev, address _e4)\n', '\t{\n', '\t\t//if (_sender == owner) { // no msg.sender on constant functions at least in mew\n', '\t\t\t_fndr = founderOrg;\n', '\t\t\t_aux = auxPartner;\n', '\t\t\t_dev = developers;\n', '\t\t\t_e4  = e4_partner;\n', '\t\t//}\n', '\t}\n', '\n', '\n', '\n', '\t// ----------------------------\n', '\t// update the ico status\n', '\t// ----------------------------\n', '\tfunction updateIcoStatus() public\n', '\t{\n', '\t\tif (icoStatus == IcoStatusValue.succeeded \n', '\t\t\t|| icoStatus == IcoStatusValue.failed)\n', '\t\t\treturn;\n', '\t\telse if (icoStatus == IcoStatusValue.anouncement) {\n', '\t\t\tif (now > fundingStart && now <= fundingDeadline) {\n', '\t\t\t\ticoStatus = IcoStatusValue.saleOpen;\n', '\t\t\t\t\n', '\t\t\t} else if (now > fundingDeadline) {\n', '\t\t\t\t// should not be here - this will eventually fail\n', '\t\t\t\ticoStatus = IcoStatusValue.saleClosed;\n', '\t\t\t}\n', '\t\t} else {\n', '\t\t\tuint numP = getNumTokensPurchased();\n', '\t\t\tuint numG = getNumGames();\n', '\t\t\tif ((now > fundingDeadline && numP < minIcoTokenGoal)\n', '\t\t\t\t|| (now > usageDeadline && numG < minUsageGoal)) {\n', '\t\t\t\ticoStatus = IcoStatusValue.failed;\n', '\t\t\t} else if ((now > fundingDeadline) // dont want to prevent more token sales\n', '\t\t\t\t&& (numP >= minIcoTokenGoal)\n', '\t\t\t\t&& (numG >= minUsageGoal)) {\n', '\t\t\t\ticoStatus = IcoStatusValue.succeeded; // hooray\n', '\t\t\t}\n', '\t\t\tif (icoStatus == IcoStatusValue.saleOpen\n', '\t\t\t\t&& ((numP >= maxMintableTokens)\n', '\t\t\t\t|| (now > fundingDeadline))) {\n', '\t\t\t\t\ticoStatus = IcoStatusValue.saleClosed;\n', '\t\t\t\t}\n', '\t\t}\n', '\n', '\t\tif (!developersGranted\n', '\t\t\t&& icoStatus != IcoStatusValue.saleOpen \n', '\t\t\t&& icoStatus != IcoStatusValue.anouncement\n', '\t\t\t&& getNumTokensPurchased() >= minIcoTokenGoal) {\n', '\t\t\t\tdoDeveloperGrant(); // grant whenever status goes from open to anything...\n', '\t\t}\n', '\n', '\t\n', '\t}\n', '\n', '\t\n', '\t// ----------------------------\n', '\t// request refund. Caller must call to request and receive refund \n', '\t// WARNING - withdraw rewards/dividends before calling.\n', '\t// YOU HAVE BEEN WARNED\n', '\t// ----------------------------\n', '\tfunction requestRefund()\n', '\t{\n', '\t\taddress nrequester = msg.sender;\n', '\t\tupdateIcoStatus();\n', '\n', '\t\tuint ntokens = getHeld(holderAccounts[nrequester].tokens);\n', '\t\tif (icoStatus != IcoStatusValue.failed)\n', '\t\t\tStatEvent("No Refund");\n', '\t\telse if (ntokens == 0)\n', '\t\t\tStatEvent("No Tokens");\n', '\t\telse {\n', '\t\t\tuint nrefund = ntokens * tokenPrice;\n', '\t\t\tif (getNumTokensPurchased() >= minIcoTokenGoal)\n', '\t\t\t\tnrefund -= (nrefund /10); // only 90 percent b/c 10 percent payout\n', '\n', '\t\t\tholderAccounts[developers].tokens += ntokens;\n', '\t\t\tholderAccounts[nrequester].tokens = 0;\n', '\t\t\tif (holderAccounts[nrequester].balance > 0) {\n', '\t\t\t\t// see above warning!!\n', '\t\t\t\tif (!holderAccounts[developers].alloced) \n', '\t\t\t\t\taddAccount(developers);\n', '\t\t\t\tholderAccounts[developers].balance += holderAccounts[nrequester].balance;\n', '\t\t\t\tholderAccounts[nrequester].balance = 0;\n', '\t\t\t}\n', '\n', '\t\t\tif (!nrequester.call.gas(rfGas).value(nrefund)())\n', '\t\t\t\tthrow;\n', '\t\t\t//StatEventI("Refunded", nrefund);\n', '\t\t}\n', '\t}\n', '\n', '\n', '\n', '\t// ---------------------------------------------------\n', '\t// payout rewards to all token holders\n', '\t// use a second holding variable called PayoutBalance to do \n', '\t// the actual payout from b/c too much gas to iterate thru \n', '\t// each payee. Only start a new run at most once per "minpayinterval".\n', '\t// Its done in runs of "_numPays"\n', '\t// we use special coding for the holderAccounts to avoid a hack\n', '\t// of getting paid at the top of the list then transfering tokens\n', '\t// to another address at the bottom of the list.\n', '\t// because of that each holderAccounts entry gets the payoutid stamped upon it (top two bytes)\n', '\t// also a token transfer will transfer the payout id.\n', '\t// ---------------------------------------------------\n', '\tfunction doPayout(uint _numPays)  internal\n', '\t{\n', '\t\tif (totalTokensMinted == 0)\n', '\t\t\treturn;\n', '\n', '\t\tif ((holdoverBalance > 0) \n', '\t\t\t&& (payoutBalance == 0)\n', '\t\t\t&& (now > (lastPayoutTime+minPayInterval))) {\n', '\t\t\t// start a new run\n', '\t\t\tcurPayoutId++;\n', '\t\t\tif (curPayoutId >= 32768)\n', '\t\t\t\tcurPayoutId = 1;\n', '\t\t\tlastPayoutTime = now;\n', '\t\t\tpayoutBalance = int(holdoverBalance);\n', '\t\t\tprOrigPayoutBal = payoutBalance;\n', '\t\t\tprOrigTokensMint = totalTokensMinted;\n', '\t\t\tholdoverBalance = 0;\n', '\t\t\tlastPayoutIndex = 0;\n', '\t\t\tStatEventI("StartRun", uint(curPayoutId));\n', '\t\t} else if (payoutBalance > 0) {\n', '\t\t\t// work down the p.o.b\n', '\t\t\tuint nAmount;\n', '\t\t\tuint nPerTokDistrib = uint(prOrigPayoutBal)/prOrigTokensMint;\n', '\t\t\tuint paids = 0;\n', '\t\t\tuint i; // intentional\n', '\t\t\tfor (i = lastPayoutIndex; (paids < _numPays) && (i < numAccounts) && (payoutBalance > 0); i++ ) {\n', '\t\t\t\taddress a = holderIndexes[i];\n', '\t\t\t\tif (a == address(0)) {\n', '\t\t\t\t\tcontinue;\n', '\t\t\t\t}\n', '\t\t\t\tvar (pid, held) = getPayIdAndHeld(holderAccounts[a].tokens);\n', '\t\t\t\tif ((held > 0) && (pid != curPayoutId)) {\n', '\t\t\t\t\tnAmount = nPerTokDistrib * held;\n', '\t\t\t\t\tif (int(nAmount) <= payoutBalance){\n', '\t\t\t\t\t\tholderAccounts[a].balance += nAmount; \n', '\t\t\t\t\t\tholderAccounts[a].tokens = (curPayoutId * (2 ** 48)) | held;\n', '\t\t\t\t\t\tpayoutBalance -= int(nAmount);\t\t\t\t\t\n', '\t\t\t\t\t\tpaids++;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\tlastPayoutIndex = i;\n', '\t\t\tif (lastPayoutIndex >= numAccounts || payoutBalance <= 0) {\n', '\t\t\t\tlastPayoutIndex = 0;\n', '\t\t\t\tif (payoutBalance > 0)\n', '\t\t\t\t\tholdoverBalance += uint(payoutBalance);// put back any leftovers\n', '\t\t\t\tpayoutBalance = 0;\n', '\t\t\t\tStatEventI("RunComplete", uint(prOrigPayoutBal) );\n', '\n', '\t\t\t} else {\n', '\t\t\t\tStatEventI("PayRun", paids );\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t}\n', '\n', '\n', '\t// ----------------------------\n', '\t// sender withdraw entire rewards/dividends\n', '\t// ----------------------------\n', '\tfunction withdrawDividends() public returns (uint _amount)\n', '\t{\n', '\t\tif (holderAccounts[msg.sender].balance == 0) { \n', '\t\t\t//_amount = 0;\n', '\t\t\tStatEvent("0 Balance");\n', '\t\t\treturn;\n', '\t\t} else {\n', '\t\t\tif ((msg.sender == developers) \n', '\t\t\t\t&&  (now < vestTime)) {\n', '\t\t\t\t//statEvent("Tokens not yet vested.");\n', '\t\t\t\t//_amount = 0;\n', '\t\t\t\treturn;\n', '\t\t\t}\n', '\n', '\t\t\t_amount = holderAccounts[msg.sender].balance; \n', '\t\t\tholderAccounts[msg.sender].balance = 0; \n', '\t\t\tif (!msg.sender.call.gas(rwGas).value(_amount)())\n', '\t\t\t\tthrow;\n', '\t\t\t//StatEventI("Paid", _amount);\n', '\t\n', '\t\t}\n', '\n', '\t}\n', '\n', '\t// ----------------------------\n', '\t// set gas for operations\n', '\t// ----------------------------\n', '\tfunction setOpGas(uint _rm, uint _rf, uint _rw)\n', '\t{\n', '\t\tif (msg.sender != owner && msg.sender != developers) {\n', '\t\t\t//StatEvent("only owner calls");\n', '\t\t\treturn;\n', '\t\t} else {\n', '\t\t\trmGas = _rm;\n', '\t\t\trfGas = _rf;\n', '\t\t\trwGas = _rw;\n', '\t\t}\n', '\t}\n', '\n', '\t// ----------------------------\n', '\t// get gas for operations\n', '\t// ----------------------------\n', '\tfunction getOpGas() constant returns (uint _rm, uint _rf, uint _rw)\n', '\t{\n', '\t\t_rm = rmGas;\n', '\t\t_rf = rfGas;\n', '\t\t_rw = rwGas;\n', '\t}\n', ' \n', '\n', '\t// ----------------------------\n', '\t// check rewards.  pass in address of token holder\n', '\t// ----------------------------\n', '\tfunction checkDividends(address _addr) constant returns(uint _amount)\n', '\t{\n', '\t\tif (holderAccounts[_addr].alloced)\n', '\t\t\t_amount = holderAccounts[_addr].balance;\n', '\t}\t\t\n', '\n', '\n', '\t// ------------------------------------------------\n', '\t// icoCheckup - check up call for administrators\n', '\t// after sale is closed if min ico tokens sold, 10 percent will be distributed to \n', '\t// company to cover various operating expenses\n', '\t// after sale and usage dealines have been met, remaining 90 percent will be distributed to\n', '\t// company.\n', '\t// ------------------------------------------------\n', '\tfunction icoCheckup() public\n', '\t{\n', '\t\tif (msg.sender != owner && msg.sender != developers)\n', '\t\t\tthrow;\n', '\n', '\t\tuint nmsgmask;\n', '\t\t//nmsgmask = 0;\n', '\t\n', '\t\tif (icoStatus == IcoStatusValue.saleClosed) {\n', '\t\t\tif ((getNumTokensPurchased() >= minIcoTokenGoal)\n', '\t\t\t\t&& (remunerationStage == 0 )) {\n', '\t\t\t\tremunerationStage = 1;\n', '\t\t\t\tremunerationBalance = (totalTokenFundsReceived/100)*9; // 9 percent\n', '\t\t\t\tauxPartnerBalance =  (totalTokenFundsReceived/100); // 1 percent\n', '\t\t\t\tnmsgmask |= 1;\n', '\t\t\t} \n', '\t\t}\n', '\t\tif (icoStatus == IcoStatusValue.succeeded) {\n', '\t\t\n', '\t\t\tif (remunerationStage == 0 ) {\n', '\t\t\t\tremunerationStage = 1;\n', '\t\t\t\tremunerationBalance = (totalTokenFundsReceived/100)*9; \n', '\t\t\t\tauxPartnerBalance =  (totalTokenFundsReceived/100);\n', '\t\t\t\tnmsgmask |= 4;\n', '\t\t\t}\n', '\t\t\tif (remunerationStage == 1) { // we have already suceeded\n', '\t\t\t\tremunerationStage = 2;\n', '\t\t\t\tremunerationBalance += totalTokenFundsReceived - (totalTokenFundsReceived/10); // 90 percent\n', '\t\t\t\tnmsgmask |= 8;\n', '\t\t\t}\n', '\n', '\t\t}\n', '\n', '\t\tuint ntmp;\n', '\n', '\t\tif (remunerationBalance > 0) { \n', '\t\t// only pay one entity per call, dont want to run out of gas\n', '\t\t\t\tntmp = remunerationBalance;\n', '\t\t\t\tremunerationBalance = 0;\n', '\t\t\t\tif (!founderOrg.call.gas(rmGas).value(ntmp)()) {\n', '\t\t\t\t\tremunerationBalance = ntmp;\n', '\t\t\t\t\tnmsgmask |= 32;\n', '\t\t\t\t} else {\n', '\t\t\t\t\tnmsgmask |= 64;\n', '\t\t\t\t}\t\n', '\t\t} else \tif (auxPartnerBalance > 0) {\n', '\t\t// note the "else" only pay one entity per call, dont want to run out of gas\n', '\t\t\tntmp = auxPartnerBalance;\n', '\t\t\tauxPartnerBalance = 0;\n', '\t\t\tif (!auxPartner.call.gas(rmGas).value(ntmp)()) {\n', '\t\t\t\tauxPartnerBalance = ntmp;\n', '\t\t\t\tnmsgmask |= 128;\n', '\t\t\t}  else {\n', '\t\t\t\tnmsgmask |= 256;\n', '\t\t\t}\n', '\n', '\t\t} \n', '\t\t\n', '\t\tStatEventI("ico-checkup", nmsgmask);\n', '\t}\n', '\n', '\n', '\t// ----------------------------\n', '\t// swap executor\n', '\t// ----------------------------\n', '\tfunction changeOwner(address _addr) \n', '\t{\n', '\t\tif (msg.sender != owner\n', '\t\t\t|| settingsState == SettingStateValue.lockedRelease)\n', '\t\t\t throw;\n', '\n', '\t\towner = _addr;\n', '\t}\n', '\n', '\t// ----------------------------\n', '\t// swap developers account\n', '\t// ----------------------------\n', '\tfunction changeDevevoperAccont(address _addr) \n', '\t{\n', '\t\tif (msg.sender != owner\n', '\t\t\t|| settingsState == SettingStateValue.lockedRelease)\n', '\t\t\t throw;\n', '\t\tdevelopers = _addr;\n', '\t}\n', '\n', '\t// ----------------------------\n', '\t// change founder\n', '\t// ----------------------------\n', '\tfunction changeFounder(address _addr) \n', '\t{\n', '\t\tif (msg.sender != owner\n', '\t\t\t|| settingsState == SettingStateValue.lockedRelease)\n', '\t\t\t throw;\n', '\t\tfounderOrg = _addr;\n', '\t}\n', '\n', '\t// ----------------------------\n', '\t// change auxPartner\n', '\t// ----------------------------\n', '\tfunction changeAuxPartner(address _aux) \n', '\t{\n', '\t\tif (msg.sender != owner\n', '\t\t\t|| settingsState == SettingStateValue.lockedRelease)\n', '\t\t\t throw;\n', '\t\tauxPartner = _aux;\n', '\t}\n', '\n', '\n', '\t// ----------------------------\n', '\t// DEBUG ONLY - end this contract, suicide to developers\n', '\t// ----------------------------\n', '\tfunction haraKiri()\n', '\t{\n', '\t\tif (settingsState != SettingStateValue.debug)\n', '\t\t\tthrow;\n', '\t\tif (msg.sender != owner)\n', '\t\t\t throw;\n', '\t\tsuicide(developers);\n', '\t}\n', '\n', '\t// ----------------------------\n', '\t// get all ico status, funding and usage info\n', '\t// ----------------------------\n', '\tfunction getIcoInfo() constant returns(IcoStatusValue _status, uint _saleStart, uint _saleEnd, uint _usageEnd, uint _saleGoal, uint _usageGoal, uint _sold, uint _used, uint _funds, uint _credits, uint _remuStage, uint _vest)\n', '\t{\n', '\t\t_status = icoStatus;\n', '\t\t_saleStart = fundingStart;\n', '\t\t_saleEnd = fundingDeadline;\n', '\t\t_usageEnd = usageDeadline;\n', '\t\t_vest = vestTime;\n', '\t\t_saleGoal = minIcoTokenGoal;\n', '\t\t_usageGoal = minUsageGoal;\n', '\t\t_sold = getNumTokensPurchased();\n', '\t\t_used = getNumGames();\n', '\t\t_funds = totalTokenFundsReceived;\n', '\t\t_credits = partnerCredits;\n', '\t\t_remuStage = remunerationStage;\n', '\t}\n', '\n', '\t// ----------------------------\n', '\t// NOTE! CALL AT THE RISK OF RUNNING OUT OF GAS.\n', '\t// ANYONE CAN CALL THIS FUNCTION BUT YOU HAVE TO SUPPLY \n', '\t// THE CORRECT AMOUNT OF GAS WHICH MAY DEPEND ON \n', '\t// THE _NUMPAYS PARAMETER.  WHICH MUST BE BETWEEN 1 AND 1000\n', '\t// THE STANDARD VALUE IS STORED IN "maxPaysPer"\n', '\t// ----------------------------\n', '\tfunction flushDividends(uint _numPays)\n', '\t{\n', '\t\tif ((_numPays == 0) || (_numPays > 1000)) {\n', '\t\t\tStatEvent("Invalid.");\n', '\t\t} else if (holdoverBalance > 0 || payoutBalance > 0) {\n', '\t\t\tdoPayout(_numPays);\n', '\t\t} else {\n', '\t\t\tStatEvent("Nothing to do.");\n', '\t\t}\n', '\t\t\t\t\n', '\t}\n', '\n', '\tfunction doDeveloperGrant() internal\n', '\t{\n', '\t\tif (!developersGranted) {\n', '\t\t\tdevelopersGranted = true;\n', '\t\t\tnumDevTokens = (totalTokensMinted * 15)/100;\n', '\t\t\ttotalTokensMinted += numDevTokens;\n', '\t\t\tif (!holderAccounts[developers].alloced) \n', '\t\t\t\taddAccount(developers);\n', '\t\t\tuint newHeld = getHeld(holderAccounts[developers].tokens) + numDevTokens;\n', '\t\t\tholderAccounts[developers].tokens = newHeld |  (curPayoutId * (2 ** 48));\n', '\n', '\t\t}\n', '\t}\n', '\n', '\n', '}']