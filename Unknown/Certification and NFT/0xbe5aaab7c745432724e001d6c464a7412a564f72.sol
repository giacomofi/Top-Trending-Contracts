['//A BurnableOpenPayment is instantiated with a specified payer and a commitThreshold.\n', '//The recipient is not set when the contract is instantiated.\n', '\n', '//The constructor is payable, so the contract can be instantiated with initial funds.\n', '//Only the payer can fund the Payment after instantiation.\n', '\n', '//All behavior of the contract is directed by the payer, but\n', '//the payer can never directly recover the payment unless he becomes the recipient.\n', '\n', '//Anyone can become the recipient by contributing the commitThreshold.\n', '//The recipient cannot change once it&#39;s been set.\n', '\n', '//The payer can at any time choose to burn or release to the recipient any amount of funds.\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', 'contract BurnableOpenPayment {\n', '    //BOP will start with a payer but no recipient (recipient==0x0)\n', '    address public payer;\n', '    address public recipient;\n', '    address constant burnAddress = 0x0;\n', '    \n', '    //Note that these will track, but not influence the BOP logic.\n', '    uint public amountDeposited;\n', '    uint public amountBurned;\n', '    uint public amountReleased;\n', '    \n', '    //payerString and recipientString enable rudimentary communication/publishing.\n', '    //Although the two parties might quickly move to another medium with better privacy or convenience,\n', '    //beginning with this is nice because it&#39;s already trustless/transparent/signed/pseudonymous/etc.\n', '    string public payerString;\n', '    string public recipientString;\n', '    \n', '    //Amount of ether a prospective recipient must pay to become (permanently) the recipient. See commit().\n', '    uint public commitThreshold;\n', '    \n', '    //What if the payer falls off the face of the planet?\n', '    //A BOP is instantiated with a chosen defaultAction, and this cannot be changed.\n', '    enum DefaultAction {None, Release, Burn}\n', '    DefaultAction public defaultAction;\n', '    \n', '    //if defaultAction != None, how long should we wait before giving up?\n', '    //Set in constructor:\n', '    uint public defaultTimeoutLength;\n', '    \n', '    //Calculated from defaultTimeoutLength on a successful recipient commit(),\n', '    //as well as whenever the payer (or possibly the recipient) calls delayDefaultAction()\n', '    uint public defaultTriggerTime;\n', '    \n', '    //Most action happens in the Committed state.\n', '    enum State {Open, Committed, Expended}\n', '    State public state;\n', '    //Note that a BOP cannot go from Committed back to Open, but it can go from Expended back to Committed\n', '    //(this would retain the committed recipient). Search for Expended and Unexpended events to see how this works.\n', '    \n', '    modifier inState(State s) { if (s != state) throw; _; }\n', '    modifier onlyPayer() { if (msg.sender != payer) throw; _; }\n', '    modifier onlyRecipient() { if (msg.sender != recipient) throw; _; }\n', '    modifier onlyPayerOrRecipient() { if ((msg.sender != payer) && (msg.sender != recipient)) throw; _; }\n', '    \n', '    event FundsAdded(uint amount);//The payer has added funds to the BOP.\n', '    event PayerStringUpdated(string newPayerString);\n', '    event RecipientStringUpdated(string newRecipientString);\n', '    event FundsRecovered();\n', '    event Committed(address recipient);\n', '    event FundsBurned(uint amount);\n', '    event FundsReleased(uint amount);\n', '    event Expended();\n', '    event Unexpended();\n', '    event DefaultActionDelayed();\n', '    event DefaultActionCalled();\n', '    \n', '    function BurnableOpenPayment(address _payer, string _payerString, uint _commitThreshold, DefaultAction _defaultAction, uint _defaultTimeoutLength)\n', '    public\n', '    payable {\n', '        if (msg.value > 0) {\n', '            FundsAdded(msg.value);\n', '            amountDeposited += msg.value;\n', '        }\n', '            \n', '        state = State.Open;\n', '        payer = _payer;\n', '        payerString = _payerString;\n', '        PayerStringUpdated(payerString);\n', '        \n', '        commitThreshold = _commitThreshold;\n', '        \n', '        defaultAction = _defaultAction;\n', '        if (defaultAction != DefaultAction.None) \n', '            defaultTimeoutLength = _defaultTimeoutLength;\n', '    }\n', '    \n', '    function getFullState()\n', '    public \n', '    returns (State, string, address, string, uint, uint, uint, uint) {\n', '        return (state, payerString, recipient, recipientString, amountDeposited, amountBurned, amountReleased, defaultTriggerTime);\n', '    }\n', '    \n', '    function addFunds()\n', '    public\n', '    onlyPayer()\n', '    payable {\n', '        if (msg.value == 0) throw;\n', '        \n', '        FundsAdded(msg.value);\n', '        amountDeposited += msg.value;\n', '        if (state == State.Expended) {\n', '            state = State.Committed;\n', '            Unexpended();\n', '        }\n', '    }\n', '    \n', '    function recoverFunds()\n', '    public\n', '    onlyPayer()\n', '    inState(State.Open)\n', '    {\n', '        FundsRecovered();\n', '        selfdestruct(payer);\n', '    }\n', '    \n', '    function commit()\n', '    public\n', '    inState(State.Open)\n', '    payable\n', '    {\n', '        if (msg.value < commitThreshold) throw;\n', '        \n', '        if (msg.value > 0) {\n', '            FundsAdded(msg.value);\n', '            amountDeposited += msg.value;\n', '        }\n', '        \n', '        recipient = msg.sender;\n', '        state = State.Committed;\n', '        Committed(recipient);\n', '        \n', '        if (defaultAction != DefaultAction.None) {\n', '            defaultTriggerTime = now + defaultTimeoutLength;\n', '        }\n', '    }\n', '    \n', '    function internalBurn(uint amount)\n', '    private\n', '    inState(State.Committed)\n', '    returns (bool)\n', '    {\n', '        bool success = burnAddress.send(amount);\n', '        if (success) {\n', '            FundsBurned(amount);\n', '            amountBurned += amount;\n', '        }\n', '        \n', '        if (this.balance == 0) {\n', '            state = State.Expended;\n', '            Expended();\n', '        }\n', '        \n', '        return success;\n', '    }\n', '    \n', '    function burn(uint amount)\n', '    public\n', '    inState(State.Committed)\n', '    onlyPayer()\n', '    returns (bool)\n', '    {\n', '        return internalBurn(amount);\n', '    }\n', '    \n', '    function internalRelease(uint amount)\n', '    private\n', '    inState(State.Committed)\n', '    returns (bool)\n', '    {\n', '        bool success = recipient.send(amount);\n', '        if (success) {\n', '            FundsReleased(amount);\n', '            amountReleased += amount;\n', '        }\n', '        \n', '        if (this.balance == 0) {\n', '            state = State.Expended;\n', '            Expended();\n', '        }\n', '        return success;\n', '    }\n', '    \n', '    function release(uint amount)\n', '    public\n', '    inState(State.Committed)\n', '    onlyPayer()\n', '    returns (bool)\n', '    {\n', '        return internalRelease(amount);\n', '    }\n', '    \n', '    function setPayerString(string _string)\n', '    public\n', '    onlyPayer()\n', '    {\n', '        payerString = _string;\n', '        PayerStringUpdated(payerString);\n', '    }\n', '    \n', '    function setRecipientString(string _string)\n', '    public\n', '    onlyRecipient()\n', '    {\n', '        recipientString = _string;\n', '        RecipientStringUpdated(recipientString);\n', '    }\n', '    \n', '    function delayDefaultAction()\n', '    public\n', '    onlyPayerOrRecipient()\n', '    inState(State.Committed)\n', '    {\n', '        if (defaultAction == DefaultAction.None) throw;\n', '        \n', '        DefaultActionDelayed();\n', '        defaultTriggerTime = now + defaultTimeoutLength;\n', '    }\n', '    \n', '    function callDefaultAction()\n', '    public\n', '    onlyPayerOrRecipient()\n', '    inState(State.Committed)\n', '    {\n', '        if (defaultAction == DefaultAction.None) throw;\n', '        if (now < defaultTriggerTime) throw;\n', '        \n', '        DefaultActionCalled();\n', '        if (defaultAction == DefaultAction.Burn) {\n', '            internalBurn(this.balance);\n', '        }\n', '        else if (defaultAction == DefaultAction.Release) {\n', '            internalRelease(this.balance);\n', '        }\n', '    }\n', '}\n', '\n', 'contract BurnableOpenPaymentFactory {\n', '    event NewBOP(address newBOPAddress);\n', '    \n', '    function newBurnableOpenPayment(address payer, string payerString, uint commitThreshold, BurnableOpenPayment.DefaultAction defaultAction, uint defaultTimeoutLength)\n', '    public\n', '    payable\n', '    returns (address) {\n', '        //pass along any ether to the constructor\n', '        address newBOPAddr = (new BurnableOpenPayment).value(msg.value)(payer, payerString, commitThreshold, defaultAction, defaultTimeoutLength);\n', '        NewBOP(newBOPAddr);\n', '        return newBOPAddr;\n', '    }\n', '}']
['//A BurnableOpenPayment is instantiated with a specified payer and a commitThreshold.\n', '//The recipient is not set when the contract is instantiated.\n', '\n', '//The constructor is payable, so the contract can be instantiated with initial funds.\n', '//Only the payer can fund the Payment after instantiation.\n', '\n', '//All behavior of the contract is directed by the payer, but\n', '//the payer can never directly recover the payment unless he becomes the recipient.\n', '\n', '//Anyone can become the recipient by contributing the commitThreshold.\n', "//The recipient cannot change once it's been set.\n", '\n', '//The payer can at any time choose to burn or release to the recipient any amount of funds.\n', '\n', 'pragma solidity ^0.4.10;\n', '\n', 'contract BurnableOpenPayment {\n', '    //BOP will start with a payer but no recipient (recipient==0x0)\n', '    address public payer;\n', '    address public recipient;\n', '    address constant burnAddress = 0x0;\n', '    \n', '    //Note that these will track, but not influence the BOP logic.\n', '    uint public amountDeposited;\n', '    uint public amountBurned;\n', '    uint public amountReleased;\n', '    \n', '    //payerString and recipientString enable rudimentary communication/publishing.\n', '    //Although the two parties might quickly move to another medium with better privacy or convenience,\n', "    //beginning with this is nice because it's already trustless/transparent/signed/pseudonymous/etc.\n", '    string public payerString;\n', '    string public recipientString;\n', '    \n', '    //Amount of ether a prospective recipient must pay to become (permanently) the recipient. See commit().\n', '    uint public commitThreshold;\n', '    \n', '    //What if the payer falls off the face of the planet?\n', '    //A BOP is instantiated with a chosen defaultAction, and this cannot be changed.\n', '    enum DefaultAction {None, Release, Burn}\n', '    DefaultAction public defaultAction;\n', '    \n', '    //if defaultAction != None, how long should we wait before giving up?\n', '    //Set in constructor:\n', '    uint public defaultTimeoutLength;\n', '    \n', '    //Calculated from defaultTimeoutLength on a successful recipient commit(),\n', '    //as well as whenever the payer (or possibly the recipient) calls delayDefaultAction()\n', '    uint public defaultTriggerTime;\n', '    \n', '    //Most action happens in the Committed state.\n', '    enum State {Open, Committed, Expended}\n', '    State public state;\n', '    //Note that a BOP cannot go from Committed back to Open, but it can go from Expended back to Committed\n', '    //(this would retain the committed recipient). Search for Expended and Unexpended events to see how this works.\n', '    \n', '    modifier inState(State s) { if (s != state) throw; _; }\n', '    modifier onlyPayer() { if (msg.sender != payer) throw; _; }\n', '    modifier onlyRecipient() { if (msg.sender != recipient) throw; _; }\n', '    modifier onlyPayerOrRecipient() { if ((msg.sender != payer) && (msg.sender != recipient)) throw; _; }\n', '    \n', '    event FundsAdded(uint amount);//The payer has added funds to the BOP.\n', '    event PayerStringUpdated(string newPayerString);\n', '    event RecipientStringUpdated(string newRecipientString);\n', '    event FundsRecovered();\n', '    event Committed(address recipient);\n', '    event FundsBurned(uint amount);\n', '    event FundsReleased(uint amount);\n', '    event Expended();\n', '    event Unexpended();\n', '    event DefaultActionDelayed();\n', '    event DefaultActionCalled();\n', '    \n', '    function BurnableOpenPayment(address _payer, string _payerString, uint _commitThreshold, DefaultAction _defaultAction, uint _defaultTimeoutLength)\n', '    public\n', '    payable {\n', '        if (msg.value > 0) {\n', '            FundsAdded(msg.value);\n', '            amountDeposited += msg.value;\n', '        }\n', '            \n', '        state = State.Open;\n', '        payer = _payer;\n', '        payerString = _payerString;\n', '        PayerStringUpdated(payerString);\n', '        \n', '        commitThreshold = _commitThreshold;\n', '        \n', '        defaultAction = _defaultAction;\n', '        if (defaultAction != DefaultAction.None) \n', '            defaultTimeoutLength = _defaultTimeoutLength;\n', '    }\n', '    \n', '    function getFullState()\n', '    public \n', '    returns (State, string, address, string, uint, uint, uint, uint) {\n', '        return (state, payerString, recipient, recipientString, amountDeposited, amountBurned, amountReleased, defaultTriggerTime);\n', '    }\n', '    \n', '    function addFunds()\n', '    public\n', '    onlyPayer()\n', '    payable {\n', '        if (msg.value == 0) throw;\n', '        \n', '        FundsAdded(msg.value);\n', '        amountDeposited += msg.value;\n', '        if (state == State.Expended) {\n', '            state = State.Committed;\n', '            Unexpended();\n', '        }\n', '    }\n', '    \n', '    function recoverFunds()\n', '    public\n', '    onlyPayer()\n', '    inState(State.Open)\n', '    {\n', '        FundsRecovered();\n', '        selfdestruct(payer);\n', '    }\n', '    \n', '    function commit()\n', '    public\n', '    inState(State.Open)\n', '    payable\n', '    {\n', '        if (msg.value < commitThreshold) throw;\n', '        \n', '        if (msg.value > 0) {\n', '            FundsAdded(msg.value);\n', '            amountDeposited += msg.value;\n', '        }\n', '        \n', '        recipient = msg.sender;\n', '        state = State.Committed;\n', '        Committed(recipient);\n', '        \n', '        if (defaultAction != DefaultAction.None) {\n', '            defaultTriggerTime = now + defaultTimeoutLength;\n', '        }\n', '    }\n', '    \n', '    function internalBurn(uint amount)\n', '    private\n', '    inState(State.Committed)\n', '    returns (bool)\n', '    {\n', '        bool success = burnAddress.send(amount);\n', '        if (success) {\n', '            FundsBurned(amount);\n', '            amountBurned += amount;\n', '        }\n', '        \n', '        if (this.balance == 0) {\n', '            state = State.Expended;\n', '            Expended();\n', '        }\n', '        \n', '        return success;\n', '    }\n', '    \n', '    function burn(uint amount)\n', '    public\n', '    inState(State.Committed)\n', '    onlyPayer()\n', '    returns (bool)\n', '    {\n', '        return internalBurn(amount);\n', '    }\n', '    \n', '    function internalRelease(uint amount)\n', '    private\n', '    inState(State.Committed)\n', '    returns (bool)\n', '    {\n', '        bool success = recipient.send(amount);\n', '        if (success) {\n', '            FundsReleased(amount);\n', '            amountReleased += amount;\n', '        }\n', '        \n', '        if (this.balance == 0) {\n', '            state = State.Expended;\n', '            Expended();\n', '        }\n', '        return success;\n', '    }\n', '    \n', '    function release(uint amount)\n', '    public\n', '    inState(State.Committed)\n', '    onlyPayer()\n', '    returns (bool)\n', '    {\n', '        return internalRelease(amount);\n', '    }\n', '    \n', '    function setPayerString(string _string)\n', '    public\n', '    onlyPayer()\n', '    {\n', '        payerString = _string;\n', '        PayerStringUpdated(payerString);\n', '    }\n', '    \n', '    function setRecipientString(string _string)\n', '    public\n', '    onlyRecipient()\n', '    {\n', '        recipientString = _string;\n', '        RecipientStringUpdated(recipientString);\n', '    }\n', '    \n', '    function delayDefaultAction()\n', '    public\n', '    onlyPayerOrRecipient()\n', '    inState(State.Committed)\n', '    {\n', '        if (defaultAction == DefaultAction.None) throw;\n', '        \n', '        DefaultActionDelayed();\n', '        defaultTriggerTime = now + defaultTimeoutLength;\n', '    }\n', '    \n', '    function callDefaultAction()\n', '    public\n', '    onlyPayerOrRecipient()\n', '    inState(State.Committed)\n', '    {\n', '        if (defaultAction == DefaultAction.None) throw;\n', '        if (now < defaultTriggerTime) throw;\n', '        \n', '        DefaultActionCalled();\n', '        if (defaultAction == DefaultAction.Burn) {\n', '            internalBurn(this.balance);\n', '        }\n', '        else if (defaultAction == DefaultAction.Release) {\n', '            internalRelease(this.balance);\n', '        }\n', '    }\n', '}\n', '\n', 'contract BurnableOpenPaymentFactory {\n', '    event NewBOP(address newBOPAddress);\n', '    \n', '    function newBurnableOpenPayment(address payer, string payerString, uint commitThreshold, BurnableOpenPayment.DefaultAction defaultAction, uint defaultTimeoutLength)\n', '    public\n', '    payable\n', '    returns (address) {\n', '        //pass along any ether to the constructor\n', '        address newBOPAddr = (new BurnableOpenPayment).value(msg.value)(payer, payerString, commitThreshold, defaultAction, defaultTimeoutLength);\n', '        NewBOP(newBOPAddr);\n', '        return newBOPAddr;\n', '    }\n', '}']
