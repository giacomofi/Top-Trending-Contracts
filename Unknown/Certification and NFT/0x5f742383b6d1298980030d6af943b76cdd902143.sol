['/* Copyright (C) Etherplay <contact@etherplay.io> - All Rights Reserved */\n', 'pragma solidity 0.4.4;\n', '\n', 'contract CompetitionStore {\n', '\t\n', '/////////////////////////////////////////////////////////////////// DATA /////////////////////////////////////////////////////////////\n', '\t\n', "\t//player's submission store the info required to verify its accuracy\n", '\tstruct Submission{\n', '\t\tuint32 score; \n', '\t\tuint32 durationRoundedDown; // duration in second of the game session\n', '\t\tuint32 version; // version of the game used\n', '\t\tuint64 seed; //seed used\n', '\t\tuint64 submitBlockNumber; // blockNumber at which the submission is processed\n', '\t\tbytes32 proofHash;//sha256 of proof : to save gas, the proof is not saved directly in the contract. Instead its hash is saved. The actual proof will be saved on a server. The player could potentially save it too. \n', '\t}\n', '\t\n', '\t//player start game parameter\n', '\tstruct Start{\n', '\t\tuint8 competitionIndex; //competition index (0 or 1) there is only 2 current competition per game, one is active, the other one being the older one which might have pending verification\n', '\t\tuint32 version;  //version of the game that the player score is based on\n', '\t\tuint64 seed; // the seed used for the game session\n', '\t\tuint64 time; // start time , used to check if the player is not taking too long to submit its score\n', '\t}\n', '\t\n', '\t// the values representing each competition\n', '\tstruct Competition{\n', '\t\tuint8 numPastBlocks;// number of past block allowed, 1 is the minimum since you can only get the hash of a past block. Allow player to start play instantunously\n', '\t\tuint8 houseDivider; // how much the house takes : 4 means house take 1/4 (25%)\n', '\t\tuint16 lag; // define how much extra time is allowed to submit a score (to accomodate block time and delays)\n', "\t\tuint32 verificationWaitTime;// wait time allowed for submission past competition's end time \n", '\t\tuint32 numPlayers;//current number of player that submited a score\n', '\t\tuint32 version; //the version of the game used for that competition, a hash of the code is published in the log upon changing\n', '\t\tuint32 previousVersion; // previousVersion to allow smooth update upon version change\n', '\t\tuint64 versionChangeBlockNumber; \n', '\t\tuint64 switchBlockNumber; // the blockNumber at which the competition started\n', '\t\tuint64 endTime;//The time at which the competition is set to finish. No start can happen after that and the competition cannot be aborted before that\n', '\t\tuint88 price;  // the price for that competition, do not change \n', '\t\tuint128 jackpot; // the current jackpot for that competition, this jackpot is then shared among the developer (in the deposit account for  funding development) and the winners (see houseDivider))\n', '\t\tuint32[] rewardsDistribution; // the length of it define how many winners there is and the distribution of the reward is the value for each index divided by the total\n', '\t\tmapping (address => Submission) submissions;  //only one submission per player per competition\n', '\t\taddress[] players; // contain the list of players that submited a score for that competition\n', '\t}\n', '\t\t\n', '\tstruct Game{\n', '\t\tmapping (address => Start) starts; // only 1 start per player, further override the current\n', '\t\tCompetition[2] competitions; // 2 competitions only to save gas, overrite each other upon going to next competition\n', '\t\tuint8 currentCompetitionIndex; //can only be 1 or 0 (switch operation : 1 - currentCompetitionIndex)\n', '\t}\n', '\n', '\tmapping (string => Game) games;\n', '\t\n', '\taddress organiser; // admin having control of the reward \n', '\taddress depositAccount;\t // is the receiver of the house part of the jackpot (see houseDivider) Can only be changed by the depositAccount.\n', '\n', '//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '\n', '\n', '///////////////////////////////////////////////////////// EVENTS /////////////////////////////////////////////////////////////\n', '\n', '\t//event logging the hash of the game code for a particular version\n', '\tevent VersionChange(\n', '\t\tstring indexed gameID,\n', '\t\tuint32 indexed version,\n', '\t\tbytes32 codeHash // the sha256 of the game code as used by the player\n', '\t);\n', '\n', '//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '\n', '\n', '\n', '//////////////////////////////////////////////////////// PLAYERS ACTIONS /////////////////////////////////////////////////////////////\n', '\t\n', '\t/*\n', '\tThe seed is computed from the block hash and the sender address\n', '\tWhile the seed can be predicted for few block away (see : numPastBlocks) this is has no much relevance since a game session have a bigger duration,\n', '\tRemember this is not gambling game, this is a skill game, seed is only a small part of the game outcome\n', '\t*/\n', '\tfunction computeSeed(uint64 blockNumber, address player) internal constant returns(uint64 seed){ \n', '\t\treturn uint64(sha3(block.blockhash(blockNumber),block.blockhash(blockNumber-1),block.blockhash(blockNumber-2),block.blockhash(blockNumber-3),block.blockhash(blockNumber-4),block.blockhash(blockNumber-5),player)); \n', '\t}\n', '\t\n', '\t/*\n', '\t\tprobe the current state of the competition so player can start playing right away (need to commit a tx too to ensure its play will be considered though)\n', '\t*/\n', '\tfunction getSeedAndState(string gameID, address player) constant returns(uint64 seed, uint64 blockNumber, uint8 competitionIndex, uint32 version, uint64 endTime, uint88 price, uint32 myBestScore, uint64 competitionBlockNumber, uint64 registeredSeed){\n', '\t\tvar game = games[gameID];\n', '\n', '\t\tcompetitionIndex = game.currentCompetitionIndex;\n', '\t\tvar competition = game.competitions[competitionIndex];\n', '\n', '\t\tblockNumber = uint64(block.number-1);\n', '\t\tseed = computeSeed(blockNumber, player);\n', '\t\tversion = competition.version;\n', '\t\tendTime = competition.endTime;\n', '\t\tprice = competition.price;\n', '\t\tcompetitionBlockNumber = competition.switchBlockNumber;\n', '\t\t\n', '\t\tif (competition.submissions[player].submitBlockNumber >= competition.switchBlockNumber){\n', '\t\t\tmyBestScore = competition.submissions[player].score;\n', '\t\t}else{\n', '\t\t\tmyBestScore = 0;\n', '\t\t}\n', '\t\t\n', '\t\tregisteredSeed = game.starts[player].seed;\n', '\t}\n', '\t\n', '\t\n', '\t\t\n', '\tfunction start(string gameID, uint64 blockNumber,uint8 competitionIndex, uint32 version) payable {\n', '\t\tvar game = games[gameID];\n', '\t\tvar competition = game.competitions[competitionIndex];\n', '\n', '\t\tif(msg.value != competition.price){\n', '\t\t\tthrow;\n', '\t\t}\n', '\n', '\t\tif(\n', '\t\t\tcompetition.endTime <= now || //block play when time is up \n', '\t\t\tcompetitionIndex != game.currentCompetitionIndex || //start happen just after a switch // should not be possible since endTime already ensure that a new competition cannot start before the end of the first\n', '\t\t\tversion != competition.version && (version != competition.previousVersion || block.number > competition.versionChangeBlockNumber) || //ensure version is same as current (or previous if versionChangeBlockNumber is recent)\n', '\t\t\tblock.number >= competition.numPastBlocks && block.number - competition.numPastBlocks > blockNumber //ensure start is not too old   \n', '\t\t\t){\n', '\t\t\t\t//if ether was sent, send it back if possible, else throw\n', '\t\t\t\tif(msg.value != 0 && !msg.sender.send(msg.value)){\n', '\t\t\t\t\tthrow;\n', '\t\t\t\t}\n', '\t\t\t\treturn;\n', '\t\t}\n', '\t\t\n', '\t\tcompetition.jackpot += uint128(msg.value); //increase the jackpot\n', '\t\t\n', '\t\t//save the start params\n', '\t\tgame.starts[msg.sender] = Start({\n', '\t\t\tseed: computeSeed(blockNumber,msg.sender)\n', '\t\t\t, time : uint64(now)\n', '\t\t\t, competitionIndex : competitionIndex\n', '\t\t\t, version : version\n', '\t\t}); \n', '\t}\n', '\t\t\n', '\tfunction submit(string gameID, uint64 seed, uint32 score, uint32 durationRoundedDown, bytes32 proofHash){ \n', '\t\tvar game = games[gameID];\n', '\n', '\t\tvar gameStart = game.starts[msg.sender];\n', '\t\t\t\n', '\t\t//seed should be same, else it means double start and this one executing is from the old one \n', '\t\tif(gameStart.seed != seed){\n', '\t\t\treturn;\n', '\t\t}\n', '\t\t\n', '\t\tvar competition = game.competitions[gameStart.competitionIndex];\n', '\t\t\n', '\t\t// game should not take too long to be submited\n', '\t\tif(now - gameStart.time > durationRoundedDown + competition.lag){ \n', '\t\t\treturn;\n', '\t\t}\n', '\n', '\t\tif(now >= competition.endTime + competition.verificationWaitTime){\n', '\t\t\treturn; //this ensure verifier to get all the score at that time (should never be there though as game should ensure a maximumTime < verificationWaitTime)\n', '\t\t}\n', '\t\t\n', '\t\tvar submission = competition.submissions[msg.sender];\n', '\t\tif(submission.submitBlockNumber < competition.switchBlockNumber){\n', '\t\t\tif(competition.numPlayers >= 4294967295){ //unlikely but if that happen this is for now the best place to stop\n', '\t\t\t\treturn;\n', '\t\t\t}\n', '\t\t}else if (score <= submission.score){\n', '\t\t\treturn;\n', '\t\t}\n', '\t\t\n', '\t\tvar players = competition.players;\n', '\t\t//if player did not submit score yet => add player to list\n', '\t\tif(submission.submitBlockNumber < competition.switchBlockNumber){\n', '\t\t\tvar currentNumPlayer = competition.numPlayers;\n', '\t\t\tif(currentNumPlayer >= players.length){\n', '\t\t\t\tplayers.push(msg.sender);\n', '\t\t\t}else{\n', '\t\t\t\tplayers[currentNumPlayer] = msg.sender;\n', '\t\t\t}\n', '\t\t\tcompetition.numPlayers = currentNumPlayer + 1;\n', '\t\t}\n', '\t\t\n', '\t\tcompetition.submissions[msg.sender] = Submission({\n', '\t\t\tproofHash:proofHash,\n', '\t\t\tseed:gameStart.seed,\n', '\t\t\tscore:score,\n', '\t\t\tdurationRoundedDown:durationRoundedDown,\n', '\t\t\tsubmitBlockNumber:uint64(block.number),\n', '\t\t\tversion:gameStart.version\n', '\t\t});\n', '\t\t\n', '\t}\n', '\t\n', '\t/*\n', '\t\taccept donation payment : this increase the jackpot of the currentCompetition of the specified game\n', '\t*/\n', '\tfunction increaseJackpot(string gameID) payable{\n', '\t\tvar game = games[gameID];\n', '\t\tgame.competitions[game.currentCompetitionIndex].jackpot += uint128(msg.value); //extra ether is lost but this is not going to happen :)\n', '\t}\n', '\n', '//////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '\t\n', '/////////////////////////////////////// PRIVATE ///////////////////////////////////////////\n', '\t\t\n', '\tfunction CompetitionStore(){\n', '\t\torganiser = msg.sender;\n', '\t\tdepositAccount = msg.sender;\n', '\t}\n', '\n', '\t\n', '\t//give a starting jackpot by sending ether to the transaction\n', '\tfunction _startNextCompetition(string gameID, uint32 version, uint88 price, uint8 numPastBlocks, uint8 houseDivider, uint16 lag, uint64 duration, uint32 verificationWaitTime, bytes32 codeHash, uint32[] rewardsDistribution) payable{\n', '\t\tif(msg.sender != organiser){\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\tvar game = games[gameID];\n', '\t\tvar newCompetition = game.competitions[1 - game.currentCompetitionIndex]; \n', '\t\tvar currentCompetition = game.competitions[game.currentCompetitionIndex];\n', '\t\t//do not allow to switch if endTime is not over\n', '\t\tif(currentCompetition.endTime >= now){\n', '\t\t\tthrow;\n', '\t\t}\n', '\n', '\t\t//block switch if reward was not called (numPlayers > 0)\n', '\t\tif(newCompetition.numPlayers > 0){\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t\n', '\t\tif(houseDivider == 0){ \n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t\n', '\t\tif(numPastBlocks < 1){\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t\n', '\t\tif(rewardsDistribution.length == 0 || rewardsDistribution.length > 64){ // do not risk gas shortage on reward\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t//ensure rewardsDistribution give always something and do not give more to a lower scoring player\n', '\t\tuint32 prev = 0;\n', '\t\tfor(uint8 i = 0; i < rewardsDistribution.length; i++){\n', '\t\t\tif(rewardsDistribution[i] == 0 ||  (prev != 0 && rewardsDistribution[i] > prev)){\n', '\t\t\t\tthrow;\n', '\t\t\t}\n', '\t\t\tprev = rewardsDistribution[i];\n', '\t\t}\n', '\n', '\t\tif(version != currentCompetition.version){\n', '\t\t\tVersionChange(gameID,version,codeHash); \n', '\t\t}\n', '\t\t\n', '\t\tgame.currentCompetitionIndex = 1 - game.currentCompetitionIndex;\n', '\t\t\n', '\t\tnewCompetition.switchBlockNumber = uint64(block.number);\n', '\t\tnewCompetition.previousVersion = 0;\n', '\t\tnewCompetition.versionChangeBlockNumber = 0;\n', '\t\tnewCompetition.version = version;\n', '\t\tnewCompetition.price = price; \n', '\t\tnewCompetition.numPastBlocks = numPastBlocks;\n', '\t\tnewCompetition.rewardsDistribution = rewardsDistribution;\n', '\t\tnewCompetition.houseDivider = houseDivider;\n', '\t\tnewCompetition.lag = lag;\n', '\t\tnewCompetition.jackpot += uint128(msg.value); //extra ether is lost but this is not going to happen :)\n', '\t\tnewCompetition.endTime = uint64(now) + duration;\n', '\t\tnewCompetition.verificationWaitTime = verificationWaitTime;\n', '\t}\n', '\t\n', '\t\n', '\t\n', '\tfunction _setBugFixVersion(string gameID, uint32 version, bytes32 codeHash, uint32 numBlockAllowedForPastVersion){\n', '\t\tif(msg.sender != organiser){\n', '\t\t\tthrow;\n', '\t\t}\n', '\n', '\t\tvar game = games[gameID];\n', '\t\tvar competition = game.competitions[game.currentCompetitionIndex];\n', '\t\t\n', '\t\tif(version <= competition.version){ // a bug fix should be a new version (greater than previous version)\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t\n', '\t\tif(competition.endTime <= now){ // cannot bugFix a competition that already ended\n', '\t\t\treturn;\n', '\t\t}\n', '\t\t\n', '\t\tcompetition.previousVersion = competition.version;\n', '\t\tcompetition.versionChangeBlockNumber = uint64(block.number + numBlockAllowedForPastVersion);\n', '\t\tcompetition.version = version;\n', '\t\tVersionChange(gameID,version,codeHash);\n', '\t}\n', '\n', '\tfunction _setLagParams(string gameID, uint16 lag, uint8 numPastBlocks){\n', '\t\tif(msg.sender != organiser){\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t\n', '\t\tif(numPastBlocks < 1){\n', '\t\t\tthrow;\n', '\t\t}\n', '\n', '\t\tvar game = games[gameID];\n', '\t\tvar competition = game.competitions[game.currentCompetitionIndex];\n', '\t\tcompetition.numPastBlocks = numPastBlocks;\n', '\t\tcompetition.lag = lag;\n', '\t}\n', '\n', '\tfunction _rewardWinners(string gameID, uint8 competitionIndex, address[] winners){\n', '\t\tif(msg.sender != organiser){\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\t\n', '\t\tvar competition = games[gameID].competitions[competitionIndex];\n', '\n', '\t\t//ensure time has passed so that players who started near the end can finish their session \n', '\t\t//game should be made to ensure termination before verificationWaitTime, it is the game responsability\n', '\t\tif(int(now) - competition.endTime < competition.verificationWaitTime){\n', '\t\t\tthrow;\n', '\t\t}\n', '\n', '\t\t\n', '\t\tif( competition.jackpot > 0){ // if there is no jackpot skip\n', '\n', '\t\t\t\n', '\t\t\tvar rewardsDistribution = competition.rewardsDistribution;\n', '\n', '\t\t\tuint8 numWinners = uint8(rewardsDistribution.length);\n', '\n', '\t\t\tif(numWinners > uint8(winners.length)){\n', '\t\t\t\tnumWinners = uint8(winners.length);\n', '\t\t\t}\n', '\n', '\t\t\tuint128 forHouse = competition.jackpot;\n', '\t\t\tif(numWinners > 0 && competition.houseDivider > 1){ //in case there is no winners (no players or only cheaters), the house takes all\n', '\t\t\t\tforHouse = forHouse / competition.houseDivider;\n', '\t\t\t\tuint128 forWinners = competition.jackpot - forHouse;\n', '\n', '\t\t\t\tuint64 total = 0;\n', '\t\t\t\tfor(uint8 i=0; i<numWinners; i++){ // distribute all the winning even if there is not all the winners\n', '\t\t\t\t\ttotal += rewardsDistribution[i];\n', '\t\t\t\t}\n', '\t\t\t\tfor(uint8 j=0; j<numWinners; j++){\n', '\t\t\t\t\tuint128 value = (forWinners * rewardsDistribution[j]) / total;\n', '\t\t\t\t\tif(!winners[j].send(value)){ // if fail give to house\n', '\t\t\t\t\t\tforHouse = forHouse + value;\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\t\n', '\t\t\tif(!depositAccount.send(forHouse)){\n', '\t\t\t\t//in case sending to house failed \n', '\t\t\t\tvar nextCompetition = games[gameID].competitions[1 - competitionIndex];\n', '\t\t\t\tnextCompetition.jackpot = nextCompetition.jackpot + forHouse;\t\n', '\t\t\t}\n', '\n', '\t\t\t\n', '\t\t\tcompetition.jackpot = 0;\n', '\t\t}\n', '\t\t\n', '\t\t\n', '\t\tcompetition.numPlayers = 0;\n', '\t}\n', '\n', '\t\n', '\t/*\n', '\t\tallow to change the depositAccount of the house share, only the depositAccount can change it, depositAccount == organizer at creation\n', '\t*/\n', '\tfunction _setDepositAccount(address newDepositAccount){\n', '\t\tif(depositAccount != msg.sender){\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\tdepositAccount = newDepositAccount;\n', '\t}\n', '\t\n', '\t/*\n', '\t\tallow to change the organiser, in case this need be \n', '\t*/\n', '\tfunction _setOrganiser(address newOrganiser){\n', '\t\tif(organiser != msg.sender){\n', '\t\t\tthrow;\n', '\t\t}\n', '\t\torganiser = newOrganiser;\n', '\t}\n', '\t\n', '\t\n', '///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n', '\n', '/////////////////////////////////////////////// OTHER CONSTANT CALLS TO PROBE VALUES ////////////////////////////////////////////////////\n', '\n', '\tfunction getPlayerSubmissionFromCompetition(string gameID, uint8 competitionIndex, address playerAddress) constant returns(uint32 score, uint64 seed, uint32 duration, bytes32 proofHash, uint32 version, uint64 submitBlockNumber){\n', '\t\tvar submission = games[gameID].competitions[competitionIndex].submissions[playerAddress];\n', '\t\tscore = submission.score;\n', '\t\tseed = submission.seed;\t\t\n', '\t\tduration = submission.durationRoundedDown;\n', '\t\tproofHash = submission.proofHash;\n', '\t\tversion = submission.version;\n', '\t\tsubmitBlockNumber =submission.submitBlockNumber;\n', '\t}\n', '\t\n', '\tfunction getPlayersFromCompetition(string gameID, uint8 competitionIndex) constant returns(address[] playerAddresses, uint32 num){\n', '\t\tvar competition = games[gameID].competitions[competitionIndex];\n', '\t\tplayerAddresses = competition.players;\n', '\t\tnum = competition.numPlayers;\n', '\t}\n', '\n', '\tfunction getCompetitionValues(string gameID, uint8 competitionIndex) constant returns (\n', '\t\tuint128 jackpot,\n', '\t\tuint88 price,\n', '\t\tuint32 version,\n', '\t\tuint8 numPastBlocks,\n', '\t\tuint64 switchBlockNumber,\n', '\t\tuint32 numPlayers,\n', '\t\tuint32[] rewardsDistribution,\n', '\t\tuint8 houseDivider,\n', '\t\tuint16 lag,\n', '\t\tuint64 endTime,\n', '\t\tuint32 verificationWaitTime,\n', '\t\tuint8 _competitionIndex\n', '\t){\n', '\t\tvar competition = games[gameID].competitions[competitionIndex];\n', '\t\tjackpot = competition.jackpot;\n', '\t\tprice = competition.price;\n', '\t\tversion = competition.version;\n', '\t\tnumPastBlocks = competition.numPastBlocks;\n', '\t\tswitchBlockNumber = competition.switchBlockNumber;\n', '\t\tnumPlayers = competition.numPlayers;\n', '\t\trewardsDistribution = competition.rewardsDistribution;\n', '\t\thouseDivider = competition.houseDivider;\n', '\t\tlag = competition.lag;\n', '\t\tendTime = competition.endTime;\n', '\t\tverificationWaitTime = competition.verificationWaitTime;\n', '\t\t_competitionIndex = competitionIndex;\n', '\t}\n', '\t\n', '\tfunction getCurrentCompetitionValues(string gameID) constant returns (\n', '\t\tuint128 jackpot,\n', '\t\tuint88 price,\n', '\t\tuint32 version,\n', '\t\tuint8 numPastBlocks,\n', '\t\tuint64 switchBlockNumber,\n', '\t\tuint32 numPlayers,\n', '\t\tuint32[] rewardsDistribution,\n', '\t\tuint8 houseDivider,\n', '\t\tuint16 lag,\n', '\t\tuint64 endTime,\n', '\t\tuint32 verificationWaitTime,\n', '\t\tuint8 _competitionIndex\n', '\t)\n', '\t{\n', '\t\treturn getCompetitionValues(gameID,games[gameID].currentCompetitionIndex);\n', '\t}\n', '}']