['pragma solidity ^0.4.11;\n', '\n', '// ------------------------------------------------------------------------\n', '// TokenTraderFactory\n', '//\n', '// Decentralised trustless ERC20-compliant token to ETH exchange contract\n', '// on the Ethereum blockchain.\n', '//\n', '// Note that this TokenTrader cannot be used with the Golem Network Token\n', '// directly as the token does not implement the ERC20\n', '// transferFrom(...), approve(...) and allowance(...) methods\n', '//\n', '// History:\n', '//   Jan 25 2017 - BPB Added makerTransferAsset(...) and\n', '//                     makerTransferEther(...)\n', '//   Feb 05 2017 - BPB Bug fix in the change calculation for the Unicorn\n', '//                     token with natural number 1\n', '//   Feb 08 2017 - BPB/JL Renamed etherValueOfTokensToSell to\n', '//                     amountOfTokensToSell in takerSellAsset(...) to\n', '//                     better describe the parameter\n', '//                     Added check in createTradeContract(...) to prevent\n', '//                     GNTs from being used with this contract. The asset\n', '//                     token will need to have an allowance(...) function.\n', '//\n', '// Enjoy. (c) JonnyLatte & BokkyPooBah 2017. The MIT licence.\n', '// ------------------------------------------------------------------------\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) throw;\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrTokenTraderWithSameOwner {\n', '        if (msg.sender != owner && TokenTrader(msg.sender).owner() != owner) throw;\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '// contract can buy or sell tokens for ETH\n', '// prices are in amount of wei per batch of token units\n', '\n', 'contract TokenTrader is Owned {\n', '\n', '    address public asset;       // address of token\n', '    uint256 public buyPrice;    // contract buys lots of token at this price\n', '    uint256 public sellPrice;   // contract sells lots at this price\n', '    uint256 public units;       // lot size (token-wei)\n', '\n', '    bool public buysTokens;     // is contract buying\n', '    bool public sellsTokens;    // is contract selling\n', '\n', '    event ActivatedEvent(bool buys, bool sells);\n', '    event MakerDepositedEther(uint256 amount);\n', '    event MakerWithdrewAsset(uint256 tokens);\n', '    event MakerTransferredAsset(address toTokenTrader, uint256 tokens);\n', '    event MakerWithdrewERC20Token(address tokenAddress, uint256 tokens);\n', '    event MakerWithdrewEther(uint256 ethers);\n', '    event MakerTransferredEther(address toTokenTrader, uint256 ethers);\n', '    event TakerBoughtAsset(address indexed buyer, uint256 ethersSent,\n', '        uint256 ethersReturned, uint256 tokensBought);\n', '    event TakerSoldAsset(address indexed seller, uint256 amountOfTokensToSell,\n', '        uint256 tokensSold, uint256 etherValueOfTokensSold);\n', '\n', '    // Constructor - only to be called by the TokenTraderFactory contract\n', '    function TokenTrader (\n', '        address _asset,\n', '        uint256 _buyPrice,\n', '        uint256 _sellPrice,\n', '        uint256 _units,\n', '        bool    _buysTokens,\n', '        bool    _sellsTokens\n', '    ) {\n', '        asset       = _asset;\n', '        buyPrice    = _buyPrice;\n', '        sellPrice   = _sellPrice;\n', '        units       = _units;\n', '        buysTokens  = _buysTokens;\n', '        sellsTokens = _sellsTokens;\n', '        ActivatedEvent(buysTokens, sellsTokens);\n', '    }\n', '\n', '    // Maker can activate or deactivate this contract&#39;s buying and\n', '    // selling status\n', '    //\n', '    // The ActivatedEvent() event is logged with the following\n', '    // parameter:\n', '    //   buysTokens   this contract can buy asset tokens\n', '    //   sellsTokens  this contract can sell asset tokens\n', '    //\n', '    function activate (\n', '        bool _buysTokens,\n', '        bool _sellsTokens\n', '    ) onlyOwner {\n', '        buysTokens  = _buysTokens;\n', '        sellsTokens = _sellsTokens;\n', '        ActivatedEvent(buysTokens, sellsTokens);\n', '    }\n', '\n', '    // Maker can deposit ethers to this contract so this contract\n', '    // can buy asset tokens.\n', '    //\n', '    // Maker deposits asset tokens to this contract by calling the\n', '    // asset&#39;s transfer() method with the following parameters\n', '    //   _to     is the address of THIS contract\n', '    //   _value  is the number of asset tokens to be transferred\n', '    //\n', '    // Taker MUST NOT send tokens directly to this contract. Takers\n', '    // MUST use the takerSellAsset() method to sell asset tokens\n', '    // to this contract\n', '    //\n', '    // Maker can also transfer ethers from one TokenTrader contract\n', '    // to another TokenTrader contract, both owned by the Maker\n', '    //\n', '    // The MakerDepositedEther() event is logged with the following\n', '    // parameter:\n', '    //   ethers  is the number of ethers deposited by the maker\n', '    //\n', '    // This method was called deposit() in the old version\n', '    //\n', '    function makerDepositEther() payable onlyOwnerOrTokenTraderWithSameOwner {\n', '        MakerDepositedEther(msg.value);\n', '    }\n', '\n', '    // Maker can withdraw asset tokens from this contract, with the\n', '    // following parameter:\n', '    //   tokens  is the number of asset tokens to be withdrawn\n', '    //\n', '    // The MakerWithdrewAsset() event is logged with the following\n', '    // parameter:\n', '    //   tokens  is the number of tokens withdrawn by the maker\n', '    //\n', '    // This method was called withdrawAsset() in the old version\n', '    //\n', '    function makerWithdrawAsset(uint256 tokens) onlyOwner returns (bool ok) {\n', '        MakerWithdrewAsset(tokens);\n', '        return ERC20(asset).transfer(owner, tokens);\n', '    }\n', '\n', '    // Maker can transfer asset tokens from this contract to another\n', '    // TokenTrader contract, with the following parameter:\n', '    //   toTokenTrader  Another TokenTrader contract owned by the\n', '    //                  same owner and with the same asset\n', '    //   tokens         is the number of asset tokens to be moved\n', '    //\n', '    // The MakerTransferredAsset() event is logged with the following\n', '    // parameters:\n', '    //   toTokenTrader  The other TokenTrader contract owned by\n', '    //                  the same owner and with the same asset\n', '    //   tokens         is the number of tokens transferred\n', '    //\n', '    // The asset Transfer() event is also logged from this contract\n', '    // to the other contract\n', '    //\n', '    function makerTransferAsset(\n', '        TokenTrader toTokenTrader,\n', '        uint256 tokens\n', '    ) onlyOwner returns (bool ok) {\n', '        if (owner != toTokenTrader.owner() || asset != toTokenTrader.asset()) {\n', '            throw;\n', '        }\n', '        MakerTransferredAsset(toTokenTrader, tokens);\n', '        return ERC20(asset).transfer(toTokenTrader, tokens);\n', '    }\n', '\n', '    // Maker can withdraw any ERC20 asset tokens from this contract\n', '    //\n', '    // This method is included in the case where this contract receives\n', '    // the wrong tokens\n', '    //\n', '    // The MakerWithdrewERC20Token() event is logged with the following\n', '    // parameter:\n', '    //   tokenAddress  is the address of the tokens withdrawn by the maker\n', '    //   tokens        is the number of tokens withdrawn by the maker\n', '    //\n', '    // This method was called withdrawToken() in the old version\n', '    //\n', '    function makerWithdrawERC20Token(\n', '        address tokenAddress,\n', '        uint256 tokens\n', '    ) onlyOwner returns (bool ok) {\n', '        MakerWithdrewERC20Token(tokenAddress, tokens);\n', '        return ERC20(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '    // Maker can withdraw ethers from this contract\n', '    //\n', '    // The MakerWithdrewEther() event is logged with the following parameter\n', '    //   ethers  is the number of ethers withdrawn by the maker\n', '    //\n', '    // This method was called withdraw() in the old version\n', '    //\n', '    function makerWithdrawEther(uint256 ethers) onlyOwner returns (bool ok) {\n', '        if (this.balance >= ethers) {\n', '            MakerWithdrewEther(ethers);\n', '            return owner.send(ethers);\n', '        }\n', '    }\n', '\n', '    // Maker can transfer ethers from this contract to another TokenTrader\n', '    // contract, with the following parameters:\n', '    //   toTokenTrader  Another TokenTrader contract owned by the\n', '    //                  same owner and with the same asset\n', '    //   ethers         is the number of ethers to be moved\n', '    //\n', '    // The MakerTransferredEther() event is logged with the following parameter\n', '    //   toTokenTrader  The other TokenTrader contract owned by the\n', '    //                  same owner and with the same asset\n', '    //   ethers         is the number of ethers transferred\n', '    //\n', '    // The MakerDepositedEther() event is logged on the other\n', '    // contract with the following parameter:\n', '    //   ethers  is the number of ethers deposited by the maker\n', '    //\n', '    function makerTransferEther(\n', '        TokenTrader toTokenTrader,\n', '        uint256 ethers\n', '    ) onlyOwner returns (bool ok) {\n', '        if (owner != toTokenTrader.owner() || asset != toTokenTrader.asset()) {\n', '            throw;\n', '        }\n', '        if (this.balance >= ethers) {\n', '            MakerTransferredEther(toTokenTrader, ethers);\n', '            toTokenTrader.makerDepositEther.value(ethers)();\n', '        }\n', '    }\n', '\n', '    // Taker buys asset tokens by sending ethers\n', '    //\n', '    // The TakerBoughtAsset() event is logged with the following parameters\n', '    //   buyer           is the buyer&#39;s address\n', '    //   ethersSent      is the number of ethers sent by the buyer\n', '    //   ethersReturned  is the number of ethers sent back to the buyer as\n', '    //                   change\n', '    //   tokensBought    is the number of asset tokens sent to the buyer\n', '    //\n', '    // This method was called buy() in the old version\n', '    //\n', '    function takerBuyAsset() payable {\n', '        if (sellsTokens || msg.sender == owner) {\n', '            // Note that sellPrice has already been validated as > 0\n', '            uint order    = msg.value / sellPrice;\n', '            // Note that units has already been validated as > 0\n', '            uint can_sell = ERC20(asset).balanceOf(address(this)) / units;\n', '            uint256 change = 0;\n', '            if (msg.value > (can_sell * sellPrice)) {\n', '                change  = msg.value - (can_sell * sellPrice);\n', '                order = can_sell;\n', '            }\n', '            if (change > 0) {\n', '                if (!msg.sender.send(change)) throw;\n', '            }\n', '            if (order > 0) {\n', '                if (!ERC20(asset).transfer(msg.sender, order * units)) throw;\n', '            }\n', '            TakerBoughtAsset(msg.sender, msg.value, change, order * units);\n', '        }\n', '        // Return user funds if the contract is not selling\n', '        else if (!msg.sender.send(msg.value)) throw;\n', '    }\n', '\n', '    // Taker sells asset tokens for ethers by:\n', '    // 1. Calling the asset&#39;s approve() method with the following parameters\n', '    //    _spender            is the address of this contract\n', '    //    _value              is the number of tokens to be sold\n', '    // 2. Calling this takerSellAsset() method with the following parameter\n', '    //    etherValueOfTokens  is the ether value of the asset tokens to be sold\n', '    //                        by the taker\n', '    //\n', '    // The TakerSoldAsset() event is logged with the following parameters\n', '    //   seller                  is the seller&#39;s address\n', '    //   amountOfTokensToSell    is the amount of the asset tokens being\n', '    //                           sold by the taker\n', '    //   tokensSold              is the number of the asset tokens sold\n', '    //   etherValueOfTokensSold  is the ether value of the asset tokens sold\n', '    //\n', '    // This method was called sell() in the old version\n', '    //\n', '    function takerSellAsset(uint256 amountOfTokensToSell) {\n', '        if (buysTokens || msg.sender == owner) {\n', '            // Maximum number of token the contract can buy\n', '            // Note that buyPrice has already been validated as > 0\n', '            uint256 can_buy = this.balance / buyPrice;\n', '            // Token lots available\n', '            // Note that units has already been validated as > 0\n', '            uint256 order = amountOfTokensToSell / units;\n', '            // Adjust order for funds available\n', '            if (order > can_buy) order = can_buy;\n', '            if (order > 0) {\n', '                // Extract user tokens\n', '                if (!ERC20(asset).transferFrom(msg.sender, address(this), order * units)) throw;\n', '                // Pay user\n', '                if (!msg.sender.send(order * buyPrice)) throw;\n', '            }\n', '            TakerSoldAsset(msg.sender, amountOfTokensToSell, order * units, order * buyPrice);\n', '        }\n', '    }\n', '\n', '    // Taker buys tokens by sending ethers\n', '    function () payable {\n', '        takerBuyAsset();\n', '    }\n', '}\n', '\n', '// This contract deploys TokenTrader contracts and logs the event\n', 'contract TokenTraderFactory is Owned {\n', '\n', '    event TradeListing(address indexed ownerAddress, address indexed tokenTraderAddress,\n', '        address indexed asset, uint256 buyPrice, uint256 sellPrice, uint256 units,\n', '        bool buysTokens, bool sellsTokens);\n', '    event OwnerWithdrewERC20Token(address indexed tokenAddress, uint256 tokens);\n', '\n', '    mapping(address => bool) _verify;\n', '\n', '    // Anyone can call this method to verify the settings of a\n', '    // TokenTrader contract. The parameters are:\n', '    //   tradeContract  is the address of a TokenTrader contract\n', '    //\n', '    // Return values:\n', '    //   valid        did this TokenTraderFactory create the TokenTrader contract?\n', '    //   owner        is the owner of the TokenTrader contract\n', '    //   asset        is the ERC20 asset address\n', '    //   buyPrice     is the buy price in ethers per `units` of asset tokens\n', '    //   sellPrice    is the sell price in ethers per `units` of asset tokens\n', '    //   units        is the number of units of asset tokens\n', '    //   buysTokens   is the TokenTrader contract buying tokens?\n', '    //   sellsTokens  is the TokenTrader contract selling tokens?\n', '    //\n', '    function verify(address tradeContract) constant returns (\n', '        bool    valid,\n', '        address owner,\n', '        address asset,\n', '        uint256 buyPrice,\n', '        uint256 sellPrice,\n', '        uint256 units,\n', '        bool    buysTokens,\n', '        bool    sellsTokens\n', '    ) {\n', '        valid = _verify[tradeContract];\n', '        if (valid) {\n', '            TokenTrader t = TokenTrader(tradeContract);\n', '            owner         = t.owner();\n', '            asset         = t.asset();\n', '            buyPrice      = t.buyPrice();\n', '            sellPrice     = t.sellPrice();\n', '            units         = t.units();\n', '            buysTokens    = t.buysTokens();\n', '            sellsTokens   = t.sellsTokens();\n', '        }\n', '    }\n', '\n', '    // Maker can call this method to create a new TokenTrader contract\n', '    // with the maker being the owner of this new contract\n', '    //\n', '    // Parameters:\n', '    //   asset        is the ERC20 asset address\n', '    //   buyPrice     is the buy price in ethers per `units` of asset tokens\n', '    //   sellPrice    is the sell price in ethers per `units` of asset tokens\n', '    //   units        is the number of units of asset tokens\n', '    //   buysTokens   is the TokenTrader contract buying tokens?\n', '    //   sellsTokens  is the TokenTrader contract selling tokens?\n', '    //\n', '    // For example, listing a TokenTrader contract on the REP Augur token where\n', '    // the contract will buy REP tokens at a rate of 39000/100000 = 0.39 ETH\n', '    // per REP token and sell REP tokens at a rate of 41000/100000 = 0.41 ETH\n', '    // per REP token:\n', '    //   asset        0x48c80f1f4d53d5951e5d5438b54cba84f29f32a5\n', '    //   buyPrice     39000\n', '    //   sellPrice    41000\n', '    //   units        100000\n', '    //   buysTokens   true\n', '    //   sellsTokens  true\n', '    //\n', '    // The TradeListing() event is logged with the following parameters\n', '    //   ownerAddress        is the Maker&#39;s address\n', '    //   tokenTraderAddress  is the address of the newly created TokenTrader contract\n', '    //   asset               is the ERC20 asset address\n', '    //   buyPrice            is the buy price in ethers per `units` of asset tokens\n', '    //   sellPrice           is the sell price in ethers per `units` of asset tokens\n', '    //   unit                is the number of units of asset tokens\n', '    //   buysTokens          is the TokenTrader contract buying tokens?\n', '    //   sellsTokens         is the TokenTrader contract selling tokens?\n', '    //\n', '    function createTradeContract(\n', '        address asset,\n', '        uint256 buyPrice,\n', '        uint256 sellPrice,\n', '        uint256 units,\n', '        bool    buysTokens,\n', '        bool    sellsTokens\n', '    ) returns (address trader) {\n', '        // Cannot have invalid asset\n', '        if (asset == 0x0) throw;\n', '        // Check for ERC20 allowance function\n', '        // This will throw an error if the allowance function\n', '        // is undefined to prevent GNTs from being used\n', '        // with this factory\n', '        uint256 allowance = ERC20(asset).allowance(msg.sender, this);\n', '        // Cannot set zero or negative price\n', '        if (buyPrice <= 0 || sellPrice <= 0) throw;\n', '        // Must make profit on spread\n', '        if (buyPrice >= sellPrice) throw;\n', '        // Cannot buy or sell zero or negative units\n', '        if (units <= 0) throw;\n', '\n', '        trader = new TokenTrader(\n', '            asset,\n', '            buyPrice,\n', '            sellPrice,\n', '            units,\n', '            buysTokens,\n', '            sellsTokens);\n', '        // Record that this factory created the trader\n', '        _verify[trader] = true;\n', '        // Set the owner to whoever called the function\n', '        TokenTrader(trader).transferOwnership(msg.sender);\n', '        TradeListing(msg.sender, trader, asset, buyPrice, sellPrice, units, buysTokens, sellsTokens);\n', '    }\n', '\n', '    // Factory owner can withdraw any ERC20 asset tokens from this contract\n', '    //\n', '    // This method is included in the case where this contract receives\n', '    // the wrong tokens\n', '    //\n', '    // The OwnerWithdrewERC20Token() event is logged with the following\n', '    // parameter:\n', '    //   tokenAddress  is the address of the tokens withdrawn by the maker\n', '    //   tokens        is the number of tokens withdrawn by the maker\n', '    //\n', '    function ownerWithdrawERC20Token(address tokenAddress, uint256 tokens) onlyOwner returns (bool ok) {\n', '        OwnerWithdrewERC20Token(tokenAddress, tokens);\n', '        return ERC20(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '    // Prevents accidental sending of ether to the factory\n', '    function () {\n', '        throw;\n', '    }\n', '}\n', '\n', 'contract FixedSupplyToken is ERC20 {\n', '    string public name;\n', '    string public symbol;\n', '    uint256 _totalSupply;\n', '    uint8 public decimals;\n', '\n', '    // Balances for each account\n', '    mapping(address => uint256) balances;\n', '\n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    // Constructor\n', '    function FixedSupplyToken(\n', '      string _name,\n', '      string _symbol,\n', '      uint256 _supply,\n', '      uint8 _decimals\n', '    ) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        _totalSupply = _supply;\n', '        decimals = _decimals;\n', '        balances[msg.sender] = _totalSupply;\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256 totalSupply) {\n', '        totalSupply = _totalSupply;\n', '    }\n', '\n', '    // What is the balance of a particular account?\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    // Transfer the balance from owner&#39;s account to another account\n', '    function transfer(address _to, uint256 _amount) returns (bool success) {\n', '        if (balances[msg.sender] >= _amount\n', '            && _amount > 0\n', '            && balances[_to] + _amount > balances[_to]) {\n', '            balances[msg.sender] -= _amount;\n', '            balances[_to] += _amount;\n', '            Transfer(msg.sender, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '    // tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '    // fees in sub-currencies; the command should fail unless the _from account has\n', '    // deliberately authorized the sender of the message via some mechanism; we propose\n', '    // these standardized APIs for approval:\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _amount\n', '    ) returns (bool success) {\n', '        if (balances[_from] >= _amount\n', '            && allowed[_from][msg.sender] >= _amount\n', '            && _amount > 0\n', '            && balances[_to] + _amount > balances[_to]) {\n', '            balances[_from] -= _amount;\n', '            allowed[_from][msg.sender] -= _amount;\n', '            balances[_to] += _amount;\n', '            Transfer(_from, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    function approve(address _spender, uint256 _amount) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract TokenToken is FixedSupplyToken{\n', '  TokenTrader[] public tokenExchanges;\n', '  uint256[] public tokenRatios; // Measured in per 1e18, e.g.g 5e17 = 50%\n', '                                // TokenRatios MUST ADD TO 1 (1e18)\n', '  uint256 tokensBought = 0;\n', '\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '  /* This generates a public event on the blockchain that will notify clients */\n', '  //event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  /* Initializes contract with initial supply tokens to the creator of the contract */\n', '\n', '  function TokenToken(\n', '    string _name,\n', '    string _symbol,\n', '    uint256 _supply,\n', '    uint8 _decimals,\n', '    TokenTrader[] initialTokenExchanges,\n', '    uint256[] initialTokenRatios\n', '    ) FixedSupplyToken(\n', '      _name,\n', '      _symbol,\n', '      _supply,\n', '      _decimals\n', '    ) {\n', '    tokenExchanges = initialTokenExchanges;\n', '    tokenRatios = initialTokenRatios;\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner {\n', '      if (msg.sender != owner) throw;\n', '      _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '      OwnershipTransferred(owner, newOwner);\n', '      owner = newOwner;\n', '  }\n', '\n', '  function setPurchaseRatios (\n', '    TokenTrader[] newTokenExchanges,\n', '    uint256[] newTokenRatios\n', '  ) onlyOwner returns (bool success) {\n', '      // Should have a lot of assertions\n', '      // TODO: Assert newTokenRatios.length == tokenRatios.length\n', '      // TODO: Assert newTokenRatios add to 1\n', '      tokenExchanges = newTokenExchanges;\n', '      tokenRatios = newTokenRatios;\n', '      return true;\n', '  }\n', '\n', '  function buyPrice() constant returns (uint256 totalPrice) {\n', '    totalPrice = 0;\n', '    for (uint i = 0; i < tokenExchanges.length; ++i) {\n', '      totalPrice += tokenExchanges[i].buyPrice() * tokenRatios[i] / 1e18;\n', '    }\n', '    return totalPrice;\n', '  }\n', '\n', '  function sellPrice() constant returns (uint256 totalPrice) {\n', '    totalPrice = 0;\n', '    for (uint i = 0; i < tokenExchanges.length; ++i) {\n', '      totalPrice += tokenExchanges[i].sellPrice() * tokenRatios[i] / 1e18;\n', '    }\n', '    return totalPrice;\n', '  }\n', '\n', '  function () { // Sending ether to it buys coins automatically\n', '    buy();\n', '  }\n', '  function buy() payable returns (uint256 amount){        // Buy in ETH\n', '\n', '    amount = msg.value / buyPrice();\n', '    for (uint i = 0; i < tokenExchanges.length; ++i) {\n', '      TokenTrader tokenExchange = tokenExchanges[i];\n', '      tokenExchange.transfer(msg.value * tokenRatios[i] / 1e18);\n', '    }\n', '    tokensBought += amount;\n', '    balances[msg.sender] += amount;                   // adds the amount to buyer&#39;s balance\n', '    balances[this] -= amount;                         // subtracts amount from seller&#39;s balance\n', '    Transfer(this, msg.sender, amount);                // execute an event reflecting the change\n', '    return amount;                                     // ends function and returns\n', '  }\n', '\n', '  function sell(uint amount) returns (uint256 revenue){   // Sell in tokens\n', '    if (balances[msg.sender] < amount ) throw;        // checks if the sender has enough to sell\n', '    balances[this] += amount;                         // adds the amount to owner&#39;s balance\n', '    balances[msg.sender] -= amount;                   // subtracts the amount from seller&#39;s balance\n', '\n', '    uint256 subTokensToSell = 0;\n', '    revenue = 0;\n', '    for (uint i = 0; i < tokenExchanges.length; ++i) { // Unsafe code: what if the loop errors halfway?\n', '      TokenTrader tokenExchange = tokenExchanges[i];\n', '      subTokensToSell = ERC20(tokenExchange.asset()).balanceOf(this)*amount/tokensBought;\n', '\n', '      revenue += subTokensToSell * tokenExchange.sellPrice();\n', '      ERC20(tokenExchange.asset()).approve(address(tokenExchange), subTokensToSell); // Approve sale\n', '      tokenExchange.takerSellAsset(subTokensToSell); // Make Sale\n', '    }\n', '\n', '    tokensBought -= amount;\n', '    msg.sender.transfer(revenue);\n', '    Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\n', '    return revenue;                                // ends function and returns\n', '  }\n', '\n', '  function breakdown(uint256 amount) {   // Breakdown in tokens\n', '    if (balances[msg.sender] < amount ) throw;        // checks if the sender has enough to sell\n', '    balances[this] += amount;                         // adds the amount to owner&#39;s balance\n', '    balances[msg.sender] -= amount;                   // subtracts the amount from seller&#39;s balance\n', '\n', '    uint256 subTokensToSell = 0;\n', '    for (uint i = 0; i < tokenExchanges.length; ++i) { // Unsafe code: what if the loop errors halfway?\n', '      TokenTrader tokenExchange = tokenExchanges[i];\n', '      subTokensToSell = ERC20(tokenExchange.asset()).balanceOf(this)*amount/tokensBought;\n', '      ERC20(tokenExchange.asset()).transfer(msg.sender, subTokensToSell);\n', '    }\n', '\n', '    tokensBought -= amount;\n', '    Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\n', '  }\n', '\n', '  function rebalance(TokenTrader fromExchange, TokenTrader toExchange, uint256 fromPercent) onlyOwner {\n', '    uint256 subTokensToSell = ERC20(fromExchange.asset()).balanceOf(this) * fromPercent / 1e18;\n', '\n', '    uint256 revenue = subTokensToSell * fromExchange.sellPrice();\n', '    ERC20(fromExchange.asset()).approve(address(fromExchange), subTokensToSell); // Approve sale\n', '    fromExchange.takerSellAsset(subTokensToSell); // Make sale\n', '\n', '    toExchange.transfer(revenue); // Make purchase with new contract.\n', '  }\n', '\n', '  function kill() { if (msg.sender == owner) selfdestruct(owner); }\n', '}']
['pragma solidity ^0.4.11;\n', '\n', '// ------------------------------------------------------------------------\n', '// TokenTraderFactory\n', '//\n', '// Decentralised trustless ERC20-compliant token to ETH exchange contract\n', '// on the Ethereum blockchain.\n', '//\n', '// Note that this TokenTrader cannot be used with the Golem Network Token\n', '// directly as the token does not implement the ERC20\n', '// transferFrom(...), approve(...) and allowance(...) methods\n', '//\n', '// History:\n', '//   Jan 25 2017 - BPB Added makerTransferAsset(...) and\n', '//                     makerTransferEther(...)\n', '//   Feb 05 2017 - BPB Bug fix in the change calculation for the Unicorn\n', '//                     token with natural number 1\n', '//   Feb 08 2017 - BPB/JL Renamed etherValueOfTokensToSell to\n', '//                     amountOfTokensToSell in takerSellAsset(...) to\n', '//                     better describe the parameter\n', '//                     Added check in createTradeContract(...) to prevent\n', '//                     GNTs from being used with this contract. The asset\n', '//                     token will need to have an allowance(...) function.\n', '//\n', '// Enjoy. (c) JonnyLatte & BokkyPooBah 2017. The MIT licence.\n', '// ------------------------------------------------------------------------\n', '\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '    function totalSupply() constant returns (uint totalSupply);\n', '    function balanceOf(address _owner) constant returns (uint balance);\n', '    function transfer(address _to, uint _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '    function approve(address _spender, uint _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        if (msg.sender != owner) throw;\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrTokenTraderWithSameOwner {\n', '        if (msg.sender != owner && TokenTrader(msg.sender).owner() != owner) throw;\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '// contract can buy or sell tokens for ETH\n', '// prices are in amount of wei per batch of token units\n', '\n', 'contract TokenTrader is Owned {\n', '\n', '    address public asset;       // address of token\n', '    uint256 public buyPrice;    // contract buys lots of token at this price\n', '    uint256 public sellPrice;   // contract sells lots at this price\n', '    uint256 public units;       // lot size (token-wei)\n', '\n', '    bool public buysTokens;     // is contract buying\n', '    bool public sellsTokens;    // is contract selling\n', '\n', '    event ActivatedEvent(bool buys, bool sells);\n', '    event MakerDepositedEther(uint256 amount);\n', '    event MakerWithdrewAsset(uint256 tokens);\n', '    event MakerTransferredAsset(address toTokenTrader, uint256 tokens);\n', '    event MakerWithdrewERC20Token(address tokenAddress, uint256 tokens);\n', '    event MakerWithdrewEther(uint256 ethers);\n', '    event MakerTransferredEther(address toTokenTrader, uint256 ethers);\n', '    event TakerBoughtAsset(address indexed buyer, uint256 ethersSent,\n', '        uint256 ethersReturned, uint256 tokensBought);\n', '    event TakerSoldAsset(address indexed seller, uint256 amountOfTokensToSell,\n', '        uint256 tokensSold, uint256 etherValueOfTokensSold);\n', '\n', '    // Constructor - only to be called by the TokenTraderFactory contract\n', '    function TokenTrader (\n', '        address _asset,\n', '        uint256 _buyPrice,\n', '        uint256 _sellPrice,\n', '        uint256 _units,\n', '        bool    _buysTokens,\n', '        bool    _sellsTokens\n', '    ) {\n', '        asset       = _asset;\n', '        buyPrice    = _buyPrice;\n', '        sellPrice   = _sellPrice;\n', '        units       = _units;\n', '        buysTokens  = _buysTokens;\n', '        sellsTokens = _sellsTokens;\n', '        ActivatedEvent(buysTokens, sellsTokens);\n', '    }\n', '\n', "    // Maker can activate or deactivate this contract's buying and\n", '    // selling status\n', '    //\n', '    // The ActivatedEvent() event is logged with the following\n', '    // parameter:\n', '    //   buysTokens   this contract can buy asset tokens\n', '    //   sellsTokens  this contract can sell asset tokens\n', '    //\n', '    function activate (\n', '        bool _buysTokens,\n', '        bool _sellsTokens\n', '    ) onlyOwner {\n', '        buysTokens  = _buysTokens;\n', '        sellsTokens = _sellsTokens;\n', '        ActivatedEvent(buysTokens, sellsTokens);\n', '    }\n', '\n', '    // Maker can deposit ethers to this contract so this contract\n', '    // can buy asset tokens.\n', '    //\n', '    // Maker deposits asset tokens to this contract by calling the\n', "    // asset's transfer() method with the following parameters\n", '    //   _to     is the address of THIS contract\n', '    //   _value  is the number of asset tokens to be transferred\n', '    //\n', '    // Taker MUST NOT send tokens directly to this contract. Takers\n', '    // MUST use the takerSellAsset() method to sell asset tokens\n', '    // to this contract\n', '    //\n', '    // Maker can also transfer ethers from one TokenTrader contract\n', '    // to another TokenTrader contract, both owned by the Maker\n', '    //\n', '    // The MakerDepositedEther() event is logged with the following\n', '    // parameter:\n', '    //   ethers  is the number of ethers deposited by the maker\n', '    //\n', '    // This method was called deposit() in the old version\n', '    //\n', '    function makerDepositEther() payable onlyOwnerOrTokenTraderWithSameOwner {\n', '        MakerDepositedEther(msg.value);\n', '    }\n', '\n', '    // Maker can withdraw asset tokens from this contract, with the\n', '    // following parameter:\n', '    //   tokens  is the number of asset tokens to be withdrawn\n', '    //\n', '    // The MakerWithdrewAsset() event is logged with the following\n', '    // parameter:\n', '    //   tokens  is the number of tokens withdrawn by the maker\n', '    //\n', '    // This method was called withdrawAsset() in the old version\n', '    //\n', '    function makerWithdrawAsset(uint256 tokens) onlyOwner returns (bool ok) {\n', '        MakerWithdrewAsset(tokens);\n', '        return ERC20(asset).transfer(owner, tokens);\n', '    }\n', '\n', '    // Maker can transfer asset tokens from this contract to another\n', '    // TokenTrader contract, with the following parameter:\n', '    //   toTokenTrader  Another TokenTrader contract owned by the\n', '    //                  same owner and with the same asset\n', '    //   tokens         is the number of asset tokens to be moved\n', '    //\n', '    // The MakerTransferredAsset() event is logged with the following\n', '    // parameters:\n', '    //   toTokenTrader  The other TokenTrader contract owned by\n', '    //                  the same owner and with the same asset\n', '    //   tokens         is the number of tokens transferred\n', '    //\n', '    // The asset Transfer() event is also logged from this contract\n', '    // to the other contract\n', '    //\n', '    function makerTransferAsset(\n', '        TokenTrader toTokenTrader,\n', '        uint256 tokens\n', '    ) onlyOwner returns (bool ok) {\n', '        if (owner != toTokenTrader.owner() || asset != toTokenTrader.asset()) {\n', '            throw;\n', '        }\n', '        MakerTransferredAsset(toTokenTrader, tokens);\n', '        return ERC20(asset).transfer(toTokenTrader, tokens);\n', '    }\n', '\n', '    // Maker can withdraw any ERC20 asset tokens from this contract\n', '    //\n', '    // This method is included in the case where this contract receives\n', '    // the wrong tokens\n', '    //\n', '    // The MakerWithdrewERC20Token() event is logged with the following\n', '    // parameter:\n', '    //   tokenAddress  is the address of the tokens withdrawn by the maker\n', '    //   tokens        is the number of tokens withdrawn by the maker\n', '    //\n', '    // This method was called withdrawToken() in the old version\n', '    //\n', '    function makerWithdrawERC20Token(\n', '        address tokenAddress,\n', '        uint256 tokens\n', '    ) onlyOwner returns (bool ok) {\n', '        MakerWithdrewERC20Token(tokenAddress, tokens);\n', '        return ERC20(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '    // Maker can withdraw ethers from this contract\n', '    //\n', '    // The MakerWithdrewEther() event is logged with the following parameter\n', '    //   ethers  is the number of ethers withdrawn by the maker\n', '    //\n', '    // This method was called withdraw() in the old version\n', '    //\n', '    function makerWithdrawEther(uint256 ethers) onlyOwner returns (bool ok) {\n', '        if (this.balance >= ethers) {\n', '            MakerWithdrewEther(ethers);\n', '            return owner.send(ethers);\n', '        }\n', '    }\n', '\n', '    // Maker can transfer ethers from this contract to another TokenTrader\n', '    // contract, with the following parameters:\n', '    //   toTokenTrader  Another TokenTrader contract owned by the\n', '    //                  same owner and with the same asset\n', '    //   ethers         is the number of ethers to be moved\n', '    //\n', '    // The MakerTransferredEther() event is logged with the following parameter\n', '    //   toTokenTrader  The other TokenTrader contract owned by the\n', '    //                  same owner and with the same asset\n', '    //   ethers         is the number of ethers transferred\n', '    //\n', '    // The MakerDepositedEther() event is logged on the other\n', '    // contract with the following parameter:\n', '    //   ethers  is the number of ethers deposited by the maker\n', '    //\n', '    function makerTransferEther(\n', '        TokenTrader toTokenTrader,\n', '        uint256 ethers\n', '    ) onlyOwner returns (bool ok) {\n', '        if (owner != toTokenTrader.owner() || asset != toTokenTrader.asset()) {\n', '            throw;\n', '        }\n', '        if (this.balance >= ethers) {\n', '            MakerTransferredEther(toTokenTrader, ethers);\n', '            toTokenTrader.makerDepositEther.value(ethers)();\n', '        }\n', '    }\n', '\n', '    // Taker buys asset tokens by sending ethers\n', '    //\n', '    // The TakerBoughtAsset() event is logged with the following parameters\n', "    //   buyer           is the buyer's address\n", '    //   ethersSent      is the number of ethers sent by the buyer\n', '    //   ethersReturned  is the number of ethers sent back to the buyer as\n', '    //                   change\n', '    //   tokensBought    is the number of asset tokens sent to the buyer\n', '    //\n', '    // This method was called buy() in the old version\n', '    //\n', '    function takerBuyAsset() payable {\n', '        if (sellsTokens || msg.sender == owner) {\n', '            // Note that sellPrice has already been validated as > 0\n', '            uint order    = msg.value / sellPrice;\n', '            // Note that units has already been validated as > 0\n', '            uint can_sell = ERC20(asset).balanceOf(address(this)) / units;\n', '            uint256 change = 0;\n', '            if (msg.value > (can_sell * sellPrice)) {\n', '                change  = msg.value - (can_sell * sellPrice);\n', '                order = can_sell;\n', '            }\n', '            if (change > 0) {\n', '                if (!msg.sender.send(change)) throw;\n', '            }\n', '            if (order > 0) {\n', '                if (!ERC20(asset).transfer(msg.sender, order * units)) throw;\n', '            }\n', '            TakerBoughtAsset(msg.sender, msg.value, change, order * units);\n', '        }\n', '        // Return user funds if the contract is not selling\n', '        else if (!msg.sender.send(msg.value)) throw;\n', '    }\n', '\n', '    // Taker sells asset tokens for ethers by:\n', "    // 1. Calling the asset's approve() method with the following parameters\n", '    //    _spender            is the address of this contract\n', '    //    _value              is the number of tokens to be sold\n', '    // 2. Calling this takerSellAsset() method with the following parameter\n', '    //    etherValueOfTokens  is the ether value of the asset tokens to be sold\n', '    //                        by the taker\n', '    //\n', '    // The TakerSoldAsset() event is logged with the following parameters\n', "    //   seller                  is the seller's address\n", '    //   amountOfTokensToSell    is the amount of the asset tokens being\n', '    //                           sold by the taker\n', '    //   tokensSold              is the number of the asset tokens sold\n', '    //   etherValueOfTokensSold  is the ether value of the asset tokens sold\n', '    //\n', '    // This method was called sell() in the old version\n', '    //\n', '    function takerSellAsset(uint256 amountOfTokensToSell) {\n', '        if (buysTokens || msg.sender == owner) {\n', '            // Maximum number of token the contract can buy\n', '            // Note that buyPrice has already been validated as > 0\n', '            uint256 can_buy = this.balance / buyPrice;\n', '            // Token lots available\n', '            // Note that units has already been validated as > 0\n', '            uint256 order = amountOfTokensToSell / units;\n', '            // Adjust order for funds available\n', '            if (order > can_buy) order = can_buy;\n', '            if (order > 0) {\n', '                // Extract user tokens\n', '                if (!ERC20(asset).transferFrom(msg.sender, address(this), order * units)) throw;\n', '                // Pay user\n', '                if (!msg.sender.send(order * buyPrice)) throw;\n', '            }\n', '            TakerSoldAsset(msg.sender, amountOfTokensToSell, order * units, order * buyPrice);\n', '        }\n', '    }\n', '\n', '    // Taker buys tokens by sending ethers\n', '    function () payable {\n', '        takerBuyAsset();\n', '    }\n', '}\n', '\n', '// This contract deploys TokenTrader contracts and logs the event\n', 'contract TokenTraderFactory is Owned {\n', '\n', '    event TradeListing(address indexed ownerAddress, address indexed tokenTraderAddress,\n', '        address indexed asset, uint256 buyPrice, uint256 sellPrice, uint256 units,\n', '        bool buysTokens, bool sellsTokens);\n', '    event OwnerWithdrewERC20Token(address indexed tokenAddress, uint256 tokens);\n', '\n', '    mapping(address => bool) _verify;\n', '\n', '    // Anyone can call this method to verify the settings of a\n', '    // TokenTrader contract. The parameters are:\n', '    //   tradeContract  is the address of a TokenTrader contract\n', '    //\n', '    // Return values:\n', '    //   valid        did this TokenTraderFactory create the TokenTrader contract?\n', '    //   owner        is the owner of the TokenTrader contract\n', '    //   asset        is the ERC20 asset address\n', '    //   buyPrice     is the buy price in ethers per `units` of asset tokens\n', '    //   sellPrice    is the sell price in ethers per `units` of asset tokens\n', '    //   units        is the number of units of asset tokens\n', '    //   buysTokens   is the TokenTrader contract buying tokens?\n', '    //   sellsTokens  is the TokenTrader contract selling tokens?\n', '    //\n', '    function verify(address tradeContract) constant returns (\n', '        bool    valid,\n', '        address owner,\n', '        address asset,\n', '        uint256 buyPrice,\n', '        uint256 sellPrice,\n', '        uint256 units,\n', '        bool    buysTokens,\n', '        bool    sellsTokens\n', '    ) {\n', '        valid = _verify[tradeContract];\n', '        if (valid) {\n', '            TokenTrader t = TokenTrader(tradeContract);\n', '            owner         = t.owner();\n', '            asset         = t.asset();\n', '            buyPrice      = t.buyPrice();\n', '            sellPrice     = t.sellPrice();\n', '            units         = t.units();\n', '            buysTokens    = t.buysTokens();\n', '            sellsTokens   = t.sellsTokens();\n', '        }\n', '    }\n', '\n', '    // Maker can call this method to create a new TokenTrader contract\n', '    // with the maker being the owner of this new contract\n', '    //\n', '    // Parameters:\n', '    //   asset        is the ERC20 asset address\n', '    //   buyPrice     is the buy price in ethers per `units` of asset tokens\n', '    //   sellPrice    is the sell price in ethers per `units` of asset tokens\n', '    //   units        is the number of units of asset tokens\n', '    //   buysTokens   is the TokenTrader contract buying tokens?\n', '    //   sellsTokens  is the TokenTrader contract selling tokens?\n', '    //\n', '    // For example, listing a TokenTrader contract on the REP Augur token where\n', '    // the contract will buy REP tokens at a rate of 39000/100000 = 0.39 ETH\n', '    // per REP token and sell REP tokens at a rate of 41000/100000 = 0.41 ETH\n', '    // per REP token:\n', '    //   asset        0x48c80f1f4d53d5951e5d5438b54cba84f29f32a5\n', '    //   buyPrice     39000\n', '    //   sellPrice    41000\n', '    //   units        100000\n', '    //   buysTokens   true\n', '    //   sellsTokens  true\n', '    //\n', '    // The TradeListing() event is logged with the following parameters\n', "    //   ownerAddress        is the Maker's address\n", '    //   tokenTraderAddress  is the address of the newly created TokenTrader contract\n', '    //   asset               is the ERC20 asset address\n', '    //   buyPrice            is the buy price in ethers per `units` of asset tokens\n', '    //   sellPrice           is the sell price in ethers per `units` of asset tokens\n', '    //   unit                is the number of units of asset tokens\n', '    //   buysTokens          is the TokenTrader contract buying tokens?\n', '    //   sellsTokens         is the TokenTrader contract selling tokens?\n', '    //\n', '    function createTradeContract(\n', '        address asset,\n', '        uint256 buyPrice,\n', '        uint256 sellPrice,\n', '        uint256 units,\n', '        bool    buysTokens,\n', '        bool    sellsTokens\n', '    ) returns (address trader) {\n', '        // Cannot have invalid asset\n', '        if (asset == 0x0) throw;\n', '        // Check for ERC20 allowance function\n', '        // This will throw an error if the allowance function\n', '        // is undefined to prevent GNTs from being used\n', '        // with this factory\n', '        uint256 allowance = ERC20(asset).allowance(msg.sender, this);\n', '        // Cannot set zero or negative price\n', '        if (buyPrice <= 0 || sellPrice <= 0) throw;\n', '        // Must make profit on spread\n', '        if (buyPrice >= sellPrice) throw;\n', '        // Cannot buy or sell zero or negative units\n', '        if (units <= 0) throw;\n', '\n', '        trader = new TokenTrader(\n', '            asset,\n', '            buyPrice,\n', '            sellPrice,\n', '            units,\n', '            buysTokens,\n', '            sellsTokens);\n', '        // Record that this factory created the trader\n', '        _verify[trader] = true;\n', '        // Set the owner to whoever called the function\n', '        TokenTrader(trader).transferOwnership(msg.sender);\n', '        TradeListing(msg.sender, trader, asset, buyPrice, sellPrice, units, buysTokens, sellsTokens);\n', '    }\n', '\n', '    // Factory owner can withdraw any ERC20 asset tokens from this contract\n', '    //\n', '    // This method is included in the case where this contract receives\n', '    // the wrong tokens\n', '    //\n', '    // The OwnerWithdrewERC20Token() event is logged with the following\n', '    // parameter:\n', '    //   tokenAddress  is the address of the tokens withdrawn by the maker\n', '    //   tokens        is the number of tokens withdrawn by the maker\n', '    //\n', '    function ownerWithdrawERC20Token(address tokenAddress, uint256 tokens) onlyOwner returns (bool ok) {\n', '        OwnerWithdrewERC20Token(tokenAddress, tokens);\n', '        return ERC20(tokenAddress).transfer(owner, tokens);\n', '    }\n', '\n', '    // Prevents accidental sending of ether to the factory\n', '    function () {\n', '        throw;\n', '    }\n', '}\n', '\n', 'contract FixedSupplyToken is ERC20 {\n', '    string public name;\n', '    string public symbol;\n', '    uint256 _totalSupply;\n', '    uint8 public decimals;\n', '\n', '    // Balances for each account\n', '    mapping(address => uint256) balances;\n', '\n', '    // Owner of account approves the transfer of an amount to another account\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    // Constructor\n', '    function FixedSupplyToken(\n', '      string _name,\n', '      string _symbol,\n', '      uint256 _supply,\n', '      uint8 _decimals\n', '    ) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        _totalSupply = _supply;\n', '        decimals = _decimals;\n', '        balances[msg.sender] = _totalSupply;\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256 totalSupply) {\n', '        totalSupply = _totalSupply;\n', '    }\n', '\n', '    // What is the balance of a particular account?\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', "    // Transfer the balance from owner's account to another account\n", '    function transfer(address _to, uint256 _amount) returns (bool success) {\n', '        if (balances[msg.sender] >= _amount\n', '            && _amount > 0\n', '            && balances[_to] + _amount > balances[_to]) {\n', '            balances[msg.sender] -= _amount;\n', '            balances[_to] += _amount;\n', '            Transfer(msg.sender, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Send _value amount of tokens from address _from to address _to\n', '    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '    // tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '    // fees in sub-currencies; the command should fail unless the _from account has\n', '    // deliberately authorized the sender of the message via some mechanism; we propose\n', '    // these standardized APIs for approval:\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _amount\n', '    ) returns (bool success) {\n', '        if (balances[_from] >= _amount\n', '            && allowed[_from][msg.sender] >= _amount\n', '            && _amount > 0\n', '            && balances[_to] + _amount > balances[_to]) {\n', '            balances[_from] -= _amount;\n', '            allowed[_from][msg.sender] -= _amount;\n', '            balances[_to] += _amount;\n', '            Transfer(_from, _to, _amount);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    function approve(address _spender, uint256 _amount) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}\n', '\n', 'contract TokenToken is FixedSupplyToken{\n', '  TokenTrader[] public tokenExchanges;\n', '  uint256[] public tokenRatios; // Measured in per 1e18, e.g.g 5e17 = 50%\n', '                                // TokenRatios MUST ADD TO 1 (1e18)\n', '  uint256 tokensBought = 0;\n', '\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '  /* This generates a public event on the blockchain that will notify clients */\n', '  //event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  /* Initializes contract with initial supply tokens to the creator of the contract */\n', '\n', '  function TokenToken(\n', '    string _name,\n', '    string _symbol,\n', '    uint256 _supply,\n', '    uint8 _decimals,\n', '    TokenTrader[] initialTokenExchanges,\n', '    uint256[] initialTokenRatios\n', '    ) FixedSupplyToken(\n', '      _name,\n', '      _symbol,\n', '      _supply,\n', '      _decimals\n', '    ) {\n', '    tokenExchanges = initialTokenExchanges;\n', '    tokenRatios = initialTokenRatios;\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner {\n', '      if (msg.sender != owner) throw;\n', '      _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '      OwnershipTransferred(owner, newOwner);\n', '      owner = newOwner;\n', '  }\n', '\n', '  function setPurchaseRatios (\n', '    TokenTrader[] newTokenExchanges,\n', '    uint256[] newTokenRatios\n', '  ) onlyOwner returns (bool success) {\n', '      // Should have a lot of assertions\n', '      // TODO: Assert newTokenRatios.length == tokenRatios.length\n', '      // TODO: Assert newTokenRatios add to 1\n', '      tokenExchanges = newTokenExchanges;\n', '      tokenRatios = newTokenRatios;\n', '      return true;\n', '  }\n', '\n', '  function buyPrice() constant returns (uint256 totalPrice) {\n', '    totalPrice = 0;\n', '    for (uint i = 0; i < tokenExchanges.length; ++i) {\n', '      totalPrice += tokenExchanges[i].buyPrice() * tokenRatios[i] / 1e18;\n', '    }\n', '    return totalPrice;\n', '  }\n', '\n', '  function sellPrice() constant returns (uint256 totalPrice) {\n', '    totalPrice = 0;\n', '    for (uint i = 0; i < tokenExchanges.length; ++i) {\n', '      totalPrice += tokenExchanges[i].sellPrice() * tokenRatios[i] / 1e18;\n', '    }\n', '    return totalPrice;\n', '  }\n', '\n', '  function () { // Sending ether to it buys coins automatically\n', '    buy();\n', '  }\n', '  function buy() payable returns (uint256 amount){        // Buy in ETH\n', '\n', '    amount = msg.value / buyPrice();\n', '    for (uint i = 0; i < tokenExchanges.length; ++i) {\n', '      TokenTrader tokenExchange = tokenExchanges[i];\n', '      tokenExchange.transfer(msg.value * tokenRatios[i] / 1e18);\n', '    }\n', '    tokensBought += amount;\n', "    balances[msg.sender] += amount;                   // adds the amount to buyer's balance\n", "    balances[this] -= amount;                         // subtracts amount from seller's balance\n", '    Transfer(this, msg.sender, amount);                // execute an event reflecting the change\n', '    return amount;                                     // ends function and returns\n', '  }\n', '\n', '  function sell(uint amount) returns (uint256 revenue){   // Sell in tokens\n', '    if (balances[msg.sender] < amount ) throw;        // checks if the sender has enough to sell\n', "    balances[this] += amount;                         // adds the amount to owner's balance\n", "    balances[msg.sender] -= amount;                   // subtracts the amount from seller's balance\n", '\n', '    uint256 subTokensToSell = 0;\n', '    revenue = 0;\n', '    for (uint i = 0; i < tokenExchanges.length; ++i) { // Unsafe code: what if the loop errors halfway?\n', '      TokenTrader tokenExchange = tokenExchanges[i];\n', '      subTokensToSell = ERC20(tokenExchange.asset()).balanceOf(this)*amount/tokensBought;\n', '\n', '      revenue += subTokensToSell * tokenExchange.sellPrice();\n', '      ERC20(tokenExchange.asset()).approve(address(tokenExchange), subTokensToSell); // Approve sale\n', '      tokenExchange.takerSellAsset(subTokensToSell); // Make Sale\n', '    }\n', '\n', '    tokensBought -= amount;\n', '    msg.sender.transfer(revenue);\n', '    Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\n', '    return revenue;                                // ends function and returns\n', '  }\n', '\n', '  function breakdown(uint256 amount) {   // Breakdown in tokens\n', '    if (balances[msg.sender] < amount ) throw;        // checks if the sender has enough to sell\n', "    balances[this] += amount;                         // adds the amount to owner's balance\n", "    balances[msg.sender] -= amount;                   // subtracts the amount from seller's balance\n", '\n', '    uint256 subTokensToSell = 0;\n', '    for (uint i = 0; i < tokenExchanges.length; ++i) { // Unsafe code: what if the loop errors halfway?\n', '      TokenTrader tokenExchange = tokenExchanges[i];\n', '      subTokensToSell = ERC20(tokenExchange.asset()).balanceOf(this)*amount/tokensBought;\n', '      ERC20(tokenExchange.asset()).transfer(msg.sender, subTokensToSell);\n', '    }\n', '\n', '    tokensBought -= amount;\n', '    Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\n', '  }\n', '\n', '  function rebalance(TokenTrader fromExchange, TokenTrader toExchange, uint256 fromPercent) onlyOwner {\n', '    uint256 subTokensToSell = ERC20(fromExchange.asset()).balanceOf(this) * fromPercent / 1e18;\n', '\n', '    uint256 revenue = subTokensToSell * fromExchange.sellPrice();\n', '    ERC20(fromExchange.asset()).approve(address(fromExchange), subTokensToSell); // Approve sale\n', '    fromExchange.takerSellAsset(subTokensToSell); // Make sale\n', '\n', '    toExchange.transfer(revenue); // Make purchase with new contract.\n', '  }\n', '\n', '  function kill() { if (msg.sender == owner) selfdestruct(owner); }\n', '}']
