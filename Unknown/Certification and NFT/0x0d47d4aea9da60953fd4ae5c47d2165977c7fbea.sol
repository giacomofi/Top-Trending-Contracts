['/// @title The main smart contract for Etherprises LLC, Delaware, U.S. (c)2017 Etherprises LLC\n', '/// @author Ville Sundell <contact@etherprises.com>\n', '// This source code is available at https://etherscan.io/address/0x0d47d4aea9da60953fd4ae5c47d2165977c7fbea\n', '// This code (and only this source code, not storage data nor other information/data) is released under CC-0.\n', '// More source regarding Etherprises LLC can be found at: https://github.com/Etherprises\n', '// The legal prose amending the contract between your series and Etherprises LLC is defined in prose() as a string array\n', '\n', 'pragma solidity ^0.4.9;\n', '\n', '//This is the main contract, this handles series creation and renewal:\n', 'contract EtherprisesLLC {\n', '    //This factory will create the series smart contract:\n', '    address public seriesFactory;\n', '    //This is the address of the only member or the series organization:\n', '    address public generalManager;\n', '    //List of series addresses, this is the main index:\n', '    address[] public series;\n', '    //Listing amendments as a legal prose, starting from 0:\n', '    string[] public prose;\n', "    //This map makes routing funds to user's latest series easy and fast:\n", '    mapping (address => address) public latestSeriesForUser;\n', "    //Series' expiring date is specified here as UNIX timestamp:\n", '    mapping (address => uint) public expiresAt;\n', "    //This maps series' name to an address\n", '    mapping (bytes32 => address) public seriesByName;\n', "    //This maps series' address to a name\n", '    mapping (address => bytes32) public seriesByAddress;\n', '    \n', '    //Events for external monitoring:\n', '    event AmendmentAdded (string newAmendment);\n', '    event FeePaid (address which);\n', '    event ManagerSet(address newManager);\n', '    event FactorySet(address newFactory);\n', '    event DepositMade(address where, uint amount);\n', '    event SeriesCreated(address addr, uint id);\n', '    \n', '    /// @dev This is the initialization function, here we just mark\n', '    /// ourselves as the General Manager for this series organization.\n', '    function EtherprisesLLC() {\n', '        generalManager = msg.sender;\n', '    }\n', '    \n', '    /// @dev This modifier is used to check if the user is the GM.\n', '    modifier ifGeneralManager {\n', '        if (msg.sender != generalManager)\n', '            throw;\n', '\n', '        _;\n', '    }\n', '    \n', '    /// @dev This modifier is used to check is the caller a series.\n', '    modifier ifSeries {\n', '        if (expiresAt[msg.sender] == 0)\n', '            throw;\n', '\n', '        _;\n', '    }\n', '    \n', '    /// @dev Withdrawal happens here from Etherprises LLC to the GM.\n', '    /// For bookkeeping and tax reasons we only want GM to withdraw.\n', '    function withdraw() ifGeneralManager {\n', '        generalManager.send(this.balance);\n', '    }\n', '    \n', '    /// @dev This checks if the series is expired. This is meant to be\n', '    /// called inside the series, and terminate the series if expired.\n', '    /// @param addr Address of the series we want to check\n', '    /// @return TRUE if series is expired, FALSE otherwise\n', '    function isExpired(address addr) constant returns (bool) {\n', '        if (expiresAt[addr] > now)\n', '            return false;\n', '        else\n', '            return true;\n', '    }\n', '    \n', '    /// @dev Amending rules of the organization, only those rules which\n', '    /// were present upon creation of the Series, apply to the Series.\n', '    /// @param newAmendment String containing new amendment. Remember to\n', '    /// prefix it with the date\n', '    function addAmendment(string newAmendment) ifGeneralManager {\n', '        // Only GM can amend the rules.\n', '        // Series obey only the rules which are set when series is created\n', '        prose.push(newAmendment);\n', '        \n', '        AmendmentAdded(newAmendment);\n', '    }\n', '    \n', '    /// @dev This function pays the yearly fee of 1 ETH.\n', '    /// @return Boolean TRUE, if everything was successful\n', '    function payFee() ifSeries payable returns (bool) {\n', '        // Receiving fee of one ETH here\n', '        if (msg.value != 1 ether)\n', '            throw;\n', '            \n', '        expiresAt[msg.sender] += 1 years;\n', '        \n', '        FeePaid(msg.sender);\n', '        return true;\n', '    }\n', '    \n', '    /// @dev Sets the general manager for the main organization.\n', '    /// There is just one member for Etherprises LLC, which is the GM.\n', '    /// @param newManger Address of the new manager\n', '    function setManager(address newManger) ifGeneralManager {\n', '        generalManager = newManger;\n', '        \n', '        ManagerSet(newManger);\n', '    }\n', '    \n', '    /// @dev This sets the factory proxy contract, which uses the factory.\n', '    /// @param newFactory Address of the new factory proxy\n', '    function setFactory(address newFactory) ifGeneralManager {\n', '        seriesFactory = newFactory;\n', '        \n', '        FactorySet(newFactory);\n', '    }\n', '    \n', '    /// @dev This creates a new series, called also from the fallback\n', '    /// with default values.\n', '    /// @notice This will create new series. Specify the name here: \n', '    /// This is the only place to define a name, the name is immutable.\n', '    /// Please note, that the name must start with an alpha character\n', '    /// (despite otherwise being UTF-8).\n', '    /// Throws an exception if the name does not technically pass the tests.\n', '    /// @param name Name of the series, must start with A-Z, and for the\n', '    /// hash table the search key will exclude all other characters\n', '    /// except A-Z. Full Unicode is supported, though\n', '    /// @param shares Amount of shares, by default this is immutable\n', '    /// @param industry Setting industry may have legal implications,\n', '    /// i.e taxation\n', '    /// @param symbol Symbol of the traded token\n', '    /// @return seriesAddress Address of the newly created series contract\n', '    /// @return seriesId Internal incremental ID number for the series\n', '    function createSeries(\n', '        bytes name,\n', '        uint shares,\n', '        string industry,\n', '        string symbol,\n', '        address extraContract\n', '    ) payable returns (\n', '        address seriesAddress,\n', '        uint seriesId\n', '    ) {\n', '        seriesId = series.length;\n', '        \n', '        var(latestAddress, latestName) = SeriesFactory(seriesFactory).createSeries.value(msg.value)(seriesId, name, shares, industry, symbol, msg.sender, extraContract);\n', '        if (latestAddress == 0)\n', '            throw;\n', '\n', '        if (latestName > 0)\n', '            if (seriesByName[latestName] == 0)\n', '                seriesByName[latestName] = latestAddress;\n', '            else\n', '                throw;\n', '\n', '        series.push(latestAddress);\n', '        expiresAt[latestAddress] = now + 1 years;\n', '        latestSeriesForUser[msg.sender] = latestAddress;\n', '        seriesByAddress[latestAddress] = latestName;\n', '        \n', '        SeriesCreated(latestAddress, seriesId);\n', '        return (latestAddress, seriesId);\n', '    }\n', '    \n', '    /// @dev This is here for Registrar ABI support.\n', '    /// @param _name Name of the series we want to search, please note\n', '    /// this is only the search key and not full name\n', '    /// @return Address of the series we want to get\n', '    function addr(bytes32 _name) constant returns(address o_address) {\n', '        return seriesByName[_name];\n', '    }\n', '    \n', '    /// @dev This is here for Registrar ABI support: return the search key\n', '    /// for a contract.\n', '    /// @param _owner Name of the series we want to search, please note\n', '    /// this is only the search key and not full name\n', '    /// @return Name of the series we want to get\n', '    function name(address _owner) constant returns(bytes32 o_name){\n', '        return seriesByAddress[_owner];\n', '    }\n', '    \n', '    /// @dev Here the fallback function either creates a new series,\n', '    /// or transfers funds to existing one.\n', '    function () payable {\n', '        if (msg.data.length > 0) {\n', '            createSeries(msg.data, 0, "", "", 0x0);\n', '        } else if (latestSeriesForUser[msg.sender] != 0) {\n', '            //This is important to implement as call so we can forward gas\n', '            if (latestSeriesForUser[msg.sender].call.value(msg.value)())\n', '                DepositMade(latestSeriesForUser[msg.sender], msg.value);\n', '        } else {\n', '            createSeries("", 0, "", "", 0x0);\n', '        }\n', '    }\n', '}\n', '\n', '//This is a placeholder contract: In real life the main contract invokes\n', '//a proxy, which in turn invokes the actual SeriesFactory\n', '//The main contract for Etherprises LLC is above this one.\n', 'contract SeriesFactory {\n', '    address public seriesFactory;\n', '    address public owner;\n', '\n', '    function createSeries (\n', '        uint seriesId,\n', '        bytes name,\n', '        uint shares,\n', '        string industry,\n', '        string symbol,\n', '        address manager,\n', '        address extraContract\n', '    ) payable returns (\n', '        address addr,\n', '        bytes32 newName\n', '    ) {\n', '        address newSeries;\n', '        bytes32 _newName;\n', '\n', '        return (newSeries, _newName);\n', '    }\n', '}']