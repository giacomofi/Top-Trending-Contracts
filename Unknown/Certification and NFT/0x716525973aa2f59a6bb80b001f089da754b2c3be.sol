['pragma solidity ^0.4.13;\n', '\n', '/*\n', '\n', 'Lottery\n', '========================\n', '\n', 'Allows users to participate in a game-theoretically sound lottery.\n', 'Author: /u/Cintix\n', '\n', '*/\n', '\n', 'contract Lottery {\n', '  // The Ticket struct encodes an address&#39; range of winning numbers.\n', '  struct Ticket {\n', '    // Offset from 0 of the Ticket&#39;s range of winning numbers.\n', '    uint128 offset;\n', '    // The value of the Ticket in Wei and the size of the range of winning numbers.\n', '    uint128 value;\n', '  }\n', '  // Store the Ticket corresponding to each user&#39;s address.\n', '  mapping (address => Ticket) public tickets;\n', '  // Store the commited hash of each host.\n', '  mapping (address => bytes32) public commits;\n', '  // Store the number of hosts securing the lottery&#39;s RNG.\n', '  uint256 public num_hosts;\n', '  // Store the number of hosts that have revealed their secret random number.\n', '  uint256 public num_hosts_revealed;\n', '  // Store the host-generated random number that determines the lottery winner.\n', '  uint256 public rng;\n', '  // Boolean indicating whether the lottery has been cancelled.\n', '  bool public cancelled;\n', '  // Store total ETH spent by users on tickets.\n', '  uint256 public total_user_eth;\n', '  // Maximum total ETH users may spend on tickets.\n', '  uint256 public total_user_eth_cap = 100 ether;\n', '  // Cut of the winnings used to incentivize host participation.\n', '  uint256 public host_percentage = 10;\n', '  // Store end time of the ticket buying phase.\n', '  uint256 public buy_end_time = 1503829813;\n', '  // Store end time of the host commit phase.\n', '  uint256 public commit_end_time = buy_end_time + 1 days;\n', '  // Store end time of the host reveal phase.\n', '  uint256 public reveal_end_time = commit_end_time + 1 days;\n', '  \n', '  // Cancel the lottery if the host quorum isn&#39;t met or a host failed to reveal in time.\n', '  function cancel_lottery() {\n', '    // Only allow canceling the lottery after the commit phase has ended.\n', '    require(now > commit_end_time);\n', '    // Determine whether there are enough hosts for trustless RNG.\n', '    bool quorum_met = num_hosts >= 2;\n', '    // Determine whether all hosts have revealed their secret random numbers.\n', '    bool all_hosts_revealed = num_hosts == num_hosts_revealed;\n', '    // Determine whether the reveal phase has ended.\n', '    bool reveal_phase_ended = now > reveal_end_time;\n', '    // Only allow canceling the lottery if the quorum hasn&#39;t been met or not all hosts revealed.\n', '    require(!quorum_met || (!all_hosts_revealed && reveal_phase_ended));\n', '    // Irreversibly cancel the lottery.\n', '    cancelled = true;\n', '  }\n', '  \n', '  // Adds a host to the lottery, increasing the security of the lottery&#39;s random number generation.\n', '  function host_lottery(bytes32 commit) payable {\n', '    // Hosts must guarantee their hashed secret random number up to the value of the lottery.\n', '    require(msg.value == total_user_eth);\n', '    // Only allow new hosts to join during the lottery&#39;s commit phase.\n', '    require((now > buy_end_time) && (now <= commit_end_time));\n', '    // Sanity check hashed secret and only allow each host to join once.\n', '    require((commit != 0) && (commits[msg.sender] == 0));\n', '    // Store the host&#39;s hashed secret random number.\n', '    commits[msg.sender] = commit;\n', '    // Increment the host counter to account for the new host.\n', '    num_hosts += 1;\n', '  }\n', '  \n', '  // Allows anyone to steal a host&#39;s committed ETH if their secret random number isn&#39;t random or isn&#39;t secret.\n', '  function steal_reveal(address host, uint256 secret_random_number) {\n', '    // Only allow stealing during the lottery&#39;s commit phase to prevent higher-gas-tx-sniping host reveals.\n', '    require((now > buy_end_time) && (now <= commit_end_time));\n', '    // Verify the secret random number matches the committed hash.\n', '    require(commits[host] == keccak256(secret_random_number));\n', '    // Irreversibly cancel the lottery, as rng is compromised.\n', '    cancelled = true;\n', '    // Update commitment prior to sending ETH to prevent recursive call.\n', '    commits[host] = 0;\n', '    // Send the thief the host&#39;s committed ETH.\n', '    msg.sender.transfer(total_user_eth);\n', '  }\n', '  \n', '  // Allow hosts to reveal their secret random number during the lottery&#39;s reveal phase.\n', '  function host_reveal(uint256 secret_random_number) {\n', '    // Only allow revealing during the lottery&#39;s reveal phase.\n', '    require((now > commit_end_time) && (now <= reveal_end_time));\n', '    // Verify the secret random number matches the committed hash.\n', '    require(commits[msg.sender] == keccak256(secret_random_number));\n', '    // Update commitment prior to sending ETH to prevent recursive call.\n', '    commits[msg.sender] = 0;\n', '    // Update random number by XORing with host&#39;s revealed secret random number.\n', '    rng ^= secret_random_number;\n', '    // Increment the counter of hosts that have revealed their secret number.\n', '    num_hosts_revealed += 1;\n', '    // Send the host back their committed ETH.\n', '    msg.sender.transfer(total_user_eth);\n', '  }\n', '  \n', '  // Allow hosts to claim their earnings from a successful lottery.\n', '  function host_claim_earnings(address host) {\n', '    // Only allow claims if the lottery hasn&#39;t been cancelled.\n', '    require(!cancelled);\n', '    // Only allow claims if there were enough hosts for trustless RNG.\n', '    require(num_hosts >= 2);\n', '    // Only allow claims if all hosts have revealed their secret random numbers.\n', '    require(num_hosts == num_hosts_revealed);\n', '    // Send the host their earnings (i.e. an even cut of 10% of ETH spent on tickets).\n', '    host.transfer(total_user_eth * host_percentage / (num_hosts * 100));\n', '  }\n', '  \n', '  // Allow anyone to send the winner their winnings.\n', '  function claim_winnings(address winner) {\n', '    // Only allow winning if the lottery hasn&#39;t been cancelled.\n', '    require(!cancelled);\n', '    // Only allow winning if there were enough hosts for trustless RNG.\n', '    require(num_hosts >= 2);\n', '    // Only allow winning if all hosts have revealed their secret random numbers.\n', '    require(num_hosts == num_hosts_revealed);\n', '    // Calculate the winning number.\n', '    uint256 winning_number = rng % total_user_eth;\n', '    // Require the winning number to fall within the winning Ticket&#39;s range of winning numbers.\n', '    require((winning_number >= tickets[winner].offset) && (winning_number < tickets[winner].offset + tickets[winner].value));\n', '    // Send the winner their winnings (i.e. 90% of ETH spent on tickets).\n', '    winner.transfer(total_user_eth * (100 - host_percentage) / 100);\n', '  }\n', '  \n', '  // Withdraw a user&#39;s ETH for them in the event the lottery is cancelled.\n', '  function withdraw(address user) {\n', '    // Only allow withdrawals if the lottery has been cancelled.\n', '    require(cancelled);\n', '    // Only allow withdrawals for users who have funds in the contract.\n', '    require(tickets[user].value != 0);\n', '    // Store the user&#39;s balance prior to withdrawal in a temporary variable.\n', '    uint256 eth_to_withdraw = tickets[user].value;\n', '    // Update the user&#39;s stored funds prior to transfer to prevent recursive call.\n', '    tickets[user].value = 0;\n', '    // Return the user&#39;s funds.  Throws on failure to prevent loss of funds.\n', '    user.transfer(eth_to_withdraw);\n', '  }\n', '  \n', '  // Default function, called when a user sends ETH to the contract.  Buys Tickets.\n', '  function () payable {\n', '    // Only allow Tickets to be purchased during the ticket buying phase.\n', '    require(now <= buy_end_time);\n', '    // Only allow one lottery Ticket per account.\n', '    require(tickets[msg.sender].value == 0);\n', '    // Set winning numbers offset to the first numbers not owned by anyone else.\n', '    tickets[msg.sender].offset = uint128(total_user_eth);\n', '    // Set the ticket value and range of winning numbers to the amount of ETH sent.\n', '    tickets[msg.sender].value = uint128(msg.value);\n', '    // Update the total amount of ETH spent on tickets.\n', '    total_user_eth += msg.value;\n', '    // Only allow tickets to be purchased up to the lottery&#39;s ETH cap.\n', '    require(total_user_eth <= total_user_eth_cap);\n', '  }\n', '}']